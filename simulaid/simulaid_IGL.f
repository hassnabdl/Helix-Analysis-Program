c     MAXPHI: maximum number of Delphi gridpoints
c             Also, MAXPHI^3 is the memory used for 2D-data - see below
c             the parameter definitions depending on MAXPHI
c     MAXREC: Maximum number of records to read (> maximum number of atoms)
c             Must be divisible by 20 !!!
c     MAXRSD: Maximum number of residues
c     MAXNEIG: Maximum number of neighbors of an atom in the neighbor list
c             (7+2*MAXNEIG)*MAXREC < MAXPHI*MAXPHI*MAXPHI
      parameter (MAXREC=200000,MAXRSD=70000,MAXNEIG=25)
      parameter (MAXREC10=10*MAXREC)
c     MAXBONDS: Maximum number of bonds (hydrogen, hydrophobic or salt bridge)
c     MAX2D: maximum number of frames for the 2-D RMSD map ; < MAXBONDS

c     MAXCV: maximum number of residues for the CV-based domain map
c            8*MAXCV+5*MAXCV*MAXCV < MAPXPHI*MAXPHI*MAXPHI
c     MAXRCORR: maximum number of residues for the residue correlation map
c            2*MAXRCORR*MAXRCORR+16*MAXRCORR < MAXPHI*MAXPHI*MAXPHI
c     MAXCONN: maximum number of residues for the residue distance map
c            3*MAXCONN*MAXCONN-11*MAXCONN < MAXPHI*MAXPHI*MAXPHI
c     The current parameters require over 612 Mb memory
      parameter (MAXPHI=400,MAX2D=5000,MAXCV=2000,MAXRCORR=3500)
      parameter (MAXBONDS=10000,MAXCONN=2900,MAXCONN10=10*MAXCONN)
c     Below is a smaller (464 Mb) system
c     parameter (MAXPHI=300,MAX2D=3500,MAXCV=2000,MAXRCORR=3500)
c     parameter (MAXBONDS=10000,MAXCONN=2900,MAXCONN10=10*MAXCONN)
c     Below is a larger (1.1Gb) system:
c     parameter (MAXPHI=640,MAX2D=10000,MAXRCORR=10000)
c     Below is an even larger (3.4Gb) system:
c     parameter (MAXPHI=930,MAX2D=20000,MAXRCORR=20000,MAXBONDS=20000)
c     To compile this large a system add -mcmodel=medium to the compilation
c     instruction
c     NOTE: keep all dimensions EVEN
c     IFILL1 - IFILL9: fillers for the different places /nnwork/ is used
      parameter (IFILL1=MAXPHI*MAXPHI*MAXPHI-(7+2*MAXNEIG)*MAXREC)
      parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
     -  (9*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
      parameter (IFILL3=MAXPHI*MAXPHI*MAXPHI-(8*MAXCV+5*MAXCV*MAXCV))
      parameter (IFILL4=MAXPHI*MAXPHI*MAXPHI-
     -  (2*MAXRCORR*MAXRCORR+17*MAXRCORR))
      parameter (IFILL5=(MAXNEIG+6)*MAXREC+IFILL1-44*MAXRSD)
      parameter (IFILL6=MAX2D*MAX2D-6*MAXBONDS)
      parameter (MAXCOL=36)
      parameter (IFILL7=MAXPHI*MAXPHI*MAXPHI-2*MAXCOL*MAXREC)
      parameter (IFILL8=MAXPHI*MAXPHI*MAXPHI-3*MAXCONN*MAXCONN
     -  -11*MAXCONN)
      parameter (IFILL9=MAXPHI*MAXPHI*MAXPHI-
     -  (2*MAXRCORR*MAXRCORR+5*MAXRCORR))
c
c     The workspace /nnwork/ is MAXPHI*MAXPHI*MAXPHI words long.
c     To increase any of these parameters, first increase MAXPHI and after
c     that increase the one you need in such a way that the corresponding
c     IFILL* remains non-negative
c
c     IMPORTANT: If a parameter value is changed, all occurrences have to be
c     changed!
c
c     nnwork in subroutine delphilabel, readmap, delphigrid, interpolate:
c     common /nnwork/ phimap(MAXPHI,MAXPHI,MAXPHI)
c     nnwork in subroutines rmsd plot2drmsd, findbestrep, rmsdcluster and
c     rmsdckp:
c     common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),ing(MAX2D,MAX2D),
c    -  ihbpair(2,MAXBONDS),a1(MAXBONDS),a2(MAXBONDS),fill(IFILL2)
c     nnwork in subroutine cvplot:
c     common /nnwork/ mx(MAXCV,MAXCV),rij(3,MAXCV,MAXCV),
c    -  dij(MAXCV,MAXCV),cvavfor(MAXCV),cvavback(MAXCV),cvav(MAXCV),
c    -  cvrow(MAXCV),cvcol(MAXCV),ca(3,MAXCV),ifill(IFILL3)
c     nnwork in subroutine residcorr and plotresidcorr:
c     real*8 trajcorr,cav1,cav2,cavs1,cavs2
c     common /nnwork/ trajcorr(MAXRCORR,MAXRCORR),cav1(3,MAXRCORR),
c    -  cav2(3,MAXRCORR),cavs1(MAXRCORR),cavs2(MAXRCORR),ifill(IFILL4)
c     nnwork in Ramachandran plot related subroutines
c     common /nnwork/ ineig(MAXNEIG,MAXREC),nneig(MAXREC),
c    -  nprossacc(6,6,MAXRSD),issprossacc(5,MAXRSD),
c    -  ixypross(2,MAXRSD),isspross(MAXRSD),ifill(IFILL5)
c     nnwork in subroutine sortbondlist
c     common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),ifill(IFILL6),
c    -  i1(MAXBONDS),i2(MAXBONDS),i3(MAXBONDS),
c    -  i4(MAXBONDS),newpair(2,MAXBONDS),
c    -  ihbpair(2,MAXBONDS),ihb_pair_res(3,MAXBONDS),ihbtores(MAXBONDS),
c    -  a1(MAXBONDS),a2(MAXBONDS),fill(IFILL2)
c     nnwork in summarize_amber related subroutines
c     common /nnwork/ data(30,MAXRSD,4),err(30,MAXRSD,4)
c     nnwork in rrconn subroutine
c     common /nnwork/ rij1(MAXCONN,MAXCONN),rij2(MAXCONN,MAXCONN),
c    -  rij3(MAXCONN,MAXCONN),xres(MAXCONN),yres(MAXCONN10),fill(IFILL8)
c
cDB      common /DEBUG/ cx0(3,10000),
cDB     -  cx1(3,10000),cx2(3,10000),cx3(3,10000),cx4(3,10000)
      parameter (MAXBRIDGEATOM=5000,MAXBRIDGETYPE=500,MAXBRIDGELEN=4)
      dimension ifchrg(MAXREC),ih(MAXREC),index(MAXREC),indexn(MAXREC),
     -  indexo(MAXREC),indexs(MAXREC),indexa(MAXREC),indexdel(MAXREC),
     -  indexsup(MAXREC),isegno(MAXREC),iatnum(MAXREC),mmtype(MAXREC),
     -  iresno(MAXREC),ifres(MAXRSD),ilres(MAXRSD),ixresno(MAXRSD),
     -  ixsegno(MAXRSD),irescount1(MAXRSD),irescount2(MAXRSD),
     -  irescount3(MAXRSD),listrefres(MAXRSD),listnegres(MAXRSD),
     -  ixres(MAXREC),ifgtyp(MAXREC),nhbneig(MAXREC),ifree(MAXREC),
     -  isc(MAXREC),molresflag(MAXRSD),indexov(MAXREC),
     -  indexrmsd(MAXREC),itemp1(MAXREC),itemp2(MAXREC),
     -  itemp3(MAXREC),itemp4(MAXREC),itemp5(MAXREC),
     -  idistdssp(9,MAXRSD),rprox(MAXREC),cv(MAXREC),atw(MAXREC),
     -  froccin(MAXREC),charge(MAXREC),temp(MAXREC),
     -  nhbdist(MAXBONDS)
c     iresno(iat): residue # read for atom iat (same # can occure repeatedly)
c     ixresno(ires): residue number read for the ires-th residue
c     ixsegno(ires): segment number read for the ires-th residue
c     ixres(iat): residue sequence number for atom iat
      dimension ixclst(MAX2D),value(MAX2D),ifa_s(MAX2D),ila_s(MAX2D),
     -  irepav(MAX2D),irepmx(MAX2D),irepeng(MAX2D),irepkm(MAX2D),
     -  nclstmem(MAX2D),iorig(MAX2D),iwt(MAX2D)
      character*4 namin(MAXREC),namout(MAXREC),resin(MAXREC),
     -  resout(MAXREC)
      dimension c(3,MAXREC10),co(3,MAXREC10),c1(3,MAXREC),c2(3,MAXREC)
      common /nnwork/ ineig(MAXNEIG,MAXREC),nneig(MAXREC),
     -  nhneig(MAXREC),nnneig(MAXREC),ncneig(MAXREC),nsneig(MAXREC),
     -  npneig(MAXREC),nneiga(MAXREC),ibnd(MAXNEIG,MAXREC),ifill(IFILL1)
      character*4 ires_s
      character*8 convdat
      character*200 sfilename
      character*500 label(MAX2D)
      common /savedat/ mxresdat,maxcondat,ifst(1000),ilst(1000),
     -  nres,iresgen,lsfilename,ires_s(1000),convdat(7,10000),sfilename
      parameter (MAXFRAMES=50000,MAXCOPY=600)
      common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
     -  increment,increment2,res(2,MAXFRAMES,MAXCOPY),
     -  x0(MAXCOPY),y0(MAXCOPY),nxselres,ixselres(MAXCOPY)
      character*1 separatorchar
      common /filenuminfo/ iaskunderscore,separatorchar
      dimension iconfsel(MAXFRAMES),icntrl(20),icntrlw(20)
      dimension molsltlim(3,MAXRSD),bfacavg(MAXRSD),ianc_anc(MAXBONDS),
     -  rlim(MAXNEIG)
      dimension edge(3),edgeorg(3),edgeopt(3),c0(3),crm(3),xyzmin(3),
     -  xyzmax(3),edgestart(3),bestedge(3),voltry(200),dimtry(200),
     -  cmin(3),cmax(3),centinp(3),shiftmmc(3),iasv(100),qsv(100),
     -  lmarker(16)
      character*1 ans,ansrun,anscnv,ansman,ansopt,anspup,asterisk,
     -  resnam1,chain1,yz(6),dssplab(MAXRSD)
      character*2 ambtyp
      character*3 w3,PSFortop
      character*4 chnam,potnam4,segnam,extnam1,segnames(MAXRSD),
     -  segid4(MAXRSD),s4,atnam4,resnam4,pflsv(100),resnamp,
     -  tempname(MAXREC)
      character*6 potnam
      character*8 atomnam,resnam,resnamslv,resnamslvdef,resnamslvlast,
     -  rn,rnn,namesv(100),calpha,rnprev,atnames(MAXREC),
     -  resnames(MAXRSD)
      character*6 marker(16),rnu,rnun,rnuprev
      character*8 version
      character*20 cellname(10)
      character*80 title,trtitle(32),linewr,liner
C@GL      character*80 wintitl
      character*200 inpfile,outfile,analfile,outfiletmp,logfilename,
     -  inpfiletmp
      character*132 line(MAXREC),ansline,blankline
      common /line_crd/ line,index
      dimension awh2o(3),ch2o(3,3),crh2o(3,3),rot(3,3),rotopt(3,3),
     -  bestrot(3,3),centgra(3)
c     Arrays used as dummy argument for clusterdistr calls outside subroutine
c     anal (ASSUMING ietotsaved=0)
      dimension etotsaved(2,1),engcl(1)
      real*8 rohsum,rohsum2,ahohsum,ahohsum2,qsum,c8(3)
      character*1 abc,digits,hexdigits
      common /charactersets/ ihex(25),abc(62),digits(14),hexdigits(25)
      character*11 formatname
      common /formats/ iqdconv(19),formatname(17)
      character*11 trajformatname
      common /trajectory/ nmmccheck,iftrajtyp(6),trajformatname(6)
      character*1 aanames1
      character*2 mmodtoamb
      character*3 aanames3
      common /atnamcon/ mmodtoamb(100),aanames1(58),aanames3(58),
     -  naanames,nnanames,nnammnames,nnames,ixwatnam
      character*2 iatnm2
      common /atnam/ aw(99),nval(99),nvalmax(99),mmofan(99),
     -  mmatno(64),iatnm2(99)
      character*3 pbcres
      common /pbcresname/ pbcres(10)
      character*4 namfcg
      common /connatdat/ ramax(99),ramax2(99),hlimfac,ianfg(99),
     -  namfcg(100),nrmw
      common /columnlim/ incol(17),iidcol(17),iialtcol(17),
     -  iinamcol(2,17),iirescol(2,17),iiccol(2,17),iiresncol(2,17),
     -  iiseqncol(2,17),iisegcol(2,17),iiresidcol(2,17),iiqcol(2,17),
     -  iipotcol(2,17),iiocccol(2,17),iichemcol(2,17)
      character*8 namnam
      common /convspec/ incon,ioutcon,ideoxy,namnam(10)
      character*5 crdext
      common /iotypes/ iocha,iochaex,iobpdb,iocpdb,ioa3pdb,ioa4pdb,
     -  iommod,iommc,iommc4,iogro,iomol2,iomae,ioins,ionxyz,
     -  iosxyz,iosxyzrq,iograsp,iofull,lext(17),crdext(17)
      character*57 RTFtyps
      common /explainRTF/ RTFtyps(4)
      character*8 resnamsv
      common /names/ resnamsv(17)
      character*1 xyz
      common /axislab/ xyz(3)
      character*200 trajnam,trajnam2
      common /trajname/ trajnam,trajnam2,ltrajnam,ltrajnam2
      real*8 xtlabc,xtlabc0
      common /boxdat/ xtlabc(6),xtlabc0(6),box(3),box0(3),edge_gen(3,3),
     -  cell0(3,27),cell(3,27),cellalt(3,27),
     -  ncell,ioppbc,noboxinfoar,noboxinfow,noboxrep,
     -  istuner,iboxtypfound,ixcrd(3),ixang(3),ixyzhex(3),
     -  ixyzhextraj(3),isizewarn
      character*2 cvffname
      character*4 charmmname
      common /cvff/ maxcvfftyp,ncvfftyp,iambig(100),charmmname(100),
     -  cvffname(100)
      common /graphics/ igl,npixx,npixy,maxpixx,maxpixy,idwmain,idwplot,
     -  wx,wy,wz,wxdr
      common /rotmat/ matrot0(4,4),matrot(4,4),nomat0
      common /rotwarn/ nrotwarn,nrottest,devmax
      common /pbcrotmat/ torot_ac(3,3),torot_ca(3,3),tofac_ac,tofac_ca
      common /depthcuedat/ near,ifar,ramp0,idepth,idepthon,idrawh,
     -  linew,isidec,nbackb,idrawslv
      common /logging/ logfile,ipredict
      character*4 tab4,ctrlM4
      common /specchar/ tab4,ctrlM4
      character*1 tab,ctrlM
      common /tab/ tab,ctrlM
      common /numbers/ sq3,sq3inv,sq3p2,sq2p3
      character*1 gcent,segid_slv
      character*4 savesym,anamin1,anamout1,anamin2,anamout2
      character*25 read_format
      character*80 molname
      character*100 hostname
      data ixcluster /0/,icntrl /20*0/,inptrajtyp /0/,noreg /0/,
     -  ianumch /0/, nextconfsel /0/,ifixq /-1/,idistprint /-1/,
     -  centgra /0.0,0.0,0.0/,numconsec /0/,i2dopt /0/,longax /0/,
     -  maxrepconf /10/,nosegid /0/
C@GL      data icentgra /0/
      data awh2o/16.0,1.0,1.0/,naslv/3/,pi /3.141592/,centinp /3*0.0/,
     -  nrecdel /0/,natsdel /0/,npbc /3/,numres /0/,nold /0/,nnh /0/,
     -  icharges /0/,innlist /0/,namleni /0/,namleno /0/,nconfadd /0/,
     -  iwhead /1/,iresnrestart /0/,iresidrestart /1/,nosort /0/,
     -  idellp /0/,nsegslt /0/,ioktoend /0/,ireorient /0/,iaddfile /0/,
     -  nsetfile /1/,imodel /0/,imodelkeep /-1/,newsega /-1/,
     -  newsegr /-1/,ichainupdate /-1/,iwdiffpdb /-1/,ioverallconf /0/,
     -  ionefile /0/,numsel /0/,natomadd /0/,nions /0/,nmolres /0/,
     -  neednnlist /0/,nsltcfg1 /0/,incr_fileno /0/,ioverlay /0/,
     -  angmin /90.0/,hblimfac /1.4/,ftol /0.00001/,ititle /0/
      data asterisk/'*'/,version /'02/05/17'/,
     -  cellname /'Cubic               ','Rectangular         ',
     -            'Face-centered cubic ','Hexagonal (Z-vertex)',
     -            'Hexagonal (Y-vertex)','Truncated octahedron',
     -            'Truncated octahedron','Hexagonal close pack',
     -            'Octahedral          ','Image file based    '/,
     -  yz /' ',' ',' ','Z','Y',' '/,calpha /'CA   '/,
     -  marker/2*'* ',4*'REMARK','      ','! ',2*'      ',
     -  '!','#',3*'! ','      '/,lmarker /2*1,4*5,10*1/,
     -  resnamslv /'     '/,anscnv /' '/,segid_slv /'W'/
      call zeroiti(iwt,0,MAX2D)
      do i=1,MAXREC
        ih(i)=0
        isegno(i)=1
        iresno(i)=1
        ixres(i)=1
        iatnum(i)=0
        isc(i)=1
        ifchrg(i)=0
        charge(i)=0.0
        froccin(i)=1.0
      end do
      do i=1,MAXRSD
        segid4(i)='    '
      end do
      maxcondat=10000
      mxresdat=1000
      maxframe=MAXFRAMES
      maxconfsel=MAXFRAMES
      maxpres=MAXCOPY
      maxbox=MAXNEIG
      radtodeg=180.0/pi
      maxreckb=MAXREC/1000
      mbtot=132*maxreckb/1000+(92*maxreckb+25*98+(MAXPHI**3+
     -  MAXBRIDGEATOM*MAXBRIDGETYPE*(2*MAXBRIDGELEN+1))/1000)/250+
     -  (MAXFRAMES*MAXCOPY*8)/1000000
      mbtot=mbtot+MAXFRAMES*MAXCOPY/500000
      ierr=0
      iboxtypfound=-1
      if (IFILL1 .lt. 1 .or. IFILL2 .lt. 1 .or. IFILL3 .lt. 1 .or.
     -    IFILL4 .lt. 1 .or. IFILL5 .lt. 1 .or. IFILL5 .lt. 1 .or.
     -    IFILL6 .lt. 1 .or. IFILL7 .lt. 1 .or. IFILL8 .lt. 1 .or.
     -    IFILL9 .lt. 1) then
        write (6,1200) IFILL1,IFILL2,IFILL3,IFILL4,IFILL5,IFILL6,IFILL7,
     -    IFILL8,IFILL9,MAXREC,MAXNEIG,MAXPHI,MAX2D,MAXCV,MAXRCORR,
     -    MAXRSD
        ierr=1
      end if
      if (MAX2D**2 .lt. 27*MAXREC) then
        write (6,1201) MAX2D,MAXREC
        ierr=1
      end if
      if (MAX2D .gt. MAXBONDS) then
        write (6,1202) MAX2D,'BOND',MAXBONDS
        ierr=1
      end if
      if (MAX2D .gt. MAXFRAMES) then
        write (6,1202) MAX2D,'FRAME',MAXFRAMES
        ierr=1
      end if
      if (ierr .gt. 0) then
        write (6,1203)
        stop
      end if
      igl=0
C@GL      igl=1
C@GL      call deflin(2,$FF00)
C@GL      call deflin(3,$F0F0)
C@GLc     call textpo(maxpixx-npixx,maxpixx,0,maxpixy-npixy)
C@GLc     call prefpo(0, getgde(GDXPMA)-1, 0, getgde(GDYPMA)-1)
C@GL      call foregr
C@GL      wintitl(1:9)='SIMULAID '
C@GL      wintitl(10:17)=version
C@GL      lwint=17
C@GL      call prefsi(npixx,npixy)
C@GL      call prefpo(maxpixx-npixx,maxpixx,maxpixy-npixy,maxpixy)
C@GL      idwmain=winope(wintitl,lwint)
C@GL      call wintit(wintitl,lwint)
C@GL      call greset
C@GL      call glcomp(0,1)
C@GL      near=getgde(GDZMIN)
C@GL      ifar=getgde(GDZMAX)
C@GL      ramp0=0.0
C@GL      idepth=1
C@GL      idrawh=1
C@GL      isidec=1
C@GL      idrawslv=1
C@GL      linew=1
C@GL      call makdptcmap(7,ramp0)
C@GL      call double
C@GL      call setcolor(1)
C@GL      call clear
C@GL      call swapbu
C@GL      call viewpo(0,npixx,0,npixy)
C@GL      call setcolor(0)
C@GL      call clear
C@GL      call setcolor(1)
c     Extract the tab & ctrl-M character
      tab=tab4(1:1)
      ctrlM=ctrlM4(1:1)
      sq3=sqrt(3.0)
      sq3inv=1.0/sq3
      sq3p2=sq3/2.0
      sq2p3=sqrt(2.0/3.0)
      call randpx_init(1357)
      nomat0=1
      noboxinfoar=-1
      nmmccheck=0
      ioppbc=-1
      ipbcinp=0
      istuner=-1
      charges=0
      call zeroiti(ixyzhextraj,0,3)
      call zeroiti(nhbdist,0,MAXBONDS)
      iwconnslv=0
      nwrconn=0
      icntrl(11)=-1
      istopatend=-1
      call blankout(blankline,1,132)
      call blankout(title,1,80)
      do i=1,32
        call blankout(trtitle(i),1,80)
      end do
      do i=1,MAX2D
        call blankout(label(i),1,500)
      end do
      ltitle=0
      ltrajnam=0
      ltrajnam2=0
      logfile=0
      ipredict=0
      ideoxymmc=-1
      iconvfile=0
      iaskunderscore=1
      iqspaceask=1
      iwritecon=0
      iwriteatsym=-1
      minresflag=-1
      separatorchar='.'
      nrotwarn=0
      nrottest=0
      isizewarn=1
      devmax=0.0
      iclone=-1
      keeprem=-1
      noatnos=-1
      iofull=iomae
      reportqmin=-1.0
      iresshift=0
      iallheavy=0
      iaddid=0
      call datprt(6,version,0,'     ',5,hostname,lhostname,iheadnode,1)
      write (6,2000) version,mbtot,MAXREC
      if (lhostname .gt. 1) write (6,2005) hostname(1:lhostname)
      call setdatapath
      write (6,2004)
      if (iheadnode .eq. -1) write (6,1226)
      if (iheadnode .eq. 1) write (6,1204)
      if (iheadnode .ne. 0) write (6,1225)
      iuout=20
      etotread=0.0
90    call quiz(ansrun,iansrun,' ',' ',0,'run type',8,0,5,6,igl,0)
      iotyp=0
      namleni=0
c     Increment this when new run types are introduced
      iruntyp=0
      iruntypclean=39
      if (ansrun .eq. 'f') then
        call menulist
        go to 90
      end if
91    if (ansrun .eq. 'l') then
c       Open logfile
        namlenl=0
        call openfile(45,0,'log',3,'new',logfilename,namlenl,
     -    notfnd,3,1,1,0,0)
        write (6,2009) logfilename(1:namlenl)
        if (ipredict .eq. 0)
     -    call askyn('Do you want to make the quizzes predictable',43,
     -      1,1,ipredict,107)
        logfile=45
        if (ipredict .eq. 1) then
          write (6,2023)
          write (logfile,1000) 'p'
        end if
        go to 90
      else if (ansrun .eq. 'p') then
        write (6,2023)
        ipredict=1
        go to 90
      else if (ansrun .eq. 'o') then
        call quiz(ansopt,iansrun,' ',' ',0,'optimization type',17,
     -    0,5,6,igl,0)
        if (ansopt .eq. 's') then
          iruntyp=1
        else if (ansopt .eq. 'p') then
          iruntyp=2
        else if (ansopt .eq. 'o') then
          iruntyp=3
        else if (ansopt .eq. 'q') then
          go to 90
        end if
      else if (ansrun .eq. 'c') then
        iruntyp=iruntypclean
        neednnlist=1
      else if (ansrun .eq. 'u') then
        call quiz(anspup,iansrun,' ',' ',0,
     -    'trajectory/configuration stack packing/unpacking',48,0,5,6,
     -    igl,103)
        if (anspup .eq. 'u' .or. anspup .eq. 'k') then
          call quiz(anscnv,iansrun,' ',' ',0,'unpacking mode',14,
     -      0,5,6,igl,0)
          if (anscnv .eq. 'o' .or. anscnv .eq. 't') ionefile=1  
          if (anscnv .eq. 'l' .or. anscnv .eq. 't') 
     -      call getlist(iconfsel,numsel,1,999999,1,maxconfsel)
          nextconfsel=1
          if (anspup .eq. 'u') then
            iruntyp=14
            if (anscnv .eq. 'o') then
              write (6,*) 'This choice would just copy the input file'
              go to 90
            end if
          else if (anspup .eq. 'k') then
            iruntyp=19
            neednnlist=1
            call getcrdtyp(0,'   ',3,iotyp,ixcl,igl)
            write (6,2016) formatname(iotyp)
            call askyn(
     -       'Do you want the headers in the additional configurations',
     -        56,1,1,iwhead,0)
          end if
          if (anscnv .eq. 'l') call askyn(
     -      'Do you want to number the files consecutively',
     -      45,1,0,numconsec,1)
          if (iotyp .eq. iobpdb) call askyn(
     -      'Do you want to mark the structures as MODEL',43,1,-1,
     -      imodel,0)
          if (anscnv .eq. 'o') iaskunderscore=0
        else if (anspup .eq. 'b') then
          iruntyp=12
        else if (anspup .eq. 'm') then
          iruntyp=37
          ioutrajtyp=0
        else if (anspup .eq. 'q') then
          go to 90
        end if
        if ((anspup .eq. 'u' .or. anspup .eq. 'k') .and.
     -       anscnv .ne. 'o' .and. anscnv .ne. 't') then
          call getint('File number increment',21,0,1,999999,incr_fileno,
     -      114)
        end if
      else if (ansrun .eq. 'n') then
c       Atom/residue NAME conversion
        call quiz(anscnv,iansrun,' ',' ',0,'name conversion type',20,
     -    0,5,6,igl,21)
        if (anscnv .eq. 'f') then
          iruntyp=9
          iformconv=0
        else if (anscnv .eq. 'r') then
          iruntyp=9
          iformconv=2
        else if (anscnv .eq. 'u') then
          iruntyp=9
          iformconv=3
          write (6,2050)
        else if (anscnv .eq. 'l') then
          iruntyp=9
          iformconv=4
        else if (anscnv .eq. 'd') then
          iruntyp=9
          iformconv=5
        else if (anscnv .eq. 'q') then
          go to 90
        else
          write (6,2002) 'structure conversion',anscnv
          stop
        end if
      else if (ansrun .eq. 's') then
c       Structure file FORMAT conversions
        call quiz(anscnv,iansrun,' ',' ',0,
     -    'structure file format conversion type',37,0,5,6,igl,0)
        if (anscnv .eq. 't') then
          iruntyp=13
        else if (anscnv .eq. 'c') then
          iruntyp=8
          iotyp=iocha
        else if (anscnv .eq. 'e') then
          iruntyp=8
          iotyp=iochaex
        else if (anscnv .eq. 'p') then
          iruntyp=8
          iotyp=iobpdb
          iresnrestart=1
        else if (anscnv .eq. 'h') then
          iruntyp=8
          iotyp=iocpdb
          iresnrestart=1
        else if (anscnv .eq. 'm') then
          iruntyp=8
          iotyp=iommod
        else if (anscnv .eq. 'l') then
          iruntyp=6
        else if (anscnv .eq. 'g') then
          iruntyp=8
          iotyp=iogro
        else if (anscnv .eq. 'i') then
          iruntyp=8
          iotyp=ioins
          print *,'WARNING: Insight potential types will not be set'
        else if (anscnv .eq. 'n') then
          iruntyp=8
          iotyp=ionxyz
        else if (anscnv .eq. 's') then
          iruntyp=8
          iotyp=iosxyz
        else if (anscnv .eq. 'r') then
          iruntyp=iosxyzrq
          iotyp=7
        else if (anscnv .eq. 'a') then
          iruntyp=11
        else if (anscnv .eq. 'o') then
          iruntyp=26
        else if (anscnv .eq. 'f') then
          call listformat(igl,0)
          go to 90
        else if (anscnv .eq. 'q') then
          go to 90
        end if
      else if (ansrun .eq. 't') then
c       Trajectory file FORMAT conversions
        call quiz(anscnv,iansrun,' ',' ',0,
     -    'trajectory file format conversion type',38,0,5,6,igl,104)
        if (anscnv .eq. 'm') then
          iruntyp=17
          neednnlist=1
          inptrajtyp=0
          ioutrajtyp=4
          iotyp=iommod
        else if (anscnv .eq. 'x') then
          iruntyp=17
          neednnlist=1
          inptrajtyp=0
          ioutrajtyp=5
          iotyp=iommod
        else if (anscnv .eq. 'c') then
          iruntyp=17
          neednnlist=1
          inptrajtyp=0
          ioutrajtyp=1
          iotyp=iocha
        else if (anscnv .eq. 'a') then
          iruntyp=17
          neednnlist=1
          inptrajtyp=0
          ioutrajtyp=2
          iotyp=iobpdb
        else if (anscnv .eq. 's') then
          iruntyp=32
          inptrajtyp=3
          ioutrajtyp=2
          iotyp=iobpdb
          call asktrajform(inptrajtyp,ioutrajtyp,mmctrajtyp,
     -      resnamslv,igl,-1,0)
        else if (anscnv .eq. 'q') then
          go to 90
        else
          write (6,2002) 'trajectory conversion',anscnv
          stop
        end if
      else if (ansrun .eq. 'e') then
        call quiz(ansman,iansrun,' ',' ',0,
     -    'conformation manipulation',25,0,5,6,igl,0)
        anscnv=ansman
        if (ansman .eq. 'e') then
          iruntyp=16
          neednnlist=1
        else if (ansman .eq. 'r') then
          iruntyp=15
          neednnlist=1
        else if (ansman .eq. 'y') then
          iruntyp=27
          neednnlist=1
        else if (ansman .eq. 'n') then
          iruntyp=28
        else if (ansman .eq. 'o') then
          iruntyp=28
          ioverlay=1
        else if (ansman .eq. 'h') then
          iruntyp=28
        else if (ansman .eq. 'd') then
          iruntyp=20
        else if (ansman .eq. 'x') then
          iruntyp=4
        else if (ansman .eq. 'w') then
          iruntyp=5
        else if (ansman .eq. 'v') then
          iruntyp=35
        else if (ansman .eq. 'c') then
          iruntyp=34
        else if (ansman .eq. 'b') then
          iruntyp=35
        else if (ansman .eq. 'l') then
          iruntyp=36
        else if (ansman .eq. 't') then
          iruntyp=38
          neednnlist=1
        else if (ansman .eq. 'q') then
          go to 90
        end if
      else if (ansrun .eq. 'd') then
        call quiz(ansman,iansrun,' ',' ',0,
     -    'structure-derived file creation',31,0,5,6,igl,0)
        if (ansman .eq. 'e') then
          iruntyp=21
        else if (ansman .eq. 'g') then
          iotyp=iograsp
          iruntyp=22
        else if (ansman .eq. 'h') then
          iotyp=iograsp
          iruntyp=23
        else if (ansman .eq. 'l') then
          iruntyp=25
        else if (ansman .eq. 'i') then
          iruntyp=24
        else if (ansman .eq. 'f') then
          iruntyp=29
          neednnlist=1
        else if (ansman .eq. 'q') then
          go to 90
        end if
      else if (ansrun .eq. 'a') then
        iruntyp=10
        neednnlist=1
      else if (ansrun .eq. 'r') then
        call quiz(anscnv,iansrun,' ',' ',0,'clustering source',17,
     -    0,5,6,igl,00)
        if (anscnv .eq. 'a') then
          iruntyp=30
        else
          iruntyp=31
        end if
      else if (ansrun .eq. 'm') then
        iruntyp=18
        if (igl .eq. 0) then
          print *,'Animating trajectories requires the SGI graphics',
     -      ' code to be compiled'
          go to 90
        end if
      else if (ansrun .eq. 'q') then
        stop
      else
        write (6,2002) 'main',ansrun
        stop
      end if
      iaskagain_inp=0
10    if (iruntyp .eq. 22 .or. iruntyp .eq. 23 .or.
     -    iruntyp .eq. 25 .or. iruntyp .eq. 31) then
c       No input structure is needed
        if (iruntyp .eq. 31) call openfile(iuout,0,'output',6,
     -    'new',outfile,namleno,notfnd,0,1,1,0,0)
        go to 101
      else
        if (iruntyp .eq. 28 .and. iaskagain_inp .eq. 0) then
          if (ansman .eq. 'n' .or. ansman .eq. 'o') then
            lena=30
            if (ioverlay .eq. 0) then
              ansline(1:lena)='REPLACING coordinate structure'
            else
              ansline(1:lena)='REFERENCE coordinate structure'
            end if
          else
            lena=36
            ansline(1:lena)='structure with the REPLACING charges'
          end if
c         Open and read first the replacement/reference coordinates
          call openfile(10,0,ansline,lena,'old',inpfile,namleni,
     -      notfnd,0,1,1,0,0)
          call getcrdtyp(10,inpfile,namleni,inpcrdtyp,ixcluster,igl)
          resnamslv=resnamsv(inpcrdtyp)
          nsegm=1
          call readconf(1,10,inpcrdtyp,iruntyp,iruntypclean,inpfile,
     -      namleni,outfile,namleno,line,title,ititle,trtitle,ntitlin,
     -      ntitltr,0,ncol,nref,nlines,nsegm,nosegid,iisegcol,index,co,
     -      iresno,iatnum,isegno,froccin,cv,segid4,iundef,naltnam,
     -      nrecdel,nneig,ineig,iha,iaskagain_ref,iendfound,0,
     -      istopatend,iqha,imodelkeep,newsega,newsegr,neednnlist,
     -      ietotread,etotread,temp,molname,molnamelen,iclone,igl,
     -      maxrepconf,MAXNEIG,MAXREC,MAXRSD)
          if (ansman .eq. 'h' .and. inpcrdtyp .ne. 6) then
            print *,'Sory, this option is valid for .pdbqt files'
            stop
          end if
          if (iaskagain_ref .gt. 0) then
            namleni=0
            go to 10
          end if
          call trnsfi(indexa,iatnum,nref)
          close (10)
          namleni=0
        end if
        itrajtyp=1
        do while (itrajtyp .gt. 0)
          namleni=0
          call openfile(10,0,'input STRUCTURE',15,'old',inpfile,
     -      namleni,notfnd,3,1,1,1,0)
          close (10)
c         Check if DCD or Amber traj file
          call isdcd(inpfile,namleni,itrajtyp1)
          if (itrajtyp1 .ne. 0)
     -       write (6,2123) inpfile (1:namleni),'Charmm'
          call isambertraj(inpfile,namleni,itrajtyp2)
          if (itrajtyp2 .ne. 0)
     -      write (6,2123) inpfile (1:namleni),'Amber'
           itrajtyp=itrajtyp1+itrajtyp2
        end do
        call openfile(10,0,'input STRUCTURE',15,'old',inpfile,namleni,
     -    notfnd,0,1,1,0,0)
        call getcrdtyp(10,inpfile,namleni,inpcrdtyp,ixcluster,igl)
        call setcol(inpcrdtyp,ncol,idcol,ialtcol,
     -    inamcol1,inamcol2,irescol1,irescol2,iccol1,iccol2,
     -    iresncol1,iresncol2,iseqncol1,iseqncol2,isegcol1,isegcol2,
     -    iresidcol1,iresidcol2,iqcol1,iqcol2,ipotcol1,ipotcol2,
     -    iocccol1,iocccol2,ichemcol1,ichemcol2,nrescol,nresncol,
     -    nsegcol,nnamcol,iofull)
        resnamslv=resnamsv(inpcrdtyp)
        if (inpcrdtyp .ge. ioa3pdb .and. iqcol2 .ge. iqcol1) icharges=1
      end if
      if (iruntyp .eq. 12 .or. iruntyp .eq. 17 .or. iruntyp .eq. 18 .or.
     -    iruntyp .eq. 19) then
        inptrajtyp=0
        if (iruntyp .eq. 12) then
103       call asktrajform(inptrajtyp,ioutrajtyp,mmctrajtyp,
     -      resnamslv,igl,+1,1)
          if (ioutrajtyp .eq. 3 .and. mmctrajtyp .ne. 1) then
            print *,'Non-binary MMC trajectory write is not implemented'
            go to 103
          end if
        else
          call asktrajform(inptrajtyp,ioutrajtyp,mmctrajtyp,
     -      resnamslv,igl,-1,1)
        end if
      end if
      if (iruntyp .eq. 10 .or. iruntyp .eq. 6 .or. iruntyp .eq. 24) then
c       Analysis or print neigboring cells, or torsion input
        namleno=namleni
        outfile=inpfile
      else if (iruntyp .ne. 12 .and. iruntyp .ne. 14 .and.
     -         iruntyp .ne. 17 .and. iruntyp .ne. 18 .and.
     -         iruntyp .ne. 19 .and. iruntyp .ne. 21 .and.
     -         iruntyp .ne. 26 .and. iruntyp .ne. 32) then
c       File format conversion or Grasp input - just  try to switch extension
        if (iruntyp .eq. 8 .or. iruntyp .eq. 22)
     -    call changeext(inpfile,outfile,namleni,namleno,crdext(iotyp),
     -      lext(iotyp),0,1)
c       Ask output file name
        call openfile(iuout,0,'output',6,'new',outfile,namleno,notfnd,
     -    0,1,1,0,0)
      end if
      if (inpcrdtyp .eq. iograsp .and. (iruntyp .ne. 9 .or.
     -   (iformconv .ne. 2 .and. iformconv .ne. 4))) then
        write (6,2047)
        close (10)
        close (iuout,status='delete')
        go to 91
      end if
      if (iwhead .eq. 0) then
        if (ischarmm(iotyp) .eq. 1) print *,'Note: ',
     -    'Number of atoms will have to be fixed manually'
        if (iotyp .eq. iommod)
     -    print *,'WARNING: Macromodel bond table will be invalid'
      end if
      if (iruntyp .eq. 8) then
        if (inpcrdtyp .eq. iotyp) then
          write (6,2064)
          close (10)
          close (iuout,status='delete')
          go to 91
        end if
        if (iotyp .le. ioins) then
          write (6,1297)
          if (inpcrdtyp .eq. ionxyz .or. inpcrdtyp .eq. iosxyz)
     -      write (6,1298)
          if (inpcrdtyp .eq. iosxyzrq) write (6,1299)
        end if
      end if
      if (iotyp .eq. 0) iotyp=inpcrdtyp
      if (ispdb(iotyp) .gt. 0 .and. iruntyp .ne. 9 .and.
     -  ansrun .ne. 'm' .and. ansrun .ne. 'q' .and. iruntyp .ne. 9) then
        call askyn(
     -    'Do you want to change atomnames to Brookhaven form',50,
     -    0,-1,noreg,9)
      end if
      if (ispdb(iotyp) .gt. 0) iresnrestart=1
      nconfig=0
      natconftot=0
      iha=1
      iqha=1
      title (1:4)='@#$%'
99    ntitlin=0
      ntitlinw=0
      nsegm=1
      ntitltr=0
      if (iruntyp .eq. 22) go to 888
      call readconf(1,10,inpcrdtyp,iruntyp,iruntypclean,inpfile,namleni,
     -  outfile,namleno,line,title,ititle,trtitle,ntitlin,
     -  ntitltr,nconfig,ncol,n,nlines,nsegm,nosegid,iisegcol,index,
     -  c,iresno,iatnum,isegno,froccin,charge,segid4,iundef,naltnam,
     -  nrecdel,nneig,ineig,iha,iaskagain_inp,iendfound,ioktoend,
     -  istopatend,iqha,imodelkeep,newsega,newsegr,neednnlist,ietotread,
     -  etotread,bfacavg,molname,molnamelen,iclone,igl,maxrepconf,
     -  MAXNEIG,MAXREC,MAXRSD)
      if (iaskagain_inp .gt. 0) then
        namleni=0
        go to 10
      end if
      if (iendfound .gt. 0) go to 9999
      islvw=0
      rn='        '
      if (nconfig .eq. 0 .or. ansrun .eq. 's') then
        call lastchar(title,ltitle,80)
        write (6,1224) n,title(1:ltitle)
        call askyn('Do you want to replace the title',32,1,-1,irep,000)
        if (irep .eq. 1) then
          call blankout(title,1,80)
          call getname(title,ltitle,'New title',9,72,0)
          if (ititle .gt. 0) then
            call blankout(line(ititle),1,80)
            line(ititle)(1:ltitle+6)='TITLE '//title(1:ltitle)
          else
            print *,'NOTE: new title will not appear on STRUCTURE files'
          end if
        end if
        if (inpcrdtyp .le. ioins) then
c         Find out solvent residue
104       if (nconfig .eq. 0) then
            resnamslvdef=resnamslv
            resnamslvlast(1:irescol2-irescol1+1)=
     -        line(index(n))(irescol1:irescol2)
            if (n .gt. 999999 .and. inpcrdtyp .eq. iocha)
     -        resnamslvlast(1:irescol2-irescol1+1)=
     -          line(index(n))(irescol1+1:irescol2+1)
            call leftadjustn(resnamslvlast,resnamslvlast,8)
            if (resnamslvlast(1:3) .eq. 'WAT' .or.
     -          resnamslvlast(1:3) .eq. 'HOH' .or.
     -          resnamslvlast(1:3) .eq. 'OH2' .or.
     -          resnamslvlast(1:3) .eq. 'TIP')
     -        resnamslvdef=resnamslvlast
            call readname('Solvent residue name in the input file',38,
     -        blankline,nrescol,resnamslvdef(1:nrescol),nrescol,
     -        resnamslv,0)
          end if
c         Find the last nonsolvent atom
          ia=1
          icinc=0
          do while (ia .le. n)
            rn(1:nrescol)=line(index(ia))(irescol1+icinc:irescol2+icinc)
            call leftadjustn(rn,rn,8)
            if (rn(1:nrescol) .ne. resnamslv(1:nrescol)) then
              ia=ia+1
              if (ia .eq. 999999 .and. inpcrdtyp .eq. iocha)
     -          icinc=icinc+1
            else
              go to 105
            end if
          end do
105       nslt=ia-1
c         Check for non-solvent residues mixed into solvents
          nsltx=0
          do ia=nslt+1,n
            rn(1:nrescol)=line(index(ia))(irescol1+icinc:irescol2+icinc)
            call leftadjustn(rn,rn,8)
            if (rn(1:nrescol) .ne. resnamslv(1:nrescol)) nsltx=nsltx+1
            if (ia .eq. 999999 .and.inpcrdtyp .eq. iocha) icinc=icinc+1
          end do
          if (nslt .eq. 0) then
            print *,'NOTE: No solute found'
          else
            print *,'Number of solute atoms found=',nslt
            if (nslt .eq. n .and. nconfig .eq. 0) then
              numslv=0
              if (resnamslv(1:nrescol) .ne. resnamslvdef(1:nrescol))then
                write (6,2124) 'NOTE',resnamslv(1:nrescol)
                call askyn('Are you sure about the solvent name',35,1,
     -            +1,iok,000)
                if (iok .eq. 0) go to 104
              else if (inpcrdtyp .ne. iommc) then
                write (6,2124) 'NOTE',resnamslv(1:nrescol)
              end if
            end if
            nsegslt=isegno(nslt)
            if (nsegslt .gt. 100 .and. n .eq. nslt) then
              write (6,2177) nsegslt,resnamslv(1:nrescol),
     -          line(index(n))(irescol1:irescol2)
              if (ipredict .eq. 0 .and. nconfig .eq. 0) then
                call askyn('Is this correct',15,1,1,iresnamok,0)
                if (iresnamok .eq. 0) go to 104
              end if
            end if
          end if
          if (nsltx .gt. 0) then
            write (6,1216) nsltx
            call askstop(1)
          end if
          if (n .gt. nslt) then
c           Determine the number of atoms in a solvent molecule
            ia=nslt+1
            do while (iresno(ia) .eq. iresno(nslt+1) .and. ia .lt. n)
              ia=ia+1
            end do
            if (ia .lt. n) ia=ia-1
            naslv=ia-nslt
            if (naslv .gt. 25) print *,'Simulaid assumes that ',
     -        'solvent molecules are different residues'
            numslv=(n-nslt)/naslv
            write (6,2082) resnamslv(1:nrescol),naslv,numslv
            modwarn=0
            if (mod(n-nslt,naslv) .ne. 0) then
              modwarn=1
              write (6,2083) n-nslt,naslv
            end if
            if ((naslv .gt. 25 .or. modwarn .gt. 0) .and.
     -          ipredict .eq. 0 .and. nconfig .eq. 0) then
              call askyn('Is this correct',15,1,1,ireadnat,0)
              if (ireadnat .eq. 0) call getint(
     -          'Number of atoms in a '//resnamslv//' molecule',30+5,
     -          1,1,n,naslv,0)
            end if
c           If the solvent is  water, islvw = 1 (otherwise islvw = 0)
            w3=resnamslv(1:3)
            if (w3 .eq. 'TIP' .or. w3 .eq. 'HOH' .or. w3 .eq. 'WTR' .or.
     -        naslv .eq. 3 .and.
     -        iatnum(nslt+1)*iatnum(nslt+2)*iatnum(nslt+3) .eq. 8)
     -           islvw=1
          end if
          if (inptrajtyp .eq. 3) then
            print *,'Please confirm:'
            call getint('Number of SOLUTE atoms',22,nslt,1,n,nslt,0)
          end if
        else
910       call getint('Number of solvent molecules',27,999999,1,0,
     -      nslvmol,0)
          if (nslvmol .gt. 0)
     -      call getint('Number of atoms per solvent molecule',28,1,1,0,
     -        naslv,0)
          nslt=n-nslvmol*naslv
          if (nslt .le. 0) then
            print *,'Too many solvent molecules'
            go to 910
          end if
        end if
        nsltcfg1=nslt
c       Establish atom ranges for the residues
        ifres(1)=1
        ixres(1)=1
        numres=0
        numresslt=0
        if (inamcol1 .lt. inamcol2) atnames(1)(1:nnamcol)=
     -     line(index(1))(inamcol1:inamcol2)
        do ia=2,n
          if (inamcol1 .lt. inamcol2) atnames(ia)(1:nnamcol)=
     -        line(index(ia)) (inamcol1:inamcol2)
          if (iresno(ia) .ne. iresno(ia-1) .or.
     -        isegno(ia) .ne. isegno(ia-1)) then
            numres=numres+1
            if (numres .ge. MAXRSD) then
              write (6,1217) MAXRSD
              stop
            end if
            ilres(numres)=ia-1
            ifres(numres+1)=ia
            ixresno(numres)=iresno(ia-1)
            ixsegno(numres)=isegno(ia-1)
            resnames(numres)='        '
            if (irescol1 .lt. irescol2) resnames(numres)(1:nrescol)=
     -        line(index(ilres(numres)))(irescol1:irescol2)
          end if
          if (ia .eq. nslt) numresslt=numres+1
          ixres(ia)=numres+1
c          write (77,9561) ia,iresno(ia),iresno(ia-1),isegno(ia),ixres(ia)
c9561      format(i6,' iresno=',i6,' iresnom1=',i6,' isegno=',i3,
c     -       ' ixres=',i6)
        end do
        numres=numres+1
        ilres(numres)=n
        ixresno(numres)=iresno(n)
        ixsegno(numres)=isegno(n)
        resnames(numres)='        '
        if (irescol1 .lt. irescol2) resnames(numres)(1:nrescol)=
     -    line(index(ilres(numres)))(irescol1:irescol2)
        if (numresslt.eq. 0 .and. nslt .gt. 0) numresslt=numres
        print *,'Number of residues=',numres,
     -    ' solute residues=',numresslt
c       Check if residue numbering is from 1 to numres
        if (iresno(1) .ne. 1) write (6,2080) iresno(1)
        iresshift=0
        do ir=1,numres
          if (ir .ne. ixresno(ir)) iresshift=1
        end do
        if (iresshift .ne. 0)
     -    write (6,2078) numres,iresno(ifres(1)),iresno(ifres(numres))
        if (nconfig .eq. 0) then
          call checkfordup(numres,n,ifres,ilres,iresno,resnames,atnames,
     -      line,index,ndupdel,maxrec,nrescol,nnamcol,idcol)
          nrecdel=nrecdel+ndupdel
        end if
      else
        if (n .ne. nold .and. iruntyp .ne. 14) then
          print *,'nconf=',nconfig+1,' WARNING: New number of atoms=',n
          ianumch=1
        end if
        nslt=0
        do ia=1,n
          if (line(index(ia))(irescol1:irescol2) .ne.
     -        resnamslv(1:nrescol)) nslt=ia
        end do
        if (nslt .ne. nsltcfg1) then
          if (iruntyp .ne. 14 .and. ansrun .ne. 's') then
            write (6,2063)
            write (6,2067) nslt,nsltcfg1
            stop
          else if (nconfig .lt. 1) then
            write (6,2065)
            write (6,2067) nslt,nsltcfg1
          end if
        end if
      end if
      nold=n
      ncation=0
      if (inpcrdtyp .lt. ioins) then
c       Obtain atomic numbers from atomnames
        if (noatnos .eq. -1) then
          noatnos=1
          if (inpcrdtyp .eq. iobpdb .or. inpcrdtyp .eq. iocpdb)
     -      call askyn('Do you have chemical symbols in cols 77-78',42,
     -        0,-1,noatnos,0)
        end if
        if (noatnos .eq. 0) then
          do ia=1,n
            iatnum(ia)=ianum(line(index(ia))(77:78),1,2)
          end do
        else
          atomnam='     '
          do ia=1,n
            atomnam(1:nnamcol)=line(index(ia))(inamcol1:inamcol2)
            ian=ianum(atomnam,1,nnamcol)
            iatnum(ia)=ian
c           print *,'atomnam,ianum,index(ia)=',
c    -        atomnam,iatnum(ia),index(ia)
          end do
        end if
        do ia=1,n
          ian=iatnum(ia)
          if (ian .eq. 3 .or. ian .eq. 11 .or. ian .eq. 19 .or.
     -      ian .eq. 37) ifchrg(ia)=1
          if (ian .eq. 12 .or. ian .eq. 20 .or. ian .eq. 38)
     -      ifchrg(ia)=2
          if (ifchrg(ia) .gt. 0) ncation=ncation+1
        end do
        if (ncation .gt. 0) print *,'Number of cations found=',ncation
c       See if there are 'lone pair' atoms, check for blank atom or residue num
        nlp=0
        nblanka=0
        nblankr=0
        nnamd=0
        nhyd=0
        do ia=1,nslt
            atomnam(1:nnamcol)=line(index(ia))(inamcol1:inamcol2)
          if (idigit(atomnam(1:1),1) .eq. 1 .or. atomnam(1:1) .eq. ' ')
     -      atomnam(1:2)=atomnam(2:3)
          if (atomnam(1:2) .eq. 'LP' .or. atomnam(1:2) .eq. 'LD' .or.
     -      atomnam(1:2) .eq. 'LG') then
            nlp=nlp+1
            if (nlp .eq. 1 .and. nconfig .eq. 0)
     -        call askyn('Do you want to delete lone pairs',32,1,1,
     -          idellp,0)
            if (idellp .eq. 1) then
              line(index(ia))(idcol:idcol)=asterisk
            end if
          end if
          if (iatnum(ia) .eq. 0) nhyd=nhyd+1
        end do
        if (nhyd .eq. 0) then
          iallheavy=1
          print *,'The solute contains all heavy atoms'
        else
          print *,'Number of hydrogens in the solute=',nhyd
        end if
        if (nlp .gt. 0) print *,'Number of lone pair centers found=',nlp
        if (idellp .eq. 1) nrecdel=nrecdel+nlp
c       Delete atoms marked for deletion (so far)
        call atomdel(line,idcol,asterisk,n,nslt,nrecdel,c,isegno,index,
     -    indexn,indexo,inpcrdtyp,iatnum,charge,iresno,ixres,ifres,
     -    ilres,nconfig,nlpdel,MAXRSD,MAXREC)
c       Mark backbone atoms (if any)
        nbackb=0
        do ia=1,nslt
          atnam4=line(index(ia))(inamcol1:inamcol1+3)
          call leftadjust4(atnam4,atnam4)
          if (atnam4 .eq. 'C   ' .or. atnam4 .eq.  'O   ' .or.
     -        atnam4 .eq. 'CA  ' .or. atnam4 .eq.  'N   ' .or.
     -        atnam4 .eq. 'HN  ' .or. atnam4 .eq.  'H   ') then
            isc(ia)=0
            nbackb=nbackb+1
          end if
          if (iseqncol2 .ge. iseqncol1) then
            if (line(index(ia))(iseqncol1:iseqncol2) .eq.
     -          blankline(iseqncol1:iseqncol2)) nblanka=nblanka+1
          end if
          if (iresncol2 .ge. iresncol1) then
            if (line(index(ia))(iresncol1:iresncol2) .eq.
     -          blankline(iresncol1:iresncol2)) then
              nblankr=nblankr+1
              line(index(ia))(iresncol2:iresncol2)='0'
            end if
          end if
        end do
        if (nbackb .gt. 0) then
          nsidec=nslt-nbackb
          if (nconfig .le. maxrepconf .and. nslt .gt. 0)
     -      write (6,2057) nbackb,nsidec
        end if
        if (nblanka+nblankr .gt. 0) then
          if (nblanka .gt. 0) write (6,2059) nblanka,'atom'
          if (nblankr .gt. 0) write (6,2059) nblankr,'residue'
          if (nblanka .eq. nslt .and. ispdb(inpcrdtyp) .gt. 0) then
            print *,'Missing atomnumbers are inserted'
            do ia=1,nslt
              write (line(index(ia))(iseqncol1:iseqncol2),1007) ia
            end do
          else
            write (6,2060)
            if (nblankr .gt. 0) write (6,2062)
            if (iruntyp .ne. iruntypclean) write (6,2061)
            call listformat(igl,inpcrdtyp)
            call askstop(1)
          end if
        end if
      end if
c     Collect solute segment limits and id-s (they can be scattered)
c     First just collect the list as came
      nsegslt=0
      isegnoo=0
      if (isegcol2 .ge. isegcol1 .and. nsegslt .gt. 0 .and.
     -    isegcol2 .ge. isegcol1)
     -  call getseg4(segid4(1),line(index(1)),isegcol1,nsegcol)
      numresf=1
      numresl=0
      molsltlim(1,1)=1
      molsltlim(2,1)=nslt
      molsltlim(3,1)=0
      minresflag=0
      nmolslt=1
      do ir=1,numresslt
        if (isegno(ifres(ir)) .ne. isegnoo) then
          if (ir .gt. 1) then
            numresl=ir-1
            molsltlim(1,nsegslt)=numresf
            molsltlim(2,nsegslt)=numresl
            if (isegcol2 .ge. isegcol1 .and. nsegslt .gt. 0) then
              if (nsegslt .le. MAXRSD) then
                call getseg4(segid4(nsegslt),
     -            line(index(ifres(numresf))),isegcol1,nsegcol)
              else
                Print *,'ERROR: number of segments/chains exceeds ',
     -            MAXRSD
                if (nslt .eq. n)
     -            print *,'Make sure solvents are recognized'
                stop
              end if
            end if
          end if
          nsegslt=nsegslt+1
          numresf=numresl+1
          isegnoo=isegno(ifres(ir))
        end if
      end do
      molsltlim(1,nsegslt)=numresf
      molsltlim(2,nsegslt)=numresslt
      if (isegcol2 .ge. isegcol1 .and. nsegslt .gt. 0)
     -  call getseg4(segid4(nsegslt),line(index(ifres(numresf))),
     -    isegcol1,nsegcol)
      nsegcol4=min0(4,nsegcol)
      if (nslt .gt. 0) then
        if (nsegslt .gt. 1 .and. nconfig .lt. maxrepconf) then
          write (6,2051) nconfig+1,nsegslt
          if (nosegid .eq. 0)
     -      write (6,2052) (segid4(i)(1:nsegcol4),i=1,nsegslt)
        end if
      else
         write (6,2054) nconfig+1
      end if
      if (nosegid .eq. 1) then
        write (6,2041)
        call askyn('Do you want to add segment IDs now',34,1,1,iaddid,0)
        if (iaddid .eq. 1) then
          do ia=1,nslt
            line(index(ia))(isegcol1:isegcol1)=
     -        abc(mod(isegno(ia)-1,62)+1)
          end do
          do ia=nslt+1,n
            line(index(ia))(isegcol1:isegcol1)='W'
          end do
        end if
      end if
      do is=1,min0(MAXRSD,nsegslt)
        numresf=molsltlim(1,is)
        numresl=molsltlim(2,is)
        if (nconfig .eq. 0) then
          write (linewr,2053) is,segid4(is)(1:nsegcol4),
     -      ifres(numresf),ilres(numresl),iresno(ifres(numresf)),
     -      iresno(ifres(numresl)),numresf,numresl
          len=67
          if (ispdb(inpcrdtyp) .gt. 0) then
            write (linewr(len+1:len+12),2068) bfacavg(is)
            len=len+12
          end if
          write (6,1000) linewr(1:len)
        end if
        if (isegcol2 .ge. isegcol1 .and. nsegslt .gt. 0 .and.
     -      segid4(is)(1:1) .eq. ' ') segid4(is)(1:1)='_'
        molsltlim(1,is)=ifres(numresf)
        molsltlim(2,is)=ilres(numresl)
        molsltlim(3,is)=0
      end do
c     Now eliminate duplicate occurrences
      ndupsg=0
      do is=2,nsegslt
        s4='_   '
        do js=1,is-1
          if (segid4(is)(1:nsegcol4) .eq. segid4(js)(1:nsegcol4) .and.
     -        segid4(is)(1:nsegcol4) .ne. s4(1:nsegcol4))
c    -      segid4(is)='#*%&'
     -      ndupsg=1
        end do
      end do
c     ndel=0
c     do is=1,nsegslt
c       if (segid4(is) .ne. '#*%&') then
c         segid4(is-ndel)=segid4(is)
c       else
c         ndel=ndel+1
c       end if
c     end do
      if (nsegslt . gt. 1 .and. nconfig .eq. 0) print *,
     -  'Input annotation indicates that the solute consists of',
     -  nsegslt,' molecules'
      if (ndupsg .gt. 0 .and. newsega+newsegr .eq. -2 .and.
     -    nconfig .lt. maxrepconf) print *,
     -  'WARNING: different segments have identical segment id'
      if ((ndupsg .gt. 0 .or. ipredict .eq. 1) .and.
     -     ispdb(inpcrdtyp) .eq. 1 .and. iaddid .eq. 0) then
        if (ichainupdate .eq. -1) call askyn(
     -    'Do you want to change the chain IDs to be all different',
     -    55,1,-1,ichainupdate,000)
        if (ichainupdate .eq. 1) then
          do is=2,nsegslt
            match=0
            do js=1,nsegslt
              if (is .ne. js .and.
     -           segid4(is)(1:1) .eq.  segid4(js)(1:1)) match=1
            end do
            if (match .eq. 1) then
c             Find a letter that is not used
              iabc=1
              matchabc=1
              do while (matchabc .gt. 0)
                matchabc=0
                do js=1,nsegslt
                  if (abc(iabc) .eq. segid4(js)(1:1)) matchabc=1
                end do
                if (matchabc .eq. 1) then
                  iabc=iabc+1
                  if (iabc .gt. 62) then
                    print *,'Chain ID character set exhausted'
                    go to 920
                  end if
                else
                  segid4(is)(1:1)=abc(iabc)
                end if
              end do
            end if
          end do
920       do ia=1,nslt
            line(index(ia))(isegcol1:isegcol2)=segid4(isegno(ia))
          end do
          if (iruntyp .ne. iruntypclean) then
            if (iwdiffpdb .eq. -1) call askyn(
     -        'Do you want a PDB file with differing chain IDs',47,1,
     -         -1,iwdiffpdb,000)
            notfnd=iwdiffpdb
            do while (notfnd .gt. 0)
              call openfile(55,0,'chain-modified',14,'new',analfile,
     -          namlena,notfnd,0,1,1,0,0)
            end do
            if (iwdiffpdb .gt. 0) then
              write (55,1000) 'REMARK Chain IDs updated'
              do ia=1,nslt
                write (55,1000) line(index(ia))(1:80)
                if (ia .lt. nslt) then
                  if (isegno(ia+1) .gt. isegno(ia))
     -              write (55,1000)'TER'
                end if
              end do
              write (55,1000) 'END'
              close (55)
            end if
          end if
        end if
      end if
      nmolslt=nsegslt
      nmolsltnoion=nsegslt
      call zeroiti(molresflag,0,numresslt)
      if (ansrun .eq. 'e' .and. ansman .eq. 'r' .or. ansrun .eq. 't')
     -  call setmolres(ifres,ilres,isegno,molresflag,
     -    molsltlim,nrescol,irescol1,irescol2,resnames,numresslt,
     -    nmolslt,nsegslt,nmolsltnoion,minresflag,index,indexa,indexs,
     -    line,maxrsd,maxrec)
      if (inpcrdtyp .le. ioins .and. nconfig .le. 1)
     -  call molarvol(nslt,n,naslv,line,index,irescol1,irescol2,
     -  iresncol1,iresncol2,naa,nna,nnw,nnf,vslt,MAXREC)
      if (nnw .gt. 0 .and. n .eq. nslt) then
        write (6,1255) nnw
        call askstop(1)
      end if
      if (nconfig .le. 1 .and. nslt .gt. 0) then
        print *,'Dimensions of the solute:'
        call extension(c,ih,0,1,nslt,cmin,cmax,c0,1,1,v)
      end if
      if (iruntyp .le. 3) then
        call nnlist(nslt,islvw,naslv,n,iatnum,ifchrg,c,nneig,nneiga,
     -    nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,line,
     -    irescol1,irescol2,inamcol1,inamcol2,index,nconfig,innlist,
     -    molresflag,hblimfac,angmin,0,ibnd,ifgtyp,isegno,ixres,
     -    maxrepconf,0,radtodeg,MAXNEIG,MAXNEIG,MAXRSD,MAXREC)
        if (nconfig .lt. maxrepconf)
     -    call checkprotchir(c,nslt,line,index,ifres,nneig,ineig,
     -      inamcol1,inamcol2,irescol1,irescol2,iresncol1,iresncol2,
     -      -1,-1,nminusinp,nplusinp,dssplab,1,MAXNEIG,MAXRSD,MAXREC)
        call askyn('Do you want to include hydrogens',32,0,1,iihh,10)
        call zeroiti(ih,0,nslt)
        if (iihh .eq. 0) then
          write (6,2056) 'included in'
        else
          write (6,2056) 'excluded from'
          do ia=1,nslt
            if (iatnum(ia) .eq. 1) ih(ia)=1
          end do
        end if
        if (iruntyp .eq. 3) then
          call askyn(
     -      'Can optimization disregard three- and four-bonded atoms',
     -      55,1,1,ino34,11)
          if (ino34 .eq. 1) then
c           Eliminate atoms with more than two neighbours
            ndrop=0
            do ia=1,nslt
              if (iatnum(ia) .gt. 1) then
                nextra=nvalmax(iatnum(ia))-nval(iatnum(ia))
                if (nneig(ia)-iihh*nhneig(ia) .gt. nextra+2) ih(ia)=1
                if (ih(ia) .eq. 1) ndrop=ndrop+1
              end if
            end do
            print *,'Number of atoms dropped as inside ',
     -        '(3 or 4-bonded) atoms=',ndrop
          else
            print *,'No atoms will be dropped for being inside atoms'
          end if
        end if
c       Change ih from 0-1 to a list of atomindices to be used
        nh=0
        do ia=1,nslt
          if (ih(ia) .eq. 1) then
            nh=nh+1
          else
            ih(ia-nh)=ia
          end if
        end do
        if (nh .gt. 0) print *,'Total number of atoms dropped=',nh
        nnh=nslt-nh
      end if
c     Put default marking into line
      do il=ntitlin+1,nlines
        if (marker(inpcrdtyp)(1:1) .eq. ' ' .or.
     -      line(il)(1:lmarker(inpcrdtyp)) .ne.
     -      marker(inpcrdtyp)(1:lmarker(inpcrdtyp)))
     -    line(il)(idcol:idcol)=' '
      end do
      if (ntitlin .gt. 0 .and.(iruntyp .lt. 6 .or.
     -    iruntyp .eq. iruntypclean)) then
        ntitprint=ntitlin
        if (ischarmm(inpcrdtyp) .eq. 1) ntitprint=ntitlin-1
        if (inpcrdtyp .eq. iommod) ntitprint=0
      end if
      if (inpcrdtyp .le. ioins) then
        do ia=1,n
          atw(ia)=aw(iatnum(ia))
        end do
      else
        do ia=1,n
          atw(ia)=1.0
        end do
      end if
      inpcrdtyporg=inpcrdtyp
      if (inpcrdtyp .ge. ioa3pdb .and. iqcol2 .ge. iqcol1) then
        call checkreschargesum(nslt,iresno,isegno,line,index,irescol1,
     -    irescol2,iresncol1,iresncol2,isegcol1,isegcol2,iqcol1,iqcol2,
     -    charge,molsltlim,'residue',7,resnames,ifres,ixres,itemp1,
     -    itemp2,nreschrg,iallzero,iallnonpos,iallnonneg,1,ifixq,
     -    reportqmin,MAXRSD,MAXREC)
        call indexit(indexa,1,nslt,0)
        call celldipole(c,n,nslt,indexa,nslt,charge,1-iallzero,atw,6,0)
      end if
      if (inpcrdtyp .le. ioins) call checknameforAC(nslt,line,index,
     -  inamcol1,inamcol2,MAXREC)
990   if (nconfig .eq. 0) print *
      if (inpcrdtyp .lt. iograsp .and.
     -    (igl .eq. 1 .or. neednnlist .eq. 1)) then
        call zeroiti(ifgtyp,0,MAXREC)
        maxboxcount=0
        call nnlist(nslt,islvw,naslv,n,iatnum,ifchrg,c,nneig,nneiga,
     -    nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,line,
     -    irescol1,irescol2,inamcol1,inamcol2,index,nconfig,innlist,
     -    molresflag,hblimfac,angmin,0,ibnd,ifgtyp,isegno,ixres,
     -    maxrepconf,0,radtodeg,MAXNEIG,MAXNEIG,MAXRSD,MAXREC)
        do ibox=1,maxrec
          if (ifgtyp(ibox) .gt. maxboxcount) maxboxcount=ifgtyp(ibox)
        end do
      end if
      if (innlist .gt. 0 .and. iruntyp .gt. 3 .and.
     -    nconfig .lt. maxrepconf)
     -  call checkprotchir(c,nslt,line,index,ifres,nneig,ineig,inamcol1,
     -    inamcol2,irescol1,irescol2,iresncol1,iresncol2,-1,-1,
     -      nminusinp,nplusinp,dssplab,1,MAXNEIG,MAXRSD,MAXREC)
      nbonddel=0
      if (innlist .gt. 0 .and. nions+nmolres .gt. 0) then
c       Find and delete intermolecular bonds
        do ir=1,numresslt
          if (molresflag(ir) .gt. 0) then
            do ia=ifres(ir),ilres(ir)
              nbdl=0
              do ja=1,nneig(ia)
                if (ixres(ineig(ja,ia)) .ne. ir) then
                  ineig(ja,ia)=-ineig(ja,ia)
                  nbonddel=nbonddel+1
                  nbdl=nbdl+1
                  if (nbonddel .le. 10) write (6,2112) ia,-ineig(ja,ia),
     -               ir,ixres(-ineig(ja,ia))
                end if
              end do
              do while (nbdl .gt. 0)
                nn=nneig(ia)
                do while (ineig(nn,ia) .gt. 0 .and. nn .gt. 1)
                  nn=nn-1
                end do
                if (ineig(nn,ia) .gt. 0) then
                  print *,'PROGRAM ERROR ineig ne 0; ir,ia,nn=',ir,ia,nn
                  nbdl=0
                else
                  inn=-ineig(nn,ia)
                  ineig(nn,ia)=ineig(nneig(ia),ia)
                  nneig(ia)=nneig(ia)-1
                  nbdl=nbdl-1
                  nn=nneig(inn)
                  do while (ineig(nn,inn) .ne. ia .and. nn .gt. 1)
                    nn=nn-1
                  end do
                  ineig(nn,inn)=ineig(nneig(inn),inn)
                  nneig(inn)=nneig(inn)-1
                end if
              end do
            end do
          end if
        end do
      end if
c     Check for atoms too close
      nclose=0
      dmin2=0.2**2
      do ia=1,n
        do ja=1,nneig(ia)
          ina=ineig(ja,ia)
          if (ina .gt. ia) then
            d2=dist2(c(1,ia),c(1,ina))
            if (d2 .lt. dmin2) then
              nclose=nclose+1
              if (inpcrdtyp .le. ioins) then
                write (6,1206) ia,line(index(ia))(inamcol1:inamcol2),
     -           iresno(ia),line(index(ia))(irescol1:irescol2),
     -           ina,line(index(ina))(inamcol1:inamcol2),
     -           iresno(ina),line(index(ina))(irescol1:irescol2),
     -           sqrt(d2)
              else
                write (6,1207) ia,ineig(ja,ia),sqrt(d2)
              end if
            end if
          end if
        end do
      end do
      if (nclose .gt. 0) write (6,1208) nclose,sqrt(dmin2)
      if (nbonddel .gt. 0)
     -  print *,'A total of ',nbonddel,' bonds were deleted'
C@GL      if (igl .eq. 1 .and. inpcrdtyp .lt. iograsp) then
C@GLc       Display  molecule (if not optimizing run)
C@GL        if (iruntyp .gt. 3) then
C@GL          if (wx .eq. 0.0) then
C@GL            if (n .eq. nslt .and. iruntyp .eq. 18) call askyn(
C@GL     -        'Do you want to reorient to the initial orientation',
C@GL     -          50,1,-1,ireorient,0)
C@GL            if (ireorient .eq. 1) then
C@GL102           call getint('Index of the atom to keep fixed',31,
C@GL     -          999999,1,n,iacent,41)
C@GL              if (nneig(iacent) .lt. 2) then
C@GL                print *,'Can not use atom with less than two neighbors'
C@GL                go to 102
C@GL              end if
C@GL              call trnsfr(centgra,c(1,iacent),3)
C@GL              call trnsfr(co,c,3*n)
C@GL            end if
C@GL            call extension(c,ih,nnh,1,n,cmin,cmax,c0,0,0,v)
C@GL            if ((cmin(1)*cmax(1) .gt. 0.0 .or. cmin(2)*cmax(2) .gt. 0.0
C@GL     -          .or. cmin(3)*cmax(3) .gt. 0.0) .and. ireorient .eq. 0)
C@GL     -          then
C@GLc             Origin is away from the system - ask for centering
C@GL              call askyn('Do you want to center the display to (0,0,0)'
C@GL     -          ,44,1,1,icentgra,0)
C@GL              if (icentgra .gt. 0) then
C@GL                do k=1,3
C@GL                  centgra(k)=(cmin(k)+cmax(k))/2.0
C@GL                end do
C@GL                call trnsfr(co,c,3*n)
C@GL              end if
C@GL            end if
C@GL            icg=icentgra+ireorient
C@GL            wx=amax1(abs(cmin(1)-centgra(1)),abs(cmax(1)-centgra(1)))
C@GL            wy=amax1(abs(cmin(2)-centgra(2)),abs(cmax(2)-centgra(2)))
C@GL            wz=amax1(abs(cmin(3)-centgra(3)),abs(cmax(3)-centgra(3)))
C@GL            wx=amax1(5.0,wx,amax1(wy,wz))*1.1
C@GL            wy=wx
C@GL            wz=wx
C@GL            call ortho(-wx,wx,-wy,wy,-wz,wz)
C@GL            wxdr=wx
C@GL          end if
C@GL          if (nconfig .gt. 0) then
C@GL              call setcolor(0)
C@GL              call clear()
C@GL              call setcolor(1)
C@GL              call drawseqn(idseqn,nconfig+1)
C@GL          end if
C@GL          call displaymol(idmol,idaxes,c,co,n,nslt,iatnum,nneig,ineig,
C@GL     -      nhneig,nhbneig,isegno,isc,outfiletmp,namlentmp,icg,centgra,
C@GL     -      nconfig,MAXNEIG)
C@GL        end if
C@GL      end if
888   nconfig=nconfig+1
      if (iruntyp .eq. 2 .or. iruntyp .eq. 3) then
        call askyn('Do you want to fix one axis of the solute',41,1,-1,
     -    i2dopt,12)
        if (i2dopt .gt. 0)
     -    call quiz(ans,i2dopt,'z','to be kept fixed',-16,'axis',
     -      4,0,5,6,igl,000)
      end if
C@GL      wintitl(18:18)=' '
C@GL      call wintit(wintitl,18)
101   if (iruntyp .eq. 0 .or. iruntyp .gt. iruntypclean) then
        print *,'PROGRAM ERROR: invalid run type=',iruntyp
        stop
      end if
c      do ia=1,n
c        write (77,9741) ia,atnames(ia),isegno(ia),iresno(ia),ixres(ia)
c9741    format(i6,' name=',a,' isegno=',i6,' iresno=',i6,' ixres=',i6)
c      end do
c      stop
      go to (100,200,300,400,500,600,700,800,800,9000,9100,9200,9300,
     -  9400,9500,9600,9700,9800,9900,8100,9620,9630,9630,9040,9050,
     -  9060,9610,9640,9650,9660,9670,9680,9685,9690,9690,9690,9200,
     -  9710,999)
     -  iruntyp
c-----Calculating the smallest enclosing sphere
100   write (6,2008)
c     print *,'n,nslt=',n,nslt
      call trnsfr(co,c,3*nslt)
      call compact(c,c,iatnum,ih,nslt,nnh,c0,rmin,rorgext,rorgcom,
     -  indexn,np,nlist,0,cv,MAXREC)
      print *,'Original radius based on x,y,z extensions=',rorgext
      call prtcell(-1,edge,edge_gen,rorgext,vol,nw,1)
      print *,'Original radius based on center-of-mass  =',rorgcom
      call prtcell(-1,edge,edge_gen,rorgcom,vol,nw,1)
      print *,'Minimum radius=',rmin
      call prtcell(-1,edge,edge_gen,rmin,vol,nw,1)
C@GL      if (igl .gt. 0) then
C@GL        if (wx .eq. 0) then
C@GL          wx=1.2*rorgext
C@GL          wy=wx
C@GL          wz=wx
C@GL          call ortho(-wx,wx,-wy,wy,-wz,wz)
C@GL          wxdr=wx
C@GL        end if
C@GL        call setcolor(1)
C@GL        call circ(0.0,0.0,rorgext)
C@GL        call shiftmol(co,n,c0,co,-1.0)
C@GL        call nnlist(nslt,islvw,naslv,n,iatnum,ifchrg,c,nneig,nneiga,
C@GL     -    nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,line,
C@GL     -    irescol1,irescol2,inamcol1,inamcol2,index,nconfig,innlist,
C@GL     -    molresflag,hblimfac,angmin,0,ibnd,ifgtyp,isegno,ixres,
C@GL     -    maxrepconf,0,radtodeg,MAXNEIG,MAXNEIG,MAXRSD,MAXREC)
C@GL        call drawmol(idmol,co,iatnum,isc,n,nslt,nneig,nhneig,ineig,
C@GL     -    isegno,0,MAXNEIG,inpfile,namleni,1,0,2,0,0,centgra,nhbneig,0)
C@GL        call depthcueonoff(1)
C@GL        do i=nlist+1,nlist+np
C@GL          call cmov(co(1,indexn(i)),co(2,indexn(i)),co(3,indexn(i)))
C@GL          call charst("*",1)
C@GLc         call circf(co(1,indexn(i)),co(2,indexn(i)),0.2)
C@GL        end do
C@GL        call depthcueonoff(0)
C@GL        call drawaxes(idaxes,0.05,0)
C@GL        call setlin(2)
C@GL        call setcolor(3)
C@GL        call pushma
C@GL        do ic=1,12
C@GL          call circ(0.0,0.0,rmin)
C@GL          call rotate(150,'y')
C@GL        end do
C@GL        call popmat
C@GL        call setlin(0)
C@GL        call swapbu
C@GL        nstep=0
C@GL        do while (nstep .ge. 0)
C@GL          call askrot(nstep)
C@GL          call setcolor(0)
C@GL          call clear
C@GL          call setcolor(1)
C@GL          call pushma
C@GL          call loadma(matrot0)
C@GL          call circ(0.0,0.0,rorgext)
C@GL          call popmat
C@GL          call drawmol(idmol,co,iatnum,isc,n,nslt,nneig,nhneig,ineig,
C@GL     -      isegno,0,MAXNEIG,inpfile,namleni,1,0,2,0,0,centgra,nhbneig,0)
C@GL        call depthcueonoff(1)
C@GL          call setcolor(3)
C@GL          do i=nlist+1,nlist+np
C@GL            call cmov(co(1,indexn(i)),co(2,indexn(i)),co(3,indexn(i)))
C@GL            call charst("*",1)
C@GLc           call circf(co(1,indexn(i)),co(2,indexn(i)),0.2)
C@GL          end do
C@GL          call depthcueonoff(0)
C@GL          call drawaxes(idaxes,0.05,0)
C@GL          call pushma
C@GL          call depthcueonoff(1)
C@GL          call setcolor(3)
C@GL          call setlin(2)
C@GL          do ic=1,12
C@GL            call circ(0.0,0.0,rmin)
C@GL            call rotate(150,'y')
C@GL          end do
C@GL          call depthcueonoff(0)
C@GL          call setlin(1)
C@GL          call popmat
C@GL          call swapbu
C@GL        end do
C@GL      end if
      call getreal('Planned solvent shell thickness',31,10.0,width,1,34)
      rminw=rmin+width
      print *,'Minimized sphere radius with',width,' A added: R=',rminw
      call prtcell(-1,edge,edge_gen,rminw,volw,nww,1)
      write (6,2001) c0
      if (marker(inpcrdtyp) .ne. '      ') then
        write (iuout,1210) marker(inpcrdtyp),marker(inpcrdtyp),rmin,vol,
     -    marker(inpcrdtyp),nw,marker(inpcrdtyp),width,nww
        ntitlinw=ntitlinw+4
      end if
      if (nslt .lt. n) then
c       Now shift the solvents
        call shiftmol(c(1,nslt+1),n-nslt,c0,c(1,nslt+1),-1.0)
c       do ia=nslt+1,n
c         do k=1,3
c           c(k,ia)=c(k,ia)-c0(k)
c         end do
c       end do
c       And trim the sphere
        if (mod(n-nslt,naslv) .ne. 0) then
          write (6,1212) naslv
        else
          rminw2=rminw**2
          nslvo=(n-nslt)/naslv
          nslv=0
          do ia=nslt+1,n
            if (line(index(ia))(irescol1:irescol2) .ne.
     -          resnamslv(1:nrescol)) then
              print *,'ERROR: Atom ',ia,' is not solvent - ',
     -          'resname: ',resnamslv(1:nrescol)
              stop
            else
c             Solvent found
              if (mod(ia-nslt,naslv) .eq. 1) then
c               Use first atom as the crm
                r2=scprod(c(1,ia),c(1,ia))
                if (r2 .gt. rminw2) then
c                 Solvent is outside the sphere - skip it
                  do j=1,naslv
                    line(index(ia+j-1))(idcol:idcol)=asterisk
                  end do
                  if (inpcrdtyp .eq. ioins) then
                    if (line(index(ia+naslv))(1:3) .eq. 'end')
     -                line(index(ia+naslv))(idcol:idcol)=asterisk
                  end if
                else
c                 Water was in central cell, keep it
                  nslv=nslv+1
                end if
              end if
            end if
          end do
          write (6,1214) nslvo,rminw,nslv
          if (nslv .eq. nslvo) then
            print *,'WARNING: No solvents were outside the sphere'
            call askstop(0)
          else
            write (iuout,1211) marker(inpcrdtyp),nslvo,nslv
            ntitlinw=ntitlinw+1
            nrecdel=nrecdel+(nslvo-nslv)*naslv
c           print *,'naslv,nrecdel=',naslv,nrecdel
          end if
        end if
      end if
      call checkprotchir(c,nslt,line,index,ifres,nneig,ineig,inamcol1,
     -  inamcol2,irescol1,irescol2,iresncol1,iresncol2,nminusinp,
     -  nplusinp,nminus,nplus,dssplab,0,MAXNEIG,MAXRSD,MAXREC)
      go to 999
c-----Optimizing orientation in a bounding cube or rectangle
200   write (6,2003)
      if (n .gt. 1.1*nslt) write (6,2012)
      call getint('Number of optimization attempts requested',41,100,
     -  1,0,nrantry,4)
      call getreal('Tolerance for minimization',26,ftol,ftol,1,0)
      call extension(c,ih,nnh,1,n,xyzmin,xyzmax,centinp,1,0,v)
      call unitmat(bestrot)
      volstart=1.0
      do k=1,3
        edgestart(k)=xyzmax(k)-xyzmin(k)
        bestedge(k)=edgestart(k)
        volstart=volstart*edgestart(k)
      end do
      call trnsfr(co,c,3*n)
      call trnsfr(c1,c,3*n)
      call quiz(ans,ians,'r',' ',0,'box or rectangle',16,0,5,6,igl,0)
      mintyp=ians+1
      itryopt=0
      if (mintyp .eq. 2) then
c       Bounding cube
        edgest=amax1(edgestart(1),edgestart(2),edgestart(3))
        print *,'Initial orientation - edge of enclosing box=',edgest
        edgestart(1)=edgest
        bested=edgest
        do itry=1,nrantry
          call optimizebound(c1,c1,c2,ih,nslt,nnh,n,rotopt,mintyp,
     -      ixyzhex,i2dopt,ftol)
          call extension(c1,ih,nnh,1,n,xyzmin,xyzmax,c0,1,0,v)
          edgemin=amax1(xyzmax(1)-xyzmin(1),xyzmax(2)-xyzmin(2),
     -      xyzmax(3)-xyzmin(3))
          print *,'Trial',itry,' edge of enclosing box=',edgemin
          if (bested .gt. edgemin) then
            call trnsfr(c,c1,3*n)
            bested=edgemin
            if (itry .eq. 1) call trnsfr(bestrot,rotopt,9)
            if (itry .gt. 1) call matprod(rotopt,rot,bestrot)
            itryopt=itry
          end if
          call ranort(rot,i2dopt)
          call rotate_c(co,n,rot,c1,'ORT_OPT',7)
          if (itry .le. 200) voltry(itry)=edgemin**3
        end do
        do k=1,3
          bestedge(k)=bested
        end do
        bestvol=bested**3
        write (6,2104) ' === ',bested
        write (iuout,2104) marker(inpcrdtyp),bested
        ipbco=1
      else
c       Bounding rectangle
        call askyn('Do you want to select the longest axis',38,1,-1,
     -    longax,000)
        if (longax .gt. 0)
     -    call quiz(ans,longax,'x','Longest',7,'axis',
     -      4,0,5,6,igl,000)
        bestvol=volstart
        write (6,2102) edgestart,volstart
        do itry=1,nrantry
          call optimizebound(c1,c1,c2,ih,nslt,nnh,n,rotopt,mintyp,
     -      ixyzhex,i2dopt,ftol)
          call extension(c1,ih,nnh,1,n,xyzmin,xyzmax,c0,1,0,v)
          volcurr=1.0
          do k=1,3
            edge(k)=xyzmax(k)-xyzmin(k)
            volcurr=volcurr*edge(k)
          end do
          write (6,2100) itry,edge,volcurr
          if (bestvol .gt. volcurr) then
            call trnsfr(c,c1,3*n)
            bestvol=volcurr
            call trnsfr(bestedge,edge,3)
            if (itry .eq. 1) call trnsfr(bestrot,rotopt,9)
            if (itry .gt. 1) call matprod(rotopt,rot,bestrot)
            itryopt=itry
          end if
          call ranort(rot,i2dopt)
          call rotate_c(co,n,rot,c1,'ORT_OPT',7)
          if (itry .le. 200) voltry(itry)=volcurr
        end do
        if (longax .gt. 0) call alignlongax(c,n,bestedge,bestrot,longax)
        write (6,2101) ' ===',' === Optimum: ',bestedge,bestvol,nslt
        write (iuout,2101)
     -    marker(inpcrdtyp),marker(inpcrdtyp),bestedge,bestvol,nslt
        write (iuout,2105)
     -    marker(inpcrdtyp),(bestedge(k)+30.0,k=1,3),
     -    marker(inpcrdtyp),(-bestedge(k)/2.0-10.0,bestedge(k)/2.0+10.0,
     -    k=1,3)
        if (itryopt .eq. 0) write (6,2026)
        if (itryopt .gt. 0) write (6,2027) itryopt
        ipbco=2
      end if
      call trystat(bestvol,voltry,nrantry,'cell volume',11)
      write (6,2072) ((bestrot(i,j),j=1,3),i=1,3)
      call extension(c,ih,nnh,1,n,xyzmin,xyzmax,c0,0,0,v)
      savesym='TRRT'
      if (abs(c0(1))+abs(c0(2))+abs(c0(3)) .ne. 0.0) then
        call askyn('Do you want to center the system to (0,0,0)',
     -    43,1,1,icent,0)
        if (icent .eq. 1) then
          call shiftmol(c,n,c0,c,-1.0)
          call shiftmol(co,n,centinp,co,-1.0)
          write (6,2074) c0
          if (marker(inpcrdtyp) .ne. '      ') then
            write (iuout,2075) marker(inpcrdtyp), marker(inpcrdtyp),
     -        savesym,'t',c0
            ntitlinw=ntitlinw+2
          end if
        end if
        call zeroit(centinp,3)
      end if
      if (marker(inpcrdtyp) .ne. '      ') then
        write (iuout,2073) marker(inpcrdtyp),
     -    (marker(inpcrdtyp),savesym,'r',i,(bestrot(k,i),k=1,3),i=1,3)
        ntitlinw=ntitlinw+4
      end if
C@GL      if (igl .gt. 0) then
C@GL        call nnlist(nslt,islvw,naslv,n,iatnum,ifchrg,c,nneig,nneiga,
C@GL     -    nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,line,
C@GL     -    irescol1,irescol2,inamcol1,inamcol2,index,nconfig,innlist,
C@GL     -    molresflag,hblimfac,angmin,0,ibnd,ifgtyp,isegno,ixres,
C@GL     -    maxrepconf,0,radtodeg,MAXNEIG,MAXNEIG,MAXRSD,MAXREC)
C@GL        call setcolor(0)
C@GL        call clear
C@GL        call swapbu
C@GL        call setcolor(0)
C@GL        call clear
C@GL        call drawpbc(edgestart,ipbco,ixyzhex,centinp,0,idpbc,4,5,
C@GL     -    0,rot,1.8,0)
C@GL        call drawaxes(idaxes,0.05,0)
C@GL        call drawmol(idmol,co,iatnum,isc,n,nslt,nneig,nhneig,ineig,
C@GL     -    isegno,0,MAXNEIG,inpfile,namleni,1,0,0,0,0,centgra,nhbneig,0)
C@GL        call drawpbc(bestedge,ipbco,ixyzhex,centinp,1,idpbcopt,3,5,
C@GL     -    0,rot,1.8,0)
C@GL        call drawmol(idmolopt,c,iatnum,isc,n,nslt,nneig,nhneig,ineig,
C@GL     -    isegno,0,MAXNEIG,inpfile,namleni,2,1,0,0,0,centgra,nhbneig,0)
C@GL        call setcolor(5)
C@GL        call swapbu
C@GL        nstep=0
C@GL        do while (nstep .ge. 0)
C@GL          call askrot(nstep)
C@GL          call setcolor(0)
C@GL          call clear
C@GL          call setcolor(4)
C@GL          call drawpbc(edgestart,ipbco,ixyzhex,centinp,1,idpbc,4,5,
C@GL     -      0,rot,1.8,0)
C@GL          call drawaxes(idaxes,0.05,0)
C@GL          call drawmol(idmol,co,iatnum,isc,n,nslt,nneig,nhneig,ineig,
C@GL     -      isegno,0,MAXNEIG,inpfile,namleni,1,0,0,0,0,centgra,nhbneig,0)
C@GL          call drawpbc(bestedge,ipbco,ixyzhex,centinp,1,idpbcopt,3,
C@GL     -      0,rot,5,1.8,0)
C@GL          call drawmol(idmolopt,c,iatnum,isc,n,nslt,nneig,nhneig,ineig,
C@GL     -      isegno,0,MAXNEIG,inpfile,namleni,2,0,0,0,0,centgra,nhbneig,0)
C@GL          call swapbu
C@GL        end do
C@GL      end if
      call checkprotchir(c,nslt,line,index,ifres,nneig,ineig,inamcol1,
     -  inamcol2,irescol1,irescol2,iresncol1,iresncol2,nminusinp,
     -  nplusinp,nminus,nplus,dssplab,0,MAXNEIG,MAXRSD,MAXREC)
      go to 999
c-----Optimizing orientation in a periodic cell
300   write (6,2007)
      if (iheadnode .eq. 1) write (6,1205)
      if (n .gt. 1.1*nslt) then
         write (6,2012)
         call askstop(0)
      end if
      call unitmat(bestrot)
      call extension(c,ih,nnh,1,n,cmin,cmax,c0,1,0,v)
      call pbctype(ioppbc,npbc,ixyzhex,1,igl)
      if (ioppbc .eq. 9) then
        print *,'This cell type is not implemented for orientational ',
     -    'optimization'
        stop
      end if
      if (ioppbc .eq. 2) then
        call askyn('Do you want to select the longest axis',38,1,-1,
     -    longax,000)
        if (longax .gt. 0)
     -    call quiz(ans,longax,'x','Longest',7,'axis',
     -      4,0,5,6,igl,000)
      end if
      ireduce=0
      if (ioppbc .eq. 5 .or. ioppbc .eq. 0) then
        print *,'NOTE: this type of cell has to be of fixed size'
      else
        call askyn('Do you want to use a fixed cell',31,0,-1,ireduce,13)
      end if
      if (ireduce .eq. 0) then
        call pbcsize(ioppbc,edge,npbc)
        closlim=0.0
        print *,'Optimal orientation will be found in a cell,'
        call prtcell(ioppbc,edge,edge_gen,0.0,volorg,nworg,1)
      else
        call getreal('Smallest image-image distance requested',39,
     -    15.0,closlim,1,13)
        write (6,2055) closlim
        call getedge(c,c,ih,n,nnh,c0,edge,edge_gen,ioppbc,npbc,ireduce,
     -    cell,ncell,cellalt,ixyzhex,closlim,indexn,indexo,cv,MAXREC)
      end if
301   call crorgn(edge,edge_gen,ioppbc,3,ncell,cell,cellalt,
     -  ixyzhex,rinscr,rcirc)
      closorg=distminimg(c,ih,n,nnh,edge,ioppbc,cell,ncell,ixyzhex,
     -  inno,jnno)
      if (ireduce .ne. 0 .and. closorg. lt. closlim) then
c       Initial cell guess is inadequate - increase cell sizes
        do i=1,npbc
          edge(i)=edge(i)*(closlim/closorg)**(1.0/3.0)*1.01
        end do
        go to 301
      end if
      call getint('Number of optimization attempts requested',41,100,
     -   1,0,nrantry,4)
      call getreal('Tolerance for minimization',26,ftol,ftol,1,0)
      call trnsfr(edgeorg,edge,npbc)
      call trnsfr(edgeopt,edge,npbc)
      if (ireduce .eq. 1) then
        print *,'=== Finalized starting cell:'
        call prtcell(ioppbc,edgeorg,edge_gen,0.0,volorg,nworg,1)
      else
        call extension(c,ih,nnh,1,n,cmin,cmax,c0,1,0,v)
        call shiftmol(c,n,c0,c,-1.0)
      end if
      write (6,2001) c0
      volopt=volorg
      write (6,2006) closorg,inno,jnno
      call trnsfr(co,c,3*n)
C@GL      if (igl .eq. 1) then
C@GL        call nnlist(nslt,islvw,naslv,n,iatnum,ifchrg,c,nneig,nneiga,
C@GL     -    nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,line,
C@GL     -    irescol1,irescol2,inamcol1,inamcol2,index,nconfig,innlist,
C@GL     -    molresflag,hblimfac,angmin,0,ibnd,ifgtyp,isegno,ixres,
C@GL     -    maxrepconf,0,radtodeg,MAXNEIG,MAXNEIG,MAXRSD,MAXREC)
C@GL        call drawpbc(edge,ioppbc,ixyzhex,centinp,0,idpbc,1,5,
C@GL     -    0,rot,1.8,0)
C@GL        call drawmol(idmol,c,iatnum,isc,n,nslt,nneig,nhneig,ineig,isegno,
C@GL     -    0,MAXNEIG,inpfile,namleni,3,0,0,0,0,centgra,nhbneig,0)
C@GL        call drawaxes(idaxes,0.05,0)
C@GL        call swapbu
C@GL      end if
      print *,'=== Initial optimization ... wait'
      call optimize(c,c,c2,ih,nslt,nnh,n,edge,edgeopt,edge_gen,ioppbc,
     -  npbc,ireduce,cell,ncell,cellalt,volopt,nwnew,closlim,
     -  closinp,closopt,bestrot,ixyzhex,in1,jn1,1,nunsat,nstickout,
     -  i2dopt,ftol)
      itryopt=0
      nimproved=0
      do ir=1,nrantry
        write (6,2038) ir
c       print *,'EDGEOPT=',edgeopt
c       print *,'CLOSOPT=',CLOSopt
        if (ir .eq. 1 .and. (ioppbc .eq. 4 .or. ioppbc .eq. 5)) then
c         First 'random' orientation is a rotation along the X axis by 90 deg
          write (6,2040) xyz(ixyzhex(1))
          call rot90(ixyzhex(1),rot)
        else
          call ranort(rot,i2dopt)
        end if
        call rotate_c(co,n,rot,c1,'ORT_OPT',7)
        call reoptimize(c1,c,c2,ih,nslt,nnh,n,edge,edgeopt,edge_gen,
     -    ioppbc,npbc,ireduce,cell,cellalt,ncell,volopt,volnew,closlim,
     -    closopt,closest,rot,bestrot,inopt,jnopt,inn,jnn,ixyzhex,
     -    iunsat,istickout,improved,i2dopt,ftol)
        nstickout=nstickout+istickout
        nunsat=nunsat+iunsat
        if (improved .eq. 1) then
          nimproved=nimproved+1
          itryopt=ir
        end if
        if (ir .le. 200) then
          voltry(ir)=volnew
          dimtry(ir)=closest
        end if
      end do
      print *
      print *,'INPUT CONFORMATION:'
      call prtcell(ioppbc,edgeorg,edge_gen,0.0,volorg,nworg,1)
      write (6,2006) closorg,inno,jnno
      print *,'OPTIMIZED CONFORMATION:'
      if (itryopt .eq. 0) write (6,2026)
      if (itryopt .gt. 0) write (6,2027) itryopt
      if (inopt .eq. 0) then
        inopt=inn
        jnopt=jnn
      end if
      closopt=distminimg(c,ih,n,nnh,edgeorg,ioppbc,cell,ncell,ixyzhex,
     -  inopt,jnopt)
      if (ireduce .eq. 1) then
        write (6,2019) 'in the starting cell ',closopt,inopt,jnopt
        call prtcell(ioppbc,edgeopt,edge_gen,0.0,vol,nw,2)
        closopm=distminimg(c,ih,n,nnh,edgeopt,ioppbc,cell,ncell,ixyzhex,
     -    inopt,jnopt)
        write (6,2019) 'in the optimized cell',closopm,inopt,jnopt
        write (6,2106) nunsat
        if (nunsat .eq. nrantry+1) write (6,2107)
      else
        write (6,2019) 'in the inputted cell',closopt,inopt,jnopt
      end if
      if (nstickout .gt. 0) write (6,2076) nstickout
      call checkwall(ioppbc,edgeopt,cmin,cmax,c,cell,1,ncell,
     -  ih,nslt,nnh,walldist)
      if (ioppbc .eq. 1 .or. ioppbc .eq. 2) then
c       Rectangle or cube
        if (walldist .lt. 0.0) then
          write (6,2035) ' by ',-walldist
        else
          write (6,2036) walldist
        end if
      else if (walldist .lt. 0.0) then
        write (6,2035)
        call askstop(0)
      end if
      if (ireduce .eq. 0) call trystat(closest,dimtry,nrantry,
     -  'image-image distance',20)
      if (ireduce .eq. 1) call trystat(volopt,voltry,nrantry,
     -  'cell volume',11)
      if (nimproved .eq. 0) then
       nw=nworg
       vol=volorg
      end if
      if (ireduce .eq. 1) then
        print *,'Optimized edge parameters=',edgeopt
        call crorgn(edgeopt,edge_gen,ioppbc,3,ncell,cell,cellalt,
     -    ixyzhex,rinscr,rcirc)
        closchk=distminck(c,ih,n,nnh,cell,cellalt,ioppbc,ncell,
     -    iclosechk,jclosechk)
        dev=abs(closchk-closopm)
      else
        closchk=distminck(c,ih,n,nnh,cell,cellalt,ioppbc,ncell,
     -    iclosechk,jclosechk)
        dev=abs(closchk-closopt)
      end if
      write (6,2081) dev
      if (dev .gt. 0.1) then
        if (dev .le. 0.5) then
          print *,'WARNING: image distance discrepancy ',
     -      'is too large (possible program error)'
          call askstop(0)
        else
          print *,'PROGRAM ERROR: too large image distance discrepancy'
        end if
        write (6,2019) 'recomputed',closchk,iclosechk,jclosechk
      end if
      call symfit(c,co,c1,n,ioppbc,bestrot)
c     Check rotation
      call rotate_c(co,n,bestrot,c1,'ORT_OPT',7)
      dev=0.0
      do ia=1,n
        do k=1,3
          if (abs(c(k,ia)-c1(k,ia)) .gt. dev) dev=abs(c(k,ia)-c1(k,ia))
        end do
      end do
      write (6,2079) dev
c     Make the longax axis the longest
      if (ireduce .eq. 1 .and. ioppbc .eq. 2)
     -  call alignlongax(c,n,bestedge,bestrot,longax)
      if (ioppbc .eq. 7) then
c       Rotate to Amber TO convention
        call rotate_c(c,n,torot_ac,c,'ORT_OPT',7)
        call matprod(torot_ac,bestrot,bestrot)
      end if
      if (ireduce .eq. 0) then
        savesym='RTTR'
        write (6,2074) c0
      else
        savesym='TRRT'
      end if
      write (6,2072) ((bestrot(i,j),j=1,3),i=1,3)
      if (marker(inpcrdtyp) .ne. '      ') then
        write (iuout,1230) marker(inpcrdtyp),marker(inpcrdtyp),
     -    cellname(ioppbc)
        if (ireduce .eq. 1)
     -    write (iuout,1232) marker(inpcrdtyp),closlim
        write (iuout,1233) marker(inpcrdtyp),vol,nw,marker(inpcrdtyp),
     -    (edgeopt(k),k=1,npbc)
        if (ioppbc .eq. 4 .or. ioppbc .eq. 5) then
          write (iuout,1231) marker(inpcrdtyp),yz(ioppbc)
          ntitlinw=ntitlinw+1
        end if
        if (ireduce .eq. 0) then
          write (iuout,2075) marker(inpcrdtyp),marker(inpcrdtyp),
     -      savesym,'t',c0
          ntitlinw=ntitlinw+1
        end if
        write (iuout,2073) marker(inpcrdtyp),
     -    (marker(inpcrdtyp),savesym,'r',i,(bestrot(k,i),k=1,3),i=1,3)
        ntitlinw=ntitlinw+4
      end if
C@GL      if (igl .gt. 0) then
C@GL        call setcolor(0)
C@GL        call clear
C@GL        call drawpbc(edgeorg,ioppbc,ixyzhex,centinp,0,idpbc,1,5,
C@GL     -    0,rot,1.8,0)
C@GL        call drawmol(idmol,co,iatnum,isc,n,nslt,nneig,nhneig,ineig,
C@GL     -    isegno,0,MAXNEIG,inpfile,namleni,3,0,0,0,0,centgra,nhbneig,0)
C@GL        call drawaxes(idaxes,0.05,0)
C@GL        call drawpbc(edgeopt,ioppbc,ixyzhex,centinp,1,idpbcopt,2,5,
C@GL     -    0,rot,1.8,0)
C@GL        call drawmol(idmolopt,c,iatnum,isc,n,nslt,nneig,nhneig,ineig,
C@GL     -    isegno,0,MAXNEIG,inpfile,namleni,4,0,0,1,0,centgra,nhbneig,0)
C@GL        call setcolor(5)
C@GL        call drawnear(idimg,c,n,cell,ncell,inopt,jnopt)
C@GL        call swapbu
C@GL        nstep=0
C@GL        do while (nstep .ge. 0)
C@GL          call askrot(nstep)
C@GL          call setcolor(0)
C@GL          call clear
C@GL          call setcolor(1)
C@GLCCCC      call drawpbc(edge,ioppbc,ixyzhex,centinp,0,idpbc,1,5,
C@GLCCCC -      0,rot,1.8,0)
C@GL          call drawmol(idmol,co,iatnum,isc,n,nslt,nneig,nhneig,ineig,
C@GL     -    isegno,0,MAXNEIG,inpfile,namleni,3,0,0,0,0,centgra,nhbneig,0)
C@GL          call drawaxes(idaxes,0.05,0)
C@GLCCCC      call drawpbc(edgeopt,ioppbc,ixyzhex,centinp,1,idpbcopt,2,
C@GLCCCC -      5,0,rot,1.8,0)
C@GLC???          If two PBC's are drawn, rotation is ignored ???
C@GL          call drawpbc(edgeopt,ioppbc,ixyzhex,centinp,0,idpbcopt,2,
C@GL     -      0,rot,5,1.8,0)
C@GL          call drawmol(idmolopt,c,iatnum,isc,n,nslt,nneig,nhneig,ineig,
C@GL     -    isegno,0,MAXNEIG,inpfile,namleni,4,0,0,1,0,centgra,nhbneig,0)
C@GL          call setcolor(5)
C@GL          call drawnear(idimg,c,n,cell,ncell,inopt,jnopt)
C@GL          call swapbu
C@GL        end do
C@GL      end if
      call checkprotchir(c,nslt,line,index,ifres,nneig,ineig,inamcol1,
     -  inamcol2,irescol1,irescol2,iresncol1,iresncol2,nminusinp,
     -  nplusinp,nminus,nplus,dssplab,0,MAXNEIG,MAXRSD,MAXREC)
      go to 999
c-----Fix distorted waters
400   roh=0.9572
      ahohd=104.52
      nah2o=3
      call makewat(ch2o,nah2o,roh,ahohd,radtodeg)
      call grelcd(ch2o,crh2o,nah2o,awh2o)
      write (6,2015) resnamslv
      write (6,2014) roh,ahohd
      if (marker(inpcrdtyp) .ne. '      ') then
        write (iuout,1240) marker(inpcrdtyp),marker(inpcrdtyp),roh,ahohd
        ntitlinw=ntitlinw+2
      end if
c     Now scan the atoms and change the waters
      nwat=0
      rohsum=0.d0
      rohsum2=0.d0
      ahohsum=0.d0
      ahohsum2=0.d0
      rohmin=1000.0
      rohmax=0.0
      ahohmin=1000.0
      ahohmax=0.0
      next_dist=0
      do i=1,n
        if (line(index(i))(irescol1:irescol2) .eq. resnamslv(1:nrescol))
     -                                                             then
          nob=idcol
          call nextchar(line(index(i)),nob,132)
          if (line(index(i))(nob:nob) .eq. 'O') then
            nwat=nwat+1
c           write (6,1990) ((c(k,i-1+j),k=1,3),j=1,3)
            call angdistw(c(1,i),c(1,i+1),c(1,i+2),roh1,roh2,rhh,ahoh)
            if (amin1(roh1,roh2) .lt. rohmin) rohmin=amin1(roh1,roh2)
            if (amax1(roh1,roh2) .gt. rohmax) rohmax=amax1(roh1,roh2)
            if (ahoh .lt. ahohmin)  ahohmin=ahoh
            if (ahoh .gt. ahohmax)  ahohmax=ahoh
            rohsum=rohsum+roh1+roh2
            rohsum2=rohsum2+roh1**2+roh2**2
            ahohsum=ahohsum+ahoh
            ahohsum2=ahohsum2+ahoh**2
            call fixup(crh2o,c(1,i),c(1,i),naslv,awh2o)
c           write (6,1990) ((c(k,i-1+j),k=1,3),j=1,3)
c1990       format('c=',/,(3f10.5))
            if (roh1 .gt. 2.0 .or. roh2 .gt. 2.0) then
              write (6,2028) nwat,roh1,roh2
              next_dist=next_dist+1
            end if
          end if
        end if
      end do
      write (6,2011) resnamslv,nwat
      if (nwat .gt. 0.0) then
        roh=rohsum/nwat/2.0
        ahoh=ahohsum/nwat
        roh2=rohsum2/nwat/2.0d0
        ahoh2=ahohsum2/nwat
        rohsd=sqrt(abs(roh2-roh**2))
        ahohsd=180.0*sqrt(abs(ahoh2-ahoh**2))/pi
        ahoh=ahoh*180.0/pi
        ahohmin=ahohmin*180.0/pi
        ahohmax=ahohmax*180.0/pi
        write (6,2013) roh,rohsd,ahoh,ahohsd,
     -    rohmin,rohmax,ahohmin,ahohmax
        go to 999
      end if
      if (next_dist .gt. 0) write (6,*) 'WARNING: ',next_dist,
     -  ' waters had O-H bondlength > 2A'
      close(10)
      close(20)
      go to 91
c-----Trimming solvents outside a periodic box
500   if (nslt .lt. n .and. nslt .gt. 0) then
        print *,'Sizes of the solute only:'
        call extension(c,ih,0,1,nslt,cmin,cmax,centinp,1,1,v)
        print *,'Sizes of the full system (solute+solvent):'
      else if (nslt .eq. n) then
        write (6,1215) resnamslv
        go to 91
      end if
      call extension(c,ih,0,1,n,cmin,cmax,centinp,1,1,v)
      call setpbccell(' ',0,edge,edge_gen,cell,ncell,cellalt,
     -  ixyzhex,npbc,ioppbc,iusepbc,vol,nw,rinscr,rcirc,1,igl)
      call quiz(ans,iansrun,'o',' ',0,'origin of the modified cell',27,
     -  0,5,6,igl,0)
      if (ans .eq. 'o') then
        call zeroit(centinp,3)
      else if (ans .eq. 'c') then
        do k=1,3
          call getreal('Component '//xyz(k),10+1,0.0,centinp(k),0,0)
        end do
      else if (ans .eq. 'a') then
        call getint('Atom index of the atom to be at the center',42,
     -    1,1,n,iacent,0)
        call trnsfr(centinp,c(1,iacent),3)
      end if
      write (6,2066) centinp
      if (abs(centinp(1))+abs(centinp(2))+abs(centinp(3)) .ne. 0) then
        call askyn(
     -    'Do you want the trimmed system to recenter to (0,0,0)',
     -    53,1,1,icent,35)
        if (icent .eq. 1) then
          call shiftmol(c,n,centinp,c,-1.0)
          call zeroit(centinp,3)
        else if (ioppbc .le. 8) then
          call shiftmol(cell,ncell,centinp,cell,+1.0)
        else
          call trnsfr(cell,centinp,3)
        end if
      end if
      if (ioppbc .gt. 0 .and. ioppbc .lt. 9) then
        call askyn('Do you want to calculate closest image distances',
     -     48,1,1,ians,5)
        if (ians .eq. 1) then
          if (nslt .gt. 1000) print *,'Calculating ... Wait'
          call indexit(ih,1,nslt,0)
          closorg=distminimg(c,ih,nslt,nslt,edge,ioppbc,cell,ncell,
     -      ixyzhex,inno,jnno)
          print *,'Closest image-image distance=',closorg
        end if
      end if
C@GL      if (igl .eq. 1) then
C@GL        call setcolor(0)
C@GL        call clear
C@GL        call drawpbc(edge,ioppbc,ixyzhex,centinp,0,idpbc,1,5,
C@GL     -    0,rot,1.8,0)
C@GL        call drawmol(idmol,c,iatnum,isc,n,nslt,nneig,nhneig,ineig,isegno,
C@GL     -    0,MAXNEIG,inpfile,namleni,0,0,0,0,0,centgra,nhbneig,0)
C@GL        call drawaxes(idaxes,0.05,0)
C@GL        call swapbu
C@GL        nstep=0
C@GL        do while (nstep .ge. 0)
C@GL          call askrot(nstep)
C@GL          call setcolor(0)
C@GL          call clear()
C@GL          call drawpbc(edge,ioppbc,ixyzhex,centinp,0,idpbc,1,5,
C@GL     -      0,rot,1.8,0)
C@GL          call drawmol(idmol,c,iatnum,isc,n,nslt,nneig,nhneig,ineig,
C@GL     -      isegno,0,MAXNEIG,inpfile,namleni,0,0,0,0,0,centgra,nhbneig,0)
C@GL          call drawaxes(idaxes,0.05,0)
C@GL         call swapbu
C@GL        end do
C@GL      end if
      if (marker(inpcrdtyp) .ne. '      ') then
        write (iuout,1250) marker(inpcrdtyp),resnamslv,
     -    marker(inpcrdtyp),cellname(ioppbc),marker(inpcrdtyp),
     -    (edge(k),k=1,npbc)
        write (iuout,1251) marker(inpcrdtyp),centinp
        ntitlinw=ntitlinw+4
      end if
      nslv=0
      nslt=0
      ia=0
      call distminsetup(edge,ioppbc)
      nsltout=0
      do i=1,n
        ia=ia+1
        if (line(index(ia))(irescol1:irescol2) .ne.
     -      resnamslv(1:nrescol)) then
          nslt=nslt+1
          call distmincalc(ioppbc,cell,ncell,ixyzhex,edge,
     -      c(1,ia),c(2,ia),c(3,ia),icmin,rmin2)
          ioutside=0
          if (icmin .gt. 1 .and. ioppbc .le. 8) ioutside=1
          if (rmin2 .gt. edge(1)**2 .and. ioppbc .eq. 9) ioutside=1
          if (ioutside .gt. 0) then
            if (inpcrdtyp .le. ioins ) then
              write (6,2025) ia,line(index(ia))(irescol1:irescol2),
     -          line(index(ia))(inamcol1:inamcol2)
            else
              write (6,2018) ia
            end if
            nsltout=nsltout+1
          end if
        else
c         Solvent found
c         Use first atom as the crm
          call distmincalc(ioppbc,cell,ncell,ixyzhex,edge,
     -      c(1,ia),c(2,ia),c(3,ia),icmin,rmin2)
          ioutside=0
          if (icmin .gt. 1 .and. ioppbc .le. 8) ioutside=1
          if (rmin2 .gt. edge(1)**2 .and. ioppbc .eq. 9) ioutside=1
          if (ioutside .gt. 0) then
c           Solvent is outside cell - skip it
            nrecdel=nrecdel+naslv
            do j=1,naslv
              line(index(ia+j-1))(idcol:idcol)=asterisk
            end do
c           if (inpcrdtyp .eq. ioins .and.
c    -          line(index(ia+naslv-1)+1)(1:3) .eq. 'end') then
c                 line(index(ia+naslv-1)+1)(idcol:idcol)=asterisk
c                 ndelimdel=ndelimdel+1
c           end if
          else
c           Solvent was in central cell, keep it
            nslv=nslv+1
          end if
          ia=ia+naslv-1
        end if
        if (ia .ge. n) go to 550
      end do
550   print *,nslv,' solvents were found inside the cell'
      print *,nslt,' non-solvent atoms were found'
      print *,nsltout,' non-solvent atoms were found outside the cell'
      go to 999
c-----Create input file for MMC
600   if (inpcrdtyp .le. ioins) then
        call askyn('Do you want to sort the atoms',29,1,-1,ians,0)
        if (ians .eq. 1)
     -    call sortatres(line,n,index,indexn,indexo,nhbneig,nneiga,
     -      ncneig,nsneig,npneig,iresncol1,iresncol2,isegno,'      ',
     -      inpcrdtyp,nconfig,20,maxrepconf,MAXREC)
c         nhbneig,nneiga - just  for  working space
      end if
      call askyn('Do you want to center the system',32,1,1,ians,0)
      if (ians .eq. 1) then
c       Center the system
        call extension(c,ih,0,1,nslt,cmin,cmax,shiftmmc,1,1,v)
        write (6,1264) shiftmmc
        call shiftmol(c,n,shiftmmc,c,-1.0)
        write (6,2001) c0
      end if
c     Generate output filenames
      call changeext(outfile,outfiletmp,namleno,namlentmp,'slt',3,0,0)
      print *,'MMC solute description file: ',outfiletmp(1:namlentmp)
      call openfile(21,0,'MMC .slt',8,'new',outfiletmp,namlentmp,notfnd,
     -  0,1,1,0,0)
      immccrd=0
      if (n .gt. nslt)
     -  call askyn('Do you want an MMC .crd file too',32,1,-1,immccrd,0)
      if (immccrd .eq. 1) then
c       Create starting coordinate file
        call changeext(outfile,outfiletmp,namleno,namlenc,'crd',3,0,0)
        print *,'MMC coordinate file: ',outfiletmp(1:namlenc)
        call openfile(iuout,0,' ',1,'new',outfiletmp,namlenc,notfnd,
     -    0,1,1,0,0)
        do ia=1,n
          write (iuout,1104) (c(k,ia),k=1,3)
        end do
        write (iuout,1265) edge,(n-nslt)/naslv
      end if
      iseg80=0
      if (ipotcol1*iqcol1 .gt. 0) then
        mmcformat=1
      else
        call quiz(ans,ians,'t',' ',0,'conversion type',15,0,5,6,igl,0)
        if (ans .eq. 'a' .or. ans .eq. 'A') then
          print *,'Atomic numbers will be used'
          mmcformat=3
          if (logfile .gt. 0) write (logfile,1000) 'a'
        else
          if (logfile .gt. 0) write (logfile,1000) 't'
          mmcformat=2
          igroups=0
          if (inpcrdtyp .eq. iocha) call askyn(
     -       'Do you want to put the segmentid into cols 77-80',
     -        48,1,-1,iseg80,0)
        end if
      end if
      call askyn(
     -  'Do you want to put residue mumbers as proximity group indices',
     -   61,1,-1,ipxgrw,0)
      ires=0
      rn='****'
      rnu='******'
      potnam='      '
      resnam='        '
      nunknown=0
      nunknownr=0
      qsum=0.0
      qsumgr=0.0
      qslt=0.0
      natprt=0
      gcent=' '
      igrold=0
      ngroups=1
      nresgr=0
      if (mmcformat .ne. 2) write (21,1007) nslt
      call check23(line,index,nslt,inamcol1,inamcol2,nnamcol,MAXREC)
      if (nconfig .eq. 1) iconvsource=3
      if (nconfig .eq. 1 .and. mmcformat .le. 2) then
        if (mmcformat .eq. 1) then
          print *,'Atom type and partial charge information is used ',
     -      'from the input structure'
        else
          call quiz(ans,iconvsource,' ',' ',0,
     -      'Molecule information source',27,0,5,6,igl,00)
          if (ans .eq. 's') then
c           Charmm RTF file(s) or Simulaid-formatted conversion files
            call getconvdat(2,5,5,nconvdat,iconvtyp,n,line,index,
     -        inamcol1,inamcol2,nnamcol,irescol1,irescol2,igrpinfo,
     -        MAXREC)
            call askyn('Do you want to break residues into groups',41,
     -        1,-1,igroups,14)
          end if
        end if
      end if
      nacol=min0(4,inamcol2-inamcol1+1)
      inamcol2a=inamcol1+nacol-1
      nawarn=0
      if (iconvsource .eq. 1) then
c       Charmm PSF file Xplor format
        PSFortop='PSF'
601     namlenn=0
        call openfile(61,0,'PSF',3,'old',inpfiletmp,namlenn,notfnd,
     -      3,1,1,0,0)
        call find_natspsf(61,liner,nerr,n,natspsf)
        if (nerr .gt. 0) go to 601
        ierrpsf=1
        ic=0
        do ia=1,min0(nslt,natspsf)
          potnam='      '
          call blankout(liner,1,80)
          call blankout(linewr,1,80)
          read (61,1000,end=603) liner
          ic=1
c         Sequence #
          call nextstring(liner,ic,ic1,ic2,80)
c         Segment id
          call nextstring(liner,ic,ic1,ic2,80)
c         Residue id
          call nextstring(liner,ic,ic1,ic2,80)
          read (liner(ic1:ic2),*,err=603) ires
c         Residue name
          call nextstring(liner,ic,ic1,ic2,80)
          resnam='        '
          resnam(1:ic2-ic1+1)=liner(ic1:ic2)
c         Atom name
          call nextstring(liner,ic,ic1,ic2,80)
          atomnam='        '
          atomnam(1:ic2-ic1+1)=liner(ic1:ic2)
          if (atomnam(1:nacol) .ne. line(index(ia))(inamcol1:inamcol2a))
     -      then
            nawarn=nawarn+1
            if (nawarn .le. 100) then
              write (6,1256) 'PSF',ia,
     -          line(index(ia))(inamcol1:inamcol2a),'PSF',
     -          atomnam(1:nacol)
              anamin1=atomnam(1:4)
              anamin2=line(index(ia))(inamcol1:inamcol1+3)
              call regularpdb(anamin1,anamout1,1)
              call regularpdb(anamin2,anamout2,1)
              if (anamout1 .eq. anamout2) write (6,1258)
            end if
          end if
c         Potential type
          call nextstring(liner,ic,ic1,ic2,80)
          potnam(1:ic2-ic1+1)=liner(ic1:ic2)
c         Charge
          call nextstring(liner,ic,ic1,ic2,80)
          read (liner(ic1:ic2),*,err=603) qslt
          if (iseg80 .eq. 0)
     -      write (linewr,1262) potnam,(c(k,ia),k=1,3),
     -      qslt,ires,gcent,resnam(1:4),atomnam(1:4)
          if (iseg80 .eq. 1)
     -      write (linewr,1263) potnam,(c(k,ia),k=1,3),
     -      qslt,ires,gcent,resnam(1:4),atomnam,
     -      line(index(ia))(isegcol1:isegcol2)
          charge(ia)=qslt
          qsum=qsum+qslt
          if (ipxgrw .gt. 0) write (linewr(61:65),1007) ires
          call lastchar(linewr,lenwr,80)
          write (21,1000) linewr(1:lenwr)
        end do
        ierrpsf=0
603     if (ierrpsf .eq. 1) then
          write (6,1266) ia,ic,liner
          go to 601
        end if
        close (61)
      else if (iconvsource .eq. 2) then
c       Amber top file
        PSFortop='top'
        ierrtop=1
611     namlenn=0
        call openfile(61,0,'TOP',3,'old',inpfiletmp,namlenn,notfnd,
     -      3,1,1,0,0)
c       First, check for atom names
        call find_ambertyp(61,'%FLAG ATOM_NAME',15,
     -    read_format,lread_format)
        read (61,read_format(1:lread_format),end=613)
     -    (tempname(ia),ia=1,n)
        do ia=1,n
          if (tempname(ia)(1:nacol) .ne.
     -        line(index(ia))(inamcol1:inamcol2a)) then
            nawarn=nawarn+1
            if (nawarn .le. 100) write (6,1256) 'top',ia,
     -        line(index(ia))(inamcol1:inamcol2a),'top',
     -        tempname(ia)(1:nacol)
          end if
        end do
        call find_ambertyp(61,'%FLAG AMBER_ATOM_TYPE',21,
     -    read_format,lread_format)
        read (61,read_format(1:lread_format),end=613)
     -    (tempname(ia),ia=1,n)
        call find_ambertyp(61,'%FLAG CHARGE',12,
     -    read_format,lread_format)
        read (61,read_format(1:lread_format),end=613)
     -    (charge(ia),ia=1,n)
        do ia=1,nslt
          potnam='      '
          call blankout(linewr,1,80)
          potnam(1:4)=tempname(ia)
          charge(ia)=charge(ia)/18.2223
          qslt=charge(ia)
          atomnam='     '
          if (nnamcol .gt. 0)
     -      atomnam(1:nnamcol)=line(index(ia))(inamcol1:inamcol2)
          resnam='     '
          resnam(1:nrescol)=line(index(ia))(irescol1:irescol2)
          ires=iresno(ia)
          if (iseg80 .eq. 0)
     -      write (linewr,1262) potnam,(c(k,ia),k=1,3),
     -      qslt,ires,gcent,resnam(1:4),atomnam(1:4)
          if (iseg80 .eq. 1)
     -      write (linewr,1263) potnam,(c(k,ia),k=1,3),
     -      qslt,ires,gcent,resnam(1:4),atomnam,
     -      line(index(ia))(isegcol1:isegcol2)
          qsum=qsum+qslt
          if (ipxgrw .gt. 0) write (linewr(61:65),1007) ires
          call lastchar(linewr,lenwr,80)
          write (21,1000) linewr(1:lenwr)
        end do
        ierrtop=0
613     if (ierrtop .eq. 1) then
          print *,'TOP file had some error'
          go to 611
        end if
        close (61)
      else
c       Conversion file or input structure info
        do ia=1,nslt
          call blankout(linewr,1,80)
          atomnam='     '
          if (nnamcol .gt. 0)
     -      atomnam(1:nnamcol)=line(index(ia))(inamcol1:inamcol2)
          if (iqcol1 .gt. 0)
     -      call readreal(line(index(ia)),iqcol1,iqcol2,qslt)
          if (inpcrdtyp .le. ioins) then
            if (rn(1:nrescol) .ne. line(index(ia))(irescol1:irescol2)
     -          .or. ia .eq. nslt .or. rnu(1:nresncol) .ne.
     -          line(index(ia))(iresncol1:iresncol2)) then
              rnn(1:nrescol)=line(index(ia))(irescol1:irescol2)
              rnun(1:nresncol)=line(index(ia))(iresncol1:iresncol2)
              if (rnun(1:nresncol) .ne. rnu(1:nresncol) .or.
     -            rnn(1:nrescol) .ne. rn(1:nrescol)) ires=ires+1
              rnu=rnun
              rn=rnn
            else
              rnprev(1:nrescol)=line(index(ia))(irescol1:irescol2)
              rnuprev(1:nresncol)=line(index(ia))(iresncol1:iresncol2)
            end if
            resnam(1:nrescol)=rn(1:nrescol)
            if (nrescol .eq. 3) resnam(4:4)=' '
            if (nrescol .eq. 5) call leftadjustn(resnam,resnam,8)
          end if
          if (mmcformat .le. 2) then
c           Pf information is available
            if (mmcformat .eq. 1) then
              if (inpcrdtyp .eq. iommod) then
                call readint(line(index(ia)),ipotcol1,ipotcol2,mmodtyp,
     -            4)
                ambtyp=mmodtoamb(mmodtyp)
                potnam(1:2)=ambtyp
              else 
               potnam(1:ipotcol2-ipotcol1+1)=
     -           line(index(ia))(ipotcol1:ipotcol2)
              end if
            else if (mmcformat .eq. 2) then
              call PDBtommc(resnam,atomnam,potnam4,qslt,ia,gcent,igr,
     -          ideoxymmc,iconvfile,nunknown,nunknownr)
              potnam(1:4)=potnam4
            end if
            if (igroups .eq. 0) then
              gcent=' '
              ngroups=ires
            else
              if (igr .ne. igrold) then
                igrold=igr
                ngroups=ngroups+1
              end if
            end if
            indexo(ia)=ngroups
            if (iresncol2 .gt. iresncol1) call readint(line(index(ia)),
     -        iresncol1,iresncol2,ngroups,2)
            qsumgr=qsumgr+qslt
            if (iseg80 .eq. 0)
     -        write (linewr,1262) potnam,(c(k,ia),k=1,3),
     -        qslt,ngroups,gcent,resnam(1:4),atomnam(1:4)
            if (iseg80 .eq. 1)
     -        write (linewr,1263) potnam,(c(k,ia),k=1,3),
     -        qslt,ngroups,gcent,resnam(1:4),atomnam,
     -        line(index(ia))(isegcol1:isegcol2)
            ires=ngroups
            charge(ia)=qslt
          else
c           Use atomic numbers for type
            write (linewr,1261) iatnum(ia),(c(k,ia),k=1,3),qslt,ires,
     -        resnam(1:4),atomnam(1:4)
          end if
          if (ipxgrw .gt. 0) write (linewr(61:65),1007) ires
          call lastchar(linewr,lenwr,80)
          write (21,1000) linewr(1:lenwr)
          qsum=qsum+qslt
          natprt=natprt+1
        end do
      end if
      if (nawarn .gt. 0) then
        write (6,1257) nawarn,PSFortop
      end if
      if (mmcformat .le. 2) then
        if (igroups .eq. 0) then
          call checkreschargesum(nslt,iresno,isegno,line,index,irescol1,
     -      irescol2,iresncol1,iresncol2,isegcol1,isegcol2,iqcol1,
     -      iqcol2,charge,molsltlim,'residue',7,resnames,ifres,ixres,
     -      itemp1,itemp2,nreschrg,iallzero,iallnonpos,iallnonneg,0,
     -      ifixq,reportqmin,MAXRSD,MAXREC)
        else
          call checkreschargesum(nslt,indexo,isegno,line,index,irescol1,
     -      irescol2,iresncol1,iresncol2,isegcol1,isegcol2,iqcol1,
     -      iqcol2,charge,molsltlim,'group',5,resnames,ifres,ixres,
     -      itemp1,itemp2,nreschrg,iallzero,iallnonpos,iallnonneg,0,
     -      ifixq,reportqmin,MAXRSD,MAXREC)
        end if
      end if
      close (iuout)
      close (21)
      if (ideoxymmc .eq. 0) write (6,2020)
      if (ideoxymmc .eq. 1) write (6,2021)
      write (6,2017) natprt,ires,qsum
      if (iconvfile .eq. 4) write (6,2022)
      if (nunknown .gt. 0) then
        print *,'WARNING:',nunknown,
     -          ' atoms had unidentifiable atomtypes'
        if (inpcrdtyp .eq. iommod) print *,'Unidentified atoms ',
     -    'retained their Macromodel type incremented by 100'
          if (inpcrdtyp .eq. iommod) print *,'(set to 999)'
      end if
      if (nunknownr .gt. 0) print *,'WARNING:',nunknownr,' atoms are ',
     -  'in unidentified residue(s)'
      close (10)
      go to 90
c-----Not used
700   continue
      go to 999
c-----Format and name conversions
c     First remove atoms to be deleted from c, update index
800   if (nconfig .eq. 1) then
        call askyn('Do you want to sort the atoms',29,0,-1,nosort,0)
      end if
      call atomdel(line,idcol,asterisk,n,nslt,nrecdel,c,isegno,index,
     -  indexn,indexo,inpcrdtyp,iatnum,charge,iresno,ixres,ifres,ilres,
     -  nconfig,natsdel,MAXRSD,MAXREC)
      call set_pdbinfo(iotyp,iwriteatsym,iwritecon,iobpdb,iocpdb,0)
      if (iruntyp .eq. 8) then
c-------Create configuration in a different format
        write (6,2046)
        call writeconf(iuout,inpcrdtyp,iotyp,inpcrdtyporg,n,n,nslt,
     -    naslv,islvw,iasv,namesv,qsv,pflsv,1,iwhead,0,iatnum,ifchrg,
     -    nconfig,innlist,c,rprox,cv,ixres,iresno,atnames,resnames,
     -    segnames,charge,isegno,marker,ntitlin,ntitlinw,title,ireseq,
     -    iresnrestart,iresidrestart,nneig,nneiga,nhbneig,ineig,nhneig,
     -    nnneig,ncneig,nsneig,npneig,numres,numslv,resnamslv,line,
     -    blankline,mmtype,ibnd,index,indexn,indexo,1,molresflag,
     -    irescount3,hblimfac,angmin,0,nosort,noreg,0,0,5,iqspaceask,
     -    0,0,0.0,0,0,0,keeprem,iwriteatsym,radtodeg,maxrepconf,MAXNEIG,
     -    MAXRSD,MAXREC)
      else
c-------Atom name and segid conversions
c       (Charmm and PDB only) and allow some conversions
        if (iformconv .gt. 0) then
          if (inpcrdtyp .eq. iograsp .and. iformconv .eq. 2) then
c           Grasp .crg file
            do ia=1,ntitlin
              call writeline(iuout,line(ia),1,incol(inpcrdtyp),0)
            end do
            do ia=1,n
              atnam4=line(ntitlin+ia)(inamcol1:inamcol2)
              call regularpdb(atnam4,
     -          line(ntitlin+ia)(inamcol1:inamcol2),1)
              call writeline(20,line(ntitlin+ia),1,incol(inpcrdtyp),0)
            end do
            close (10)
            close (iuout)
            go to 90
          else if (iformconv .eq. 4) then
c           Left-adjust atomnames
            do ia=1,n
              call leftadjustline(line(index(ia)),inamcol1,inamcol2)
            end do
          else if (iformconv .eq. 5) then
c           Make atom names unique
            inamcol22=min0(inamcol1+3,inamcol2)
            do ia=1,nslt
              tempname(ia)=line(index(ia))(inamcol1:inamcol22)
c              write (6,8719) ia,index(ia),tempname(ia),line(index(ia))
c8719          format(i4,' index=',i4,' name=',a,/,a)
            end do
            call uniquename(tempname,nslt)
            do ia=1,nslt
              line(index(ia))(inamcol1:inamcol22)=tempname(ia)
            end do
          else
c           Regularization
            call fixrecform(line,index,n,iformconv,inamcol1,inamcol2,
     -        irescol1,irescol2,MAXREC)
            if (iformconv .eq. 2) write (iuout,1275) marker(inpcrdtyp)
            if (iformconv .eq. 3) write (iuout,1277) marker(inpcrdtyp)
          end if
        else
c         Name conversions
          if (nconfig .eq. 1) then
c           Specify conversions, setup data
             if (inpcrdtyp .eq. iogro) print *,'WARNING: Only four ',
     -         'characters will be use from the names'
            call initnamconv(noconv)
          end if
c         Write header
c         if (marker(iotyp) .ne. '      ') write (iuout,1274)
c    -      marker(inpcrdtyp),namnam(incon),namnam(ioutcon)
          call check23(line,index,nslt,inamcol1,inamcol2,nnamcol,MAXREC)
          nrch=0
          nach=0
          nwarn=0
          nblank1=0
          do ia=1,n
            atomnam='     '
            atomnam(1:nnamcol)=line(index(ia))(inamcol1:inamcol2)
            if (atomnam(1:1) .eq. ' ') nblank1=nblank1+1
            resnam='        '
            resnam(1:nnamcol)=line(index(ia))(irescol1:irescol2)
            atnam4=atomnam(1:4)
            if (atomnam(5:5) .ne. ' ') atnam4=atomnam(2:5)
            resnam4=resnam(1:4)
            if (resnam(5:5) .ne. ' ') resnam4=resnam(2:5)
            call namconv(nrescol,resnam4,atnam4,resnam4,atnam4,nrch,
     -        nach,line(index(ia)),idcol,nrecdel)
            atomnam='        '
            atomnam(1:4)=atnam4
            resnam='        '
            resnam(1:4)=resnam4
            if (nrescol .eq. 3 .and. resnam(4:5) .ne. '  ') then
              nwarn=nwarn+1
              if (nwarn .eq. 1) write (6,2010)
            else
              line(index(ia))(irescol1:irescol2)=resnam(1:nrescol)
            end if
            line(index(ia))(inamcol1:inamcol2)=atomnam(1:nnamcol)
          end do
          if (nconfig .eq. 1) then
            if (ideoxy .eq. 0) write (6,2020)
            if (ideoxy .eq. 1) write (6,2021)
            write (6,1276) nrch,nach
            if ((namnam(incon) .eq. 'Amber   ' .or.
     -        namnam(incon) .eq. 'Amber94 ' .or.
     -        namnam(incon) .eq. 'Charmm  ') .and.
     -        nblank1 .gt. 0) write (6,1278) namnam(incon),nblank1
          end if
        end if
        if (inpcrdtyp .eq. iomol2) then
c         Save the mol2 file (temporary hack)
          do i=1,nlines
            call lastchar(line(i),lc,80)
            write (iuout,1000) line(i)(1:lc)
          end do
        else if (inpcrdtyp .eq. iomae) then
          write (6,*) 'Writing in Maestro format is not implemented'
          stop
        else
          call writeconf(iuout,inpcrdtyp,inpcrdtyp,inpcrdtyporg,n,n,
     -      nslt,naslv,islvw,iasv,namesv,qsv,pflsv,0,iwhead,0,iatnum,
     -      ifchrg,nconfig,innlist,c,rprox,cv,ixres,iresno,atnames,
     -      resnames,segnames,charge,isegno,marker,ntitlin,ntitlinw,
     -      title,ireseq,iresnrestart,iresidrestart,nneig,nneiga,
     -      nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,numres,
     -      numslv,resnamslv,line,blankline,mmtype,ibnd,index,indexn,
     -      indexo,1,molresflag,irescount3,hblimfac,angmin,1,nosort,
     -      1,0,0,5,iqspaceask,0,0,0.0,0,0,0,keeprem,iwriteatsym,
     -      radtodeg,maxrepconf,MAXNEIG,MAXRSD,MAXREC)
        end if
      end if
      natconftot=natconftot+n
      if (nconfig .eq. 1) then
        if (numres-numslv .gt. 0)
     -    call writeseq(outfile,namleno,numres,resnames,dssplab,numslv,
     -    line,index,iotyp,title,nslt,n,0,igl,MAXRSD,MAXREC)
        if (nsegcol .gt. 1) then
          nsegcolout=iisegcol(2,iotyp)-iisegcol(1,iotyp)+1
          if (nsegcolout .lt. nsegcol) write (6,2024) nsegcolout
        end if
        call getint(
     -    'Total number of additional configurations to process',52,
     -      0,1,0,nconfadd,42)
        if (nconfadd .gt. 0) then
          call askyn('Are they in separate files',26,1,+1,
     -      iaddfile,43)
          if (iaddfile .eq. 1) then
            call filenamenum(inpfile,namleni,outfiletmp,namlenn,2,-1)
            write (6,2048)
            call writeline(6,outfiletmp,1,namlenn,0)
            write (6,2049)
            call getint('Number of datasets per file',27,1,1,nconfadd,
     -        nsetfile,0)
          end if
          if (iaddfile .eq. 0 .or. nsetfile .gt. 1) then
            call askyn(
     -       'Do you want the headers in the additional configurations',
     -       56,1,1,iwhead,44)
            if (iwhead .eq. 0) then
             if (ischarmm(iotyp) .eq. 1) print *,
     -         'Note: Number of atoms will have to be fixed manually'
              if (iotyp .eq. iommod)
     -          print *,'WARNING: Macromodel bond table will be invalid'
            end if
          end if
        end if
      end if
      if (nconfadd .gt. 0) print *,'Configuration ',nconfig,' done'
      if (nconfadd+1 .gt. nconfig) then
        if (iaddfile .eq. 1 .and. mod(nconfig,nsetfile) .eq. 0) then
          close (10)
          numfil=nconfig/nsetfile+1
          call filenamenum(inpfile,namleni,outfiletmp,namlenn,numfil,-1)
          call openfile(10,0,'input',5,'old',outfiletmp,namlenn,
     -      notfnd,0,1,1,0,0)
          close (iuout)
          call filenamenum(outfile,namleno,outfiletmp,namlenn,numfil,+1)
          call openfile(iuout,0,'output',6,'new',outfiletmp,namlenn,
     -      notfnd,0,1,1,0,0)
        end if
        if (iotyp .eq. iobpdb .or. iotyp .eq. iocpdb)
     -     write (iuout,2045) nconfig+1
c!!     ntitlin=0
        if (ixcluster .eq. 0) then
          go to 99
        else
          call readxcluster(n,c,10,nconfig)
          inpcrdtyp=iotyp
          call setcol(inpcrdtyp,ncol,idcol,ialtcol,
     -      inamcol1,inamcol2,irescol1,irescol2,iccol1,iccol2,
     -      iresncol1,iresncol2,iseqncol1,iseqncol2,isegcol1,isegcol2,
     -      iresidcol1,iresidcol2,iqcol1,iqcol2,ipotcol1,ipotcol2,
     -      iocccol1,iocccol2,ichemcol1,ichemcol2,nrescol,nresncol,
     -      nsegcol,nnamcol,iofull)
          go to 990
        end if
      end if
      if (nconfig .gt. 1) then
        print *,'Total number of atoms processed=',natconftot
        if (iwhead .eq. 0 .and.
     -    (ischarmm(iotyp) .eq. 1 .or. iotyp .eq. iommod)) then
            write (6,2042) natconftot,outfile(1:namleno)
        end if
      end if
      stop
c-----Analyze
9000  call analyze(nconfig,inpcrdtyp,inpcrdtyporg,ianaltyp,extnam1,
     -  analfile,inpfile,namleni,line,index,n,nslt,nmolslt,numres,
     -  numresslt,c,atw,rprox,cv,charge,iatnum,ifchrg,ncl,nneig,nneiga,
     -  nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,mmtype,
     -  molsltlim,isegno,ih,ifgtyp,molresflag,co,c1,c2,temp,ibnd,
     -  indexn,indexo,indexs,indexa,indexdel,ifree,icntrl,indexov,
     -  indexrmsd,itemp1,itemp2,itemp3,itemp4,itemp5,naslv,islvw,
     -  innlist,hblimfac,angmin,iresno,ixres,ixresno,ixsegno,ifres,
     -  ilres,irepav,irepmx,irepeng,irepkm,irescol1,irescol2,iresncol1,
     -  iresncol2,inamcol1,inamcol2,iqcol1,iqcol2,idcol,segid4,
     -  resnamslv,atnames,resnames,irescount1,irescount2,irescount3,
     -  listrefres,listnegres,segnames,ianc_anc,dssplab,idistdssp,
     -  marker,iwhead,nsegslt,isc,reportqmin,
C@GL     -  icg,wintitl,lwint,
     -  ntitlin,ntitlinw,title,version,iresnrestart,iresidrestart,
     -  blankline,label,inptrajtyp,mmctrajtyp,itraj,ireorient,centgra,
     -  iconfsel,numsel,nclstmem,iresshift,lastanal,ifixq,nhbdist,iwt,
     -  rlim,iqspaceask,icharges,iallheavy,keeprem,pi,radtodeg,asterisk,
     -  maxconfsel,maxrepconf,MAXNEIG,maxbox,MAXBONDS,MAXRSD,MAXREC,
     -  MAXREC10,MAXRCORR,MAX2D)
      if (ncl .gt. 0 .and. lastanal .eq. 23) then
        iaskunderscore=1
        innlist=-1
        ioutrajtyp=inptrajtyp
        call askyn('Do you want separate trajectories of the clusters',
     -    49,1,-1,iseptraj,000)
        if (iseptraj .gt. 0) then
          if (inptrajtyp .ne. 2) then
            write (6,2103) trajformatname(ioutrajtyp)
            call askyn('Do you want Amber trajectories instead',38,
     -        1,-1,iuseamb,000)
            if (iuseamb .eq. 1) ioutrajtyp=2
          end if
          if (istuner .eq. 1) print *,'Trajectories created will not ',
     -      'carry stepsize tuning information'
          call getint('Minimum cluster size to use',27,0,1,0,minmem,0)
          indexn(ncl+1)=indexo(ncl)+1
          irepcall=0
          if (minresflag .eq. -1)
     -      call setmolres(ifres,ilres,isegno,molresflag,
     -        molsltlim,nrescol,irescol1,irescol2,resnames,numresslt,
     -        nmolslt,nsegslt,nmolsltnoion,minresflag,index,indexa,
     -        indexs,line,maxrsd,maxrec)
          do icl=1,ncl
            nmem=indexn(icl+1)-indexn(icl)
            if (nmem .ge. minmem) then
c             Generate trajectory for cluster icl
              call filenamenum(trajnam,ltrajnam,trajnam2,ltrajnam2,
     -          icl,+1)
              write (6,2058) icl,nmem,trajnam2(1:ltrajnam2)
              call convtraj(ioutrajtyp,inptrajtyp,mmctrajtyp,inpcrdtyp,
     -          n,nslt,naslv,islvw,iatnum,ifchrg,innlist,ih,c,co,c1,c2,
     -          rprox,cv,iresno,ixres,ifres,ilres,itemp1,itemp2,itemp3,
     -          atnames,resnames,segnames,charge,isegno,itemp5,segid4,
     -          irescount1,irescount2,marker,asterisk,ntitlin,title,
     -          ireseq,iresnrestart,iresidrestart,inamcol1,inamcol2,
     -          irescol1,irescol2,iseqncol1,iseqncol2,isegcol1,isegcol2,
     -          iqcol1,iqcol2,idcol,nneig,nneiga,nhbneig,ineig,nhneig,
     -          nnneig,ncneig,nsneig,npneig,numres,numslv,resnamslv,
     -          line,blankline,mmtype,ibnd,index,itemp4,indexo,indexs,
     -          indexdel,indexa,mmtype,indexsup,atw,edge,ifree,namin,
     -          namout,resin,resout,icntrl,icntrlw,iha,molresflag,temp,
     -          rprox,irescount3,hblimfac,angmin,iconfsel(indexn(icl)),
     -          nmem,nextconfsel,molsltlim,nmolslt,nmolsltnoion,1,
     -          minresflag,iqspaceask,0,iwriteatsym,radtodeg,tofac,
     -          irepcall,ipbcinp,maxconfsel,1,maxrepconf,igl,pi,MAXRSD,
     -          MAXNEIG,MAXREC)
              irepcall=1
            end if
          end do
        end if
        call askyn(
     -    'Do you want to extract cluster representative conformations',
     -    59,1,-1,irepconf,000)
        if (irepconf .eq. 1) then
9001      call quiz(ans,ireptyp,' ',' ',0,
     -      'cluster representative type',27,0,5,6,igl,0)
          if (ans .eq. 'e') then
            if (inptrajtyp .ne. 3) then
              write (6,1209)
              go to 9001
            else if (irepeng(1) .eq. 0) then
              print *,'No energy-based representative is available'
              go to 9001
            end if
            call trnsfi(irepav,irepeng,ncl)
          else if (ans .eq. 'k') then
            nz=0
            do i=1,ncl
              if (irepkm(i) .eq. 0) nz=nz+1
            end do
            if (nz .eq. 0) then
              call trnsfi(irepav,irepkm,ncl)
            else
              print *,'K-means clustering centers are not available'
              go to 9001
            end if
          end if
          if (ans .eq. 'm') call trnsfi(irepav,irepmx,ncl)
c         Sort the cluster representatives
c         call sortlist(iout,irepav,ncl,itemp1,iorig,'AVG',0,MAX2D)
          call mrgsortlist(irepav,itemp1,itemp2,itemp3,itemp4,cv,temp,
     -      ncl)
          do i=1,ncl
            itemp2(i)=nclstmem(iorig(i))
          end do
          call trnsfi(nclstmem,itemp2,ncl)
          if (inptrajtyp .eq. 0)
     -      call asktrajform(inptrajtyp,ioutrajtyp,mmctrajtyp,
     -        resnamslv,igl,-1,1)
          call quiz(ans,ireptyp,' ',' ',0,'form of extraction',18,0,
     -      5,6,igl,0)
          if (ans .eq. 't') then
            if (inptrajtyp .ne. 2) then
              write (6,2103) trajformatname(ioutrajtyp)
              call askyn('Do you want Amber trajectories instead',38,
     -          1,-1,iuseamb,000)
              if (iuseamb .eq. 1) ioutrajtyp=2
            end if
            call getname(trajnam2,ltrajnam2,
     -        'Name of the output trajectory',29,200,0)
            if (minresflag .eq. -1)
     -        call setmolres(ifres,ilres,isegno,molresflag,
     -          molsltlim,nrescol,irescol1,irescol2,resnames,numresslt,
     -          nmolslt,nsegslt,nmolsltnoion,minresflag,index,indexa,
     -          indexs,line,maxrsd,maxrec)
            call convtraj(ioutrajtyp,inptrajtyp,mmctrajtyp,inpcrdtyp,
     -        n,nslt,naslv,islvw,iatnum,ifchrg,innlist,ih,c,co,c1,c2,
     -        rprox,cv,iresno,ixres,ifres,ilres,itemp1,itemp2,itemp3,
     -        atnames,resnames,segnames,charge,isegno,itemp5,segid4,
     -        irescount1,irescount2,marker,asterisk,ntitlin,title,
     -        ireseq,iresnrestart,iresidrestart,inamcol1,inamcol2,
     -        irescol1,irescol2,iseqncol1,iseqncol2,isegcol1,isegcol2,
     -        iqcol1,iqcol2,idcol,nneig,nneiga,nhbneig,ineig,nhneig,
     -        nnneig,ncneig,nsneig,npneig,numres,numslv,resnamslv,line,
     -        blankline,mmtype,ibnd,index,itemp4,indexo,indexs,indexdel,
     -        indexa,mmtype,indexsup,atw,edge,ifree,namin,namout,resin,
     -        resout,icntrl,icntrlw,iha,molresflag,temp,rprox,
     -        irescount3,hblimfac,angmin,irepav,ncl,nextconfsel,
     -        molsltlim,nmolslt,nmolsltnoion,1,minresflag,iqspaceask,0,
     -        iwriteatsym,radtodeg,tofac,irepcall,ipbcinp,1,maxconfsel,
     -        maxrepconf,igl,pi,MAXRSD,MAXNEIG,MAXREC)
          else
            innlist=-1
            nextconfsel=1
            ionefile=0
            imodel=0
            if (ans .eq. 'o' .or. ans .eq. 'm') ionefile=1
            if (ans .eq. 'm') imodel=1
            if (ionefile .eq. 0) call askyn(
     -        'Do you want to number the files consecutively',45,
     -        1,0,numconsec,1)
            call getcrdtyp(0,'   ',3,iotyp,ixcl,igl)
            write (6,2016) formatname(iotyp)
            separatorchar='.'
            call unpacktraj(inptrajtyp,mmctrajtyp,inpcrdtyp,iotyp,
     -        inpcrdtyporg,n,nslt,naslv,iislvw,numres,numslv,resnamslv,
     -        iatnum,ifchrg,ixres,atnames,resnames,segnames,marker,
     -        ireseq,iresnrestart,iresidrestart,c,rprox,cv,charge,
     -        ntitlin,title,nneig,nneiga,nhbneig,ineig,nhneig,nnneig,
     -        ncneig,nsneig,npneig,isegno,iresno,line,blankline,ifree,
     -        icntrl,innlist,mmtype,ibnd,index,indexn,indexo,molresflag,
     -        hblimfac,angmin,ioppbc,cell,ncell,ionefile,iwhead,imodel,
     -        ncl,irepav,irescount3,nclstmem,numconsec,incr_fileno,
     -        nextconfsel,iqspaceask,keeprem,radtodeg,ioverallconf,
     -        maxconfsel,maxrepconf,MAXNEIG,MAXRSD,MAXREC,MAX2D)
          end if
        end if
      end if
      if (nrotwarn .gt. 0) write (6,1213) nrotwarn,nrottest,devmax
      if (itraj .gt. 0) stop
      go to 9910
c-----Generate torsion information
9040  call torsinp(nconfig,inpcrdtyp,itform,extnam1,analfile,inpfile,
     -  namleni,line,index,n,nslt,c,iatnum,ifchrg,nneig,nneiga,nhbneig,
     -  ineig,nhneig,nnneig,ncneig,nsneig,npneig,isegno,ixres,ibnd,
     -  indexo,naslv,islvw,innlist,molresflag,hblimfac,angmin,irescol1,
     -  irescol2,iresncol1,iresncol2,inamcol1,inamcol2,pi,radtodeg,
     -  maxrepconf,MAXNEIG,maxbox,MAXRSD,MAXREC)
      go to 9910
c-----Generate cell information
9050  call pbctype(ioppbc,npbc,ixyzhex,1,igl)
      if (ioppbc .lt. 1 .or. ioppbc .gt. 9) then
        print *,'This cell type (',ioppbc,') has no neighbor cell info'
        go to 9910
      end if
      call pbcsize(ioppbc,edge,npbc)
      ncellfn=13
      analfile(1:ncellfn)='imagecell.pdb'
      call openfile(10,0,'image cell',10,'new',analfile,ncellfn,
     -  notfnd,0,1,1,0,0)
      print *,'Cell centers for ',cellname(ioppbc),
     -  ' PBC will be written to file ',analfile(1:ncellfn)
      nvertfn=15
      outfiletmp(1:nvertfn)='pbcvertices.pdb'
      call openfile(20,0,'cell vertex',11,'new',outfiletmp,nvertfn,
     -  notfnd,0,1,1,0,0)
      print *,'Cell vertices for ',cellname(ioppbc),
     -  ' PBC will be written to file ',outfiletmp(1:nvertfn)
      call crorgn(edge,edge_gen,ioppbc,3,ncell,cell,cellalt,
     -  ixyzhex,rinscr,rcirc)
      call  prtcell(ioppbc,edge,edge_gen,r,vol,nw,1)
      call transrot(cell,c2,atw,temp,rot,xyzmin,edge_gen,molsltlim,
     -  nsegslt,nsegslt,minresflagx,ncell,ncell,1,npbc,
     -  ixyzhex,nneig,ineig,molresflag,ixres,indexn,indexo,igl,0,0,0,
     -  pi,MAXRSD,MAXNEIG,MAXREC)
c     Print cell centers
      do ia=1,ncell
        do k=1,3
          c8(k)=cell(k,ia)
        end do
        call writepdbd(10,c8,ia,1,'CELL',pbcres(ioppbc),'P',1.0,0.0)
      end do
c     write (10,1101) ((cell(k,i),k=1,3),i=1,ncell)
      iclr=1
      call zeroit(centinp,3)
      call drawpbc(edge,edge_gen,ioppbc,ixyzhex,centinp,0,
C@GL     -  idpbc,iclr,5,
     -  1,rot,1.8,20)
C@GL      if (igl .gt. 0) then
C@GL        call drawpbc(edge,edge_gen,ioppbc,ixyzhex,centinp,0,idpbc,iclr,
C@GL     -    5,1,rot,1.8,20)
C@GL        call drawaxes(idaxes,0.05,0)
C@GL        nstep=0
C@GL        do while (nstep .ge. 0)
C@GL          call askrot(nstep)
C@GL          call setcolor(0)
C@GL          call clear
C@GL          call setcolor(iclr)
C@GL          call drawpbc(edge,edge_gen,ioppbc,ixyzhex,centinp,0,idpbc,
C@GL     -      iclr,5,0,rot,1.8,0)
C@GL          call drawaxes(idaxes,0.05,0)
C@GL          call swapbu
C@GL        end do
C@GL      end if
      close(10)
      close(20)
      go to 91
c-----Generate Gaussian ONIOM input
9060  call makeoniom(inpcrdtyp,inpfile,outfiletmp,namleni,namlentmp,n,
     -  nslt,naslv,islvw,c,index,iatnum,ifchrg,indexn,indexo,indexs,
     -  mmtype,isegno,ixres,ih,ibnd,ifgtyp,nneig,nneiga,nhbneig,ineig,
     -  nhneig,nnneig,ncneig,nsneig,npneig,molresflag,hblimfac,angmin,
     -  ipotcol1,ipotcol2,iqcol1,iqcol2,irescol1,irescol2,nrescol,
     -  inamcol1,inamcol2,nnamcol,maxrepconf,innlist,nconfig,line,
     -  radtodeg,igl,MAXNEIG,MAXRSD,MAXREC)
C@GL      if (igl .eq. 1)
C@GL     -  call displaymol(idmol,idaxes,c,co,n,nslt,iatnum,nneig,ineig,
C@GL     -  nhneig,nhbneig,isegno,isc,outfiletmp,namlentmp,icg,centgra,
C@GL     -  nconfig-1,MAXNEIG)
      go to 91
c-----Generate Amsol input
9100  call makeamsol(n,c,iatnum,nneig,ineig,iqcol1,iqcol2,line,
     -  index,indexn,inpcrdtyp,nconfig,iuout,MAXNEIG,MAXREC)
      go to 91
c-----Generate trajectory from input configuration sequence
9200  if (nconfig .eq. 1) then
        if (anspup .eq. 'm') then
          if (ispdb(inpcrdtyp) .eq. 0) then
            print *,'MODEL/ENDMDL file can only be made from PDB files'
            stop
          else
            print *,'Input PDB files are assumed to be separate,',
     -        ' one structure each'
            iaddfile=1
            nsetfile=1
          call openfile(iuout,0,'output MODEL/ENDMDL',19,'new',
     -      outfile,namleno,notfnd,0,1,1,0,0)
          end if
        end if
        namleno=0
        if (ioutrajtyp .eq. 1 .or.
     -     (ioutrajtyp .eq. 3 .and. mmctrajtyp .eq. 1)) then
          call openfile(iuout,0,'output trajectory',17,'new',
     -      outfile,namleno,notfnd,0,2,1,0,0)
        else if (ioutrajtyp .gt. 0) then
          call openfile(iuout,0,'output trajectory',17,'new',
     -      outfile,namleno,notfnd,0,1,1,0,0)
        end if
        if (notfnd .gt. 0) then
          print *,'ERROR: problem opening file ',outfile(1:namleno)
          stop
        end if
        call indexit(indexs,1,n,0)
        call getint('Number of configurations to combine',35,0,1,0,
     -    nconftot,0)
        nconfadd=nconftot-1
        if (nconfadd .gt. 0) then
          if (anspup .ne. 'm') call askyn('Are they in separate files',
     -      26,1,+1,iaddfile,43)
          if (iaddfile .eq. 1) then
            call filenamenum(inpfile,namleni,outfiletmp,namlenn,2,-1)
            write (6,2048)
            call writeline(6,outfiletmp,1,namlenn,0)
            write (6,2049)
            if (anspup .ne. 'm') call getint(
     -        'Number of datasets per file',27,1,1,nconfadd,nsetfile,0)
          end if
        end if
        if (ntitltr .lt. 30) then
          trtitle(ntitltr+1)=
     -      'Simulaid combined single structures form file(s)'
          trtitle(ntitltr+2)=inpfile(1:namleni)
          ntitltr=ntitltr+2
        end if
      end if
      if (anspup .eq. 'm') then
        write (iuout,2043) nconfig
        rewind 10
        do while (.true.)
          call blankout(liner,1,80)
          read (10,1000,end=9201) liner
          if (liner(1:3) .eq. 'END') then
            write (iuout,2044)
            go to 9201
          else
            call lastchar(liner,lc,80)
            write (iuout,1000) liner(1:lc)
          end if
        end do
9201    if (liner(1:3) .ne. 'END') write (iuout,2044)
      else
        call maketraj(nconfig,nconfadd+1,c,c1,rprox,cv,ih,nslt,n,naslv,
     -    islvw,ntitltr,trtitle,line,inpcrdtyp,1,inptrajtyp,ioutrajtyp,
     -    mmctrajtyp,20,iatnum,ifchrg,innlist,iresno,ixres,atnames,
     -    resnames,segnames,charge,isegno,marker,ntitlin,title,ireseq,
     -    iresnrestart,iresidrestart,nneig,nneiga,nhbneig,ineig,nhneig,
     -    nnneig,ncneig,nsneig,npneig,numres,numslv,resnamslv,blankline,
     -    mmtype,ibnd,index,indexn,indexo,indexs,icntrlw,icntrl,ifree,
     -    molresflag,irescount3,0,0,0,n,hblimfac,angmin,iqspaceask,
     -    keeprem,iwriteatsym,radtodeg,etotread,0,maxrepconf,MAXNEIG,
     -    MAXRSD,MAXREC)
      end if
      if (nconfadd+1 .gt. nconfig) then
        if (iaddfile .eq. 1 .and. mod(nconfig,nsetfile) .eq. 0) then
          close (10)
          numfil=nconfig/nsetfile+1
          call filenamenum(inpfile,namleni,outfiletmp,namlenn,numfil,-1)
          call openfile(10,0,'input',5,'old',outfiletmp,namlenn,
     -      notfnd,0,1,1,0,0)
        end if
      end if
      go to 9910
c-----Rearrange atoms according to an RTF file
9300  if (nconfig .eq. 1)
     -  call getconvdat(1,5,2,nconvdat,iconvtyp,n,line,index,
     -    inamcol1,inamcol2,nnamcol,irescol1,irescol2,igrpinfo,MAXREC)
      call sortatresrtf(line,n,nslt,index,indexn,indexo,isegno,itemp1,
     -  irescol1,irescol2,iresncol1,iresncol2,isegcol1,isegcol2,
     -  inamcol1,inamcol2,inpcrdtyp,nconfig,MAXREC)
c     print *,'sortrtf done'
      go to 999
c-----Unpack stacked configurations
9400  call unpackconf(line,nlines,ncol,inpfile,namleni,nconfig,
     -  molname,molnamelen,numsel,iconfsel,numconsec,maxconfsel,
     -  nextconfsel,incr_fileno,ioverallconf,ionefile,natsfirst,n,30,
     -  MAXREC)
c     Unpacking runs loop back unconditionally
      if (numsel .eq. 0) ioktoend=1
      if (numsel .gt. 0 .and. iconfsel(nextconfsel) .eq. 0) go to 9999
      go to 99
c-----Rotate/translate structure
9500  call transrot(c,c2,atw,temp,rot,xyzmin,edge_gen,molsltlim,nmolslt,
     -  nmolsltnoion,minresflag,n,nslt,naslv,npbc,ixyzhex,nneig,ineig,
     -  molresflag,ixres,indexn,indexo,igl,1,nconfig,nosegid,pi,MAXRSD,
     -  MAXNEIG,MAXREC)
      if (inpcrdtyp .eq. iomol2) then
c       Write coordinates back and save the mol2 file (temporary hack)
        do ia=1,nslt
          write (line(index(ia))(iccol1:iccol2),1107) (c(k,ia),k=1,3)
        end do
        do i=1,nlines
          call lastchar(line(i),lc,80)
          write (iuout,1000) line(i)(1:lc)
        end do
        stop
      end if
      call writeconf(iuout,inpcrdtyp,iotyp,inpcrdtyporg,n,n,nslt,naslv,
     -  islvw,iasv,namesv,qsv,pflsv,1,iwhead,0,iatnum,ifchrg,nconfig,
     -  innlist,c,rprox,cv,ixres,iresno,atnames,resnames,segnames,
     -  charge,isegno,marker,ntitlin,ntitlinw,title,ireseq,iresnrestart,
     -  iresidrestart,nneig,nneiga,nhbneig,ineig,nhneig,nnneig,ncneig,
     -  nsneig,npneig,numres,numslv,resnamslv,line,blankline,mmtype,
     -  ibnd,index,indexn,indexo,0,molresflag,irescount3,hblimfac,
     -  angmin,0,nosort,noreg,0,0,5,iqspaceask,0,0,0.0,0,0,0,keeprem,
     -  iwriteatsym,radtodeg,maxrepconf,MAXNEIG,MAXRSD,MAXREC)
      stop
c-----Extract parts of the system
9600  call select(line,nrecdel,idcol,asterisk,n,nslt,index,ixres,
     -  isegcol1,isegcol2,iseqncol1,iseqncol2,inamcol1,inamcol2,
     -  irescol1,irescol2,iqcol1,iqcol2,charge,iatnum,nneig,ineig,
     -  indexdel,0,igl,MAXNEIG,MAXREC)
      go to 999
c-----Modify (mutate/add) atoms
9610  call modify(inpcrdtyp,c,n,nslt,line,index,iatnum,nneig,ineig,
     -  isegno,iresno,charge,natomadd,igl,pi,MAXNEIG,MAXREC)
      go to 999
c-----Extract the sequence
9620  call writeseq(inpfile,namleni,numres,resnames,dssplab,numslv,line,
     -    index,inpcrdtyp,title,nslt,n,1,igl,MAXRSD,MAXREC)
      go to 9910
c-----Convert trajectories
9700  call convtraj(ioutrajtyp,inptrajtyp,mmctrajtyp,inpcrdtyp,n,nslt,
     -  naslv,islvw,iatnum,ifchrg,innlist,ih,c,co,c1,c2,rprox,cv,iresno,
     -  ixres,ifres,ilres,itemp1,itemp2,itemp3,atnames,resnames,
     -  segnames,charge,isegno,itemp5,segid4,irescount1,irescount2,
     -  marker,asterisk,ntitlin,title,ireseq,iresnrestart,iresidrestart,
     -  inamcol1,inamcol2,irescol1,irescol2,iseqncol1,iseqncol2,
     -  isegcol1,isegcol2,iqcol1,iqcol2,idcol,nneig,nneiga,nhbneig,
     -  ineig,nhneig,nnneig,ncneig,nsneig,npneig,numres,numslv,
     -  resnamslv,line,blankline,mmtype,ibnd,index,indexn,indexo,indexs,
     -  indexdel,indexa,mmtype,indexsup,atw,edge,ifree,namin,namout,
     -  resin,resout,icntrl,icntrlw,iha,molresflag,temp,rprox,
     -  irescount3,hblimfac,angmin,iconfsel,numsel,nextconfsel,
     -  molsltlim,nmolslt,nmolsltnoion,0,minresflag,iqspaceask,1,
     -  iwriteatsym,radtodeg,tofac,0,ipbcinp,0,maxconfsel,maxrepconf,
     -  igl,pi,MAXRSD,MAXNEIG,MAXREC)
      stop
c-----Animate trajectory
9800  continue
C@GL      call animatetraj(idmol,inptrajtyp,mmctrajtyp,n,nslt,
C@GL     -  naslv,resnamslv,iatnum,isc,c,co,c1,nneig,nhneig,
C@GL     -  nhbneig,ineig,innlist,isegno,ih,nnh,
C@GL     -  ifree,icntrl,segid4,nsegcol,nsegslt,inamcol1,
C@GL     -  inamcol2,ireorient,iacent,icentgra,centgra,tofac,
C@GL     -  MAXNEIG,MAXREC)
      stop
c-----Unpack trajectory
9900  call unpacktraj(inptrajtyp,mmctrajtyp,inpcrdtyp,iotyp,
     -  inpcrdtyporg,n,nslt,naslv,iislvw,numres,numslv,resnamslv,iatnum,
     -  ifchrg,ixres,atnames,resnames,segnames,marker,ireseq,
     -  iresnrestart,iresidrestart,c,rprox,cv,charge,ntitlin,title,
     -  nneig,nneiga,nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,
     -  isegno,iresno,line,blankline,ifree,icntrl,innlist,mmtype,ibnd,
     -  index,indexn,indexo,molresflag,hblimfac,angmin,ioppbc,cell,
     -  ncell,ionefile,iwhead,imodel,numsel,iconfsel,irescount3,
     -  nclstmem,numconsec,incr_fileno,nextconfsel,iqspaceask,keeprem,
     -  radtodeg,ioverallconf,maxconfsel,maxrepconf,MAXNEIG,MAXRSD,
     -  MAXREC,MAX2D)
      stop
c-----Create residue trace PDB file
8100  if (inpcrdtyp .gt. ioins) then
        print *,'This input format does not have enough information'
        stop
      end if
      write (6,2071) outfile(1:namleno)
      write (iuout,2069)
      do il=1,ntitlin
        if (ispdb(inpcrdtyp) .gt. 0) then
          write (iuout,1000) line(il)(1:80)
        else if (ischarmm(iotyp) .eq. 1) then
          write (iuout,2070) line(il)(3:75)
        else if (inpcrdtyp .eq. iommod) then
          write (iuout,2070) line(1)(1:70)
          write (iuout,2070) line(1)(71:132)
        else
          write (iuout,2070) line(il)(1:73)
        end if
      end do
      if (nconfig .eq. 1) then
        call modrepats
        call askyn('Do you want to limit trace to CA-s',34,1,-1,icaonly,
     -    6)
      end if
      segnam='    '
      nresf=0
      do ir=1,numresslt
        call findat(iarep,ifres(ir),ilres(ir),line,index,
     -    irescol1,inamcol1,MAXREC)
c       print *,'ia,irf=',ia,irf
        atomnam='        '
        atomnam(1:nnamcol)=line(index(iarep))(inamcol1:inamcol2)
        resnam='        '
        resnam(1:nrescol)=line(index(iarep))(irescol1:irescol2)
        segnam(1:nsegcol)=line(index(iarep))(isegcol1:isegcol2)
        if (inpcrdtyp .ne. iobpdb) segnam(1:1)=abc(isegno(iarep))
        call leftadjustn(atomnam,rnn,8)
        if (icaonly .eq. 0 .or. rnn .eq. calpha(1:nnamcol)) then
          nresf=nresf+1
          call createrec(ansline,inpcrdtyp,iobpdb,c(1,iarep),c(2,iarep),
     -      c(3,iarep),atomnam,resnam,segnam,nresf,nresf,nresf,
     -      chnam,potnam,1.0,1.0,1,1,'  ',nneig(iarep),ineig(1,iarep),
     -      ibnd,blankline)
          write (iuout,1000) ansline(1:80)
          indexn(nresf)=iarep
        end if
      end do
      if (nconfig .eq. 1)
     -  call askyn('Do you want CONECT records written in the PDB file',
     -    50,1,-1,iwritecon,0)
      if (iwritecon .eq. 1) then
        do ir=2,nresf
          iat=indexn(ir)
          iatprev=indexn(ir-1)
          if (isegno(iat) .eq. isegno(iatprev))
     -      write (iuout,1110) ir,ir-1
        end do
      end if
      write (iuout,1000) 'END'
      go to 9910
c-----Create a Grasp .crg  or UGBD .   file
9630  namleno=0
      call openfile(iuout,0,'output',6,'new',outfile,namleno,notfnd,
     -  0,1,1,0,0)
      write (6,1000) RTFtyps
      ncol=5
      if (iruntyp .eq. 23) ncol=7
      nconvdat=0
      call getrtfdat(nconvdat,ncol,iconvtyp,ntypedat)
      if (iruntyp .eq. 22)
     -   call writegrasp(iuout,nconvdat,analfile,namlena)
      if (iruntyp .eq. 23)
     -   call writeUHBD(iuout,nconvdat,analfile,namlena,iconvtyp)
      stop
c-----Replace coordinates
9640  if (n .lt. nref) write (6,2090) 'more',nref,n
      if (n .gt. nref) write (6,2090) 'less',nref,n
      if (n .ne. nref)  call askstop(0)
      if (ioverlay .eq. 0) then
c       Just copy
        if (anscnv .eq. 'n') call trnsfr(c,co,3*nref)
        if (anscnv .eq. 'h') call trnsfr(charge,cv,nref)
        nerr=0
        do ia=1,min0(n,nref)
          if (iatnum(ia) .ne. indexa(ia)) then
            write (6,2091) ia,iatnum(ia),indexs(ia)
            nerr=nerr+1
          end if
        end do
        if (nerr .eq. 0) print *,'All atomic numbers matched'
        if (nerr .gt. 0)  call askstop(0)
      else if (anscnv .eq. 'o') then
c       Overlay
        call askyn('Do you want to select the atoms to match',40,1,1,
     -    iselect,45)
        if (iselect .eq. 0) then
          call getint('Number of atoms to match',24,min0(n,nref),1,
     -      min0(n,nref),nmatch,0)
          call indexit(indexa,1,nmatch,0)
        else
c         call getlist(indexa,nmatch,1,n,1,MAXREC)
          call select(line,nrecdel,idcol,asterisk,n,nslt,index,ixres,
     -      isegcol1,isegcol2,iseqncol1,iseqncol2,inamcol1,inamcol2,
     -      irescol1,irescol2,iqcol1,iqcol2,charge,iatnum,nneig,ineig,
     -      indexdel,0,igl,MAXNEIG,MAXREC)
          call masktolist(indexa,indexdel,n,nmatch,0)
          write (6,2029) nmatch
        end if
        call bestoverlay(nmatch,indexa,indexa,co,c,atw,0.d0,c1,c2,temp,
     -    rot,c0,crm,0,0.001,0,MAXREC)
        call shiftmol(c,n,crm,c1,-1.0)
        call rotate_c(c1,n,rot,c2,'OVERLAY',7)
        call shiftmol(c2,n,c0,c,+1.0)
      end if
      go to 999
c-----Write Charmm RTF residue record(s)
9650  iqok=0
      if (iqcol2 .ge. iqcol1) iqok=1
      ipotok=0
      if (ipotcol2 .ge. ipotcol1) ipotok=1
c     namin(ia): atomname; resin(ia): pf name
      do ia=1,nslt
        namin(ia)=line(index(ia))(inamcol1:inamcol2)
        if (ipotok .eq. 1) then
          namout(ia)='    '
          namout(ia)= line(index(ia))(ipotcol1:ipotcol2)
          if (inpcrdtyp .eq. ioins) resin(ia)=namout(ia)
        else
          namout(ia)='????'
        end if
        if (iqok .eq. 1) then
          read (line(index(ia))(iqcol1:iqcol2),*) charge(ia)
        else
          charge(ia)=0.0
        end if
      end do
      do ir=1,numresslt
        resnames(ir)='     '
        ia=ifres(ir)
        resnames(ir)(1:nrescol)=line(index(ia))(irescol1:irescol2)
      end do
      resnamp='    '
      do while (resnamp .ne. 'DONE')
        call getname(resnamp,len,
     -    'Residue name to print (type DONE to quit)',41,4,0)
        ir=1
        do while (resnamp .ne. resnames(ir)(1:4)
     -    .and. ir .lt. numresslt)
          ir=ir+1
        end do
        if (resnamp .eq. resnames(ir)(1:4)) then
          if (inpcrdtyp .eq. ioins) then
c           Insight .car file - convert types
            call cvffconv(cvffname,charmmname,resin(ifres(ir)),
     -        indexn(ifres(ir)),namout(ifres(ir)),ilres(ir)-ifres(ir)+1,
     -        indexa,ncvfftyp,iambig,indexs,nambig,noconv,0,maxcvfftyp)
            call refineconv(ilres(ir)-ifres(ir)+1,namout(ifres(ir)),
     -        namin,iatnum,indexa,indexn,nneig,ineig,nhneig,itemp1,
     -        indexo,MAXNEIG,maxcvfftyp,MAXREC)
c           indexn,indexo,indexa,indexs: icvff,iringtyp,iused,lstambig
            write (6,2031) noconv,nambig
            do i=1,maxcvfftyp
              if (indexa(i) .gt. 0 ) then
                if (iambig(i) .eq. 0) then
                  write (6,2032) i,cvffname(i),charmmname(i)
                else
                  write (6,2033) i,cvffname(i),charmmname(i)
                end if
              end if
            end do
          end if
          if (noconv .gt. 0) write (6,2034)
          call printrtfres(ifres(ir),ilres(ir),nneig,ineig,resnamp,
     -      charge,namin,namout,indexs,iqok,ipotok,iuout,outfile,
     -      namleno,MAXNEIG,MAXREC)
          call checkdupnames(namin(ifres(ir)),4,ilres(ir)-ifres(ir)+1,
     -      'RTF atom names',14,idup)
          if (idup .eq. 0) print *,'No duplicate names found - OK'
        else if (resnamp .ne. 'DONE') then
          print *,'No residue named ',resnamp,' was found'
        end if
      end do
      close (iuout)
      stop
c-----Cluster atoms
9660  nresfound=iresno(nslt)-iresno(1)+1
      call getrange(ifdenat,1,ildenat,nslt,incrden,1,
     -  'atoms to use for density calculation',36,nslt,115)
      if (nresfound .gt. 1 .and. incrden .gt. 1) then
        call askyn(
     -    'Do you want to increment by residue (instead of atoms)',54,
     -    1,-1,iresinc,0)
      else
        iresinc=0
      end if
      if (iresinc .eq. 0) then
c       Incrementing by atoms
        if ((ildenat-ifdenat+1)/incrden+1 .gt. MAX2D) then
          write (6,2096) MAX2D,MAX2D
          go to 9660
        end if
        na=0
        do ia=ifdenat,ildenat,incrden
          na=na+1
          call trnsfr(c2(1,na),c(1,ia),3)
          froccin(na)=froccin(ia)
          charge(na)=charge(ia)
        end do
      else
c       Incrementing by residues
        na=0
        nr=0
        iresprev=0
        do ia=ifdenat,ildenat
          iresia=iresno(ia)
          if (iresia .ne. iresprev) then
            nr=nr+1
            iresprev=iresia
          end if
          if (mod(nr,incrden) .eq. 1) then
            na=na+1
            if (na .gt. MAX2D) then
              write (6,2096) MAX2D,MAX2D
              go to 9660
            else
              call trnsfr(c2(1,na),c(1,ia),3)
              froccin(na)=froccin(ia)
              charge(na)=charge(ia)
            end if
          end if
        end do
      end if
      print *,'Extracted ',na,' atoms for clustering'
      call pairdistconf(c2,na,rmsdmn,rmsdmx)
      rmsdmin=sqrt(rmsdmn)
      rmsdmax=sqrt(rmsdmx)
      write (6,2097) rmsdmin,rmsdmax
      write (iuout,2097) rmsdmin,rmsdmax
      call indexit(indexs,1,na,0)
      call clusterdistr(na,iuout,temp,rmsdmn,rmsdmx,nhbdist,itemp1,
     -  itemp2,itemp3,itemp4,indexn,indexo,ncl,indexa,indexs,ixclst,
     -  itemp5,value,ifa_s,ila_s,ih,cv,0.0,rdclust,etotsaved,0,'RMSD',
     -  4,1,1,irepav,irepmx,irepeng,irepkm,engcl,c2,co,c1,na,0,iclstyp,
     -  iwt,0,label,500,0,idistprint,1,1,igl,MAX2D,1)
      call printclusterext(c2,co,ncl,indexn,indexo,ixclst,na,
     -  iclstyp,outfile,namleno,iuout)
      close (iuout)
      call printclusterpdb(c2,froccin,charge,ncl,indexn,indexo,ixclst,
     -  title,na)
      call countsim(indexn,indexo,ixclst,ncl,0.0,rmsdsim,iorig,iuout,
     -  MAX2D)
c-----Cluster data
9670  call read_distmat(10,n,distmin,distmax,indexdel,label,inpfile,
     -  iuout,igl,MAX2D)
      call indexit(indexs,1,n,0)
      call clusterdistr(n,iuout,temp,distmin,distmax,nhbdist,itemp1,
     -  itemp2,itemp3,itemp4,indexn,indexo,ncl,indexa,indexs,ixclst,
     -  itemp5,value,ifa_s,ila_s,ih,cv,0.0,rdclust,etotsaved,0,
     -  'Distance',8,1,1,irepav,irepmx,irepeng,irepkm,engcl,c2,co,c1,1,
     -  0,iclstyp,iwt,0,label,500,1,idistprint,1,1,igl,MAX2D,1)
      call countsim(indexn,indexo,ixclst,ncl,0.0,rmsdsim,iorig,iuout,
     -  MAX2D)
      stop
c-----Separate MMC trajectory into fixed number trajectories
9680  continue
      call splittraj_MMC_Amb(inptrajtyp,mmctrajtyp,inpcrdtyp,
     -  nslt,naslv,c,icntrl,ifree,iconfsel,title,trtitle,indexn,indexo,
     -  indexs,maxconfsel,maxrepconf,MAXREC)
      stop
c-----Reverse orientational optimization
9685  call reverse_opt(c,n,line,maxat)
      go to 999
c-----Generate unit cell from asymmetric unit
9690  call makeunitcell(10,inpfile,namleni,inpcrdtyp,c,c1,atw,nslt,
     -  numresslt,nsegslt,segid4,molsltlim,line,index,iruntyp-33,iuout,
     -  outfile,namleno,itemp1,radtodeg,MAXRSD,MAXREC)
      stop
c-----Creat a retro-inverso peptide from a normal one
9710  chain1=line(index(1))(isegcol1:isegcol1)
      read (line(index(1))(iseqncol1:iseqncol2),*) ia1
      iaincr=ia1-1
      call retroinverso(c,nslt,iatnum,line,index,chain1,nsegm,iaincr,
     -  inamcol1,inamcol2,iresncol1,iresncol2,irescol1,irescol2,pi,
     -  ifail,nneig,ineig,itemp1,iuout,MAXNEIG,MAXREC)
      if (ifail .eq. 0) write (6,1223) outfile(1:namleno)
      if (ifail .gt. 0) close(iuout,status='delete')
      stop
c-----Filter the file through the sorting and resequencing routines
999   if (iotyp .eq. iograsp) go to 998
      if (nrotwarn .gt. 0) write (6,1213) nrotwarn,nrottest,devmax
      if (iotyp .eq. iomol2) then
        print *,'Sorry - output in .mol2 format is not implemented'
        stop
      end if
      iatfirst=1
      iresfirst=1
      iresidfirst=1
      iremove_segid=0
      if (iruntyp .eq. iruntypclean) then
        if (nconfig .eq. 1) then
          call askyn('Do you want to override/remove the segmentid',44,
     -      1,-1,ioverride,131)
          if (ioverride .eq. 1) then
            call askyn('Do you want to just remove the segmentid',40,1,
     -        -1,iremove_segid,0)
            if (iremove_segid .eq. 1) then
              do ia=1,n
                call blankout(line(index(ia)),isegcol1,isegcol2)
              end do
            else
              if (innlist .eq. 0)
     -          call nnlist(nslt,islvw,naslv,n,iatnum,ifchrg,c,nneig,
     -            nneiga,nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,
     -            npneig,line,irescol1,irescol2,inamcol1,inamcol2,index,
     -            nconfig,innlist,molresflag,hblimfac,angmin,0,ibnd,
     -            ifgtyp,isegno,ixres,maxrepconf,0,radtodeg,
     -            MAXNEIG,MAXNEIG,MAXRSD,MAXREC)
c             indexa,indexn,indexo: iclst,ifirst,ilast
              call clstrs(ineig,nneig,indexs,1,nslt,indexa,indexn,
     -          indexo,0,nofcls,mmtype,0,mmtype,0,77,inperr,0,MAXREC,
     -          MAXREC,MAXNEIG)
              nmix=0
              do ic=1,nofcls
                do ia=indexn(ic),indexo(ic)
                  atw(ia-indexn(ic)+1)=indexa(ia)
                end do
                nmem=indexo(ic)-indexn(ic)+1
                call indexit(indexs,1,nmem,0)
                call mrgsrt(6,indexs,atw,nmem,indexa,ifree,mmtype,cv,
     -            MAXREC)
                do ia=indexn(ic),indexo(ic)
                  indexa(ia)=atw(ia-indexn(ic)+1)
                end do
                write (6,1218) ic,indexa(indexn(ic)),indexa(indexo(ic))
                if (indexo(ic)-indexn(ic) .ne.
     -               indexa(indexo(ic))-indexa(indexn(ic))) then
                   write (6,1219) ic
                  nmix=nmix+1
                end if
              end do
              if (nmix .eq. 0) then
                do ic=1,nofcls
                  do ia=indexn(ic),indexo(ic)
                    isegno(ia)=ic
                    line(index(ia))(isegcol1:isegcol1)=abc(ic)
                  end do
                end do
                nsegadd=nofcls-nsegslt
                nsegslt=nofcls
                nsegm=nsegm+nsegadd
                do ia=nslt+1,n
                  isegno(ia)=isegno(ia)+nsegadd
                  line(index(ia))(isegcol1:isegcol1)='W'
                end do
              else
                write (6,1221)
              end if
            end if
          end if
          if (iruntyp .ne. 28)
     -     call set_pdbinfo(iotyp,iwriteatsym,iwritecon,iobpdb,iocpdb,1)
          if (iwritecon .gt. 0) then
            nwrconn=nslt
            if (iwconnslv .eq. 1) nwrconn=n
            if (n .gt. nslt) call askyn(
     -       'Do you want to write CONECT records for the solvents too',
     -        56,1,-1,iwconnslv,0)
            if (innlist .eq. 0)
     -        call nnlist(nslt,islvw,naslv,n,iatnum,ifchrg,c,nneig,
     -          nneiga,nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,
     -          line,irescol1,irescol2,inamcol1,inamcol2,index,nconfig,
     -          innlist,molresflag,hblimfac,angmin,0,ibnd,ifgtyp,isegno,
     -          ixres,maxrepconf,0,radtodeg,MAXNEIG,MAXNEIG,MAXRSD,
     -          MAXREC)
          end if
        end if
      end if
      if (nconfig .eq. 1 .and. natomadd .eq. 0)
     -  call askyn('Do you want the atoms sorted',28,0,-1,nosort,0)
      if (iruntyp .le. 5 .or. iruntyp .eq. 7 .or. iruntyp .eq. 15 .or.
     -    (iruntyp .eq. 28 .and. anscnv .ne. 'h') .or.
     -    iruntyp .eq. 33) then
c       Write back the new coordinates
        do ia=1,n
          if (iotyp .eq. iocha) then
            icinc=0
            if (ia .ge. 1000000) icinc=1
            write (line(index(ia))(iccol1+icinc:iccol2+icinc),1101)
     -        (c(k,ia),k=1,3)
          else if (iotyp .eq. iochaex) then
            write (line(index(ia))(iccol1:iccol2),1105) (c(k,ia),k=1,3)
          else if (ispdb(iotyp) .gt. 0) then
            write (line(index(ia))(iccol1:iccol2),1102) (c(k,ia),k=1,3)
          else if (iotyp .eq. iommod) then
            write (line(index(ia))(iccol1:iccol2),1103) (c(k,ia),k=1,3)
          else if (iotyp .eq. ioins) then
            write (line(index(ia))(iccol1:iccol2),1104) (c(k,ia),k=1,3)
          else if (iotyp .eq. iommc) then
            write (line(index(ia))(iccol1:iccol2),1101) (c(k,ia),k=1,3)
          else if (iotyp .eq. ionxyz .or. iotyp .eq. iosxyz .or.
     -             iotyp .eq. iosxyzrq) then
            icol=1
            call nextchar(line(index(ia)),icol,132)
            call nextblank(line(index(ia)),icol,132)
            write (line(index(ia))(icol:ncol),1104) (c(k,ia),k=1,3)
          end if
        end do
      end if
      if (iruntyp .eq. 28 .and. anscnv .eq. 'h') then
c       Write back charges
        do ia=1,n
          write (line(index(ia))(iqcol1:iqcol2),1106) cv(ia)
        end do
      end if
      if (nconfig .eq. 1 .and.
     -    ispdb(iotyp) .gt. 0 .and. noreg .eq. 0) then
        do ia=1,n
          call regularpdb(line(index(ia))(inamcol1:inamcol2),
     -      line(index(ia))(inamcol1:inamcol2),1)
        end do
      end if
      if (iruntyp .eq. 28) then
        if (anscnv .eq. 'h') write (6,1222) 'charges'
        if (anscnv .ne. 'h') write (6,1222) 'coordinates'
        call writeout(iuout,inpcrdtyp,iotyp,line,index,isegno,n,
     -    marker,1,1,0,ntitlin,ntitlinw,title,blankline,nosort,1,0,
     -    0.0,0,0,0,keeprem,iwriteatsym,iatnum,MAXREC)
        stop
      end if
      if (iotyp .eq. iobpdb .and. n .gt. 0 .and.
     -    iremove_segid .eq. 0) then
c       If PDB record has no chain ID, put A-Z-a-z-0-9 (increment after TER)
        iseg_slv=0
        i62warn=0
        do ia=1,n
          if (line(index(ia))(isegcol1:isegcol2) .eq. ' ') then
            if (iseg_slv .gt. 0) then
              line(index(ia))(isegcol1:isegcol2)=segid_slv
            else if (isegno(ia) .le. 62) then
              line(index(ia))(isegcol1:isegcol2)=abc(isegno(ia))
            else
              line(index(ia))(isegcol1:isegcol2)='9'
              i62warn=1
            end if
          end if
          if (iseg_slv .eq. 0 .and. iresno(ia) .eq. numresslt+1) then
            segid_slv=line(index(ia))(isegcol1:isegcol2)
            iseg_slv=isegno(ia)
          end if
        end do
        if (i62warn .eq. 1) print *,'WARNING: ',
     -    'After the 62nd TER record ALL segments are labeled 9'
      else if (iotyp .eq. iommod) then
c       Make sure both protein residue names are present
        do ia=1,nslt
          resnam='        '
          resnam(1:nrescol)=line(index(ia))(irescol1:irescol2)
          if (inpcrdtyp .eq. iommod) resnam1=line(index(ia))(95:95)
          if (inpcrdtyp .ne. iommod) resnam1=' '
          if ((resnam .eq. '     ' .or. resnam .eq. 'UNK  ')
     -      .and. resnam1 .ne. ' ') then
            call changeprot(resnam,resnam1,1)
            line(index(ia))(irescol1:irescol2)=resnam(1:nrescol)
          else if ((resnam1 .eq. ' ' .or. resnam1 .eq. 'X') .and.
     -             resnam .ne. '     ') then
            call changeprot(resnam,resnam1,2)
            line(index(ia))(95:95)=resnam1
          end if
        end do
      end if
c     Perform the actual elimination of the record now
998   write (6,2039) nconfig,nrecdel,n
      call atomdel(line,idcol,asterisk,n,nslt,nrecdel,c,isegno,index,
     -  indexn,indexo,iotyp,iatnum,charge,iresno,ixres,ifres,ilres,
     -  nconfig,nfindel,MAXRSD,MAXREC)
c     print *,'atomdel done'
c     Perform sort/resequence operations
      if (iotyp .lt. ioins .and. iruntyp .ne. 13 .and.
     -    nosort .eq. 0) then
        call sortatres(line,n,index,indexn,indexo,nhbneig,nneiga,
     -    iresno,nsneig,npneig,iresncol1,iresncol2,isegno,marker(iotyp),
     -    iotyp,nconfig,20,maxrepconf,MAXREC)
        call trnsfi(isegno,npneig,n)
        do i=1,n
          read (line(index(i))(iresncol1:iresncol2),*) iresno(i)
        end do
      end if
c     print *,'sortatres done'
      ireseqdef=-1
      if (iruntyp .eq. iruntypclean .or. nlpdel+natsdel+nfindel .gt. 0)
     -  iresqdef=1
      if (ischarmm(iotyp) .eq. 1 .or. ispdb(iotyp) .gt. 0 .or.
     -    iotyp .eq. iommod .or. iotyp .eq. iommc) then
        call reseq(line,index,n,nslt,nsegm,iatfirst,iresfirst,
     -    iresidfirst,iotyp,iresno,resnames,numres,numslv,naslv,
     -    resnamslv,iresnrestart,iresidrestart,nconfig,ireseq,ireseqdef,
     -    MAXRSD,MAXREC)
      end if
c     print *,'reseq done'
      call writeout(iuout,inpcrdtyp,iotyp,line,index,isegno,n,marker,1,
     -  1,0,ntitlin,ntitlinw,title,blankline,nosort,0,0,0.0,0,0,
     -  iwritecon,keeprem,iwriteatsym,iatnum,MAXREC)
      if (iwritecon .gt. 0) then
c       For PDB format, write out the connectivity info (if asked for)
        nwarn=0
        nwrconn=nslt
        if (iwconnslv .eq. 1) nwrconn=n
        do ia=1,nwrconn
          nndone=0
          do il=1,(nneig(ia)-1)/3+1
            write (iuout,1110) ia,(ineig(in,ia),
     -        in=nndone+1,min0(nneig(ia),nndone+3))
            nndone=nndone+3
          end do
          if (nneig(ia) .eq. 0 .and. (iatnum(ia) .lt. 10 .or.
     -      (iatnum(ia) .gt. 14 .and. iatnum(ia) .lt. 18) .or.
     -       iatnum(ia) .eq. 35 .and. iatnum(ia) .lt. 53)) then
            write (6,2108) ia,iatnm2(iatnum(ia))
            nwarn=nwarn+1
          end if
          if (iatnum(ia) .eq. 1 .and. nneig(ia) .gt. 1) then
            write (6,2109) ia,nneig(ia)
            nwarn=nwarn+1
          end if
        end do
        if (nwarn .gt. 0) write (6,2110)
        write (iuout,1000) 'END'
      end if
c     print *,'writeout done'
      if (nconfig .eq. 1 .and. numres-numslv .gt. 0)
     -  call writeseq(outfile,namleno,numres,resnames,dssplab,numslv,
     -  line,index,iotyp,title,nslt,n,0,igl,MAXRSD,MAXREC)
c-----Check for additional configurations, loop back.
9910  if ((iruntyp .eq. iruntypclean .or. iruntyp .eq. 13 .or.
     -     (iruntyp .eq. 10 .and. itraj .eq. 0) .or. iruntyp .eq. 9 .or.
     -     iruntyp .eq. 15 .or. iruntyp .eq. 20)
     -  .and. nconfig .eq. 1 .and. nconfadd .eq. 0) then
c       Cleanup, conversion or analysis can be run on a batch of configurations
        call getint('Number of additional configurations to process',46,
     -      0,1,0,nconfadd,42)
        if (nconfadd .ge. maxrepconf) write (6,2111) maxrepconf
      end if
      if (nconfadd+1 .gt. nconfig) then
        if (ixcluster .eq. 0) then
          go to 99
        else
          call readxcluster(n,c,10,nconfig)
          inpcrdtyp=iotyp
          call setcol(inpcrdtyp,ncol,idcol,ialtcol,
     -      inamcol1,inamcol2,irescol1,irescol2,iccol1,iccol2,
     -      iresncol1,iresncol2,iseqncol1,iseqncol2,isegcol1,isegcol2,
     -      iresidcol1,iresidcol2,iqcol1,iqcol2,ipotcol1,ipotcol2,
     -      iocccol1,iocccol2,ichemcol1,ichemcol2,nrescol,nresncol,
     -      nsegcol,nnamcol,iofull)
          go to 990
        end if
      end if
      stop
9999  if (iruntyp .ne. 14 .or. n .eq. 0)
     -  print *,'WARNING: Run out of data prematurely'
      stop
1000  format(a)
1007  format(i5)
1101  format(3f10.5)
1102  format(3f8.3)
1103  format(3f12.5)
1104  format(3f15.9)
1105  format(3f20.10)
1106  format(f6.3)
1107  format(3f12.5)
1110  format('CONECT',4i5)
1200  format(' PROGRAM ERROR: invalid parameters',/,
     -  ' - IFILL*s have to be positive'/,
     -  ' IFILL1=',i10,' IFILL2=',i10,' IFILL3=',i10,' IFILL4=',i10,/,
     -  ' IFIIL5=',i10,' IFILL6=',i10,' IFILL7=',i10,' IFILL8=',i10,/,
     -  ' IFIIL9=',i10,/,' MAXREC=',i10,' MAXNEIG=',i10,' MAXPHI=',i10,
     -  ' MAX2D=',i10,/,' MAXCV=',i10,' MAXRCORR=',i10,' MAXRSD=',i10)
1201  format(' PROGRAM ERROR: invalid parameters: MAX2D (',i6,')**2',/,
     -  ' must be larger than 27*MAXREC (',i9,')')
1202  format(' PROGRAM ERROR: invalid parameters: MAX2D (',i6,')',/,
     -  ' can not be greater than MAX',a,'S (',i9,')')
1203  format(' Fix the PARAMETER statements - see comments at the top',
     -  ' of the source code')
1204  format(/,' WARNING: you are running on the cluster head node')
1205  format(' WARNING: This calculation may be quite time consuming',/,
     -  7x,'Please, log on to a compute node and restart')
1206  format(' NOTE: atoms',i7,' (',a,') res#',i6,' (',a,') &',i7,
     -  ' (',a,') res#',i6,' (',a,')',/,7x,'are too close (',f4.2,' A)')
1207  format(' NOTE: atoms',i7,' and',i7,' are too close (',f4.2,' A)')
1208  format(' A total of ',i7,' atom pairs were closer than',f5.2,' A')
1209  format(' This trajectory format does not carry the energy',/,
     -  ' - use MMC binary format to save the energy')
1210  format(a6,' The program SIMULAID moved the coordinates',
     -  ' to the center of the smallest',/,
     -  a6,' surrounding sphere with radius=',f8.3,' A volume=',f12.2,
     -  ' A**3',/,a6,' accomodating ',i6,' waters (when empty)',/,
     -  a6,' Adding a ',f8.3,' A layer would require',i6,' waters',
     -  '  (when empty)')
1211  format(a6,' The number of solvents were reduced from',i6,' to',i7)
1212  format(' ERROR: Number of nonsolute atoms is not a ',
     -  'multiple of the number of solvent',/,8x,'atoms (',i5,
     -  ') No trimming will be performed')
1213  format(' NOTE:',i6,' rotation matrix elements deviated from ',
     - 'orthogonality',/,' by more than 0.1 (out of ',i10,' tests);',
     -  ' largest deviation=',f6.4)
1214  format( 'Original number of solvents=',i6,/,
     -  ' number of solvents remaining within a sphere of radius',
     -  f6.2,' A =',i6)
1215  format(' There are no solvents in this structure - there is ',
     -  'nothing to trim.'/,
     -   ' Are you sure your solvent has residue name ',a,' ?')
1216  format(' WARNING:',i5,' non-solvent atoms were found mixed into',
     -  ' the solvents',/,9x,'Solute atoms found after the first ',
     -  'solvent may be ignored',/,9x,
     -  'You may want to restart and specify a different solvent name')
1217  format(' Number of residues exceeds ',i9,' redimension with ',
     -  ' increased parameter MAXRSD')
1218  format(' Cluster ',i3,' atom range: ',i6,' - ',i6)
1219  format(' Cluster ',i3,' members are not contiguous')
c1220  format(a6,' The program SIMULAID oriented the principal',
c     -  ' axis ',/,a6,' along the diagonal of the cell',/,
c     -  a6,' with minimum image-image distace of',f6.2,' A  ',
c     -  ' Closest image distance=',f8.3,' A',/,a6,' Cell volume=',
c     -  f12.2,' A**3 accomodating ',i5,' waters',/
c     -  a6,' Cell parameters=',3f10.6,' A')
1221  format(' Segment id override canceled since some segments are ',
     -  'not contiguous')
1222  format(' Records unchanged apart from the ',a)
1223  format(' Retro-inverso peptide is written to file ',a)
1224  format(' Number of atoms found in the input file=',i7,/,
     -  ' Title read:',/,1x,a)
1225  format(10x,'Functions requiring sizable CPU time should be ',
     -  'run on a compute node')
1226  format(/,' WARNING: could not determine if this is a cluster ',
     -  'headnode')
 
1230  format(a6,' The program SIMULAID optimized the orientation',
     -  ' of the molecule',/,
     -  a6,' in a periodic ',a,' cell')
1231  format(a6,' The vertex of the hexagon is on the ',a1,' axis')
1232  format(a6,' Minimum image-image distance requested=',f6.2,' A')
1233  format(a6,' Cell volume=', f12.2,' A**3 accomodating',i6,
     -  ' waters',/,a6,' Cell parameter(s)=',3f10.6)
1240  format(a6,' The geometry of the water molecules was changed',
     -  ' to canonical',/,a6,' R(O-H)=',f10.5,' A  H-O-H angle=',f10.4,
     -  ' deg')
1250  format(a6,' Waters (',a,') outside the simulation box were ',
     -  'dropped',/,a6,' Cell shape: ',a20,/,
     -  a6,' Cell parameters=',3f10.6)
1251  format(a6,' origin=',3f10.6)
1255  format(' WARNING: the solute contains ',i6,' water molecules',/,
     -  10x,'These waters will not be treated as solvents',/,
     -  10x,'This may be result of incorrectly specified ',
     -  'solvent residue name')
1256  format(' WARNING: atomnames in structure and ',a,
     -  ' files differ:',/,' atom# ',i6,' name=',a,1x,a,' name=',a)
1257  format(' WARNING: ',i6,' atom names in the structure read ',
     -  'did not match',/,' the names in the ',a,' file.')
1258  format(' Name difference is due only to different adherenece to ',
     -  'the PDB name convention',/,' - Simulaid can change it with ',
     -  'the regularizing or undo regularizing function')
1261  format(i7,4f10.5,i5,2x,2a4)
1262  format(1x,a6,4f10.5,i5,a1,1x,2a4)
1263  format(1x,a6,4f10.5,i5,a1,1x,2a4,10x,a4)
1264  format(' The system will be shifted by ',3f10.5)
1265  format('   0.0        ',/,3f15.9,/,
     -  i5,'  3830 30779 55730   639      1357')
1266  format(' PSF file had an error at atom #',i8,' col=',i2,
     -  ' - last line read:',/,a)
c1274  format(a6,' Atom and residue names converted from ',a8,' to ',a8,
c     -  ' by SIMULAID')
1275  format(a6,' Atomnames regularized to PDB conventions by',
     -  ' SIMULAID')
1276  format(' Number of solute residue names changed=',i5,/,
     -  ' Number of solute atom names changed=',i5)
1277  format(a6,' Leading numerals have been moved back from atomnames',
     -  ' by SIMULAID')
1278  format(' NOTE: atom names in ',a,' convention are left-adjusted.',
     -  /,'       However,',i7,' atom names have a leading blank',/,
     -  '       (atom names can be left-adjusted with Simulaid)')
1297  format(' NOTE: atomnames, potential types are the chemical ',
     -  'names')
1298  format(' Segmentid=A, Resid=RESI Res.num.=1, charge=0.0')
1299  format(' Segmentid=A, Resid=RESI')
2000  format(/,' SIMULAID: simulation setup and analysis utilities,',
     -  ' written by Mihaly Mezei ',/,' Version ',a8,'; Memory use=',i4,
     -  ' Mb; Maximum number of input records=',i6,
     -  /,' M. Mezei, J. Comp. Chem., Vol 31, 2658-2668 (2010).',
     -  ' DOI:10.1002/jcc.21551')
2001  format(' Original position of the center [Shift vector*(-1)]= ',
     -  3f8.3,' A')
2002  format(' PROGRAM ERROR in the ',a,' menu - invalid code:',a)
2003  format(' Optimizing orientation to minimize the bounding ',
     -  'cube/rectange')
2004  format(' NOTE: input prompts showing ? will yield an ',
     -  'explanation by typing just a ?')
2005  format(' Running on host ',a)
2006  format(' Original closest approach=',f8.3,' A',
     -  ' Nearest image atoms:',2i5)
2007  format(' Optimizing the orientation of the molecule in the',
     -  ' simulation cell')
2008  format(' Calculating the smallest enclosing sphere')
2009  format(' Keyboard inputs will be logged in the file ',a)
2010  format(' WARNING: Only the first three characters of the residue',
     -  ' name will be used')
2011  format(/,' Number of waters (',a,') found=',i5)
2012  format(' WARNING: solvent box will not be aligned with the ',
     -  'coordinate axes.',/,10x,'It is better to optimize the ',
     -  'orientation BEFORE solvating')
2013  format(' Mean O-H bondlength=',f9.5,' A S.D.=',f8.5,/,
     -  ' Mean H-O-H angle   =',f9.5,' deg S.D.=',f8.5,/,
     -  ' O-H bondlength range: [',f8.5,',',f8.5,']',/,
     -  ' H-O-H angle range   : [',f8.4,',',f8.4,']')
2014  format(' O-H distance=',f7.5,' A',10x,'H-O-O angle=',f8.3,' deg')
2015  format(' Solvent residue name in the input file:',a)
2016  format(' Unpacked configurations will be in ',a,' format')
2017  format(' Number of atoms printed=',i6,
     -  ' Number of residues found=',i5,/,' Total charge=',f8.3,/,
     -  ' (Charge sum is a sensitive indicator of the correctness',
     -  ' of the conversion)')
2018  format(' WARNING: Solute atom',i6,' is outside the ',
     -  'simulation cell')
2019  format(' Smallest image distance in best orientation (',a,')=',
     -  f8.3,' A',/,' Nearest image atoms=',2i5)
2020  format(' Nucleic acids are in Oxy form')
2021  format(' Nucleic acids are in Deoxy form')
2022  format(' NOTE: PATCH residues have to be edited/checked manually')
2023  format(' Interactive quizzes will not depend on the data.',/,
     -   ' Default options will be used and a message will be printed')
2024  format(' NOTE: segment IDs are reduced to ',i1,' character')
2025  format(' WARNING: Solute atom',i6,' (',a,1x,a,') is outside the ',
     -  'simulation cell')
2026  format(' Could not improve on the initial orientation',/,
     -  ' You may try more random initial orientations')
2027  format(' Optimal orientation is from the ',i4,'th try')
2028  format(' Water # ',i6,' is too distorted - roh1=',f6.1,' A roh2=',
     -  f6.1,' A')
2029  format(' Number of atoms used for the overlay calculation=',i6)
 
2031  format(' cvff atom types in the .car file will be converted to ',
     -  'Charmm22 types',/,
     -  ' (users should check the resulting Charmm types, though)',/,
     -  ' Insight-assigned charges will be used',/,
     -  ' Number of missing conversions=',i2,
     -  ' number of ambiguous conversions=',i2,/,
     -  ' List of conversions used:')
2032  format(' Conversion # ',i3,1x,a2,' --> ',a4)
2033  format(' Conversion # ',i3,1x,a2,' --> ',a4,
     -  ' (ambiguous conversion - check!)')
2034  format(' Missing conversions will have Charmm atom types ??** ',
     -  '(** is the cvff label)',/,' - these should be fixed manually')
2035  format(' WARNING: optimal solute sticks out of the simulation ',
     -  'box',a,f8.2,' A',/,' - it is advisable to scale up the box')
2036  format(' The atom nearest to the cell boundary is ',f8.2,
     -  ' A away from the wall')
2038  format(' === Optimization random orientation No.',i2,' ... wait')
2039  format(' Conf',i5,' Number of atoms deleted=',i5,' (out of',i6,
     -  ')')
2040  format(5x,'First orientation is a 90 degree rotation around the ',
     -  a,' axis')
2041  format(' NOTE: segment ID is missing - you can add them with a ',
     -  'CLEAN operation or',/,7x,'add them now')
2042  format(' CHANGE the number of atoms to',i8,' in the file',/,5x,a)
2043  format('MODEL',i6)
2044  format('ENDMDL')
2045  format('REMARK Structure # ',i7)
2046  format(' NOTE: This conversion only affects the record format.',/,
     -  '     Atom and residue names are changed with the conversion ',
     -  'option',/,
     -  '     "converting to di<F>ferent PDB residue and atomname ',
     -  'convention"')
2047  format(' ERROR: this functionality is invalid for Grasp ',
     -  '.crg input')
2048  format(' The second input file should be called ',$)
2049  format('  and subsequent files should increment the .2.')
2050  format(' Leading digits of atomnames will be moved to the first ',
     -  'nonblank place',/,' four digit atomnames will be cyclicly ',
     -  'permuted')
2051  format(' Conf ',i4,':',i5,' chains/segments found in the solute')
2052  format(' Chain IDs: ',30(1x,a))
2053  format(i5,1x,a4,' Ats:',i6,'-',i6,' Res num:',i5,'-',i5,
     -  ' Res ix:',i5,'-',i5)
2054  format(' Conf ',i7,': No solute was found')
2055  format(' Smallest cell will be found with minimum image-image ',
     -  'distance of',f6.1,' A')
2056  format(' Hydrogens will be ',a,' the optimization')
2057  format(' There are ',i5,' backbone atoms and ',i7,
     -  ' putative side chain solute atoms')
2058  format(' Generating trajectory for cluster ',i4,' with',i6,
     -  ' members',/,' Cluster trajectory:',a)
2059  format(' WARNING:',i5,1x,a,' numbers were blank in the input ',
     -  'file')
2060  format(10x,'This is likely due to incorrect input file format ',
     -  'and cause a crash')
2061  format(10x,'You may try a Clean operation')
2062  format(10x,'All blank residue fields will be read as zero')
2063  format(' ERROR: Number of solute atoms can not be changed')
2064  format(' Input is already in the requested format')
2065  format(' NOTE: Number of solute atoms changed')
2066  format(' The center of the cell=',3f10.5)
2067  format(8x,'Previous # of atoms=',i6,' current # of atoms=',i6)
2068  format(' <B>=',f7.1)
2069  format('REMARK Residue trace (by default alpha carbon) PDB file')
2070  format('REMARK ',a)
2071  format(' PDB file with residue trace will be written to ',a)
2072  format(' Input configuration is multiplied by the matrix',/,
     - (10x,3f11.7))
2073  format(a6,' Multiply by the matrix below to recover the ',
     -  'original orientation',/,(a6,1x,a4,a1,i1,5x,3f11.7))
2074  format(' Optimized configuration was shifed to (0,0,0) from',/,
     - 10x,3f15.6)
2075  format(a6,' Original position is recovered with translation by',/,
     - a6,1x,a4,a1,5x,3f15.6)
2076  format(' The solute did not fit in the cell in ',i4,' trial ',
     -  'conformations')
2177  format(' There are',i6,' solute segments (molecules)',/,
     -  5x,'The solvent residue name is assumed to be ',a,' and',/,
     -  5x,'the name of the last residue is ',a)
2078  format(' NOTE: residue numbers are not consecutive',/,
     -  7x,'There are',i6,' residues, starting at',i4,' ending at',i6)
2079  format(' Maximum deviation between optimal and rerotated ',
     -  'configuration=',e12.5)
2080  format(' NOTE: residue numbers start at ',i6,' (instead of 1)')
2081  format(' Smallest image-image distance calculated by full ',
     -  'enumeration',/,10x,'differs from the final value by',e9.2,' A')
2082  format(' Simulaid established the number of atoms per ',a,
     -  ' molecule as',i6,/,
     -  ' The number of solvent molecules found=',i6)
2083  format(' WARNING: the number of atoms assumed to be solvents ',
     -  '(',i6,')',/,' is not divisible by the assumed number of ',
     -  'atoms in a solvent molecule')

2090  format(' WARNING: reference structure had ',a,' atoms (',i7,') ',
     -  'than ',/,10x,'the structure modified (',i7,')')
2091  format(' WARNING: atom',i6,' atomic #=',i2,' differs from',
     -  ' the reference atomic # (',i2,')')
2096  format(' ERROR: too many atoms are requested.',/,
     -  ' Current dimensioning allows only for',i6,' * ',i6,' matrix')
2097  format(' Range of atom-atom distances found: [',f12.5,',',f12.5,
     -  '] A')
2100  format(' === Trial',i4,': edge=',3f9.4,' A vol=',e15.8,' A^3')
2101  format(a,' Edges of the smallest box still enclosing the solute:',
     -  /,a,3f10.5,' A vol=',e15.8,' A^3 Nslt=',i6)
2102  format('  === Initial box size=',3f10.5,' A volume=',e12.5,' A^3')
2103  format(' Output trajectory format:',a)
2104  format(a,'Edge of the smallest cube still enclosing the solute=',
     -  f15.7)
2105  format(a,' Possible box definition: PBCN RECT ',3f7.2,/,
     -  a,' Possible inner box definition: MOND ',6f7.2)
2106  format(' Note: ',i3,' optimizations resulted in unsatisfactory ',
     -  'image distance')
2107  format(' ERROR: no optimizations resulted in satisfactory ',
     -  'image distance',/,' - repeat with more random trys')
2108  format(' WARNING: atom # ',i6,' (',a,') has no bonds')
2109  format(' WARNING: atom # ',i6,' (a hydrogen) has ',i2,' bonds')
2110  format(' NOTE: Bond thresholds for atoms can be changed',/,
     -  7x,'- use the Analyze - Geometry/topology menu')
2111  format(' NOTE: warnings, summaries (if any) will be turned off ',
     -  'after the',i3,'-th conf.')
2112  format(' Bond between atoms ',i6,' and ',i6,' connect a ',
     -  'molecular residue (',i5,')',/' or ion to an other residue (',
     -  i5,') - it is deleted')
 
2123  format(' ERROR: file ',a,' is a ',a,' trajectory file',/,8x,
     -  'you have to specify a structure file (e.g., PDB or CRD file)')
2124  format(1x,a,': no solvent residue ',a,' was found')
      end
      subroutine readconf(ifull,inpt,inpcrdtyp,iruntyp,iruntypclean,
     -  inpfile,namleni,outfile,namleno,line,title,ititle,trtitle,
     -  ntitlin,ntitltr,nconfig,ncol,n,nlines,nsegm,nosegid,iisegcol,
     -  index,c,iresno,iatnum,isegno,froccin,charge,segid4,iundef,
     -  naltnam,nrecdel,nneig,ineig,iha,itrunc,iendfound,ioktoend,
     -  istopatend,iqha,imodelkeep,newsega,newsegr,neednnlist,ietotread,
     -  etotread,bfacavg,molname,molnamelen,iclone,igl,maxrepconf,maxng,
     -  maxrec,maxrsd)
      character*(*) inpfile,outfile
      character* 132 line(maxrec)
      character*80 title,trtitle(32),molname,linewr
      character*4 segid4(maxrsd)
      dimension c(3,maxrec),index(maxrec),iresno(maxrec),iatnum(maxrec),
     -  isegno(maxrec),froccin(maxrec),charge(maxrec),iisegcol(2,13),
     -  nneig(maxrec),ineig(maxng,maxrec),bfacavg(maxrsd)
      common /clonedat/ nclone,iaclnf(1000),iaclnl(1000),ncopcln(1000)
      character*11 formatname
      common /formats/ iqdconv(19),formatname(17)
      character*5 crdext
      common /iotypes/ iocha,iochaex,iobpdb,iocpdb,ioa3pdb,ioa4pdb,
     -  iommod,iommc,iommc4,iogro,iomol2,iomae,ioins,ionxyz,
     -  iosxyz,iosxyzrq,iograsp,iofull,lext(17),crdext(17)
      character*2 iatnm2
      common /atnam/ aw(99),nval(99),nvalmax(99),mmofan(99),
     -  mmatno(64),iatnm2(99)
      common /logging/ logfile,ipredict
      real*8 bfacsum
      character*1 altnam(50),s1,asterisk,ans
      character*2 atsymbol
      character*4 s4,segidprev
      character*8 atomnam
      character*8 segmid
      character*6 rnu
      character*51 question
      character* 132 lineinp,lineprev,linenext
      character*200 altfile
      dimension noblank3(132),in12(2)
      data nnoblank3 /15/, noblank3
     -  /1,5,11,13,19,21,27,29,35,37,43,45,51,119,124,117*0/
      data asterisk/'*'/, question
     -   /'Clone   : original index of the first and last atom'/
      iaskagain=0
      nclone=0
      iendfound=0
      iunrecog=0
      naltnam=0
      itrunc=0
      icinc=0
      nosegid=0
      etotread=0.0
      bfacsum=0.d0
      nbfacsum=0
      nbfacsumtot=0
      ikeepfullalt=-1
      call setcol(inpcrdtyp,ncol,idcol,ialtcol,
     -  inamcol1,inamcol2,irescol1,irescol2,iccol1,iccol2,
     -  iresncol1,iresncol2,iseqncol1,iseqncol2,isegcol1,isegcol2,
     -  iresidcol1,iresidcol2,iqcol1,iqcol2,ipotcol1,ipotcol2,
     -  iocccol1,iocccol2,ichemcol1,ichemcol2,nrescol,nresncol,
     -  nsegcol,nnamcol,iofull)
c     print *,'READCONF ialtcol=',ialtcol,' idcol=',idcol
      iresnoprev=0
      iresinc=0
      incresno=0
      if (iresncol2-iresncol1 .lt. 8)
     -  incresno=10**(iresncol2-iresncol1+1)-1
      nsegmid=isegcol2-isegcol1+1
      lineread=0
      if (ischarmm(inpcrdtyp) .eq. 1) then
c-------Charmm input
        call blankout(lineinp,1,ncol)
        do i=1,maxrec
          read (inpt,1001,end=9999) lineinp
          if (ifull .eq. 1) line(i)=lineinp
          if (i .eq. 1) then
             if (lineinp(1:1) .ne. '*') then
               write (6,1215) inpfile(1:namleni),'Charmm CRD'
               namleni=0
               iunrecog=1
             end if
             title=lineinp(3:80)
          end if
          if (lineinp(1:1) .ne. '*') then
            go to 11
          else if (i .gt. 32) then
            write (6,1213) 'title',i,32
            stop
          else
            trtitle(i)=lineinp(3:80)
            call checkforetot(1,lineinp,nconfig,etotread,ietotread,1)
          end if
          ntitlin=i
          ntitltr=i
          if (nconfig .le. maxrepconf) then
            call lastchar(lineinp,ifc,ncol)
            write (6,1010) lineinp(1:ifc)
          end if
        end do
c       Decode number of atoms
11      lineread=ntitlin+1
        call lastchar(lineinp,lc,ncol)
        if (lc .le. 1 .and. lineinp(1:1) .eq. ' ') go to 9917
        if (inpcrdtyp .eq. iocha) read (lineinp(1:6),*,err=9915) n
        if (inpcrdtyp .eq. iochaex) read (lineinp(1:10),*,err=9915) n
        if (ifull .eq. 1) line(lineread)=lineinp
        nlines=ntitlin+1+n
        if (n .lt. 1) then
          print *,'ERROR: non-positive number of atoms found:',n
          stop
        end if
        if (nlines .gt. maxrec) then
          write (6,1213) 'input',nlines,maxrec,' '
          stop
        end if
        print *,'Reading',n,' atoms; configuration #:',nconfig
        segmid='        '
        do i=1,n
          read (inpt,1001,end=3000) lineinp
          if (ifull .eq. 1) then
            line(ntitlin+1+i)=lineinp
            index(i)=ntitlin+1+i
          end if
          if (i .gt. 1) then
            if (lineinp(isegcol1+icinc:isegcol2+icinc) .ne.
     -          segmid(1:nsegmid)) then
              nsegm=nsegm+1
            end if
          end if
          isegno(i)=nsegm
          call readint(lineinp,iresncol1+icinc,iresncol2+icinc,
     -      iresno(i),2)
          if (iresnoprev-iresno(i) .eq. incresno .and. incresno .ne. 0)
     -      iresinc=iresinc+incresno+1
          iresnoprev=iresno(i)
          iresno(i)=iresno(i)+iresinc
          lineread=ntitlin+i+1
          if (inpcrdtyp .eq. iocha) then
            read (lineinp(iccol1+icinc:iccol2+icinc),1101,err=9911)
     -        (c(k,i),k=1,3)
          else
            read (lineinp(iccol1+icinc:iccol2+icinc),1105,err=9911)
     -        (c(k,i),k=1,3)
          end if
          if (iqcol2 .ge. iqcol1)
     -      read (lineinp(iqcol1:iqcol2),*,err=9912,end=8801) charge(n)
          go to 8802
c         Blank charge field should be zero
8801      charge(n)=0.0
8802      iatnum(i)=
     -      ianum(lineinp(inamcol1+icinc:inamcol2+icinc),1,nnamcol)
          lineprev=lineinp
          if (inpcrdtyp .eq. iocha) then
            segmid(1:nsegmid)=lineinp(isegcol1+icinc:isegcol2+icinc)
          else
            call leftadjustline(lineinp,isegcol1,isegcol2)
            segmid(1:4)=lineinp(isegcol1:isegcol1+3)
          end if
          if (i .eq. 999999) icinc=1
        end do
      else if (ispdb(inpcrdtyp) .gt. 0) then
c-------PDB input
        if (nconfig .eq. 0 .and. ipredict .eq. 1) write (6,2077)
        iundef=0
        ititfound=0
        ititrfound=0
        ntitltr=0
        ntitlin=0
        naltdel=0
        linenext_read=0
        namlena=0
        molnamelen=0
        iatseqnumprev=0
        lineinp(1:1)='X'
        i=0
        do while (lineinp(1:4) .ne. 'ATOM' .and.
     -        lineinp(1:6) .ne. 'HETATM' .and. i .lt. maxrec)
          i=i+1
          call blankout(lineinp,1,ncol)
          read (inpt,1001,end=9999) lineinp
          call lastchar(lineinp,lcinp,ncol)
          lineread=i
          call checkforetot(6,lineinp,nconfig,etotread,ietotread,1)
          if (ifull .eq. 1) line(i)=lineinp
          if (lineinp(1:5) .eq. 'TITLE' .and. ititrfound .eq. 0) then
            title=lineinp(7:80)
            ititle=1
            ititrfound=1
            ititfound=1
          end if
          if (ititfound .eq. 0 .and. (lineinp(1:6) .eq. 'HEADER'
     -        .or. lineinp(1:6) .eq. 'REMARK')) then
            title=line(i)(7:80)
            ititfound=1
          end if
          if ((lineinp(1:5) .eq. 'TITLE' .or. lineinp(1:6) .eq. 'HEADER'
     -        .or. lineinp(1:6) .eq. 'REMARK')
     -        .and. ntitltr .lt. 32) then
            ntitltr=ntitltr+1
            trtitle(ntitltr)=lineinp(7:80)
          end if
          if (nconfig .le. maxrepconf) then
            if (lineinp(1:6) .eq. 'HEADER' .or.
     -          lineinp(1:5) .eq. 'TITLE' .or.
     -          lineinp(1:6) .eq. 'REMARK' .and. i .lt. 11) then
              write (6,1015) lineinp(1:min0(79,lcinp))
            end if
          end if
          if (lineinp(1:31) .eq. 'REMARK    Name               : ') then
            ic=32
            call nextblank(lineinp,ic,ncol)
            molnamelen=ic-32
            molname(1:molnamelen)=lineinp(32:ic-1)
          end if
          if (lineinp(1:5) .eq. 'MODEL') then
            if (imodelkeep .eq. -1) call quiz(ans,imodelkeep,'k',' ',0,
     -        'MODEL record treatment',22,0,5,6,igl,0)
            if (imodelkeep .gt. 1) then
              line(lineread)(1:6)='REMARK'
            end if
          end if
          ntitlin=ntitlin+1
        end do
        index(1)=ntitlin
        nlines=ntitlin
        ntitlin=ntitlin-1
        n=0
        nhdel=0
        nudel=0
        lineread=ntitlin
        do while (.true.)
          if (lineread .gt. ntitlin) then
            if (linenext_read .eq. 0) then
              call blankout(lineinp,1,ncol)
              read (inpt,1001,end=23) lineinp
            else
              lineinp=linenext
              linenext_read=0
            end if
            if (nlines .eq. maxrec) then
            write (6,1213) 'input',nlines+1,maxrec,' '
            stop
          end if
            if (ifull .eq. 1) line(lineread+1)=lineinp
            nlines=nlines+1
          end if
          lineread=lineread+1
          if (lineinp(1:5) .eq. 'MODEL') then
            if (imodelkeep .gt. 1) line(lineread)(1:6)='REMARK'
          else if (lineinp(1:6) .eq. 'ENDMDL') then
            if (imodelkeep .eq. 2) then
              line(lineread)(1:6)='REMARK'
            else if (imodelkeep .eq. 3) then
              line(lineread)(1:6)='END   '
            else if (imodelkeep .eq. 4) then
              line(lineread)(1:6)='TER   '
            end if
            go to 23
          else if (lineinp(1:3) .eq. 'END' .and. lineinp(4:7).ne. 'ROOT'
     -      .and. lineinp(4:9) .ne. 'BRANCH') then
c           Don't check for data after END for trajectory combining
            if (iruntyp .eq. 12 .and. lineinp(1:3) .eq. 'END') go to 23
            if (istopatend .eq. 1) then
              go to 23
            else if (istopatend .eq. -1) then
c             See if file ends
              call blankout(linenext,1,ncol)
              read (inpt,1001,end=23) linenext
              call lastchar(linenext,ilc,ncol)
              print *,'Data after END was found:'
              print *,linenext(1:ilc)
              linenext_read=1
              call askyn(
     -          'Do you want to replace middle END records with TER',
     -          50,0,-1,istopatend,000)
              if (istopatend .eq. 1) go to 23
              lineinp(1:3)='TER'
            else
c             Replace END with TER
              lineinp(1:3)='TER'
            end if
          end if
          if (lineinp(1:3) .eq. 'TER' .and. nbfacsum .gt. 0) then
            if (nbfacsum .gt. 0) bfacavg(nsegm)=bfacsum/nbfacsum
            nsegm=nsegm+1
            nbfacsumtot=nbfacsumtot+nbfacsum
            bfacsum=0.d0
            nbfacsum=0
          end if
          if (lineinp(1:6) .eq. 'HETATM' .and. iqha .eq. 0
     -        .and. ipredict .eq. 0) then
            call askyn('Do you want to include heteroatoms',34,1,1,iha,
     -        16)
            iqha=1
          end if
          if (lineinp(1:4) .eq. 'ATOM' .or.
     -             lineinp(1:6) .eq. 'HETATM') then
            if (lineinp(iccol1:iccol2) .eq.
     -        '************************') then
              if (iundef .eq. 0) then
                write (6,2032)
                call askyn('Do you want to drop the atom',28,1,-1,
     -            idrop,00)
                if (idrop .eq. 1) then
                  iundef=1
                else
                  iundef=2
                end if
              end if
              if (iundef .eq. 1) then
                lineinp(idcol:idcol)=asterisk
                nudel=nudel+1
c               print *,'n,nudel,idcol=',n,nudel,idcol
                go to 210
              end if
            end if
210         n=n+1
            if (n .eq. 1) segidprev='****'
            if (n .gt. maxrec) then
              write (6,1213) 'input',nlines,maxrec,' '
              stop
            end if
            if (ifull .eq. 1) index(n)=nlines
            icont=0
            if (n .eq. 1 .and. nconfig .eq. 0) then
c             Check if PDB type given corresponds to chainid input
              s4=lineinp(iisegcol(1,iocpdb):iisegcol(2,iocpdb))
              s1=lineinp(iisegcol(1,iobpdb):iisegcol(2,iobpdb))
              if (s1 .eq. ' ' .and. s4 .eq. '    ') then
                if (iruntyp .ne. iruntypclean .and.
     -              nconfig .le. maxrepconf) then
                  print *,'WARNING: segment ID is missing - you may ',
     -              'have to run a CLEAN operation'
                  nosegid=1
                end if
              else if (inpcrdtyp .eq. iobpdb) then
                if (s1 .eq. ' ') then
                  write (6,2115) 'Charmm',' ','SSSS','S','    '
                  icont=1
                end if
              else
                if (s4 .eq. '    ') then
                  write (6,2115) 'Brookhaven','S','    ',' ','SSSS'
                  icont=1
                end if
              end if
            end if
            if (icont .gt. 0) call askstop(1)
            if (lineinp(1:6) .eq. 'HETATM' .and. iha .eq. 0) then
              lineinp(idcol:idcol)=asterisk
              nhdel=nhdel+1
            else
              if (lineinp(7:11) .eq. '*****') then
                iatseqnum=iatseqnumprev+1
                write (lineinp(7:11),1007) mod(iatseqnum,100000)
              else
                read (lineinp(7:11),*) iatseqnum
              end if
              if (inpcrdtyp .eq. iocpdb .or. inpcrdtyp .eq. ioa3pdb .or.
     -            inpcrdtyp .eq. ioa4pdb)
     -          call leftadjustline(lineinp,irescol1,irescol2)
              if (n .gt. 1) then
                if (lineinp(isegcol1:isegcol2) .ne.
     -              segidprev(1:nsegmid)) then
                  bfacavg(nsegm)=0.0
                  nsegm=isegno(n-1)+1
                  if (nbfacsum .gt. 0) bfacavg(nsegm)=bfacsum/nbfacsum
                  nbfacsumtot=nbfacsumtot+nbfacsum
                  bfacsum=0.d0
                  nbfacsum=0
                else if (iatseqnum .lt. iatseqnumprev .and.
     -                   iatseqnumprev .ne. 99999) then
                  if (newsega .eq. -1) then
                    write (6,1216) iatseqnum,iatseqnumprev
                    call askyn('Do you want to start a new segment',34,
     -                1,1,newsega,000)
                  end if
                  if (newsega .eq. 1) nsegm=nsegm+1
                end if
              end if
              isegno(n)=nsegm
              iatseqnumprev=iatseqnum
            end if
            if (lineinp(iccol1:iccol2) .eq.
     -        '************************') then
              do k=1,3
                c(k,n)=999.9
              end do
              write (lineinp(iccol1:iccol2),1102) (c(k,n),k=1,3)
            else
              read (lineinp(iccol1:iccol2),1102,err=9911) (c(k,n),k=1,3)
            end if
            iatnum(n)=ianum(lineinp(inamcol1:inamcol2),1,nnamcol)
            call readint(lineinp,iresncol1,iresncol2,iresno(n),2)
            if (iresno(n) .lt. iresnoprev .and.
     -        lineinp(isegcol1:isegcol2) .eq. segidprev(1:nsegmid)) then
              if (newsegr .eq. -1) then
                write (6,1217) iresno(n),iresnoprev,iatseqnum,n
                idefans=1
                if (iresnoprev .eq. 9999) idefans=-1
                call askyn('Do you want to start a new segment',34,
     -            1,idefans,newsegr,000)
              end if
              if (newsegr .eq. 1) then
c               Increment segment number, but only when it was not already done
                isegdec=0
                if (n .gt. 1) then
                  if (isegno(n) .gt. isegno(n-1)) isegdec=1
                end if
                if (isegdec .eq. 0) then
                  nsegm=nsegm+1
                  isegno(n)=nsegm
                end if
              end if
            end if
            if (iresnoprev-iresno(n) .eq. incresno .and. incresno .ne.0)
     -        iresinc=iresinc+incresno+1
            segidprev(1:nsegmid)=lineinp(isegcol1:isegcol2)
            froccin(n)=1.0
            iresnoprev=iresno(n)
            iresno(n)=iresno(n)+iresinc
            if (iocccol2 .ge. iocccol1)
     -        read (lineinp(iocccol1:iocccol2),*,err=9912,end=8805)
     -        froccin(n)
            bfac=0.0
            read (lineinp(61:66),*,end=8805,err=8805) bfac
            bfacsum=bfacsum+bfac
            nbfacsum=nbfacsum+1
8805        if (iqcol2 .ge. iqcol1)
     -       read (lineinp(iqcol1:iqcol2),*,err=9912,end=8803) charge(n)
            go to 8804
c           Blank charge field should be zero
8803        charge(n)=0.0
          end if
8804      if (lineinp(1:4) .eq. 'ATOM' .or.
     -             lineinp(1:6) .eq. 'HETATM') then
C           if (lineinp(idcol:idcol) .ne. asterisk .and.
C    -        inpcrdtyp .eq. iobpdb) then
C             Only Brookhaven PDB has alternate location character
            if (lineinp(idcol:idcol) .ne. asterisk .and.
     -          iruntyp .ne. 21) then
              if (lineinp(ialtcol:ialtcol) .ne. ' ') then
c               Alternative location found
                if (froccin(n) .eq. 1.0) then
                  if (ikeepfullalt .eq. -1) then
                    print *,'Fully occupied alternative record found:'
                    print *,lineinp
                    call askyn(
     -              'Do you want to keep such alternative record mark',
     -              48,1,-1,ikeepfullalt,0)
                  end if
                  if (ikeepfullalt .eq. 0) lineinp(ialtcol:ialtcol)=' '
                end if
              end if
              if (lineinp(ialtcol:ialtcol) .ne. ' ') then
                if (naltnam .eq. 0) then
                  naltnam=1
                  naltrec=0
                  altnam(naltnam)=lineinp(ialtcol:ialtcol)
                  if (ipredict .eq. 0) then
                    call changeext(outfile,altfile,namleno,namlena,
     -                'alt',3,1,0)
                    call openfile(40,0,' ',1,'new',altfile,namlena,
     -                notfnd,0,1,1,0,0)
                    write (6,2040) altfile(1:namlena)
                    write (40,2044)
                  end if
                  iname=1
                else
c                 See if name already occurred
                  do iname=1,naltnam
                    if (altnam(iname) .eq. lineinp(ialtcol:ialtcol))
     -                go to 22
                  end do
                  naltnam=naltnam+1
                  iname=naltnam
                  altnam(naltnam)=lineinp(ialtcol:ialtcol)
                end if
22              if (ipredict .eq. 0) then
                  call writeline(40,lineinp,1,ncol,0)
                  naltrec=naltrec+1
                else
c                 Duplicates will be dropped - blank out alternate marker
                  lineinp(ialtcol:ialtcol)=' '
                  if (iname .ne. 1) then
                    naltdel=naltdel+1
                    lineinp(idcol:idcol)=asterisk
                  end if
                end if
              end if
            end if
            if (ifull .eq. 1) line(lineread)=lineinp
          end if
          lineprev=lineinp
        end do
23      if (nhdel .gt. 0) print *,nhdel,' heteroatoms will be deleted'
        if (nudel .gt. 0)
     -    print *,nudel,' undetermined atoms will be deleted'
        nrecdel=nhdel+nudel
        if (naltnam .gt. 0) then
          write (6,2030) naltrec,(altnam(in),in=1,naltnam)
          if (ipredict .eq. 1) write (6,2029) altnam(1)
        end if
        naltdeltot=0
        if (naltnam .gt. 0 .and. ipredict .eq. 0 .and.
     -      iruntyp .ne. 21) then
          linewr(1:39)='Do you want to drop records with mark  '
          ndrop=0
          do in=1,naltnam
            linewr(39:39)=altnam(in)
            call askyn(linewr,39,1,0,idrop,0)
            if (idrop .eq. 0) altnam(in)=' '
            ndrop=ndrop+idrop
          end do
          if (ndrop .eq. naltnam) then
            print *,'WARNING: ALL alternate records will be dropped'
            call askstop(0)
          else
            if (ndrop .eq. 0)
     -        print *,'NOTE: ALL alterante records will be kept'
            print *,'List of deleted records will be ADDED to the',
     -        ' file ',altfile(1:namlena)
          end if
          call askyn(
     -      'Do you want to blank out the alternative mark',45,1,+1,
     -      iblankalt,00)
          write (40,2045)
          do in=1,naltnam
            naltdel=0
            do i=1,n
c             Mark locations to be deleted
              if (line(index(i))(ialtcol:ialtcol) .ne. ' ') then
                if (line(index(i))(ialtcol:ialtcol) .eq. altnam(in))then
                  naltdel=naltdel+1
                  line(index(i))(idcol:idcol)=asterisk
                  call writeline(40,line(index(i)),1,ncol,0)
                end if
              end if
            end do
            if (altnam(in) .ne. ' ') then
              write (6,2043) naltdel,altnam(in)
              if (naltdel .eq. 0) print *,'PROGRAM ERROR: naltdel=0'
            end if
            naltdeltot=naltdeltot+naltdel
          end do
          if (iblankalt .eq. 1) then
            do i=1,n
              if (line(index(i))(ialtcol:ialtcol) .ne. ' ')
     -          line(index(i))(ialtcol:ialtcol)=' '
            end do
          end if
        end if
c       Get last segment bfac average
        bfacavg(nsegm)=0.0
        if (nbfacsum .gt. 0) bfacavg(nsegm)=bfacsum/nbfacsum
        nbfacsumtot=nbfacsumtot+nbfacsum
c       Check if residue number position is ok (Charmm sometimes uses col27)
        ndig27=0
        n9999=0
        ictest=27
        do ia=1,n
          if (idigit(line(index(ia))(ictest:ictest),1) .eq. 1) then
c           Residue number extends to col 27 - fix it
            call readint(line(index(ia)),iresncol1,iresncol2+1,
     -        iresno(ia),2)
            if (iresno(ia) .le. 9999) then
              line(index(ia))(iresncol1:iresncol2)=
     -          line(index(ia))(iresncol1+1:iresncol2+1)
              line(index(ia))(iresncol2+1:iresncol2+1)=' '
            else
              n9999=n9999+1
            end if
            ndig27=ndig27+1
c            write (77,6544) ia,iresno(ia),iresncol1,iresncol2,irno_old
c6544        format(' ia,iresno=',2i6,' ic1,2=',2i3,' irno_old=',i5)
          end if
        end do
        if (ndig27 .gt. 0) write (6,2116) ictest,ndig27,ictest
        if (n9999 .gt. 0) write (6,2117) ictest
        if (naltdeltot .gt. 0)
     -    print *,naltdeltot,' alternate atoms will be deleted'
        nrecdel=nrecdel+naltdeltot
c        write (77,9671) (ia,line(index(ia))(iseqncol1:iseqncol2),
c     -    isegno(ia),iresno(ia),ia=1,n)
c9671    format(i6,1x,a,' isegno=',i3,' iresno=',i5)
      else if (inpcrdtyp .eq. iommod) then
c-------Macromodel structure file input
c       Decode number of atoms
        lineread=1
        read (inpt,1001,end=9999) lineinp
        if (ifull .eq. 1) line(1)=lineinp
        call lastchar(lineinp,lc,ncol)
        if (lc .le. 1 .and. lineinp(1:1) .eq. ' ') go to 9917
        read (lineinp(2:6),1007,err=9915,end=9999) n
        title=lineinp(8:87)
        trtitle(1)=lineinp(8:87)
        ntitltr=1
c       Make sure title is not blank
        icol=7
        call nextchar(lineinp,icol,132)
        if (icol .gt. 80) line(1)(7:16)='Macromodel'
        if (nconfig .le. maxrepconf) then
          call lastchar(lineinp,ifc,ncol)
          write (6,1010) lineinp(7:ifc)
        end if
        ntitlin=1
        nlines=n+1
        do i=1,n
          read (inpt,1001,end=3000) lineinp
          if (ifull .eq. 1) line(i+1)=lineinp
          do j=1,nnoblank3
            k=noblank3(j)
            if (lineinp(k:k) .ne. ' ') write (6,2051) i,k,lineinp(k:k)
          end do
          if (ifull .eq. 1) index(i)=i+1
          lineread=i+1
          read (lineinp(iccol1:iccol2),1103,err=9911) (c(k,i),k=1,3)
          read(lineinp(iqcol1:iqcol2),*) charge(i)
          call readint(lineinp,ipotcol1,ipotcol2,ityp,4)
          if (ityp .lt. 1 .or. ityp .gt. 64) then
            print *,'ERROR: invalid Macromodel atom type:',ityp
            iatnum(i)=99
          else
            iatnum(i)=mmatno(ityp)
          end if
        end do
        if (ifull .eq. 1) then
c         Collect segment id-s (they can be scattered)
          nsegm=0
          do ia=1,n
            isegno(ia)=0
            s1=line(ia+1)(isegcol1:isegcol2)
            do j=1,nsegm
              if (s1 .eq. segid4(j)(1:1)) isegno(ia)=j
            end do
            if (isegno(ia) .eq. 0) then
              nsegm=nsegm+1
              segid4(nsegm)(1:1)=s1
              isegno(ia)=nsegm
            end if
            call readint(line(ia+1),iresncol1,iresncol2,iresno(ia),2)
          end do
        end if
      else if (inpcrdtyp .eq. iommc .or. inpcrdtyp .eq. iommc4) then
c-------MMC .slt file input
        ntitlin=0
        nsegm=1
        n=0
        do irec=1,maxrec
          lstch=0
          do while (lstch .le. 1)
            read (inpt,1001,end=41) lineinp
            call lastchar(lineinp,lstch,80)
          end do
          if (ifull .eq. 1) line(irec)=lineinp
          lineread=irec
          icol=1
          call nextchar(lineinp,icol,132)
          if (lineinp(icol:icol) .eq. '!') then
c           Comment line - see if it is title
            if (irec .eq. ntitlin+1) then
              ntitlin=ntitlin+1
              if (nconfig .eq. 0 .and. ntitlin .eq. 1)
     -          title=lineinp(1:80)
              if (nconfig .le. maxrepconf) then
                call lastchar(lineinp,ifc,ncol)
                write (6,1010) lineinp(1:ifc)
              end if
            end if
          else
            n=n+1
            if (ifull .eq. 1) index(n)=irec
            call readint(lineinp,iresncol1,iresncol2,iresno(n),2)
            if (n .gt. 1) then
              if (iresno(n) .lt. iresno(n-1)) nsegm=nsegm+1
            end if
            isegno(n)=nsegm
            read (lineinp(iccol1:iccol2),1101,err=9911) (c(k,n),k=1,3)
            iatnum(n)=ianum(lineinp(inamcol1:inamcol2),1,nnamcol)
            read(lineinp(iqcol1:iqcol2),*) charge(n)
          end if
        end do
        itrunc=maxrec
41      if (ifull .eq. 1) then
          if (iclone .eq. -1) call askyn(
     -      'Do you have cloning information',31,1,-1,iclone,17)
          if (iclone .gt. 0) then
            write (6,*) 'NOTE: cloned atoms will have the coordinates ',
     -        'of the atom it was cloned from'
            neednnlist=1
            call getint('Number of clones',16,0,1,1000,nclone,98)
            do ic=1,nclone
42            write (question(6:8),1003) ic
              call getintline(question,51,1,n,in12,2,00)
              iaclnf(ic)=in12(1)
              iaclnl(ic)=in12(2)
              if (iaclnf(ic) .gt. iaclnl(ic))then
                print *,'Invalid range'
                go to 42
              end if
              if (ic .gt. 1) then
                if (iaclnf(ic) .lt. iaclnl(ic-1)) then
                  print *,'Cloned molecules should be specified in ',
     -              'increasing order'
                  go to 41
                end if
              end if
              call getint('Number of copies',16,0,1,0,ncopcln(ic),0)
            end do
            do ic=nclone,1,-1
              incr0=iaclnl(ic)-iaclnf(ic)+1
              incr=(ncopcln(ic)-1)*incr0
              incri0=index(iaclnl(ic))-index(iaclnf(ic))+1
              incri=(ncopcln(ic)-1)*incri0
c             Make room
              do irec=index(n),index(iaclnl(ic))+1,-1
                line(irec+incri)=line(irec)
              end do
c             Adjust index, segment and  and residue number
              incrres=iresno(iaclnl(ic))-iresno(iaclnf(ic))+1
              incrseg=isegno(iaclnl(ic))-isegno(iaclnf(ic))+1
              if (iaclnf(ic) .gt. 1) then
                if (isegno(iaclnf(ic)) .eq. isegno(iaclnf(ic)-1)) then
c                 If cloned segment was not recognized as such, increment isegno
                  do ia=iaclnf(ic),iaclnl(ic)
                    isegno(ia)=isegno(ia)+1
                  end do
                end if
              end if
              do ia=n,iaclnl(ic)+1,-1
                index(ia+incr)=index(ia)+incri
                isegno(ia+incr)=isegno(ia-incr0)+ncopcln(ic)*incrseg
                iresno(ia+incr)=iresno(ia)+(ncopcln(ic)-1)*incrres
                write (line(index(ia+incr))(iresncol1:iresncol2),1007)
     -            iresno(ia+incr)
              end do
c             write (77,4411) 'B',(index(i),i=1,n+incr)
c             Clone
              do id=1,ncopcln(ic)-1
                do ir=index(iaclnf(ic)),index(iaclnl(ic))
                  line(ir+id*incri0)=line(ir)
                end do
                do ia=iaclnf(ic),iaclnl(ic)
                  isegno(ia+id*incr0)=isegno(ia)+id
                  index(ia+id*incr0)=index(ia)+id*incri0
                  iresno(ia+id*incr0)=iresno(ia)+id*incrres
                  write (line(index(ia+id*incr0))(iresncol1:iresncol2),
     -              1007) iresno(ia+id*incr0)
                end do
              end do
              n=n+incr
              lineread=lineread+incri
            end do
c           write (77,4411) 'C',(index(i),i=1,n)
            do ia=1,n
              irec=index(ia)
              read (line(irec)(iccol1:iccol2),1101,err=9911)
     -          (c(k,ia),k=1,3)
c             write (77,*) 'ia,irec,an,iat=',ia,irec,
c    -         line(irec)(inamcol1:inamcol2),iatnum(ia)
c             iatnum(ia)=ianum(line(irec)(inamcol1:inamcol2),1,nnamcol)
            end do
          end if
        end if
        nlines=lineread
        if (nlines .eq. 0) iendfound=1
c        do ia=1,n
c          write (77,7622) ia,index(ia),line(index(ia))(1:80),
c     -      iresno(ia),isegno(ia)
c7622  format(2i5,a,' ires,isegno=',2i5)
c        end do
c        do ia=1,n
c          write (77,7633) ia,index(ia),iatnum(ia),(c(k,ia),k=1,3)
c7633  format(2i5,' iatnum=',i5,' c=',3f10.5)
c        end do
      else if (inpcrdtyp .eq. iogro) then
c-------Gromos/Gromacs .gro file input
        ntitlin=1
        read (inpt,1001,end=9999) lineinp
        if (ifull .eq. 1) line(1)=lineinp
        title=lineinp(1:80)
        trtitle(1)=lineinp(1:80)
        ntitltr=1
        if (nconfig .le. maxrepconf) then
          call lastchar(lineinp,ifc,ncol)
          write (6,1010) lineinp(1:ifc)
        end if
        read (inpt,1001) lineinp
        if (ifull .eq. 1) line(2)=lineinp
        call lastchar(lineinp,lc,ncol)
        if (lc .le. 1 .and. lineinp(1:1) .eq. ' ') go to 9917
        read (lineinp(1:5),1007,err=9915) n
        nlines=2
        if (n+nlines .gt. maxrec) then
          write (6,1213) 'input',n+nlines,maxrec
          stop
        end if
        do i=1,n
          nlines=nlines+1
          if (ifull .eq. 1) index(i)=nlines
          lineread=nlines
          read (inpt,1001,end=3000) lineinp
          if (ifull .eq. 1) line(nlines)=lineinp
          read (lineinp(iccol1:iccol2),1102,err=9911) (c(k,i),k=1,3)
          call readint(lineinp,iresncol1,iresncol2,iresno(i),2)
          if (iqcol2 .ge. iqcol1)
     -      read(lineinp(iqcol1:iqcol2),*) charge(i)
        end do
      else if (inpcrdtyp .eq. iomol2) then
c-------Tripos .mol2 file input
        print *,'NOTE: This format is mostly for input only'
        call  readmol2(inpt,line,nlines,n,iresno,iatnum,nneig,ineig,
     -    iseqncol1,iseqncol2,inamcol1,irescol1,iresncol1,iresncol2,
     -    iccol1,iccol2,ipotcol1,iqcol1,iqcol2,ncol,c,charge,index,
     -    maxng,MAXREC)
      else if (inpcrdtyp .eq. iomae) then
c-------Schrodinger Maestro input
        print *,'NOTE: This format is for input only'
        call read_mae_mol(n,nbonds,iatnum,iresno,isegno,nsegm,c,charge,
     -    nneig,ineig,index,line,inpcrdtyp,iofull,inpt,6,ierr,MAXREC,
     -    MAXNG)
        if (ierr .gt. 0) stop
        nlines=n
      else if (inpcrdtyp .eq. ioins) then
c-------Insight .car file input
        ntitlin=4
        read (inpt,1001) lineinp
        if (ifull .eq. 1) line(1)=lineinp
c       Check for older version
        icarvers=3
        if (lineinp(17:17) .eq. '2') then
          icarvers=2
          idcol=65
          itcol=62
          iqcol1=69
          iqcol2=75
          iresncol1=57
          iresncol2=61
        end if
        print *,'Version',icarvers
        read (inpt,1001) lineinp
        if (ifull .eq. 1) line(2)=lineinp
        call writeline(6,lineinp,1,ncol,0)
        ipbc=0
        if (lineinp(1:6) .eq. 'PBC=ON' .or. lineinp(1:6) .eq. 'PBC=2D')
     -    ipbc=1
        read (inpt,1001) lineinp
        if (ifull .eq. 1) line(3)=lineinp
        title=lineinp(1:80)
        trtitle(1)=lineinp(1:80)
        ntitltr=1
        if (nconfig .le. maxrepconf) then
          call lastchar(lineinp,ifc,ncol)
          write (6,1010) lineinp(1:ifc)
        end if
        read (inpt,1001) lineinp
        if (ifull .eq. 1) line(5)=lineinp
        if (ipbc .eq. 1) then
          ntitlin=ntitlin+1
          read (inpt,1001) lineinp
          if (ifull .eq. 1) line(ntitlin)=lineinp
        end if
        n=0
        lineread=ntitlin
        ntitadd=0
        do i=1,maxrec
          lstch=0
          do while (lstch .le. 1)
            read (inpt,1001,end=51) lineinp
            call lastchar(lineinp,lstch,80)
          end do
          if (ifull .eq. 1) line(lineread+1)=lineinp
          lineread=lineread+1
          if (lineread .gt. maxrec) then
            write (6,1213) 'input',lineread,maxrec
            stop
          end if
          if (lineinp(1:1) .eq. '!') then
            if (lineread .eq. ntitlin+i) then
c             Additional header lines
              ntitadd=ntitadd+1
              call writeline(6,line(lineread),1,ncol,0)
            end if
          else if (lineinp(1:3) .eq. 'end') then
            nsegm=nsegm+1
          else
            n=n+1
            index(n)=lineread
            if (n .gt. 1) then
              if (lineinp(isegcol1:isegcol2) .ne.
     -            lineprev(isegcol1:isegcol2)) nsegm=nsegm+1
            end if
            isegno(n)=nsegm
            lineread=ntitlin+i
            read (lineinp(iccol1:iccol2),1104,err=9911) (c(k,n),k=1,3)
            atomnam='     '
            atomnam(1:2)=lineinp(ichemcol1:ichemcol2)
            iatnum(n)=ianum(atomnam,1,2)
            icol=iresncol1
            call nextchar(lineinp,icol,132)
            call nextblank(lineinp,icol,132)
            icoll=icol-1
            do while (icoll .gt. iresncol1 .and.
     -                idigit(lineinp(icoll:icoll),1) .eq. 0)
              icoll=icoll-1
            end do
            call readint(lineinp,iresncol1,icoll,iresno(n),2)
            read(lineinp(iqcol1:iqcol2),*) charge(n)
          end if
          lineprev=lineinp
        end do
51      ntitlin=ntitlin+ntitadd
        if (icarvers .eq. 3 .and. ifull .eq. 1) then
          rnu='      '
          nrescar=0
          do i=1,n
            if (line(index(i))(iresncol1:iresncol2) .ne. rnu) then
              nrescar=nrescar+1
              rnu=line(index(i))(iresncol1:iresncol2)
              write (line(index(i))(iresncol1:iresncol2),1006) nrescar
            else
              write (line(index(i))(iresncol1:iresncol2),1006) nrescar
            end if
          end do
          write (6,2028) nrescar
        end if
      else if (inpcrdtyp .eq. ionxyz .or. inpcrdtyp .eq. iosxyz .or.
     -         inpcrdtyp .eq. iosxyzrq) then
c-------Insight free format input
c       Decode number of atoms
        call lastchar(lineinp,lc,ncol)
        if (lc .le. 1 .and. lineinp(1:1) .eq. ' ') go to 9917
        read (inpt,*,err=9915) n
        ntitlin=0
        if (n .gt. maxrec) then
          write (6,1213) 'input',n,maxrec
          stop
        end if
        do i=1,n
          read (inpt,1001,end=3000) lineinp
          if (ifull .eq. 1) line(ntitlin+1)=lineinp
          index(i)=ntitlin+i
          lineread=ntitlin+i
          if (inpcrdtyp .eq. ionxyz) then
            read (lineinp,*,err=9913) iatnum(i),(c(k,i),k=1,3)
          else if (inpcrdtyp .eq. iosxyz .or.
     -             inpcrdtyp .eq. iosxyzrq) then
            icol=1
            call nextchar(lineinp,icol,132)
            i1=icol
            call nextblank(lineinp,icol,132)
            atsymbol='  '
            atsymbol(1:icol-i1)=lineinp(i1:icol-1)
            atomnam='     '
            atomnam(1:2)=atsymbol
            iatnum(i)=ianum(atomnam,1,2)
            if (inpcrdtyp .eq. iosxyz) then
              read (lineinp(icol:ncol-icol+1),*,err=9911) (c(k,i),k=1,3)
            else
              read (lineinp(icol:ncol-icol+1),*,err=9916)
     -          (c(k,i),k=1,3),iresno(i),charge(i)
            end if
          end if
        end do
      else
c-------Grasp .crg file
        ntitlin=1
        read (inpt,1001) lineinp
        if (ifull .eq. 1) line(ntitlin)=lineinp
        do while (line(ntitlin)(1:1) .eq. '!')
          ntitlin=ntitlin+1
          read (inpt,1001) lineinp
          if (ifull .eq. 1) line(ntitlin)=lineinp
        end do
        ntitlin=ntitlin-1
        n=1
        lineread=ntitlin
        do while (.true.)
          read (inpt,1001,end=3001) lineinp
          if (ifull .eq. 1) line(ntitlin+n)=lineinp
          if (ifull .eq. 1) index(n)=ntitlin+n
          lineread=ntitlin+n
          n=n+1
        end do
3001    n=n-1
      end if
      go to 9900
3000  itrunc=i-1
      go to 9919
9999  iendfound=1
      if (ioktoend .eq. 1) return
      go to 9919
9911  write (6,9001) lineinp(iccol1:iccol2),iccol1,iccol2,icinc
      print *,'n=',n
      go to 9919
9912  print *,'Invalid syntax for charge'
      go to 9919
9913  print *,'Invalid syntax for coordinates or atomno'
      go to 9919
9915  print *,'Invalid syntax for number of atoms'
      go to 9919
9916  print *,'Invalid syntax for coordinates or resno or charge'
      go to 9919
9917  print *,'Number of atoms is missing'
      stop
9919  if (lineread .eq. 0) then
        write (6,1210)
      else
        write (6,1209) lineread,lineinp
      end if
      if (iendfound .eq. 1 .or. n .eq. 0) then
        if (nconfig .eq. 0) then
          print *,'ERROR: Coordinate file ',inpfile(1:namleni),
     -    ' is empty'
          iaskagain=1
        else
          print *,'WARNING: run out of data after ',nconfig,
     -      ' configurations'
          iendfound=1
          if (nconfig .eq. 0) call askstop(0)
        end if
      end if
      if (itrunc .gt. 0) then
        print *,'WARNING: Coordinate file contains only ',itrunc,
     -    ' atoms instead of ',n
        n=itrunc
        if (nconfig .eq. 0) call askstop(0)
        itrunc=0
      end if
      if (iunrecog .eq. 1) then
        print *,'Contents of file ',inpfile(1:namleni),' are not in ',
     -    formatname(inpcrdtyp),' format'
        if (nconfig .eq. 0) then
          iaskagain=1
        else
          stop
        end if
      end if
9900  if (naltnam .gt. 0) close (40)
      if (nbfacsumtot .eq. 0) call zeroit(bfacavg,nsegm)
      return
1001  format(a132)
1003  format(i3)
1006  format(i4)
1007  format(i5)
1010  format(a)
1101  format(3f10.5)
1102  format(3f8.3)
1103  format(3f12.5)
1104  format(3f15.9)
1105  format(3f20.10)
1015  format(1x,a)
1213  format(' ERROR: number of ',a,' lines (',i9,') exceeds limit (',
     -  i7,')  - redimension',a,/,
     -  8x,'Make sure you have an END line after each configuration')
1215  format(' ERROR: File ',a,' does not',/, 8x,'appear to be in ',a,
     -  ' format')
1216  format(' Sequence number',i6,' is less than the previous',
     -  ' sequence number (',i6,')')
1217  format(' Residue id ',i6,' is less than the previous residue id ',
     -  '(',i6,')',/,' Sequence # read:',i7,' n=',i7,')')
1209  format(' Last line read (',i7,'-th):',/,a)
1210  format(' No data found in the file')
2028  format(' Residue sequence names are changed to sequence numbers',
     -  /,' Number of residues found=',i4)
2029  format(' Alternative locations ',a,' will be kept and the others',
     -  ' dropped')
2030  format(i4,' alternative location records have been found',/,
     -  ' The following characters were found in column 17:',50(1x,a1))
 
2032  format('Lines with undefined coordinates were found',/,
     -  ' The atom may be dropped or the coordinates may be set to ',
     -  '999.9')
2040  format(' The input PDB file contains records with non-blank ',
     -  'character in column 17.',/,
     -  6x,'These records, marking alternate positions, will be ',
     -  'written on file',/,6x,a)
2043  format(i5,' records containing alternate location marked with ',
     -  a1,' will be deleted')
2044  format('REMARK RECORDS WITH ALTERNATE LOCATION MARKER')
2045  format('REMARK RECORDS WITH ALTERNATE LOCATION MARKER TO BE ',
     -  'DELETED')
2051  format(' WARNING: non-blank character in line of atom ',i5,
     -  ' column ',i3,':',a1)
2077  format(' Note: all heteroatoms will be kept and',/,
     -  7x,'only the first of alternate records will be used')
2115  format(' WARNING: Input structure has ',a,'-type segment ID, ',
     -  'i.e.,'/,'ATOM  99999 AAAA RRR ',a1,
     -  ' 999       0.0     0.0     0.0    1.00  0.0       ',a4,/,
     -  ' instead of',/,'ATOM  99999 AAAA RRR ',a1,
     -  ' 999       0.0     0.0     0.0    1.00  0.0       ',a4)
2116  format(' Column ',i2,' is not blank for',i7,' atoms',/,
     -  5x,'- residue numbers will be read including column',i3,/,
     -  5x,'- residue numbers < 10000 will be shifted 1 colum to the ',
     -  'right')
2117  format(' NOTE: residue numbers > 9999 will be left using ',
     -  'column',i3)
9001  format(' Invalid syntax for coordinates:',a,
     -  ' (cols ',i3,' - ',i3,'; icinc=',i1,')')
      end
      subroutine readcharges(inptyp,inpt,nread,charge,iatnum,nerr)
      dimension charge(nread),iatnum(nread)
      character*1 inptyp
      character*8 atomnam
      character*80 line,filename
      namlen=0
      if (inptyp .eq. 'a') then
        call openfile(inpt,0,'Amber prtmtop',13,'old',filename,namlen,
     -    notfound,3,1,1,0,0)
        do while (line(1:12) .ne. '%FLAG CHARGE')
          read (11,1000,end=199) line
        end do
        read (inpt,1000,end=199) line
        read (inpt,1001,end=198,err=198) (charge(i),i=1,nread)
        do i=1,nread
          charge(i)=charge(i)/18.2223
c         write (77,*) i,' q=',charge(i)
        end do
      else if (inptyp .eq. 'c') then
        call openfile(inpt,0,'Charmm PSF',10,'old',filename,namlen,
     -    notfound,3,1,1,0,0)
        call find_natspsf(inpt,line,nerr,nread,natspsf)
        if (nerr .gt. 0) go to 999
        do ia=1,nread
          call blankout(line,1,80)
          read (inpt,1000,end=999) line
          ic=1
          do irec=1,7
            call nextstring(line,ic,ic1,ic2,80)
            if (irec .eq. 5) then
              atomnam='        '
              atomnam(1:ic2-ic1+1)=line(ic1:ic2)
            end if
          end do
          charge(ia)=0.0
          iok=0
          read (line(ic1:ic2),*,err=603) charge(ia)
          iok=1
603       if (iok .eq. 0) then
            write (6,2000) 'PSF',line(1:79)
            nerr=nerr+1
           end if
        end do
      else if (inptyp .eq. 'd') then
        call openfile(inpt,0,'Autodock .pdbqt',15,'old',filename,namlen,
     -    notfound,3,1,1,0,0)
        ia=0
        do while (ia .lt. nread)
          read (inpt,1000,end=399) line
          if (line(1:4) .eq. 'ATOM' .or. line(1:6) .eq. 'HETATM') then
            ia=ia+1
            charge(ia)=0.0
            iok=0
            read (line(71:76),*,err=604) charge(ia)
            iok=1
604         if (iok .eq. 0) then
              write (6,2000) '.pdbqt',line(1:79)
              nerr=nerr+1
            end if
          end if
        end do
399     if (ia .lt. nread) then
          nerr=1
          write (6,2001) ia,nread
        end if
      end if
      nwarn=0
      qsum=0.d0
      nqz=0
      do i=1,nread
        qsum=qsum+charge(i)
        if (charge(i) .eq. 0.0) nqz=nqz+1
        if (charge(i) .lt. -1.0001 .or. charge(i) .gt. 1.0001) then
          nwarn=nwarn+1
          write (6,2004) i,charge(i)
        else if (iatnum (i) .gt. 0) then
          if (iatnum(i) .eq. 1 .and. charge(i) .lt. -0.05 .or.
     -        iatnum(i) .eq. 8 .and. charge(i) .gt. 0.0) then
            write (6,2002) i,iatnum(i),charge(i)
            nwarn=nwarn+1
          end if
        end if
      end do
      if (nqz .eq. nread) then
        print *,'All charges read are zero'
        nerr=nerr+1
      else
        write (6,2003) qsum,nqz
      end if
      if (nerr .gt. 0) then
        print *,'There were errors in reading the charges'
        call askstop(1)
        print *,'No charges will be used'
      end if
      go to 999
199   print *,'Did not find charge flag in file ',filename(1:namlen)
      nerr=1
      go to 999
198   print *,'Run out of data'
      nerr=1
999   close (inpt)
      return
1000  format(a)
1001  format(5e16.8)
2000  format(' ERROR: invalid charge in ',a,' record:',/,1x,a)
2001  format(' ERROR: only ',i7,' atoms were found (instead of ',i7,')')
2002  format(' WARNING: Atom',i6,' atomic #',i2,' has unlikely sign:',
     -  f5.2)
2003  format(' Total charge =',f8.3,/,' Number of zero charges=',i6)
2004  format(' WARNING: charge for atom',i6,': ',f8.4)
      end
      subroutine find_natspsf(inpt,line,ierr,n,natspsf)
      character*80 line
      ierr=0
      natspsf=0
      do while (natspsf .eq. 0)
        call blankout(line,1,80)
        read (inpt,1010,end=602) line
        ic=1
        call nextstring(line,ic,ic1,ic2,80)
        call nextstring(line,ic,ic21,ic22,80)
        if (ic22 .gt. ic21) then
          if (line(ic21:ic22) .eq. '!NATOM')
     -      read(line(ic1:ic2),*,err=602) natspsf
        end if
      end do
602   if (natspsf .eq. 0) then
        print *,'ERROR: no !NATOM line was found'
        ierr=1
      else if (natspsf .lt. n) then
        write (6,2000) n,natspsf
        ierr=1
      else
        print *,'Number of atoms found in the PSF file=',natspsf
      end if
      return
1010  format(a)
2000  format(' ERROR: the number of atoms to read (',i8,') exceeds ',
     -  'the number of atoms in the PSF file (',i8,')')
      end
      subroutine reverse_opt(c,n,line,maxat)
      character*132 line(maxat)
      dimension c(3,maxat)
      dimension shift(3),rot(3,3)
      nlfound=0
      do il=1,100
        do icc=1,10
          if (line(il)(icc:icc+3) .eq. 'RTTR' .or.
     -        line(il)(icc:icc+3) .eq. 'TRRT') then
            nlfound=nlfound+1
            ic=icc+4
            if (line(il)(ic:ic) .eq. 't') then
              ic=ic+5
              read (line(il)(ic+1:ic+45),2000) shift
            else if (line(il)(ic:ic) .eq. 'r') then
              ic=ic+1
              read(line(il)(ic:ic),*) i
              ic=ic+5
              read (line(il)(ic+1:ic+33),2001) (rot(i,k),k=1,3)
            end if
          end if
        end do
c       print *,line(il)(1:77)
c       print *,'nlfound=',nlfound
      end do
      if (nlfound .lt. 4) go to 999
      write (6,1000) ((rot(i,k),k=1,3),i=1,3),shift
      call shiftmol(c,n,shift,c,1.0)
      call rotate_c(c,n,rot,c,'REVERSE',7)
      return
999   print *,'ERROR: no transformation information was found'
      return
1000  format(' Structure will be shifted by',5x,3f15.6,/,
     -  ' Structure will be rotated by',/,3(5x,3f11.7,/))
2000  format(3f15.6)
2001  format(3f11.7)
      end
      subroutine makeunitcell(inpt,inpfile,linpfile,inpcrdtyp,c,ctemp,
     -  atw,n,numresslt,nsegslt,segid4,molsltlim,line,index,iasymbio,
     -  iuout,outfile,namleno,itemp,radtodeg,maxseg,maxat)
      character*(*) inpfile,outfile
      character*132 line(maxat)
      character*4 segid4(maxseg)
      dimension c(3,maxat),ctemp(3,maxat),index(maxat),atw(maxat),
     -  molsltlim(3,maxseg),itemp(maxat)
      character*1 abc,digits,hexdigits
      common /charactersets/ ihex(25),abc(62),digits(14),hexdigits(25)
      character*1 xyz
      common /axislab/ xyz(3)
      dimension shiftasym(3,20),rotasym(3,3,20),abcabg(6),cmin(3),
     -  cmax(3),c0(3),edge(3),uxyz(3,3),cellxyz(3,3),vertex(3,8),
     -  crm_as(3,20),crmtest(3),ctest(3),shift(3),maskseg(20),
     -  iusedseg(20)
      character*1 segids(62),chainprev,chlist(20),chidused(60),chnew
      character*80 lineinp,linew
      character*200 cellfile
      if (iasymbio .eq. 1) print *,'Generating a full unit cell'
      if (iasymbio .eq. 2) print *,'Generating biological oligomers'
      if (iasymbio .eq. 3)
     -  print *,'Generating all crsytal contacts of the asymetric unit'
      write (6,2000) n,outfile(1:namleno)
      call zeroit(abcabg,6)
      do i=1,62
        segids(i)=abc(i)
      end do
      do is=1,nsegslt
        do i=1,62
          if (segid4(is)(1:1) .eq. segids(i)) segids(i)=' '
        end do
      end do
      call askyn(
     -  'Is the unit cell information in the input STRUCTURE file',56,
     -  1,+1,isamef,000)
      if (isamef .eq. 1) then
        inptcell=inpt
        rewind inpt
        cellfile=inpfile
        len=linpfile
        if (ispdb(inpcrdtyp) .ne. 1)
     -    write (6,2006) cellfile(1:len),'is not'
      else
        inptcell=98
        len=0
        call openfile(inptcell,0,'cell information',16,'old',cellfile,
     -    len,notfnd,0,1,1,0,0)
        if (cellfile(len-2:len) .ne. 'pdb' .and.
     -      cellfile(len-2:len) .ne. 'PDB')
     -    write (6,2006) cellfile(1:len),'does not appear to be'
      end if
      icellfound=0
c     Find crytal info first
      do while (icellfound .eq. 0)
        read (inptcell,1000,end=666) lineinp
        if (lineinp(1:6) .eq. 'CRYST1') then
          read (lineinp(7:54),*,err=888) abcabg
          icellfound=1
        end if
      end do
666   irect=0
      call unitmat(uxyz)
      if (icellfound .eq. 1) then
        write (6,2002) abcabg
        call trnsfr(edge,abcabg,3)
      else
        print *,'No unit cell information (CRST1 records) found'
        do k=1,3
          call getreal(
     -      'Edge length in the '//xyz(k)//' direction (A)',34,
     -      999999.0,edge(k),1,0)
        end do
        call getreal('ey-ez angle(in deg)',19,90.0,abcabg(4),1,0)
        call getreal('ex-ez angle(in deg)',19,90.0,abcabg(5),1,0)
        call getreal('ex-ey angle(in deg)',19,90.0,abcabg(6),1,0)
      end if
      if (abcabg(4) .eq. 90.0 .and. abcabg(5) .eq. 90.0 .and.
     -    abcabg(6) .eq. 90.0) irect=1
      if (irect .eq. 0) then
c       Generate cell's unit vectors
        cosxy=cos(abcabg(6)/radtodeg)
        uxyz(1,2)=cos(abcabg(6)/radtodeg)
        uxyz(2,2)=sin(abcabg(6)/radtodeg)
        uxyz(1,3)=cos(abcabg(5)/radtodeg)
        uxyz(2,3)=
     -    (uxyz(1,2)*uxyz(1,3)-cos(abcabg(4)/radtodeg))/uxyz(2,2)
        uxyz(3,3)=sqrt(1.0-uxyz(1,3)**2+uxyz(2,3)**2)
        write (6,2005) uxyz
      end if
      do i=1,3
        do k=1,3
          cellxyz(k,i)=edge(i)*uxyz(k,i)
        end do
      end do
      rewind inptcell
      nasym=0
      if (iasymbio .eq. 1 .or. iasymbio .eq. 3) then
        do while (.true.)
          read (inptcell,1000,end=999) lineinp
          if (lineinp(1:18) .eq. 'REMARK 290   SMTRY') then
            read (lineinp(19:19),*,err=888) k
            read (lineinp(20:23),*,err=888) nasym
            read (lineinp(24:53),*,err=888) (rotasym(k,i,nasym),i=1,3)
            read (lineinp(54:68),*,err=888) shiftasym(k,nasym)
          else if (lineinp(1:6) .eq. 'CRYST1') then
            read (lineinp(7:54),*,err=888) abcabg
            icellfound=1
          end if
        end do
999     if (nasym .eq. 0) then
          print *,'No transformation info was found in file ',
     -      cellfile(1:len)
          stop
        end if
        if (inptcell .ne. inpt) close (inptcell)
        if (nasym*n .gt. maxat) then
          write (6,2007) nasym*n,maxat
          stop
        end if
c       Now create the transformed coordinates
        print *,'Number of transformations found:',nasym
        do isym=2,nasym
          call rotate_c(c,n,rotasym(1,1,isym),c(1,(isym-1)*n+1),
     -      'SYMTRAN',7)
          call shiftmol(c(1,(isym-1)*n+1),n,shiftasym(1,isym),
     -      c(1,(isym-1)*n+1),1.0)
          do is=1,nsegslt
            molsltlim(1,(isym-1)*nsegslt+is)=(isym-1)*n+molsltlim(1,is)
            molsltlim(2,(isym-1)*nsegslt+is)=(isym-1)*n+molsltlim(2,is)
            if (molsltlim(3,is) .gt. 0) then
             molsltlim(3,(isym-1)*nsegslt+is)=(isym-1)*n+molsltlim(3,is)
            else
              molsltlim(3,(isym-1)*nsegslt+is)=molsltlim(3,is)
            end if
          end do
        end do
        ntot=n*nasym
c       Generate the unit cell vertices
        call zeroit(vertex,3*8)
        nv=0
        do ix=1,2
          do iy=1,2
            do iz=1,2
              nv=nv+1
              do k=1,3
                if (ix .eq. 2) vertex(k,nv)=vertex(k,nv)+cellxyz(k,1)
                if (iy .eq. 2) vertex(k,nv)=vertex(k,nv)+cellxyz(k,2)
                if (iz .eq. 2) vertex(k,nv)=vertex(k,nv)+cellxyz(k,3)
              end do
            end do
          end do
        end do
        nattot=nasym*n
        call compact_ucell(c,ctemp,itemp,molsltlim,ntot,nasym*nsegslt,
     -    vertex,cmin,cmax,c0,edge,uxyz,nshift)
c       icompact=0
c       if (irect .eq. 1) then
c         call try_to_compact(c,ctemp,molsltlim,edge,n,nasym*nsegslt,
c    -      icompact)
c         if (icompact .eq. 1) then
c           print *,'Further translations made the cell more compact:'
c           call extension(c,itemp,0,1,n,cmin,cmax,c0,1,0,v)
c         end if
c       else
c         print *,'NOTE: the Edit/trans... option may translate the ',
c    -      'images to a more compact form'
c       end if
        print *,'NSHIFT=',nshift,' NTOT=',ntot
        if (nshift .gt. 0) then
          do i=1,ntot
            write (line(index(i))(31:54),1001) (c(k,i),k=1,3)
          end do
          call extension(c,itemp,0,1,ntot,cmin,cmax,c0,1,0,vol)
        end if
        if (iasymbio .eq. 3) then
c         Gather all contacts
          print *,'Wait ... '
          do is=1,nasym
            call cofms(c(1,(is-1)*n+1),crm_as(1,is),n,atw)
          end do
          ncopy=1
          call trnsfr(ctemp,c,n*3)
          do is=2,nasym
            print *,'Testing asymetric unit #',is
            d_org=dist2(crm_as(1,1),crm_as(1,is))
            do ix=-2,2
              do iy=-2,2
                do iz=-2,2
                  call zeroit(shift,3)
                  do k=1,3
                    shift(k)=shift(k)+ix*cellxyz(k,1)
                    shift(k)=shift(k)+iy*cellxyz(k,2)
                    shift(k)=shift(k)+iz*cellxyz(k,3)
                  end do
c                 Test copy # is shifted by shift
                  call arrsum(crm_as(1,is),shift,crmtest,3)
c                 if (dist2(crm_as(1,1),crm_test) .lt. d_org*1.2) then
c                   See if this copy is in contact with asym #1
                    do ia=1,n
                      call arrsum(c(1,(is-1)*n+ia),shift,ctest,3)
                      do ja=1,n
                        if (dist2(ctest,c(1,ja)) .lt. 36.0) then
c                         Use this copy
                          ncopy=ncopy+1
                          if (n*ncopy .gt. maxat) then
                            write (6,2007) nasym*n,maxat
                            stop
                          end if
                          call trnsfr(ctemp(1,(ncopy-1)*n+1),
     -                      c(1,(is-1)*n+1),n*3)
                          call shiftmol(ctemp(1,(ncopy-1)*n+1),n,shift,
     -                      ctemp(1,(ncopy-1)*n+1),1.0)
                          go to 100
                        end if
                      end do
                    end do
c                 end if
100               continue
                end do
              end do
            end do
          end do
          print *,'Number of contact copies=',ncopy-1
          call trnsfr(c,ctemp,3*n*ncopy)
        else
          ncopy=nasym
        end if
        ifs=1
        do is=nsegslt+1,ncopy*nsegslt
          do while (segids(ifs) .eq. ' ')
            ifs=ifs+1
          end do
          segid4(is)='    '
          segid4(is)(1:1)=segids(ifs)
          segids(ifs)=' '
        end do
        write (6,2001) ((segid4((isym-1)*nsegslt+is)(1:1),is=1,nsegslt),
     -    ' ',isym=1,ncopy)
        iseg=nsegslt
        ix_nslt=index(n)
        do i=1,ix_nslt
          call lastchar(line(i),lc,80)
          write (iuout,1000) line(i)(1:lc)
        end do
        do isym=2,ncopy
          chainprev=' '
          do i=1,n
            linew=line(index(i))(1:80)
            write (linew(31:54),1001) (c(k,(isym-1)*n+i),k=1,3)
            write (linew(07:11),1002) (isym-1)*n+i
            if (linew(22:22) .ne. chainprev) then
              write (iuout,1000) 'TER'
              iseg=iseg+1
              chainprev=linew(22:22)
            end if
            linew(22:22)=segid4(iseg)(1:1)
            call lastchar(linew,lc,80)
            write (iuout,1000) linew(1:lc)
          end do
        end do
        if (iasymbio .eq. 1) then
          icelldup=1
          do while (icelldup .gt. 0)
            call askyn(
     -        'Do you want to create an (other) duplicate cell',47,
     -        1,-1,icelldup,000)
            if (icelldup .eq. 1) then
              call zeroit(shift,3)
              do k=1,3
                call getint(
     -            'Shift factor (-1,0,1) in the '//xyz(k)//' direction',
     -            40,0,0,1,ixyzk,0)
                do l=1,3
                  shift(l)=shift(l)+ixyzk*cellxyz(l,k)
                end do
              end do
              nw=n*ncopy
              nsw=iseg
              call shiftmol(c,nw,shift,ctemp,1.0)
              do isym=1,ncopy
                write (iuout,1000) 'TER'
                chainprev=' '
                do i=1,n
                  linew=line(index(i))(1:80)
                  write (linew(31:54),1001)(ctemp(k,(isym-1)*n+i),k=1,3)
                  write (linew(07:11),1002) nw+(isym-1)*n+i
                  if (linew(22:22) .ne. chainprev) then
                    write (iuout,1000) 'TER'
                    iseg=iseg+1
                    chainprev=linew(22:22)
                  end if
                  linew(22:22)=segid4(iseg-nsw)(1:1)
                  call lastchar(linew,lc,80)
                  write (iuout,1000) linew(1:lc)
                end do
              end do
            end if
          end do
          call askyn('Do you want to write the cell vertices/edges too',
     -      48,1,+1,icellw,000)
          if (icellw .eq. 1) then
            print *,'Cell vertices will be chain X, all HE atoms'
            write (iuout,1000) 'TER'
            do nv=1,8
              write (iuout,2003) nasym*n+nv,nasym*numresslt+1,
     -          (vertex(k,nv),k=1,3)
            end do
            do inc=1,2
              incr=nattot+4*(inc-1)
              write (iuout,2004) incr+1,incr+2,incr+3
              write (iuout,2004) incr+2,incr+4
              write (iuout,2004) incr+3,incr+4
            end do
            do i=1,4
              write (iuout,2004) nattot+i,nattot+i+4
            end do
          end if
        end if
        write (iuout,1000) 'END'
      else
c       Generate biological oligomers
        write (iuout,1000)
     -  'REMARK Biological oligomers as specified by REMARK 350 records'
        nchread=0
        iread=0
        nsegtot=nsegslt
        nslttot=n
        do ic=1,nsegslt
          chidused(ic)=segid4(ic)(1:1)
        end do
        call zeroiti(iusedseg,0,nsegslt)
        do while (.true.)
          if (iread .eq. 0) then
            call blankout(lineinp,1,80)
            read (inptcell,1000,end=777) lineinp
          else
            iread=0
          end if
          if (lineinp(1:18) .eq. 'REMARK 350 APPLY T') then
            call lastchar(lineinp,lc,80)
            ic=42
            call nextchar(lineinp,ic,80)
            nchread=0
            do while (ic .le. lc)
              nchread=nchread+1
              chlist(nchread)=lineinp(ic:ic)
              ic=ic+3
            end do
c           print *,'CHLIST=',(chlist(i),i=1,nchread)
          else if (lineinp(1:18) .eq. 'REMARK 350   BIOMT') then
            k=0
            do while (lineinp(1:18) .eq. 'REMARK 350   BIOMT' .and.
     -                k .lt. 3)
              read (lineinp(19:19),*,end=888,err=888) k
              read (lineinp(20:23),*,end=888,err=888) nasym
              read (lineinp(24:53),*,end=888,err=888)
     -         (rotasym(k,i,nasym),i=1,3)
              read (lineinp(54:68),*,end=888,err=888) shiftasym(k,nasym)
              call blankout(lineinp,1,80)
              read (inptcell,1000,end=777) lineinp
              iread=1
            end do
c           Chek if transformation causes actual change
            notransf=1
            do k=1,3
              if (shiftasym(k,nasym) .ne. 0.0 .or.
     -            rotasym(k,k,nasym) .ne. 1.0) notransf=0
              do kk=1,k-1
                if (rotasym(k,kk,nasym) .ne. 0.0 .or.
     -              rotasym(kk,k,nasym) .ne. 0.0) notransf=0
              end do
            end do
            if (nchread .eq. 0) then
c             No chain was specified - use all chains
              do ic=1,nsegslt
                maskseg(ic)=1
              end do
            else
c             Set mask for chains selected
              call zeroiti(maskseg,0,nsegslt)
              do ic=1,nchread
                do icc=1,nsegslt
                  if (chlist(ic) .eq. segid4(icc)(1:1)) maskseg(icc)=1
                end do
              end do
            end if
            do ic=1,nsegslt
              if (maskseg(ic).eq. 1) then
                if (iusedseg(ic) .eq. 1 .and. notransf .eq. 1) then
                  print *,'Chain ',segid4(ic)(1:1),' skipped'
                  maskseg(ic)=0
                else
                  iusedseg(ic)=1
                end if
              end if
            end do
            do ic=1,nsegslt
              if (maskseg(ic) .eq. 1) then
                if (notransf .eq. 0) then
c                 Generate new chain ID
                  ich=0
                  new=0
                  do while (ich .lt. 62 .and. new .eq. 0)
                    new=1
                    ich=ich+1
                    do icc=1,nsegtot
                      if (abc(ich) .eq. chidused(icc)) new=0
                    end do
                  end do
                  chnew=abc(ich)
                  chidused(nsegtot+1)=chnew
                else
                  chnew=segid4(ic)(1:1)
                end if
                write (6,2008) segid4(ic)(1:1),chnew
c                write (6,9671) (chidused(i),i=1,nsegtot)
c9671            format(' CHIDUSED=',20a1)
c               Transform chain ic and write the corresponding PDB file
                is1=molsltlim(1,ic)
                is1o=is1
                icn=ic
                if (nasym .gt. 1) then
                  is1=nslttot+1
                  icn=nsegtot+1
                end if
                natss=molsltlim(2,ic)-molsltlim(1,ic)+1
                isn=is1
                call rotate_c(c(1,is1o),natss,rotasym(1,1,nasym),
     -            ctemp(1,isn),'BIOMOL',6)
                call shiftmol(ctemp(1,isn),natss,shiftasym(1,nasym),
     -            ctemp(1,isn),1.0)
                if (nasym .gt. 1) then
                  molsltlim(1,icn)=nslttot+1
                  molsltlim(2,icn)=nslttot+natss
                  if (molsltlim(3,is) .gt. 0) then
                    molsltlim(3,icn)=nslttot+(molsltlim(3,ic)-is1+1)
                  else
                    molsltlim(3,icn)=molsltlim(3,ic)
                  end if
                end if
c               print *,'IC =',ic ,' if,l=',(molsltlim(k,ic),k=1,2)
c               print *,'ICN=',icn,' if,l=',(molsltlim(k,icn),k=1,2)
                do i=molsltlim(1,icn),molsltlim(2,icn)
                  io=i-molsltlim(1,icn)+molsltlim(1,ic)
                  linew=line(index(io))(1:80)
                  write (linew(31:54),1001)(ctemp(k,i),k=1,3)
                  linew(22:22)=chnew
                  call lastchar(linew,lc,80)
                  write (iuout,1000) linew(1:lc)
                end do
                write (iuout,1000) 'TER'
                if (notransf .eq. 0) then
                  nslttot=nslttot+natss
                  nsegtot=nsegtot+1
                end if
              end if
            end do
          end if
        end do
777     if (nasym .eq. 0) then
          print *,'No transformation info was found in file ',
     -      cellfile(1:len)
         return
        end if
        if (inptcell .ne. inpt) close (inptcell)
      end if
      return
888   print *,'Error in line:'
      print *,lineinp
      stop
1000  format(a)
1001  format(3f8.3)
1002  format(i5)
2000  format(' Transformations will be applied to ',i6,' atoms - ',
     -  'waters are ignored',/,
     -  ' PDB file generated will be written to ',a)
2001  format(' Chain IDs of the transformed segments: ',/,1x,(78a1))
2002  format(' Unit cell dimensions:',3f10.3,' A',/,
     -  ' Cell axis angles:    ',3f10.3,' deg')
2003  format('ATOM  ',i5,1x,' HE ',1x,'CEL',1x,'X',i4,1x,3x,3f8.3,
     -  '  1.0   0.0')
2004  format('CONECT',4i5)
2005  format(' Unit vectors of the non-rectangular unit cell:',/,
     -  ' ex=',3f9.5,/,' ey=',3f9.5,/,' ez=',3f9.5)
2006  format(' NOTE: cell information is in PDB syntax but the file',/,
     -  a,1x,a,' a PDB file')
2007  format(' Number of atoms in the extended system (',i8,
     -    ') exceeds limit (',i8,')',/,'Redimension the program')
2008  format(' Chain ',a,' transformed as chain ',a)
      end
      subroutine compact_ucell(c,ctemp,itemp,molsltlim,n,nmolslt,
     -  vertex,cmin,cmax,c0,edge,uxyz,nshift)
      dimension c(3,n),ctemp(3,n),itemp(n),molsltlim(3,nmolslt),
     -  edge(3),uxyz(3,3),vertex(3,8),cmin(3),cmax(3),c0(3)
      print *,'COMPACT_UCELL n,nmolslt=',n,nmolslt,' VOL=',vol
      icompact=1
      nshift=0
      do while (icompact .gt. 0)
        icompact=0
        do im=1,nmolslt
          ifst=molsltlim(1,im)
          ilst=molsltlim(2,im)
          nats=ilst-ifst+1
c         print *,'IFST,ILST=',ifst,ilst
          call trnsfr(ctemp,c(1,ifst),3*nats)
          call trnsfr(ctemp(1,nats+1),vertex,24)
          call extension(ctemp,itemp,0,1,nats+8,cmin,cmax,c0,1,0,vol)
          call checkonedir(c,ctemp,itemp,ifst,ilst,edge,uxyz,
     -      vertex,cmin,cmax,c0,vol,1,ixshift,n)
          call checkonedir(c,ctemp,itemp,ifst,ilst,edge,uxyz,
     -      vertex,cmin,cmax,c0,vol,2,iyshift,n)
          call checkonedir(c,ctemp,itemp,ifst,ilst,edge,uxyz,
     -      vertex,cmin,cmax,c0,vol,3,izshift,n)
          ishift=ixshift+iyshift+izshift
          print *,'ixshift,iyshift,izshift=',ixshift,iyshift,izshift
          icompact=icompact+ishift
          nshift=nshift+ishift
        end do
      end do
      print *,'COMP NSHIFT=',nshift
      return
      end
      subroutine checkonedir(c,ctemp,itemp,ifst,ilst,edge,uxyz,
     -  vertex,cmin,cmax,c0,vol,iaxis,ishift,n)
      dimension c(3,n),ctemp(3,n),itemp(n),edge(3),uxyz(3,3),
     -  vertex(3,8),cmin(3),cmax(3),c0(3)
      dimension shift(3)
      print *,'CHECKONEDIR iaxis=',iaxis,' ifst,ilst=',ifst,ilst
      ishift=0
      nats=ilst-ifst+1
      do ix=-1,1,2
c       Translate back and forth along the x axis
        if (ishift .eq. 0) then
c         Generate translation along the iaxis-th axis 
          do k=1,3
            shift(k)=edge(k)*uxyz(k,iaxis)
          end do
c         print *,'SHIFT=',shift
          call shiftmol(c(1,ifst),nats,shift,ctemp,float(ix))
          call trnsfr(ctemp(1,nats+1),vertex,24)
          call extension(ctemp,itemp,0,1,nats+8,cmin,cmax,c0,1,0,volnew)
          print *,'VOL,VOLNEW=',vol,volnew,' ix,iaxis=',ix,iaxis
          if (volnew/vol .lt. 0.9) then
            vol=volnew
            call trnsfr(c(1,ifst),ctemp,3*nats)
            print *,'MOVED ifst,ilst=',ifst,ilst
            ishift=1
          end if
        end if
      end do
      return
      end
      subroutine try_to_compact(c,ctemp,molsltlim,edge,nslt,nmolslt,
     -  icompact)
      dimension c(3,nslt),ctemp(3,nslt),molsltlim(3,nmolslt),edge(3)
      dimension shift(3)
      do im=1,nmolslt
        ifst=molsltlim(1,im)
        ilst=molsltlim(2,im)
        icomp=1
        do while (icomp .gt. 0)
          icomp=0
          call countout_rect(ifst,ilst,c,edge,nouttot,kmax,nslt)
          if (float(nouttot)/float(ilst-ifst+1) .gt. 0.1) then
c           Translate
            if (kmax .lt. 0) then
              kmax=-kmax
              fact_s=1.0
            else
              fact_s=-1.0
            end if
            call zeroit(shift,3)
            shift(kmax)=edge(kmax)
            call shiftmol(c(1,ifst),ilst-ifst+1,shift,ctemp(1,ifst),
     -        fact_s)
c           Check if ctemp is more compact
            call countout_rect(ifst,ilst,ctemp,edge,nouttotnew,kmax,
     -        nslt)
            if (nouttotnew .lt. nouttot) then
              call trnsfr(c(1,ifst),ctemp(1,ifst),3*(ilst-ifst+1))
              icompact=1
              icomp=1
            end if
          end if
        end do
      end do
      return
      end
      subroutine countout_rect(ifst,ilst,c,edge,nouttot,kmax,n)
      dimension c(3,n),edge(3)
      dimension nxyzp(3),nxyzm(3)
      call zeroiti(nxyzp,0,3)
      call zeroiti(nxyzm,0,3)
      do ia=ifst,ilst
        do k=1,3
          if (c(k,ia) .lt. 0.0) nxyzm(k)=nxyzm(k)+1
          if (c(k,ia) .gt. edge(k)) nxyzp(k)=nxyzp(k)+1
        end do
      end do
      nouttot=0
      noutmax=0
      kmax=0
      do k=1,3
        nouttot=nouttot+nxyzm(k)+nxyzp(k)
        if (nxyzp(k) .gt. noutmax) then
          noutmax=nxyzp(k)
          kmax=k
        end if
        if (nxyzm(k) .gt. noutmax) then
          noutmax=nxyzm(k)
          kmax=-k
        end if
      end do
c      write (6,1000) nxyzm,nxyzp
c      write (6,1001) ifst,ilst,nouttot,edge
c1000  format(' COUNTOUT nxyzm=',3i9,' nxyzp=',3i9)
c1001  format(' COUNTOUT ifst,ilst=',2i6,' nout=',i6,' e=',3f10.5)
      return
      end
      subroutine readmol2(iomol2,line,nlines,natsmol2,iresno,iatnum,
     -  nnmol2,inmol2,iseqncol1,iseqncol2,inamcol1,irescol1,iresncol1,
     -  iresncol2,iccol1,iccol2,ipotcol1,iqcol1,iqcol2,lenrec,cmol2,
     -  qmol2,index,maxng,maxat)
      dimension iresno(maxat),iatnum(maxat),nnmol2(maxat),
     -  inmol2(maxng,maxat),cmol2(3,maxat),qmol2(maxat),index(maxat)
      character* 132 line(maxat)
      character*1 xyz
      common /axislab/ xyz(3)
c     character*2 bondord(maxng,maxat)
c     character*4 resnamprev
      character*80 lineinp
c     print *,'READMOL2 iomol2,maxng,maxat=',iomol2,maxng,maxat
c     print *,'READMOL2 inamcol1=',inamcol1,' irescol1=',irescol1,
c    -  ' iresncol1=',iresncol1
      natsmol2=0
      nres=0
c     resnamprev='XYZU'
      call blankout(lineinp,1,80)
      nlines=0
      naterr=0
      nlines_mol=0
      do while (lineinp(1:17) .ne. '@<TRIPOS>MOLECULE')
        read (iomol2,1000,end=777) lineinp
        nlines=nlines+1
        line(nlines)=lineinp
      end do
      nlines_mol=nlines
      do while (lineinp(1:13) .ne. '@<TRIPOS>ATOM')
        read (iomol2,1000,end=777) lineinp
        nlines=nlines+1
        line(nlines)(1:80)=lineinp
      end do
c     print *,line(nlines_mol+2)(1:60)
777   if (nlines_mol .eq. 0) then
        print *,'ERROR: no MOLECULE record is found'
        stop
      end if
      read (line(nlines_mol+2),*,err=771) nats,nbonds
c     print *,'nats,nbonds=',nats,nbonds
771   do while (lineinp(1:13) .ne. '@<TRIPOS>BOND')
        call blankout(lineinp,1,80)
        read (iomol2,1000,end=888) lineinp
        nlines=nlines+1
        line(nlines)(1:80)=lineinp
        if (lineinp(1:13) .ne. '@<TRIPOS>BOND') then
          natsmol2=natsmol2+1
          index(natsmol2)=nlines
c       print *,'NLINES=',nlines,' natsmol2=',natsmol2,
c    -    ' index(natsmol2)=',index(natsmol2)
c       print *,line(nlines)
          call blankout(line(nlines),1,80)
          if (natsmol2 .gt. maxat) then
            write (6,2001) maxat
            stop
          end if
          call blankout(line(nlines),1,80)
          ic=1
c         Atom id
          call nextchar(lineinp,ic,lenrec)
          ic1=ic
          call nextblank(lineinp,ic,lenrec)
          nsp=iseqncol2-iseqncol1+1-(ic-ic1)
          line(nlines)(iseqncol1+nsp:iseqncol2)=lineinp(ic1:ic-1)
c         Atom name
          call nextchar(lineinp,ic,lenrec)
          ic1=ic
          call nextblank(lineinp,ic,lenrec)
          ic2=ic-1
c         Check for blank within the atom name
          icc=ic
          call nextchar(lineinp,icc,lenrec)
          if (icc-ic1 .le. 4) then
c           Fill in the blank
            ic2=icc
            do ic=ic1,ic2
              if (lineinp(ic:ic) .eq. ' ') lineinp(ic:ic)='_'
            end do
          end if
          line(nlines)(inamcol1:inamcol1+ic2-ic1)=lineinp(ic1:ic2)
          iatnum(natsmol2)=ianum(lineinp(ic1:ic2),1,ic2-ic1+1)
c         Coordinates
          lencoord=(iccol2-iccol1+1)/3
          do k=1,3
            call nextchar(lineinp,ic,lenrec)
            if (ic .eq. lenrec) go to 555
            ic1=ic
            call nextblank(lineinp,ic,lenrec)
            if (ic-ic1 .lt. 3) then
              write (6,2002) xyz(k),lineinp(ic1:ic-1)
            end if
            read (lineinp(ic1:ic-1),*,err=555) cmol2(k,natsmol2)
            write (line(nlines)
     -        (iccol1+(k-1)*lencoord:iccol1+k*lencoord-1),1001)
     -        cmol2(k,natsmol2)
          end do
c         Atomtype
          call nextchar(lineinp,ic,lenrec)
          if (ic .eq. lenrec) go to 555
          ic1=ic
          call nextblank(lineinp,ic,lenrec)
          line(nlines)(ipotcol1:ipotcol1+ic-ic1-1)=lineinp(ic1:ic-1)
c         Substance id (residue number)
          call nextchar(lineinp,ic,lenrec)
          ic1=ic
          call nextblank(lineinp,ic,lenrec)
          read (lineinp(ic1:ic-1),*,err=555),nres
c         Residue (substructure) name
          call nextchar(lineinp,ic,lenrec)
          if (ic .eq. lenrec) go to 555
          ic1=ic
          call nextblank(lineinp,ic,lenrec)
          line(nlines)(irescol1:irescol1+ic-ic1-1)=lineinp(ic1:ic-1)
c         if (resnamprev(1:ic-ic1) .ne. lineinp(ic1:ic-1)) then
c           New residue
c           nres=nres+1
c           resnamprev(1:ic-ic1)=lineinp(ic1:ic-1)
c         end if
          write (line(nlines)(iresncol1:iresncol2),1003) nres
          iresno(natsmol2)=nres
c         Charge
          call nextchar(lineinp,ic,lenrec)
          if (ic .eq. lenrec) go to 555
          ic1=ic
          call nextblank(lineinp,ic,lenrec)
          read (lineinp(ic1:ic-1),*,err=555) qmol2(natsmol2)
          write (line(nlines)(iqcol1:iqcol2),1002) qmol2(natsmol2)
c         Status bit - not read for now
        end if
        go to 556
555     call lastchar(lineinp,iclast,80)
        write (6,2000) 'atom',natsmol2,lineinp(1:iclast)
        naterr=naterr+1
        if (naterr .eq. 25) then
          call askyn('There were 25 errors so far. Do you want to stop',
     -      48,1,+1,istop,000)
          if (istop .eq. 1) stop
        endif
556     continue
      end do
888   print *,'Read ',natsmol2,' atoms'
      if (nats .ne. natsmol2) then
        write (6,2003) natsmol2,nats
        call askstop(1)
      end if
      call zeroiti(nnmol2,0,natsmol2)
      nerr=0
      nbmol2=0
      do ibn=1,nbonds
        call blankout(lineinp,1,80)
        read (iomol2,1000,end=999,err=666) lineinp
        nlines=nlines+1
        line(nlines)=lineinp
        read (lineinp,*,end=999) ib,ia,ja
c       Bond order label is ignored for now
c       ic=1
c       do ifnd=1,4
c         call nextchar(lineinp,ic,lenrec)
c         ic1=ic
c         call nextblank(lineinp,ic,lenrec)
c       end do
        if (nnmol2(ia) .lt. maxng) then
          nnmol2(ia)=nnmol2(ia)+1
          inmol2(nnmol2(ia),ia)=ja
c         bondord(nnmol2(ia),ia)(1:ic-ic1)=lineinp(ic1:ic-1)
        else
          print *,'ERROR: atom ',ia,' has more than ',maxng,
     -      ' neighbors'
          nerr=nerr+1
        end if
        if (nnmol2(ja) .lt. maxng) then
          nnmol2(ja)=nnmol2(ja)+1
          inmol2(nnmol2(ja),ja)=ia
c         bondord(nnmol2(ja),ja)(1:ic-ic1)=lineinp(ic1:ic-1)
        else
          print *,'ERROR: atom ',ja,' has more than ',maxng,
     -      ' neighbors'
          nerr=nerr+1
        end if
        nbmol2=nbmol2+1
      end do
999   print *,'Read ',nbmol2,' bonds'
      return
666   call lastchar(lineinp,iclast,80)
      write (6,2000) 'bond',nbmol2,lineinp(1:iclast)
      return
1000  format(a)
1001  format(f12.5)
1002  format(f7.4)
1003  format(i4)
2000  format(' ERROR: Invalid .mol2 ',a,' record, natsmol2=',i5,
     -  ' record:',/,1x,a)
2001  format(' ERROR: maximum number of atoms (',i9,') is exceeded',/,
     -  ' Recompile the program with parameter MAXREC set larger')
2002  format(' ERROR: ',a1,'-coordinate has too few digits:',a)
2003  format(' WARNING: # of atoms read (',i6,') differs from the # ',
     -  'specified (',i6,')')
      end
      subroutine read_mae_mol(nats,nbonds,ian,iresn,isegno,nsegm,c,q,
     -  nn,in,index,line,inptyp_mae,iofull,inpt,iout,ierr,maxat,maxng)
      dimension ian(maxat),iresn(maxat),isegno(maxat),c(3,maxat),
     -  q(maxat),index(maxat)
      dimension nn(maxat),in(maxng,maxat)
      character*132 line(maxat)
      character*400 linein
      parameter (MAXCOL=50)
      character*20 items(MAXCOL)
      character*50 colid(MAXCOL)
      dimension litems(MAXCOL),lcolid(MAXCOL),iancount(99)
      character*2 iatnm2
      common /atnam/ aw(99),nval(99),nvalmax(99),mmofan(99),
     -  mmatno(64),iatnm2(99)
      character*4 segn4,segn4prev
c     print *,'READ_MAE inpt,iout,inptyp_mae=',inpt,iout,inptyp_mae
      call setcol(inptyp_mae,ncol,idcol,ialtcol,
     -  inamcol1,inamcol2,irescol1,irescol2,iccol1,iccol2,
     -  iresncol1,iresncol2,iseqncol1,iseqncol2,isegcol1,isegcol2,
     -  iresidcol1,iresidcol2,iqcol1,iqcol2,ipotcol1,ipotcol2,
     -  iocccol1,iocccol2,ichemcol1,ichemcol2,nrescol,nresncol,
     -  nsegcol,nnamcol,iofull)
      iccol11=iccol1
      iccol12=iccol1+(iccol2-iccol1+1)/3
      iccol13=iccol12+(iccol2-iccol1+1)/3
      len=400
      ierr=1
      ix_x=0
      ix_y=0
      ix_z=0
      ix_rnum=0
      ix_rnam=0
      ix_anam=0
      ix_occ=0
      ix_tfac=0
      ix_atno=0
      ix_charge1=0
      ix_segn=0
      call read_head('m_atom',6,nats,linein,len,inpt,iout)
c     print *,'NATS=',nats
c     Read item descriptors
      call read_colid(ndcol,colid,lcolid,'atoms',5,linein,len,iend,
     -  inpt,iout,MAXCOL)
      if (iend .eq. 1) return
      do icol=1,ndcol
        lc=lcolid(icol)
        if (colid(icol)(1:lc) .eq. 'r_m_x_coord') then
          ix_x=icol
        else if (colid(icol)(1:lc) .eq. 'r_m_y_coord') then
          ix_y=icol
        else if (colid(icol)(1:lc) .eq. 'r_m_z_coord') then
          ix_z=icol
        else if (colid(icol)(1:lc) .eq. 'i_m_residue_number') then
          ix_rnum=icol
        else if (colid(icol)(1:lc) .eq. 's_m_pdb_residue_name' .or.
     -           colid(icol)(1:lc) .eq. 's_m_residue_name') then
          ix_rnam=icol
        else if (colid(icol)(1:lc) .eq. 's_m_chain_name') then
          ix_segn=icol
        else if (colid(icol)(1:lc) .eq. 's_m_pdb_atom_name' .or.
     -           colid(icol)(1:lc) .eq. 's_m_atom_name') then
          ix_anam=icol
        else if (colid(icol)(1:lc) .eq. 'r_m_pdb_occupancy') then
          ix_occ=icol
        else if (colid(icol)(1:lc) .eq. 'r_m_pdb_tfactor') then
          ix_tfac=icol
        else if (colid(icol)(1:lc) .eq. 'i_m_atomic_number') then
          ix_atno=icol
        else if (colid(icol)(1:lc) .eq. 'r_m_charge1') then
          ix_charge1=icol
        end if
      end do
c     print *,'ix_x,y,z=',ix_x,ix_y,ix_z
c     print *,'ix_rnam,rnum,anam,atno=',ix_rnam,ix_rnum,ix_anam,ix_atno
      if (ix_x*ix_y*ix_z .eq. 0)
     -   write (6,*) 'WARNING: coordinate records are missing'
      if (ix_anam .eq. 0) write (6,*)
     -   'WARNING: atom name record is missing - generic atom names',
     -  ' will be generated'
      do ia=1,nats
        do k=1,3
          c(k,ia)=999.9
        end do
        ian(ia)=-1
        iresn(ia)=-1
        occ=0.0
        tfac=0.0
        call blankout(line(ia),inamcol1,inamcol2)
      end do
      segn4prev='@#*&'
      nsegm=0
      nnoname=0
      nUNK=0
      do ia=1,nats
        call blankout(line(ia),1,ncol)
        call blankout(linein,1,len)
        read (inpt,1000,end=991) linein
        index(ia)=ia
        ic=1
        do icol=1,ndcol
          call nextstring(linein,ic,ic1,ic2,len)
          litems(icol)=ic2-ic1+1
          items(icol)(1:litems(icol))=linein(ic1:ic2)
c         write (6,*) 'IA,ICOL,IC1,IC2=',ia,icol,ic1,ic2
        end do
        icol=1
c        write (6,8791) ia,(ic,litems(ic),items(ic)(1:litems(ic)),ic=1,3)
c8791  format(' IA=',i2,3(' ic=',i2,' l=',i2,' item=',a))
        read (items(icol)(1:litems(icol)),*,end=992,err=992) ix
        if (ix .ne. ia) then
          write (iout,2002) 'atom',ia,ix
          return
        end if
        icol=ix_x
        if (items(max0(1,icol))(1:2) .ne. '<>' .and. icol .gt. 0) then
          read (items(icol)(1:litems(icol)),*,end=992,err=992) c(1,ia)
          line(ia)(iccol11:iccol11+litems(icol)-1)=
     -      items(icol)(1:litems(icol))
        end if
        icol=ix_y
        if (items(max0(1,icol))(1:2) .ne. '<>' .and. icol .gt. 0) then
          read (items(icol)(1:litems(icol)),*,end=992,err=992) c(2,ia)
          line(ia)(iccol12:iccol12+litems(icol)-1)=
     -      items(icol)(1:litems(icol))
        end if
        icol=ix_z
        if (items(max0(1,icol))(1:2) .ne. '<>' .and. icol .gt. 0) then
          read (items(icol)(1:litems(icol)),*,end=992,err=992) c(3,ia)
          line(ia)(iccol13:iccol13+litems(icol)-1)=
     -      items(icol)(1:litems(icol))
        end if
        icol=ix_rnum
        if (items(max0(1,icol))(1:2) .ne. '<>' .and. icol .gt. 0) then
          read (items(icol)(1:litems(icol)),*,end=992,err=992) iresn(ia)
          line(ia)(iresncol1:iresncol1+litems(icol)-1)=
     -      items(icol)(1:litems(icol))
        end if
        if (ix_rnam .eq. 0) then
          call blankout(line(ia),irescol1,irescol2)
          line(ia)(irescol1:irescol1+2)='LIG'
        else
          icol=ix_rnam
          if (items(max0(1,icol))(1:2) .ne. '<>' .and. icol .gt. 0)
c    -      resnam(ia)(1:litems(icol))=items(icol)(1:litems(icol))
     -      line(ia)(irescol1:irescol1+litems(icol)-1)=
     -        items(icol)(1:litems(icol))
          if (items(max0(1,icol))(1:3) .eq. 'UNK') nUNK=nUNK+1
        end if
        icol=ix_segn
        if (items(max0(1,icol))(1:2) .ne. '<>' .and. icol .gt. 0) then
          segn4='    '
          len4=min0(4,litems(icol))
          segn4(1:len4)=items(icol)(1:len4)
          if (segn4 .ne. segn4prev) then
            nsegm=nsegm+1
            segn4prev=segn4
          end if
          isegno(ia)=nsegm
        end if
        icol=ix_anam
        if (items(max0(1,icol))(1:2) .ne. '<>' .and. icol .gt. 0)
c    -    atnam(ia)(1:litems(icol))=items(icol)(1:litems(icol))
     -    line(ia)(inamcol1:inamcol1+litems(icol)-1)=
     -      items(icol)(1:litems(icol))
        if (line(ia)(inamcol1:inamcol2) .eq. '    ') nnoname=nnoname+1
        icol=ix_occ
        if (items(max0(1,icol))(1:2) .ne. '<>' .and. icol .gt. 0) then
          read (items(icol)(1:litems(icol)),*,end=992,err=992) occ
          line(ia)(iocccol1:iocccol1+litems(icol)-1)=
     -      items(icol)(1:litems(icol))
        end if
        icol=ix_atno
        if (items(max0(1,icol))(1:2) .ne. '<>' .and. icol .gt. 0) then
          read (items(icol)(1:litems(icol)),*,end=992,err=992) ian(ia)
c         if (ian(ia) .le. 99)
c    -      line(ia)(ichemcol1:ichemcol1+1)=iatnm2(ian(ia))
c         print *,'IA=',ia,' INCHEMCOL1=',ichemcol1,' cnam=',
c    -      iatnm2(ian(ia))
        end if
        write (line(ia)(1:10),1001) ia
        icol=ix_charge1
        if (items(max0(1,icol))(1:2) .ne. '<>' .and. icol .gt. 0) then
          read (items(icol)(1:litems(icol)),*,end=992,err=992) q(ia)
          line(ia)(iqcol1:iqcol1+litems(icol)-1)=
     -      items(icol)(1:litems(icol))
        else
          icol=ix_tfac
          if (items(max0(1,icol))(1:2) .ne. '<>' .and. icol .gt. 0) then
            read (items(icol)(1:litems(icol)),*,end=992,err=992) q(ia)
            line(ia)(iqcol1:iqcol1+litems(icol)-1)=
     -        items(icol)(1:litems(icol))
          end if
        end if
c       write (77,1000) line(ia)
      end do
      if (nnoname .gt. 0) then
        if (nnoname .lt. nats .and. nnoname .ne. nUNK) then
c         Just added hydrogen
          nha=0
          do ia=1,nats
            if (line(ia)(inamcol1:inamcol2) .eq. '    ') then
              nha=nha+1
              line(ia)(inamcol1:inamcol1)='H'
              ic=inamcol1+1
              call writeint(line(ia),ic,nha,nhlen)
            end if
          end do
        else
c         All (UNK) names are blank - generate them from atomic numbers
          call zeroiti(iancount,0,99)
          do ia=1,nats
            if (line(ia)(inamcol1:inamcol2) .eq. '    ') then
              iancount(ian(ia))=iancount(ian(ia))+1
              line(ia)(inamcol1:inamcol1+1)=iatnm2(ian(ia))
              if (line(ia)(inamcol1+1:inamcol1+1) .eq. ' ') then
                if (iancount(ian(ia)) .le. 999) then
                  ic=inamcol1+1
                  call writeint(line(ia),ic,iancount(ian(ia)),nal)
                else
                  write (iout,*) 'Atom count for ',iatnm2(ian(ia)),
     -              'exceeds 999'
                end if
              else
                if (iancount(ian(ia)) .le. 99) then
                  ic=inamcol1+2
                  call writeint(line(ia),ic,iancount(ian(ia)),nal)
                else
                  write (iout,*) 'Atom count for ',iatnm2(ian(ia)),
     -              'exceeds 99'
                end if
              end if
            end if
          end do
        end if
      end if
c     print *,'NATS=',nats
      call read_head('m_bond',6,nbonds,linein,len,inpt,iout)
c     print *,'NBONDS,maxng=',nbonds,maxng
      if (maxng .gt. 1) then
c       Read bond info
        call read_colid(ndcol,colid,lcolid,'bonds',5,linein,len,iend,
     -    inpt,iout,MAXCOL)
        if (iend .eq. 1) return
        call zeroiti(nn,0,nats)
        call zeroiti(in,0,maxng*nats)
c       print *,'NDCOL=',ndcol
        do ib=1,nbonds
          call blankout(linein,1,len)
          read (inpt,1000,end=991) linein
          ic=1
          call nextstring(linein,ic,ic1,ic2,len)
          icol=1
          read (linein(ic1:ic2),*,end=992,err=992) ix
          if (ix .ne. ib) then
            write (iout,2002) 'atom',ib,ix
            return
          end if
          ic=ic2+1
          call nextstring(linein,ic,ic1,ic2,len)
          icol=2
          read (linein(ic1:ic2),*,end=992,err=992) ib1
          ic=ic2+1
          call nextstring(linein,ic,ic1,ic2,len)
          icol=3
          read (linein(ic1:ic2),*,end=992,err=992) ib2
          nn(ib1)=nn(ib1)+1
          in(nn(ib1),ib1)=ib2
          nn(ib2)=nn(ib2)+1
          in(nn(ib2),ib2)=ib1
        end do
      end if
      ierr=0
      return
991   write (iout,2001) 'atom descriptors'
      return
992   write (iout,2000) colid(icol)(1:lcolid(icol)),
     -  items(icol)(1:litems(icol)),linein(1:50)
      print *,'icol=',icol,' litems=',litems(icol)
      return
1000  format(a)
1001  format(i10)
2000  format(' ERROR: invalid ',a,':',a,' in line',/,1x,a)
2001  format(' ERROR: run out of data while reading ',a)
2002  format(' ERROR: index misaligment when reading ',a,
     - ' i=',i6,' i(read)=',i6)
      end
      subroutine read_head(lab,llab,n,line,len,inpt,iout)
      character*(*) lab,line
      n=0
      do while (n .eq. 0)
        call blankout(line,1,len)
        read (inpt,1000,end=991) line
        ic=1
        call nextchar(line,ic,len)
        if (ic .lt. len) then
          if (line(ic:ic+llab-1) .eq. lab(1:llab) .and.
     -        line(ic+llab:ic+llab) .eq. '[') then
c           Header found
            ic1=ic+llab+1
            ic=ic1
            call findchar(']',line,ic,len)
            if (ic .eq. len) go to 992
            read (line(ic1:ic-1),*,end=992,err=992) n
          end if
        end if
      end do
      return
991   write (iout,2001) lab(1:llab)
      return
992   write (iout,2000) 'Invalid number of items',line(1:50)
      return
1000  format(a)
2000  format(' ERROR: ',a,' in line',/,1x,a)
2001  format(' ERROR: run out of data while reading ',a,' header')
      end
      subroutine read_colid(ndcol,colid,lcolid,lab,llab,line,len,
     -  iend,inpt,iout,maxcol)
      character*(*) lab,line
      character*50 colid(maxcol)
      dimension lcolid(MAXCOL)
c     print *,'READ COLID inpt,iout=',inpt,iout,' lab=',lab(1:llab)
      ndcol=1
      colid(1)='index'
      lcolid(1)=5
      ic=1
      iend=0
      do while (line(ic:ic+2) .ne. ':::')
        call blankout(line,1,200)
        read (inpt,1000,end=991,err=991) line
        call lastchar(line,lc,len)
        if (lc .gt. 1) then
          ic=1
          call nextchar(line,ic,len)
          if (line(ic:ic) .ne. '#') then
            ndcol=ndcol+1
            lcolid(ndcol)=min0(lc-ic+1,50)
c           print *,'ndcol,ic,lc=',ndcol,ic,lc
            colid(ndcol)(1:lcolid(ndcol))=line(ic:lc)
          end if
        end if
      end do
      ndcol=ndcol-1
      return
991   write (iout,2000) lab(1:llab)
      iend=1
      return
1000  format(a)
2000  format(' ERROR: run out of data while reading ',a,
     -  ' column identifiers')
      end
      subroutine setmolres(ifres,ilres,isegno,molresflag,
     -  molsltlim,nrescol,irescol1,irescol2,resnames,numresslt,nmolslt,
     -  nsegslt,nmolsltnoion,minresflag,index,indexa,indexs,line,
     -  maxrsd,maxrec)
      dimension ifres(maxrec),ilres(maxrec),isegno(maxrec),
     -  molresflag(maxrsd),
     -  molsltlim(3,maxrsd),index(maxrec),indexa(maxrec),indexs(maxrec)
      character* 132 line(maxrec)
      character*8 resnames(maxrsd)
      character*8 ionresnam(100),molresnam(100)
c     Check for ions - make them separate molecules
      write (6,2117)
      call askyn('Do you have ions in this system',31,1,-1,ions,18)
      if (ions .gt. 0) call getnamelist(ionresnam,nrescol,nions,
     -  'Ion residue name',16,100)
      write (6,2118)
      call askyn('Do you have molecular residues in this system',
     - 45,1,-1,imolres,19)
      if (imolres .gt. 0) call getnamelist(molresnam,nrescol,
     -  nmolres,'Molecular residue name',22,100)
      if (ions+imolres .gt. 0) then
        nions_found=0
        nmolres_found=0
c       Gather residue names
        if (ions .gt. 0) call zeroiti(indexa,0,nions)
        if (imolres .gt. 0) call zeroiti(indexs,0,nmolres)
        minresflag=2
        do ir=1,numresslt
          resnames(ir)(1:nrescol)=
     -      line(index(ifres(ir)))(irescol1:irescol2)
          if (ions .gt. 0) then
            do irr=1,nions
              if (resnames(ir)(1:nrescol) .eq.
     -            ionresnam(irr)(1:nrescol)) then
                molresflag(ir)=2
                indexa(irr)=indexa(irr)+1
                nions_found=nions_found+1
              end if
            end do
          end if
          if (imolres .gt. 0) then
            do irr=1,nmolres
              if (molresflag(ir) .eq. 0 .and.
     -            resnames(ir)(1:nrescol) .eq.
     -            molresnam(irr)(1:nrescol))  then
                molresflag(ir)=1
                indexs(irr)=indexs(irr)+1
                nmolres_found=nmolres_found+1
              end if
            end do
          end if
          if (minresflag .gt. molresflag(ir)) minresflag=molresflag(ir)
        end do
        if (ions .gt. 0) then
          if (nions_found .eq. 0) write (6,2115) 'ions'
          if (nions_found .gt. 0) write (6,2114) 'ions',nions_found
        end if
        if (imolres .gt. 0) then
          if (nmolres_found .eq. 0) write (6,2115) 'molecular residues'
          if (nmolres_found .gt. 0)
     -      write (6,2114) 'molecular residues',nmolres_found
        end if
      else
        minresflag=0
      end if
      nrnoion=numresslt
      nmolion=0
      if (ions .gt. 0) then
c       Last block of solute residues may be ions
        write (6,2121) (ionresnam(irr)(1:nrescol),'ion',
     -    indexa(irr),irr=1,nions)
        ir=numresslt
        do while (ir .gt. 1 .and. molresflag(ir) .eq. 2)
          ir=ir-1
        end do
        if (ir .eq. 1 .and. molresflag(ir) .eq. 2) ir=0
        nrnoion=ir
        numresions=numresslt-nrnoion
        do ir=1,nrnoion
          if (molresflag(ir) .eq. 2) then
            write (6,2116) ir
            molresflag(ir)=1
          end if
        end do
        nsegnoion=isegno(ilres(nrnoion))
        do ir=nrnoion+1,numresslt
          molsltlim(1,nsegnoion+ir-nrnoion)=ifres(ir)
          molsltlim(2,nsegnoion+ir-nrnoion)=ilres(ir)
          molsltlim(3,nsegnoion+ir-nrnoion)=0
        end do
        nmolion=numresslt-nrnoion
        nmolslt=nmolslt+nmolion-(nsegslt-nsegnoion)
c        write (77,7272) (is,(molsltlim(k,is),k=1,2),is=1,nmolslt)
c7272    format(i4,' molsltlims=',2i6)
      end if
      if (imolres .gt. 0) then
        write (6,2121) (molresnam(irr)(1:nrescol),'molecular residue',
     -    indexs(irr),irr=1,nmolres)
c       Make requested residues molecules
        nmoladd=0
        numresslt=0
        do ir=nrnoion,1,-1
          if (molresflag(ir) .eq. 1) then
            numresslt=numresslt+1
            is=isegno(ilres(ir))
            if (ilres(ir) .eq. molsltlim(2,is) .and.
     -          ifres(ir) .eq. molsltlim(1,is)) then
c             Do nothing
c
            else if (ilres(ir) .eq. molsltlim(2,is)) then
c             Last residue of the segment
              nmoladd=nmoladd+1
              do iss=nmolslt+nmoladd,is+2,-1
                molsltlim(1,iss)=molsltlim(1,iss-1)
                molsltlim(2,iss)=molsltlim(2,iss-1)
              end do
              molsltlim(1,is+1)=ifres(ir)
              molsltlim(2,is+1)=ilres(ir)
              molsltlim(2,is)=ifres(ir)-1
            else if (ifres(ir) .eq. molsltlim(1,is)) then
c             First residue of the segment
              nmoladd=nmoladd+1
              do iss=nmolslt+nmoladd,is+2,-1
                molsltlim(1,iss)=molsltlim(1,iss-1)
                molsltlim(2,iss)=molsltlim(2,iss-1)
              end do
              molsltlim(1,is+1)=ilres(ir)+1
              molsltlim(2,is+1)=molsltlim(2,is)
              molsltlim(1,is)=ifres(ir)
              molsltlim(2,is)=ilres(ir)
            else
c             Residue in the middle of the segment
              nmoladd=nmoladd+2
              do iss=nmolslt+nmoladd,is+3,-1
                molsltlim(1,iss)=molsltlim(1,iss-2)
                molsltlim(2,iss)=molsltlim(2,iss-2)
              end do
              molsltlim(2,is)=ifres(ir)-1
              molsltlim(1,is+2)=ilres(ir)+1
              molsltlim(2,is+2)=molsltlim(2,is)
              molsltlim(1,is+1)=ifres(ir)
              molsltlim(2,is+1)=ilres(ir)
            end if
          end if
        end do
        nmolslt=nmolslt+nmoladd
c       write (77,7272) (is,(molsltlim(k,is),k=1,2),is=1,nmolslt)
      end if
      nmolsltnoion=nmolslt-nmolion
      if (ions+imolres .gt. 0) then
        do is=1,nmolslt
          molsltlim(3,is)=0
        end do
      end if
      return
2114  format(' Number of ',a,' found=',i4)
2115  format(' ERROR: none of the given ',a,' were found')
2116  format(' WARNING: residue ',i5,' is an ion residue but is not ',
     -  'at the end of the solute in a contiguous block ',/,
     -  ' - it will be treated as a molecular residue')
2117  format(' Simulaid treats ions as separate molecules for PBC ',
     -  'calculations',/,' and will not be considered part of the ',
     -  'solute ',/,' for the purpose of centering the system.',/,
     -  ' Ions have to be grouped together at the end of the solute ')
2118  format(' Simulaid treats segments as whole molecules for PBC ',
     -  'calculations.',/,' However, you may specify residue names ',/,
     -  ' that are to be considered separate molecules')
2121  format(' Number of ',a,1x,a,'s found=',i3)
      end
      subroutine uniquename(anames,n)
      character*4 anames(n)
      dimension ntyp(200)
      character*4 typnames(200),number
      ntyps=0
      do ia=1,n
        call findname(anames(ia),typnames,1,ntyps,ix,4)
        if (ix .eq. 0) then
          ntyps=ntyps+1
          if (ntyps .gt. 200) then
            print *,'Number of names exceeds 200 - redimension ',
     -        'the subroutine uniquenames'
            stop
          end if
          typnames(ntyps)=anames(ia)
        end if
      end do
      call zeroiti(ntyp,0,200)
      do ia=1,n
        call findname(anames(ia),typnames,1,ntyps,ix,4)
        if (ix .eq. 0) then
          print *,'PROGRAM ERROR in uniquename: ix=0'
        else
          ntyp(ix)=ntyp(ix)+1
          call lastchar(anames(ia),lc,4)
          ic=1
          call writeint(number,ic,ntyp(ix),len)
          if (lc+len .gt. 4) then
            write (6,1000) ntyp(ix),anames(ia)
            if (anames(ia)(1:1) .eq. ' ') write (6,1001)
            stop
          end if
          anames(ia)(lc+1:lc+len)=number(1:len)
        end if
      end do
      return
1000  format(' There is no room to write ',i4,' after ',a)
1001  format(' You can make room by first leftadjust the atom names')
      end
      subroutine getseg4(segid4,line,isegcol1,nsegcol)
      character*4 segid4
      character*8 segid8
      character* 132 line
c     Get a max 4 character segment name
      if (nsegcol .le. 4) then
        segid4(1:nsegcol)=line(isegcol1:isegcol1+nsegcol-1)
      else
        segid8(1:nsegcol)=line(isegcol1:isegcol1+nsegcol-1)
        call leftadjustline(segid8,1,nsegcol)
        segid4(1:4)=segid8(1:4)
      end if
      return
      end
      subroutine askax(prompt,lprompt,iaxis,ihelp)
      character*(*) prompt
      character*1 ans
      character*80 question
      question=prompt(1:lprompt)//' (x,y,z)'
      lquestion=lprompt+8
      iaxis=0
      do while (iaxis .eq. 0)
        call getname(ans,len,question,lquestion,1,0)
        if (ans .eq. 'x' .or. ans .eq. 'X') then
          iaxis=1
        else if (ans .eq. 'y' .or. ans .eq. 'Y') then
          iaxis=2
        else if (ans .eq. 'z' .or. ans .eq. 'Z') then
          iaxis=3
        else
          print *,'Invalid answer'
        end if
      end do
      return
      end
      subroutine molarvol(nslt,n,naslv,line,index,ir1,ir2,irn1,irn2,
     -  naa,nna,nnw,nnf,v,maxrec)
c     Calculate molar volume using known values of amino and nucleic acids
      character* 132 line(maxrec)
      dimension index(maxrec)
      character*8 resname,resnamela
      character*1 aanames1
      character*2 mmodtoamb
      character*3 aanames3
      common /atnamcon/ mmodtoamb(100),aanames1(58),aanames3(58),
     -  naanames,nnanames,nnammnames,nnames,ixwatnam
      common /pmvol/ pmvaana(58)
      lresn=ir2-ir1+1
c     print *,'MOLARV ir1,ir2,irn1,irn2=',ir1,ir2,irn1,irn2
c     print *,'MOLARV nslt=',nslt
      vna=0.0
      vpr=0.0
      vw=0.0
      naa=0
      nna=0
      nnw=0
      nnf=0
      iresnumo=0
      do ia=1,nslt
        call readint(line(index(ia)),irn1,irn2,iresnum,2)
        if (iresnum .ne. iresnumo) then
c         New residue starts
          iresnumo=iresnum
          resname(1:lresn)=line(index(ia))(ir1:ir2)
          call leftadjustn(resname,resnamela,lresn)
          call findname(resnamela,aanames3,1,naanames,ix,3)
          if (ix .gt. 0 .and.
     -        ix .ne. ixwatnam-1 .and. ix .ne. ixwatnam) then
            vpr=vpr+pmvaana(ix)
            naa=naa+1
          else if (resname(1:3) .eq. 'TIP' .or.
     -       resname(1:3) .eq. 'WTR' .or. resname(1:3) .eq. 'HOH') then
            vw=vw+pmvaana(32)
            nnw=nnw+1
          else
            call findname(resnamela,aanames3,
     -        naanames+nnammnames+1,nnames,ix,3)
            if (ix .gt. 0) then
              vna=vna+pmvaana(ix)
              nna=nna+1
            else
              nnf=nnf+1
            end if
          end if
c         write (77,*) 'ia=',ia,' resname=',resname(1:3),
c    -      ' naa,nnw,nna,nnf=',naa,nnw,nna,nnf
        end if
      end do
      if (n .gt. nslt) then
        resname(1:lresn)=line(index(nslt+1))(ir1:ir2)
        call leftadjustn(resname,resnamela,lresn)
        if (resnamela(1:3) .eq. 'TIP' .or.
     -      resname(1:3) .eq. 'WTR' .or. resname(1:3) .eq. 'HOH') then
          nnw=(n-nslt)/naslv
          vw=nnw*18.07*1.e+24/6.022045e+23
        end if
      end if
      if (nslt .gt. 0) then
        vpr=vpr*1.e+24/6.022045e+23
        vna=vna*1.e+24/6.022045e+23
        v=vpr+vna
        write (6,1000) naa,nna,nnf,v
        if (naa .gt. 0) write (6,1001) 'protein',vpr
        if (nna .gt. 0) then
          write (6,1001) 'nucleic acid',vna
          write (6,1003)
        end if
        if (nnf .gt. 0) write (6,1002)
      end if
      if (n .gt. nslt) then
        if (nnw .gt. 0) then
          print *,'The solvent is assumed to be water'
          write (6,1001) 'water',vw
        end if
      end if
      return
1000  format(' The solute contains ',i4,' amino acid residues',
     -  i4,' nucleic acid residues',/,
     -  ' and',i6,' unclassified residues',/,
     -  ' The volume of the solute is estimated to be ',f10.2,' A^3')
1001  format(' Volume of the ',a,' (part) is estimated to be',f12.2,
     -  ' A^3')
1002  format(' NOTE: unclassified residues did not contribute to the ',
     -  'total solute volume')
1003  format(' NOTE: Nucleic acid volumes are very sensitive to ',
     -  'cc, salt, etc.')
      end
      subroutine dssp(c,n1,n,nslt,line,index,inamcol1,inamcol2,
     -  iresncol1,iresncol2,nneig,ineig,nbox,indices,ihbneig,ixc,ixo,
     -  ixn,ixa,dssplab,idistdssp,ch,cres,enghb,iparal,iantiparal,nss,
     -  itypss,ifss,ilss,nconfig,iwdssp,iwrose,iwhead,ifail,radtodeg,
     -  maxrepconf,maxng,nnlistlen,maxbox,listlen,maxss,maxrsd,maxrec)
      dimension c(3,n),index(n),nneig(n),ineig(maxng,nnlistlen),
     -  indices(maxbox,listlen),nbox(listlen),ihbneig(n),ixc(n),ixo(n),
     -  ixn(n),ixa(n),cres(3,n),iparal(n),iantiparal(n),
     -  idistdssp(9,maxrsd),ch(3,maxrsd),enghb(maxrsd),itypss(maxss),
     -  ifss(maxss),ilss(maxss)
      character*1 dssplab(maxrsd)
      dimension ccprev(3),rx(3),rn(3),rnprev(3),rn1(3),rn1prev(3)
      character*1 charl1(50),charl2(50)
      character*8 atnam
      character* 132 line(maxrec)
      character*1 typc
      character*21 ssname
      common /dsspnames/ lssname(9),ssname(9),typc(9)
      real*8 cosa
      data ing /0/,ils /0/
      lnam=inamcol2-inamcol1+1
c     print *,'DSSP n,nslt,iwdssp=', n,nslt,iwdssp
      ifail=0
      iok=1
      nres=0
      nresok=0
      iccprevf=0
      icccurrf=0
      icfound=0
      iofound=0
      infound=0
      ihfound=0
      iafound=0
      do ia=n1,nslt
        atnam(1:lnam)=line(index(ia))(inamcol1:inamcol2)
        if (lnam .eq. 4) atnam(5:8)='    '
        if (lnam .gt. 4) call leftadjustn(atnam,atnam,lnam)
        if (atnam(1:4) .eq. 'C   ' .or. atnam(1:4) .eq. ' C   ') then
          icfound=1
          ixc(nres+1)=ia
        else if (atnam(1:4) .eq. 'O   ' .or. atnam(1:4) .eq. ' O   ')
     -           then
          iofound=1
          ixo(nres+1)=ia
        else if (atnam(1:4) .eq. 'N   ' .or. atnam(1:4) .eq. ' N   ')
     -           then
          infound=1
          ixn(nres+1)=ia
        else if (atnam(1:4) .eq. 'CA  ' .or. atnam(1:4) .eq. ' CA  ')
     -           then
          iafound=1
          ixa(nres+1)=ia
        else if (atnam(1:4) .eq. 'H   ' .or. atnam(1:4) .eq. ' H   '
     -    .or. atnam(1:4) .eq. ' D  ' .or. atnam(1:4) .eq. 'D   ' .or.
     -    atnam(1:4) .eq. 'HN  ' .or. atnam(1:4) .eq. ' HN ') then
          ihfound=1
          call trnsfr(ch(1,nres+1),c(1,ia),3)
        end if
        if (ia .eq. nslt) then
          iresn=-1
        else
          read (line(index(ia+1))(iresncol1:iresncol2),*,ERR=999) iresn
          if (ia .eq. n1) ireso=iresn
        end if
        if (iresn .ne. ireso) then
c         New residue
          nres=nres+1
          iok=1
          if (ireso .ne. 0) then
c           print *,'icfound,infound,iofound,ihfound=',
c    -          icfound,infound,iofound,ihfound
            if (icfound*infound*iofound .lt. 1) then
              if (nconfig .le. maxrepconf)
     -          print *,'Residue ',ireso,' is missing N, C or O'
              iok=0
            else if (ihfound .eq. 0) then
c             Generate H coordinates from C(prev), CA and N
              iok=0
              call zeroit(ch(1,nres),3)
              if (iccprevf*iafound .eq. 1) then
                dnh=0.0
                dnc=0.0
                do k=1,3
                  rx(k)=2.0*c(k,ixn(nres))-c(k,ixa(nres))-ccprev(k)
                  dnh=dnh+rx(k)**2
                  dnc=dnc+(c(k,ixn(nres))-ccprev(k))**2
                end do
                if (dnc .lt. 4.0) then
                  do k=1,3
                    ch(k,nres)=c(k,ixn(nres))+rx(k)/sqrt(dnh)
                  end do
                  iok=1
                else
c                 print *,'nconfig,maxrepconf=',nconfig,maxrepconf
                  if (nconfig .le. maxrepconf)
     -              print *,'Chain break at residue',nres,
     -              ' no H generated'
                end if
              else
                if (nconfig .le. maxrepconf)
     -            print *,'Could not generate H for residue',ireso
              end if
            end if
            if (icfound .eq. 1) then
              iccprevf=1
              if (nres .gt. 1 .and. ixn(nres) .gt. 0) then
                if (dist2(ccprev,c(1,ixn(nres))) .gt. 4.0) then
                  ihbneig(nres-1)=-1
                  if (nconfig .le. maxrepconf)
     -              print *,'Chain break between residues',nres-1,
     -                ' and',nres
                end if
              end if
              call trnsfr(ccprev,c(1,ixc(nres)),3)
            else
              iccprevf=0
              call zeroit(ccprev,3)
            end if
            if (iok .eq. 1) then
              nresok=nresok+1
              ihbneig(nres)=0
            else
              ihbneig(nres)=-1
            end if
          end if
          ireso=iresn
          icfound=0
          iofound=0
          infound=0
          ihfound=0
          iafound=0
        end if
c       write (77,*) 'ia,ireso,nres=',ia,ireso,nres
      end do
      if (nresok .eq. 0) then
        print *,'ERROR: No residues containing C, O and N were found'
        ifail=1
        return
      end if
c      do i=1,nres
c        write (77,1144) i,'CA:',line(index(ixa(i)))(1:80)
c        write (77,1144) i,'C :',line(index(ixc(i)))(1:80)
c        write (77,1144) i,'N :',line(index(ixn(i)))(1:80)
c        write (77,1144) i,'O :',line(index(ixo(i)))(1:80)
c        dd=dist2(ch(1,i),c(1,ixn(i)))
c        ddco=dist2(c(1,ixc(i)),c(1,ixo(i)))
c        ddcn=dist2(c(1,ixc(i)),c(1,ixn(i)))
c        write (77,*) 'dCO=',sqrt(ddco),' dCN=',sqrt(ddcn)
c        write (77,1133) i,sqrt(dd),(ch(k,i),k=1,3)
c1133    format(i5,' d(N-H)=',f10.5,' ch=',3f10.5)
c1144    format(i6,1x,a,1x,a)
c1145    format(i6,1x,a,1x,3f10.5)
c      end do
      threshold=-0.5/(0.42*0.20*332.0)
      do ir=1,nres
        enghb(ir)=threshold+1.0e-5
        dssplab(ir)=' '
        if (ixc(ir) .gt. 0) then
          call trnsfr(cres(1,ir),c(1,ixc(ir)),3)
        else
          call zeroit(cres(1,ir),3)
        end if
      end do
      rchb=9.2
      call nnlistsim(1,nres,cres,nneig,ineig,indices,nbox,
     -  rchb,ifail,maxng,nnlistlen,maxbox,listlen,0)
      if (ifail .gt. 0) then
        print *,'Linked-cell routine failed'
        do ir=1,nres
          if (ihbneig(ir) .ge. 0) then
            do jr=ir+3,nres
              if (ihbneig(jr) .ge. 0) then
                if (dist2(c(1,ixc(ir)),c(1,ixc(jr))) .lt. rchb**2) then
                  eij=1.0/sqrt(dist2(c(1,ixo(ir)),c(1,ixn(jr))))+
     -              1.0/sqrt(dist2(c(1,ixc(ir)),ch(1,jr)))-
     -              1.0/sqrt(dist2(c(1,ixo(ir)),ch(1,jr)))-
     -              1.0/sqrt(dist2(c(1,ixc(ir)),c(1,ixn(jr))))
                  eji=1.0/sqrt(dist2(c(1,ixo(jr)),c(1,ixn(ir))))+
     -              1.0/sqrt(dist2(c(1,ixc(jr)),ch(1,ir)))-
     -              1.0/sqrt(dist2(c(1,ixo(jr)),ch(1,ir)))-
     -              1.0/sqrt(dist2(c(1,ixc(jr)),c(1,ixn(ir))))
c                if (eij .lt. threshold .or. eji .lt. threshold)
c     -            write (77,1156) ir,jr,eij*(0.42*0.20*332.0),
c     -              eji*(0.42*0.20*332.0)
c1156            format(' ir,jr=',2i5,' eij,eji=',2f10.5)
                  if (eij .lt. enghb(ir)) then
                    if (enghb(ir) .eq. 0.0) write (6,1157) ir,jr,
     -                ihbneig(ir),enghb(ir),eij
                    ihbneig(ir)=jr
                    enghb(ir)=eij
                  end if
                  if (eji .lt. enghb(jr)) then
                    if (enghb(jr) .eq. 0.0) write (6,1157) jr,ir,
     -                ihbneig(jr),enghb(ir),eji
                    ihbneig(jr)=ir
                    enghb(jr)=eji
                  end if
                end if
              end if
            end do
          end if
        end do
      else
        do ir=1,nres
          if (ihbneig(ir) .ge. 0) then
            do jjr=1,nneig(ir)
              jr=ineig(jjr,ir)
              if (ihbneig(jr) .ge. 0 .and. jr .gt. ir+2) then
                if (dist2(c(1,ixc(ir)),c(1,ixc(jr))) .lt. rchb**2) then
                  eij=1.0/sqrt(dist2(c(1,ixo(ir)),c(1,ixn(jr))))+
     -              1.0/sqrt(dist2(c(1,ixc(ir)),ch(1,jr)))-
     -              1.0/sqrt(dist2(c(1,ixo(ir)),ch(1,jr)))-
     -              1.0/sqrt(dist2(c(1,ixc(ir)),c(1,ixn(jr))))
                  eji=1.0/sqrt(dist2(c(1,ixo(jr)),c(1,ixn(ir))))+
     -              1.0/sqrt(dist2(c(1,ixc(jr)),ch(1,ir)))-
     -              1.0/sqrt(dist2(c(1,ixo(jr)),ch(1,ir)))-
     -              1.0/sqrt(dist2(c(1,ixc(jr)),c(1,ixn(ir))))
c                  if (eij .lt. threshold .or. eji .lt. threshold)
c                  if (ir .lt. 999)
c     -              write (77,1155) ir,jr,eij,eji,threshold
c1155              format(' ir,jr=',2i5,' eij,eji=',2f10.5,' tr=',f10.5)
                  if (eij .lt. enghb(ir)) then
                    if (enghb(ir) .eq. 0.0) write (6,1157) ir,jr,
     -                ihbneig(ir),enghb(ir),eij
                    ihbneig(ir)=jr
                    enghb(ir)=eij
                  end if
                  if (eji .lt. enghb(jr)) then
                    if (enghb(jr) .eq. 0.0) write (6,1157) jr,ir,
     -                ihbneig(jr),enghb(ir),eji
                    ihbneig(jr)=ir
                    enghb(jr)=eji
                  end if
c                  if (ir .lt. 999) write (77,1154) ir,ihbneig(ir),
c     -              enghb(ir),jr,ihbneig(jr),enghb(jr)
c1154              format(' ir,ihbneig(ir),enghb(ir)=',2i5,f10.5,
c     -              ' jr,ihbneig(jr),enghb(jr)=',2i5,f10.5)
                end if
              end if
            end do
          end if
        end do
      end if
c     A hydrogen bond exist from C=O(i) to NH(ihbneig(i))
      nss=0
      call zeroiti(iparal,0,nres)
      call zeroiti(iantiparal,0,nres)
      ir=1
      do while (ir .lt. nres)
c       Look for the next SS element
        do while (ir .lt. nres .and. ihbneig(ir) .le. 0)
          ir=ir+1
        end do
        nhbinc=ihbneig(ir)-ir
        irf=ir
        nss0=nss
c       write (77,*) 'Start check ir=',ir,' nhbinc=',nhbinc
        if (nhbinc .gt. 2 .and. nhbinc .le. 5) then
c         Possible helix start
          ihfound=1
          nstep=1
          ir=ir+1
          do while (ihfound .eq. 1)
            nhbinc1=ihbneig(ir)-(ir)
            nhbinc2=ihbneig(ir+1)-(ir+1)
            nhbinc3=ihbneig(ir+2)-(ir+2)
            if (nhbinc1 .ne. nhbinc) then
              if (nhbinc2 .ne. nhbinc) then
                if (nhbinc1 .eq. nhbinc2) then
                  ihfound=0
                else if (nhbinc3 .ne. nhbinc) then
                  ihfound=0
                end if
              end if
            end if
c           write (77,6622) ir,nhbinc1,nhbinc2,nhbinc3,ihfound
c6622       format(' ir=',i4,' dihn1,2,3=',3i3,' ifhound=',i2)
            if (ihfound .eq. 1) then
              nstep=nstep+1
              irprev=ir
              ir=ir+1
            end if
          end do
          if (ir-irf .gt. 1) then
            nss=nss+1
            ifss(nss)=irf
            ilss(nss)=ir+nhbinc-1
            itypss(nss)=nhbinc+3
c           write (06,*) 'Helix nss,ifss,ilss,itypss=',nss,ifss(nss),
c    -        ilss(nss),itypss(nss)
          else
            ir=ir-1
          end if
        else if (nhbinc .eq. -3) then
c         Possible Lambda helix
          ihfound=1
          nstep=1
          ir=ir+1
          do while (ihfound .eq. 1)
            nhbinc1=ihbneig(ir)-(ir)
            if (nhbinc1 .ne. nhbinc) then
              ihfound=0
            end if
c           write (77,6622) ir,nhbinc1,nhbinc2,nhbinc3,ihfound
c6622       format(' ir=',i4,' dihn1,2,3=',3i3,' ifhound=',i2)
            if (ihfound .eq. 1) then
              nstep=nstep+1
              irprev=ir
              ir=ir+1
            end if
          end do
          if (ir-irf .gt. 1) then
            nss=nss+1
            ifss(nss)=irf
            ilss(nss)=ir+nhbinc-1
            itypss(nss)=9
c           write (77,*) 'L Helix nss,ifss,ilss,itypss=',nss,ifss(nss),
          end if
        else if (ihbneig(ir) .gt. 0) then
c         Possible sheet
          isfound=1
          isfirst=0
          islast=0
          npar=0
          napar=0
          ineigmax=0
          ineigmin=nres
          ifs=-1
          do while (isfound .eq. 1)
            jr=ihbneig(ir)
c           write (77,*) 'Sheet? ir,jr,ihbneig(jr)=',ir,jr,ihbneig(jr)
            if (jr .gt. 0) then
              if (ihbneig(jr) .eq. ir) then
c               HB(i,j) = HB(j,i) => Antiparallel
                iantiparal(ir)=1
                ing=jr
                ifs=ir-1
                ils=ir+1
c               write (77,*) 'A1 ir=',ir
              end if
            end if
            if (jr .gt. 2) then
              if (ihbneig(jr-2) .gt. 0) then
                if (ihbneig(jr-2) .eq. ir) then
c                 HB(j-1,i)=HB(i,j+1) => Parallel
                  iparal(ir)=1
                  ing=jr
                  ifs=ir
                  ils=ir+2
c                 write (77,*) 'P2 ir=',ir
                end if
              end if
            end if
            if (ir .gt. 1 .and. ir .lt. nres) then
              jrm=ihbneig(ir-1)
              if (jrm .gt. 0) then
                if (ihbneig(jrm) .eq. ir+1) then
c                 HB(i-1,j)=HB(j,i+1) => Parallel
                  iparal(ir)=1
                  ing=jrm
                  ifs=ir
                  ils=ir+2
c                 write (77,*) 'P1 ir=',ir
                end if
              end if
            else
              jrm=0
            end if
            if (jrm .gt. 2) then
              if (ihbneig(jrm-2) .gt. 0) then
                if (ihbneig(jrm-2) .eq. ir+1) then
c                 HB(i-1,j+1)=HB(j-1,i+1) => Antiparallel
                  iantiparal(ir)=1
                  ing=jrm
                  ifs=ir
                  ils=ir+2
c                 write (77,*) 'A2 ir=',ir
                end if
              end if
            end if
            if (iparal(ir)+iantiparal(ir) .gt. 0) then
              if (isfirst .eq. 0) isfirst=ifs
              if (ineigmin .gt. ing) ineigmin=ing
              if (ineigmax .lt. ing) ineigmax=ing
            else if (ir .eq. 1) then
              isfound=0
            else if (ir .gt. 1) then
              if (iparal(ir-1)+iantiparal(ir-1) .eq. 0) then
                isfound=0
                islast=ils
              end if
            end if
            npar=npar+iparal(ir)
            napar=napar+iantiparal(ir)
            ir=ir+1
c           write (77,*)'End do isfound,ir=',isfound,ir
          end do
c         write (77,*)'islast,isfirst,npar,napar,ineigmin,max=',
c    -       islast,isfirst,npar,napar,ineigmin,ineigmax
          if (islast-isfirst .gt. 2 .and. isfirst .gt. 0) then
            nss=nss+1
            ifss(nss)=isfirst
            ilss(nss)=islast
            if (npar*napar .gt. 0) then
              itypss(nss)=3
            else if (npar .gt. 0)  then
              itypss(nss)=1
              if (ineigmax-ineigmin .gt. (islast-isfirst)*2)
     -          itypss(nss)=4
            else if (napar .gt. 0)  then
              itypss(nss)=2
              if (ineigmax-ineigmin .gt. (islast-isfirst)*2)
     -          itypss(nss)=5
            end if
c           write (77,*) 'Sheet nss,ifss,ilss,itypss=',nss,ifss(nss),
c    -        ilss(nss),itypss(nss)
          end if
        end if
        if (nss .eq. maxss) then
          write (6,1002) maxss
          if (iwdssp .gt. 0) write (iwdssp,1002) maxss
          ir=nres
        else if (nss .eq. nss0) then
c         Neither helix nor sheet - just skip over
c         do while (ir .lt. nres .and. ihbneig(ir) .ne. 0)
            ir=ir+1
c         end do
        else
          if (nss .gt. 1) then
            if (ilss(nss-1) .ge. ifss(nss)) ifss(nss)=ilss(nss-1)+1
          else
            if (ifss(1) .lt. 1) ifss(1)=1
          end if
          ir=ir+1
        end if
      end do
      do iss=1,nss
c        write (77,1001) iss,ifss(iss),ilss(iss),itypss(iss)
c1001    format(' SS',i4,' Start at',i4,' End at',i4,' Type=',i2)
        do ir=ifss(iss),ilss(iss)
          dssplab(ir)=typc(itypss(iss))
          idistdssp(itypss(iss),ir)=idistdssp(itypss(iss),ir)+1
        end do
      end do
      if (iwdssp .gt. 0) then
        if (nconfig .le. 1) then
          if (nss .gt. 0) then
            write (iwdssp,2005) (i,ifss(i),ilss(i),
     -        ssname(itypss(i))(1:lssname(itypss(i))),i=1,nss)
            write (6,2005) (i,ifss(i),ilss(i),
     -        ssname(itypss(i))(1:lssname(itypss(i))),i=1,nss)
          else
            write (iwdssp,2006) 
            write (6,2006) 
          end if
        end if
        if (iwhead .eq. 1)
     -     write (iwdssp,2004) (typc(i),ssname(i)(1:lssname(i)),i=1,9)
        iresf=1
        do while (iresf .le. nres)
          iresl=min0(nres,iresf+49)
          do ic=1,50
            charl1(ic)=' '
            charl2(ic)=' '
          end do
          do ir=max0(3,iresf),min0(iresl,nres-2)
            if (ixa(ir-2)*ixa(ir)*ixa(ir+2) .ne. 0) then
              call angles(dist2(c(1,ixa(ir-2)),c(1,ixa(ir))),
     -          dist2(c(1,ixa(ir+2)),c(1,ixa(ir))),
     -          dist2(c(1,ixa(ir-2)),c(1,ixa(ir+2))),ca1,ca2,cbend)
              cosa=dble(cbend)
              bend=180.0-dacoscheck(cosa,ccc,1,6,'DSSP')*radtodeg
c             write (77,*) ir,' bend=',bend
              if (bend .gt. 70.0) charl1(ir-iresf+1)='S'
            else
              charl1(ir-iresf+1)='?'
            end if
          end do
          do ir=max0(2,iresf),min0(iresl,nres-2)
            if (ixa(ir-1)*ixa(ir)*ixa(ir+1)*ixa(ir+2) .ne. 0) then
              tors=dihangl(c,ixa(ir-1),ixa(ir),ixa(ir+1),ixa(ir+2),0,n)
c             write (77,*) ir,' tors=',tors*radtodeg
              if (tors .ge. 0.0) then
                charl2(ir-iresf+1)='+'
              else
                charl2(ir-iresf+1)='-'
              end if
            else
              charl2(ir-iresf+1)='?'
            end if
          end do
          write (iwdssp,2000) iresf,iresl,(mod(i,10),i=iresf,iresl)
          write (iwdssp,2001) (mod(ihbneig(i)/1000,10),i=iresf,iresl)
          write (iwdssp,2001) (mod(ihbneig(i)/100,10),i=iresf,iresl)
          write (iwdssp,2001) (mod(ihbneig(i)/10,10),i=iresf,iresl)
          write (iwdssp,2001) (mod(ihbneig(i),10),i=iresf,iresl)
          write (iwdssp,2002) (charl1(i-iresf+1),i=iresf,iresl)
          write (iwdssp,2002) (charl2(i-iresf+1),i=iresf,iresl)
          write (iwdssp,2002) (dssplab(i),i=iresf,iresl)
          iresf=iresl+1
        end do
      end if
      if (iwrose .gt. 0) then
c       Tentative alternative for turn detection (see Rose's 1977 paper)
        write (iwrose,*) 'Data for turn detection with GW Rose method'
        call normplane(c(1,ixa(1)),c(1,ixa(3)),c(1,ixa(5)),rnprev)
        call normplane(c(1,ixa(2)),c(1,ixa(3)),c(1,ixa(4)),rn1prev)
        do ir=4,nres-2
          call radcirc(c(1,ixa(ir-2)),c(1,ixa(ir)),c(1,ixa(ir+2)),r)
          call normplane(c(1,ixa(ir-2)),c(1,ixa(ir)),c(1,ixa(ir+2)),rn)
          rnn=scprod(rn,rnprev)
          call normplane(c(1,ixa(ir-1)),c(1,ixa(ir)),c(1,ixa(ir+1)),rn1)
          rnn1=scprod(rn1,rn1prev)
          call angles(dist2(c(1,ixa(ir-2)),c(1,ixa(ir))),
     -      dist2(c(1,ixa(ir+2)),c(1,ixa(ir))),
     -      dist2(c(1,ixa(ir-2)),c(1,ixa(ir+2))),ca1,ca2,cbend)
          cosa=dble(cbend)
          bend=180.0-dacoscheck(cosa,ccc,1,6,'DSSP')*radtodeg
          charl1(1)=' '
          if (bend .gt. 70.0) charl1(1)='S'
          write (iwrose,2003) ir,charl1(1),dssplab(ir),r,rnn,rnn1
          call trnsfr(rnprev,rn,3)
          call trnsfr(rn1prev,rn1,3)
        end do
      end if
      return
999   write (6,1000) ia,line
      if (iwdssp .gt. 0) write (iwdssp,1000) ia,line
      return
1000  format(' ERROR: invalid residue number for atom ',i6,':',/,a)
1002  format(' ERROR: maximum number of secondary structure elements (',
     -  i3,') has been reached',/,' - redimension the program ')
1157  format(' eHB update ',i4,' to ',i4,' eold=',f6.2,' old partner=',
     -  i4,' enew=',f6.2)
2000  format(/,i6,'-',i5,': ',50i1)
2001  format(14x,50i1)
2002  format(14x,50a1)
2003  format(i5,' DSSP labels:',a1,1x,a1,' rc=',f8.3,
     -  ' rn.rnprv(2)=',f8.4,' rn.rnprv(1)=',f8.4)
2004  format(/' line 1: residue number (mod 10)',/,
     -  ' lines 2-5: the digits of the residue number to which the ',/,
     -  12x,'residue number of line 1 is H-bonded (if any)',/,
     -  ' line 6: S for residues with bend angle ',
     -  '(CA(ir-2)-CA(ir)-CA(ir+2)) > 70 deg',/,
     -  ' line 7: + or -, the sign of the ',
     -  '(CA(ir-1)-CA(ir)-CA(ir+1)-CA(ir+2)) angle',/,
     -  ' line 8: secondary structure element type:',/,
     -  9(9x,a1,': ',a))
2005  format(/,(' SS#',i3,' Residue index range: [',i5,',',i5,'] Type:',
     -  a))
2006  format(' No secondary structure element was found')
      end
      subroutine gethxlims(ires1,ires2,nslt,numres,iresno,ires11,ires22,
     -  iadssp1,iadssp2,maxrec)
      dimension iresno(maxrec)
      ires11=max0(1,ires1-5)
      ires22=min0(numres,ires2+5)
c     print *,'ires1,ires2,ires11,ires22,nslt=',
c    -  ires1,ires2,ires11,ires22,nslt
      iadssp1=1
      do while (iadssp1 .lt. nslt .and.
     -  iresno(iadssp1) .lt. ires11)
        iadssp1=iadssp1+1
      end do
      iadssp2=iadssp1
      do while (iadssp2 .lt. nslt .and.
     -  iresno(iadssp2) .le. ires22)
        iadssp2=iadssp2+1
      end do
      iadssp2=iadssp2-1
c     print *,'call DSSP iadssp1,iadssp2=',iadssp1,iadssp2
      return
      end
      subroutine checkforhelix(ires1,ires2,ires11,dssplab,indexn,iw,
     -  hxoklab,ihxok,lab,llab,maxrsd,maxrec)
      dimension indexn(maxrec)
      character*1 dssplab(maxrsd)
      character*6 hxoklab(3)
      character*(*) lab
      ihxok=1
      nhxres=ires2-ires1+1
      iresinc=ires1-ires11
      do ir=1,nhxres
        indexn(ir)=1
        iri=ir+iresinc
        if (dssplab(iri) .ne. 'G' .and. dssplab(iri) .ne. 'H'
     -    .and. dssplab(iri) .ne. 'I' .and.
     -     dssplab(ir) .ne. 'L') indexn(ir)=0
        if (dssplab(iri) .eq. ' ') dssplab(iri)='?'
      end do
      if (indexn(1) .eq. 0 .or. indexn(nhxres) .eq. 0) then
        ihxok=3
      else
        do ir=2,nhxres-1
          if (indexn(ir) .eq. 0) ihxok=2
        end do
      end if
      write (iw,2088) lab(1:llab),hxoklab(ihxok),
     -  (dssplab(ir+iresinc),ir=1,nhxres)
      return
2088  format(a,' is ',a,': ',(60a1))
      end
      subroutine getlist(list,len,minval,maxval,nlist,maxlen)
      dimension list(nlist,maxlen)
      common /logging/ logfile,ipredict
      character*200 outfiletmp
      character*80 listprompt
      character*80 line
c     Get a list of integers (nlist=1) or a pair of integers (nlist=2)
c     from a file or from the terminal
      namlenl=-1
      listinp=55
      listprev=-999999
      iallpair=0
      irangeinp=0
      write (6,1006) ' '
      if (nlist .eq. 1) then
        write (6,1006) ' in increasing order'
      else
        call askyn(
     -    'Do you want to input just one number per line',
     -    45,1,-1,iallpair,99)
         if (iallpair .eq. 0) write (6,1006) ' one pair per line'
         if (iallpair .eq. 1) write (6,1006) ' one per line'
      end if
      call openfile(listinp,1,'list',4,'old',outfiletmp,namlenl,
     -  notfnd,0,1,1,0,0)
      if (namlenl .eq. 0) then
        listinp=5
        if (nlist .eq. 1) write (6,1002)
      end if
      maxvalchk=maxval
      if (maxval .eq. 999999) maxvalchk=0
      len=0
      if (nlist .eq. 1 .and. listinp .ne. 5) then
        call readfreelist(list,len,listinp,1,maxlen)
        go to 8
      else if (nlist .eq. 1) then
c       Input list interactively
100     do while (.true.)
          call blankout(line,1,80)
          call getname(line,lline,'0/r/#:',6,80,0)
          if (lline .eq. 0) go to 999
          if (line(1:1) .eq. 'r' .or. line(1:1) .eq. 'R') then
c           Input a range
            irangeinp=1
            call getrange(ifst,999999,ilst,999999,increment,1,'number',
     -        6,maxvalchk,0)
            if (ifst .le. listprev) then
              print *,'Ignoring this range - list has to be in ',
     -          'increasing order'
              ndrop=1
            else
              do ics=ifst,ilst,increment
                len=len+1
                list(1,len)=ics
              end do
              listprev=list(1,len)
              if (list(1,len) .ne. ilst) then
                write (6,1005) list(1,len),ilst
              end if
            end if
          else
            read (line,*,err=99,end=8) ics
            if (ics .eq. 0) then
              list(1,len+1)=0
              go to 8
            else
              len=len+1
              list(1,len)=ics
            end if
          end if
          ndrop=0
          if (ics .le. listprev) then
            print *,'Ignoring',ics,' - sorry, list has to be in ',
     -        'increasing order'
            print *,'LISTPREV=',listprev
            len=len-1
            ndrop=1
          end if
          if (ndrop .eq. 0) then
            if (len .eq. maxlen) then
              print *,'List truncated at the',maxlen,'-th element ',
     -         '- redimension Simulaid for longer list'
              go to 8
            end if
c           if (irangeinp .eq. 1) then
c             len=len+1
c             list(1,len)=ics
c             listprev=ics
c           end if
          end if
          listprev=list(1,len)
          irangeinp=0
        end do
99      print *,'Invalid input - ignored'
        go to 100
      else if (iallpair .eq. 0) then
c       Input pair list
200     do while (.true.)
          call blankout(line,1,80)
          if (listinp .eq. 5) then
            write (listprompt,1008) 'pair'
            call getname(line,lline,listprompt,28,80,0)
          else
            read (listinp,1004,end=999) line
          end if
          read (line,*,err=88) i1
          if (i1 .eq. 0) go to 8
          len=len+1
          read (line,*,err=88) (list(k,len),k=1,2)
          if (maxvalchk .gt. 0) then
            do k=1,2
              if (list(k,len) .gt. maxval .or.
     -            list(k,len) .lt. minval) then
                write (6,1010) list(k,len),minval,maxval
                len=len-1
                go to 200
              end if
            end do
          end if
          if (len .eq. maxlen) then
            print *,'List truncated at the',maxlen,'-th element ',
     -       '- redimension Simulaid for longer list'
            go to 8
          end if
        end do
88      print *,'Invalid input - ignored'
        go to 200
      else
c       Create pair list from input list
300     do while (.true.)
          if (listinp .eq. 5) write (6,1008) 'element'
          call blankout(line,1,80)
          if (listinp .eq. 5) then
            write (listprompt,1008) 'element'
            call getname(line,lline,listprompt,31,80,0)
          else
            read (listinp,1004,end=999) line
          end if
          read (line,*,err=77) i1
          if (maxvalchk .gt. 0 .and.
     -        (i1 .gt. maxval .or. i1 .lt. minval)) then
            write (6,1010) i1,minval,maxval
            go to 300
          end if
          if (i1 .eq. 0) go to 777
          len=len+1
          list(1,len)=i1
          if (len*(len-1)/2 .eq. maxlen) then
            print *,'List truncated at the',maxlen,'-th element ',
     -       '- redimension Simulaid for longer list'
            go to 777
          end if
        end do
77      print *,'Invalid input - ignored'
        go to 300
c       Now make the pairs
777     lenpair=0
        do i=1,len-1
          list(2,i)=list(1,len)
        end do
        lenrest=len-1
        lenpair=lenrest
        do while (lenrest .gt. 1)
          do i=1,lenrest-1
            lenpair=lenpair+1
            list(1,lenpair)=list(1,i)
            list(2,lenpair)=list(1,lenrest)
          end do
          lenrest=lenrest-1
        end do
        if (lenpair .ne. len*(len-1)/2)
     -    print *,'PROGRAM ERROR: len=',len,' lenpair=',lenpair
        len=lenpair
        go to 8
      end if
999   write (6,1007) line
      list(1,len+1)=0
8     if (listinp .ne. 5) close(listinp)
      if (len .lt. 100) write (6,1000) ((list(k,i),k=1,nlist),i=1,len)
      write (6,1009) len
      return
1000  format(' The list read:',/,(10i8))
1002  format(' Type 0 to finish the list',/,
     -  ' Type a number to be added to the list',/,
     -  ' Type R or r to be able to enter a range')
1004  format(a)
1005  format(' WARNING: Last number added to the list=',i6,
     -  ' (instead of ',i6,')')
1006  format(' List file is a free-formatted list of sequence numbers',
     -  /,a,/,' Hit return to input list interactively')
1007  format(' Premature end of the list file - last record read=',/,a)
1008  format(' Next ',a,' (or 0 to finish): ',$)
1009  format(' Finished reading',i6,' list items')
1010  format(' ERROR: List element ',i8,' is outside the alllowed ',
     -  'range [',i6,',',i8,']')
      end
      subroutine readfreelist(list,len,inp,isort,maxlen)
      dimension list(maxlen)
      character*80 line
      len=0
      ic=0
      lc=0
      iprev=0
      nerr=0
      do while (.true.)
        if (ic .ge. lc) then
          call blankout(line,1,80)
          read (inp,1000,end=999) line
          call lastchar(line,lc,80)
          if (lc .eq. 0) return
          ic=1
        end if
        call nextstring(line,ic,ic1,ic2,80)
        ic=ic2+1
        iok=0
        read (line(ic1:ic2),*,err=777) i
        iok=1
        len=len+1
        if (len .gt. maxlen) then
          write (6,1001) maxlen
          return
        end if
        if (isort .eq. 1) then
          if (len .eq. 1 .or. i .gt. iprev) then
            list(len)=i
          else
            write (6,1002) i,iprev
            len=len-1
          end if
          iprev=i
        else
          list(len)=i
        end if
777     if (iok .eq. 0) then
          print *,'ERROR: Invalid list element:',line(ic1:ic2),
     -      ' ignored'
          nerr=nerr+1
          if (nerr .gt. 2*maxlen) then
            print *,'Too many invalid elements - stopping; iuinp=',inp
            stop
          end if
        end if
      end do
999   return
1000  format(a)
1001  format(' ERROR: list length exceeds',i6,' - redimension Simulaid')
1002  format(' ERROR: list element (',i6,') is not greater than the ',
     -  'previous value (',i6,')')
      end
      subroutine getclusterpairs(npairs,iclustermem,ifstclst1,ifstclst2,
     -  ilstclst2,nslt,idebug,maxpairs,maxclustermem)
      dimension iclustermem(maxclustermem),ifstclst1(maxpairs),
     -  ifstclst2(maxpairs),ilstclst2(maxpairs)
      character*39 pairprompt
      character*80 line
      character*200 outfiletmp
c     print *,'GETCLUSTERPAIRS idebug,maxpairs,maxclustermem=',
c    -  idebug,maxpairs,maxclustermem
      listinp=55
      npairread=0
      namlenl=-1
      print *,
     -  '     Hit enter to input the cluster member list interactively'
      call openfile(listinp,1,'cluster member list',19,'old',outfiletmp,
     -  namlenl,notfnd,0,1,1,0,0)
      if (namlenl .eq. 0) then
        listinp=5
        if (npairread .eq. 0) write (6,1002)
      end if
      iread=0
      np1=-1
      do while (np1 .ne. 0)
100     if (listinp .eq. 5) then
          write (pairprompt,1000) npairread+1,1
          call getint(pairprompt,39,0,1,maxclustermem,np1,0)
        else
          read (listinp,*,err=100,end=999) np1
        end if
        if (np1 .eq. 0) go to 999
101     if (listinp .eq. 5) then
          call getname(line,lline,'Members (comma-separated):',26,80,0)
          read (line(1:lline),*,err=101,end=101)
     -     (iclustermem(iread+i),i=1,np1)
        else
          read (listinp,*,err=101,end=888)
     -      (iclustermem(iread+i),i=1,np1)
        end if
        ifstclst1(npairread+1)=iread+1
        iread=iread+np1
        ifstclst2(npairread+1)=iread+1
102     if (listinp .eq. 5) then
          write (pairprompt,1000) npairread+1,2
          call getint(pairprompt,39,1,1,maxclustermem,np2,0)
        else
          read (listinp,*,err=102,end=999) np2
        end if
103     if (listinp .eq. 5) then
          call getname(line,lline,'Members (comma-separated):',26,80,0)
          read (line(1:lline),*,err=103,end=103)
     -      (iclustermem(iread+i),i=1,np2)
        else
          read (listinp,*,err=103,end=888)
     -      (iclustermem(iread+i),i=1,np2)
        end if
        iread=iread+np2
        ilstclst2(npairread+1)=iread
        npairread=npairread+1
      end do
999   do ip=1,npairread
        if (idebug .gt. 0) then
          write (6,1003) ip,1,ifstclst2(ip)-ifstclst1(ip),
     -      (iclustermem(i),i=ifstclst1(ip),ifstclst2(ip)-1)
          write (6,1003) ip,2,ifstclst2(ip)-ifstclst2(ip)+1,
     -      (iclustermem(i),i=ifstclst2(ip),ilstclst2(ip))
        end if
        do i=ifstclst1(ip),ifstclst2(ip)-1
          if (iclustermem(i) .lt. 1 .or.  iclustermem(i) .gt. nslt) then
            write (6,1004) ip,1,iclustermem(i),nslt
          end if
        end do
        do i=ifstclst2(ip),ilstclst2(ip)
          if (iclustermem(i) .lt. 1 .or.  iclustermem(i) .gt. nslt) then
            write (6,1004) ip,2,iclustermem(i),nslt
          end if
        end do
      end do
      npairs=npairread
      return
888   print *,'ERROR: invalid list for cluster',ic12,
     -  ' pair #',npairread+1
      return
1000  format('Pair ',i3,' number of members in cluster',i2)
1002  format(' Type 0 to finish the list')
1003  format(' Pair',i3,' cluster',i2,':',(10i5))
1004  format(' ERROR: pair',i3,', cluster',i2,' member (',i6,
     -  ') is outside the',' range [1,',i6,']')
      end
      subroutine getname(name,len,label,lablen,maxlen,ihelp)
      character*(*) name,label
      character*1 promptchar
      character*80 prompt
      character*200 line
      common /logging/ logfile,ipredict
      prompt(1:lablen)=label(1:lablen)
      llen=lablen
      promptchar='='
      if (label(lablen:lablen) .eq. ':') then
        promptchar=' '
      end if
      if (ihelp .gt. 0) then
        prompt(llen+1:llen+4)=' [?]'
        llen=llen+4
      end if
      llen=llen+1
      prompt(llen:llen)=promptchar
100   write (6,1000) prompt(1:llen)
      call blankout(line,1,200)
      read (5,1001) line
      ifc=1
      call nextchar(line,ifc,200)
      if (line(ifc:ifc) .eq. '?') then
        call explanation(ihelp)
        go to 100
      end if
      if (ifc .eq. 200) then
        len=0
        if (logfile .gt. 0) write (logfile,1001)
      else
        call lastchar(line,len,200)
        lenn=len-ifc+1
        if (lenn .gt. maxlen) then
          print *,'Name read (',line(ifc:len),') is longer than ',
     -      'allowed (',maxlen,')'
          lenn=maxlen
        end if
        name(1:lenn)=line(ifc:ifc+lenn-1)
        if (logfile .gt. 0) write (logfile,1001) line(1:len)
        len=lenn
      end if
      return
1000  format(1x,a,$)
1001  format(a)
      end
      subroutine getnamelist(list,lench,nlist,label,lablen,maxlen)
      character*(*) list(maxlen),label
      character*80 line
      character*200 outfiletmp
      common /logging/ logfile,ipredict
      nlist=0
      line(1:3)='***'
      write (6,1004) lench
      do while (line(1:3) .ne. 'XYZ' .and. line(1:3) .ne. '   ')
        write (6,1000) label(1:lablen),nlist+1
        call blankout(line,1,80)
        read (5,1001) line
        call lastchar(line,iclast,80)
        if (logfile .gt. 0) write (logfile,1001) line(1:iclast)
        if (line(1:4) .eq. 'READ') then
c         Switch to reading from a file
          listinp=55
          namlenl=-1
          call openfile(listinp,1,'name list',9,'old',outfiletmp,
     -      namlenl,notfnd,0,1,1,0,0)
          do while (.true.)
            call blankout(line,1,80)
            read (listinp,1001,end=99) line
            if (line(1:3) .eq. 'XYZ') go to 99
            call lastchar(line,iclast,80)
            if (iclast .gt. lench) write (6,1002) lench
            nlist=nlist+1
            call blankout(list(nlist),1,lench)
            list(nlist)(1:iclast)=line(1:iclast)
          end do
99        close (listinp)
          line(1:3)='XYZ'
        else
          if (iclast .gt. lench) write (6,1002) lench
        end if
        if (line(1:3) .ne. 'XYZ') then
          if (nlist .eq. maxlen) then
            write (6,1003) maxlen
            call askstop(0)
            return
          else
            nlist=nlist+1
            call blankout(list(nlist),1,lench)
            list(nlist)(1:iclast)=line(1:iclast)
          end if
        end if
      end do
      write (6,5655) (label(1:lablen),i,list(i)(1:lench),i=1,nlist)
5655  format(1x,a,' #',i4,':',a)
      return
1000  format(1x,a,' #',i3,' (XYZ or enter to end list)=',$)
1001  format(a)
1002  format(' WARNING: Only the first ',i2,' characters will be used')
1003  format(' WARNING: maximum number of list elements (',i4,') has ',
     -  'been reached - input stops')
1004  format(' Type READ as the residue name to read a list from a ',
     -  'file',/,' Names are of maximum ',i2,' characters')
      end
      subroutine listformat(igl,ityp)
      character*11 formatname
      common /formats/ iqdconv(19),formatname(17)
      common /columnlim/ incol(17),iidcol(17),iialtcol(17),
     -  iinamcol(2,17),iirescol(2,17),iiccol(2,17),iiresncol(2,17),
     -  iiseqncol(2,17),iisegcol(2,17),iiresidcol(2,17),iiqcol(2,17),
     -  iipotcol(2,17),iiocccol(2,17),iichemcol(2,17)
      character*1 ans
      if (ityp .eq. 0) then
        call quiz(ans,ians,'d',' ',0,'file format',11,0,5,6,igl,0)
        it=iqdconv(ians)
      else
        it=ityp
      end if
      write (6,1000) formatname(it)
      write (6,1002) incol(it)
      if (iinamcol(2,it) .ge. iinamcol(1,it))
     -   write (6,1001) 'atom name:           ',(iinamcol(k,it),k=1,2)
      if (iirescol(2,it) .ge. iirescol(1,it))
     -   write (6,1001) 'residue name:        ',(iirescol(k,it),k=1,2)
      if (iiseqncol(2,it) .ge. iiseqncol(1,it))
     -   write (6,1001) 'atom number:         ',(iiseqncol(k,it),k=1,2)
      if (iiresncol(2,it) .ge. iiresncol(1,it))
     -   write (6,1001) 'residue number:      ',(iiresncol(k,it),k=1,2)
      if (iisegcol(2,it) .ge. iisegcol(1,it))
     -   write (6,1001) 'segment (chain) ID:  ',(iisegcol(k,it),k=1,2)
      if (iiresidcol(2,it) .ge. iiresidcol(1,it))
     -   write (6,1001) 'residue ID (Charmm): ',(iiresidcol(k,it),k=1,2)
      if (iiccol(2,it) .ge. iiccol(1,it))
     -   write (6,1001) 'X,Y,Z coordinates:   ',(iiccol(k,it),k=1,2)
      if (iiqcol(2,it) .ge. iiqcol(1,it))
     -   write (6,1001) 'atomic charges:      ',(iiqcol(k,it),k=1,2)
      if (iipotcol(2,it) .ge. iipotcol(1,it))
     -   write (6,1001) 'potential identifier:',(iipotcol(k,it),k=1,2)
      if (iichemcol(2,it) .ge. iichemcol(1,it))
     -   write (6,1001) 'Chemical element:    ',(iichemcol(k,it),k=1,2)
      if (iialtcol(it) .gt. 0) write (6,1003) iialtcol(it)
      return
1000  format(' Record format specification for ',a,' input')
1001  format(' Column range for ',a,i3,' - ',i3)
1002  format(' Number of characters in a record:',11x,i3)
1003  format(' Alternate marker column:',20x,i3)
      end
      subroutine getcrdtyp(inpt,filex,lenfile,ifiltyp,ixcluster,igl)
      character*(*) filex
      character*5 crdext
      common /iotypes/ iocha,iochaex,iobpdb,iocpdb,ioa3pdb,ioa4pdb,
     -  iommod,iommc,iommc4,iogro,iomol2,iomae,ioins,ionxyz,
     -  iosxyz,iosxyzrq,iograsp,iofull,lext(17),crdext(17)
      character*11 formatname
      common /formats/ iqdconv(19),formatname(17)
      character*1 ans
      character*5 ext
      character*6 inoutlab
      character*132 line
      ifiltyp=0
      lenext=lenfile
      if (lenext .ge. 5) then
c       Extract extension
        ic=lenext
        do while (filex(ic:ic) .ne. '.' .and. ic .gt. max0(1,lenext-6))
          ic=ic-1
        end do
        lenext=lenext-ic
        if (lenext .le. 5) ext(1:lenext)=filex(ic+1:ic+lenext)
      else
        ext(1:lenext)=filex(1:lenext)
      end if
      if (ext(1:3) .ne. 'dat' .and. lenext .le. 5) then
        do it=1,ioins
          if (crdext(it)(1:lenext) .eq. ext(1:lenext) .and.
     -        lext(it) .eq. lenext) ifiltyp=it
        end do
      end if
      if (ext(1:5) .eq. 'pdbqs') then
        ifiltyp=ioa3pdb
      else if (ext(1:5) .eq. 'pdbqt') then
        ifiltyp=ioa4pdb
      else if (lenext .eq. 3 .and. (ext(1:3) .eq. 'pdb' .or.
     -    ext(1:3) .eq. 'PDB' .or. ext(1:3) .eq. 'ent')) then
c       Specify PDB type
        write (6,2000) 'PDB'
c       Check file for segid/chaind
        line(1:4)='    '
        do while (line(1:4) .ne. 'ATOM')
          read (inpt,1000,end=999) line
        end do
        rewind inpt
        ifiltyp=0
        if (line(22:22) .eq. ' ' .and. line(73:76) .ne. '    ') then
          write (6,2001) 'PDB','Charmm'
          ifiltyp=iocpdb
        else if (line(22:22) .ne. ' ' .and. line(73:76) .eq. '    ')then
          write (6,2001) 'PDB','Brookhaven'
          ifiltyp=iobpdb
        end if
        ians=0
        if (ifiltyp .gt. 0) call askyn('Is that OK',10,1,1,ians,00)
        if (ians .eq. 0) then
          call quiz(ans,ians,'b',' ',0,'PDB file type',13,0,5,6,igl,0)
          if (ans .eq. 'b') ifiltyp=iobpdb
          if (ans .eq. 'c') ifiltyp=iocpdb
        end if
      else if (ext(1:3) .eq. 'CRD') then
        write (6,2000) 'Charmm CRD'
c       Specify Charmm CRD type
        line (1:1)='*'
        do while (line(1:1) .eq. '*')
          read (inpt,1000,end=999) line
        end do
        read (inpt,1000) line
        call blankout(line,1,132)
        read (inpt,1000) line
        call lastchar(line,lc,132)
        rewind inpt
        if (lc .le. 80) then
          write (6,2001) 'Charmm','extended'
          ifiltyp=iocha
        else
          write (6,2001) 'Charmm','standdard'
          ifiltyp=iochaex
        end if
        call askyn('Is that OK',10,1,1,ians,00)
        if (ians .eq. 0) then
          call quiz(ans,ians,'o',' ',0,'Charmm CRD file type',20,0,5,6,
     -      igl,0)
          if (ans .eq. 'o') ifiltyp=iocha
          if (ans .eq. 'e') ifiltyp=iochaex
        end if
      else if (ext(1:3) .eq. 'slt') then
c       Specify MMC version
        ifiltyp=iommc
        call askyn('Is the .slt file in the old format',34,1,-1,is4,134)
        if (is4 .eq. 1) ifiltyp=iommc4
      else if (ext(1:3) .eq. 'rep') then
        write (6,2000) 'Macromodel/Xcluster'
        ifiltyp=iommod
        ixcluster=1
      end if
      if (ifiltyp .ne. 0) then
        write (6,2000) formatname(ifiltyp)
      else
        inoutlab=' input'
        if (ext(1:3) .eq. '   ') inoutlab='output'
100     call quiz(ans,ians,' ',inoutlab,6,'file format',11,0,5,6,igl,0)
        ifiltyp=iqdconv(ians)
        if (ans .eq. 'x') then
c         Macromodel/Xcluster
          ifiltyp=iommod
          ixcluster=1
        end if
        if (ifiltyp .eq. 0) then
          print *,'PROGRAM ERROR: invalid answer character'
          go to 100
        end if
      end if
      return
999   write (6,2002) filex(1:max0(1,lenfile))
      stop
1000  format(a)
2000  format(' The the input format is established as ',a)
2001  format(' The ',a,' format is found to be ',a)
2002  format(' ERROR: input file ',a,' does not have coordinate ',
     -  'records')
      end
      subroutine asktrajform(inptrajtyp,ioutrajtyp,mmctrajtyp,
     -  resnamslv,igl,inout,iasktrajtyp)
      character*8 resnamslv
      character*5 crdext
      common /iotypes/ iocha,iochaex,iobpdb,iocpdb,ioa3pdb,ioa4pdb,
     -  iommod,iommc,iommc4,iogro,iomol2,iomae,ioins,ionxyz,
     -  iosxyz,iosxyzrq,iograsp,iofull,lext(17),crdext(17)
      character*8 resnamsv
      common /names/ resnamsv(17)
      character*1 ansfrm
      character*6 inoutlab
      data itrajtyp /0/
      if (iasktrajtyp .eq. 1) then
        inoutlab='output'
        if (inout .eq. -1) inoutlab=' input'
        call quiz(ansfrm,ians,' ',inoutlab,6,'trajectory file format',
     -    22,0,5,6,igl,0)
        if (ansfrm .eq. 'c') then
          itrajtyp=1
        else if (ansfrm .eq. 'a') then
          itrajtyp=2
        else if (ansfrm .eq. 'l') then
          itrajtyp=3
        else if (ansfrm .eq. 'o') then
          itrajtyp=4
        else if (ansfrm .eq. 'x') then
          itrajtyp=5
        else if (ansfrm .eq. 'd') then
          itrajtyp=6
        end if
        if (inout .eq. +1) then
          ioutrajtyp=itrajtyp
        else
          inptrajtyp=itrajtyp
        end if
      end if
      if (itrajtyp .eq. 3 .or. iasktrajtyp .eq. 0) then
        call quiz(ansfrm,ians,' ',' ',0,'MMC trajectory file format',26,
     -    0,5,6,igl,0)
        if (ansfrm .eq. 'b') then
          mmctrajtyp=1
        else if (ansfrm .eq. 'a') then
            mmctrajtyp=2
        else if (ansfrm .eq. 'n') then
          mmctrajtyp=3
        else if (ansfrm .eq. 'p') then
          mmctrajtyp=4
          resnamslv=resnamsv(iobpdb)
        else if (ansfrm .eq. 'c') then
          mmctrajtyp=5
          resnamslv=resnamsv(iocha)
        end if
      end if
      return
      end
      subroutine writeconf(iout,inpcrdtyp,iotyp,inpcrdtyporg,n0,n,nslt,
     -  naslv,islvw,iasv,namesv,qsv,pflsv,icreaterec,iwhead,imodel,
     -  iatnum,ifchrg,nconfig,innlist,c,rprox,cv,ixres,iresno,atnames,
     -  resnames,segnames,charge,isegno,marker,ntitlin,ntitlinw,title,
     -  ireseq,iresnrestart,iresidrestart,nneig,nneiga,nhbneig,ineig,
     -  nhneig,nnneig,ncneig,nsneig,npneig,numres,numslv,resnamslv,line,
     -  blankline,mmtype,ibnd,index,indexn,indexo,iclean,molresflag,
     -  idupl,hblimfac,angmin,noleftad,nosort,noreg,iusecvforq,
     -  nobondord,nqdec,iqspaceask,ianaltyp,ifromtraj,etot,ietot,
     -  nclstmem,noend,keeprem,iwriteatsym,radtodeg,maxrepconf,maxng,
     -  maxrsd,maxrec)
      character* 132 line(maxrec),blankline
      character*80 title
      character*4 segnames(maxrsd),pflsv(100)
      character*8 atnames(maxrec),resnames(maxrsd),namesv(100)
      character*6 marker(16)
      dimension nneig(maxrec),ineig(maxng,maxrec),iatnum(maxrec),
     -  ifchrg(maxrec),c(3,maxrec),cv(maxrec),ixres(maxrec),
     -  rprox(maxrec),charge(maxrec),nhbneig(maxrec),nneiga(maxrec),
     -  nhneig(maxrec),nnneig(maxrec),ncneig(maxrec),nsneig(maxrec),
     -  npneig(maxrec),isegno(maxrec),iresno(maxrec),mmtype(maxrec),
     -  ibnd(maxng,maxrec),index(maxrec),indexn(maxrec),indexo(maxrec),
     -  molresflag(maxrsd),idupl(maxrsd),iasv(100),qsv(100)
      common /columnlim/ incol(17),iidcol(17),iialtcol(17),
     -  iinamcol(2,17),iirescol(2,17),iiccol(2,17),iiresncol(2,17),
     -  iiseqncol(2,17),iisegcol(2,17),iiresidcol(2,17),iiqcol(2,17),
     -  iipotcol(2,17),iiocccol(2,17),iichemcol(2,17)
      character*11 formatname
      common /formats/ iqdconv(19),formatname(17)
      character*5 crdext
      common /iotypes/ iocha,iochaex,iobpdb,iocpdb,ioa3pdb,ioa4pdb,
     -  iommod,iommc,iommc4,iogro,iomol2,iomae,ioins,ionxyz,
     -  iosxyz,iosxyzrq,iograsp,iofull,lext(17),crdext(17)
      character*2 iatnm2
      common /atnam/ aw(99),nval(99),nvalmax(99),mmofan(99),mmatno(64),
     -  iatnm2(99)
      character*1 abc,digits,hexdigits
      common /charactersets/ ihex(25),abc(62),digits(14),hexdigits(25)
      common /logging/ logfile,ipredict
      character*2 mmcgm
      character*4 segnam,chnam,xseg
      character*6 potnam
      character*8 resnam,resnamslv,atomnam
      character*8 segnamlong
      dimension iabc(62),cw(3)
      data xseg /'XXXX'/
c     print *,'WRITECONF nslt=',nslt,' n0,n=',n0,n,
c    -  ' iwriteatsym=',iwriteatsym
      mmcgm='  '
      call set_pdbinfo(iotyp,iwriteatsym,iwritecon,iobpdb,iocpdb,0)
      call setcol(inpcrdtyp,ncol,idcol,ialtcol,
     -  inamcol1,inamcol2,irescol1,irescol2,iccol1,iccol2,
     -  iresncol1,iresncol2,iseqncol1,iseqncol2,isegcol1,isegcol2,
     -  iresidcol1,iresidcol2,iqcol1,iqcol2,ipotcol1,ipotcol2,
     -  iocccol1,iocccol2,ichemcol1,ichemcol2,nrescol,nresncol,
     -  nsegcol,nnamcol,iofull)
      frocc=1.0
      if (iotyp .eq. iommod .and. nobondord .eq. 0) then
c       Macromodel
        call nnlist(nslt,islvw,naslv,n,iatnum,ifchrg,c,nneig,nneiga,
     -    nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,line,
     -    irescol1,irescol2,inamcol1,inamcol2,index,nconfig,innlist,
     -    molresflag,hblimfac,angmin,0,ibnd,indexo,isegno,ixres,
     -    maxrepconf,0,radtodeg,maxng,maxng,maxrsd,maxrec)
        call bondord(iatnum,mmtype,n,nneig,ineig,nhneig,ibnd,maxng,c,
     -    index,ncneig,nsneig,inamcol1,inamcol2,irescol1,irescol2,line,
     -    nconfig,maxrepconf,maxrec)
      end if
      if (inpcrdtyp .le. ioins .and. isegcol2 .ge. isegcol1) then
c       Get segment id name list
        nsegm=isegno(n)
        segnames(1)='    '
        call getseg4(segnames(1),line(index(1)),isegcol1,nsegcol)
c       segnames(1)(1:nsegcol)=line(index(1))(isegcol1:isegcol2)
        do ia=2,min0(n0,n)
c         write(77,*) 'nconfig=',nconfig,' ia=',ia,'isegno=',isegno(ia)
c         write(77,*) 'index=',index(ia)
          if (isegno(ia) .ne. isegno(ia-1)) then
            segnam='    '
            call getseg4(segnam,line(index(ia)),isegcol1,nsegcol)
c           segnam(1:nsegcol)=line(index(ia))(isegcol1:isegcol2)
            call leftadjust4(segnam,segnam)
            segnames(isegno(ia)-isegno(1)+1)=segnam
          end if
        end do
        if (n .gt. n0) then
          incsg=0
          if (n0 .eq. nslt) then
            segnames(isegno(n0)-isegno(1)+1)=xseg(1:min0(4,nsegcol))
            incsg=1
          end if
          do ia=n0+1,n
            isegno(ia)=isegno(n0)+incsg
          end do
        end if
        if (ischarmm(iotyp) .eq. 1 .or. iotyp .eq. iocpdb) then
          do is=1,nsegm
            segnam=segnames(is)
            if (nconfig .gt. 1) then
c             For Charmm output, change the segment ID when there is room
CHX
              do ic=1,4
                if (segnam(ic:ic) .eq. ' ') then
                  nslen=ic-1
                  go to 100
                end if
              end do
c             No blank, leave it
              go to 101
100           write (segnamlong,1006) nconfig
              call nextchar(segnamlong,ic,8)
              nnlen=min0(4-nslen,8-ic+1)
              segnam(nslen+1:nslen+nnlen)=segnamlong(ic:ic+nnlen-1)
101           continue
            else if (nsegcol .eq. 1) then
              segnam(2:4)='CHR'
            end if
            segnames(is)=segnam
          end do
        else if (iotyp .eq. iobpdb .and. nsegcol .gt. 1) then
c         Make sure new segment ID's are different
          call zeroiti(iabc,0,62)
          ndupl=0
          do is=1,nsegm
            do iss=1,62
              if (segnames(is)(1:1) .eq. abc(iss)) then
                if (iabc(iss) .eq. 0) then
                  iabc(iss)=is
                else
                  ndupl=ndupl+1
                  idupl(ndupl)=is
                end if
                go to 200
              end if
            end do
            if (segnames(is)(1:1) .eq. ' ') then
              ndupl=ndupl+1
              idupl(ndupl)=is
            else
              print *,'Invalid chain id character:',segnames(is)(1:1)
              segnames(is)(1:1)=' '
            end if
200         continue
          end do
          if (ndupl .gt. 0) then
            ifree0=0
            do id=1,ndupl
              do is=ifree0+1,62
                if (iabc(is) .eq. 0) then
                  ifree0=is
                  segnames(idupl(id))=abc(is)
                  go to 201
                end if
              end do
            end do
            ifree0=62
            print *,'More than 62 different segments exist - all the ',
     -        'remainings will be called Z'
201         continue
          end if
        end if
      else
c       Create segment id's from segment numbers
        do is=isegno(1),isegno(n)
          segnames(is)(1:1)=abc(min0(62,is))
          segnames(is)(2:4)='   '
        end do
      end if
c     Create atom records
      segnam='A   '
      resnam='RES     '
      atomnam='        '
      potnam='      '
      chnam='    '
      q=0.0
      icinc=0
      do iat=1,n
        if (inpcrdtyp .le. ioins .and. iat .le. n0) then
c         Full information is available
          if (isegcol2 .ge. isegcol1)
     -      segnam=segnames(isegno(iat)-isegno(1)+1)
          resnam(1:nrescol)=resnames(ixres(iat))(1:nrescol)
c         if (iat .lt. 25) print *,'RESNAM=',resnam
c    -      line(index(iat))(irescol1+icinc:irescol2+icinc)
          call leftadjustn(resnam,resnam,8)
          ic1=iresncol1
          call nextchar(line(index(iat)),ic1,132)
          ic2=ic1
          call nextblank(line(index(iat)),ic2,132)
          ic2=min0(iresncol2+1,ic2)
          if (ic2 .lt. ic1) then
            write (6,1000) iat
            ires=0
          else
c           call readint(line(index(iat)),ic1,ic2-1,ires,2)
            ires=iresno(iat)
          end if
          atomnam(1:nnamcol)=atnames(iat)(1:nnamcol)
c    -      line(index(iat))(inamcol1+icinc:inamcol2+icinc)
          if (iotyp .eq. iommod) then
               write (potnam(1:4),1006) mmtype(iat)
          else if (ipotcol2 .ge. ipotcol1) then
             potnam(1:ipotcol2-ipotcol1+1)=
     -         line(index(iat))(ipotcol1:ipotcol2)
          end if
          if (iqcol2 .ge. iqcol1) q=charge(iat)
c    -      call readreal(line(index(iat)),iqcol1+icinc,iqcol2+icinc,q)
          if (iat .eq. 999999 .and. inpcrdtyp .eq. iocha) icinc=1
        else if (inpcrdtyp .le. ioins .and. iat .gt. n0) then
c         Add solvent information
          resnam=resnamslv
          iatslv=mod(iat-n0-1,naslv)+1
          iatnum(iat)=iasv(iatslv)
          charge(iat)=qsv(iatslv)
          q=qsv(iatslv)
          if (inpcrdtyp .eq. ioins .or. inpcrdtyp .eq. iommc)
     -      potnam(1:4)=pflsv(iatslv)
          atomnam=namesv(iatslv)
          ires=iresno(n0)+(iat-n0-1)/naslv+1
          iresno(iat)=ires
        else
c         Only limited information is available
          atomnam(1:2)=iatnm2(iatnum(iat))
          if (inpcrdtyp .eq. iosxyzrq) then
            ires=iresno(iat)
            q=charge(iat)
          end if
        end if
        if (iusecvforq .eq. 1) then
          q=cv(iat)
          frocc=rprox(iat)
        end if
        chnam(1:2)=iatnm2(iatnum(iat))
        if (icreaterec .eq. 1) then
          irec=ntitlin+iat
          if (inpcrdtyp .eq. iotyp .and. iotyp .eq. iommc)
     -      mmcgm=line(index(iat))(51:52)
          line(irec)=blankline
          iqspace=1
          if (q .ge. 1000.0) then
            if (iqspaceask .eq. 1) then
              print *,'B-factor column entry > 1000 found'
              if (ipredict .eq. 0) then
                call askyn('Do you want to use all 6 characters',35,0,
     -            -1,iqspace,124)
              else
                print *,'All 6 characters will be used'
                iqspace=0
              end if
              iqspaceask=0
            end if
          end if
c          write (77,7611) iat,ires,q,segnam
c7611      format(' iat=',i6,' ires=',i5,' q=',f10.5,' segnam=',a)
          if (iotyp .le. ioins) then
            call trnsfr(cw,c(1,iat),3)
            if (inpcrdtyp .eq. iogro .and. iotyp .ne. iogro) then
              do k=1,3
                cw(k)=c(k,iat)*10.0
              end do
            else if (iotyp .eq. iogro) then
              do k=1,3
                cw(k)=c(k,iat)*0.1
              end do
            end if
            if (inpcrdtyp .eq. iomae) then
              segnam(1:1)=abc(min0(62,isegno(iat)))
              segnam(2:4)='   '
            end if
            call createrec(line(irec),inpcrdtyp,iotyp,cw(1),cw(2),cw(3),
     -        atomnam,resnam,segnam,iat,ires,ires,chnam,potnam,
     -        frocc,q,nqdec,iqspace,mmcgm,nneig(iat),ineig(1,iat),
     -        ibnd(1,iat),blankline)
          else
            call writefree(line(irec),iotyp,chnam,c(1,iat),c(2,iat),
     -        c(3,iat),ires,q)
          end if
          index(iat)=irec
        end if
c       Left justify residue and atom names
        if (iotyp .eq. iogro) then
          call leftadjustline(line(index(iat)),iirescol(1,iotyp),
     -      iirescol(2,iotyp))
          call rightadjustline(line(index(iat)),
     -      iinamcol(1,iotyp),iinamcol(2,iotyp))
        else
          call leftadjustline(line(index(iat)),iirescol(1,iotyp),
     -      iirescol(2,iotyp))
          if ((ispdb(iotyp) .eq. 0 .or. inpcrdtyp .eq. iogro) .and.
     -         noleftad .eq. 0)
     -      call leftadjustline(line(index(iat)),
     -        iinamcol(1,iotyp),iinamcol(2,iotyp))
        end if
        if (iotyp .eq. ioins) call leftadjustline(line(index(iat)),
     -    iiresncol(1,iotyp),iiresncol(2,iotyp))
        if (ispdb(iotyp) .gt. 0 .and. noreg .eq. 0) call regularpdb(
     -    line(index(iat))(iinamcol(1,iotyp):iinamcol(2,iotyp)),
     -    line(index(iat))(iinamcol(1,iotyp):iinamcol(2,iotyp)),1)
      end do
      if (iclean .eq. 1) then
        if (iotyp .lt. ioins .and. nosort .eq. 0)
     -    call sortatres(line,n,index,indexn,indexo,nhbneig,nneiga,
     -    ncneig,nsneig,npneig,iiresncol(1,iotyp),iiresncol(2,iotyp),
     -    isegno,'      ',iotyp,nconfig,iout,maxrepconf,maxrec)
        if ((ischarmm(iotyp) .eq. 1 .or. ispdb(iotyp) .gt. 0 .or.
     -       iotyp .eq. iommod .or. iotyp .eq. iommc) .and.
     -       nosort .eq. 0)
     -    call reseq(line,index,n,nslt,nsegm,iatfirst,iresfirst,
     -      iresidfirst,iotyp,iresno,resnames,numres,numslv,naslv,
     -      resnamslv,iresnrestart,iresidrestart,nconfig,ireseq,+1,
     -      maxrsd,maxrec)
      end if
      imodelnum=imodel
      if (imodel .gt. 0) imodelnum=nconfig
      call writeout(iout,inpcrdtyporg,iotyp,line,index,isegno,n,marker,
     -  iwhead,1,imodelnum,ntitlin,ntitlinw,title,blankline,nosort,
     -  ianaltyp,ifromtraj,etot,ietot,nclstmem,noend,keeprem,
     -  iwriteatsym,iatnum,maxrec)
      return
1000  format(' Atom ',i6,' has no residue number - it is set to zero')
1006  format(i4)
      end
      subroutine writeout(iout,inpcrdtyp,iotyp,line,index,isegno,n,
     -  marker,iwhead,iwhead0,imodelnum,ntitlin,ntitlinw,title,
     -  blankline,nosort,ianaltyp,ifromtraj,etot,ietot,nclstmem,noend,
     -  keeprem,iwriteatsym,iatnum,maxrec)
c     Puts out the generated configuration, with proper headers, separators
      dimension index(n),isegno(n),iatnum(n)
      character*6 marker(16)
      character*80 title,linew
      character* 132 line(maxrec),blankline,ansline,pline
      character*5 crdext
      common /iotypes/ iocha,iochaex,iobpdb,iocpdb,ioa3pdb,ioa4pdb,
     -  iommod,iommc,iommc4,iogro,iomol2,iomae,ioins,ionxyz,
     -  iosxyz,iosxyzrq,iograsp,iofull,lext(17),crdext(17)
      common /logging/ logfile,ipredict
      character*11 formatname
      common /formats/ iqdconv(19),formatname(17)
      common /columnlim/ incol(17),iidcol(17),iialtcol(17),
     -  iinamcol(2,17),iirescol(2,17),iiccol(2,17),iiresncol(2,17),
     -  iiseqncol(2,17),iisegcol(2,17),iiresidcol(2,17),iiqcol(2,17),
     -  iipotcol(2,17),iiocccol(2,17),iichemcol(2,17)
      real*8 xtlabc,xtlabc0
      common /boxdat/ xtlabc(6),xtlabc0(6),box(3),box0(3),edge_gen(3,3),
     -  cell0(3,27),cell(3,27),cellalt(3,27),
     -  ncell,ioppbc,noboxinfoar,noboxinfow,noboxrep,
     -  istuner,iboxtypfound,ixcrd(3),ixang(3),ixyzhex(3),
     -  ixyzhextraj(3),isizewarn
      common /analparm/ nsltref_f,nsltref_l,rcut_cv,icvtyp
c     write (6,*) 'WRITEOUT inpcrdtyp,iotyp,n,iwhead=',
c    -  inpcrdtyp,iotyp,n,iwhead
      nline_add=0
      pline=blankline
      pline(1:6)=marker(iotyp)
      if (iwhead .eq. 1) then
        if (iwhead0 .eq. 1 .and. marker(iotyp) .ne. '      ') then
c         Write headers
          if (ispdb(iotyp) .gt. 0 .or. ischarmm(iotyp) .eq. 1) then
c           Charmm or PDB outputs
            if (inpcrdtyp .eq. iommod) then
              icol=60
              call nextblank(line(1),icol,132)
              pline(8:icol+1)=line(1)(7:icol)
              call writeline(iout,pline,1,icol+1,0)
              pline(icol+2:132)=blankline(icol+2:132)
              icol=icol-50
              call nextchar(line(1)(51:130),icol,132)
              call lastchar(line(1),ifc,130)
              if (icol .lt. 80) then
                pline(8:ifc-(icol+50)+8)=line(1)(icol+50:ifc)
                call writeline(iout,pline,1,ifc-(icol+50)+8,0)
              end if
            else
              if (ispdb(inpcrdtyp) .gt. 0) then
                mncl=7
                mxcl=79
              else
                mncl=2
                mxcl=74
              end if
              ilw=ntitlinw
              if (ntitlin .eq. 0) then
                call blankout(linew,1,80)
                write (linew,1000) marker(iotyp)
                call lastchar(linew,lc0,80)
                call lastchar(title,lct,80)
                ltitle=min0(lct,80-lc-1)
                lc=lc0+ltitle+1
                linew(1:lc)=linew(1:lc0)//' '//title(1:ltitle)
                write (iout,1000) linew(1:lc)
                nline_add=1
              end if
              do i=1,ntitlin
                if (ischarmm(iotyp) .eq. 1 .and. i .le. ntitlin) then
c                 Make sure not to write more than 30 lines, and no blanks
                  if (ianaltyp .eq. 13 .or. ianaltyp .eq. 20 .or.
     -                ianaltyp .eq. 22) then
                    nline_add=1
                  else if (ianaltyp .eq. 14) then
                    nline_add=3
                  else
                    nline_add=0
                  end if
                  if (i .eq. 1 .and. (ietot .eq. 1 .or. nclstmem .gt. 0
     -                .or. ifromtraj .gt. 0)) then
                    nline_add=nline_add+1
                    call blankout(linew,1,80)
                    write (linew,1000) marker(iotyp)
                    call lastchar(linew,lc,80)
                    if (ietot .eq. 1) then
                      write (linew,2034) '*',etot
                      call lastchar(linew,lc,80)
                    end if
                    if (nclstmem .gt. 0) then
                      write (linew(lc+1:lc+16),2036) nclstmem
                      lc=lc+16
                    end if
                    if (ifromtraj .gt. 0) then
                      write (linew(lc+1:lc+16),2037) ifromtraj
                      lc=lc+16
                    end if
                    write (iout,1000) linew(1:lc)
                  end if
                  if (ilw .lt. 30-nline_add) then
c                   Skip energy record since that was only in the input template
                    ietotread=0
                    if (ifromtraj .gt. 0) call checkforetot(1,line(i),
     -                0,etotread,ietotread,0)
                    if (ietotread .eq. 1) nline_add=nline_add-1
                    if (ietotread .eq. 0) then
                      icol=mncl
                      call nextchar(line(i),icol,132)
                      call lastchar(line(i),ifc,mxcl)
                      if (icol .le. mxcl) then
                        ilw=ilw+1
                        pline(8:ifc-icol+8)=line(i)(icol:ifc)
                        call writeline(iout,pline,1,ifc-icol+8,0)
                      end if
                    end if
                  end if
                else
                  if (i .eq. 1 .and. (ietot .eq. 1 .or. nclstmem .gt. 0
     -                .or. ifromtraj .gt. 0)) then
                    nline_add=nline_add+1
                    call blankout(linew,1,80)
                    write (linew,1000) marker(iotyp)
                    call lastchar(linew,lc,80)
                    if (ietot .eq. 1) then
                      write (linew(lc+1:lc+19),2034) etot
                      lc=lc+19
                    end if
                    if (nclstmem .gt. 0) then
                      write (linew(lc+1:lc+16),2036) nclstmem
                      lc=lc+16
                    end if
                    if (ifromtraj .gt. 0) then
                      write (linew(lc+1:lc+16),2037) ifromtraj
                      lc=lc+16
                    end if
                    write (iout,1000) linew(1:lc)
                  end if
                  call lastchar(line(i),ifc,mxcl)
                  ietotread=0
                  if (ifromtraj .gt. 0)
     -              call checkforetot(6,line(i),0,etotread,ietotread,0)
                  if (ietotread .eq. 0) then
                    if (mncl .eq. 7) then
c                     PDB to PDB - keep full non-atom lines
                      call writeline(iout,line(i),1,ifc,0)
                    else
                      pline(8:ifc-mncl+8)=line(i)(mncl:ifc)
                      call writeline(iout,pline,1,ifc-mncl+8,0)
                    end if
                  end if
                end if
                pline(8:132)=blankline(8:132)
              end do
c             Add data column annotation, if required
              pline=blankline
              if (ianaltyp .eq. 13) then
                write (iout,2031) marker(iotyp),'hydropathy label'
              else if (ianaltyp .eq. 14) then
                if (icvtyp .eq. 1) then
                  write (iout,2031) marker(iotyp),'Circular variance'
                else
                  write (iout,2031) marker(iotyp),
     -              'weighted circular variance'
                end if
                write (pline,2032) marker(iotyp),rcut_cv
                call writeline(iout,pline,1,0,0)
                write (pline,2033) marker(iotyp),nsltref_f,nsltref_l
                call writeline(iout,pline,1,0,0)
              else if (ianaltyp .eq. 20) then
                write (iout,2031) marker(iotyp),
     -            'Delphi potential label'
              else if (ianaltyp .eq. 22) then
                write (iout,2031) marker(iotyp),
     -            'residue Root Mean Square Fluctuation (RMSF)'
              else if (ianaltyp .eq. 37) then
                write (iout,2031) marker(iotyp),
     -            'residue distance difference average'
              else if (ianaltyp .eq. 38) then
                write (iout,2031) marker(iotyp),
     -          'residue Root Mean Square Fluctuation (RMSF) difference'
              else if (ianaltyp .eq. 91) then
                write (iout,2035) marker(iotyp),'representative-based'
              else if (ianaltyp .eq. 92) then
                write (iout,2035) marker(iotyp),
     -             'closest approach-based'
              else if (ianaltyp .eq. 93) then
                write (iout,2035) marker(iotyp),'mutually proximal'
              else if (ianaltyp .eq. 94) then
                write (iout,2035) marker(iotyp),'sum of all'
              end if
            end if
            if (noboxinfoar .eq. 0) then
              write (iout,2030) marker(iotyp),box
            end if
          else if (iotyp .eq. ioins) then
            write (iout,2062)
            if (inpcrdtyp .le. ioins) then
              write (iout,1001) title
            else
              write (iout,2029) ' ',formatname(inpcrdtyp)
            end if
            write (iout,2063)
          end if
        end if
        if (inpcrdtyp .ne. iotyp .and. marker(iotyp) .ne. '      ')
     -    write (iout,2029) marker(iotyp),formatname(inpcrdtyp)
c       Write number of atoms
        if (iotyp .eq. iocha) then
          if (n .lt. 100000) then
            write (iout,1291) n
          else
            write (6,3000)
            call askstop(1)
            write (6,3001)
            write (iout,1292) n
          end if
        else if (iotyp .eq. iochaex) then
           write (iout,1293) n
        else if (iotyp .eq. iommod) then
          ansline=blankline
          write (ansline(1:6),1008) n
          if (title(1:4) .ne. '@#$%') then
            ansline(8:87)=title
          else
            ansline(8:28)='Converted by Simulaid'
            if (ntitlin . gt. 0)
     -        ansline(30:109)=title
          end if
          call lastchar(ansline,ifc,incol(inpcrdtyp))
          call writeline(iout,ansline,1,ifc,0)
        else if (iotyp .eq. iogro) then
          write (iout,1001) title
          write (iout,1007) n
        else if (iotyp .eq. ionxyz .or. iotyp .eq. iosxyz .or.
     -           iotyp .eq. iosxyzrq) then
          write (iout,1007) n
        end if
      end if
      if (ischarmm(iotyp) .eq. 1) then
c       Left-adjust residue ID
        iresidcol1=iiresidcol(1,iotyp)
        iresidcol2=iiresidcol(2,iotyp)
        do ia=1,n
          call leftadjustline(line(index(ia)),iresidcol1,iresidcol2)
        end do
      end if
      if (imodelnum .gt. 0) write (iout,1002) 'MODEL',imodelnum
      ncol=incol(iotyp)
      call lastchar(line(index(1)),ifc,ncol)
      if (n .gt. 0) then
        if (iwriteatsym .gt. 0)
     -    call addatsym(line(index(1)),iatnum(1),ifc)
        call writeline(iout,line(index(1)),1,ifc,0)
      end if
      if (nosort .eq. 1 .and.
     -    ispdb(inpcrdtyp) .gt. 0 .and. ispdb(iotyp) .gt. 0) then
c       REMARK records can only be placed safely if index is unchanged
        nrem=0
        do i=index(1),index(n)
          if (line(i)(1:6) .eq. 'REMARK') nrem=nrem+1
        end do
        if (nrem .gt. 0 .and. keeprem .eq. -1) then
          call askyn(
     -      'Do you want to keep REMARK records among the ATOM records',
     -      57,1,1,keeprem,000)
        end if
      end if
c      if (keeprem .gt. 0) write (77,8811)
c     -  (i,index(i),line(index(i))(1:80),i=1,index(n))
c8811  format(i5,' index-',i5,' line=',a)
c     ixprev=max0(0,index(1)-3)
      ixprev=index(1)
      do ia=2,n
        if (isegno(ia) .ne. isegno(ia-1)) then
c         Segment end
          if (ispdb(iotyp) .gt. 0) write (iout,1000) 'TER'
          if (iotyp .eq. ioins) write (iout,1000) 'end'
        end if
        if (keeprem .eq. 1) then
          if (index(ia)-ixprev .gt. 1) then
            do i=ixprev+1,index(ia)
              if (line(i)(1:6) .eq. 'REMARK') then
                call lastchar(line(i),lc,80)
                call writeline(iout,line(i),1,lc,0)
              end if
            end do
          end if
          ixprev=index(ia)
        end if
        call lastchar(line(index(ia)),ifc,ncol)
        if (iwriteatsym .gt. 0)
     -    call addatsym(line(index(ia)),iatnum(ia),ifc)
        call writeline(iout,line(index(ia)),1,ifc,0)
      end do
      if (imodelnum .gt. 0) then
        write (iout,1000) 'ENDMDL'
        write (iout,1000) 'TER'
      else if (ispdb(iotyp) .gt. 0 .and. noend .eq. 0) then
        write (iout,1000) 'END'
      end if
      if (iotyp .eq. ioins) write (iout,2064)
      return
1000  format(a)
1001  format(a80)
1002  format(a,i6)
1007  format(i5)
1008  format(i6)
1291  format('*',/,i5)
1292  format('*',/,i6)
1293  format('*',/,i10,2x,'EXT')
2029  format(a,' Simulaid generated this file from ',a,' input')
2030  format(a,' Cell dimensions: ',3f10.5)
2031  format(a,' Data column shows ',a)
2032  format(a,' Cutoff used for the CV calculation=',f5.1,' A')
2033  format(a,' Solute atom range used for the CV calculation [',i4,
     -  ',',i5,']')
2034  format(' E=',e16.8)
2035  format(a,' Data column shows ',a,' contact counts')
2036  format(' Nclstmem=',i6)
2037  format(' Frame #',i8)
2062  format('!BIOSYM archive 3',/,'PBC=OFF')
2063  format('!DATE')
2064  format('end',/,'end')
3000  format(' WARNING number of atoms exceeds the format limit',/,
     -  ' You may want to restart the run and ask for the extended ',
     -  ' Charmm format')
3001  format(' WARNING number of atoms will be printed with i6 format')
      end
      subroutine addatsym(line,ian,ifc)
      character*(*) line
      character*2 iatnm2
      common /atnam/ aw(99),nval(99),nvalmax(99),mmofan(99),
     -  mmatno(64),iatnm2(99)
      character*2 chemsym
      character*4 name
c     print *,'ADDATSYM ifc=',ifc
c     Add atomic symbol to col 77-78
      if (ifc .gt. 76) then
        write (6,1000) line(1:80)
      else
        call blankout(line,ifc+1,80)
      end if
      if (ian .lt. 1) then
        name=line(13:16)
        iatno=ianum(name,1,4)
      else
        iatno=ian
      end if
      chemsym=iatnm2(iatno)
      if (chemsym(2:2) .eq. ' ') then
         chemsym(2:2)=chemsym(1:1)
         chemsym(1:1)=' '
      end if
      line(77:78)=chemsym
      if (ifc .lt. 77) ifc=78
      return
1000  format(' WARNING: columns 77-78 is not blank:',/,a)
      end
      subroutine createrec(line,inpcrdtyp,ioutyp,cx,cy,cz,
     -  atnam,resnam,segnam,iseqno,iresnum,iresid,chemnam,potnam,
     -  frocc,q,nqdec,iqspace,mmcgm,nn,in,ibnd,blankline)
      character* 132 line,blankline
      character*1 resnam1
      character*4 atnam,segnam,chemnam
      character*6 potnam
      character*8 resnam
      character*5 crdext
      character*2 mmcgm
      common /iotypes/ iocha,iochaex,iobpdb,iocpdb,ioa3pdb,ioa4pdb,
     -  iommod,iommc,iommc4,iogro,iomol2,iomae,ioins,ionxyz,
     -  iosxyz,iosxyzrq,iograsp,iofull,lext(17),crdext(17)
      dimension in(nn),ibnd(nn)
c      write (77,7711) ioutyp,potnam,atnam,resnam,iresnum
c7711  format(' CREATEREC ioutyp,potnam,atnam,resnam=',i4,3(2x,a5),
c     -  ' iresnum=',i5)
c      write (77,*) 'CREATEREC ioutyp,iogro=',ioutyp,iogro
c      write (77,7611) iresnum,iresid,q,segnam
c7611  format(' CREATEREC ires,resid=',2i5,' q=',f10.5,' segnam=',a)
c     print *,'CREATEREC inpcrdtyp,ioutyp=',inpcrdtyp,ioutyp
      call setcol(inpcrdtyp,ncol,idcol,ialtcol,
     -  namcol1,namcol2,irescol1,irescol2,iccol1,iccol2,
     -  iresncol1,iresncol2,iseqncol1,iseqncol2,isegcol1,isegcol2,
     -  iresidcol1,iresidcol2,iqcol1,iqcol2,ipotcol1,ipotcol2,
     -  iocccol1,iocccol2,ichemcol1,ichemcol2,nrescol_i,nresncol,
     -  nsegcol_i,nnamcol_i,iofull)
      call setcol(ioutyp,ncol,idcol,ialtcol,
     -  namcol1,namcol2,irescol1,irescol2,iccol1,iccol2,
     -  iresncol1,iresncol2,iseqncol1,iseqncol2,isegcol1,isegcol2,
     -  iresidcol1,iresidcol2,iqcol1,iqcol2,ipotcol1,ipotcol2,
     -  iocccol1,iocccol2,ichemcol1,ichemcol2,nrescol,nresncol,
     -  nsegcol,nnamcol,iofull)
      line=blankline
      if (ioutyp .eq. iocha) then
        icinc=0
        if (icinc .gt. 999999) icinc=1
        write (line(iseqncol1+icinc:iseqncol2+icinc),1000)
     -    mod(iseqno,100000)
        write (line(iresncol1+icinc:iresncol2+icinc),1000)
     -    mod(iresnum,100000)
        if (iseqno .eq. 100000) write (6,1100) 'seqno',99999,'CRD'
        if (iresnum .eq. 100000) write (6,1100) 'resnum',99999,'CRD'
        write (line(iccol1+icinc:iccol2+icinc),1011) cx,cy,cz
        call putreal(line(iqcol1+icinc:iqcol2+icinc),iqcol2-iqcol1+1,
     -    q,nqdec)
        write (line(iresidcol1+icinc:iresidcol2+icinc),1001)
     -    mod(iresid,10000)
        if (iresid .eq. 10000) write (6,1100) 'iresid',9999,'Charmm'
        call leftadjustline(line,iresidcol1+icinc,iresidcol2+icinc)
      else if (ioutyp .eq. iochaex) then
        write (line(iseqncol1:iseqncol2),1005) iseqno
        write (line(iresncol1:iresncol2),1005) iresnum
        write (line(iccol1:iccol2),1015) cx,cy,cz
        call putreal(line(iqcol1:iqcol2),iqcol2-iqcol1+1,q,2*nqdec)
        write (line(iresidcol1:iresidcol2),1004) iresid
        call leftadjustline(line,iresidcol1,iresidcol2)
      else if (ispdb(ioutyp) .gt. 0) then
        if (resnam .eq. '     ' .or. resnam .eq. 'UNK  ') then
          line(1:6)='HETATM'
        else
          line(1:6)='ATOM  '
        end if
        write (line(iseqncol1:iseqncol2),1000) mod(iseqno,100000)
        write (line(iresncol1:iresncol2),1001) mod(iresnum,10000)
        write (line(iccol1:iccol2),1012) cx,cy,cz
        if (iresnum .eq. 10000) write (6,1100) 'resnum',9999,'PDB'
        if (iseqno .eq. 100000) write (6,1100) 'seqno',99999,'PDB'
        if (frocc .eq. 1.0) then
          line(55:60)='   1.0'
        else
          call putreal(line(55:60),6,frocc,0)
        end if
        if (iqspace .eq. 1) then
          line(iqcol1:iqcol1)=' '
          call putreal(line(iqcol1+1:iqcol2),iqcol2-iqcol1,q,nqdec)
        else
          call putreal(line(iqcol1:iqcol2),iqcol2-iqcol1+1,q,nqdec)
        end if
        if (ioutyp .eq. iocpdb) then
c         Right shift names that are less than four characters
          if (atnam(1:1) .ne. ' ' .and. atnam (4:4) .eq. ' ') then
            atnam(2:4)=atnam(1:3)
            atnam(1:1)=' '
          end if
        end if
      else if (ioutyp .eq. iommod) then
        write (line(iresncol1:iresncol2),1000) iresnum
        write (line(iccol1:iccol2),1013) cx,cy,cz
        call writeitem(line,ipotcol1,ipotcol2,potnam,0)
        line(110:118)='  0.00000'
        line(iqcol1:iqcol2)=' '
        call putreal(line(iqcol1+1:iqcol2),iqcol2-iqcol1,q,nqdec)
        do i=1,nn
          write (line(12+(i-1)*8:12+(i-1)*8),1002) ibnd(i)
          write (line(5+(i-1)*8:10+(i-1)*8),1003) in(i)
        end do
        do i=nn+1,6
          line(4+(i-1)*8+1:4+i*8)='     0 0'
        end do
c       Create also the 1-letter residue code
        call changeprot(resnam,resnam1,2)
        line(isegcol1-1:isegcol2-1)=resnam1
      else if (ioutyp .eq. iommc) then
        write (line(iresncol1:iresncol2),1000) iresnum
        write (line(iccol1:iccol2),1011) cx,cy,cz
        call writeitem(line,ipotcol1,ipotcol2,potnam,0)
        call putreal(line(iqcol1:iqcol2),iqcol2-iqcol1+1,q,nqdec)
        line(51:52)=mmcgm
      else if (ioutyp .eq. iogro) then
        write (line(iseqncol1:iseqncol2),1000) iseqno
        write (line(iresncol1:iresncol2),1000) iresnum
        line(irescol1:irescol1)=' '
        line(namcol1:namcol1)=' '
        write (line(iccol1:iccol2),1012) cx/10.0,cy/10.0,cz/10.0
        write (line(iccol1+24:iccol2+24),1012) 0.0,0.0,0.0
      else if (ioutyp .eq. ioins) then
        write (line(iresncol1:iresncol2),1001) iresnum
        call writeitem(line,ichemcol1,ichemcol2,chemnam,0)
        if (inpcrdtyp .eq. ioutyp) then
          call writeitem(line,ipotcol1,ipotcol2,potnam,0)
        else
          call writeitem(line,ipotcol1,ipotcol2,chemnam,0)
        end if
        write (line(iccol1:iccol2),1014) cx,cy,cz
        call putreal(line(iqcol1:iqcol2),iqcol2-iqcol1+1,q,nqdec)
      end if
      call writeitem(line,irescol1,irescol2,resnam,nrescol_i)
      call writeitem(line,isegcol1,isegcol2,segnam,min0(4,nsegcol_i))
      call writeitem(line,namcol1,namcol2,atnam,min0(4,nnamcol_i))
      return
1000  format(i5)
1001  format(i4)
1002  format(i1)
1003  format(i6)
1004  format(i8)
1005  format(i10)
1011  format(3f10.5)
1012  format(3f8.3)
1013  format(3f12.5)
1014  format(3f15.9)
1015  format(3f20.10)
1100  format(' WARNING: leading ',a,' digits over ',i7,
     -  '  are dropped (',a,' format limit)')
      end
      subroutine set_pdbinfo(iotyp,iwriteatsym,iwritecon,iobpdb,iocpdb,
     -  iaskcon)
      if (iotyp .eq. iobpdb .or. iotyp .eq. iocpdb) then
        if (iwriteatsym .lt. 0) call askyn(
     -    'Do you want chemical names written in the PDB file',50,
     -    1,-1,iwriteatsym,0)
        if (iaskcon .eq. 1) call askyn(
     -    'Do you want CONECT records written in the PDB file',50,1,
     -    -1,iwritecon,0)
      end if
      return
      end
      subroutine askstop(idef)
      common /logging/ logfile,ipredict
      if (ipredict .eq. 0) then
        call askyn('Do you want to continue',23,1,idef,icont,20)
        if (icont .eq. 0) stop
      else
        print *,'Run continues as predictable input was requested'
      end if
      return
      end
      subroutine putreal(out,len,val,ndec)
      character*(*) out
      character*25 out25
c     Puts a real number into out
      if (ndec .eq. 0) then
        write (out25,100) val
      else if (ndec .eq. 1) then
        write (out25,101) val
      else if (ndec .eq. 2) then
        write (out25,102) val
      else if (ndec .eq. 3) then
        write (out25,103) val
      else if (ndec .eq. 4) then
        write (out25,104) val
      else if (ndec .eq. 5) then
        write (out25,105) val
      else if (ndec .eq. 6) then
        write (out25,106) val
      else if (ndec .eq. 7) then
        write (out25,107) val
      else if (ndec .eq. 8) then
        write (out25,108) val
      else if (ndec .eq. 9) then
        write (out25,109) val
      else if (ndec .eq. 10) then
        write (out25,110) val
      else
        print *,'Illegal number of decimal digits in putmol:',ndec
        write (out25,110) val
      end if
c     Check for exceeding the length
      ic=1
      call nextchar(out25,ic,25)
      if (ic .le. 25-len) then
        out=out25(ic:ic+len-1)
      else
        out=out25(25-len+1:25)
      end if
c     print *,'PUTREAL val=',val,' out=',out,' len=',len
      return
100   format(f25.0)
101   format(f25.1)
102   format(f25.2)
103   format(f25.3)
104   format(f25.4)
105   format(f25.5)
106   format(f25.6)
107   format(f25.7)
108   format(f25.8)
109   format(f25.9)
110   format(f25.10)
      end
      subroutine writefree(line,ioutyp,chemnam,cx,cy,cz,ires,q)
      character*4 chemnam
      character* 132 line
      character*5 crdext
      common /iotypes/ iocha,iochaex,iobpdb,iocpdb,ioa3pdb,ioa4pdb,
     -  iommod,iommc,iommc4,iogro,iomol2,iomae,ioins,ionxyz,
     -  iosxyz,iosxyzrq,iograsp,iofull,lext(17),crdext(17)
c     Limited free-format outputs for InsightII
      if (ioutyp .eq. ionxyz) then
        write (line,1100) ianum(chemnam,0,4),cx,cy,cz
      else if (ioutyp .eq. iosxyz) then
        write (line,1101) chemnam,cx,cy,cz
      else if (ioutyp .eq. iosxyzrq) then
        write (line,1102) chemnam,cx,cy,cz,ires,q
      end if
      return
1100  format(i5,3f10.5)
1101  format(a5,3f10.5)
1102  format(a5,3f10.5,i5,f10.5)
      end
      subroutine writepdbd(iout,c,ia,ir,atnam,resnam,segnam,frocc,bfac)
      real*8 c(3)
      character*4 atnam
      character*3 resnam
      character*1 segnam
      write (iout,1000) ia,atnam,resnam,segnam,ir,c,frocc,bfac
      return
1000  format('ATOM  ',i5,1x,a4,1x,a3,1x,a1,i4,1x,3x,3f8.3,f6.2,f6.1)
      end
      subroutine writegrasp(iout,nconvdat,analfile,namlena)
      character*200 analfile
c     Write a Grasp .crg file from convdat
      character*4 ires
      character*8 convdat
      character*200 sfilename
      common /savedat/ mxresdat,maxcondat,ifst(1000),ilst(1000),
     -  nres,iresgen,lsfilename,ires(1000),convdat(7,10000),sfilename
      nl=min0(namlena,50)
      write (iout,1000) analfile(1:nl)
      write (iout,1001)
      nxa=0
      nxr=0
      do ia=1,nconvdat
        read (convdat(4,ia),*) ch
        write (iout,2000) convdat(2,ia)(1:4),convdat(1,ia)(1:3),ch
        if (convdat(1,ia)(4:4) .ne. ' ') nxr=nxr+1
        if (convdat(2,ia)(5:5) .ne. ' ') nxa=nxa+1
      end do
      if (nxa .gt. 0) write (6,1002) nxa,'atom',4
      if (nxr .gt. 0) write (6,1002) nxr,'residue',3
      return
1000  format('!Generated by Simulaid from ',a)
1001  format('atom__resnumbc_charge_')
1002  format('WARNING: ',i5,1x,a,' names were longer than ',
     -  i1,' characters')
2000  format(a4,2x,a3,6x,f6.3)
      end
      subroutine writeUHBD(iout,nconvdat,analfile,namlena,icon)
      character*200 analfile
c     Write a UHBD .dat file from convdat
      character*4 ires
      character*8 convdat
      character*200 sfilename
      common /savedat/ mxresdat,maxcondat,ifst(1000),ilst(1000),
     -  nres,iresgen,lsfilename,ires(1000),convdat(7,10000),sfilename
      character*7 libname(3)
      data libname /'Amber  ','CHARMM ','GROMACS'/
      nl=min0(namlena,50)
      write (iout,1000) libname(icon),analfile(1:nl)
      do ia=1,nconvdat
        iatno=ianum(convdat(2,ia),1,4)
        read (convdat(4,ia),*,err=999) ch
        read (convdat(6,ia),*,err=999) eps
        read (convdat(7,ia),*,err=999) sig
        write (iout,2000) convdat(2,ia)(1:4),convdat(1,ia)(1:4),
     -    ch,eps,sig,(sig/2.0)*2.0**(1.0/6.0)
      end do
      return
999   write (6,2001) ia,convdat(4,ia),convdat(6,ia),convdat(7,ia)
      return
1000  format(a,/,'!Generated by Simulaid from ',a,/,
     -  'atom  resi   chrg   epsi   sigm   radi end')
2000  format(a4,2x,a3,6x,5f8.4)
2001  format(' PROGRAM ERROR: invalid data in convdat ia=',i4,
     -  ' convdat4,6,7=',3f9.4)
      end
      subroutine setcol(inpcrdtyp,ncol,idcol,ialtcol,
     -  inamcol1,inamcol2,irescol1,irescol2,iccol1,iccol2,
     -  iresncol1,iresncol2,iseqncol1,iseqncol2,isegcol1,isegcol2,
     -  iresidcol1,iresidcol2,iqcol1,iqcol2,ipotcol1,ipotcol2,
     -  iocccol1,iocccol2,ichemcol1,ichemcol2,nrescol,nresncol,nsegcol,
     -  nnamcol,iofull)
      common /columnlim/ incol(17),iidcol(17),iialtcol(17),
     -  iinamcol(2,17),iirescol(2,17),iiccol(2,17),iiresncol(2,17),
     -  iiseqncol(2,17),iisegcol(2,17),iiresidcol(2,17),iiqcol(2,17),
     -  iipotcol(2,17),iiocccol(2,17),iichemcol(2,17)
c     print *,'SETCOL inpcrdtyp=',inpcrdtyp
      ncol=incol(inpcrdtyp)
      idcol=iidcol(inpcrdtyp)
      ialtcol=iialtcol(inpcrdtyp)
      inamcol1=iinamcol(1,inpcrdtyp)
      inamcol2=iinamcol(2,inpcrdtyp)
      irescol1=iirescol(1,inpcrdtyp)
      irescol2=iirescol(2,inpcrdtyp)
      iccol1=iiccol(1,inpcrdtyp)
      iccol2=iiccol(2,inpcrdtyp)
      iresncol1=iiresncol(1,inpcrdtyp)
      iresncol2=iiresncol(2,inpcrdtyp)
      iseqncol1=iiseqncol(1,inpcrdtyp)
      iseqncol2=iiseqncol(2,inpcrdtyp)
      isegcol1=iisegcol(1,inpcrdtyp)
      isegcol2=iisegcol(2,inpcrdtyp)
      iresidcol1=iiresidcol(1,inpcrdtyp)
      iresidcol2=iiresidcol(2,inpcrdtyp)
      iqcol1=iiqcol(1,inpcrdtyp)
      iqcol2=iiqcol(2,inpcrdtyp)
      ipotcol1=iipotcol(1,inpcrdtyp)
      ipotcol2=iipotcol(2,inpcrdtyp)
      iocccol1=iiocccol(1,inpcrdtyp)
      iocccol2=iiocccol(2,inpcrdtyp)
      ichemcol1=iichemcol(1,inpcrdtyp)
      ichemcol2=iichemcol(2,inpcrdtyp)
      nrescol=irescol2-irescol1+1
      nresncol=iresncol2-iresncol1+1
      nsegcol=isegcol2-isegcol1+1
      nnamcol=inamcol2-inamcol1+1
      if (inpcrdtyp .gt. iofull) then
        nrescol=4
        iqcol1=0
      end if
      return
      end
      subroutine readxcluster(natoms,c,inpt,nconfig)
      dimension c(3,natoms)
      character*132 inpline
c     X-cluster new coordinates
c     print *,'natoms,inpt,nconfig=',natoms,inpt,nconfig
      read (inpt,1001) inpline
c     print *,'inpline=',inpline
      read (inpline(1:6),1008,err=999) nn
      if (-nn .ne. natoms) then
        print *,'ERROR: Number of atoms in the first ',
     -    'structure=',natoms
        print *,'Number of atoms in the X-cluster structure=',-nn
        print *,'Nconfig=',nconfig
        stop
      end if
      do i=1,natoms
        read (inpt,1001) inpline
        read (inpline(6:41),1103) (c(k,i),k=1,3)
      end do
      return
999   print *,'Invalid number of atoms reading in xcluster'
      stop
1001  format(a132)
1008  format(i6)
1103  format(3f12.5)
      end
      subroutine leftadjustline(line,ic1,ic2)
      character*(*) line
      icol=ic1
      call nextchar(line,icol,132)
      nshift=icol-ic1
      if (nshift .gt. 0) then
        do i=icol,ic2
          line(i-nshift:i-nshift)=line(i:i)
        end do
        do i=1,nshift
          line(ic2-i+1:ic2-i+1)=' '
        end do
      end if
      return
      end
      subroutine rightadjustline(line,ic1,ic2)
      character* 132 line
c     print *,'RIGHTADJUSTLINE ic1,ic2=',ic1,ic2,' line=',line(ic1:ic2)
      nshift=0
      do while (line(ic2-nshift:ic2-nshift) .eq. ' '
     -         .and. nshift .le. ic2-ic1)
        nshift=nshift+1
      end do
      do ic=ic1,ic2-nshift
        icc=ic2-ic+ic1
        line(icc:icc)=line(icc-nshift:icc-nshift)
      end do
      do ic=ic1,ic1+nshift-1
        line(ic:ic)=' '
      end do
c     print *,'nshift=',nshift,' line=',line(ic1:ic2)
      return
      end
      subroutine leftadjust4(in,out)
c*****Left-adjust a string of four characters
      character*(*) in
      character*4 out,outt
      outt='    '
      do i=1,4
        if (in(i:i) .ne. ' ') then
          do j=i,4
            outt(j-i+1:j-i+1)=in(j:j)
          end do
          out=outt
          return
        end if
      end do
      out=in(1:4)
      return
      end
      subroutine leftadjustn(in,out,n)
c*****Left-adjust a string of n characters
      character*(*) in
      character*(*) out
      nz=0
      i=1
      do while(i .lt. n .and. in(i:i) .eq. ' ')
        i=i+1
      end do
      if (i .eq. n .and. in(n:n) .eq. ' ') then
        call blankout(out,1,n)
        return
      end if
      nz=i-1
      do j=nz+1,n
        out(j-nz:j-nz)=in(j:j)
      end do
      do j=n-nz+1,n
        out(j:j)=' '
      end do
      return
      end
      subroutine askrot(nstep)
      common /rotmat/ matrot0(4,4),matrot(4,4),nomat0
      character*1 ans,ans0,anslc,xyzorig(3)
      common /askrotdat/ angle,ans0
      common /depthcuedat/ near,ifar,ramp0,idepth,idepthon,idrawh,
     -  linew,isidec,nbackb,idrawslv
      character*1 xyz
      common /axislab/ xyz(3)
      character*3 onoff(2)
      data onoff /'OFF','ON '/,xyzorig /'x','y','z'/
      if (nstep .eq. 0) then
        ans0='x'
        angle=10.0
      end if
      if (mod(nstep,20) .eq. 0)
     -  write (6,2104) onoff(2-idepth),onoff(2-idrawh),onoff(2-isidec),
     -  onoff(2-idrawslv),linew
      nstep=nstep+1
      ans=' '
100   read (5,1010) ans
      if (ans .eq. 's' .or. ans .eq. 'S') then
        nstep=-1
        return
      else if (ans .eq. 'q' .or. ans .eq. 'Q') then
        call getreal('New angle increment',19,angle,angle,0,36)
        go to 100
      else if (ans .eq. 'd' .or. ans .eq. 'D') then
        idepth=1-idepth
        write (6,2001) 'Depth cueing',onoff(idepth+1)
        go to 100
      else if (ans .eq. 'h' .or. ans .eq. 'H') then
        idrawh=1-idrawh
        write (6,2001) 'Hydrogens',onoff(idrawh+1)
        go to 100
      else if (ans .eq. 'c' .or. ans .eq. 'C') then
        if (nbackb .gt. 0) then
          isidec=1-isidec
          write (6,2001) 'Side chains',onoff(isidec+1)
        else
          print *,'There are no backbone atoms - input ignored'
        end if
        go to 100
      else if (ans .eq. 'v' .or. ans .eq. 'V') then
        idrawslv=1-idrawslv
        write (6,2001) 'Solvents',onoff(idrawslv+1)
        go to 100
      else if (idigit(ans,1) .eq. 1) then
        read (ans,*) linew
        write (6,2002) linew
      end if
      if (ans .eq. 'x' .or. ans .eq. 'y' .or. ans .eq. 'z'
     -    .or. ans .eq. 'X' .or. ans .eq. 'Y' .or. ans .eq. 'Z') then
        anslc=ans
        call uplow(ans,anslc,1,noabc)
        do k=1,3
          if (anslc .eq. xyz(k)) ans=xyzorig(k)
        end do
        ans0=ans
      else
        ans=ans0
      end if
      iaxis=10.0*angle
c     print *,'iaxis=',iaxis,' ans=',ans,' angle=',angle
C@GL      call rotate(iaxis,ans)
      return
1010  format(a1)
2001  format(1x,a,' has been turned ',a)
2002  format(' Solute linewidth has been changed to',i2)
2104  format(' Type x/y/z to rotate by 10 degrees around axis x/y/z',/,
     -  ' Type q to change the angle increment',/,
     -  ' Type d to toggle depth-cueing ',a,/,
     -  ' Type h to toggle showing hydrogens  ',a,/,
     -  ' Type c to toggle showing sidechains ',a,/,
     -  ' Type v to toggle showing solvents   ',a,/,
     -  ' Type a number (1 digit) to change the linewidth from',i2,/,
     -  ' Hit <Enter> to continue rotating around the previous axis',/,
     -  ' Type s to stop the rotation and continue the run')
      end
C@GL      subroutine getrotmat(matrot,nomat,lab)
C@GL      dimension matrot(4,4)
C@GL      character*4 lab
C@GLc     print *,'GETROTMAT ',lab,' nomat=',nomat
C@GL      if (nomat .eq. 1) then
C@GL        nomat=0
C@GL        call pushma
C@GL        call getmat(matrot)
C@GL        call popmat
C@GLc        write (6,1000) lab,matrot
C@GL      end if
C@GL      return
C@GLc1000  format(' Matrix read at ',a4,':',/,(4i12))
C@GL      end
      subroutine cvffconv(cvffname,charmmname,incvff,icvff,outnam,n,
     -  iused,ntypein,iambig,lstambig,nambig,noconv,ioutmsg,maxtyp)
      character*4 incvff,outnam,xxxx
      dimension incvff(n),icvff(n),outnam(n),iused(maxtyp),lstambig(n),
     -  iambig(maxtyp)
      character*2 cvffname(100)
      character*4 charmmname(100)
      data xxxx /'****'/
c     Convert cvff types into Charmm22 type (first approximation)
c      write (6,8888) cvffname
c8888  format(20(1x,a2))
      call zeroiti(iused,0,maxtyp)
      nambig=0
      noconv=0
      do i=1,n
        icvff(i)=0
        j=0
        do while (j .lt. ntypein .and. icvff(i) .eq. 0)
          j=j+1
          if (incvff(i)(1:2) .eq. cvffname(j)) then
            icvff(i)=j
            outnam(i)=charmmname(j)
            if (outnam(i)(1:1) .eq. '?') then
              write (6,101) incvff(i)(1:2),i
              if (ioutmsg .gt. 0) write (ioutmsg,101) incvff(i)(1:2),i
              noconv=noconv+1
            else
              iused(j)=iused(j)+1
            end if
            if (iambig(j) .gt. 0) then
              nambig=nambig+1
              lstambig(nambig)=i
            end if
          end if
        end do
        if (icvff(i) .eq. 0) then
          write (6,100) incvff(i)(1:2),i
          if (ioutmsg .gt. 0) write (ioutmsg,100) incvff(i)(1:2),i
          outnam(i)=xxxx
        end if
      end do
      return
100   format(' ERROR: atom type ',a2,' atom number',i4,' is not a',
     -  ' valid cvff type',/,' - check input file')
101   format(' PROBLEM: no conversion is given for atom type ',a2,
     -  ' atom number ',i4)
      end
      subroutine refineconv(n,cvffnam,iatnam,iatnum,iused,
     -  icvff,nneig,ineig,nhneig,nringnb,iringtyp,maxng,maxtyp,maxat)
      dimension nneig(maxat),ineig(maxng,n),iatnum(maxat),
     -  iatnam(maxat),icvff(maxat),nhneig(maxat),
     -  cvffnam(maxat),nringnb(maxat),iringtyp(maxat),iused(maxtyp)
      character*2 nnam
      character*4 cvffnam,iatnam,obl,ob,ct2,ct3
c     'Refine' conversion by differentiation of some cases
      data obl /'O   '/,ob /'OB  '/,ct2 /'CT2 '/,ct3 /'CT3 '/
c-----Determine ring membership type
c     print *,'REFINECONV n,maxng,maxtyp=',n,maxng,maxtyp
c     Count ring member neighbours
      do i=1,n
        iringtyp(i)=0
c       Set iringtyp(i) to -1 for ring atoms
        nnam=cvffnam(i)(1:2)
        if (nnam .eq. 'c5' .or. nnam .eq. 'cp' .or. nnam .eq. 'np'
     -      .or. nnam .eq. 'ni') iringtyp(i)=-1
        nringnb(i)=0
        nn=nneig(i)
        do j=1,nn
          nnam=cvffnam(ineig(j,i))(1:2)
          if (nnam .eq. 'c5' .or. nnam .eq. 'cp' .or. nnam .eq. 'np'
     -        .or. nnam .eq. 'ni') nringnb(i)=nringnb(i)+1
        end do
      end do
c     Set iringtyp(i) to 5 and 6, resp when ring size is known for sure
      do i=1,n
        if (cvffnam(i)(1:2) .eq. 'c5') iringtyp(i)=5
        if (cvffnam(i)(1:2) .eq. 'cp') iringtyp(i)=6
        if (cvffnam(i)(1:2) .eq. 'ni') iringtyp(i)=5
      end do
c     Set iringtyp(i) to 4 for ring junction atoms (to be refined later)
      do i=1,n
        if (nringnb(i) .gt. 2) iringtyp(i)=4
      end do
      nchange=0
      nrep=0
      do while (nchange .gt. 0 .or. nrep .eq. 0)
c     For ring nitrogens not set yet, deduce ring size from neighbours'
        nrep=nrep+1
        do i=1,n
          if (iatnum(i) .eq. 7 .and. iringtyp(i) .eq. -1) then
            nn=nneig(i)
            do in=1,nn
              if (iringtyp(ineig(in,i)) .eq. 5) then
                iringtyp(i)=5
                nchange=nchange+1
              end if
              if (iringtyp(ineig(in,i)) .eq. 6) then
                iringtyp(i)=6
                nchange=nchange+1
              end if
            end do
          end if
        end do
      end do
c     For ring junction, set type if possible
      do i=1,n
        if (iringtyp(i) .eq. 4) then
          nn=nneig(i)
          nn5=0
          nn6=0
          do in=1,nn
            if (iringtyp(ineig(in,i)) .eq. 5) nn5=nn5+1
            if (iringtyp(ineig(in,i)) .eq. 6) nn6=nn6+1
          end do
          if (nn5 .gt. 0 .and. nn6 .gt. 0) iringtyp(i)=1
          if (nn6 .eq. 0 .and. nn5 .eq. 3) iringtyp(i)=2
          if (nn5 .eq. 0 .and. nn6 .eq. 3) iringtyp(i)=3
        end if
      end do
c     Now -1: some ring atom; 0: No ring atom; 1:5/6 junction; 2: 5/5 junction
c     3: 6/6 junction; 4: some junction; 5:5-membered ring; 6:6-membered ring
      do i=1,n
        if (iatnam(i) .eq. obl) then
c         Separate carbonyl oxygen in acetic acid
          ic=ineig(1,i)
          if (nneig(i) .gt. 1 .or. iatnum(ic) .ne. 6) then
            write (6,100) nneig(i),iatnam(i),i
          else
            nnc=nneig(ic)
            if (nnc .eq. 2) then
              ij1=ineig(1,ic)
              ij2=ineig(2,ic)
              if (iatnum(ij1) .eq. 6 .and. iatnam(ij2) .eq. 'OH1 '
     -          .or. iatnum(ij2) .eq. 6 .and. iatnam(ij1) .eq. 'OH1 ')
     -          then
                iatnam(i)=ob
                iused(83)=iused(83)+1
                icvff(i)=83
              end if
            end if
          end if
        else if (cvffnam(i)(1:2) .eq. 'c ') then
          if (nhneig(i) .eq. 2) then
            iatnam(i)=ct2
            iused(84)=iused(84)+1
            icvff(i)=84
          else if (nhneig(i) .eq. 3) then
            iatnam(i)=ct3
            iused(85)=iused(85)+1
            icvff(i)=85
          end if
        else if (cvffnam(i)(1:2) .eq. 'cn' .and. nhneig(i) .eq. 2) then
          iatnam(i)=ct2
          iused(86)=iused(86)+1
          icvff(i)=86
        end if
      end do
      return
100   format(' ERROR: type O has',i2,' neighbours and the first is '
     -  ,a4,' i=',i4,/,' - check coordinate file')
      end
      subroutine printrtfres(if,il,nneig,ineig,resnam,q,atnam,potnam,
     -  nglist,iqok,ipotok,iout,outfile,namleno,maxng,maxat)
      dimension nneig(maxat),ineig(maxng,maxat),q(maxat),nglist(maxng)
      character*4 resnam,atnam(maxat),potnam(maxat)
      character*(*) outfile
      if (iqok .eq. 0) write (iout,1000) 'Charges were unavailable'
      if (ipotok .eq. 0) write (iout,1000) 'FP labels were unavailable'
c-----Print residue name, charge
      qsum=0.0
      qabssum=0.0
      if (iqok .eq. 1) then
        do ia=if,il
          qsum=qsum+q(ia)
          qabssum=qabssum+abs(q(ia))
        end do
      end if
      if (qabssum .eq. 0.0) write (iout,1000) 'All charges are zero ??'
c-----Print atoms
      write (iout,1003) resnam,qsum
      qsum=0.0
      do ia=if,il
        write (iout,1002) atnam(ia),potnam(ia),q(ia)
        qsum=qsum+q(ia)
        if (isinteger(qsum,4,qoffset) .eq. 1 .and. qabssum .gt. 0.001)
     -     write (iout,1004)
      end do
c-----Print bonds
      do ia=if,il
        nn=nneig(ia)
        if (nn .gt. 0) then
          nnl=0
          do ja=1,nn
            in=ineig(ja,ia)
            if (in .gt. ia) then
              nnl=nnl+1
              nglist(nnl)=in
            end if
          end do
          if (nnl .gt. 0) write (iout,1001)
     -      (atnam(ia),atnam(nglist(j)),j=1,nnl)
        end if
      end do
      write (6,2000) resnam,outfile(1:namleno),il-if+1,qsum
      return
1000  format('! ',a)
1001  format('BOND  ',12(a4,1x))
1002  format('ATOM ',a4,1x,a4,f10.5)
1003  format('RESI ',a4,f10.5)
1004  format('GROUP')
2000  format(' RTF file for residue ',a,' was printed a to file ',a,/,
     -  ' Number of atoms=',i4,' Charge sum=',f6.2)
      end
      subroutine writeitem(line,icol1,icol2,name,namlen)
c     Place one item into a record
      character* 132 line
      character*(*) name
      if (icol1 .gt. icol2) return
      if (namlen .eq. 0) then
        namelen=icol2-icol1+1
      else
        namelen=min0(icol2-icol1+1,namlen)
      end if
      call blankout(line,icol1,icol2)
      line(icol1:icol1+namelen-1)=name(1:namelen)
      return
      end
      subroutine sortatres(line,n,index,indexn,indexo,ifa,ila,iresn,
     -  ireso,isegn,iresncol1,iresncol2,isegno,marker,inpcrdtyp,nconfig,
     -  iout,maxrepconf,maxrec)
      character* 132 line(maxrec)
      character*6 marker
      dimension index(n),isegno(n),indexo(n),indexn(n),ifa(n),ila(n),
     -  iresn(n),ireso(n),isegn(n)
      character*5 crdext
      common /iotypes/ iocha,iochaex,iobpdb,iocpdb,ioa3pdb,ioa4pdb,
     -  iommod,iommc,iommc4,iogro,iomol2,iomae,ioins,ionxyz,
     -  iosxyz,iosxyzrq,iograsp,iofull,lext(17),crdext(17)
c     Rearrange coordinates to keep atoms of the same residue together
c     print *,'SORTATRES,iresncol1,2',n,iresncol1,iresncol2
      if (n .eq. 1) return
      if (nconfig .le. maxrepconf)
     -  print *,'Sorting by segment (chain) id and residue id'
      if (n .gt. 1000) print *,'..... Wait'
      nresncol=iresncol2-iresncol1+1
      call indexit(indexo,1,n,0)
c     Individual intervals consist of single elements at start
      nn=n
      call indexit(ifa,1,n,0)
      call indexit(ila,1,n,0)
c     Merge pairs of intervals
11    nnpair=nn/2
      l=1
      do i=1,nnpair
        call mergerec(line,index,indexo,isegno,iresncol1,iresncol2,
     -    ifa(l),ila(l),ifa(l+1),ila(l+1),iresn,ireso,isegn,n,maxrec)
        ifa(i)=ifa(l)
        ila(i)=ila(l+1)
        l=l+2
      end do
      if (2*nnpair .eq. nn) go to 21
c     Take care of last (odd) interval
      call mergerec(line,index,indexo,isegno,iresncol1,iresncol2,
     -  ifa(nnpair),ila(nnpair),ifa(nn),ila(nn),iresn,ireso,isegn,n,
     -  maxrec)
      ila(nnpair)=ila(nn)
21    nn=nnpair
      if (nn .gt. 1) go to 11
c     print *,'Sortatres n=',n
      do i=1,n
        indexn(indexo(i))=i
      end do
      if (inpcrdtyp .eq. iommod)
     -  call nnupdate(index,indexn,indexo,n,n,line,0,maxrec)
      if (marker .ne. '      ') write (iout,1270) marker
      return
1270  format(a6,' Atoms sorted by residues by SIMULAID')
      end
      subroutine filenamenum(inpfile,namleni,numfile,namlenn,n,inout)
      character*200 inpfile,numfile
      character*1 separatorchar
      common /filenuminfo/ iaskunderscore,separatorchar
c     inout=-1: input file; inout=+1: output file; inout=+2: unpacking output f
      iunderscore=0
c     print *,'FNAMNUM inout=',inout,' iaskunderscore=',iaskunderscore,
c    -  ' separatorchar=',separatorchar
c     Find last '.'
      do ic=namleni,1,-1
        if (inpfile(ic:ic) .eq. '.') then
          nl1=ic
          go to 100
        end if
      end do
      nl1=namleni+1
100   nl0=nl1-1
      if (nl0 .gt. 1) then
c       Skip '.1.' if present
        if (inpfile(nl0-1:nl0+1) .eq. '.1.' .or.
     -      inpfile(nl0-1:nl0+1) .eq. '_1.') nl1=nl1-2
        if (inout .eq. 2 .and. iaskunderscore .eq. 1) then
c         Unpacking traj or configs - always ask separator character
          print *,'Filenumber separator is . (e.g., x_2.pdb)'
          call askyn('Use _ as the filenumber separator instead',
     -      41,1,-1,iunderscore,0)
          iaskunderscore=-1
        end if
        if (separatorchar .eq. '.' .and. iaskunderscore .eq. 1) then
          if (inpfile(nl0-1:nl0-1) .eq. '_') then
            separatorchar='_'
            iunderscore=1
          else if (inpfile(nl0-1:nl0-1) .ne. '.') then
            if (inout .eq. -1) then
              call askyn(
     -          'Are the file numbers separated by _ (e.g., x_2.pdb)',
     -          51,1,-1,iunderscore,0)
            else
              print *,'Filenumber separator is . (e.g., x_2.pdb)'
              call askyn('Use _ as the filenumber separator instead',
     -          41,1,-1,iunderscore,0)
              iaskunderscore=-1
            end if
          end if
        end if
      end if
      if (iabs(iaskunderscore) .eq. 1) then
        if (iunderscore .eq. 1) separatorchar='_'
        if (inout .gt. 0)
     -    write (6,2000) separatorchar,inpfile(nl1:namleni)
        iaskunderscore=0
      end if
c     Insert numeral
      numfile(1:nl0)=inpfile(1:nl0)
      numfile(nl1:nl1)=separatorchar
      nl1=nl1+1
      call writeint(numfile,nl1,n,lenw)
      nl1=nl1-1
c     Add part of the filename after the '.' (if any)
      if (namleni .gt. nl0) then
        numfile(nl1+1:nl1+namleni-nl0)=inpfile(nl0+1:namleni)
        nl1=nl1+namleni-nl0
      end if
      namlenn=nl1
      return
2000  format(' Output file names should be of the form x',a1,'*',a)
      end
      subroutine unpackconf(line,nlines,ncol,inpfile,namleni,nconfig,
     -  molname,molnamelen,numsel,iconfsel,numconsec,maxconfsel,
     -  nextconfsel,incr_fileno,ioverallconf,ionefile,
     -  natsfirst,nats,iuunp,maxrec)
c     Unpack the next conformation from the stack
      dimension iconfsel(maxconfsel)
      character*(*) molname
      character*132 line(maxrec)
      character*200 inpfile,outfile
c     print *,'UNPACKCONF nextconfsel,nconfig,ionefile=',
c    -                    nextconfsel,nconfig,ionefile
      if (numsel .gt. maxconfsel) then
        print *,'PROGRAM ERROR: illegal numsel (',numsel,');',
     -    ' maxconfsel=',maxconfsel
        stop
      end if
      if (numsel .gt. 0) then
        if (nconfig .eq. iconfsel(nextconfsel)) then
c         Selection found - increment nextconfsel
          nextconfsel=nextconfsel+1
        else
c         Configuration not selected - skip
          return
        end if
      end if
c     print *,'Unpackconf nconfig,numsel,nextconfsel=',
c    -  nconfig,numsel,nextconfsel
      if (nconfig .eq. 1) natsfirst=nats
      if (nextconfsel .le. 10) then
        if (nats .ne. natsfirst) write (6,1012) nconfig,nats,natsfirst
      end if
      if (ionefile .eq. 0) then
        if (molnamelen .gt. 0) then
c         Currently only DOCK PDB files have molecule names read
          nl1=molnamelen
          outfile(1:nl1)=molname(1:nl1)
          outfile(nl1+1:nl1+4)='.pdb'
          nl1=nl1+4
        else
          ifnumw=nconfig+incr_fileno
          if (numconsec .gt. 0) ifnumw=nextconfsel-1+incr_fileno
          call filenamenum(inpfile,namleni,outfile,nl1,ifnumw,+2)
        end if
        call openfile(iuunp,0,'output',6,'new',outfile,nl1,notfnd,2,1,1,
     -    0,ioverallconf)
        if (notfnd .eq. 1) then
          write (6,1011) outfile(1:nl1)
          call askyn('Do you want to overwrite all existing files',43,
     -      1,-1,ioverallconf,0)
          if (ioverallconf .eq. 0) stop
          call openfile(iuunp,0,'output',6,'new',outfile,nl1,notfnd,2,1,
     -      1,0,ioverallconf)
        end if
        write (6,1010) outfile(1:nl1)
      else if (nextconfsel .eq. 2) then
c       Open overall file (input filename with_sel added to it)
        outfile=inpfile
        ic=namleni
        do while (ic .gt. 1 .and. inpfile(ic:ic) .ne. '.')
          ic=ic-1
        end do
        if (ic .gt. 1) then
          outfile(ic:ic+3)='_sel'
          outfile(ic+4:namleni+4)=inpfile(ic:namleni)
        else
          outfile(namleni+1:namleni+4)='_sel'
        end if
        nl1=namleni+4
        call openfile(iuunp,0,'output',6,'new',outfile,nl1,notfnd,0,1,
     -    1,0,ioverallconf)
        write (6,1010) outfile(1:nl1)
      end if
      lf=1
      if (line(1)(1:3) .eq. 'TER' .or. line(1)(1:3) .eq. 'END') lf=2
      do i=lf,nlines
        call writeline(iuunp,line(i),1,ncol,0)
      end do
      if (ionefile .eq. 0) close (iuunp)
      return
1010  format(' Writing file: ',a)
1011  format(' Problem opening file: ',a)
1012  format(' NOTE: # of atoms in configuration',i7,'=',i6,
     -  'in the first conf:',i6) 
      end
      subroutine genrot(rot,pi,iax,angle,igl)
      dimension rot(3,3)
      character*1 ans
      character*6 rq
      print *,'Rotating the structure (if required)'
      call quiz(ans,iax,' ',' ',0,'rotation type',13,0,5,6,igl,0)
c     print *,'ans=',ans
      if (ans .eq. 'i') then
        iax=0
      else if (ans .eq. 'q') then
        iax=-1
        return
      end if
      if (iax .gt. 0) then
        call getreal(
     -    'Angle (+: clockwise, -: counterclockwise, viewed from +'
     -    //ans//' axis)',62,999999.0,angle,0,0)
        angler=angle*(pi/180.0)
        iz=iax
        ix=mod(iz,3)+1
        iy=mod(iz+1,3)+1
        call unitmat(rot)
c       print *,'ix,iy,iz=',ix,iy,iz
        rot(ix,ix)=cos(angler)
        rot(ix,iy)=sin(angler)
        rot(iy,ix)=-rot(ix,iy)
        rot(iy,iy)=rot(ix,ix)
      else
c       Input rotation matrix
        do i=1,3
          do j=1,3
            write (rq,1003) i,j
            call getreal(rq,6,999999.0,rot(i,j),0,00)
          end do
        end do
      end if
c      do i=1,3
c        write (6,7777) i,(rot(j,i),j=1,3)
c7777    format(i3,' rot i =',3f7.4)
c      end do
      return
1003  format('R(',i1,',',i2,')')
      end
      subroutine modify(inpcrdtyp,c,n,nslt,line,index,iatno,nneig,ineig,
     -  isegno,iresno,charge,natomadd,igl,pi,maxneig,maxrec)
      dimension c(3,maxrec),index(maxrec),iatno(maxrec),nneig(maxrec),
     -  ineig(maxneig,maxrec),isegno(maxrec),iresno(maxrec),
     -  charge(maxrec)
      character*4 atnam,pflab
      character* 132 line(maxrec)
      character*2 iatnm2
      common /atnam/ aw(99),nval(99),nvalmax(99),mmofan(99),
     -  mmatno(64),iatnm2(99)
      character*5 crdext
      common /iotypes/ iocha,iochaex,iobpdb,iocpdb,ioa3pdb,ioa4pdb,
     -  iommod,iommc,iommc4,iogro,iomol2,iomae,ioins,ionxyz,
     -  iosxyz,iosxyzrq,iograsp,iofull,lext(17),crdext(17)
      character*1 ans,modtyp
      character*2 ATD4typ
      character*80 question
      dimension c12(3),iadef(3)
      data ia4 /0/
      character*21 ngdefnum
      data ngdefnum /'Defining neighbour # '/,ATD4typ /'  '/
      if (inpcrdtyp .eq. iomol2) then
        print *,'Sorry, molecule editing with mol2 format is not ',
     -    'implemented'
         return
      end if
      call setcol(inpcrdtyp,ncol,idcol,ialtcol,
     -  inamcol1,inamcol2,irescol1,irescol2,iccol1,iccol2,
     -  iresncol1,iresncol2,iseqncol1,iseqncol2,isegcol1,isegcol2,
     -  iresidcol1,iresidcol2,iqcol1,iqcol2,ipotcol1,ipotcol2,
     -  iocccol1,iocccol2,ichemcol1,ichemcol2,nrescol,nresncol,
     -  nsegcol,nnamcol,iofull)
      chargech=0.0
      nocharge=1
      if (iqcol2 .gt. iqcol1) nocharge=0
      nochargeask=1
      do while (.true.)
        ifail=0
        atnam='    '
        call quiz(modtyp,iansmut,' ',' ',0,'modification type',17,
     -    0,5,6,igl,89)
        if (modtyp .ne. 'q' .and. modtyp .ne. 'c' .and. modtyp .ne. 'r'
     -      .and. nochargeask .eq.  1) then
          if (inpcrdtyp .eq. iocha .or. inpcrdtyp .eq. iochaex)
     -      call askyn('Do you have charges in the weight column',40,
     -        0,-1,nocharge,0)
          if (ispdb(inpcrdtyp) .eq. 1) call askyn(
     -        'Do you have charges in the temperature factor column',52,
     -        0,+1,nocharge,0)
          nochargeask=0
        end if
        if (modtyp .eq. 'm') then
          call getint('Atom number to replace',22,0,1,nslt,ia,0)
          call listatom(line,index,iatno,ia,inpcrdtyp,iofull,
     -      'Atom to mutate',14,n,maxrec)
          question='Name'//' of the new atom'
          lq=20
          call getname(atnam,len,question,lq,4,0)
          iatno(ia)=ianum(atnam,1,nnamcol)
          if (nneig(ia) .eq. 1) then
            ia1=ineig(1,ia)
            call listatom(line,index,iatno,ia1,inpcrdtyp,iofull,
     -        'Root atom     ',14,n,maxrec)
            call getint('Valence',7,nval(iatno(ia)),1,8,newn,0)
            call defaultbondl(newn,nneig(ia1),iatno(ia),iatno(ia1),
     -        r12)
            call getreal('New distance',12,r12,rij,1,0)
            call arrdiff(c(1,ia),c(1,ia1),c12,3)
            rnorm=sqrt(scprod(c12,c12))
            do k=1,3
              c(k,ia)=c(k,ia1)+rij*c12(k)/rnorm
            end do
          else
            write (6,1001) ia
          end if
        else if (modtyp .eq. 'a' .or. modtyp .eq. 'b' .or.
     -           modtyp .eq. 't') then
          call getint(
     -      'Index of the atom that the new atom is bonded to',48,
     -      0,1,nslt,ia1,0)
          call listatom(line,index,iatno,ia1,inpcrdtyp,iofull,
     -      'Atom R1         ',16,n,maxrec)
          question='Name'//' of the new atom'
          lq=20
          call getname(atnam,len,question,lq,4,0)
          iatnoadd=ianum(atnam,1,nnamcol)
          if (iatno(ia1) .eq. 1) then
            write (6,1002) ia1
            ifail=1
          end if
          if (modtyp .eq. 'a') then
            write (6,1000)
            call findroot('R2',ia1,0,iatno,nneig,ineig,line,index,
     -        inpcrdtyp,iofull,ia2,n,ifail,maxneig,maxrec)
            call findroot('R3',ia2,ia1,iatno,nneig,ineig,line,index,
     -        inpcrdtyp,iofull,ia3,n,ifail,maxneig,maxrec)
            if (ifail .eq. 0) then
              call getint('Valence',7,nval(iatnoadd),1,8,newn,0)
              call defaultbondl(nneig(ia1)+1,newn,iatno(ia1),iatnoadd,
     -          r12)
              call getreal('R1-X distance',13,r12,rij,1,0)
100           call quiz(ans,ians,' ',' ',0,'R2-R1-X angle',13,0,5,6,
     -          igl,0)
              if (ans .eq. 'i' .or. ans .eq. 'I') then
                call getreal('R2-R1-X angle',13,999999.0,aijk,1,0)
              else if (ans .eq. '3') then
                aijk=180.0-acos(1.0/3.0)*180.0/pi
              else if (ans .eq. '2') then
                aijk=120.0
              else if (ans .eq. '1') then
                aijk=180.0
              else
                print *,'Invalid answer'
                go to 100
              end if
200           call quiz(ans,ians,' ',' ',0,
     -          'R3-R2-R1-X torsion angle',24,0,5,6,igl,0)
              if (ans .eq. 'i' .or. ans .eq. 'I') then
                call getreal('R3-R2-R1-X torsion',18,999999.0,tijkl,0,0)
              else if (ans .eq. 'c' .or. ans .eq. 'C') then
                tijkl=0.0
              else if (ans .eq. 't' .or. ans .eq. 'T') then
                tijkl=180.0
              else if (ans .eq. '+') then
                tijkl=60.0
              else if (ans .eq. '-') then
                tijkl=-60.0
              else if (ans .eq. 'p' .or. ans .eq. 'P') then
                tijkl=120.0
              else if (ans .eq. 'm' .or. ans .eq. 'M') then
                tijkl=-120.0
              else
                print *,'Invalid answer'
                go to 200
              end if
              ia=n+1
              call addatom(1,c(1,ia3),c(1,ia3),c(1,ia2),c(1,ia1),
     -          c(1,ia),rij,aijk,tijkl,0.0,pi,ifail)
            end if
          else if (modtyp .eq. 'b' .or. modtyp .eq. 't') then
            if (modtyp .eq. 'b') nndef=2
            if (modtyp .eq. 't') nndef=3
            call zeroiti(iadef,0,3)
            if (nneig(ia1) .ne. nndef)
     -        write (6,1007) ia1,nneig(ia1),nndef
            do ind=1,nndef
              write (ngdefnum(21:21),1003) ind
              if (ind .le. nneig(ia1)) then
c               Neighbor exists
                iadef(ind)=ineig(ind,ia1)
                call listatom(line,index,iatno,iadef(ind),inpcrdtyp,
     -            iofull,ngdefnum,21,n,maxrec)
               else
C               No bonded neighbor - ask for one
                write (6,1004) ind
                call getint('Index of the next definig atom',30,0,1,
     -            nslt,iadef(ind),0)
                call listatom(line,index,iatno,iadef(ind),inpcrdtyp,
     -            ioins,ngdefnum,21,n,maxrec)
               end if
            end do
            ia2=iadef(1)
            ia3=iadef(2)
            ia4=iadef(3)
            if (ia4 .eq. 0) ia4=ia3
            call getint('Valence',7,nval(iatnoadd),1,8,newn,0)
            call defaultbondl(nneig(ia1)+1,newn,iatno(ia1),iatnoadd,r12)
            call getreal('R1-X distance',13,r12,rij,1,0)
            bend=0.0
            if (nndef .eq. 2) call getreal(
     -        'Angle between R1-X and the negative bisector',44,0.0,
     -        bend,1,000)
            ia=n+1
            call addatom(nndef,c(1,ia4),c(1,ia3),c(1,ia2),c(1,ia1),
     -        c(1,ia),rij,aijk,tijkl,bend,pi,ifail)
          end if
          if (ifail .eq. 0) then
            natomadd=natomadd+1
            n=n+1
            nslt=nslt+1
            index(n)=index(n-1)+1
            line(index(n))=line(index(ia1))
            nneig(n)=1
            ineig(1,n)=ia1
            nneig(ia1)=nneig(ia1)+1
            ineig(nneig(ia1),ia1)=n
            isegno(n)=isegno(ia1)
            iresno(n)=iresno(ia1)
            call blankout(line(index(n)),iresncol1,iresncol2)
            icolw=iresncol1
            call writeint(line(index(n)),icolw,iresno(n),lenw)
            call rightadjustline(line(index(n)),iresncol1,iresncol2)
          end if
        else if (modtyp .eq. 'c') then
C         Create new bond
          call getint('Index of the first atom of the new bond',39,
     -      0,1,nslt,ia1,0)
          call listatom(line,index,iatno,ia1,inpcrdtyp,iofull,
     -          ' ',1,n,maxrec)
          call getint('Index of the second atom of the new bond',39,
     -      0,1,nslt,ia2,0)
          call listatom(line,index,iatno,ia2,inpcrdtyp,iofull,
     -          ' ',1,n,maxrec)
          ibonded=0
          do ia=1,nneig(ia1)
            if (ia2 .eq. ineig(ia,ia1)) ibonded=1
          end do
          if (ibonded .eq. 1) then
            print *,'These atoms are already bonded'
          else
            nneig(ia1)=nneig(ia1)+1
            nneig(ia2)=nneig(ia2)+1
            ineig(nneig(ia1),ia1)=ia2
            ineig(nneig(ia2),ia2)=ia1
          end if
        else if (modtyp .eq. 'q') then
          if (natomadd .gt. 0) then
            print *,natomadd,' atoms were added'
          end if
          if (nocharge .eq. 0) write (6,1006) chargech
          return
        end if
        if (ifail .eq. 0) then
c         Specify properties of the new atom
          line(index(ia))(inamcol1:inamcol2)=atnam(1:nnamcol)
          if (ipotcol1 .le. ipotcol2) then
            question='Potential label'//' of the new atom'
            lq=31
            pflab='    '
            call getname(pflab,len,question,lq,ipotcol2-ipotcol1+1,0)
            line(index(ia))(ipotcol1:ipotcol2)=
     -        pflab(1:ipotcol2-ipotcol1+1)
          end if
          if (nocharge .eq. 0) then
            if (modtyp .eq. 'm') then
              read (line(index(ia))(iqcol1:iqcol2),*) qprev
              chargech=chargech-qprev
            end if
            call getreal('Charge',6,999999.0,q,0,0)
            if (q .lt. 0.0) q=q-0.000001
            if (q .gt. 0.0) q=q+0.000001
            call putreal(line(index(ia))(iqcol1:iqcol2),iqcol2-iqcol1+1,
     -        q,4)
            chargech=chargech+q
            charge(ia)=q
          end if
          if (inpcrdtyp .eq.  ioa4pdb) then
            call getname(ATD4typ,len,'Autodock-4 atom type',20,2,0)
            line(index(ia))(78:79)=ATD4typ
          end if
          if (inpcrdtyp .eq. iocha) then
            icinc=0
            if (n .ge. 1000000) icinc=1
            write (line(index(ia))(iccol1+icinc:iccol2+icinc),1011)
     -        (c(k,ia),k=1,3)
          else if (inpcrdtyp .eq. iochaex) then
            write (line(index(ia))(iccol1:iccol2),1015) (c(k,ia),k=1,3)
          else if (inpcrdtyp .eq. iommc) then
            write (line(index(ia))(iccol1:iccol2),1011) (c(k,ia),k=1,3)
          else if (ispdb(inpcrdtyp) .gt. 0) then
            write (line(index(ia))(iccol1:iccol2),1012) (c(k,ia),k=1,3)
          else if (inpcrdtyp .eq. iommod) then
            write (line(index(ia))(iccol1:iccol2),1013) (c(k,ia),k=1,3)
          else if (inpcrdtyp .eq. iogro) then
            write (line(index(ia))(iccol1:iccol2),1012)
     -        (c(k,ia)/10.0,k=1,3)
          else if (inpcrdtyp .eq. ioins) then
            write (line(index(ia))(iccol1:iccol2),1014) (c(k,ia),k=1,3)
          end if
        end if
      end do
1000  format(' The position of the new atom X will be specified by ',
     -  'specifing ',/,' a sequence of bonded atoms R3-R2-R1-X,',
     -  ' the distance r(R1-X),',/,
     -  ' the angle a(R2-R1-X) and the torsion t(R3-R2-R1-X)')
1001  format(' Atom',i5,' has more than one bond - position will not ',
     -  'change')
1002  format(' Atom',i5,' is a hydrogen - can not attach to it')
1003  format(i1)
1004  format(' Neighbor #',i1,' is undefined')
 
1006  format(' Total charge changed by ',f7.4)
1007  format(' NOTE: atom',i6,' has',i2,' bonded neighbours ',
     -  '(instead of',i2,')')
1011  format(3f10.5)
1012  format(3f8.3)
1013  format(3f12.5)
1014  format(3f15.9)
1015  format(3f10.10)
      end
      subroutine retroinverso(c,nslt,iatnum,line,index,chain,nsegm,
     -  iaincr,inamcol1,inamcol2,iresncol1,iresncol2,irescol1,irescol2,
     -  pi,ifail,nneig,ineig,mask,iout,maxng,maxrec)
      dimension c(3,nslt),iatnum(nslt),index(nslt),nneig(nslt),
     -  ineig(maxng,nslt),mask(nslt)
      dimension cn(3),ca(3),cb(3),cd(3),cg(3),cm_na(3),cm_bd(3),e(3),
     -  rh(3)
      character*1 chain
      character*4 atnam4
      character*8 atnam,resnam,hnname
      character* 132 line(maxrec)
c     print *,'RETROINVERSO nslt=',nslt
      if (nsegm .gt. 1) then
        write (6,1002)
        ifail=1
        return
      end if
      lnam=inamcol2-inamcol1+1
      ifail=0
      nres=0
      nresok=0
      icfound=0
      iofound=0
      infound=0
      ihfound=0
      iafound=0
      ia2=nslt
      frocc=1.0
      bfac=0.0
      if (chain .eq. ' ') chain='A'
      call indexit(mask,1,nslt,0)
      npro=0
      nwr=0
      ia=1
      read (line(index(1))(iresncol1:iresncol2),*,ERR=999) iresninc
      iresninc=iresninc-1
      do ia=nslt,1,-1
        atnam(1:lnam)=line(index(ia))(inamcol1:inamcol2)
        atnam4=atnam(1:4)
c       print *,'IA=',ia,' ATNAM=',atnam(1:lnam)
        if (lnam .eq. 4) atnam(5:8)='    '
        if (lnam .gt. 4) call leftadjustn(atnam,atnam,lnam)
        if (atnam4 .eq. 'C   ' .or. atnam4 .eq. ' C   ') then
          icfound=ia
        else if (atnam4 .eq. 'O   ' .or. atnam4 .eq. ' O   ') then
          iofound=ia
        else if (atnam4 .eq. 'N   ' .or. atnam4 .eq. ' N   ') then
          infound=ia
        else if (atnam4 .eq. 'CA  ' .or. atnam4 .eq. ' CA  ') then
          iafound=ia
        else if (atnam4 .eq. 'H   ' .or. atnam4 .eq. ' H   ' .or.
     -           atnam4 .eq. 'HN  ' .or. atnam4 .eq. ' HN ') then
          ihfound=ia
          hnname=atnam
        end if
        if (ia .eq. 1) then
          iresn=-1
        else
          read (line(index(ia-1))(iresncol1:iresncol2),*,ERR=999) iresn
c         print *,'IRESN=',iresn
          if (ia .eq. nslt) ireso=iresn
        end if
        if (iresn .ne. ireso) then
c         New residue
          nres=nres+1
          ia1=ia
c         Now make the transformation
          resnam(1:irescol2-irescol1+1)=
     -      line(index(ia1))(irescol1:irescol2)
          ndel_extra=0
          if (iresn .eq. -1) then
c           Remove extra hydrogens from N
            nhf=0
            do inn=1,nneig(infound)
              in=ineig(inn,infound)
c             print *,'IN=',in,' atno=',iatnum(in),' nhf=',nhf
              if (iatnum(in) .eq. 1) then
                nhf=nhf+1
                if (nhf .gt. 1) then
                  mask(in)=0
                  ndel_extra=ndel_extra+1
                else
                  ihfound=in
                end if
              end if
            end do
c           print *,'H clean ndel=',ndel_extra
          end if
          if (nres .eq. 1) then
c           Remove extra oxygen from C
            do inn=1,nneig(icfound)
              in=ineig(inn,icfound)
              atnam(1:lnam)=line(index(in))(inamcol1:inamcol2)
c             print *,'IN=',in,' name=',atnam(1:4)
              if (atnam(1:4) .ne. 'O   ' .and. atnam(1:4) .ne. ' O   ')
     -            then
                mask(in)=0
                ndel_extra=ndel_extra+1
              end if
            end do
c           print *,'O clean ndel=',ndel_extra
          end if
c          write (6,9861) nres,ia1,ia2,resnam(1:3),ireso,iresn,
c     -      icfound,infound,iofound,ihfound,iafound
c9861      format(' nres=',i4,' ia1,2=',2i6,' resnam=',a,' ireso,n=',2i4,
c     -      /,' icfound,infound,iofound,ihfound,iafound=',5i6)
          if (icfound*infound*iofound*iafound .eq. 0) then
             print *,'Residue ',ireso,' is missing N, C, CA or O'
             ifail=1
             return
          end if
          hnname=' N      '
          mask(icfound)=0
          mask(infound)=0
          mask(iafound)=0
          mask(iofound)=0
          if (resnam(1:3) .eq. 'PRO') then
c           Special procedure for proline
            npro=npro+1
            ibfound=0
            idfound=0
            igfound=0
            ihfound=0
c           print *,'PRO ia1,ia2=',ia1,ia2
            do i=ia1,ia2
              atnam(1:lnam)=line(index(i))(inamcol1:inamcol2)
              call leftadjustn(atnam,atnam,lnam)
              if (atnam(1:4) .eq. 'CB  ') then
                ibfound=i
              else if (atnam(1:4) .eq. 'CD  ') then
                idfound=i
              else if (atnam(1:4) .eq. 'CG  ') then
                igfound=i
              else if (atnam(1:4) .eq. 'HA  ') then
                ihfound=i
              end if
            end do
            if (ibfound*idfound*igfound*ihfound .eq. 0) then
              print *,'Proline residue ',ireso,
     -          ' has no CB, CD, CG or HA'
              ifail=1
              return
            end if
            nwr=nwr+1
            write (iout,1000) iaincr+nwr,' N  ','PRO',chain,
     -        iresninc+nres,(c(k,icfound),k=1,3),frocc,bfac
            call trnsfr(cn,c(1,icfound),3)
            nwr=nwr+1
            write (iout,1000) iaincr+nwr,' CA ','PRO',chain,
     -        iresninc+nres,(c(k,iafound),k=1,3),frocc,bfac
            call trnsfr(ca,c(1,iafound),3)
            nwr=nwr+1
            write (iout,1000) iaincr+nwr,' CB ','PRO',chain,
     -        iresninc+nres,(c(k,ibfound),k=1,3),frocc,bfac
            call trnsfr(cb,c(1,ibfound),3)
            nwr=nwr+1
            write (iout,1000) iaincr+nwr,' CD ','PRO',chain,
     -        iresninc+nres,(c(k,iofound),k=1,3),frocc,bfac
            call trnsfr(cd,c(1,iofound),3)
c            write (6,9866) icfound,iafound,ibfound,iofound,infound
c9866        format(' icfound,iafound,ibfound,iofound,infound=',5i6)
c           write (6,*) 'cn=',cn
c           write (6,*) 'ca=',ca
c           write (6,*) 'cb=',cb
c           write (6,*) 'cd=',cd
            phirad=dihangl(c,iofound,icfound,iafound,ibfound,0,maxrec)*
     -        180.0/pi
c           print *,'phirad=',phirad,' ',phirad
c           Generate new CG
            if (abs(phirad) .gt. 45.0) then
              print *,'NOTE: Proline ring # ',iresninc+nres,
     -          ' will be wide open'
              call addatom(1,cd,cn,ca,cb,cg,1.0,105.0,phirad,0.0,pi,
     -          ifail)
            else
              do k=1,3
                cm_na(k)=(c(k,infound)+ca(k))/2.0
              end do
c             write (6,*) 'cm_na=',cm_na
              dcg=sqrt(dist2(c(1,igfound),cm_na))
              do k=1,3
                cm_na(k)=(cn(k)+ca(k))/2.0
                cm_bd(k)=(cb(k)+cd(k))/2.0
              end do
c             write (6,*) 'cm_na=',cm_na
c             write (6,*) 'cm_bd=',cm_bd
              call arrdiff(cm_bd,cm_na,e,3)
c             write (6,*) 'e=',e
              enorm=sqrt(scprod(e,e))
c             write (6,*) 'dcg=',dcg,' enorm=',enorm
              do k=1,3
                cg(k)=cm_na(k)+dcg*e(k)/enorm
              end do
            end if
c           write (6,*) 'cg=',cg
            nwr=nwr+1
            write (iout,1000) iaincr+nwr,' CG ','PRO',chain,
     -        iresninc+nres,cg,frocc,bfac
c           Generate new hydrogens
            call addatom(2,e,ca,cg,cb,rh,1.0,0.0,0.0,57.0,pi,ifail)
            nwr=nwr+1
            write (iout,1000) iaincr+nwr,' HB2','PRO',chain,
     -        iresninc+nres,rh,frocc,bfac
            call addatom(2,e,ca,cg,cb,rh,1.0,0.0,0.0,-57.0,pi,ifail)
            nwr=nwr+1
            write (iout,1000) iaincr+nwr,' HB3','PRO',chain,
     -        iresninc+nres,rh,frocc,bfac
            call addatom(2,e,cb,cd,cg,rh,1.0,0.0,0.0,57.0,pi,ifail)
            nwr=nwr+1
            write (iout,1000) iaincr+nwr,' HG2','PRO',chain,
     -        iresninc+nres,rh,frocc,bfac
            call addatom(2,e,cb,cd,cg,rh,1.0,0.0,0.0,-57.0,pi,ifail)
            nwr=nwr+1
            write (iout,1000) iaincr+nwr,' HG3','PRO',chain,
     -        iresninc+nres,rh,frocc,bfac
            call addatom(2,e,cn,cg,cd,rh,1.0,0.0,0.0,57.0,pi,ifail)
            nwr=nwr+1
            write (iout,1000) iaincr+nwr,' HD2','PRO',chain,
     -        iresninc+nres,rh,frocc,bfac
            call addatom(2,e,cn,cg,cd,rh,1.0,0.0,0.0,-57.0,pi,ifail)
            nwr=nwr+1
            write (iout,1000) iaincr+nwr,' HD3','PRO',chain,
     -        iresninc+nres,rh,frocc,bfac
            nwr=nwr+1
            write (iout,1000) iaincr+nwr,' HA ','PRO',chain,
     -        iresninc+nres,(c(k,ihfound),k=1,3),frocc,bfac
            nwr=nwr+1
            write (iout,1000) iaincr+nwr,' C  ','PRO',chain,
     -        iresninc+nres,(c(k,infound),k=1,3),frocc,bfac
            nwr=nwr+1
            write (iout,1000) iaincr+nwr,' O  ','PRO',chain,
     -        iresninc+nres,(c(k,idfound),k=1,3),frocc,bfac
          else
            if (ihfound .eq. 0) then
              print *,'Residue ',ireso,' is missing the amide H'
              nht=0
              do i=ia1,ia2
                atnam(1:lnam)=line(index(ia))(inamcol1:inamcol2)
                atnam4=atnam(1:4)
                if (atnam4 .eq. 'H1  ' .or. atnam4 .eq. ' H1  ' .or.
     -              atnam4 .eq. 'H2  ' .or. atnam4 .eq. ' H2  ' .or.
     -              atnam4 .eq. 'H3  ' .or. atnam4 .eq. ' H3  ')
     -           nht=nht+1
              end do
              if (nht .gt. 0) write (6,1002)
              ifail=1
              return
            end if
            mask(ihfound)=0
c           Write new backbone
            nsc=ia2-ia1-4-ndel_extra
            rco=sqrt(dist2(c(1,icfound),c(1,iofound)))
            rnh=sqrt(dist2(c(1,infound),c(1,ihfound)))
            nwr=nwr+1
            write (iout,1000) iaincr+nwr,' N  ',resnam(1:3),chain,
     -        iresninc+nres,(c(k,icfound),k=1,3),frocc,bfac
            call rescale_bl(c(1,icfound),c(1,iofound),cn,rco,rnh)
            nwr=nwr+1
            write (iout,1000) iaincr+nwr,' H  ',resnam(1:3),chain,
     -        iresninc+nres,cn,frocc,bfac
            nwr=nwr+1
            write (iout,1000) iaincr+nwr,' CA ',resnam(1:3),chain,
     -        iresninc+nres,(c(k,iafound),k=1,3),frocc,bfac
            do i=ia1,ia2
              if (mask(i) .gt. 0) then
                nwr=nwr+1
                write (iout,1000) iaincr+nwr,
     -            line(index(i))(inamcol1:inamcol2),resnam(1:3),chain,
     -            iresninc+nres,(c(k,i),k=1,3),frocc,bfac
              end if
            end do
            write (iout,1000) iaincr+nwr,' C  ',resnam(1:3),chain,
     -        iresninc+nres,(c(k,infound),k=1,3),frocc,bfac
            call rescale_bl(c(1,infound),c(1,ihfound),cn,rnh,rco)
            nwr=nwr+1
            write (iout,1000) iaincr+nwr,' O  ',resnam(1:3),chain,
     -        iresninc+nres,cn,frocc,bfac
          end if
          ireso=iresn
          icfound=0
          iofound=0
          infound=0
          ihfound=0
          iafound=0
          ia2=ia1-1
        end if
c       write (77,*) 'ia,ireso,nres=',ia,ireso,nres
      end do
      if (npro .gt. 0) write (6,1001) npro
      return
999   print *,'Illegal record in line'
      print *,line(index(ia))
1000  format('ATOM  ',i5,1x,a4,1x,a3,1x,a1,i4,1x,3x,3f8.3,2f6.2)
1001  format(' NOTE:',i3,' prolines were found - run a minimzation to ',
     -  'correct the distorsions')
1002  format(' It looks like the input is not a single peptide',/,
     -  ' Run each peptide (chain) sperately')
      end
      subroutine rescale_bl(c1,c2,cn,ro,rn)
      dimension c1(3),c2(3),cn(3)
      dimension e(3)
      do k=1,3
        e(k)=(c2(k)-c1(k))/ro
      end do
      do k=1,3
        cn(k)=c1(k)+e(k)*rn
      end do
      return
      end
      subroutine defaultbondl(nni1,nni2,ian1,ian2,r12)
c     Establish default bondlength based on atomic numbers and valences
c     To be extended
      if (ian1 .lt. ian2) then
        nngi1=nni2
        nngi2=nni1
        iatn1=ian2
        iatn2=ian1
      else
        nngi1=nni1
        nngi2=nni2
        iatn1=ian1
        iatn2=ian2
      end if
      r12=999999.0
      if (iatn1 .eq. 6) then
c       Carbon
        if (nngi1 .eq. 4) then
          if (iatn2 .eq. 1) r12=1.08
          if (iatn2 .eq. 6) r12=1.53
        else if (nngi1 .eq. 3) then
c         if (iatn2 .eq. 1) r12=1.03
c         if (iatn2 .eq. 6) r12=1.03
        else if (nngi1 .eq. 2) then
c         if (iatn2 .eq. 1) r12=1.03
c         if (iatn2 .eq. 6) r12=1.03
        end if
      else if (iatn1 .eq. 7) then
c       Nitrogen
        if (nngi1 .ge. 3) then
          if (iatn2 .eq. 1) r12=0.99
          if (iatn2 .eq. 6) r12=1.37
c         if (iatn2 .eq. 7) r12=1.03
        end if
      else if (iatn1 .eq. 8) then
c       Oxigen
        if (nngi1 .eq. 2) then
          if (iatn2 .eq. 1) r12=0.96
          if (iatn2 .eq. 6) r12=1.43
c         if (iatn2 .eq. 7) r12=1.03
c         if (iatn2 .eq. 8) r12=1.03
        else if (nngi1 .eq. 1) then
          if (iatn2 .eq. 6) r12=1.23
c         if (iatn2 .eq. 7) r12=1.03
c         if (iatn2 .eq. 8) r12=1.03
        end if
      else if (iatn1 .eq. 15) then
c       Phosphorus
c       if (iatn2 .eq. 1) r12=1.03
c       if (iatn2 .eq. 6) r12=1.03
c       if (iatn2 .eq. 7) r12=1.03
c       if (iatn2 .eq. 8) r12=1.03
      else if (iatn1 .eq. 16) then
c       Sulphur
        if (iatn2 .eq. 1) r12=0.96
        if (iatn2 .eq. 6) r12=1.81
c       if (iatn2 .eq. 7) r12=1.03
c       if (iatn2 .eq. 8) r12=1.03
      end if
      return
      end
      subroutine findroot(lev,ia,ianoneig,iatno,nneig,ineig,line,index,
     -  inpcrdtyp,iofull,ia1,n,ifail,maxneig,maxrec)
      dimension index(n),iatno(n),nneig(n),ineig(maxneig,n)
      character*2 lev
      character* 132 line(maxrec)
      character*16 lab1,lab2
      dimension iahv(8)
      data lab1 /'Possible R2 atom'/,lab2 /'Index of atom R2'/,
     -  ia2heavy /0/
      if (ifail .gt. 0) return
      lab1(10:11)=lev
      lab2(15:16)=lev
c     print *,'FINDROOT ia=',ia,' inpcrdtyp=',inpcrdtyp,' ix(ia)=',index(ia)
      nnheavy=0
      if (nneig(ia) .eq. 0) then
        write (6,1001) ia,' '
        ifail=1
        return
      end if
      do ja=1,nneig(ia)
        ia1=ineig(ja,ia)
c       print *,'ia,ja,ia1,iatno(ia1)=',ia,ja,ia1,iatno(ia1)
        if (iatno(ia1) .gt. 1 .and. ia1 .ne. ianoneig) then
          call listatom(line,index,iatno,ia1,inpcrdtyp,iofull,lab1,16,n,
     -      maxrec)
          nnheavy=nnheavy+1
          iahv(nnheavy)=ia1
          ia2heavy=ia1
        end if
      end do
      if (nnheavy .gt. 1) then
100     call getint(lab2,16,0,1,n,ia1,46)
        nfound=0
        do ja=1,nnheavy
          if (ia1 .eq. iahv(ja)) nfound=1
        end do
        if (nfound .eq. 0) then
          write (6,1000) ia1,(iahv(ja),ja=1,nnheavy)
          go to 100
        end if
      else if (nnheavy .eq. 1) then
        ia1=ia2heavy
        write (6,1002) ia1,lev
      else
        write (6,1001) ia,' heavy atom '
        ifail=1
        return
      end if
      return
1000  format(' ERROR: index',i6,' is not among indices ',8i6)
1001  format(' ERROR: atom',i6,' has no',a,'neighbor')
1002  format(' Atom',i6,' will be used for ',a)
      end
      subroutine listatom(line,index,iatno,ia,inpcrdtyp,iofull,lab,llab,
     -  n,maxrec)
      dimension index(n),iatno(n)
      character* 132 line(maxrec),ll
      character*(*) lab
      character*4 pflab
      character*12 qlab
      call setcol(inpcrdtyp,ncol,idcol,ialtcol,
     -  inamcol1,inamcol2,irescol1,irescol2,iccol1,iccol2,
     -  iresncol1,iresncol2,iseqncol1,iseqncol2,isegcol1,isegcol2,
     -  iresidcol1,iresidcol2,iqcol1,iqcol2,ipotcol1,ipotcol2,
     -  iocccol1,iocccol2,ichemcol1,ichemcol2,nrescol,nresncol,
     -  nsegcol,nnamcol,iofull)
      ll=line(index(ia))
      pflab='    '
      qlab='            '
      nqcol=iqcol2-iqcol1+1
      if (nqcol .gt. 0) qlab(1:nqcol)=ll(iqcol1:iqcol2)
      nqcol=max0(1,nqcol)
      if (ipotcol1 .le. ipotcol2) pflab=ll(ipotcol1:ipotcol2)
      write (6,1000) lab(1:llab),ia,ll(inamcol1:inamcol2),
     -  ll(irescol1:irescol2),ll(iresncol1:iresncol2),
     -  iatno(ia),pflab,qlab(1:nqcol)
      return
1000  format(1x,a,i6,' (',a,1x,a,') resnum=',a,' iatnum=',i2,
     -  ' pf=',a,' q=',a)
      end
      subroutine addatom(ityp,r4,r3,r2,r1,x,rij,aijk,tijkl,bend,pi,
     -  ifail)
c     Add one atom with known distance, angle and torsion
      dimension r4(3),r3(3),r2(3),r1(3),x(3)
      dimension c12(3),c13(3),c14(3),c23(3),x0(3),e2(3),e3(3),bs(3)
      dimension p(3,4)
      if (ityp .eq. 1) then
c       Seqential definition
        write (6,1001) rij,aijk,tijkl
        call arrdiff(r1,r2,c12,3)
        call arrdiff(r3,r2,c23,3)
c       print *,'ADDATOM r1=',r1
c       print *,'ADDATOM r2=',r2
c       print *,'ADDATOM r3=',r3
        rnorm12=sqrt(scprod(c12,c12))
        rnorm23=sqrt(scprod(c23,c23))
        if (aijk .lt. 179.9) then
          if (abs(scprod(c12,c23)/(rnorm12*rnorm23)) .gt. 0.999) then
            print *,'Root atoms are colinear - new atom site is ',
     -        'undefined'
            ifail=ifail+1
          end if
          do k=1,3
            c12(k)=c12(k)/rnorm12
            c23(k)=c23(k)/rnorm23
            x0(k)=r1(k)-rij*c12(k)*cos(pi*aijk/180.0)
          end do
          xproj=rij*sin(pi*aijk/180.0)
          call vprd(c12,c23,e3)
          call vprd(e3,c12,e2)
          do k=1,3
            x(k)=x0(k)+xproj*(cos(pi*tijkl/180.0)*e2(k)+
     -        sin(pi*tijkl/180.0)*e3(k))
          end do
        else
c         Atoms r3, r2, r1, and x are colinear
          do k=1,3
            x(k)=r1(k)+rij*c12(k)/rnorm12
          end do
        end if
c       print *,'ADDATOM x=',x
        call trnsfr(p(1,1),r3,3)
        call trnsfr(p(1,2),r2,3)
        call trnsfr(p(1,3),r1,3)
        call trnsfr(p(1,4),x,3)
c       print *,'2,3,4 angle=',angleijk(p,4,2,3,4,6)*180.0/3.1415
c       print *,'1,2,3,4 dih angle=',
c    -    dihangl(p,1,2,3,4,0,100000)*180.0/3.1415
      else if (ityp .eq. 2) then
c       Bisector definition
        write (6,1002) rij
        call arrdiff(r1,r2,c12,3)
        call arrdiff(r1,r3,c13,3)
        rnorm12=sqrt(scprod(c12,c12))
        rnorm13=sqrt(scprod(c13,c13))
        do k=1,3
          c12(k)=c12(k)/rnorm12
          c13(k)=c13(k)/rnorm13
        end do
        colinear=scprod(c12,c13)
        if (colinear .lt. -0.999) then
          print *,'Atoms R2, R1, and R3 are colinear - can not use ',
     -      'bisector definition'
            ifail=ifail+1
        end if
        call arrsum(c12,c13,bs,3)
        rnormbs=sqrt(scprod(bs,bs))
        if (bend .eq. 0.0) then
          do k=1,3
            bs(k)=bs(k)*rij/rnormbs
            x(k)=r1(k)+bs(k)
          end do
        else
          call arrdiff(r2,r3,c23,3)
          call vprd(c23,bs,e3)
          rnorm3=sqrt(scprod(e3,e3))
          rnormbs=sqrt(scprod(bs,bs))
          bendr=bend*pi/180.0
          do k=1,3
            x(k)=r1(k)+
     -        rij*(bs(k)*cos(bendr)/rnormbs+e3(k)*sin(bendr)/rnorm3)
          end do
        end if
      else if (ityp .eq. 3) then
c       Trisector definition
        write (6,1003) rij
        call arrdiff(r1,r2,c12,3)
        call arrdiff(r1,r3,c13,3)
        call arrdiff(r1,r4,c14,3)
        rnorm12=sqrt(scprod(c12,c12))
        rnorm13=sqrt(scprod(c13,c13))
        rnorm14=sqrt(scprod(c14,c14))
        do k=1,3
          c12(k)=c12(k)/rnorm12
          c13(k)=c13(k)/rnorm13
          c14(k)=c14(k)/rnorm14
          bs(k)=c12(k)+c13(k)+c14(k)
        end do
        rnormbs=sqrt(scprod(bs,bs))
        if (rnormbs .lt. 0.01) then
          print *,'Atom R1 is in the plane of R2, R3, and R4 ',
     -      'can not use trisector definition'
            ifail=ifail+1
        end if
        do k=1,3
          bs(k)=bs(k)*rij/rnormbs
          x(k)=r1(k)+bs(k)
        end do
      end if
      return
1001  format(' Adding X: r(X-R1)=',f7.4,' a(R2-R1-X)=',f8.2,
     -  ' t(R3-R2-R1-X)=',f8.2)
1002  format(' Adding X: r(X-R1)=',f7.4,' along the negative bisector',
     -  ' of the R2-R1-R3 angle')
1003  format(' Adding X: r(X-R1)=',f7.4,' along the negative trisector',
     -  ' of the pyuramid with ',/,' base R2, R3, and R3')
      end
      subroutine select(line,nrecdel,idcol,asterisk,n,nslt,index,ixres,
     -  isegcol1,isegcol2,iseqncol1,iseqncol2,inamcol1,inamcol2,
     -  irescol1,irescol2,iqcol1,iqcol2,charge,iatno,nneig,ineig,
     -  indexdel,iout,igl,maxneig,maxrec)
c     Extract parts of the system
      dimension index(n),ixres(n),indexdel(n),charge(n),iatno(n),
     -  nneig(n),ineig(maxneig,n)
      character*1 asterisk,ans,lastans
      character*4 chainid,chainidn,atnam,atnamadj,resnam,resnamadj,
     -  namesel(200)
      character* 132 line(maxrec)
      data ans /' '/
c      write (6,7877) isegcol1,isegcol2,iseqncol1,iseqncol2,
c     -  inamcol1,inamcol2,irescol1,irescol2
c7877  format(' isegcol12=',2i4,' iseqncol12=',2i4,' inamcol12=',2i4,
c     -  ' irescol12=',2i4)
      nsegcol=isegcol2-isegcol1+1
      nrescol=irescol2-irescol1+1
      if (iseqncol2 .gt. iseqncol1) then
        call readint(line(index(nslt)),iseqncol1,iseqncol2,iseqno,1)
      else
        iseqno=nslt
      end if
      maxresno=ixres(n)
      write (6,1000) iseqno,maxresno
      if (iout .gt. 0 .and. iout .ne. 6)
     -  write (iout,1000) iseqno,maxresno
      nkeep=0
      call zeroiti(indexdel,0,n)
      do while (.true.)
        nrecdel0=nrecdel
        lastans=ans
        call quiz(ans,ians,' ',' ',0,'selecting option',16,0,5,6,igl,0)
        if (ans .eq. 'c' .or. ans .eq. 's') then
          if (nsegcol .gt. 0) then
            call blankout(chainid,1,nsegcol)
            if (ans .eq. 'c') then
              call getname(chainid,len,'Chain ID to keep',16,4,0)
              if (iout .gt. 0)
     -          write (iout,2002) 'Keep only',chainid(1:nsegcol)
            else if (ans .eq. 's') then
              call getname(chainid,len,'Chain ID to drop',16,4,0)
              if (iout .gt. 0)
     -          write (iout,2002) 'Drop',chainid(1:nsegcol)
            end if
          else
            print *,'This input format does not have chain ID'
          end if
        else if (ans .eq. 'k') then
          nkeep=nkeep+1
          if (nkeep .gt. 1) then
            write (6,2003)
            call askstop(1)
          else
            call getrange(ifst,999999,ilst,999999,i,0,'atom to keep',
     -        12,n,0)
          end if
          if (iout .gt. 0) write (iout,2000) 'atoms',' ',ifst,ilst
        else if (ans .eq. 'd') then
          call getrange(ifst,999999,ilst,999999,i,0,'atom to drop',12,
     -      n,0)
          if (iout .gt. 0) write (iout,2001) 'atoms',' ',ifst,ilst
        else if (ans .eq. 'r') then
          nkeep=nkeep+1
          if (nkeep .gt. 1) then
            write (6,2003)
            call askstop(1)
          else
            call getrange(ifst,999999,ilst,999999,i,0,
     -        'residue to keep',15,maxresno,0)
          end if
          if (iout .gt. 0) write (iout,2000) 'residues',' ',ifst,ilst
        else if (ans .eq. 'e') then
          call getrange(ifst,999999,ilst,999999,i,0,
     -      'residue to drop',15,maxresno,0)
          if (iout .gt. 0) write (iout,2001) 'residues',' ',ifst,ilst
        else if (ans .eq. 't') then
c         Read atom name list to keep
          call getnamelist(namesel,4,nnamesel,'Atoms names to use',18,
     -      200)
          write (6,2004) 'Atom',(namesel(i),i=1,nnamesel)
        else if (ans .eq. 'u') then
c         Read residue name list to keep
          call getnamelist(namesel,nrescol,nnamesel,
     -      'Residue names to use',12,200)
          write (6,2004) 'Residue',(namesel(i),i=1,nnamesel)
        else if (ans .eq. 'v') then
c         Drop all solvents
          if (n .eq. nslt)
     -      print *,'There are no solvents in the system - check the ',
     -        'solvent residue name'
        else if (ans .eq. 'q') then
          if (nrecdel .eq. n) then
            print *,'NOTE: all atoms were deleted'
            call askstop(-1)
          else if (nrecdel .eq. 0 .and. lastans .ne. 'v') then
            print *,'NOTE: no atom was deleted'
            call askstop(-1)
          end if
          return
        else if (ans .eq. 'a') then
          if (iout .gt. 0) write (iout,2000) 'the alpha carbons'
        else if (ans .eq. 'b') then
          if (iout .gt. 0) write (iout,2000) 'the backbone'
        else if (ans .eq. 'h') then
          if (iout .gt. 0) then
            write (iout,2001) 'the aliphatic hydrogens'
            if (iqcol2 .gt. iqcol1) write (iout,*)
     -        'Hydrogen charges will be added to the carbon charge'
          end if
        else if (ans .eq. 'l') then
          if (iout .gt. 0) then
            write (iout,2001) 'all hydrogens'
            if (iqcol2 .gt. iqcol1) write (iout,*)
     -        'Hydrogen charges will be added to the heavy atom charge'
          end if
        end if
        ncfound=0
        ignoreseqno=0
        do ia=1,n
          idrop=0
          if (isegcol2 .ge. isegcol1) then
            chainidn=line(index(ia))(isegcol1:isegcol2)
          else
            chainidn='    '
          end if
          if (iseqncol2 .gt. iseqncol1 .and. ignoreseqno .eq. 0) then
            call readint(line(index(ia)),iseqncol1,iseqncol2,iseqno,1)
          else
            iseqno=ia
          end if
          if (iseqno .gt. 99990 .and. ignoreseqno .eq. 0) then
            ignoreseqno=1
            write (6,*) 'Sequence number read will be ignored'
          end if
          iresno=ixres(ia)
          atnam=line(index(ia))(inamcol1:inamcol2)
          call leftadjust4(atnam,atnamadj)
c          write (77,7778) ia,iseqno,iresno,atnam,atnamadj,
c     -      chainid(1:nsegcol),chainidn(1:nsegcol)
c7778      format(' ia,iseqno,iresno=',3i4,' atnam=',a,' atnamadj=',a,
c     -      ' chainid,n=',a,1x,a)
          if (ans .eq. 'c') then
            if (chainidn(1:nsegcol) .ne. chainid(1:nsegcol)) idrop=1
            if (idrop .eq. 0) ncfound=ncfound+1
          else if (ans .eq. 's') then
            if (chainidn(1:nsegcol) .eq. chainid(1:nsegcol)) idrop=1
            if (idrop .eq. 1) ncfound=ncfound+1
          else if (ans .eq. 'b') then
            if (atnamadj(1:3) .ne. 'CA ' .and. atnamadj(1:2) .ne. 'C '
     -          .and. atnamadj(1:2) .ne. 'O '
     -          .and. atnamadj(1:2) .ne. 'N '
     -          .and. atnamadj(1:2) .ne. 'H '
     -          .and. atnamadj(1:3) .ne. 'HN ') idrop=1
c            write (77,9781) ia,atnam,atnamadj(1:3),idrop
c9781        format(i6,' atnam=',a,' atnamadj=',a,' idrop=',i2)
          else if (ans .eq. 'a') then
            if (atnamadj(1:3) .ne. 'CA ') idrop=1
          else if (ans .eq. 't') then
            idrop=1
            do i=1,nnamesel
              if (atnamadj(1:4) .eq. namesel(i)) idrop=0
            end do
          else if (ans .eq. 'u') then
            resnam(1:nrescol)=line(index(ia))(irescol1:irescol2)
            call leftadjustn(resnam,resnamadj,nrescol)
            idrop=1
            do i=1,nnamesel
              if (resnamadj(1:nrescol) .eq. namesel(i)(1:nrescol))
     -          idrop=0
            end do
          else if (ans .eq. 'h' .or. ans .eq. 'l') then
            if (iatno(ia) .eq. 1) then
              if (nneig(ia) .gt. 0) then
                iac=ineig(1,ia)
                if (iatno(ineig(1,ia)) .eq. 6 .or. ans .eq. 'l') then
                  idrop=1
                  if (iqcol2 .gt. iqcol1)
     -              charge(iac)=charge(iac)+charge(ia)
                end if
              else
                print *,'Atom ',ia,' has no neighbour'
                call askyn('Do you want to keep it',22,1,-1,ikeep,0)
                if (ikeep .eq. 0) idrop=1
              end if
            end if
          else if (ans .eq. 'k') then
            if (iseqno .lt. ifst .or. iseqno .gt. ilst) idrop=1
          else if (ans .eq. 'd') then
            if (iseqno .ge. ifst .and. iseqno .le. ilst) idrop=1
          else if (ans .eq. 'r') then
            if (iresno .lt. ifst .or. iresno .gt. ilst) idrop=1
          else if (ans .eq. 'e') then
            if (iresno .ge. ifst .and. iresno .le. ilst) idrop=1
          else if (ans .eq. 'v') then
            if (ia .gt. nslt) idrop=1
          end if
c         if (idrop .gt. 0 .and.
c    -       line(index(ia))(idcol:idcol) .ne. asterisk) then
c           nrecdel=nrecdel+1
c           line(index(ia))(idcol:idcol)=asterisk
c         end if
          if (idrop .gt. 0 .and. indexdel(ia) .eq. 0) then
            nrecdel=nrecdel+1
            indexdel(ia)=1
            line(index(ia))(idcol:idcol)=asterisk
          end if
        end do
        if (ans .eq. 'c' .or. ans .eq. 's') then
          if (ncfound .gt. 0) print *,'Number of chain ',
     -      chainid(1:nsegcol),' atoms=',ncfound
          if (ncfound .eq. 0) print *,'NOTE: no chain ',
     -      chainid(1:nsegcol),' atoms were found'
        end if
        print *,(nrecdel-nrecdel0),' atoms deleted in this step'
        if (ans .eq. 'h' .and. iqcol2 .gt. iqcol1) then
c         Write back charges into line
          do ia=1,n
            call blankout(line(index(ia)),iqcol1,iqcol2)
            if (iqcol2-iqcol1 .gt. 6)  then
              write (line(index(ia))(iqcol2-8:iqcol2),1003) charge(ia)
            else
              write (line(index(ia))(iqcol2-5:iqcol2),1002) charge(ia)
            end if
          end do
        end if
      end do
1000  format(' Selecting atoms from the system',/,' Number of solute ',
     -  'atoms=',i6,' Largest solute residue number=',i6)
1002  format(f6.3)
1003  format(f9.5)
2000  format(' Keep only ',a,a,'in the range [',i6,',',i6,']')
2001  format(' Delete ',a,a,'in the range [',i6,',',i6,']')
2002  format(1x,a,' chain/segment ',a)
2003  format(' Only one range-keeping operation is meaningful.',/,
     -  ' For multiple ranges, use multiple deleting operationa')
2004  format(1x,a,' names to use:',/,
     -  (10(1x,a4)))
      end
      subroutine getrange(ifst,ifstdef,ilst,ilstdef,incr,incrask,
     -  question,lquestion,maxval,ihelp)
      character*(*) question
      character*80 line
c     Input a range
c     print *,'GETRANGE ifst,ifstdef,ilst,ilstdef=',
c    - ifst,ifstdef,ilst,ilstdef
c     print *,'GETRANGE maxval=',maxval
      line(7:6+lquestion)=question(1:lquestion)
100   line(1:6)='First '
      call getint(line,6+lquestion,ifstdef,1,maxval,ifst,ihelp)
      line(1:6)='Last  '
      call getint(line,6+lquestion,ilstdef,1,maxval,ilst,ihelp)
      if (ilst .lt. ifst) then
        print *,'Invalid range'
        go to 100
      end if
      if (incrask .gt. 0) then
101     call getint('Increment',9,1,1,ilst-ifst+1,incr,47)
        if (incr .lt. 1) then
          print *,'Invalid increment'
          go to 101
        end if
      end if
      return
      end
      subroutine nnupdate(index,indexn,indexo,n,nmax,line,isort,maxrec)
      dimension index(nmax),indexn(nmax),indexo(nmax)
      character* 132 line(maxrec)
c     Change atomnumbers in bond list
      do ia=1,n
        do ib=1,6
          ic1=6+(ib-1)*8
          ic2=ic1+4
          read (line(index(ia))(ic1:ic2),1000) iold
c         if (iold .ne. 0) write (6,888) ia,index(ia),ib,ic1,ic2,iold
c888      format(' ia,index(ia),ib=',3i3,' ic1,2=',2i3,' iold=',i3)
          if (iold .gt. 0) then
c           print *,'isort,indexo(iold),indexn(iold)=',
c    -         isort,indexo(iold),indexn(iold)
            if (isort .eq. 0) then
              if (iold .gt. 0)
     -          write (line(index(ia))(ic1:ic2),1000) indexn(iold)
            else
              if (indexo(iold) .gt. 0)
     -          write (line(index(ia))(ic1:ic2),1000) indexo(iold)
            end if
          end if
        end do
      end do
      return
1000  format(i5)
      end
      subroutine findixsort(list,ifrst,nlist,intg,ix,itry)
      dimension list(nlist)
c     Find intg in the sorted list
      imin=ifrst
      imax=nlist
      ix=0
      if (imin .gt. imax) then
        itry=imin
        return
      end if
      do while (imax-imin .gt. 1)
        itry=(imax+imin)/2
        if (list(itry) .eq. intg) then
          ix=itry
          return
        else if (list(itry) .gt. intg) then
          imax=itry
        else
          imin=itry
        end if
      end do
      itry=imax
      if (imax .eq. imin) then
        if (list(itry) .eq. intg) ix=itry
      else
        if (list(imin).eq. intg) then
          ix=imin
        else if (list(imax).eq. intg) then
          ix=imax
        end if
      end if
      return
      end
      subroutine mergerec(line,index,indexo,isegno,iresncol1,iresncol2,
     -  m1,m2,n1,n2,iresn,ireso,isegn,n,maxrec)
c#    MMC routine 127 lstmod: 01/08/88
c*****Merge two sets for the sorting
      character* 132 line(maxrec)
      dimension index(n),indexo(n),isegno(n),iresn(n),ireso(n),isegn(n)
c     i,j: counters for the first and second part, resp.
c     k: counter for the merged array
c     print *,'m1,m2,n1,n2,n=',m1,m2,n1,n2,n
      i=m1
      j=n1
      k=1
20    if (i .le. m2 .and. j .le. n2) then
c       Pick value from first or second part, depending on the comparison
        if (isegno(i) .gt. isegno(j)) then
          idiff=1
        else if (isegno(i) .lt. isegno(j)) then
          idiff=-1
        else
c         Compare residue numbers since segment id's were identical
          call readint(line(index(i)),iresncol1,iresncol2,numi,2)
          call readint(line(index(j)),iresncol1,iresncol2,numj,2)
          if (numi .gt. numj) then
            idiff=1
          else
            idiff=0
          end if
        end if
        if (idiff .eq. 1) then
          iresn(k)=index(j)
          ireso(k)=indexo(j)
          isegn(k)=isegno(j)
          j=j+1
        else
          iresn(k)=index(i)
          ireso(k)=indexo(i)
          isegn(k)=isegno(i)
          i=i+1
        end if
        k=k+1
        go to 20
      else
        if (i .le. m2) then
c         Leftover in the first part
          do l=i,m2
            iresn(k)=index(l)
            ireso(k)=indexo(l)
            isegn(k)=isegno(l)
            k=k+1
          end do
        end if
        if (j .le. n2) then
c         Lefotver in the second part
          do l=j,n2
            iresn(k)=index(l)
            ireso(k)=indexo(l)
            isegn(k)=isegno(l)
            k=k+1
          end do
        end if
      end if
c     Move back merged data into index
      k=0
      do l=m1,n2
        k=k+1
        index(l)=iresn(k)
        indexo(l)=ireso(k)
        isegno(l)=isegn(k)
      end do
      return
      end
      subroutine mrgsrt(iout,indexx,value,n,ifa,ila,itemp,temp,maxt)
c*****Sort the indexx and value array in the order of increasing value(i)
      dimension indexx(n),value(n)
      dimension ifa(maxt),ila(maxt),itemp(maxt),temp(maxt)
c     print *,'MRGSRT n,maxt=',n,maxt
      if (n .eq. 0 .or. n .eq. 1) return
      if (n .gt. maxt) then
        write (iout,1000) n,maxt
        return
      else if (n .lt. 0) then
        write (iout,1001) n
        return
      end if
c     Individual intervals consist of single elements
      nn=n
      call indexit(ifa,1,n,0)
      call indexit(ila,1,n,0)
c     Merge pairs of intervals
11    nnpair=nn/2
      l=1
      do i=1,nnpair
        call mergelst(indexx,value,ifa(l),ila(l),ifa(l+1),ila(l+1),
     -    itemp,temp,maxt)
        ifa(i)=ifa(l)
        ila(i)=ila(l+1)
        l=l+2
      end do
      if (2*nnpair .ne. nn) then
c       Take care of last (odd) interval
        call mergelst(indexx,value,ifa(nnpair),ila(nnpair),ifa(nn),
     -    ila(nn),itemp,temp,maxt)
        ila(nnpair)=ila(nn)
      end if
      nn=nnpair
      if (nn .gt. 1) go to 11
      return
1000  format(' ERROR: mrgsrt input array length(',i8,') exceeds the ',
     -  'limit:',i6)
1001  format(' PROGRAM ERROR: negative number of elements to sort:',i6)
      end
      subroutine mergelst(indexx,value,m1,m2,n1,n2,ires,res,maxt)
c#    MMC routine 263 lstmod: 06/23/97
c*****Merge two sets for the sorting
      dimension indexx(maxt),value(maxt),ires(maxt),res(maxt)
c     i,j: counters for the first and second part, resp.
c     k: counter for the merged array
      i=m1
      j=n1
      k=1
20    if (i .le. m2 .and. j .le. n2) then
c       Pick value from first or second part, depending on value
        if (value(i) .le. value (j)) then
          res(k)=value(i)
          ires(k)=indexx(i)
          i=i+1
          go to 40
        end if
        res(k)=value(j)
        ires(k)=indexx(j)
        j=j+1
40      k=k+1
        go to 20
      end if
      if (i .le. m2) then
c       Leftover in the first part
        do l=i,m2
          res(k)=value(l)
          ires(k)=indexx(l)
          k=k+1
        end do
      end if
      if (j .le. n2) then
c       Leftover in the second part
        do l=j,n2
          res(k)=value(l)
          ires(k)=indexx(l)
          k=k+1
        end do
      end if
c     Move back merged data into index, value
      k=0
      do l=m1,n2
        k=k+1
        indexx(l)=ires(k)
        value(l)=res(k)
      end do
      return
      end
      block data
      character*100 datapath,datapaths
      common /environment/ npaths,ldatapath,ldatapaths(4),
     -  datapath,datapaths(4)
      character*1 aanames1
      character*2 mmodtoamb
      character*3 aanames3,repats
      common /atnamcon/ mmodtoamb(100),aanames1(58),aanames3(58),
     -  naanames,nnanames,nnammnames,nnames,ixwatnam
      common /pmvol/ pmvaana(58)
      common /represent/ repats(2,50),maxrepat
      character*2 iatnm2
      common /atnam/ aw(99),nval(99),nvalmax(99),mmofan(99),
     -  mmatno(64),iatnm2(99)
      character*4 namfcg
      common /connatdat/ ramax(99),ramax2(99),hlimfac,ianfg(99),
     -  namfcg(100),nrmw
      common /columnlim/ incol(17),iidcol(17),iialtcol(17),
     -  iinamcol(2,17),iirescol(2,17),iiccol(2,17),iiresncol(2,17),
     -  iiseqncol(2,17),iisegcol(2,17),iiresidcol(2,17),iiqcol(2,17),
     -  iipotcol(2,17),iiocccol(2,17),iichemcol(2,17)
      character*8 resnamsv
      common /names/ resnamsv(17)
      character*11 formatname
      common /formats/ iqdconv(19),formatname(17)
      character*4 tanames
      character*8 tnames
      common /tordat/ ntorn,tanames(4,28),tnames(28)
      character*4 ires
      character*8 convdat
      character*200 sfilename
      common /savedat/ mxresdat,maxcondat,ifst(1000),ilst(1000),
     -  nres,iresgen,lsfilename,ires(1000),convdat(7,10000),sfilename
      parameter (MAXFRAMES=50000,MAXCOPY=600)
      common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
     -  increment,increment2,res(2,MAXFRAMES,MAXCOPY),
     -  x0(MAXCOPY),y0(MAXCOPY),nxselres,ixselres(MAXCOPY)
      common /graphics/ igl,npixx,npixy,maxpixx,maxpixy,idwmain,idwplot,
     -  wx,wy,wz,wxdr
      character*5 crdext
      common /iotypes/ iocha,iochaex,iobpdb,iocpdb,ioa3pdb,ioa4pdb,
     -  iommod,iommc,iommc4,iogro,iomol2,iomae,ioins,ionxyz,
     -  iosxyz,iosxyzrq,iograsp,iofull,lext(17),crdext(17)
      real*8 xtlabc,xtlabc0
      common /boxdat/ xtlabc(6),xtlabc0(6),box(3),box0(3),edge_gen(3,3),
     -  cell0(3,27),cell(3,27),cellalt(3,27),
     -  ncell,ioppbc,noboxinfoar,noboxinfow,noboxrep,
     -  istuner,iboxtypfound,ixcrd(3),ixang(3),ixyzhex(3),
     -  ixyzhextraj(3),isizewarn
      common /t_test/ t_test_CI_1(5),t_test_CI_2(5),t_test_table(5,30)
      integer*4 tab4,ctrlM4
      common /specchar/ tab4,ctrlM4
      character*1 tab,ctrlM
      common /tab/ tab,ctrlM
      common /askhex/ iaskhex(4),ishex(4)
      character*1 xyz
      common /axislab/ xyz(3)
      character*1 abc,digits,hexdigits
      common /charactersets/ ihex(25),abc(62),digits(14),hexdigits(25)
      character*3 pbcres
      common /pbcresname/ pbcres(10)
      character*11 trajformatname
      common /trajectory/ nmmccheck,iftrajtyp(6),trajformatname(6)
      common /solvres/ iaskdiffres,idiffres
      character*57 RTFtyps
      common /explainRTF/ RTFtyps(4)
      character*1 typc
      character*21 ssname
      common /dsspnames/ lssname(9),ssname(9),typc(9)
      character*2 cvffname
      character*4 charmmname
      common /cvff/ maxcvfftyp,ncvfftyp,iambig(100),charmmname(100),
     -  cvffname(100)
      character*40 clstyp
      common /cluster_typ/ nclstyp,inumclst(9),ireadcutoff(9),
     -  lclstyp(9),clstyp(9)
c     tab4: b'00001001000010010000100100001001'
      data tab4 /151587081/
c     ctrlM4: b'00001101000011010000110100001101'
      data ctrlM4 /218959117/
      data iaskhex /4*1/,ishex /4*0/
      data abc /'A','B','C','D','E','F','G','H','I','J','K','L',
     -          'M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
     -          'a','b','c','d','e','f','g','h','i','j','k','l',
     -          'm','n','o','p','q','r','s','t','u','v','w','x','y','z',
     -          '0','1','2','3','4','5','6','7','8','9'/
      data digits /'0','1','2','3','4','5','6','7','8','9',
     -             ' ','-','+','.'/
      data hexdigits /'0','1','2','3','4','5','6','7','8','9',
     -             'a','b','c','d','e','f','A','B','C','D','E','F',
     -             ' ','-','+'/
      data ihex/0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,10,11,12,13,14,15,
     -  0,0,0/
      data t_test_CI_1 /0.10,0.05,0.025,0.01,0.05/
      data t_test_CI_2 /0.20,0.10,0.05,0.025,0.01/
      data t_test_table /
     -  0.325,6.314,12.706,31.821,63.657,
     -  0.289,2.920,4.303,6.965,9.925,
     -  0.277,2.353,3.182,4.541,5.841,
     -  0.271,2.132,2.776,3.747,4.604,
     -  0.267,2.015,2.571,3.365,4.032,
     -  0.265,1.943,2.447,3.143,3.707,
     -  0.263,1.895,2.365,2.998,3.499,
     -  0.262,1.860,2.306,2.896,3.355,
     -  0.261,1.833,2.262,2.821,3.250,
     -  0.260,1.812,2.228,2.764,3.169,
     -  0.260,1.796,2.201,2.718,3.106,
     -  0.259,1.782,2.179,2.681,3.055,
     -  0.259,1.771,2.160,2.650,3.012,
     -  0.258,1.761,2.145,2.624,2.977,
     -  0.258,1.753,2.131,2.602,2.947,
     -  0.258,1.746,2.120,2.583,2.921,
     -  0.257,1.740,2.110,2.567,2.898,
     -  0.257,1.734,2.101,2.552,2.878,
     -  0.257,1.729,2.093,2.539,2.861,
     -  0.257,1.725,2.086,2.528,2.845,
     -  0.257,1.721,2.080,2.518,2.831,
     -  0.256,1.717,2.074,2.508,2.819,
     -  0.256,1.714,2.069,2.500,2.807,
     -  0.256,1.711,2.064,2.492,2.797,
     -  0.256,1.708,2.060,2.485,2.787,
     -  0.256,1.706,2.056,2.479,2.779,
     -  0.256,1.703,2.052,2.473,2.771,
     -  0.256,1.701,2.048,2.467,2.763,
     -  0.256,1.699,2.045,2.462,2.756,
     -  0.256,1.697,2.042,2.457,2.750/
      data xyz /'X','Y','Z'/
      data igl /0/,npixx/800/,npixy/800/,maxpixx /1271/,maxpixy /991/
      data wx/0.0/,wy /0.0/,wz /0.0/
c     Paths that Simulaid recognizes automatically
      data npaths /4/
      data datapaths /
     -   '/hpc/users/mezeim01/simulaid/',
     -   '/home/mezei/simulaid/',
     -   '/mm/simulaid/',
     -   '/MYPATH/'/
      data ldatapaths /29,21,13,00/
      data ldatapath /0/
      data lext /4*3,2*5,4*3,4,6*3/
      data crdext/'CRD  ','CRD','pdb  ','pdb  ','pdbqs','pdbqt','dat  ',
     -  'slt  ','slt  ','gro  ','mol2 ','mae  ','car  ','dat  ','dat  ',
     -  'dat  ','crg  '/
      data mmodtoamb /'  ','C ','CT','CH','C2','C3','CD','  ','  ','  ',
     -                '  ','  ','  ','  ','O ','OH','  ','O2','OT','  ',
     -                '  ','  ','  ','  ','N ','NT','  ','  ','  ','  ',
     -                'NA','N3','  ','  ','  ','  ','  ','  ','  ','  ',
     -                'HC','HO','H ','H3','  ','  ','  ','  ','S ','  ',
     -                '  ','  ','P ','  ','  ','  ','  ','  ','  ','  ',
     -                '  ','  ','LP','  ','  ','  ','  ','  ','  ','  ',
     -                30*'  '/
      data aanames1 /'C'  ,'H'  ,'I'  ,'M'  ,'S'  ,'V'  ,'A'  ,'G'  ,
     -               'L'  ,'P'  ,'T'  ,'F'  ,'R'  ,'Y'  ,'W'  ,'D'  ,
     -               'N'  ,'B'  ,'E'  ,'Q'  ,'Z'  ,'K'  ,
     -               'C'  ,'H'  ,'H'  ,'H'  ,'H'  ,'H'  ,'H'  ,'H'  ,
     -               'X'  ,'0'  ,
     -               'a'  ,'b'  ,'c'  ,'d'  ,'p'  ,'6'  ,
     -               'A'  ,'C'  ,'G'  ,'U'  ,'T'  ,
     -               'A'  ,'C'  ,'G'  ,'U'  ,'T'  ,
     -               'A'  ,'C'  ,'G'  ,'U'  ,'T'  ,
     -               'A'  ,'C'  ,'G'  ,'U'  ,'T'  /
      data aanames3 /'CYS','HIS','ILE','MET','SER','VAL','ALA','GLY',
     -               'LEU','PRO','THR','PHE','ARG','TYR','TRP','ASP',
     -               'ASN','ASX','GLU','GLN','GLX','LYS',
     -               'CYX','HID','HSD','HSD','HSE','HSP','HIP','HIE',
     -               'UNK','HOH',
c     Macromodel definitions
     -               ' A ',' C ',' G ',' U ',' T ','PHO',
c     Nucleic acids
     -               'ADE','CYT','GUA','URA','THY',
c     Amber nucleic acids
     -               'RA ','RC ','RG ','RU ','RT ',
     -               'RA3','RC3','RG3','RU3','RT3',
     -               'RA5','RC5','RG5','RU5','RT5'/
      data naanames /32/,nnammnames /6/,nnanames /5/,nnames /58/,
     -  ixwatnam /32/
c     AA PMV values from D.P. Kharkoz, Biochemistry Vol. 36, pp 10276-85 (1997)
c     NA PMV values from A. Kundu & N. Kishore, J. Soltn. Chem., Vol 31,
c     37 is added to represent PO4-
c     pp 477-497 (2002); V(G)=V(A)+[V(TYR)-V(PHE)]
      data pmvaana /67.71,93.06,101.92,99.62,54.95,85.05,54.7,37.5,
     -  101.92,74.8,71.12,116.06,121.2,118.0,138.16,68.56,
     -  71.56,68.56,84.0,88.16,84.0,105.7,
     -  67.71,7*93.06,0.0,18.1,6*0.0,
     -  214.0,111.0,216.0,109.0,122.0,
     -  214.0,111.0,216.0,109.0,122.0,
     -  214.0,111.0,216.0,109.0,122.0,
     -  214.0,111.0,216.0,109.0,122.0/
      data mmatno /9*6,4*0,6,5*8,3*0,8,14*7,2*0,7,5*1,2*0,1,16,16,
     -     0,16,15,0,0,9,17,35,53,14,0,38,39,40/
      data mmofan /
     -     48,64,64,64,64,14,40,23,56,64,64,64,64,60,53,52,57,64,64,64,
     -     64,64,64,64,64,64,64,64,64,64,64,64,64,64,58,64,64,64,64,64,
     -     64,64,64,64,64,64,64,64,64,64,64,64,59,64,64,64,64,64,64,64,
     -     64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
     -     64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64/
      data iatnm2/'H ','He','Li','Be','B ','C ','N' ,
     -   'O ','F ','Ne','Na','Mg','Al','Si','P ',
     -   'S ','Cl','Ar','K ','Ca','Sc','Ti','V ',
     -   'Cr','Mn','Fe','Co','Ni','Cu','Zn','Ga',
     -   'Ge','As','Se','Br','Kr',
     -   'Rb','Sr','Y ','Zr','Nb','Mo','Tc','Ru',
     -   'Rh','Pd','Ag','Cd','In','Sn','Sb','Te',
     -   'I ','Xe','Cs','Ba','La',14*'  ',
     -   'Hf','Ta','W ','Re','Os','Ir','Pt','Au',
     -   'Hg','Tl','Pb','Bi','Po','At','Rn',
     -   '  ','q ','LP','El','C1','C2','C3',5*'  ',
     -     'Du'/
      data aw/1.00797,4.0026,6.939,9.0122,10.811,12.01115,
     -  14.0067,15.9994,18.9984,20.17,22.98977,24.305,
     -  26.98154,28.08,30.97376,32.06,35.453,39.94,
     -  39.09,40.08,44.96,47.90,50.94,51.97,54.94,55.85,58.33,
     -  58.71,63.55,65.38,69.72,72.59,74.92,78.96,79.90,83.80,
     -  85.47,87.62,88.91,91.22,
     -  92.91,95.94,98.91,101.07,102.91,106.4,107.87,112.40,114.84,
     -  118.69,
     -  121.75,127.60,126.90,131.3,132.91,137.34,138.91,14*0.0,
     -  178.49,180.95,183.85,186.2,190.2,192.2,195.09,197.97,200.59,
     -  204.37,207.19,208.98,210.0,210.0,222.0,
     -  0.0,3*0.00001,13.01912,14.02709,15.03506,5*0.0,0.00001/
      data nval   /1,0, 1,2,3,4,4,2,1,0, 1,2,3,4,5,6,1,0,
     -  68*0, 4*0,3,2,1,6*0/
      data nvalmax/1,0, 1,2,3,4,4,2,1,0, 1,2,3,4,5,6,1,0,
     -  68*0, 4*0,3,2,1,6*0/
c     Connectivity info constants
      data ramax /1.3,0.0,3*1.60,1.65,3*1.68,0.0,
     -  3*2.1,2*1.8,2.10,1.95,0.0,
c    -  2.0,2*2.3,2*1.8,1.95,1.95,0.0,
     -  18*2.5, 50*2.5, 4*0.0, 3*1.615,6*0.0/
      data hlimfac /0.7/
      data nrmw /0/
c     ianfg(i): if an atom is a functional group by itself, the fcg no
c     of atomic number i.
      data ianfg /0,0,41,43,4*0,61,0,45,47,4*0,63,0,49,51,14*0,65,0,
     -  50*0,
     -  4*0,2,3,4,6*0/
C     data nval   /1,4*0,4,3,2,1,4*0,6,5,2,24*0,3,2,1,7*0/
C     data nvalmax/1,4*0,4,4,2,1,4*0,6,5,25*0,3,2,1,7*0/
      data namfcg    /'>C< ','>CH-','>CH2','-CH3','=C< ','=CH-',
     -  '=CH2','=C= ','-=CH','==C ','>N- ','>NH ','-NH2','=N- ',
     -  '=NH ','-=N ','C=O ','H/CO','-O- ','P-O-','-OH ','>PO2',
     -  '>N+<','N+H1','N+H2','N+H3','COO-','-SH ','-S- ','    ',
     -  10*'    ','  Li',' Li+','  Be','Be2+','  Na',' Na+',
     -  '  Mg','Mg2+','   K','  K+','  Ca','Ca2+',8*'    ',
     -  '   F','  F-','  Cl',' Cl-','  Br',' Br+',32*'    ',
     -  '????','VERR'/
      data maxrepat /37/
      data repats  /'CYS','CA ','HIS','CA ','ILE','CA ','MET','CA ',
     -  'SER','CA ','VAL','CA ','ALA','CA ','GLY','CA ','LEU','CA ',
     -  'PRO','CA ','THR','CA ','PHE','CA ','ARG','CA ','TYR','CA ',
     -  'TRP','CA ','ASP','CA ','ASN','CA ','ASX','CA ','GLU','CA ',
     -  'GLN','CA ','GLX','CA ','LYS','CA ','UNK','CA ','HSD','CA ',
     -  'ADE','P  ','THY','P  ','GUA','P  ','CYT','P  ','URA','P  ',
     -  'A  ','P  ','T  ','P  ','G  ','P  ','C  ','P  ','U  ','P  ',
     -  'TIP','OH2','HOH','O  ','WAT','O  ',26*'   '/
      data iocha /1/,iochaex /2/,iobpdb /3/,iocpdb /4/,ioa3pdb /5/,
     -  ioa4pdb /6/,iommod /7/,iommc/8/,iommc4 /9/,iogro /10/,
     -  iomol2 /11/,iomae /12/,ioins /13/,ionxyz /14/,iosxyz /15/,
     -  iosxyzrq /16/,iograsp /17/
c     incol: number  of characters/line
c     iidcol: position for deletion marker
c     iialtcol: position for alternative location marker (PDB only)
c     iinamcol: atomname range
c     iirescol: residue name range
c     iiccol: x,y,z coordinate range
c     iiresncol: residue number range
c     iiseqcol: atom sequence number range
c     iisegcol: segment id (chain id) range
c     iiresidcol: residue id (Charmm only) range
c     iiqcol: partial charge (for PDB files the B factor) range
c     iipotcol: potential identifier range
c     iiocccol: fractional occupancy range (PDB files)
c     iichemcol: chemical element identifier range
      data incol /80,132,3*80,92,131,80,80,68,80,132,5*80/,
     -  iidcol /16,111,4*12,126,1,1,68,81,111,5*81/,
     -  iialtcol /0,0,4*17,11*0/,
     -  iinamcol /17,20,33,40,13,16,13,16,13,16,13,16,125,128,59,62,
     -    57,60,12,15,08,13,33,40, 1,4,0,-1,0,-1,0,-1,1,4/,
     -  iirescol /12,15,23,30,18,20,18,21,18,21,18,21,120,123,55,58,
     -    53,56,06,10,62,67,23,30, 52,55,0,-1,0,-1,0,-1,0,-1/,
     -  iiccol /21,50,41,100,31,54,31,54,31,54,31,54,53,88,8,37,
     -    06,35,21,44,15,50,41,100, 05,50,0,-1,0,-1,0,-1,7,10/,
     -  iiresncol /6,10,11,20,23,26,23,26,23,26,23,26,90,94,48,52,
     -    46,50,1,5,57,60,13,18, 57,62,0,-1,0,-1,0,-1,0,-1/,
     -  iiseqncol /1,5,1,10,7,11,7,11,7,11,7,11,0,-1,0,-1,
     -    0,-1,16,20,01,06,1,10, 0,-1,0,-1,0,-1,0,-1,0,-1/,
     -  iisegcol /52,55,103,110,22,22,73,76,22,22,22,22,96,96,0,-1,
     -    0,-1,0,-1,00,-1,103,106, 0,-1,0,-1,0,-1,0,-1,0,-1/,
     -  iiresidcol /57,60,113,120,0,-1,0,-1,0,-1,0,-1,0,-1,0,-1,
     -    0,-1,0,-1,0,00,-1,0,-1, -1,0,-1,0,-1,0,-1,0,-1/,
     -  iiqcol /61,70,121,132,61,66,61,66,71,76,71,76,101,109,38,47,
     -    36,45,0,-1,69,76,121,132, 74,80,0,-1,0,-1,0,-1,11,17/,
     -  iipotcol /0,-1,0,-1,0,-1,0,-1,0,-1,0,-1,1,4,2,7,
     -    2,5,0,-1,52,55,0,-1, 62,65,0,-1,0,-1,0,-1,0,-1/,
     -  iiocccol /0,-1,0,-1,55,60,55,60,65,70,55,60,0,-1,0,-1,
     -    0,-1,0,-1,0,-1,113,120, 0,-1,0,-1,0,-1,0,-1,0,-1/,
     -  iichemcol /0,-1,77,78,0,-1,0,-1,0,-1,0,-1,0,-1,0,-1,
     -    0,-1,0,-1,0,-1,108,109, 71,72,0,-1,0,-1,0,-1,0,-1/
      data formatname /'Charmm     ','Charmm-ext ','Brookh. PDB',
     -  'Charmm PDB ','ATD-3 PDBQS','ATD-4 PDBQT','Macromodel ',
     -  'MMC SLTA   ','MMC4 SLTA  ','Gromos/macs','Tripos mol2',
     -  'SCH Maestro','Insight car','Ins nxyz   ','Ins sxyz   ',
     -  'Ins sxyzrq ','Grasp crg  '/
      data trajformatname /'Charmm-DCD ','Amber-crd  ','MMC        ',
     -  'Macromodel ','Macromod-Xc','Amber-CDF  '/
      data iqdconv /1,2,3,3,4,5,6,7,7,8,9,10,11,12,13,14,15,16,17/
      data resnamsv /2*'TIP3 ','HOH  ',2*'TIP3 ','HOH  ',3*'TIP3 ',
     -  'SPC  ','HOH ','WTR  ',5*'TIP3 '/
      data ntorn /28/,tnames /'psi  ','phi  ','omega','chi1 ','chi1 ',
     -  'chi1 ','chi1 ','chi1 ','chi2 ','chi2 ','chi2 ','chi2 ','chi2 ',
     -  'chi2 ','chi2 ','chi2 ','chi2 ','chi3 ',
     -  'chi3 ','chi3 ','chi3 ','chi4 ','chi4 ','chi5 ','chi6 ',
     -  'chi21','chi21','chi21'/
      data tanames /
     -  'N   ','CA  ','C   ','N   ', 'C   ','N   ','CA  ','C   ',
     -  'CA  ','C   ','N   ','CA  ', 'N   ','CA  ','CB  ','CG  ',
     -  'N   ','CA  ','CB  ','OG  ', 'N   ','CA  ','CB  ','OG1 ',
     -  'N   ','CA  ','CB  ','CG1 ', 'N   ','CA  ','CB  ','SG  ',
     -  'CA  ','CB  ','CG  ','CD  ', 'CA  ','CB  ','OG  ','HG  ',
     -  'CA  ','CB  ','SG  ','HG1 ', 'CA  ','CB  ','CG  ','SD  ',
     -  'CA  ','CB  ','CG  ','OD1 ', 'CA  ','CB  ','CG  ','ND1 ',
     -  'CA  ','CB  ','OG1 ','HG1 ', 'CA  ','CB  ','CG  ','CD1 ',
     -  'CA  ','CB  ','CG1 ','CD1 ', 'CB  ','CG  ','CD  ','OE1 ',
     -  'CB  ','CG  ','CD  ','CE  ', 'CB  ','CG  ','SD  ','CE  ',
     -  'CB  ','CG  ','CD  ','NE  ', 'CG  ','CD  ','CE  ','NZ  ',
     -  'CG  ','CD  ','NE  ','CZ  ', 'CD  ','NE  ','CZ  ','NH1 ',
     -  'CE1 ','CZ  ','OH  ','HH  ', 'CA  ','CB  ','CG  ','CD1 ',
     -  'CA  ','CB  ','CG1 ','CD1 ', 'CA  ','CB  ','OG1 ','HG1 '/
      data maxcvfftyp /100/,ncvfftyp /48/
c     List of CVFF atomtypes (1-48). Above 80: alternate conversions
      data cvffname /
     -  'h ',  'd ',  'hn',  'ho',  'hp',  'hs',  'h*',  'c ',
     -  'cg',  "c'",  'cp',  'cr',  'c-',  'ca',  'c3',  'cn',
     -  'c2',  'c1',  'c5',  'c=',  'ct',  'ci',  'n ',  'n2',
     -  'np',  'n3',  'n4',  'n=',  'nt',  'n1',  'ni',  "o'",
     -  'o ',  'o-',  'oh',  'o*',  's ',  's1',  'sh',  'p ',
     -  'si',  'f ',  'cl',  'br',  'Cl',  'Na',  'c+',  'nu',32*'  ',
     -  "o'",  "o'",  "o'",  'c ',  'c ',  'cn',  'np',  'c5',
     -  'c5',  'cp',  'cp',  'c5',  'c5',  'cp',  'oh', 5*'  '/
      data charmmname /
     -  'HA  ','HA  ','H   ','H   ','H   ','H   ','HT  ','CT1 ',
     -  'CT2 ','C   ','CA  ','CA  ','??c-','CT1 ','CT3 ','CT1 ',
     -  'CT2 ','CT1 ','CA  ','C   ','??ct','CA  ','NH2 ','??n2',
     -  '??np','NN5 ','??n4','??n=','??nt','??n1','NR3 ','O   ',
     -  'OS  ','??o-','OH1 ','OT  ','S   ','SM  ','SS  ','??p ',
     -  '??si','??f ','??cl','??br','??Cl','??Na','??c+','??nu',
     -  32*'    ',2*'    ','OB  ','CT2 ','CT3 ','CT2 ',
     -  11*'    ','    ','    ','    '/
      data iambig /
     -  0,0,0,0,0,0,0,0,0,0, 0,0,1,0,0,0,0,0,0,1, 0,1,0,0,0,0,0,0,0,0,
     -  70*0/
      data iftrajtyp /2,1,1,1,1,2/
      data  iaskdiffres /0/,idiffres /0/
      data typc/'P','A','s','p','a','G','H','I','L'/
      data ssname /'Parallel sheet','Antiparallel sheet',
     -  'Mixed, p/A sheet','Double parallel sheet',
     -  'Double antipar sheet',
     -  '3-helix','4-helix','5-helix','Lambda-helix'/
      data lssname /14,18,16,21,20,3*7,12/
      data  ioppbc /-1/, ncell /0/, ixcrd /1,3,6/, ixang /2,4,5/
      data RTFtyps /
     -  ' RTF (Residue/Topology File) files can be                ',
     -  '     Charmm top_*.inp, in the toppar directory of Charmm ',
     -  '     Amber  *.in, in the dat/leap/prep directory of Amber',
     -  '     Gromos/Gromacs *.rtp                                '/
      data pbcres /'CUB','REC','FCC','HXP','   ','TOC','TOA','HCP',
     -  'OCT','IMG'/
      data inumclst /0,1,0,1,1,0,1,0,0/,
     -  ireadcutoff /1,0,0,0,0,1,0,1,1/,
     -  nclstyp /9/,lclstyp /25,32,34,35,34,34,40,29,30/
      data clstyp /
     -  'single link, fixed cutoff               ',
     -  'single link, fixed # of clusters        ',
     -  'single link, several fixed cutoffs      ',
     -  'K-medoids (nodes as cluster centers     ',
     -  'K-means (COMs as cluster centers)       ',
     -  'maximum neigborhood, fixed cutoff       ',
     -  'maximum neigborhood, fixed # of clusters',
     -  'clique clusters, fixed cutoff           ',
     -  'density clusters, fixed cutoff          '/
      end
      block data quizdata
      character*60 promptlist1,promptlist2,promptlist3,promptlist4,
     -  promptlist5,promptlist6,promptlist7,promptlist8,promptlist9,
     -  promptlist10,prompttype
      common /quizinfo/ nqst(500),lqst(500),iqfst(500),iqlst(500),
     -  maxq,init,nprompttype,
     -  promptlist1(50),promptlist2(50),promptlist3(50),
     -  promptlist4(50),promptlist5(50),promptlist6(50),
     -  promptlist7(50),promptlist8(50),promptlist9(50),
     -  promptlist10(50),prompttype(500)
      data init /0/,maxq /500/
c     Free letters for analysis: Z,W,0,5-9
c     Free letters for main menu: B,D,J,K,N,P,R,S,W,X,Y,Z
      data promptlist1 /
     -  '**** optimization type                                      ',
     -  '<S>mallest sphere calculation                               ',
     -  'O<P>timize orientation in bounding cube/rectangle           ',
     -  '<O>ptimize orientation in a periodic cell                   ',
     -  '<Q>uit optimization                                         ',
     -  '**** trajectory/configuration stack packing/unpacking       ',
     -  '<U>npack configurations into (single) file(s)               ',
     -  'Unpac<K> trajectory into single configurations              ',
     -  'Com<B>ine configurations into a trajectory                  ',
     -  'Combine PDB file into a set of <M>ODEL/ENDMDL records       ',
     -  '<Q>uit packing/unpacking selection                          ',
     -  '**** conformation manipulation                              ',
     -  '<E>dit the configuration (delete selected atoms)            ',
     -  '<R>otate, translate, scale and/or center configuration      ',
     -  'Modif<Y> the configuration (mutate/add atoms)               ',
     -  'Replace coordi<N>ates of a configuration from an other conf.',
     -  '<O>verlay structure on a reference structure                ',
     -  'Change a peptide to re<T>ro-inverso                         ',
     -  'Replace c<H>arges of a configuration from an other conf.    ',
     -  'Write P<D>B file of the residue trace (alpha carbons)       ',
     -  'Fi<X> water geometry to experimental geometry               ',
     -  'Trim <W>aters outside a simulation                          ',
     -  'Re<V>erse optimization                                      ',
     -  'Create full crystal <C>ell from the asymmetric unit         ',
     -  'Create <B>iological oligomers from the asymmetric unit      ',
     -  'Gather all crysta<L> contacts of the asymmetric unit        ',
     -  '<Q>uit conformation manipulation selection                  ',
     -  '**** file format                                            ',
     -  '<C>harmm (.CRD)                                             ',
     -  'Charmm 32 <E>xtended (.CRD)                                 ',
     -  'Brookhaven <P>db file                                       ',
     -  'Brookhaven P<D>B, heteroatoms kept, alternates dropped      ',
     -  'Charmm pd<B>, (4-character segid, no chainid)               ',
     -  'Autodock3 PDB<Q>S (PDB + charge and surface coeficients)    ',
     -  'Autodock4 PDBQ<T> (PDB + charge + type [+torsions])         ',
     -  '<M>acromodel                                                ',
     -  'Macromodel/<X>cluster                                       ',
     -  'MMC <S>LTA input (.slt)                                     ',
     -  'MMC<4> SLTA input, old format (.slt)                        ',
     -  'Gr<O>mos/Gromacs (.gro)                                     ',
     -  'Tripos mol<2> (.mol2) - used mostly for input               ',
     -  'Sc<H>rodinger Maestro (.mae) - used only for input          ',
     -  '<I>nsight Biosym (.car)                                     ',
     -  'Insight free format with atomic n<U>mber                    ',
     -  'Insight fre<E> format with atom name                        ',
     -  'Insight f<R>ee format with atom name, residue name, charge  ',
     -  'Gr<A>sp .crg file                                           ',
     -  '**** trajectory file format                                 ',
     -  '<C>harmm/NAMD (.DCD)                                        ',
     -  '<A>mber                                                     '/
      data promptlist2 /
     -  'MMC Monte Car<L>o                                           ',
     -  'Macr<O>model                                                ',
     -  'Macromodel/<X>cluster                                       ',
     -  'Amber C<D>F                                                 ',
     -  '**** structure-derived file creation                        ',
     -  '<E>xtract sequence                                          ',
     -  'Create a <G>rasp .crg file                                  ',
     -  'Create a U<H>BD .dat file                                   ',
     -  'Print neigboring PBC cel<L> centers, cell vertices          ',
     -  'Torsion <I>nput generation                                  ',
     -  'Create Charmm RT<F> residue record(s)                       ',
     -  '<Q>uit structure-derived file generation                    ',
     -  '**** MMC trajectory file format                             ',
     -  '<B>inary                                                    ',
     -  '<A>SCII                                                     ',
     -  'A<N>notated ASCII                                           ',
     -  '<P>DB                                                       ',
     -  '<C>harmm CRD                                                ',
     -  '**** name conversion type                                   ',
     -  '<R>egularizing pdb names                                    ',
     -  '<U>ndo pdb regularizing (eliminate lead numbers)            ',
     -  '<L>eft-adjust atom names                                    ',
     -  'Convert to di<F>ferent PDB residue and atomname convention  ',
     -  'Make atom names all <D>ifferent                             ',
     -  '<Q>uit name conversion                                      ',
     -  '**** structure file format conversion type                  ',
     -  'Rearrange a<T>oms in a structure ccording to an RTF file    ',
     -  'Convert structure to <C>harmm CRD format                    ',
     -  'Convert structure to <E>xtended Charmm CRD format           ',
     -  'Convert structure to Brookhaven <P>DB format                ',
     -  'Convert structure to C<H>armm PDB format (seg id)           ',
     -  'Convert structure to <M>acromodel dat format                ',
     -  'Convert structure to MMC Monte Car<L>o input                ',
     -  'Convert structure to <G>romos/Gromacs format                ',
     -  'Convert structure to <I>nsightII .car format                ',
     -  'Convert structure to InsightII <N>xyz free format           ',
     -  'Convert structure to InsightII <S>xyz free format           ',
     -  'Convert structure to InsightII sxyz<R>q free form.          ',
     -  'Convert structure to <A>msol 3.5 input format               ',
     -  'Convert structure to Gaussian <O>niom format                ',
     -  'List column ranges for a different structure <F>ormat       ',
     -  '<Q>uit structure file format conversion                     ',
     -  '**** trajectory file format conversion type                 ',
     -  'Convert trajectory to <C>harmm format                       ',
     -  'Convert trajectory to <A>mber format                        ',
     -  'Convert trajectory to <M>acromodel format                   ',
     -  'Convert trajectory to <X>cluster format                     ',
     -  '<S>eparate GCE MMC trajectory into Amber trajectories       ',
     -  '<Q>uit trajectory conversion                                ',
     -  '**** PBC cell type                                          '/
      data promptlist3 /
     -  '<N>o PBC                                                    ',
     -  '<C>ubic                                                     ',
     -  '<R>ectangular                                               ',
     -  '<F>ace-centered cubic                                       ',
     -  '<H>exagonal prism                                           ',
     -  'Ske<W>ed hexagonal prism                                    ',
     -  '<T>runcated octahedron, X -> square (Charmm)                ',
     -  'Truncated <O>ctahedron, X -> hexagon (Amber, NAMD)          ',
     -  'He<X>agonal close-packed                                    ',
     -  'Octahe<D>ral (NAMD)                                         ',
     -  '<I>mage file defined                                        ',
     -  '<S>phere                                                    ',
     -  '**** configuration analysis                                 ',
     -  '<G>eometry/topology (links, bond, angle, torsion, etc.)  [6]',
     -  '<B>ond (salt bridge, hydrogen/hydrophobic) track, corr.  [5]',
     -  'Atomic propert<Y> (CV, hydrophobicity, Delphi potential) [3]',
     -  'M<O>lecular property (shell vol, rad, com, dipole, axis) [4]',
     -  'R<M>SD calculation (1D, 2D RMSD map, 2-traj cross RMSD)  [4]',
     -  'Meas<U>re distances (atom-atom, residue-residue, etc.)   [7]',
     -  'Psi-Phi R<A>machandran and dial plots                       ',
     -  'Bond angle statistics d<I>al plots                          ',
     -  '<T>orsion angle statistics and dial plots                   ',
     -  'Proline <K>ink calculation                                  ',
     -  'Heli<X> analysis (TRAJELIX)                                 ',
     -  '<P>seudorotation angle calculation                          ',
     -  'D<S>SP secondary structure assignment                       ',
     -  'Circular <V>ariance map                                     ',
     -  'Residue cov/cor matrix (from inp/traj), <N>ormal mode anal. ',
     -  'Summarize Amber energy <D>ecomposition tables               ',
     -  '<Q>uit analyzing this structure                             ',
     -  '**** topology/geometry analysis                             ',
     -  'Nei<G>hbor, bondlength, angle, torsion list                 ',
     -  '1-<4> neighbour and torsion list                            ',
     -  '<F>unctional group and backbone list                        ',
     -  '<B>ond length, angle list and distribution                  ',
     -  '<Q>uit topology/geometry analysis                           ',
     -  '**** bond tracking                                          ',
     -  '<H>ydrogen bond list, time course, and correlation          ',
     -  'Hydro<P>hobic contact list, time course, and correlation    ',
     -  '<S>alt bridge list, time course, and correlation            ',
     -  'Heavy atom <C>ontact search                                 ',
     -  'Hydrogen-bonded <B>ridge search                             ',
     -  'Residue-residue bond (HB, SB or HPH) <M>atrix comparison    ',
     -  '<Q>uit bond tracking                                        ',
     -  '**** atomic property calculation                            ',
     -  'Hydrophobicit<Y> (hydropathy) labeling                      ',
     -  '<C>ircular variance labeling                                ',
     -  'Delphi <P>otential labeling                                 ',
     -  '<Q>uit atomic property calculation                          ',
     -  '**** molecular property calculation                         '/
      data promptlist4 /
     -  'S<O>lvation shell volume                                    ',
     -  'Principal axis <D>irections                                 ',
     -  'Radius (gyration, hydrodynamic), COM, inert, dipole <M>oment',
     -  'Average <B>factors for each PDB chain/segment               ',
     -  '<Q>uit molecular property calculation                       ',
     -  '**** RMSD calculation                                       ',
     -  '<1>-D RMSD and RMSF calculation                             ',
     -  '<2>-D RMSD calculation                                      ',
     -  '<C>ross RMSD map for a trajectory pair                      ',
     -  'RMSF <D>ifference calculation                               ',
     -  '<Q>uit RMSD calculation                                     ',
     -  '**** distance analysis                                      ',
     -  'R<E>sidue distance list                                     ',
     -  'Mo<L>ecule-molecule distance list                           ',
     -  'Residue adjacency <M>atrix power analysis                   ',
     -  'Track PBC-adj<U>sted distance of two atoms                  ',
     -  'A<T>om-atom distance distribution                           ',
     -  'Atom-atom <S>D matrix from a trajectory                     ',
     -  '<C>heck for unphysical distances                            ',
     -  'C<O>mpare average residue-residue distance matrices         ',
     -  '<Q>uit distance analysis                                    ',
     -  '**** torsion input generation                               ',
     -  '<T>orsion input for Macromodel                              ',
     -  '<P>rotein torsion input for Macromodel                      ',
     -  'P<R>otein sidechain input for MMC                           ',
     -  'Prote<I>n full torsion input for MMC                        ',
     -  '<G>eneral full torsion input for MMC                        ',
     -  '**** selecting option                                       ',
     -  'Keep all solute atoms - i.e., drop sol<V>ents (if any)      ',
     -  'Select (keep only one) <C>hain/segment/molecule (id)        ',
     -  'Excise (drop only one) chain/<S>egment/molecule (id)        ',
     -  'Keep only the <B>ackbone                                    ',
     -  'Keep only the <A>lpha carbons                               ',
     -  'Drop aliphatic <H>ydrogens                                  ',
     -  'Drop al<L> hydrogens                                        ',
     -  'Select atom range to <K>eep                                 ',
     -  'Select atom range to <D>rop                                 ',
     -  'Select <R>esidue range to keep                              ',
     -  'Select r<E>sidue range to drop                              ',
     -  'Select a<T>om names to keep                                 ',
     -  'Select resid<U>e names to keep                              ',
     -  '<Q>uit selecting                                            ',
     -  '**** modification type                                      ',
     -  '<M>utate an atom                                            ',
     -  'Add new atom, defined by bond and torsion <A>ngles          ',
     -  'Add new atom, defined by <B>isector of 2 neigbours          ',
     -  'Add new atom, defined by <T>risector of 3 neigbours         ',
     -  '<C>reate bond between two atoms                             ',
     -  '<Q>uit modifying                                            ',
     -  '**** box or rectangle                                       '/
      data promptlist5 /
     -  'Bounding <C>ube                                             ',
     -  'Bounding <R>ectangle                                        ',
     -  '**** circular variance type                                 ',
     -  '<O>riginal circular variance                                ',
     -  '<W>eighted circular variance                                ',
     -  '**** ring type                                              ',
     -  '<G>eneral                                                   ',
     -  '<P>roline                                                   ',
     -  '<5>-membered sugar                                          ',
     -  '<6>-membered sugar                                          ',
     -  '<D>one with ring calculations                               ',
     -  '**** unpacking mode                                         ',
     -  'Unpack <A>ll configurations into single files               ',
     -  'Unpack se<L>ected configurations into single files          ',
     -  'Unpack all configurations into <O>ne file                   ',
     -  'Unpack selec<T>ed configurations into one file              ',
     -  '**** anchor atoms                                           ',
     -  'Use <A>ll qualifying atoms as potential anchors             ',
     -  'Give <L>ist of solute anchor atom indices                   ',
     -  'Give solute anchor atom inde<X> range                       ',
     -  'Give list of solute anchor atom residue <N>umbers           ',
     -  'Give solute anchor atom residue <R>ange                     ',
     -  'Give list of solute anchor atom <T>ypes                     ',
     -  'Use protein <B>ackbone O and H                              ',
     -  'Use atoms with high enough partial <C>harge                 ',
     -  '<Q>uit anchor definiton quiz                                ',
     -  '**** hydrophobic/contact anchors                            ',
     -  'Use <A>ll atoms as potential anchors                        ',
     -  'Give <L>ist of solute anchor atom indices                   ',
     -  'Give solute anchor atom inde<X> range                       ',
     -  'Give list of solute anchor atom residue <N>umbers           ',
     -  'Give solute anchor atom residue <R>ange                     ',
     -  '<Q>uit anchor definiton quiz                                ',
     -  '**** salt-bridge anchors                                    ',
     -  'Use <A>ll atoms able to form salt bridge                    ',
     -  'Give <L>ist of solute anchor atom indices                   ',
     -  'Give list of solute anchor atom residue <N>umbers           ',
     -  'Give solute anchor atom residue <R>ange                     ',
     -  '<Q>uit anchor definiton quiz                                ',
     -  '**** salt-bridge definition mode                            ',
     -  'Give <L>ist of salt-bridge atom names                       ',
     -  'Give minimum <C>harge of salt-bridge atoms                  ',
     -  '<B>oth                                                      ',
     -  '**** pbcinp                                                 ',
     -  '<C>harmm formatted image file                               ',
     -  '<S>imulaid format (3f10.5)                                  ',
     -  '**** origin of the modified cell                            ',
     -  'Coordinate system <O>rigin (0,0,0)                          ',
     -  'Inputted <C>oordinate                                       ',
     -  'Coordinate of a selected <A>tom                             '/
      data promptlist6 /
     -  '**** clustering algorithm                                   ',
     -  '<S>ingle-link, with input cutoff                            ',
     -  'Single-link, with <I>nput number of clusters                ',
     -  'Single-link, with m<U>ltiple input cutoffs                  ',
     -  '<K>-medoids (cluster center is a node)                      ',
     -  'K-means (cluster center is the <C>OM when clustering atoms) ',
     -  '<M>aximum neigborhood, with input cutoff                    ',
     -  'Maximum neigborhood, with input <N>umber of clusters        ',
     -  'C<L>ique clusters only, input cutoff (heuristic)            ',
     -  '<D>ensity, with input cutoff                                ',
     -  '<Q>uit clustering                                           ',
     -  '**** file form (PDB or CRD)                                 ',
     -  '<P>DB                                                       ',
     -  '<C>harmm CRD                                                ',
     -  '**** region definition mode                                 ',
     -  'H and M regions defined by atom-centered <S>pheres          ',
     -  'H and M regions defined by user-given <L>ists               ',
     -  '**** hydropathy/hydrophobicity scale source                 ',
     -  '<K>yte-Doolittle hydropathicity scale                       ',
     -  '<E>isenberg normalized consensus scale                      ',
     -  '<W>hite group  octanol scale                                ',
     -  '<I>nput a scale (see http://pref.etfos.hr/scacor/)          ',
     -  '**** axis                                                   ',
     -  '<X> axis                                                    ',
     -  '<Y> axis                                                    ',
     -  '<Z> axis                                                    ',
     -  '**** treatment of contacts                                  ',
     -  'Calculate <A>verage residue-residue contacts                ',
     -  'Calculate <C>umulative contacts                             ',
     -  '<I>gnore multiple contacts                                  ',
     -  '**** molecular center                                       ',
     -  '<G>eometric center                                          ',
     -  '<C>enter of mass                                            ',
     -  '<T>opological center                                        ',
     -  '<I>nputted center                                           ',
     -  '**** subclustering algorithm                                ',
     -  'Remove (temporarily) low-<C>onnectivity structures          ',
     -  'Remove (temporarily) low-<D>ensity structures               ',
     -  '**** output atom order                                      ',
     -  'Leave the order <U>nchanged                                 ',
     -  '<R>ead the new order from a file (.sort, Charmm CRD or PDB) ',
     -  'Rearrange atoms by matching names to a <D>ifferent structure',
     -  '**** yes or no                                              ',
     -  '<Y>es                                                       ',
     -  '<N>o                                                        ',
     -  '**** bond correlation type                                  ',
     -  'Correlate <B>oth the on and off states                      ',
     -  'Correlate only the <O>n states                              ',
     -  'Correlate <A>veraged on states                              ',
     -  '**** correlation - measure transformation                   '/
      data promptlist7 /
     -  'Distance measure is (1<->corr)^correxp                      ',
     -  'Distance measure is (1</>corr)^correxp                      ',
     -  'Distance measure is <C>orr^correxp (i.e., anticorrelation)  ',
     -  '**** Output format for sequence list                        ',
     -  '<C>harmm sequence input                                     ',
     -  'PDB <S>SEQRES input                                         ',
     -  'Title + <1>-char list                                       ',
     -  '<P>IR                                                       ',
     -  '<G>CG                                                       ',
     -  '**** PF label type                                          ',
     -  '<A>mber                                                     ',
     -  '<Charmm                                                     ',
     -  '**** R2-R1-X angle                                          ',
     -  'sp<3> (109.5)                                               ',
     -  'sp<2> (120.0)                                               ',
     -  'sp<1> (180.0)                                               ',
     -  '<I>nput angle                                               ',
     -  '**** R3-R2-R1-X torsion angle                               ',
     -  '<C>is   (000.0)                                             ',
     -  '<T>rans (180.0)                                             ',
     -  'g<+>   (+60.0)                                              ',
     -  'g<->   (-60.0)                                              ',
     -  'a+<P>  (+120.0)                                             ',
     -  'a-<M>  (-120.0)                                             ',
     -  '<I>nput angle                                               ',
     -  '**** conversion type                                        ',
     -  'Convert to s<T>andard MMC types and charges                 ',
     -  'Convert to <A>tomic numbers only                            ',
     -  '**** PDB file type                                          ',
     -  '<B>rookhaven chainid                                        ',
     -  '<C>harmm segment id                                         ',
     -  '**** Charmm CRD file type                                   ',
     -  '<O>riginal (80-character) format                            ',
     -  '<E>xtended (132-character format), defined in c32           ',
     -  '**** residue distance definition                            ',
     -  'Residue distances will be based on <R>epresentative atoms   ',
     -  'Residue distances will be based on <C>losest atoms          ',
     -  '**** adjacency analysis                                     ',
     -  '0/1 (<I>nteger) adjacency matrix and its matrix powers      ',
     -  '0.0-1.0 (<W>eighted) adjacency matrix and its matrix powers ',
     -  'Distance-scaled adjacency matrix and product-like <S>ums    ',
     -  '**** trajectory unit                                        ',
     -  'Number of <F>rames                                          ',
     -  '<P>icoseconds                                               ',
     -  '<N>anoseconds                                               ',
     -  '<M>iliseconds                                               ',
     -  '**** sequence file type                                     ',
     -  '<S>imulaid-written .sort file (possibly fixed manually)     ',
     -  '<P>DB file, using the ATOM and HETATM redord sequence number',
     -  '<C>harmm .CRD file, using the sequence number               '/
      data promptlist8 /
     -  'Charmm .CRD file, <L>ong format, using the sequence number  ',
     -  '**** Molecule information source                            ',
     -  'User-supplied Charmm <P>SF file (Xplor format)              ',
     -  'User-supplied Amber <T>op file                              ',
     -  '<S>imulaid formatted conversion file or Charmm RTF file     ',
     -  '**** clustering source                                      ',
     -  'Cluster <A>toms of an input structure                       ',
     -  'Read the <D>istance matrix of the items to be clustered     ',
     -  '**** transformation type                                    ',
     -  '<U>se the matrix as is                                      ',
     -  'Set r(i,j) to r(i,j)^<N>                                    ',
     -  'Set r(i,j) to r(i,j)^(1</>N)                                ',
     -  'Set r(i,j) to 1 <-> r(i,j)                                  ',
     -  'Set r(i,j) to (1 - r(i,j))^N<P>                             ',
     -  'Set r(i,j) to (1 - r(i,j))^(1/N)<I>                         ',
     -  'Set r(i,j) to <A>bs(r(i,j))^N                               ',
     -  'Set r(i,j) to (<1>-abs(r(i,j))^N                            ',
     -  'Set r(i,j) to (r(i,j)-<M>in(r(i,j))^N                       ',
     -  '**** Contact type                                           ',
     -  '<R>epresentative atom based                                 ',
     -  '<M>utual proximity based                                    ',
     -  '<S>um of all three contact types                            ',
     -  '**** cluster representative type                            ',
     -  'Lowest <A>verage RMDS                                       ',
     -  'Lowest <M>aximum RMDS                                       ',
     -  'Lowest <E>nergy                                             ',
     -  'Centers from <K>-means clustering (if available)            ',
     -  '**** form of extraction                                     ',
     -  '<S>ingle files                                              ',
     -  'Structures stacked in <O>ne file                            ',
     -  'Structures stacked in one file as <M>ODELs                  ',
     -  '<T>trajectory                                               ',
     -  '**** atoms for RMSD calculation                             ',
     -  '<A>ll                                                       ',
     -  '<S>elect atoms                                              ',
     -  'Atoms used for <O>verlay                                    ',
     -  '**** charge input                                           ',
     -  '<N>o charge input                                           ',
     -  'Input charges from <A>mber prmtop file                      ',
     -  'Input charges from <C>harmm PSF file                        ',
     -  'Input charges from Auto<D>ock .pdbqt file                   ',
     -  '**** (additional) conformation transformation type          ',
     -  '<S>hift (translate) the system by an input vector           ',
     -  'Shift the system to a new position of a selected <A>tom     ',
     -  'Shift the system and reset it into a <P>BC cell             ',
     -  '<C>enter the system in a PBC cell                           ',
     -  '<R>otate the system by an angle                             ',
     -  'Rotate the system based on <B>ond directions                ',
     -  'Sca<L>e the coordinates (change units)                      ',
     -  'S<E>parate molecules (for clarity)                          '/
      data promptlist9 /
     -  '<Q>uit conformation transformation type selection           ',
     -  '**** rotation type                                          ',
     -  'Rotate around the <X> axis                                  ',
     -  'Rotate around the <Y> axis                                  ',
     -  'Rotate around the <Z> axis                                  ',
     -  '<I>nput a rotation matrix                                   ',
     -  '<Q>uit rotating                                             ',
     -  '**** torsion input list                                     ',
     -  '<P>rotein torsion input (bacbone omega skipped)             ',
     -  'Protein <S>idechain input                                   ',
     -  'Protein <B>ackbone input                                    ',
     -  '<G>eneral full torsion input                                ',
     -  '<U>ser-defined list                                         ',
     -  '**** bond-difference plot type                              ',
     -  '<S>igned differences                                        ',
     -  '<A>bsolute value of the diferences                          ',
     -  '<D>iscretized (-1/0/1) diferences                           ',
     -  '**** SD normalization                                       ',
     -  '<N>o normalization                                          ',
     -  'Normalize by the site <R>MSDs of the two atoms              ',
     -  'Normalize by the <D>istance between the two atoms           ',
     -  'Normalize by the <I>nverse distance between the two atoms   ',
     -  '**** MODEL record treatment                                 ',
     -  '<K>eep MODEL/ENDMDL records                                 ',
     -  '<D>elete MODEL/ENDMDL records                               ',
     -  'Change ENDMDL to <E>ND and delete MODEL records             ',
     -  'Change ENDMDL to <T>ER and delete MODEL records             ',
     -  '**** autocorrelation calculation mode                       ',
     -  'End the AUC data generation at the last <O>n state          ',
     -  'End the AUC data generation at the <L>ast frame of the track',
     -  'Pad the track with additional <Z>eros                       ',
     -  'Pad the track by re<U>sing the last stretch of the track    ',
     -  'Pad the track by <R>andom 0/1 sequence; p(1)=fract(n)       ',
     -  '**** k-medoids center choice                                ',
     -  'Center of a set is the node with smallest <M>aximum distance',
     -  'Center of a set is the node with smallest <A>verage distance',
     -  'Center of a set is the node with smallest average <R>ank    ',
     -  '**** density clustering variant                             ',
     -  '<C>ommon neighbors minimum (CNN)                            ',
     -  '<M>utual neighbors and common neighbors minimum (CNN-opt)   ',
     -  'M<U>tual neighbors and separate neighbors minimum (DBSCAN)  ',
     -  '**** run type                                               ',
     -  'Print all menu and submenu <F>unctions                      ',
     -  'Geometry <O>ptimization (orientation, smallest sphere) [3]  ',
     -  '<C>leanup (sort, renumber, regroup, round charges)          ',
     -  '<S>tructure file and type conversions [12]                  ',
     -  '<T>rajectory file and type conversions [4]                  ',
     -  'Atom <N>ame and residue name conversions [4]                ',
     -  'Trajectory - str<U>cture file conversions (pack/unpack)  [4]',
     -  'Conformation <E>dit (trans/rot/cent/xtal/add/del, etc.) [14]'/
      data promptlist10 /
     -  'Structure-<D>erived files (seq, RTF, UHBD, torsion, etc.)[6]',
     -  '<A>nalyze (TRAJELIX, RMSD, H-bonds, CV, etc.) [16]          ',
     -  'Cluste<R> atoms or data defined by a distance matrix [2]    ',
     -  'Make the input <P>redictable                                ',
     -  'Open <L>ogfile logging the keyboard inputs                  ',
     -  'Ani<M>ate trajectory                                        ',
     -  '<Q>uit Simulaid                                             ',
c     NOTE: Keep runtype the last item !
     -  '****                                                        ',
     -  42*
     -  '                                                            '/
c     Leave the "run type" menu at the end.
      end
      subroutine setdatapath
c     Find out if any of the stored datapaths has a pdb_nam.dat
      character*100 datapath,datapaths
      common /environment/ npaths,ldatapath,ldatapaths(4),
     -  datapath,datapaths(4)
      character*200 filename
c     Try stored paths
      do ip=1,npaths
        filename(1:ldatapaths(ip))=datapaths(ip)(1:ldatapaths(ip))
        filename(ldatapaths(ip)+1:ldatapaths(ip)+12)='/pdb_nam.dat'
        namlen=ldatapaths(ip)+12
        call openfile(88,0,' ',1,'OLD',filename,namlen,notfound,2,1,0,1,
     -    0)
        if (notfound .eq. 0) then
          datapath=datapaths(ip)
          ldatapath=ldatapaths(ip)
          write (6,1000) datapath(1:ldatapath)
          close (88)
          return
        end if
      end do
      print *,'NOTE: no valid datapath is found to Simulaid-provided ',
     -    'conversion files'
      ldatapath=0
      return
1000  format(' Conversion files found in directory ',a)
      end
      subroutine reseq(line,index,n,nslt,nsegm,iatfirst,iresfirst,
     -  iresidfirst,ioutyp,iresno,resnames,numres,numslv,naslv,
     -  resnamslv,iresnrestart,iresidrestart,nconfig,ireseq,ireseqdef,
     -  maxrsd,maxrec)
      dimension iresno(maxrec)
      character* 132 line(maxrec)
      character*8 resnam,resnames(maxrsd),resnamslv
      character*4 segnam
      dimension index(n)
      character*5 crdext
      common /iotypes/ iocha,iochaex,iobpdb,iocpdb,ioa3pdb,ioa4pdb,
     -  iommod,iommc,iommc4,iogro,iomol2,iomae,ioins,ionxyz,
     -  iosxyz,iosxyzrq,iograsp,iofull,lext(17),crdext(17)
      common /solvres/ iaskdiffres,idiffres
      common /logging/ logfile,ipredict
c     Make sure residue numbers and atom numbers are consecutive
      call setcol(ioutyp,ncol,idcol,ialtcol,
     -  inamcol1,inamcol2,irescol1,irescol2,iccol1,iccol2,
     -  iresncol1,iresncol2,iseqncol1,iseqncol2,isegcol1,isegcol2,
     -  iresidcol1,iresidcol2,iqcol1,iqcol2,ipotcol1,ipotcol2,
     -  iocccol1,iocccol2,ichemcol1,ichemcol2,nrescol,nresncol,
     -  nsegcol,nnamcol,iofull)
      nrescol=irescol2-irescol1+1
      nresncol=iresncol2-iresncol1+1
      nsegcol=isegcol2-isegcol1+1
c     print *,'RESEQ nslt,naslv,nconfig=',nslt,naslv,nconfig
c     print *,'reseq  n=',n,' nrescol,nresncol,nsegcol=',
c    -  nrescol,nresncol,nsegcol
c     print *,irescol1,irescol2,iresncol1,iresncol2,
c    -  isegcol1,isegcol2
c     print *,' iseqncol1,2=',iseqncol1,iseqncol2
c     print *,'iresidcol1,iresidcol2=',iresidcol1,iresidcol2
      if (ireseq .eq. -1) return
      if (nconfig .eq. 1) then
        call askyn('Do you want to adjust atom and residue numbers',
     -    46,1,ireseqdef,ireseq,0)
        if (ireseq .eq. 1) then
          call getint('Atom number of the first atom',29,
     -      1,1,0,iatfirst,48)
          call getint('Residue number of the first residue',35,
     -      1,1,0,iresfirst,48)
          print *,'First atom and residue numbers=',iatfirst,iresfirst
          if (ischarmm(ioutyp) .eq. 1) then
            call getint('Residue id of the first residue',31,
     -        iresfirst,1,0,iresidfirst,48)
            print *,'First residue id=',iresidfirst
          else
            iresidfirst=0
          end if
          if (nsegm .gt. 1 .or. ipredict .eq. 1) then
c           Allow for consecutive residue numbers over segments
            call askyn(
     -       'Do you want to restart residue numbering at each segment',
     -        56,1,-1,iresnrestart,0)
            if (ischarmm(ioutyp) .eq. 1) then
            call askyn(
     -      'Do you want to restart residue id numbers at each segment',
     -        57,1,+1,iresidrestart,0)
            else
              iresidrestart=0
            end if
            if (iresnrestart+iresidrestart .gt. 0)
     -        print *,'Residue ranges for each segment are listed above'
          end if
        end if
      end if
      if (ireseq .ne. 1) return
      numslv=0
      resnam='        '
      resnam(1:nrescol)=line(index(1))(irescol1:irescol2)
      iresnoprev=iresno(1)
      resnames(1)=resnam
      if (nsegcol .gt. 0)
     -  segnam(1:nsegcol)=line(index(1))(isegcol1:isegcol2)
c     print *,'resnam,resnum,segnam,n=',resnam,resnum,segnam,n
      numres=iresfirst
      iiresnum=iresfirst
      iiresid=iresidfirst
      ncha=0
c     print *,'C nsegcol=',nsegcol
      do ia=1,n
        if (line(index(ia))(irescol1:irescol2) .ne. resnam(1:nrescol)
     -     .or. iresno(ia) .ne. iresnoprev) then
          numres=numres+1
          iiresnum=iiresnum+1
          iiresid=iiresid+1
          resnam(1:nrescol)=line(index(ia))(irescol1:irescol2)
          iresnoprev=iresno(ia)
          resnames(numres)=resnam
          if (resnamslv(1:nrescol) .eq. resnam(1:nrescol))
     -      numslv=numslv+1
        else if (iaskdiffres .eq. 0 .and. nconfig .eq. 1) then
          if (ia .eq. nslt+naslv+1) then
c           Second solvent is the same residue as the first
            call askyn(
     -        'Do you want the solvents to be different residues',49,
     -        1,1,idiffres,0)
            iaskdiffres=1
          end if
        end if
        if (ia .gt. nslt+naslv .and. idiffres .eq. 1) then
          if (mod(ia-1-nslt,naslv) .eq. 0) then
            numres=numres+1
            iiresnum=iiresnum+1
            iiresid=iiresid+1
            numslv=numslv+1
          end if
        end if
        if (nsegcol .gt. 0) then
          if (segnam(1:nsegcol) .ne. line(index(ia))(isegcol1:isegcol2))
     -                           then
c           New segment was found
            if (iresnrestart .eq. 1) iiresnum=iresfirst
            if (iresidrestart .eq. 1) iiresid=iresidfirst
            segnam(1:nsegcol)=line(index(ia))(isegcol1:isegcol2)
          end if
        end if
c       Sequence number (if used)
        if (iseqncol1 .gt. 0) then
          call readint(line(index(ia)),iseqncol1,iseqncol2,iaorg,1)
          ianew=ia+iatfirst-1
          if (iaorg .ne. ianew) ncha=ncha+1
          if (ioutyp .eq. iochaex) then
            write (line(index(ia))(iseqncol1:iseqncol2),1001) ianew
          else
            write (line(index(ia))(iseqncol1:iseqncol2),1000) ianew
          end if
        end if
        if (numres .gt. maxrsd) then
          write (6,2000) maxrsd,numres
          stop
        end if
c       Check for change in residue number/id
        call readint(line(index(ia)),iresncol1,iresncol2,iiresorg,2)
        if (iiresorg .ne. iiresnum) ncha=ncha+1
        if (ischarmm(ioutyp) .eq. 1) then
c         Residue id
          call readint(line(index(ia)),iresidcol1,iresidcol2,iiresorg,2)
          if (iiresorg .ne. iiresid) ncha=ncha+1
        end if
        if (ioutyp .eq. iocha ) then
          write (line(index(ia))(iresncol1:iresncol2),1000)
     -      mod(iiresnum,100000)
          if (iiresnum .eq. 100000)
     -       write (6,1100) 'residue number',100000
          write (line(index(ia))(iresidcol1:iresidcol2),1006)
     -      mod(iiresid,100000)
          if (iiresid .eq. 100000)
     -       write (6,1100) 'residue id',100000
        else if (ioutyp .eq. iochaex) then
          write (line(index(ia))(iresncol1:iresncol2),1001) iiresnum
          write (line(index(ia))(iresidcol1:iresidcol2),1002) iiresid
        else if (ioutyp .eq. iommc ) then
          write (line(index(ia))(iresncol1:iresncol2),1000)
     -      mod(iiresnum,100000)
          if (iiresnum .eq. 100000)
     -     write (6,1100) 'residue number',100000
        else
          write (line(index(ia))(iresncol1:iresncol2),1006)
     -      mod(iiresnum,10000)
          if (iiresnum .eq. 10000) write (6,1100) 'residue number',10000
        end if
      end do
c     Add '3' to 'TIP'
c     print *,'numres=',numres
      do ir=1,numres
        if (resnames(ir)(1:3) .eq. 'TIP') resnames(ir)(4:4)='3'
      end do
      if (nconfig .eq. 1) then
        if (ncha .gt. 0) then
          print *,'Atom and/or residue sequence numbers were changed'
        else
          print *,'No sequence number was changed'
        end if
      end if
      return
1000  format(i5)
1001  format(i10)
1002  format(i8)
1006  format(i4)
1100  format(' WARNING: leading digits for ',a,' over ',i7,
     -  '  are dropped')
2000  format( 'ERROR: Maximum number of residues (',i5,') is exceeded',
     -  /,' - recompile simulaid with MAXRSD=',i6,' or greater')
      end
      subroutine fixrecform(line,index,n,iconv,inamcol1,inamcol2,
     -  irescol1,irescol2,maxrec)
      character* 132 line(maxrec)
      character*4 atnamo,atnamn
      character*8 resnam
      dimension index(n)
      if (iconv .eq. 2) itofrom=1
c     'Regularize' PDB atomnames
      if (iconv .eq. 3) itofrom=0
c     'De-regularize' PDB atomnames
      n2=0
      do ia=1,n
        resnam='        '
        resnam(1:irescol2-irescol1+1)=
     -    line(index(ia))(irescol1:irescol2)
        atnamo=line(index(ia))(inamcol1:inamcol2)
        call regularpdb(atnamo,atnamn,itofrom)
        line(index(ia))(inamcol1:inamcol2)=atnamn
      end do
      if (n2 .gt. 0) print *,'WARNING: ',n2,
     -    ' atomnames had more than one leading digits'
      return
      end
      subroutine atomdel(line,idcol,asterisk,n,nslt,nrecdel,c,isegno,
     -  index,indexn,indexo,inpcrdtyp,iatnum,charge,iresno,ixres,ifres,
     -  ilres,nconfig,ndel,maxrsd,maxrec)
      character* 132 line(maxrec)
      dimension c(3,n),isegno(n),index(n),indexn(n),indexo(n),iatnum(n),
     -  iresno(n),ixres(n),charge(n),ifres(maxrsd),ilres(maxrsd)
      character*1 asterisk
      character*5 crdext
      common /iotypes/ iocha,iochaex,iobpdb,iocpdb,ioa3pdb,ioa4pdb,
     -  iommod,iommc,iommc4,iogro,iomol2,iomae,ioins,ionxyz,
     -  iosxyz,iosxyzrq,iograsp,iofull,lext(17),crdext(17)
c     print *,'ATOMDEL nrecdel,n,idcol,nconfig=',nrecdel,n,idcol,nconfig
      if (nrecdel .eq. 0) return
      ndel=0
      nsltdel=0
      do i=1,n
c       Update index to eliminate the dropped molecules
        if (line(index(i))(idcol:idcol) .eq. asterisk) then
          ndel=ndel+1
          if (i .le. nslt) nsltdel=nsltdel+1
          indexo(i)=0
        else if (ndel .gt. 0) then
          index(i-ndel)=index(i)
          indexo(i)=i-ndel
          iatnum(i-ndel)=iatnum(i)
          iresno(i-ndel)=iresno(i)
          isegno(i-ndel)=isegno(i)
          charge(i-ndel)=charge(i)
          call trnsfr(c(1,i-ndel),c(1,i),3)
        end if
      end do
      if (nsltdel .gt. 0 .and. nconfig .eq. 0)
     -  print *,'Number of solute atoms deleted=',nsltdel
      if (ndel .ne. nrecdel) then
        write (6,1000) ndel,nrecdel
      end if
c     print *,'atomdel n,inpcrdtyp=',n,inpcrdtyp
      if (inpcrdtyp .eq. iommod)
     -  call nnupdate(index,indexn,indexo,n-ndel,n,line,1,maxrec)
      n=n-ndel
      nslt=nslt-nsltdel
c     Establish atom ranges for the residues reflecting the deletions
      ifres(1)=1
      numres=0
      ixres(1)=1
      do ia=2,n
        if (iresno(ia) .ne. iresno(ia-1) .or.
     -      isegno(ia) .ne. isegno(ia-1)) then
          numres=numres+1
          ilres(numres)=ia-1
          do ja=ifres(numres),ilres(numres)
            ixres(ja)=numres
          end do
          ifres(numres+1)=ia
        end if
      end do
      ilres(numres+1)=n
      nrecdel=0
      return
1000  format(' PROGRAM ERROR: Number of asterisk-marked lines found=',
     -  i5,/,5x,'differs from number of records to be deleted=',i5)
      end
      subroutine initnamconv(noconv)
c     Read in atom and residue name conversion tables, set up limits, etc
      character*200 filename,line
      character*8 namnam
      character*9 recnam
      common /convspec/ incon,ioutcon,ideoxy,namnam(10)
      character*3 ires0
      character*4 anamcontab,rnamcontab,atnam
      common /convdat/ nanamcon,nrnamcon,nres0,ifst(100),ilst(100),
     -  ncon,nconcol,anamcontab(1000,13),rnamcontab(13,100),ires0(100),
     -  icongro
      ideoxy=-1
      filename='pdb_nam.dat'
      namlen=11
      iuconv=70
      call openfile(iuconv,0,'namcon',6,'OLD',filename,namlen,
     -  notfnd,1,1,0,0,0)
      write (6,2001) filename(1:namlen)
c     Read in conversion information
      maxconcol=13
c     nconcol: number of colums containing conversion data
c     ncon: number of name conversions (PDB can have several columns)
      read (iuconv,*) ncon,nconcol
      if (nconcol .gt. maxconcol) then
        print *,'ERROR: Conversion data columns exceeds limit (',
     -    maxconcol,')'
        stop
      end if
c     namename: Names of the conventions
      read (iuconv,*) (namnam(i),i=1,ncon)
      do ic=1,ncon
        if (namnam(ic)(1:3) .eq. 'Gro') icongro=ic
      end do
      call chosename(namnam,ncon,'input',5,incon)
      call chosename(namnam,ncon,'output',6,ioutcon)
      if (incon .eq. ioutcon) then
        print *,'Names will be matched without conversion'
        noconv=1
        return
      else
        noconv=0
      end if
      if (namnam(ioutcon) .eq. 'Macromod') then
        print *,'Sorry, conversions TO Macromodel are not implemented'
        stop
      end if
      if (incon .eq. icongro .or. ioutcon .eq. icongro) write (6,2006)
      write (6,2004) namnam(incon),namnam(ioutcon)
      recnam='residname'
      do i=1,100
        read (iuconv,1000,end=992) line
        read (line,*,err=9921) (rnamcontab(j,i),j=1,nconcol)
c       read (iuconv,*,err=9921,end=992)
c       read (iuconv,*,end=992)
c    -    (rnamcontab(j,i),j=1,nconcol)
        if (rnamcontab(1,i) .eq. 'DONE') then
          nrnamcon=i
          go to 120
        end if
      end do
      go to 993
9921  write (6,2005) recnam,filename(1:namlen),i,line
      stop
120   irec=0
      recnam='atomnname'
      do i=1,100000
        read (iuconv,1000,end=991) line
        read (line,*,err=9921) (anamcontab(irec+1,j),j=1,nconcol)
c        write (77,2200) i,irec,(anamcontab(irec+1,j),j=1,nconcol)
c2200    format(' i,irec=',2i4,' anam=',12(1x,a4))
        if (anamcontab(irec+1,1) .eq. 'DONE') then
          nanamcon=irec
          go to 110
        end if
        atnam=anamcontab(irec+1,2)
        ndiff=0
        do j=3,nconcol
          if (atnam .ne. anamcontab(irec+1,j) .and.
     -        anamcontab(irec+1,j) .ne. '   ') ndiff=ndiff+1
        end do
c        write (77,7711) i,irec,nconcol,ndiff,anamcontab(irec+1,1),
c     -   anamcontab(irec+1,2)
c7711    format(' i,irec,nconcol,ndiff=',4i5,2a6)
        if (ndiff .gt. 0) irec=irec+1
        if (irec .eq. 1000) then
          print *,'Atom name table exceeds the maximum (1000)'
          stop
        end if
      end do
110   nres0=1
      ires0(nres0)=anamcontab(1,1)(1:3)
      ifst(nres0)=1
      do i=2,nanamcon
        if (anamcontab(i,1) .ne. anamcontab(i-1,1)) then
c         New residue found
          ilst(nres0)=i-1
          nres0=nres0+1
          ires0(nres0)=anamcontab(i,1)(1:3)
          ifst(nres0)=i
        end if
      end do
      ilst(nres0)=nanamcon
      close (iuconv)
c      do i=1,nres0
c        write (99,7123) i,ires0(i),ifst(i),ilst(i)
c7123    format(i3,1x,a3,3i5)
c      end do
c      do i=1,nanamcon
c        write (77,7755) i,(anamcontab(i,j),j=1,nconcol)
c7755    format(i5,10(2x,'*',a4,'*'))
c      end do
      return
991   print *,'ERROR: atom name table ended abruptly'
      stop
992   print *,'ERROR: residue name table ended abruptly'
      stop
993   print *,'ERROR: too many residues, increase size of ',
     -  'rnamcontab'
      stop
1000  format(a200)
2001  format(' Name-conversion file:',a)
2004  format(' Atom and residue name convention are changed from ',
     -  a,' to ',a)
2005  format(' ERROR: invalid ',a,' record in file ',a,
     -  ' record no=',i8,' :'/,a)
2006  format(' NOTE: only 4 characters will be used for conversion',/,
     -  7x,'Only protein conversions are complete for Gromacs')
      end
      subroutine chosename(namelist,nnames,lab,lablen,iname)
      character*(*) namelist(nnames),lab
100   write (6,1000) lab(1:lablen)
      do i=1,nnames
        if (i .lt. nnames) write (6,1001) namelist(i),i
        if (i .eq. nnames) write (6,1002) namelist(i),i
      end do
      call getint('Convention number',17,999999,1,nnames,iname,00)
      if (iname .lt. 1 .or. iname .gt. nnames) then
        print *,'Invalid choice'
        go to 100
      end if
      return
1000  format(' Possible ',a,' name conventions:')
1001  format(5x,a8,':',i3)
1002  format(5x,a8,':',i3,'  ',$)
      end
      subroutine namconv(nrescol,resnamin,atnamin,resnamout,atnamout,
     -  nrch,nach,line,idcol,nrecdel)
c     Perform an atom and residue name conversion
      character* 132 line
      character*1 ans1
      character*4 atnamin,atnamout,an0,an1,resnamin,resnamout,rn0
      character*8 namnam
      common /convspec/ incon,ioutcon,ideoxy,namnam(10)
      character*3 ires0
      character*4 anamcontab,rnamcontab
      common /convdat/ nanamcon,nrnamcon,nres0,ifst(100),ilst(100),
     -  ncon,nconcol,anamcontab(1000,13),rnamcontab(13,100),ires0(100),
     -  icongro
      data inamconv /0/
      incol1=incon+1
      incol2=incon+1
      if (incon .eq. ncon) incol2=nconcol
      an0=atnamin
      rn0=resnamin
c     write (77,*) 'Aresnamin=',resnamin,' atnamin=',atnamin
      atnamout=atnamin
      call leftadjust4(resnamin,resnamin)
      call leftadjust4(atnamin,an1)
      inrescol=nrescol
      if (incon .eq. ncon) then
        call regularpdb(an1,atnamin,1)
        inrescol=3
      else
        if (idigit(an1(1:1),1) .eq. 1 .and. ioutcon .ne. ncon)
     -    call regularpdb(an1,atnamin,-1)
      end if
c     write (77,*) ' an1=',an1,' atnamin=',atnamin
c     print *, 'an1,atnamin=',an1,'|',atnamin
      atnamout=atnamin
      an1=atnamin
      resnamout=resnamin
c     Find first the residue name in the resname table
      iresconv=0
      do i=1,nrnamcon
        do j=incol1,incol2
          if (resnamin(1:inrescol) .eq.
     -        rnamcontab(j,i)(1:inrescol)) then
            iresconv=i
            resnamout=rnamcontab(ioutcon+1,i)
c           write (77,*) 'Match i,j=',i,j,' rno=',resnamout
            go to 100
          end if
        end do
      end do
      go to 910
c     Find generic residue name
100   iresconv0=0
      do i=1,nres0
        if (ires0(i) .eq. rnamcontab(1,iresconv)(1:3)) then
          iresconv0=i
c         write (77,*) 'Generic resname=',ires0(i)
          go to 110
        end if
      end do
      write (6,2001) rnamcontab(1,iresconv)
c     Find the atom conversion - first check residue-specific conversions
110   if (iresconv0 .gt. 0) then
        do i=ifst(iresconv0),ilst(iresconv0)
          do j=incol1,incol2
c           write (77,*)
c    -        'i=',i,' atnamin=',atnamin,' atab=',anamcontab(i,j)
            if (atnamin .eq. anamcontab(i,j)) then
              if (anamcontab(i,ioutcon+1) .eq. '****') then
                line(idcol:idcol)='*'
                nrecdel=nrecdel+1
              else if (anamcontab(i,ioutcon+1) .ne. '    ') then
                atnamout=anamcontab(i,ioutcon+1)
              end if
c             write (77,7712) atnamin,resnamin,atnamout
c7712          format(' FOUND: an=',a4,' rn=',a4,' ao=',a4)
              inamconv=i
              go to 900
            end if
          end do
        end do
      end if
c     Not found among the specifics  - check the residue independent list
      do i=ifst(1),ilst(1)
        do j=incol1,incol2
          if (atnamin .eq. anamcontab(i,j)) then
            if (anamcontab(i,ioutcon+1) .eq. '****') then
              line(idcol:idcol)='*'
              nrecdel=nrecdel+1
            else if (anamcontab(i,ioutcon+1) .ne. '    ') then
              atnamout=anamcontab(i,ioutcon+1)
            end if
            inamconv=i
c           write (77,*) 'Generic found atnamout=',atnamout,' i,j=',i,j
            go to 900
          end if
        end do
      end do
      inamconv=0
c     Take care of oxy/deoxy nucleic acids
900   if (nrescol .ge. 4 .and. resnamout(4:4) .ne. ' ') then
        if (resnamout(1:1) .eq. 'D' .or. resnamout(1:1) .eq. 'R') then
          if (ideoxy .eq. -1) then
            if (resnamout(2:4) .eq. 'ADE' .or. resnamout(2:4) .eq.
     -        'GUA' .or. resnamout(2:4) .eq. 'CYT') then
c             Ask if oxy or deoxy NA
              call getname(ans1,len,
     -          'Nucleic acid type (D for Deoxy, R Oxy)',38,1,0)
              ideoxy=1
              if (ans1 .eq. 'r' .or. ans1 .eq. 'R') ideoxy=0
            else if (resnamout(2:4) .eq. 'THY') then
              ideoxy=1
            else if (resnamout(2:4) .eq. 'URA') then
              ideoxy=0
            end if
          else if (ideoxy .eq. 1) then
            resnamout(1:1)='D'
          else if (ideoxy .eq. 0) then
            resnamout(1:1)='R'
          end if
        end if
      end if
      if (ioutcon .eq. icongro) then
c       Gromacs output - check for residue name change
        ifound=0
        if (ires0(iresconv0) .eq. 'ASP') then
          call findname('HD2 ',anamcontab(1,ioutcon+1),ifst(iresconv0),
     -      ilst(iresconv0),ifound,3)
        else if (ires0(iresconv0) .eq. 'CYS') then
          call findname('HG  ',anamcontab(1,ioutcon+1),ifst(iresconv0),
     -      ilst(iresconv0),ifound,2)
        else if (ires0(iresconv0) .eq. 'GLU') then
          call findname('HE2 ',anamcontab(1,ioutcon+1),ifst(iresconv0),
     -      ilst(iresconv0),ifound,3)
        else if (ires0(iresconv0) .eq. 'LYS') then
          call findname('HZ3 ',anamcontab(1,ioutcon+1),ifst(iresconv0),
     -      ilst(iresconv0),ifound,3)
        end if
        if (ifound .gt. 0) resnamout(4:4)='H'
      end if
c     Check for changes
910   if (inamconv*iresconv .eq. 0) then
        if (incon .eq. ncon) then
c         Undo the regularization
          call leftadjust4(an0,an1)
          if (idigit(an1(1:1),1) .eq. 1)
     -      call regularpdb(an1,atnamout,-1)
        else
          atnamout=an1
        end if
      end if
      if (rn0 .ne. resnamout) nrch=nrch+1
      if (an0 .ne. atnamout) nach=nach+1
c      write (77,7723) rn0,an0,resnamout,atnamout
c7723  format(' rn0,an0=',a,1x,a,' ,resnamout,atnamout=',a,1x,a)
      return
2001  format(' ERROR: Generic residue id ',a4,' is not found - ',
     -  'conversion is skipped',/,8x,'Check the conversion table file')
      end
      subroutine regularpdb(inp,reg,itofrom)
      character*4 inp,reg,regg,inpl
      regg='    '
      call leftadjust4(inp,inpl)
c     write (06,*) 'REGPDB inp=',inp,' inpl=',inpl,' itofrom=',itofrom
      if (itofrom .eq. 1) then
c       To PDB
        if (inpl(1:1) .eq. 'C' .or. inpl(1:1) .eq. 'O' .or.
     -    inpl(1:1) .eq. 'N' .or. inpl(1:1) .eq. 'S' .or.
     -    inpl(1:1) .eq. 'P') then
          regg(2:4)=inpl(1:3)
          if (inpl(4:4) .ne. ' ') then
            if (idigit(inpl(4:4),1) .eq. 1) then
              regg(1:1)= inpl(4:4)
            else if (idigit(inpl(3:3),1) .eq. 1) then
              regg(1:1)= inpl(3:3)
              regg(4:4)= inpl(4:4)
            else if (idigit(inpl(2:2),1) .eq. 1) then
              regg(1:1)= inpl(3:3)
              regg(3:3)= inpl(3:3)
              regg(4:4)= inpl(4:4)
            else
              write (6,1000) ' ',inpl
            end if
          end if
        else if (inpl(1:1) .eq. 'H' .or. inpl(1:1) .eq. 'D') then
          if (inpl .eq. 'H   ') then
            regg=' H  '
          else if (inpl .eq. 'D   ') then
            regg=' D  '
          else if (inpl(3:4) .eq. '  ') then
c           Two-character H name
            regg(2:3)=inpl(1:2)
          else if (inpl(4:4) .eq. ' ') then
c           Three-character H name
            regg(1:1)=' '
            regg(2:4)=inpl(1:3)
          else
c           Four-character H name
            if (idigit(inpl(4:4),1) .eq. 1) then
c             HXXd -> dHXX
              regg(1:1)=inpl(4:4)
              regg(2:4)=inpl(1:3)
            else if (idigit(inpl(2:2),1) .eq. 1 .and.
     -               idigit(inpl(3:3),1) .eq. 1) then
c             HddX -> dHXd
              regg(1:1)=inpl(2:2)
              regg(2:2)=inpl(1:1)
              regg(3:3)=inpl(4:4)
              regg(4:4)=inpl(3:3)
            else if (idigit(inpl(2:2),1) .eq. 1) then
c             HdXX -> dHXX
              regg(1:1)=inpl(2:2)
              regg(2:2)=inpl(1:1)
              regg(3:4)=inpl(3:4)
            else if (idigit(inpl(3:3),1) .eq. 1) then
c             HXdX -> dHXX
              regg(1:1)=inpl(3:3)
              regg(2:2)=inpl(1:1)
              regg(3:3)=inpl(2:2)
              regg(4:4)=inpl(4:4)
            else
              write (6,1000) ' H ',inpl
              regg=inpl
            end if
          end if
        else if (idigit(inpl(1:1),1) .eq. 1 .and.
     -           inpl(4:4) .eq. ' ') then
           regg(2:3)=inpl(2:3)
           if (inpl(3:4) .eq. '  ') then
             regg(3:3)=inpl(1:1)
           else
             regg(4:4)=inpl(1:1)
           end if
        else
          regg=inpl
        end if
      else
c       From PDB
c       Just move the number away from the first position, if any
        if (idigit(inpl(1:1),1) .eq. 1) then
          if (inpl(3:4) .eq. '  ' .or. inpl(3:4) .eq. "''" .or.
     -        inpl(3:4) .eq. '**' .or. inpl(3:4) .eq. "' " .or.
     -        inpl(3:4) .eq. '* ') then
c           Two-character H name
            regg(1:1)=inpl(2:2)
            regg(2:2)=inpl(1:1)
          else if (inpl(4:4) .eq. ' ' .or. inpl(4:4) .eq. '*' .or.
     -             inpl(4:4) .eq. "'") then
c           Three-character H name
            regg(1:2)=inpl(2:3)
            regg(3:3)=inpl(1:1)
          else
c           Four-character H name
c           Permute cyclicly
            regg(1:3)=inpl(2:4)
            regg(4:4)=inpl(1:1)
          end if
        else
          regg=inpl
        end if
      end if
      reg=regg
c     write (06,*) 'REGPDB reg=',reg
      return
1000  format(' ERROR: can not regularize 4-character',a,
     -  'name withot a digit:',a)
      end
      subroutine check23(line,index,nslt,inamcol1,inamcol2,nnamcol,
     -  maxrec)
      dimension index(nslt)
      character*132 line(maxrec)
      character*1 lcprev1,lcprev2
      character*5 atomnam,prev1,prev2
c     Look for atomnames X2,X3 without X1
      lcprev1=' '
      lcprev2=' '
      prev1(1:1)='     '
      prev2(1:1)='     '
      iasked=0
      do ia=1,nslt
        atomnam(1:nnamcol)=line(index(ia))(inamcol1:inamcol2)
        call lastchar(atomnam,lc,nnamcol)
c        write (77,2299) ia,atomnam,lc,lcprev1,lcprev2,prev1,prev2
c2299    format(i5,' anam=',a,' lc=',i1,' lcprev1,2=',a,1x,a,
c     -    ' prev1,2=',a,1x,a)
        if (atomnam(lc:lc) .eq. '3' .and.
     -      (atomnam(1:1) .eq. 'H' .or. atomnam(1:2) .eq. ' H')) then
          if ((lcprev2 .ne. '1' .or.
     -        prev2(1:lc-1) .ne. atomnam(1:lc-1)) .and.
     -        prev1(1:lc-1) .eq. atomnam(1:lc-1)) then
c           X2,X3 without X1 found
            if (iasked .eq. 0) then
              write (6,1000)
     -          atomnam(1:lc),prev1(1:lc),prev1(1:lc-1)//'1'
              call askyn('Do you want to shift H*2-H*3 to H*1-H*2',39,
     -          1,1,ishift,123)
              if (ishift .eq. 0) return
              iasked=1
            end if
c           Make the shift
            line(index(ia-1))(inamcol1+lc-1:inamcol1+lc-1)='1'
            line(index(ia))(inamcol1+lc-1:inamcol1+lc-1)='2'
          end if
        end if
        prev2=prev1
        prev1=atomnam
        lcprev2=lcprev1
        lcprev1=atomnam(lc:lc)
      end do
      return
1000  format(' Atom names ',a,' and ',a,' were found without ',a)
      end
      subroutine openfile(iunit,iswitch,prompt,lenprompt,mode,
     -  filename,namlen,notfound,idatapath,ib,nosys,noecho,ioverall)
      character*(*) prompt,filename
      character*3 mode
      character*100 datapath,datapaths
      common /environment/ npaths,ldatapath,ldatapaths(4),
     -  datapath,datapaths(4)
      common /logging/ logfile,ipredict
      character*11 formnam
      character*80 promptq
      dimension lenform(2),formnam(2)
      data formnam /'formatted  ','unformatted'/,lenform /9,11/
c     iswitch=1: Switch to terminal input if namlen=0
c     ib: 1/2: formatted/unformatted
c     nosys=1: don't try to look into datapath
c     ioverall=1: no matter what, overwrite without asking existing file
c     print *,'OPENFILE ipredict=',ipredict,' fn=',filename(1:namlen)
      notfound=0
      iover=0
100   if (namlen .le. 0) then
        write (promptq,1000) prompt(1:lenprompt)
        lprompt=lenprompt+17
        call getname(filename,namlen,promptq,lprompt,200,0)
c       print *,'Name read:',filename(1:namlen)
        if (namlen .eq.  0) then
          if (iswitch .eq. 1) then
            print *,'No name was provided - switching to terminal input'
            return
          else
            go to 100
          end if
        end if
      end if
      if (ipredict .eq. 1 .and. mode .eq. 'new') then
        print *,'Opening file ',filename(1:namlen)
        call askyn('If the file exists, do you want to overwrite it',47,
     -    1,-1,iover,0)
      end if
      lenfrm=lenform(ib)
110   open(unit=iunit,status=mode,file=filename(1:namlen),
     -  iostat=iopen,form=formnam(ib)(1:lenfrm))
      if (iopen .ne. 0) then
        if ((iover+ioverall) .gt. 0 .and. mode .eq. 'new') then
          open(unit=iunit,status='old',file=filename(1:namlen),
     -      iostat=iopen,form=formnam(ib)(1:lenfrm))
          if (iopen .gt. 0) then
            write (6,1004) 'overwriting',filename(1:namlen)
            stop
          end if
          return
        end if
        if (idatapath .eq. 2) then
c         Just return notfound=1
          notfound=1
          return
        else if (idatapath .eq. 3 .and. mode .eq. 'old') then
          write (6,1004) 'opening',filename(1:namlen)
          namlen=0
          go to 100
        end if
        if (mode .eq. 'old' .or. mode .eq. 'OLD') then
          if (idatapath .eq. 1 .and. nosys .eq. 0 .and.
     -             ldatapath .gt. 0) then
c           Try datapath
            filename=datapath(1:ldatapath)//filename(1:namlen)
            namlen=namlen+ldatapath
            open(unit=iunit,status=mode,file=filename(1:namlen),
     -        iostat=iopen,form=formnam(ib)(1:lenfrm))
            if (iopen .eq. 0) then
              filename(1:namlen)=filename(ldatapath+1:ldatapath+namlen)
              go to 200
            end if
          end if
          write (6,1004) 'opening',filename(1:namlen)
          namlen=-1
          go to 100
        else
          if (ipredict .eq. 0) then
            write (6,1004) 'opening',filename(1:namlen)
            call askyn(
     -        'Do you want to overwrite it if it already exists',48,
     -        1,-1,iover,0)
          end if
          if (iover .eq. 1) then
            print *,'Overwriting file ',filename(1:namlen)
            open(unit=iunit,status='old',file=filename(1:namlen),
     -        iostat=iopen,form=formnam(ib)(1:lenfrm))
            if (iopen .eq. 0) then
              close (iunit,status='delete')
              go to 110
            end if
            write (6,1002) filename(1:namlen)
          end if
          namlen=-1
          go to 100
        end if
      end if
200   if (namlen .eq. 0) namlen=lenchar(filename,1,200)
      if (noecho .eq. 0)
     -  print *,'File ', filename(1:namlen),' opened on unit ',iunit
      return
1000  format('Name of the ',a,' file')
1002  format(' There is still a problem opening file ',a)
1004  format(' Problem ',a,' file ',a)
      end
      subroutine checkdir(dirname,ldirname,iunit,iopen)
      character*(*) dirname
      character*80 filename
      filename(1:ldirname)=dirname(1:ldirname)
      filename(ldirname+1:ldirname+7)='/xyzXYZ'
      open(unit=iunit,status='new',file=filename(1:ldirname+7),
     -  iostat=iopen,form='formatted')
      if (iopen .eq. 0) close(iunit,status='delete')
      return
      end
      subroutine changeext(oldname,newname,leno,lenn,newext,lenext,
     -  insert,iask)
      character*200 oldname,newname,tempname
      character*(*) newext
      character*80 question,oldext
      tempname=oldname
      lenn=leno
      do while (lenn .gt. 0 .and. tempname(lenn:lenn) .ne. '.')
        lenn=lenn-1
      end do
      if (lenn .eq. 0) then
c       Input file had no '.' in it - just add extension
        lenn=leno+1
        tempname(lenn:lenn)='.'
      end if
      if (insert .eq. 0) then
c       Replace the extension
        tempname(lenn+1:lenn+lenext+1)=newext
        lenn=lenn+lenext+1
        if (iask .eq. 0) then
          newname=tempname
        else
          question='Output file name: '//tempname(1:lenn)//' - is it OK'
          lq=29+lenn
          call askyn(question,lq,1,1,ians,00)
          if (ians .eq. 1) then
            newname=tempname
          else
            lenn=0
          end if
        end if
      else
c       Insert extension between file name root and old extension
        oldext=tempname(lenn:leno)
        newname=tempname(1:lenn-1)//'_'//newext//oldext
        lenn=leno+lenext+1
      end if
      return
      end
      subroutine isdcd(filename,namlen,idcdtyp)
c     idcdtyp: 0: not a DCD file; 1: coordinate DCD file; 2: velocity DCD file
      character*200 filename
      character*4 header
      call openfile(97,0,' ',1,'old',filename,namlen,notfound,0,2,1,1,0)
      rewind 97
      idcdtyp=0
      read (97,end=99,err=99) header
      if (header .eq. 'CORD') idcdtyp=1
      if (header .eq. 'VELD') idcdtyp=2
99    close (97)
      return
      end
      subroutine isambertraj(filename,namlen,itrajtyp)
c     itrajtyp: 0: not aan Amber trajectory file
c               1: likely to be an Amber tarjectory file
      character*200 filename
      character* 132 line
      call openfile(97,0,' ',1,'old',filename,namlen,notfound,0,1,1,1,0)
      rewind 97
      itrajtyp=0
      read (97,1000,end=99,err=99) line
      call blankout(line,1,132)
      read (97,1000,end=99,err=99) line
      call lastchar(line,ifc,132)
      if (ifc .le. 72 .or. ifc .gt. 80) go to 99
      ndec=0
      do ic=1,ifc
       if (idigit(line(ic:ic),2) .eq. 0) go to 99
       if (line(ic:ic) .eq. '.') ndec=ndec+1
      end do
      if (ndec .ne. 10) go to 99
      itrajtyp=1
99    close (97)
      return
1000  format(a)
      end
      subroutine writeseq(outfile,namleno,numres,resnames,resnames1,
     -  numslv,line,index,inpcrdtyp,title,nslt,n,ionly,igl,maxrsd,
     -  maxrec)
c*****Generates a residue list in a variety of formats
      dimension index(maxrec)
      character*200 outfile,seqfile
      character* 132 line(maxrec)
      character*80 title
      character*1 ans,resnames1(maxrsd)
      character*4 segid
      character*8 resnames(maxrsd)
      character*1 aanames1
      character*2 mmodtoamb
      character*3 aanames3
      character*80 seqid
      common /atnamcon/ mmodtoamb(100),aanames1(58),aanames3(58),
     -  naanames,nnanames,nnammnames,nnames,ixwatnam
      common /columnlim/ incol(17),iidcol(17),iialtcol(17),
     -  iinamcol(2,17),iirescol(2,17),iiccol(2,17),iiresncol(2,17),
     -  iiseqncol(2,17),iisegcol(2,17),iiresidcol(2,17),iiqcol(2,17),
     -  iipotcol(2,17),iiocccol(2,17),iichemcol(2,17)
      character*1 abc,digits,hexdigits
      common /charactersets/ ihex(25),abc(62),digits(14),hexdigits(25)
      character*5 crdext
      common /iotypes/ iocha,iochaex,iobpdb,iocpdb,ioa3pdb,ioa4pdb,
     -  iommod,iommc,iommc4,iogro,iomol2,iomae,ioins,ionxyz,
     -  iosxyz,iosxyzrq,iograsp,iofull,lext(17),crdext(17)
      character*6 typnam(5)
      character*30 question
      data typnam /'Charmm','PDB   ','1-char','PIR   ','GCG   '/
c     print *,'WRITESEQ numres,numslv=',numres,numslv
      if (inpcrdtyp .gt. ioins) then
        print *,'This input format does not have sequence information'
        stop
      end if
      if (ionly .eq. 0) then
c       Run incidental to sequence generation - use default format w/o/ asking
        call askyn('Do you want a sequence list',27,1,-1,iseqls,0)
        if (iseqls .eq. 0) return
        iostyp=inpcrdtyp
        if (iostyp .gt. 2) iostyp=2
        write (6,2002) typnam(iostyp)
      else
c       Ask for format
        call quiz(ans,iostyp,' ',' ',0,
     -    'Output format for sequence list',31,0,5,6,igl,00)
      end if
      call changeext(outfile,seqfile,namleno,namlens,'seq',3,0,0)
      call openfile(30,0,' ',1,'new',seqfile,namlens,notfnd,0,1,1,0,0)
      isegidc1=iisegcol(1,inpcrdtyp)
      isegidc2=iisegcol(2,inpcrdtyp)
      iresnc1=iiresncol(1,inpcrdtyp)
      iresnc2=iiresncol(2,inpcrdtyp)
      iresc1=iirescol(1,inpcrdtyp)
      iresc2=iirescol(2,inpcrdtyp)
      nrescol=iresc2-iresc1+1
c     Write sequence input (by segments)
      if (nslt .eq. n) then
        index(n+1)=index(n)+1
        line(index(n+1))(isegidc1:isegidc1)='*'
        line(index(n+1))(iresnc1:iresnc1)='*'
      end if
      lenseq=1
      lenseqo=1
      ia=1
      nseg=0
      nfail=0
      do while (ia .le. nslt)
        nseg=nseg+1
        segid=line(index(ia))(isegidc1:isegidc2)
        do while (segid .eq.
     -    line(index(ia))(isegidc1:isegidc2) .and. ia .le. nslt)
            ia=ia+1
            if (line(index(ia))(iresnc1:iresnc2) .ne.
     -        line(index(ia-1))(iresnc1:iresnc2)) then
              resnames(lenseq)(1:nrescol)=
     -          line(index(ia-1))(iresc1:iresc2)
              lenseq=lenseq+1
            end if
        end do
        if (iostyp .eq. 1) then
          write (30,2022)
          ifc=1
          call nextchar(title,ifc,80)
          if (ifc .lt. 78) write (30,2020) '* ', title(1:78)
          write (30,2024) segid,lenseq-lenseqo,
     -      (resnames(i)(1:nrescol),i=lenseqo,lenseq-1)
          write (30,2021) segid
          if (numslv .gt. 0) then
            write (30,2023)
     -        line(index(nslt+1))(isegidc1:isegidc2),numslv
            if (line(index(nslt+1))(isegidc1:isegidc2) .eq.
     -          line(index(nslt))(isegidc1:isegidc2))
     -      write (6,2026) line(index(nslt))(isegidc1:isegidc2)
          end if
        else if (iostyp .eq. 2) then
          ir1=lenseqo
          nl=0
          do while (ir1 .le. lenseq-1)
            nl=nl+1
            ir2=min0(lenseq-1,ir1+12)
            write (30,2100) nl,segid(1:1),lenseq-lenseqo,
     -        (resnames(ir)(1:3),ir=ir1,ir2)
            ir1=ir2+1
          end do
        else if (iostyp .ge. 3) then
c         Convert to 1-character ID-s
          do ir=lenseqo,lenseq-1
            call changeprot(resnames(ir),resnames1(ir),2)
            if (resnames1(ir) .eq. '*') nfail=nfail+1
          end do
          if (iostyp .eq. 3) then
            if (nseg .eq. 1) write (30,2020) title
            write (30,2001) (resnames1(i),i=lenseqo,lenseq-1)
          else if (iostyp .eq. 4) then
c           PIR
            question='Sequence id of segment    '
            write (question(24:30),1002) nseg,abc(nseg)
            call getname(seqid,namlen,question,30,80,0)
            if (namlen .eq. 0) then
              seqid(1:1)=abc(nseg)
              namlen=1
            end if
            call lastchar(title,lentit,80)
            lentit=min0(80,lentit+4+namlen)
            write (30,2027) seqid(1:namlen),title(1:lentit),
     -        seqid(1:namlen)
            resnames1(lenseq)='*'
            write (30,2001) (resnames1(i),i=lenseqo,lenseq)
          else
            call gcgwrite(inpcrdtyp,line,index(1),seqfile,namlens,30,
     -        resnames1(lenseqo),lenseq-lenseqo,.false.,maxrec)
          end if
        end if
        lenseqo=lenseq
      end do
      write (6,2025) typnam(iostyp),numres-numslv,seqfile(1:namlens)
      if (numslv .gt. 0) print *,'Number of solvent residues=',numslv
      if (nfail .gt. 0) print *,'WARNING',nfail,' residues had no ',
     -  '1-character version'
      return
1002  format(i3,' [',a1,']')
2001  format(80a1)
2002  format(' Sequence is saved in ',a,' format',/,' Use the ',
     -  '<E>xtract sequence option to get it in other formats')
2020  format(a,a)
2021  format('GENERATE ',a4,' SETUP',/)
2022  format('READ SEQUENCE CARD')
2023  format('!Solvent segment',/,'READ SEQU',a4,1x,i6,/)
2024  format('* Sequence list from SIMULAID Segid=',a4,/,
     -  '* ',/,i5,/,(12a5))
2025  format(1x,a,' sequence (input) list of ',i6,' residues were',
     -  ' written to file ',/,5x,a)
2026  format(' WARNING: Solvent segmentid (',a4,') is the same as',
     -  ' the last solute segment id')
2027  format('>P1;',a,1x,a,/,'sequence:',a,':::::::0.0: 0.0')
2100  format('SEQRES',i4,1x,a1,i5,1x,13(1x,a3))
      end
      subroutine gcgwrite(inpcrdtyp,line,nhead,inpfile,leninpfile,ifile,
     -  seq,lenseq,skipnuc,maxrec)
      character*1 seq(lenseq),type
      character*4 pdbid
      character* 132 line(maxrec)
      character*200 inpfile
      character*40 keywords
      character*62 textinp
      character*5 crdext
      common /iotypes/ iocha,iochaex,iobpdb,iocpdb,ioa3pdb,ioa4pdb,
     -  iommod,iommc,iommc4,iogro,iomol2,iomae,ioins,ionxyz,
     -  iosxyz,iosxyzrq,iograsp,iofull,lext(17),crdext(17)
      logical skipnuc
c     Determine if protein or nucleic acid
      type='N'
      do i=1,lenseq
        if (seq(i) .ne. 'A' .and. seq(i) .ne. 'C' .and.
     -      seq(i) .ne. 'G' .and. seq(i) .ne. 'T' .and.
     -      seq(i) .ne. 'U') then
c         Amino acid residue found
          type='P'
          go to 31
        end if
      end do
31    if (skipnuc .and. type .eq. 'N') return
      if (ispdb(inpcrdtyp) .gt. 0) then
c       Translate header into keywords and pdb id
        nhline=0
        do i=1,nhead
          if (line(i)(1:6) .eq. 'HEADER') then
            nhline=nhline+1
            if (nhline .eq. 1) then
              pdbid=line(i)(63:66)
              keywords=line(i)(11:50)
            end if
          end if
        end do
      else
        call getname(keywords,len,'Keywords (max 40 chars)',23,40,0)
        call getname(pdbid,len,
     -    '4-character identifier (for LOCUS key)',38,4,0)
      end if
      write (ifile,1001) pdbid,lenseq
c     Calculate the checksum
      icheck=0
      icount=0
      do l=1,lenseq
        icount=icount+1
        lchar=ichar(seq(l))  !convert to ascii decimal form
        if (lchar.ge.97 .and. lchar.le.122)
     -    lchar=lchar-32     !change lower case to upper case
        icheck=icheck + icount*lchar
        if (icount.eq.57) icount=0
      end do
      lsum=icheck/10000                  !integer division
      icheck=icheck - lsum*10000        !remainder which is the checksum
      if (ispdb(inpcrdtyp) .gt. 0) then
c       Get compound name as definition
        ncline=0
        do i=1,nhead
          if (line(i)(1:6) .eq. 'COMPND') then
            ncline=ncline+1
            if (ncline .eq. 1) then
              write (ifile,1003) line(i)(11:72)
            else
              write (ifile,1004) line(i)(11:72)
            end if
          end if
        end do
      else
        call getname(textinp,len,'Compound name (for DEFINITION key)',
     -    34,62,0)
        write (ifile,1003) textinp
      end if
      write (ifile,1002) inpfile(1:leninpfile)
      write (ifile,1006) keywords
      write (ifile,1005) pdbid,lenseq,type,icheck
      nline=(lenseq-1)/50+1
      if=1
      linelim=50
      do iline=1,nline
        linc=(iline-1)*50
        if (iline .eq. nline) linelim=lenseq-linc
        nfirst=(iline-1)*50+1
        write (ifile,1000) nfirst,(seq(linc+l),l=if,linelim)
      end do
      return
1000  format(i8,1x,5(10a1,1x))
1001  format('LOCUS       ',a4,'------',i7,' AA    PROT',
     -  12x,'PRE-ENTRY 00/00/0')
1002  format('ORIGIN      ',a)
1003  format('DEFINITION  ',a62)
1004  format(12x,a62)
1005  format(1x,a4,' Length:',i5,' April 2, 1992      Type: ',a1,
     -  '  Check:',i6,' ..')
1006  format('KEYWORDS    ',a62)
      end
      subroutine pbctype(ioppbc,npbc,ixyzhex,nonone,igl)
      dimension ixyzhex(3)
      common /pbcrotmat/ torot_ac(3,3),torot_ca(3,3),tofac_ac,tofac_ca
      common /rotmat/ matrot0(4,4),matrot(4,4),nomat0
      character*1 xyz
      common /axislab/ xyz(3)
      character*1 ans,ansedge,ansvertex
100   call quiz(ans,ians,'r',' ',0,'PBC cell type',13,0,5,6,igl,0)
      if (ans .eq. 'n') then
c       None
        if (nonone .eq. 0) then
          ioppbc=-1
          npbc=1
        else
          print *,'No PBC choice is invalid in this context'
          go to 100
        end if
      else if (ans .eq. 'c') then
c       Cubic
        ioppbc=1
        npbc=1
      else if (ans .eq. 'r') then
c       Rectangular
        ioppbc=2
        npbc=3
      else if (ans .eq. 'f') then
c       Face-centered cubic
        ioppbc=3
        npbc=1
c       Face-centered cubic
      else if (ans .eq. 'h' .or. ans .eq. 'w') then
c       Hexagonal prizms
200     call quiz(ansedge,ixyzhex(1),' ',
     -    'parallel to the prism length',-28,'axis',4,0,5,6,igl,0)
        call quiz(ansvertex,ixyzhex(2),' ',
     -    'going through the hexagon vertex',-32,'axis',4,0,5,6,igl,0)
        if (ansedge .eq. ansvertex) then
          print *,'ERROR: can not use the same axes twice'
          go to 200
        end if
        ixyzhex(3)=1
        do while (ixyzhex(3) .eq. ixyzhex(1) .or.
     -    ixyzhex(3) .eq. ixyzhex(2))
          ixyzhex(3)=ixyzhex(3)+1
        end do
        write (6,2000) xyz(ixyzhex(1)),xyz(ixyzhex(2))
        if (ans .eq. 'h') then
          ioppbc=4
          npbc=2
        else
c         Skewed hexagonal prizm
          ioppbc=5
          npbc=3
        end if
      else if (ans .eq. 't' .or. ans .eq. 'o') then
c       Truncated Octahedron,
        npbc=1
        torot_ac(1,1)=1.0/sqrt(3.0)
        torot_ac(2,1)=1.0/sqrt(3.0)
        torot_ac(3,1)=1.0/sqrt(3.0)
        torot_ac(1,2)=-1.0/sqrt(6.0)
        torot_ac(2,2)=-1.0/sqrt(6.0)
        torot_ac(3,2)=2.0/sqrt(6.0)
        torot_ac(1,3)=1.0/sqrt(2.0)
        torot_ac(2,3)=-1.0/sqrt(2.0)
        torot_ac(3,3)=0.0
        tofac_ac=2.0/sqrt(3.0)
        torot_ca(1,1)=1.0/sqrt(3.0)
        torot_ca(1,2)=1.0/sqrt(3.0)
        torot_ca(1,3)=1.0/sqrt(3.0)
        torot_ca(2,1)=-1.0/sqrt(6.0)
        torot_ca(2,2)=-1.0/sqrt(6.0)
        torot_ca(2,3)=2.0/sqrt(6.0)
        torot_ca(3,1)=1.0/sqrt(2.0)
        torot_ca(3,2)=-1.0/sqrt(2.0)
        torot_ca(3,3)=0.0
        tofac_ca=sqrt(3.0)/2.0
        if (ans .eq. 't') then
c         Charmm convention (x normal to square)
          ioppbc=6
          write (6,2011)
        else if (ans .eq. 'o') then
c         Truncated Octahedron, Amber/NAMD convention (X normal to hexagon)
          ioppbc=7
          npbc=1
          write (6,2012)
        end if
      else if (ans .eq. 'x') then
c       Hexagonal close packed
        ioppbc=8
        npbc=1
      else if (ans .eq. 'd') then
c       Octahedral
        ioppbc=9
        npbc=1
        write (6,2013)
      else if (ans .eq. 'i') then
c       Image-cell file input
        ioppbc=10
      else if (ans .eq. 's') then
c       Spehere
        ioppbc=11
        npbc=1
      else
        print *,'PROGRAM ERROR'
      end if
      return
2000  format(' Hexagonal prism edge: along the ',a,' axis',/,
     -  ' Axis going through the hexagon: ',a)
2011  format(' Charmm convention - X axis is normal to a square')
2012  format(' Amber/NAMD convention - X axis is normal to a hexagon')
2013  format(' NOTE: For now, this PBC can not be used for optimizing',
     -  ' orientation')
      end
      subroutine pbcsize(ioppbc,edge,npbc)
      dimension edge(3)
      character*1 xyz
      common /axislab/ xyz(3)
      common /numbers/ sq3,sq3inv,sq3p2,sq2p3
      if (ioppbc .eq. 0) then
c       Will be read with the images
      else if (ioppbc .eq. 1) then
        call getreal('Edge length (A)',15,999999.0,edge(1),1,0)
      else if (ioppbc .eq. 2) then
        do k=1,3
          call getreal('Edge length in the '//xyz(k)//' direction (A)',
     -      34,999999.0,edge(k),1,0)
        end do
      else if (ioppbc .eq. 3) then
        call getreal('Edge parameter of the FCC cell (A)',34,999999.0,
     -    edge(1),1,58)
      else if (ioppbc .eq. 4) then
c       Hexagonal prism (regular)
        call getreal('Length of the prism (A)',23,999999.0,edge(1),1,0)
        call getreal('Edge of the hexagon (A)',23,999999.0,edge(2),1,0)
      else if (ioppbc .eq. 5) then
c       Skewed hexagonal prism
        call getreal('Length of the prism (A)',23,999999.0,edge(1),1,0)
        call getreal('Cell length (a) along Cartesian axis (A)',40,
     -    999999.0,edge(3),1,59)
        call getreal(
     -    'Cell length (b) at ca 120 deg of Cartesian axis (A)',51,
     -    999999.0,edge(2),1,59)
      else if (ioppbc .eq. 6) then
c       Truncated octahedron, Charmm convention (x axis to a square face)
        call getreal('Charmm periodic cell X coordinate (A)',37,
     -    999999.0,cellx,1,60)
        edge(1)=cellx/2.0
      else if (ioppbc .eq. 7) then
c       Truncated octahedron, Amber/NAMD convention (x axis to a hexagon face)
        call getreal('Amber/NAMD periodic cell X coordinate (A)',41,
     -    999999.0,cellx,1,60)
        edge(1)=(cellx/2.0)/sq3p2
      else if (ioppbc .eq. 8) then
c       Hexagonal close packing
        call getreal('Inscribed sphere diameter (A)',29,999999.0,
     -    edge(1),1,61)
      else if (ioppbc .eq. 9) then
        call getreal('Edge of the rhomboid (A)',24,999999.0,
     -    edge(1),1,00)
      else if (ioppbc .eq. 10) then
        call getreal('Radius of the sphere',20,999999.0,edge(1),1,0)
      end if
      do k=npbc+1,3
        edge(k)=edge(npbc)
      end do
      return
      end
      subroutine readimg(cell,ncell,igl)
      dimension cell(3,27)
      character*1 xyz
      common /axislab/ xyz(3)
      character*1 abc,digits,hexdigits
      common /charactersets/ ihex(25),abc(62),digits(14),hexdigits(25)
      character*1 ans
      character*80 line
      character*200 imgfile
      dimension scale(3)
c     print *,'READIMG cell=',scale
      call quiz(ans,ians,' ','image',5,'PBC cell type',13,0,5,6,igl,0)
      lenfilename=0
      call openfile(30,0,'image',5,'old',imgfile,lenfilename,notfnd,
     -  1,1,1,0,0)
      if (ans .eq. 'c') then
c       Charmm
        do k=1,3
          call getreal(
     -    'Charmm '//xyz(k)//' axis image parameter (@'//abc(58+k)//')',
     -      34,999999.0,scale(k),1,0)
        end do
        ncell=1
        call zeroit(cell,3)
        rewind 30
        line(1:3)='   '
        do while (line(1:3) .ne. 'END' .and. line(1:3) .ne. 'end')
          read (30,888,end=999) line
c         write (6,888) line
          if (line(1:3) .eq. 'END') then
            print *,'Read ',ncell-1,' images - (0,0,0) was added'
c           write (6,1003) (ic,(cell(k,ic),k=1,3),ic=1,ncell)
          else
            if (line(1:5) .eq. 'TRANS') then
              ncell=ncell+1
              read (line(7:36),900,err=998) (cell(k,ncell),k=1,3)
              do k=1,3
                cell(k,ncell)=-scale(k)*cell(k,ncell)
              end do
            end if
          end if
        end do
      else
c       Simulaid format
        do k=1,3
          call getreal('Multiplying factor for the '//xyz(k)//' axis',
     -      33,1.0,scale(k),1,37)
        end do
        ncell=0
        do while (.true.)
          read (30,1001,err=998,end=100) (cell(k,ncell+1),k=1,3)
          ncell=ncell+1
          do k=1,3
            cell(k,ncell)=cell(k,ncell)*scale(k)
          end do
        end do
100     print *,'Read ',ncell,' cell centers - (0,0,0) is assumed ',
     -    'to be listed'
      end if
      return
998   write (6,1000) ncell,line(7:36)
      stop
999   print *,'ERROR: Image file is not terminated properly'
      stop
900   format(3f10.0)
888   format(a80)
c1003  format(' The PBC cell centers:',/,30(i5,3f10.4,/))
1000  format(' ERROR: invalid cell coordinate input for cell ',i3,
     -  ':',/,8x,a)
1001  format(3f10.5)
      end
      subroutine setpbccell(quest,lquest,edge,edge_gen,cell,ncell,
     -  cellalt,ixyzhex,npbc,ioppbc,iusepbc,vol,nw,rinscr,
     -  rcirc,nonone,igl)
      dimension edge(3),edge_gen(3,3),cell(3,27),cellalt(3,27),
     -  ixyzhex(3)
      character*(*) quest
      iusepbc=1
      if (lquest .gt. 0) call askyn(quest,lquest,1,-1,iusepbc,0)
      if (iusepbc .eq. 1) then
        call pbctype(ioppbc,npbc,ixyzhex,nonone,igl)
        call pbcsize(ioppbc,edge,npbc)
        if (ioppbc .eq. 0) then
          call readimg(cell,ncell,igl)
        else
          call crorgn(edge,edge_gen,ioppbc,3,ncell,cell,cellalt,
     -      ixyzhex,rinscr,rcirc)
        end if
        call prtcell(ioppbc,edge,edge_gen,0.0,vol,nw,1)
      end if
      if (ioppbc .eq. -1) iusepbc=0
      return
      end
      subroutine compact(co,cn,iatnum,ih,n,nnh,c0,rmin,rorgext,rorgcom,
     -  list,np,nlist,nocom,r,maxrec)
      dimension co(3,n),cn(3,n),iatnum(n),ih(n),c0(3),list(n),r(n)
c     Calculate the center and radius of the smallest sphere enclosing
c     all atoms in c
      character*2 iatnm2
      common /atnam/ aw(99),nval(99),nvalmax(99),mmofan(99),
     -  mmatno(64),iatnm2(99)
      dimension cmin(3),cmax(3),del(3),c1(3),c2(3),c3(3),c4(3),ca(3),
     -  rd(4),czero(3),cai(2),com(3),iopp(3)
      data iopp/0,0,0/,idiagplane /0/,nopp /0/
      call zeroit(czero,3)
c     print *,'COMPACT n,nnh=',n,nnh
      call extension(co,ih,nnh,1,n,cmin,cmax,c0,0,0,v)
      r0=0.0
      do k=1,3
c       print *,'c0,cmax,cmin=',c0(k),cmax(k),cmin(k)
        if (cmax(k) -c0(k) .gt. r0) r0=cmax(k)-c0(k)
      end do
      if (nocom .eq. 0) then
        do i=1,n
          r(i)=0.0
          if (iatnum(i) .gt. 0) r(i)=aw(iatnum(i))
        end do
        call cofms(co,com,n,r)
      end if
c     Calculate distances from c0, collect those within 60% of r0
      r02=r0**2
c     print *,'R02=',r02
      extfac=0.36
31    nlist=0
      rmaxext=0
      do ii=1,nnh
        i=ih(ii)
        ri2=dist2(co(1,i),c0)
c       print *,'i=',i,' ri2,r02=',ri2,r02
        if (ri2 .ge. r02*extfac) then
          nlist=nlist+1
          list(nlist)=i
          r(nlist)=ri2
          if (ri2 .gt. rmaxext) then
            rmaxext=ri2
            lmax=nlist
          end if
        end if
      end do
      if (nlist .lt. 2) then
        print *,'Too few atoms remained:',nlist
        call askyn('Do you want to keep all atoms instead',37,
     -    1,1,ikeep,0)
        if (ikeep .eq. 0) stop
        extfac=0.0
        go to 31
      end if
      nlstorg=nlist
      rorgext=sqrt(rmaxext)
      if (rorgext .lt. 0.01) then
        print *,'ERROR: The original radius of the solute is < 0.01'
        stop
      end if
c     print *,'nlist,rorgext=',nlist,rorgext
      if (nocom .eq. 0) then
        rmaxcom=0.0
        do ii=1,nnh
          i=ih(ii)
          ri2=dist2(co(1,i),com)
          if (ri2 .gt. rmaxcom) then
            rmaxcom=ri2
          end if
        end do
        rorgcom=sqrt(rmaxcom)
      end if
c     write (6,2344) (list(i),i=1,6),(r(i),i=1,6)
      nstep=1
      np=1
      call swapl(list,r,nlist,lmax,-1,maxrec)
      call lpshiftc(co,list,nlist,del,c0,np,maxrec)
c     write (6,2344) (list(i),i=1,6),(r(i),i=1,6)
      call findshift(co,r,list,c0,del,nlist+1,nlist,rlambda,lmax,nzero,
     -  maxrec)
c     print *,'nzero(1)=',nzero
c     print *,'lambda=',rlambda
      call transc(c0,del,rlambda)
      call newdist(r,co,list,c0,nlstorg,maxrec)
c     write (6,2344) (list(i),i=1,6),(r(i),i=1,6)
      np=2
      nlistdel=0
      call swapl(list,r,nlist,lmax,-1,maxrec)
30    nstep=nstep+1
      call lpshiftc(co,list,nlist,del,c0,np,maxrec)
c2344 format(' Nlist=',6i2,' r=',6f8.3)
      call findshift(co,r,list,c0,del,nlist+1,nlist-nlistdel,
     -  rlambda,lmax,nzero,maxrec)
c     print *,'nzero(2)=',nzero
c     print *,'lambda=',rlambda
      nlistdel=0
      do k=1,3
        c1(k)=co(k,list(nlist+1))-c0(k)
      end do
      rlammax=scprod(c1,del)
      if ((rlambda .ge. rlammax .or. rlambda .eq. 0.0) .and.
     -  nzero .le. 1) then
c       Make these two atoms the diameter
        write (6,1001) list(nlist+1),list(nlist+2)
        rlambda=rlammax
        go to 90
      end if
c     Check the triangle lmax, nlist+1, nlist+2 if it has an obtuse angle
33    call angles(r(lmax),r(nlist+1),r(nlist+2),cal,ca(1),ca(2))
      do ic=1,2
        if (ca(ic) .lt. 0.0) then
          call swapl(list,r,nlist+ic,lmax,0,maxrec)
          call swapl(list,r,nlist-nlistdel,lmax,0,maxrec)
          nlistdel=nlistdel+1
c         nlistdel>0 will make the lambda search bypass the last nlistdel ats
          call transc(c0,del,rlambda)
          call newdist(r,co,list,c0,nlstorg,maxrec)
          write (6,1002) list(nlist),list(nlist+1),list(nlist+2)
c         Go back to generate new triangle
          go to 30
        end if
      end do
      call transc(c0,del,rlambda)
      call newdist(r,co,list,c0,nlstorg,maxrec)
      np=3
c     write (6,6666) r(lmax),(r(nlist+ii),ii=1,np)
      if (nlistdel .eq. 0) then
        call swapl(list,r,nlist,lmax,-1,maxrec)
      else
        call swapl(list,r,nlist,nlist-nlistdel,0,maxrec)
        call swapl(list,r,nlist,lmax,-1,maxrec)
      end if
c     write (6,6666) r(lmax),(r(nlist+ii),ii=1,np)
c6666  format(' Distances of vertices from c0=',4f8.2)
40    nstep=nstep+1
c     Find shift preserving the distance from three points
      do k=1,3
        c1(k)=co(k,list(nlist+2))-co(k,list(nlist+1))
        c2(k)=co(k,list(nlist+3))-co(k,list(nlist+1))
      end do
      call vprd(c1,c2,del)
      do k=1,3
        c1(k)=co(k,list(nlist+1))-c0(k)
      end do
      facsgn=1.0
      if (scprod(c1,del) .lt. 0.0) facsgn=-1.0
      call norm(del,facsgn)
      call findshift(co,r,list,c0,del,nlist+1,nlist-nlistdel,
     -  rlambda,lmax,nzero,maxrec)
      nlistdel=0
c     Check for maximum
      rlammax=scprod(c1,del)
      idiagplane=0
      if (rlambda .ge. rlammax) then
c       First three atoms are in a diagonal plane
        write (6,1003) list(nlist+1),list(nlist+2),list(nlist+3)
        rlambda=rlammax
        idiagplane=1
        go to 90
      end if
c     Check for center of the sphere being outside the tetrahedron
      call transc(c0,del,rlambda)
      call newdist(r,co,list,c0,nlstorg,maxrec)
      rlambda=0.0
      ix=list(lmax)
      do ip=1,np
c       iopp(i) will be set to ip if atom (nlist+ip) and c0 are separated
c       by a tetrahedron face
        nopp=0
        call getindex(nlist,ip,iv,i1,i2)
        do k=1,3
          c1(k)=co(k,list(i1))-co(k,ix)
          c2(k)=co(k,list(i2))-co(k,ix)
          c3(k)=co(k,list(iv))-co(k,ix)
          c4(k)=c0(k)-co(k,ix)
        end do
        call vprd(c1,c2,ca)
        if (scprod(ca,c3)*scprod(ca,c4) .lt. 0.0) then
          nopp=nopp+1
          iopp(nopp)=ip
        end if
      end do
      if (nopp .eq. 1) then
c       First drop (temporarily) vertex nlist+iopp(1)
        ip=nlist+iopp(1)
c       swap vertex ip with nlist+1
        call swapl(list,r,nlist+1,ip,0,maxrec)
        write (6,1004) list(lmax),list(nlist+1),list(nlist+2),
     -    list(nlist+3)
c       rr=sqrt(r(nlist+1))
c       print *,'R=',rr
c       write (6,6666) r(lmax),(r(nlist+ii),ii=1,np)
        nlistdel=nlistdel+1
c       nlistdel>0 will make the lambda search bypass the last nlistdel ats
        nlist=nlist+1
        np=np-1
c       Go back to check the triangle
        go to 33
      else if (nopp .eq. 2) then
c       Two opposing vertices found
        do ic=1,2
          ip=iopp(ic)
          call getindex(nlist,ip,iv,i1,i2)
          call angles(dist2(co(1,i1),co(1,i2)),r(i1),r(i2),
     -                caix,cai(1),cai(2))
          if (cai(1)*cai(2) .gt. 0.0) then
c           Acute triangle face found, just drop ip
c           Swap vertex ip with lmax
            call swapl(list,r,nlist+ip,lmax,0,maxrec)
c           Move ip to the top of the list for temporary disregard
            call swapl(list,r,nlist,lmax,0,maxrec)
            nlistdel=nlistdel+1
            write (6,1005) list(nlist),
     -        list(nlist+1),list(nlist+2),list(nlist+3)
c           rr=sqrt(r(nlist+1))
c           print *,'R=',rr
c           write (6,6666) (r(nlist+ii),ii=1,np)
c           Go back to generate new tetrahedron
            go to 40
          end if
        end do
c       If reached here, neither faces are acute triangles - temporarily
c       drop both
        call swapl(list,r,nlist+iopp(1),nlist+1,0,maxrec)
        call swapl(list,r,nlist+iopp(2),nlist+2,0,maxrec)
        nlistdel=2
        nlist=nlist+2
        np=2
        go to 30
      end if
c     If reached here, center is inside the tetrahedron - done.
      np=4
      call swapl(list,r,nlist,lmax,-1,maxrec)
c     Calculation done, perform the shift
90    call transc(c0,del,rlambda)
      call newdist(r,co,list,c0,nlstorg,maxrec)
c     write (6,6666) (r(nlist+ii),ii=1,np)
      call shiftmol(co,n,c0,cn,-1.0)
c     Calculate the minimum radius (as the maximum of the surface atom radii)
      rminmax=0.0
      do ip=1,np
        ii=list(nlist+ip)
        rd(ip)=sqrt(cn(1,ii)**2+cn(2,ii)**2+cn(3,ii)**2)
        if (rminmax .lt. rd(ip)) rminmax=rd(ip)
      end do
      rmin=rminmax
      write (6,1000) (list(nlist+ip),ip=1,np)
      ndiff=0
      do ip=2,np
        if (abs(rd(ip)-rmin) .gt. 0.001) ndiff=ndiff+1
      end do
      if (ndiff-idiagplane .gt. 0) then
          print *,'PROGRAM ERROR: The radii of the points on',
     -    ' the sphere are different:'
         write (6,1010) (rd(ii),ii=1,np)
      end if
      call chksphr(cn,ih,n,nnh,rmin,czero)
      return
1000  format(' --- Sphere-spanning atoms:',4i6)
1001  format(' --- Diameter found spanned by atoms',2i6)
1002  format(' --- Center of circle outside the triangle',3i6)
1003  format(' --- Diagonal plane found spanned by atoms',3i6)
1004  format(' --- Sphere center is outside one tetrahedron face',4i6)
1005  format(' --- Sphere center is outside two tetrahedron faces',4i6)
1010  format('Radii=',4f8.4)
      end
      subroutine swapl(list,r,nlist,lmax,nlincr,maxrec)
      dimension list(maxrec),r(maxrec)
c     Shift the atom lmax to the end of the list,
c     change nlist by nlincr (-1 or 0)
c     print *,'nlist,lmax=',nlist,lmax
c     print *,'SWAPL nlist,lmax=',nlist,lmax
      call swapi4(list(nlist),list(lmax))
      rr=r(nlist)
      r(nlist)=r(lmax)
      r(lmax)=rr
      nlist=nlist+nlincr
      return
      end
      subroutine lpshiftc(c,list,nlist,del,c0,np,maxrec)
      dimension c(3,maxrec),list(maxrec),del(3),c0(3)
c     Generate linear or planar shift
      do k=1,3
        del(k)=0.0
        do ip=1,np
          del(k)=del(k)+c(k,list(nlist+ip))
        end do
        del(k)=del(k)/np-c0(k)
      end do
      call norm(del,1.0)
      return
      end
      subroutine findshift(c,r,list,c0,del,is,nlist,rlambda,lmax,nzero,
     -  maxrec)
      dimension c(3,maxrec),r(maxrec),list(maxrec),c0(3),del(3)
c     Calculate the allowed shift of center, rlambda, along del
      nzero=0
      rl2=r(is)
      rl=sqrt(rl2)
      coslrl=0.0
      do k=1,3
        coslrl=coslrl+del(k)*(c(k,list(is))-c0(k))
      end do
c     cosl=cosl/rl
      rlambda=rl2
      do i=1,nlist
        ri2=r(i)
        ri=sqrt(ri2)
        cosiri=0.0
        do k=1,3
          cosiri=cosiri+del(k)*(c(k,list(i))-c0(k))
        end do
c       cosi=cosi/ri
c       if (rl*cosl .ne. ri*cosi) then
c         rlambdai=(rl2-ri2)/(2.0*(rl*cosl-ri*cosi))
        if (coslrl .ne. cosiri) then
          rlambdai=(rl2-ri2)/(2.0*(coslrl-cosiri))
        else
          rlambdai=0.0
        end if
c        write (6,7777) i,rl2,ri2,rl,ri,cosl,cosi,rlambdai
c7777    format(i3,' rli2=',2f8.3,' rli=',2f6.2,' cli=',2f8.5,
c     -    ' l=',f8.3)
        if (rlambdai .lt. rlambda .and. rlambdai .ge. 0.0) then
          rlambda=rlambdai
          lmax=i
        end if
        if (rlambdai .lt. 1.e-4 .and. rlambdai .ge. 0.0) then
          call swapl(list,r,nlist-nzero,lmax,-1,maxrec)
          lmax=nlist-nzero
          nzero=nzero+1
        end if
      end do
      return
      end
      subroutine getindex(nlist,ip,iv,i1,i2)
c     Generate the vertex indices corresponding the (nlist+ip)th list element
      iv=nlist+ip
      i1=nlist+mod(ip,3)+1
      i2=nlist+mod(ip+1,3)+1
      return
      end
      subroutine transc(c0,del,rlambda)
      dimension c0(3),del(3)
      do k=1,3
        c0(k)=c0(k)+rlambda*del(k)
      end do
      return
      end
      subroutine newdist(r,c,list,c0,n,maxrec)
      dimension r(maxrec),c(3,maxrec),list(maxrec),c0(3)
      do i=1,n
        li=list(i)
        r(i)=dist2(c(1,li),c0)
      end do
      return
      end
      subroutine chksphr(c,ih,n,nnh,rmin,czero)
      dimension c(3,n),ih(n),czero(3)
c     Check if nothing is outside the sphere
      do ii=1,nnh
        i=ih(ii)
        rr=dist2(c(1,i),czero)
        if (rr-0.001 .gt. rmin**2) then
          print *,'PROGRAM ERROR: Atom ',i,' is outside the sphere'
          rr=sqrt(rr)
          print *,'  rmin=',rmin,' r=',rr
        end if
      end do
      return
      end
      subroutine angles(e1,e2,e3,ca1,ca2,ca3)
      ee1=sqrt(e1)
      ee2=sqrt(e2)
      ee3=sqrt(e3)
      ca1=(e2+e3-e1)/(2.0*ee2*ee3)
      ca2=(e1+e3-e2)/(2.0*ee1*ee3)
      ca3=(e1+e2-e3)/(2.0*ee1*ee2)
      return
      end
      function angleijk(c,n,i1,i2,i3,iout)
c#    MMC routine 347 lstmod: 05/03/05
c*****Calculates the c1-c2-c3 angle
      dimension c(3,n)
      real*8 cosangle
      d12=dist2(c(1,i1),c(1,i2))
      d23=dist2(c(1,i2),c(1,i3))
      d13=dist2(c(1,i1),c(1,i3))
      if (d12*d23 .gt. 0.0) then
        cosangle=dble((d12+d23-d13)/(2.0*sqrt(d12*d23)))
        angleijk=dacoscheck(cosangle,ccc,1,iout,'ANGLEIJK')
      else
        angleijk=0.0
      end if
      end
      function dihangl(a,ix,jx,kx,lx,noneg,maxrec)
c#    MMC routine 345 lstmod: 06/22/09
c*****Returns the dihedral angle of atoms a(ix),a(jx),a(kx),a(lx)
      dimension a(3,maxrec)
      real*8 ai(3),aj(3),ak(3),al(3)
      real*8 dij(3),dkj(3),dlk(3),dii(3),djj(3),cp(3),cosijk,cosjkl,
     -  cosijk1,cosjkl1,costa,rjk,rjk2,rij,rij2,rkl,rkl2,dcoszero
      real*8 dscprod
      data dcoszero/0.99999d0/
c     print *,'DIHANGL ix,jx,kx,lx=',ix,jx,kx,lx
      do k=1,3
        ai(k)=a(k,ix)
        aj(k)=a(k,jx)
        ak(k)=a(k,kx)
        al(k)=a(k,lx)
      end do
      call arrdistsd(ak,aj,rjk,rjk2)
      call arrdistsd(ai,aj,rij,rij2)
      call arrdistsd(ak,al,rkl,rkl2)
c     if (LEVTEST .gt. 1) write (77,7710) 1,ai,2,aj,3,ak,4,al
c     if (LEVTEST .gt. 2) then
c       write (77,7711) rjk,rij,rkl
c       call arrdistsd(ai,ak,rik,rik2)
c       call arrdistsd(aj,al,rjl,rjl2)
c       write (iout,7717) rik,rjl
c     end if
      call darrdiff(ai,aj,dij,3)
      call darrdiff(ak,aj,dkj,3)
      call darrdiff(al,ak,dlk,3)
      cosijk1=dscprod(dij,dkj)
      cosjkl1=-dscprod(dlk,dkj)
c     if (LEVTEST .gt. 3) write (iout,7712) cosijk1,cosjkl1
      cosijk=cosijk1/(rij*rjk)
      cosjkl=cosjkl1/(rkl*rjk)
      if (cosijk .lt. -dcoszero .or. cosijk .gt. dcoszero .or.
     -  cosjkl .lt. -dcoszero .or. cosjkl .gt. dcoszero) then
        write (6,7716) cosijk,cosjkl
        dihangl=0.d0
        return
      end if
c     if (LEVTEST .gt. 3) write (iout,7713) cosijk,cosjkl
      costa=0.d0
      do k=1,3
        dii(k)=dij(k)-dkj(k)*cosijk1/rjk2
        djj(k)=dlk(k)+dkj(k)*cosjkl1/rjk2
        costa=costa+dii(k)*djj(k)
      end do
      costa=costa/(rij*rkl*sqrt((1.0-cosijk*cosijk)*
     -  (1.0-cosjkl*cosjkl)))
c     if (LEVTEST .gt. 3) write (iout,7714) costa
      angle=dacoscheck(costa,ccc,1,6,'DIHANGL')
c     Decide sign of the angle
      call dvprd(dii,dkj,cp)
      if (cp(1)*djj(1)+cp(2)*djj(2)+cp(3)*djj(3) .gt. 0.0) angle= -angle
c     if (LEVTEST .gt. 1) write (iout,7715) angle*180.0/3.141592,costa
      if (angle .lt. 0.d0 .and. noneg .eq. 1)
     -   angle = angle + 6.2831853170d0
      dihangl=angle
      return
c7710  format(' DIHANGL:',4(' c',i1,'=',f8.4,2f9.4))
c7711  format(' DIHANGL: rjk=',f12.6,' rij=',f12.6,' rkl=',f12.6)
c7712  format(' DIHANGL: cosijk1=',f9.5,' cosjkl1=',f9.5)
c7713  format(' DIHANGL: cosijk=',f9.5,' cosjkl=',f9.5)
c7714  format(' DIHANGL: costa=',f9.5)
c7715  format(' DIHANGL: torsion=',f10.5,' cos(tors)=',f8.5)
7716  format(' DIHANGL: colinear atoms, torsion set to 0',
     -  ' cosijk,jkl=',2e13.5)
c7717  format(' DIHANGL: rik=',f12.6,' rjl=',f12.6)
      end
      function dacoscheck(dargin,argin,idbp,iout,lab)
c*****Make sure cos is in the [-1,1] range, return dacos(arg)
      real*8 dargin,arg
      character*(*) lab
      if (idbp .eq. 0) arg=argin
      if (idbp .eq. 1) arg=dargin
      if (arg .lt. -1.0d0) then
        if (arg .lt. -1.01d0) write (iout,1000) arg,lab
        arg=-1.0d0
        dacoscheck=dacos(-1.0d0)
      else if (arg .gt. 1.0d0) then
        if (arg .gt. 1.01d0) write (iout,1000) arg,lab
        arg=1.0d0
        dacoscheck=0.0d0
      else
        dacoscheck=dacos(arg)
      end if
      return
1000  format(' PROGRAM ERROR: invalid sin or cos value:',f10.6,
     -  ' in subroutine ',a)
      end
      subroutine normplane(a,b,c,rn)
      dimension a(3),b(3),c(3),rn(3)
c     rn is the normal to the plane of a,b, and c
      dimension d1(3),d2(3)
      do k=1,3
        d1(k)=a(k)-b(k)
        d2(k)=c(k)-b(k)
      end do
      call vprd(d1,d2,rn)
      call norm(rn,1.0)
      return
      end
      subroutine radcirc(a,b,c,r)
      dimension a(3),b(3),c(3)
c     r is the radius of the circle going through a,b, and c
      call angdistw(b,a,c,rHB,rb,rac,angabc)
      sabc=sin(angabc)
      if (sabc .lt. 0.00001) then
        r=999999.9
      else
        r=rac/(sin(angabc)*2.0)
      end if
      return
      end
      subroutine pseudorot(a,n,ix,nmem,nneig,ineig,psr5,psr,npsr,ansrun,
     -  incgen,z,r,sinpsrs,cospsrs,q,qs,q2s,zav,zsq,zavs,zsqs,
     -  iprint,iout,nconf,radtodeg,maxng,maxrec)
      real*8 sinpsrs,cospsrs,qs,q2s,zavs,zsqs
      dimension a(3,n),ix(nmem),nneig(n),ineig(maxng,n),psr5(5),
     -  psr(nmem),z(nmem),r(3,nmem),sinpsrs(nmem),cospsrs(nmem),
     -  q(nmem),qs(nmem),q2s(nmem)
      character*1 ansrun
      dimension r0(3),r1(3),r2(3),rnorm(3),theta(5)
c     Calculate the pseudorotation angle defined by atoms i1-inmem,
      if (nmem .eq. 0) return
      npsr=0
      pi=atan(1.0)*4.0
      denomfac=2.0*(sin(36.0*pi/180.0)+sin(72.0*pi/180.0))
c     Check if atoms ix(1-nmem) form a loop
      do i=1,nmem
        if (ix(i) .lt. 1 .or. ix(i) .gt. n) then
          print *,'ERROR: invalid atomindex:',ix(i)
          return
        end if
        j=mod(i,nmem)+1
        do in=1,nneig(ix(i))
          if (ineig(in,ix(i)) .eq. ix(j)) go to 100
        end do
        write (iout,1000) ix(i),ix(j),sqrt(dist2(a(1,ix(i)),a(1,ix(j))))
100     continue
      end do
      npsr=(nmem-1)/2
      if (nconf .eq. 1) then
        zsqs=0.d0
        zavs=0.d0
        do i=1,npsr
          sinpsrs(i)=0.d0
          cospsrs(i)=0.d0
          qs(i)=0.d0
          q2s(i)=0.d0
        end do
      end if
      if (nmem .eq. 5) then
c       As defined by Altona & Sundaralingam, JACS (1972) 94, 8205.
c       Average over all cyclic permutations
        do it=1,5
          theta(it)=dihangl(a,ix(mod(it-1,5)+1),ix(mod(it,5)+1),
     -      ix(mod(it+1,5)+1),ix(mod(it+2,5)+1),0,maxrec)
        end do
c        write (iout,8711) (theta(it)*radtodeg,it=1,5)
c8711    format(' theta 1-5=',5f8.3)
        do id=0,4
          psr0=radtodeg*atan(((theta(mod(2+id,5)+1)+
     -         theta(mod(4+id,5)+1))-(theta(mod(1+id,5)+1)+
     -         theta(mod(3+id,5)+1)))/(theta(mod(id,5)+1)*denomfac))
          if (theta(mod(id,5)+1) .lt. 0) psr0=psr0+180.0
          psr5(id+1)=psr0
        end do
      end if
c     Cremer & Pople, JACS 97, 1354 (1975)
      call zeroit(r0,3)
      call zeroit(r1,3)
      call zeroit(r2,3)
      do i=1,nmem
        do k=1,3
          r0(k)=r0(k)+a(k,ix(i))
        end do
      end do
      do i=1,nmem
        do k=1,3
          r(k,i)=a(k,ix(i))-r0(k)/nmem
          r1(k)=r1(k)+r(k,i)*sin(2.0*pi*(i-1)/float(nmem))
          r2(k)=r2(k)+r(k,i)*cos(2.0*pi*(i-1)/float(nmem))
        end do
      end do
      call vprd(r1,r2,rnorm)
      rnmag=sqrt(rnorm(1)**2+rnorm(2)**2+rnorm(3)**2)
      do k=1,3
        rnorm(k)=rnorm(k)/rnmag
      end do
c      write (iout,2000) rnorm
c2000  format(' rnorm=',3f10.6)
      zsq=0.0
      do i=1,nmem
        z(i)=scprod(rnorm,r(1,i))
        zsq=zsq+z(i)**2
      end do
      zav=sqrt(zsq)
      if (nconf .gt. 0) then
        zavs=zavs+zav
        zsqs=zsqs+zsq
      end if
      sinsum=0.0
      cossum=0.0
      do m=2,npsr
        do i=1,nmem
          sinsum=sinsum-z(i)*sin(2*pi*m*(i-1-incgen)/float(nmem))
          cossum=cossum+z(i)*cos(2*pi*m*(i-1-incgen)/float(nmem))
        end do
        q(m)=sqrt((2.0/float(nmem))*(sinsum**2+cossum**2))
        tn=sinsum/cossum
        sqdenom=sqrt(1.0+tn*tn)
        sn=tn/sqdenom
        cs=1.0/sqdenom
        if (sinsum .lt. 0 .and. sn .gt. 0.0) sn=-sn
        if (cossum .lt. 0 .and. cs .gt. 0.0) cs=-cs
        if (nconf .gt. 0) then
          sinpsrs(m)=sinpsrs(m)+sn
          cospsrs(m)=cospsrs(m)+cs
          qs(m)=qs(m)+q(m)
          q2s(m)=q2s(m)+q(m)**2
        end if
        psr(m)=atansc(sn,cs,1,radtodeg)
      end do
      if (npsr .gt. 0)  then
        if (nmem .eq. 5) then
          psrndb=psr5(1)
c         write (iout,1004) psr5
          do id=1,4
            psrcorr=psr5(id+1)-id*144.0
            if (abs(psrcorr+360.0-psr5(id+1)) .lt.
     -          abs(psrcorr-psr5(id+1))) psrcorr=psrcorr+360.0
            if (abs(psrcorr-360.0-psr5(id+1)) .lt.
     -          abs(psrcorr-psr5(id+1))) psrcorr=psrcorr-360.0
            psrav=psrav+psrcorr
            psr5(id+1)=psrcorr
          end do
          psrav=psrav/5.0
        end if
        if (iprint .eq. 1) then
          if (ansrun .eq. '5') write (iout,1003) psrndb
          if (nmem .eq. 1) write (iout,1005) psr5,psrav
          write (iout,1007) zav
          write (iout,1006) 'angles',(psr(i),i=2,npsr)
          write (iout,1006) 'amplitudes',(q(i),i=2,npsr)
        end if
      end if
      return
1000  format(' WARNING: atoms ',i6,' and ',i6,' are not bonded, dij=',
     -  f8.3,' A',/,10x,'- ring is not complete')
1003  format(' Torsion-based pseudorotation angle, NDB convention=',
     -  f8.3,' deg')
c1004  format(' Torsion-based pseudorotation angles with all origins:',
c     -  /,5x,5f8.3,' deg')
1005  format(' Phase corrected torsion-based pseudorotation angles ',
     -  'with all origins:',/,5x,5f8.3,' deg   Mean=',f8.3,' deg')
1006  format(' General puckering ',a,' (Cremer & Pople)=',/,(10f8.2))
1007  format(' Root mean square distance from the mean plane=',f8.2,
     -  ' A')
      end
      subroutine getring(line,index,ix5,irescol1,irescol2,
     -  inamcol1,inamcol2,n,numres,iresring,iresno,ifres,ilres,nmem,
     -  ansrun,noask,incgen,iapex,igl,maxring,maxrec)
      character* 132 line(maxrec)
      dimension index(maxrec),ix5(maxring),iresno(n),ifres(maxrec),
     -  ilres(maxrec)
      character*1 ansrun
      character*2 s5name(5),pname(5),s6name(6)
      character*4 atomnam
      character*15 question
      data s5name /'C1','C2','C3','C4','O4'/
      data s6name /'C1','C2','C3','C4','C5','O5'/
      data pname /'CA','CB','CG','CD','N '/
      data question /'Ring member #  '/
      notfound=0
100   if (noask .eq. 0)
     -   call quiz(ansrun,irtyp,' ',' ',0,'ring type',9,0,5,6,igl,0)
      if (ansrun .eq. 'd') then
        nmem=0
        return
      else if (ansrun .eq. 'g') then
        call getint('Number of atoms in the ring',27,nmem,1,MAXRING,
     -    nmem,0)
        do i=1,nmem
          write (question(14:15),1000) i
          call getint(question,15,999999,1,n,ix5(i),00)
        end do
        incgen=0
      else if (noask .eq. 0) then
        call getint('Residue number of the ring',26,0,1,numres,iresring,
     -    0)
        if (iresring .lt. 1 .or. iresring .gt. iresno(n)) then
          write (6,1001) iresring,iresno(n)
          go to 100
         end if
      end if
      if (ansrun .eq. '6') then
c       Find hexose sugar
        nmem=6
c       Apex is O
        incgen=5
        do i=1,nmem
          do ia=ifres(iresring),ilres(iresring)
            atomnam=line(index(ia))(inamcol1:inamcol1+3)
            call leftadjust4(atomnam,atomnam)
            if (atomnam(1:2) .eq. s6name(i) .and.
     -          atomnam(3:3) .ne. ' ') then
              ix5(i)=ia
              go to 110
            end if
          end do
          write (6,1002) s6name(i),iresring,
     -      line(index(ifres(iresring)))(irescol1:irescol2)
          notfound=1
110       continue
        end do
      else if (ansrun .eq. '5') then
c       Find pentose sugar
        nmem=5
c       Apex is O
        incgen=4
        do i=1,nmem
          do ia=ifres(iresring),ilres(iresring)
            atomnam=line(index(ia))(inamcol1:inamcol1+3)
            call leftadjust4(atomnam,atomnam)
            if (atomnam(1:2) .eq. s5name(i) .and.
     -          atomnam(3:3) .ne. ' ') then
              ix5(i)=ia
              go to 120
            end if
          end do
          notfound=1
          write (6,1002) s5name(i),iresring,
     -      line(index(ifres(iresring)))(irescol1:irescol2)
120       continue
        end do
      else if (ansrun .eq. 'p') then
c       Find proline
        nmem=5
c       Apex is N (?)
        incgen=4
        do i=1,nmem
          do ia=ifres(iresring),ilres(iresring)
c           print *,'ia,r=',ia,line(index(ia))(inamcol1:inamcol1+1)
            atomnam=line(index(ia))(inamcol1:inamcol1+3)
            call leftadjust4(atomnam,atomnam)
            if (atomnam(1:2) .eq. pname(i)) then
              ix5(i)=ia
              go to 130
            end if
          end do
          notfound=1
          write (6,1002) pname(i),iresring,
     -      line(index(ifres(iresring)))(irescol1:irescol2)
130       continue
        end do
      end if
      nnamcol=inamcol2-inamcol1+1
      if (notfound .eq. 1) then
        nmem=0
      else
        if (nnamcol .gt. 0) then
        write (6,1003) (ix5(i),line(index(ix5(i)))(irescol1:irescol2),
     -    line(index(ix5(i)))(inamcol1:inamcol2),i=1,nmem)
        iapex=ix5(incgen+1)
        write (6,1007) iapex,' ',
     -    line(index(ix5(incgen+1)))(irescol1:irescol2),
     -    line(index(ix5(incgen+1)))(inamcol1:inamcol2)
        else
          write (6,1004) (ix5(i),i=1,nmem)
          write (6,1007) iapex
        end if
      end if
      return
1000  format(i2)
1001  format(' ERROR: residue number ',i5,' is outside the [0,',i5,
     -  '] range')
1002  format(' ERROR: ring atom ',a,' is not found in residue ',i4,
     -  ' (',a,')')
1003  format(' Calculations for ring',/,5(i6,' ',a,1x,a))
1004  format(' Calculations for ring',/,(5i6))
1007  format(' Apex of ring: atom',i6,a,'(',a,1x,a,')')
      end
      function atansc(sn,cs,ideg,radtodeg)
      data pi /3.141592/
      if (cs .eq. 0.0) then
        phi=pi/2.0
      else
        phi=atan(sn/cs)
      end if
      if (cs .lt. 0.0) phi=phi-pi
      if (ideg .eq. 0) then
        atansc=phi
      else
        atansc=radtodeg*phi
      end if
      return
      end
      subroutine diagonal(cn,ih,n,nnh,edge,ioppbc,cell,ncell,
     -  ixyzhex,closorgd,closest)
      dimension cn(3,n),ih(n),edge(3),cell(3,27),ixyzhex(3)
c     Orient molecule along the diagonal
      dimension rot(3,3)
      closorgd=distminimg(cn,ih,n,nnh,edge,ioppbc,cell,ncell,ixyzhex,
     -  inod,jnod)
c     Calculate rotation matrix
      sq2=sqrt(edge(1)**2+edge(2)**2)
      sq3=sqrt(edge(1)**2+edge(2)**2+edge(3)**2)
      rot(1,1)= edge(1)/sq3
      rot(1,2)=-edge(2)/sq3
      rot(1,3)=-edge(3)/sq3
      rot(2,1)= edge(2)/sq2
      rot(2,2)= edge(1)/sq2
      rot(2,3)=0.0
      rot(3,1)= edge(1)*edge(3)/(sq2*sq3)
      rot(3,2)=-edge(2)*edge(3)/(sq2*sq3)
      rot(3,3)= sq2/sq3
c     call chkort(rot)
      call rotate_c(cn,n,rot,cn,'DIAGONAL',8)
      closest=distminimg(cn,ih,n,nnh,edge,ioppbc,cell,ncell,ixyzhex,
     -  innd,jnnd)
      return
      end
      subroutine checkwall(ioppbc,edge,cmin,cmax,c,cell,ncell1,ncell,
     -  ih,nslt,nnh,walld)
      dimension edge(3),cmin(3),cmax(3),c0(3),c(3,nslt),ih(nslt),
     -  cell(3,27)
      if (ioppbc .eq. 1 .or. ioppbc .eq. 2) then
        call extension(c,ih,nnh,1,nslt,cmin,cmax,c0,0,0,v)
        walld=1000.0
        do k=1,3
          wd=(edge(k)-(cmax(k)-cmin(k)))/2.0
          if (wd .lt. walld) walld=wd
        end do
      else
        walld=1.0
        do ia=1,nslt
          call genimdist(c(1,ia),cell,ncell1,ncell,icmin,rmin2)
          if (icmin .gt. 1) walld=-1.0
        end do
      end if
      return
      end
      subroutine trystat(opt,try,ntry,label,llabel)
      dimension try(200)
      character*(*) label
      nt=min0(200,ntry)
      nopt=0
      do it=1,nt
        if (abs(try(it)-opt)/abs(abs(try(it))+abs(opt)) .lt. 0.00001)
     -    nopt=nopt+1
      end do
      write (6,1000) label(1:llabel),nopt
      if (nopt .eq. 0) print *,'WARNING: best orientation was ',
     -  'optimzed from the input conformation'
      if (nopt .eq. 1) print *,
     -  'WARNING: more random trys are likely to reach better optimum'
      return
1000  format(' The number of times the optimal ',a,' was reached=',i3)
      end
      subroutine optimizebound(co,cn,cnew,ih,nslt,nnh,n,rot,mintyp,
     -  ixyzhex,i2dopt,ftol)
      dimension co(3,n),cn(3,n),cnew(3,n),ih(n),rot(3,3)
c     Find the orientation minimizing the size of the bounding cube
      dimension edge(3),cell(3,27),ixyzhex(3)
      dimension simplex(4,3),angle(3),vertex(4)
      if (i2dopt .eq. 0) then
c       3-D optimzation - initialize simplex
        call zeroit(simplex,12)
        do i=1,3
          simplex(i,i)=0.1
        end do
        do i=1,4
          do k=1,3
            angle(k)=simplex(i,k)
          end do
          vertex(i)=touch(co,ih,nslt,nnh,edge,ioppbc,cell,ncell,
     -      ixyzhex,angle,rot,mintyp,0,cnew)
        end do
c       print *,'-Initial simplex distances=',vertex
c       call chkort(rot)
        call amoeba(simplex,vertex,4,3,3,ftol,iter,co,cnew,ih,nslt,nnh,
     -    edge,ioppbc,cell,ncell,ixyzhex,rot,mintyp)
      else
c       2-D optimzation
        call opt2d(co,cnew,ih,n,nslt,nnh,edge,ioppbc,cell,ncell,
     -    ixyzhex,angle,rot,ftol,mintyp,i2dopt,iter)
      end if
      print *,'--- Number of iterations=',iter
      call rotate_c(co,n,rot,cn,'OPTBOUND',8)
      return
      end
      subroutine optimize(co,cn,cnew,ih,nslt,nnh,n,edge,edgen,edge_gen,
     -  ioppbc,npbc,ireduce,cell,ncell,cellalt,volnew,nwnew,
     -  closlim,closorg,closest,rot,ixyzhex,inn,jnn,ichk,iunsat,
     -  istickout,i2dopt,ftol)
      dimension co(3,n),cn(3,n),cnew(3,n),ih(n),edge(3),edgen(3),
     -  edge_gen(3,3),cell(3,27),cellalt(3,27),rot(3,3),ixyzhex(3)
c     Find the orientation maximizing image-image distances
      dimension cmin(3),cmax(3),edgenn(3)
      dimension simplex(4,3),angle(3),vertex(4)
c     print *,'OPTIMIZE start closlim,n,nslt=',closlim,n,nslt
      iunsat=0
      istickout=0
      call checkwall(ioppbc,edge,cmin,cmax,co,cell,1,ncell,
     -  ih,nslt,nnh,walldist)
      if (walldist .lt. 0.0) then
        volnew=1.e+33
        print *,'Optimization skipped because solute is out of the box'
        istickout=1
        return
      end if
c     print *,'edge=',edge,' ncell=',ncell
      closorg=distminimg(co,ih,nslt,nnh,edge,ioppbc,cell,ncell,ixyzhex,
     -  inno,jnno)
      if (nslt .lt. 3000 .and. ichk .eq. 1) then
        clo=distminck(co,ih,nslt,nnh,cell,cellalt,ioppbc,ncell,
     -    inno1,jnno1)
        if (abs(closorg-clo) .gt. 0.0001) print *,
     -    'PROGRAM ERROR: Original distance=',closorg,' Check=',clo
      end if
      if (i2dopt .eq. 0) then
c       3-D optimzation - initialize simplex
        call zeroit(simplex,12)
        do i=1,3
          simplex(i,i)=0.1
        end do
        do i=1,4
          do k=1,3
            angle(k)=simplex(i,k)
          end do
          vertex(i)=touch(co,ih,nslt,nnh,edge,ioppbc,cell,ncell,
     -      ixyzhex,angle,rot,1,0,cnew)
        end do
c       print *,'-Initial simplex distances=',vertex
c       call chkort(rot)
        call amoeba(simplex,vertex,4,3,3,ftol,iter,co,cnew,ih,nslt,nnh,
     -    edge,ioppbc,cell,ncell,ixyzhex,rot,1)
      else
c       2-D optimzation
        call opt2d(co,cnew,ih,n,nslt,nnh,edge,ioppbc,cell,ncell,
     -    ixyzhex,angle,rot,ftol,1,i2dopt,iter)
      end if
      print *,'--- Number of iterations=',iter
      call rotate_c(co,n,rot,cn,'OPTIMIZE',8)
      closest=distminimg(cn,ih,nslt,nnh,edge,ioppbc,cell,ncell,ixyzhex,
     -  inn,jnn)
      write (6,2006) closorg,closest
      if (closest .gt. closlim .and. ireduce .eq. 1) then
        if (npbc .gt. 1) then
          call cellreduce(0,cn,ih,nslt,nnh,edge,edgen,edge_gen,ioppbc,
     -      npbc,cell,ncell,cellalt,ixyzhex,closest,volnew,nwnew)
          call trnsfr(edgenn,edgen,3)
        else
          call trnsfr(edgenn,edge,3)
        end if
        call cellreduce(1,cn,ih,nslt,nnh,edgenn,edgen,edge_gen,ioppbc,
     -    npbc,cell,ncell,cellalt,ixyzhex,closlim,volnew,nwnew)
        write (6,2007) volnew,nwnew
c       Recreate the cell centers for edge
        call crorgn(edge,edge_gen,ioppbc,3,ncell,cell,cellalt,
     -    ixyzhex,rinscr,rcirc)
      else if (ireduce .eq. 1) then
        print *,'Smallest image distance is unsatisfactory:',closest
        iunsat=1
      end if
      return
2006  format(' Initial and optimized smallest image distances=',
     -  f5.2,f6.2,' A')
2007  format(' Smallest reduced volume=',f10.2,' A**3 accomodating ',i6,
     -  ' waters')
      end
      subroutine reoptimize(c,copt,c2,ih,nslt,nnh,n,edge,edgeopt,
     -  edge_gen,ioppbc,npbc,ireduce,cell,cellalt,ncell,volopt,volnew,
     -  closlim,closopt,closest,rot0,bestrot,inopt,jnopt,inn,jnn,
     -  ixyzhex,iunsat,istickout,impr,i2dopt,ftol)
      dimension c(3,n),copt(3,n),c2(3,n),ih(n),edge(3),edgeopt(3),
     -  edge_gen(3,3),edgen(3),cell(3,27),cellalt(3,27),rot0(3,3),
     -  bestrot(3,3),rotopt(3,3),ixyzhex(3)
c     print *,'Reoptimize n,ioppbc=',n,ioppbc
      impr=0
      volnew=volopt
      call optimize(c,c,c2,ih,nslt,nnh,n,edge,edgen,edge_gen,ioppbc,
     -  npbc,ireduce,cell,ncell,cellalt,volnew,nwnew,closlim,closorg,
     -  closest,rotopt,ixyzhex,inn,jnn,1,iunsat,istickout,i2dopt,ftol)
      if (istickout .gt. 0) return
      if (ireduce .eq. 1) then
c       Select smallest volume
        if (volnew .lt. volopt) then
          volopt=volnew
          closopt=closest
          inopt=inn
          jnopt=jnn
          call trnsfr(copt,c,3*n)
          call trnsfr(edgeopt,edgen,3)
          call matprod(rotopt,rot0,bestrot)
          impr=1
        end if
      else
c       Select largest minimum distance
        if (closest .gt. closopt) then
          closopt=closest
          inopt=inn
          jnopt=jnn
          call trnsfr(copt,c,3*n)
          call matprod(rotopt,rot0,bestrot)
          impr=1
        end if
      end if
      return
      end
      subroutine symfit(c,co,c1,n,ioppbc,bestrot)
      dimension c(3,n),co(3,n),c1(3,n),bestrot(3,3)
c     Find the closest symmetrical image of the optimized ort to the original
      dimension nrot(3,8),kk(3),rot0(3,3),rot(3,3,3),rotopt(3,3)
      data nrot /4,4,4, 2,2,2, 4,4,4, 6,2,2, 6,2,2, 4,4,4, 4,4,4, 4,4,4/
      pi2=2.0*acos(-1.0)
      d0=dist2n(c,co,n)
      ncha=0
      do k=1,3
        call unitmat(rot(1,1,k))
        k1=mod(k,3)+1
        k2=mod(k+1,3)+1
        angle=pi2/float(nrot(k,ioppbc))
        rot(k1,k1,k)=cos(angle)
        rot(k2,k2,k)=rot(k1,k1,k)
        rot(k1,k2,k)=sin(angle)
        rot(k2,k1,k)=-rot(k1,k2,k)
      end do
      do k1=1,nrot(1,ioppbc)
        kk(1)=k1
        do k2=1,nrot(2,ioppbc)
          kk(2)=k2
          do k3=1,nrot(3,ioppbc)
            kk(3)=k3
            call unitmat(rot0)
            do k=1,3
              do i=1,kk(k)
                call matprod(rot(1,1,k),rot0,rot0)
              end do
            end do
            call rotate_c(c,n,rot0,c1,'SYMFIT1',7)
c           call checkchir(c1,n,2,1,3,4,6,isg)
c           print *,'k1,k2,k3=',k1,k2,k3,' isg=',isg
            d1=dist2n(co,c1,n)
            if (d1 .lt. d0-1.0) then
              ncha=ncha+1
              call trnsfr(rotopt,rot0,9)
              d0=d1
c              write (6,1781) ncha,k,d0,d1,rot0
c1781          format(' nch,k=',2i3,' d0,d1=',2e12.5,' rot0=',(/,3f8.4))
            end if
          end do
        end do
      end do
      if (ncha .gt. 0) then
        call rotate_c(c,n,rotopt,c,'SYMFIT',6)
        call matprod(rotopt,bestrot,bestrot)
      end if
      return
      end
      subroutine alignlongax(c,n,edge,rot,longax)
      dimension c(3,n),edge(3),rot(3,3)
      dimension permute(3,3)
      character*1 xyz(3)
      data xyz /'X','Y','Z'/
      edgelong=amax1(edge(1),edge(2),edge(3)) 
      if (edge(longax) .eq. edgelong) return
      call zeroit(permute,9)
      k=1
      longedge=0
      do while (longedge .eq. 0 .and. k .le. 3)
        if (edge(k) .eq. edgelong) longedge=k
        k=k+1
      end do
      permute(longedge,longax)=1.0
      print *,'longedge,longax=',longedge,longax
      kx=mod(longedge,3)+1
      ky=mod(longax,3)+1
      permute(kx,ky)=1.0
      print *,'kx,ky=',kx,ky
      kx=mod(kx,3)+1
      ky=mod(ky,3)+1
      permute(kx,ky)=1.0
      print *,'kxx,kyy=',kx,ky
      write (6,2001) ((permute(i,j),j=1,3),i=1,3)
      write (6,2000) xyz(longax),xyz(longedge)
      call rotate_c(c,n,permute,c,'ALIGNLONG',9)
      call rotate_c(edge,1,permute,edge,'ALIGNLONG1',10)
      call matprod(permute,rot,rot)
      return
2000  format(' System is rotated to make the ',a,' axis the longest ',
     -  '(current longest: ',a,' axis)')
2001  format(' Permute:',/,(3f4.1))
      end
      subroutine checkreschargesum(nslt,iresno,isegno,line,index,
     -  irescol1,irescol2,iresncol1,iresncol2,isegcol1,isegcol2,iqcol1,
     -  iqcol2,charge,molsltlim,label,llabel,resnames,ifres,
     -  ixres,ixchrg,ixnochrg,nreschrg,iallzero,iallnonpos,iallnonneg,
     -  ichecksavedq,ifixq,reportqmin,maxrsd,maxrec)
      dimension index(maxrec),iresno(maxrec),ifres(maxrec),
     -  isegno(maxrec),ixchrg(maxrec),ixnochrg(maxrec),charge(maxrec),
     -  molsltlim(3,maxrsd),ixres(maxrec)
      character*(*) label
      character*8 resnames(maxrsd)
      character* 132 line(maxrec)
      character*8 rnprev
      character*6 rnuprev
      real*8 qsum
      character*19 segline
      data segline /' Segment     (    )'/
c     Check if residue charges are integers, print charge sum
c     print *,'CHECKRESCHARGESUM nslt=',nslt
      nrescol=irescol2-irescol1+1
      nresncol=iresncol2-iresncol1+1
      iresprev=iresno(1)
      ixresprev=ixres(1)
      isegprev=isegno(1)
      ndigits=3
      nsegm=isegno(nslt)
      isegnoprev=0
      if (reportqmin .lt. 0.0) call getreal(
     -  'Minimum deviation from integral residue charge to print',55,
     -  0.0,reportqmin,1,000)
      do isg=1,nsegm
        iallzero=1
        iallnonpos=1
        iallnonneg=1
        nreschrg=0
        nresnochrg=0
        nresck=0
        nonintegral=0
        iallzerores=1
        qrsum=0.0
        qsum=0.d0
        qdevmax=0.d0
c       print *,'isg=',isg,' mlim=',molsltlim(1,isg),molsltlim(2,isg)
        do ia=molsltlim(1,isg),molsltlim(2,isg)
          ir=iresno(ia)
          is=isegno(ia)
          if (nsegm .gt. 1 .and. is .gt. isegnoprev) then
            write (segline(9:12),1006) isg
            ncol=12
            if (isegcol2 .gt. isegcol1) then
              segline(15:isegcol2-isegcol1+1)=
     -          line(index(ia))(isegcol1:isegcol2)
              ncol=19
            end if
            write (6,1008) segline(1:ncol)
          end if
          isegnoprev=is
          q=charge(ia)
          if (q .lt. 0.0) iallnonneg=0
          if (q .gt. 0.0) iallnonpos=0
          if (q .ne. 0.0) iallzero=0
          if (q .ne. 0.0) iallzerores=0
          if (ir .ne. iresprev .or. is .ne. isegprev .or.
     -        ia .eq. molsltlim(2,isg)) then
            rnprev(1:nrescol)=line(index(ia-1))(irescol1:irescol2)
            rnuprev(1:nresncol)=line(index(ia-1))(iresncol1:iresncol2)
            qscheck=qrsum
c           resnames(iresprev)=rnprev
            if (ia .eq. nslt .or. ia .eq. molsltlim(2,isg))
     -        qscheck=qscheck+q
            if (isinteger(qscheck,ndigits,qoffset) .eq. 0) then
              if (abs(qoffset) .ge. reportqmin)
     -          write (6,1000) label(1:llabel),iresprev,
     -            rnuprev(1:nresncol),rnprev(1:nrescol),qscheck
              nonintegral=nonintegral+1
              if (abs(qoffset) .gt. qdevmax) qdevmax=abs(qoffset)
            else if (abs(qscheck) .gt. 0.1) then
              nreschrg=nreschrg+1
              ixchrg(nreschrg)=ixresprev
            end if
            if (iallzerores .eq. 1) then
              nresnochrg=nresnochrg+1
              ixnochrg(nresnochrg)=ixresprev
            end if
            qrsum=0.0
            iresprev=ir
            ixresprev=ixres(ia)
            isegprev=is
            nresck=nresck+1
            iallzerores=1
          end if
          qrsum=qrsum+q
          qsum=qsum+q
        end do
        if (iallzero .eq. 1) then
          write (6,1005) ' '
        else
          if (iallnonneg .eq. 1) write (6,1005) ' positive or ',isg
          if (iallnonpos .eq. 1) write (6,1005) ' negative or ',isg
        end if
        if (iallzero+iallnonpos+iallnonneg .eq. 0 .or. nslt .le. 10)then
          nerr=0
          if (ichecksavedq .eq. 1) then
            do ia=molsltlim(1,isg),molsltlim(2,isg)
              read(line(index(ia))(iqcol1:iqcol2),*,err=555,end=555) q
              if (abs(q-charge(ia)) .gt. 0.0001 .and. nerr .lt. 10) then
                write (6,1004) ia,charge(ia),q
                nerr=nerr+1
              end if
              go to 556
555           nerr=nerr+1
              if (nerr .le. 10) print *,'ERROR: Invalid charge on atom',
     -          ia,':',line(index(ia))(iqcol1:iqcol2)
              if (nerr .eq. 10)
     -            print *,'Further error messages are suppressed'
556           continue
            end do
          end if
          write (6,1001) nresck,label(1:llabel),qsum
          if (nonintegral .gt. 0) write (6,1009) nonintegral
          if (nerr .gt. 0)
     -      print *, 'WARNING: ',nerr,' atom records had errors'
          qsum4=qsum
          if (isinteger(qsum4,ndigits,qoffset) .eq. 0)
     -      print *,'WARNING: Total charge is not integer'
          if (nresnochrg .gt. 0 .and. iallzero .eq. 0) write (6,1007)
     -      (ixnochrg(ir),resnames(ixnochrg(ir))(1:nrescol),
     -      ir=1,nresnochrg)
          if (nreschrg .gt. 0) write (6,1002)(iresno(ifres(ixchrg(ir))),
     -      resnames(ixchrg(ir))(1:nrescol),ir=1,nreschrg)
          if (nonintegral .gt. 0) then
            if (nresck .gt. 1) write (6,1003) qdevmax
            if (ifixq .eq. -1) call askyn(
     -      'Do you want to redistribute charges to integral resid sums'
     -        ,58,1,-1,ifixq,126)
            if (ifixq .gt. 0) then
              qmin=10.0**(-ndigits)
              qround=10.0**(-ndigits-2)
              qrsum=0.0
              qcorrsum=0.0
              iresf=1
              iresprev=iresno(1)
              isegprev=isegno(1)
              do ia=molsltlim(1,isg),molsltlim(2,isg)
                ir=iresno(ia)
                is=isegno(ia)
                read(line(index(ia))(iqcol1:iqcol2),*) q
                if (ir .ne. iresprev .or. is .ne. isegprev .or.
     -              ia .eq. molsltlim(2,isg)) then
                  qscheck=qrsum
                  if (ia .eq. molsltlim(2,isg)) qscheck=qscheck+q
                  ii=isinteger(qscheck,ndigits,qoffset)
                  qcorrsum=qcorrsum-qoffset
                  if (ii .eq. 0) then
c                   Divide extra charge (qdistr) into small chunks
                    ntotchunks=abs(qoffset)/qmin
                    qmins=qmin
                    if (qoffset .gt. 0.0) qmins=-qmin
                    qdistr=ntotchunks*qmins
                    qdistr1=(ntotchunks+1)*qmins
                    if (abs(qoffset+qdistr) .gt.
     -                  abs(qoffset+qdistr1))then
                      qdistr=qdistr1
                      ntotchunks=ntotchunks+1
                    end if
                    natsres=ia-iresf
                    nchunks=ntotchunks/natsres
                    nchunkext=ntotchunks-natsres*nchunks
                    do ja=iresf,ia-1
                      qadd=nchunks*qmins
                      if (nchunkext .gt. 0 .and. ja-iresf .lt.nchunkext)
     -                  qadd=qadd+qmins
                      qfix=charge(ja)+qadd
                      call putreal(line(index(ja))(iqcol1:iqcol2),
     -                  iqcol2-iqcol1+1,qfix,ndigits)
                      charge(ja)=qfix
                    end do
                  end if
                  qrsum=0.0
                  iresprev=ir
                  isegprev=is
                  iresf=ia
                end if
                qrsum=qrsum+q
              end do
              if (abs(qcorrsum) .gt. abs(qmin)) print *,
     -          'WARNING: total charge distributed is not zero:',
     -          qcorrsum
            end if
          end if
        end if
      end do
      return
1000  format(' Charge sum on ',a,i6,' (',a,1x,a,') is not integer:',
     -  f10.4)
1001  format(' Checked ',i6,1x,a,'s for charge sum. Total charge=',
     -  f10.5,' e')
1002  format(' Charged residues (residues with nonintegral charges ',
     -  'omitted):',/,5(i5,'(',a,')'))
1003  format(' Largest absolute deviation from integral charge=',f8.5)
1004  format(' Program ERROR: solute atom',i6,' charge saved=',f8.5,
     -  ' charge read=',f8.5)
1005  format(' WARNING: all charges are',a,'zero in segment',i4)
1006  format(i4)
1007  format(' WARNING: the following residues have no charges:',/,
     -  5(i5,'(',a,')'))
1008  format(a)
1009  format(' Number of residues with nonitegral charge sum=',i4)
      end
      subroutine checknameforAC(nslt,line,index,inamcol1,inamcol2,
     -  maxrec)
      dimension index(maxrec)
      character* 132 line(maxrec)
      common /logging/ logfile,ipredict
c     Change atomnames using A for aromatic carbons to C
      naromc=0
      ichangeatoc=0
      do ia=1,nslt
        ifc=inamcol1
        call nextchar(line(index(ia)),ifc,inamcol2)
        if (line(index(ia))(ifc:ifc) .eq. 'A') then
          naromc=naromc+1
          if (naromc .eq. 1) then
            if (ipredict .eq. 0) then
              print *,'Atom names starting with A may stand for ',
     -          'aromatic carbons'
              call askyn('Do you want to change A*** atoms to C***',40,
     -          1,1,ichangeatoc,0)
            else
              write (6,1001)
              ichangeatoc=1
            end if
          end if
          if (ichangeatoc .eq. 1) line(index(ia))(ifc:ifc)='C'
        end if
      end do
      if (naromc .gt. 0) write (6,1000) naromc
      return
1000  format(' Number of atomnames changed from A*** to C***=',i4)
1001  format(' Atoms with name A*** (assumed to be aromatic carbons) ',
     -  'are renamed to C***',/,
     -  ' To avoid this, do not make the input predictable')
      end
      subroutine checkfordup(numres,n,ifres,ilres,iresno,resnames,
     -  atnames,line,index,ndupdel,maxrec,nrescol,nnamcol,idcol)
      dimension ifres(numres),ilres(numres),iresno(n),index(n)
      character*8 resnames(numres),atnames(n)
      character*132 line(maxrec)
      iask=1
      ideldup=1
      ndupdel=0
      do ir=1,numres
        do ia=ifres(ir),ilres(ir)-1
          do ja=ia+1,ilres(ir)
            if (line(index(ia))(idcol:idcol) .eq. ' ' .and.
     -          line(index(ja))(idcol:idcol) .eq. ' ') then
              if (atnames(ia)(1:nnamcol) .eq. atnames(ja)(1:nnamcol))
     -                                                           then
                if (iask .eq. 1) then
                  write (6,2000) resnames(ir)(1:nrescol),iresno(ia),
     -              ia,ja,atnames(ia)(1:nnamcol)
                  call askyn('Do you want to delete the duplicate',35,1,
     -              1,ideldup,0)
                  call askyn(
     -             'Do you want to the same action with all duplicates',
     -              50,0,1,iask,0)
                end if
                if (ideldup .eq. 1) then
                  line(index(ja))(idcol:idcol)='*'
                  ndupdel=ndupdel+1
                end if
              end if
            end if
          end do
        end do
      end do
      if (ndupdel .gt. 0)
     -  write (6,*) 'Number of duplicate names deleted=',ndupdel
      return
2000  format(' Residue ',a,i6,' atoms',2i7,' have same name:',a)
      end
      subroutine checkprotchir(c,n,line,index,ifres,nneig,ineig,
     -  inamcol1,inamcol2,irescol1,irescol2,iresncol1,iresncol2,
     -  nminus0,nplus0,nminus,nplus,ild,iverb,maxneig,maxrsd,maxrec)
      dimension c(3,maxrec),nneig(n),ineig(maxneig,n),index(maxrec),
     -  ifres(maxrec)
      character*1 ild(maxrsd)
      character* 132 line(maxrec)
      character*8 atnam
      lnam=inamcol2-inamcol1+1
      ncheck=0
      nminus=0
      nplus=0
      nplusminus=0
      nhgen=0
      iresno=0
      read (line(index(1))(iresncol1:iresncol2),*) iresnoprev
c     print *,'CHPROTC n,maxrec,iverb,maxneig=',n,maxrec,iverb,maxneig
      icafound=0
      do ia=1,n
        atnam(1:lnam)=line(index(ia))(inamcol1:inamcol2)
        if (lnam .eq. 4) atnam(5:8)='    '
        call leftadjustn(atnam,atnam,8)
        read (line(index(ia))(iresncol1:iresncol2),*) iresno
        if (atnam(1:4) .eq. 'CA  ') then
          icafound=1
          ic=0
          in=0
          icb=0
          iha=0
          nfound=0
          ica=ia
          ierr=0
          do iaa=1,nneig(ia)
            ing=ineig(iaa,ia)
            atnam(1:lnam)=line(index(ing))(inamcol1:inamcol2)
            if (lnam .eq. 4) atnam(5:8)='    '
            call leftadjustn(atnam,atnam,8)
            call lookforneig(atnam(1:4),'C   ',ing,ic,nfound,ica,ierr)
            call lookforneig(atnam(1:4),'N   ',ing,in,nfound,ica,ierr)
            call lookforneig(atnam(1:4),'CB  ',ing,icb,nfound,ica,ierr)
            call lookforneig(atnam(1:4),'HA  ',ing,iha,nfound,ica,ierr)
          end do
          if (ierr .eq. 0) then
            if (nfound .eq. 3 .and. iha .eq. 0) then
c             HA is missing only - generate it
              iha=maxrec
              nfound=nfound+1
              do k=1,3
                c(k,maxrec)=c(k,ica)+
     -            (3.0*c(k,ica)-c(k,icb)-c(k,in)-c(k,ic))
              end do
              nhgen=nhgen+1
            end if
            if (nfound .eq. 4) then
              ncheck=ncheck+1
              call checkchir(c,maxrec,ica,in,iha,icb,ic,isg)
              if (isg .lt. 0) then
                nminus=nminus+1
                ild(ncheck)='D'
              else if (isg .gt. 0)  then
                nplus=nplus+1
                ild(ncheck)='L'
              end if
            else
              nplusminus=nplusminus+1
              ncheck=ncheck+1
              ild(ncheck)='-'
            end if
          else
            nplusminus=nplusminus+1
            ncheck=ncheck+1
            ild(ncheck)='e'
          end if
        end if
        if (iresno .ne. iresnoprev) then
          if (icafound .eq. 0) then
c           Non AA residue
            nplusminus=nplusminus+1
            ncheck=ncheck+1
            ild(ncheck)='-'
          end if
          iresnoprev=iresno
          icafound=0
        end if
      end do
      if (nhgen .gt. 0)
     -  print *,'Number of HAs generated for chirality check=',nhgen
      if (nminus0 .ge. 0 .and. nplus0 .ge .0) then
        nchch=iabs(nminus-nminus0)+iabs(nplus-nplus0)
        if (nchch .gt. 0)
     -    print *,'PROGRAM ERROR:',nchch,' CA atom(s) changed chirality'
      else
        nchch=0
      end if
      if (iverb .gt. 0 .or. nchch .gt. 0) then
        if (nplus+nminus .gt. 0) then
          write (6,1000) nplus+nminus,nplus,nminus,nplusminus
          if (nplus*nminus .ne. 0) then
c           Both L and D was found
            call print1charlist(ild,ncheck,line,index,ifres,irescol1,
     -        irescol2,maxrec)
          end if
          if (nminus .gt. 0) write(6,1001)
        else
          print *,'No chiral CA atom was found'
        end if
      end if
      return
1000  format(i6,' chiral CAs were found, ',i5,' in L and ',i5,' in D ',
     -  'conformation',/,i6,' achiral CAs were found (glycine)')
1001  format(' NOTE: chiral peptide center in D conformation was found')
      end
      subroutine lookforneig(atnam4,label,ing,ilabel,nfound,ica,ierr)
      character*4 atnam4,label
      if (atnam4 .eq. label) then
        if (ilabel .gt. 0) then
          write (6,1000) ica,label,ilabel,ing
          ierr=ierr+1
        else
          ilabel=ing
          nfound=nfound+1
        end if
      end if
      return
1000  format(' ERROR: CA atom # ',i6,' has extra ',a,' neighbour:',2i7)
      end
      subroutine print1charlist(charlist,nlist,line,index,ifres,
     -  irescol1,irescol2,maxrec)
      character*1 charlist(nlist)
      character*(*) line(maxrec)
      dimension index(maxrec),ifres(maxrec)
      character*1 aa1(50)
      character*8 resname
      lresname=irescol2-irescol1+1
      i0=0
      do while (i0 .lt. nlist)
        print *
        imax=i0+min0(50,nlist-i0)
        write (6,1001)'Chirality:',(charlist(i),i=i0+1,imax)
c       Get 1-character AA list
        iimax=imax-i0
        do i=i0+1,imax
          ii=i-i0
          resname(1:lresname)=line(index(ifres(i)))(irescol1:irescol2)
          call leftadjustline(resname,1,lresname)
          call changeprot(resname,aa1(ii),2)
c          if (i0 .eq. 0)
c     -      write (6,7711) i,ii,index(i),lresname,resname,aa1(ii)
c7711  format('  i,ii=',2i4,' index=',i4,' lresname=',i4,
c     -  ' resname=',a,' aa1=',a)
        end do
        write (6,1001)'Residue:  ',(aa1(ii),ii=1,iimax)
        moddiv=1
        nline=alog10(float(imax))+1
        do iline=1,nline
          write (6,1002) (mod(i/moddiv,10),i=i0+1,imax)
          moddiv=moddiv*10
        end do
        i0=i0+50
      end do
      return
1001  format(1x,a10,50a1)
1002  format(11x,50i1)
      end
      subroutine checkchir(c,n,i0,i1,i2,i3,i4,isg)
      dimension c(3,n)
      dimension d01(3),d02(3),d34(3),rnorm12(3)
c     Check the chirality of atom c(1,i0). If i1,i2,i3,i4 are the indices of
c     atoms with increasing atomic number then isg = +1 -> R ; isg = -1 -> S.
      call arrdiff(c(1,i1),c(1,i0),d01,3)
      call arrdiff(c(1,i2),c(1,i0),d02,3)
      call arrdiff(c(1,i4),c(1,i3),d34,3)
      call vprd(d01,d02,rnorm12)
      isg=1
      if (scprod(d34,rnorm12) .lt. 0.0) isg=-1
      return
      end
      subroutine cellreduce(it,c,ih,n,nnh,edge,edgen,edge_gen,ioppbc,
     -  npbc,cell,ncell,cellalt,ixyzhex,closmn,volnew,nwnew)
      dimension c(3,n),ih(n),edge(3),edgen(3),edge_gen(3,3),cell(3,27),
     -  cellalt(3,27),ixyzhex(3)
c     When it=0, find out if any of the cell sizes can be further reduced
c     without affecting the closest approach
c     When it=1, scale down the cell until the minimum approach is reached
      dimension edgenn(3),delxyz(3)
c     print *,'CELLRED  edge=',edge
c     print *,'CELLRED  closmn=',closmn
      if (closmn .eq. 0.0) then
        call crorgn(edge,edge_gen,ioppbc,3,ncell,cell,cellalt,
     -    ixyzhex,rinscr,rcirc)
        closmin=distminimg(c,ih,n,nnh,edge,ioppbc,cell,ncell,ixyzhex,
     -    inn,jnn)
      else
        closmin=closmn
      end if
      call trnsfr(edgen,edge,3)
      call trnsfr(edgenn,edge,3)
      call zeroit(delxyz,3)
      delsum=0.0
      icmax=npbc
      if (it .eq. 1) icmax=1
      do ic=1,icmax
        del=0.01
        if (icmax .gt. 1) then
          edgenn(ic)=edge(ic)-del
        else
          do k=1,3
            edgenn(k)=edge(k)*(1.0-del/edge(1))
          end do
        end if
        call crorgn(edgenn,edge_gen,ioppbc,3,ncell,cell,cellalt,
     -    ixyzhex,rinscr,rcirc)
        dnew=distminimg(c,ih,n,nnh,edgenn,ioppbc,cell,ncell,ixyzhex,
     -    inn,jnn)
c       print *,'Cellred ic,closmin,dnew=',ic,closmin,dnew
        if (dnew .ge. closmin-1.e-4) then
c         Successful reduction - see how far it can be taken
          edgen(ic)=edgenn(ic)
          del=0.5
          nred=0
          maxred=25
          do while (del .gt. 0.005 .and. nred .lt. maxred)
            nred=nred+1
            if (icmax .gt. 1) then
              edgenn(ic)=edgen(ic)-del
            else
              do k=1,3
                edgenn(k)=edgen(k)*(1.0-del/edge(1))
              end do
            end if
c           write (6,8788) edgenn
c8788        format(' edgenn=',3f10.5)
            call crorgn(edgenn,edge_gen,ioppbc,3,ncell,cell,cellalt,
     -        ixyzhex,rinscr,rcirc)
            dnew=distminimg(c,ih,n,nnh,edgenn,ioppbc,cell,ncell,ixyzhex,
     -        inn,jnn)
c             print *,'dnew,del=',dnew,del
            if (dnew .gt. closmin-1.e-4) then
              if (icmax .gt. 1) then
                edgen(ic)=edgenn(ic)
                delxyz(ic)=delxyz(ic)+del
              else
                call trnsfr(edgen,edgenn,3)
                delsum=delsum+del
              end if
              del=2.0*del
            else
              del=del/2.0
            end if
          end do
        else if (icmax .gt. 1) then
          edgenn(ic)=edgenn(ic)+del
        end if
      end do
      if (icmax .gt. 1) then
        write (6,1000) (delxyz(k),k=1,3)
      else
        delfac=(1.0-delsum/edge(1))
        write (6,1001) delfac
      end if
      call prtcell(ioppbc,edgen,edge_gen,0.0,volnew,nwnew,0)
      return
1000  format(5x,' Anisotropic cell contraction achieved by:',3f6.2,' A')
1001  format(5x,' Isotropic cell contraction by a factor of ',f6.4)
      end
      subroutine getedge(co,cn,ih,n,nnh,c0,edge,edge_gen,ioppbc,npbc,
     -  ireduce,cell,ncell,cellalt,ixyzhex,closlim,list,iatnum,cv,
     -  maxrec)
      dimension list(maxrec),iatnum(maxrec)
      dimension co(3,n),cn(3,n),ih(n),c0(3),edge(3),edge_gen(3,3),
     -  cell(3,27),cv(n),cellalt(3,27),ixyzhex(3)
      character*1 xyz
      common /axislab/ xyz(3)
      dimension cmin(3),cmax(3),edgen(3)
      data kmax /0/
c     Calculate the cell parameters from the molecule size and the solvent
c     layer width
      width=closlim/2.0
      if (ioppbc .eq. 3 .or. (ioppbc .ge. 6 .and. ioppbc .le. 8)) then
c       Mostly spherical PBC's (FCC, TO or HEX CP)
        print *,'Cell parameter obtained from smallest enclosing ',
     -          'sphere:'
        call compact(co,cn,iatnum,ih,n,nnh,c0,rmin,rorgext,rorgcom,
     -    list,np,nlist,1,cv,maxrec)
        write (6,1003) rmin
        if (ioppbc .eq. 3) then
c         FCC
          edge(1)=(rmin+width)*sqrt(2.0)
        else if (ioppbc .eq. 6 .or. ioppbc .eq. 7) then
c         Truncated octahedron
c         edge parameter is the distance of the truncating squares
c         from the center
c         Inscribed sphere is tangent to centers of opposite hexagons
          edge(1)=(rmin+width)*2.0/sqrt(3.0)
        else if (ioppbc .eq. 8) then
c         Hexagonal close packing
          edge(1)=2.0*(rmin+width)
        end if
      else if (ioppbc .gt. 0) then
c       Rectangular, cubic or hexagonal
        call extension(co,ih,nnh,1,n,cmin,cmax,c0,0,1,v)
        do k=1,3
          write (6,1004) xyz(k),c0(k),cmin(k),cmax(k)
          edge(k)=cmax(k)-cmin(k)+2.0*width
        end do
        if (ioppbc .eq. 2) then
          write (6,1000) (xyz(k),cmin(k),cmax(k),k=1,3)
        else if (ioppbc .eq. 1) then
          emax=0
          do k=1,3
            if (edge(k) .gt. emax) then
              emax=edge(k)
              kmax=k
            end if
          end do
          do k=1,3
            edge(k)=emax
          end do
          write (6,1001) xyz(kmax),cmin(kmax),cmax(kmax)
        else
          ix1=ixyzhex(1)
          write (6,1002) xyz(ix1),cmin(ix1),cmax(ix1),
     -     (xyz(ixyzhex(k)),k=2,3),
     -     (cmin(ixyzhex(k)),cmax(ixyzhex(k)),k=2,3)
           edge(2)=(amax1((cmax(ixyzhex(2))-cmin(ixyzhex(2))),
     -     (cmax(ixyzhex(3))-cmin(ixyzhex(3))))+2.0*width)*2.0/sqrt(3.0)
          edge(3)=edge(2)
        end if
        call shiftmol(co,n,c0,cn,-1.0)
      end if
      call prtcell(ioppbc,edge,edge_gen,0.0,volnew,nwnew,1)
      if (ireduce .eq. 1) then
        if (npbc .gt. 1) then
          call cellreduce(0,cn,ih,n,nnh,edge,edgen,edge_gen,ioppbc,npbc,
     -      cell,ncell,cellalt,ixyzhex,0.0,volnew,nwnew)
          call trnsfr(edge,edgen,3)
        end if
        call cellreduce(1,cn,ih,n,nnh,edge,edgen,edge_gen,ioppbc,npbc,
     -    cell,ncell,cellalt,ixyzhex,closlim,volnew,nwnew)
        call trnsfr(edge,edgen,3)
      end if
      return
1000  format(' Initial edges of the rectangle are based on the X, Y,',
     -  ' and Z extensions:',/,5x,3(1x,a1,f8.3,' - ',f8.3,5x))
1001  format(' Initial edge of the cube is based on the ',a1,
     -  ' extension:',f8.3,' - ',f8.3)
1002  format(' Initial length of the prism based the ',a,' extension:',
     -  ' (',f8.3,' - ',f8.3,')',/,' Initial edge of the hexagon ',
     -  'based on the ',a,' and ',a,' extensions:',
     -  /,' (',f8.3,' - ',f8.3,'), (',f8.3,' - ',f8.3,')')
1003  format(' Inscribed sphere radius=',f10.5)
1004  format(1x,a1,' c0=',f10.5,' cmin=',3f10.5,' cmax=',3f10.5)
      end
      subroutine prtcell(ioppbc,edge,edge_gen,r,vol,nw,iprtopt)
      dimension edge(3),edge_gen(3,3)
      common /numbers/ sq3,sq3inv,sq3p2,sq2p3
      dimension c0(3)
      if (iprtopt .lt. 0) then
        iprt=3
        iout=-iprtopt
      else
        iprt=iprtopt
        iout=6
      end if
      if (ioppbc .eq. 1) then
        vol=edge(1)**3
        if (iprt .gt. 0) write (iout,1001) edge(1)
      else if (ioppbc .eq. 2) then
        vol=edge(1)*edge(2)*edge(3)
        if (iprt .gt. 0) write (iout,1002) edge
      else if (ioppbc .eq. 3) then
        vol=2.0*edge(1)**3
        if (iprt .gt. 0) write (iout,1003) edge(1)
      else if (ioppbc .eq. 4) then
        vol=edge(1)*edge(2)**2*3.0*sqrt(3.0)/2.0
        if (iprt .gt. 0) write (iout,1004) edge(1),edge(2)
      else if (ioppbc .eq. 5) then
        edgex=edge(3)
        edgey=edge(2)
        edgep=edge(1)
        w=sqrt(edgey**2-edgex**2/4.0)
        h=(w-edgex/(2.0*sqrt(3.0)))/2.0
        vol=edgep*edgex*w
        obang=180.0-(180.0/3.14159)*acos(edgex/(2.0*edgey))
        if (iprt .gt. 0) write (iout,1005) edgep,obang,edgey,edgex
      else if (ioppbc .eq. 6 .or. ioppbc .eq. 7) then
        vol=4.0*edge(1)**3
        if (iprt .gt. 0) then
          rhex=edge(1)/sq3p2
          cx_c=2.0*edge(1)
          cx_a=cx_c*sq3p2
          write (iout,1006) edge(1),rhex,cx_c,cx_a
        end if
      else if (ioppbc .eq. 8) then
        vol=edge(1)**3/sqrt(2.0)
        if (iprt .gt. 0) write (iout,1008) edge(1)
      else if (ioppbc .eq. 9) then
        call vprd(edge_gen(1,2),edge_gen(1,3),c0)
        vol=abs(scprod(edge_gen(1,1),c0))
        if (iprt .gt. 0) write (iout,1009) edge(1)
      else if (ioppbc .eq. 10) then
        write (iout,*) 'Inputtted image cell centers'
      else if (ioppbc .eq. 11) then
        vol=4.0*3.141592/3.0*r**3
        iprt=3
        if (iprt .gt. 0) write (iout,1010) r
      else if (ioppbc .eq. -1) then
        vol=4.0*3.141592/3*r**3
        iprt=3
      else
        print *,'PROGRAM ERROR: invalid PBC option in prtcell:',ioppbc
        return
      end if
      nw=vol/(30.090)
      if (iprt .eq. 1) write (iout,2000) vol,nw
      if (iprt .eq. 2) write (iout,2001) vol,nw
      return
1001  format(' Edge of the cube=',f11.6,' A')
1002  format(' Edges of the rectangle=',3f11.6,' A')
1003  format(' FCC cell parameter used=',f11.6,' A')
1004  format(' Hexagonal prism length=',f11.6,
     -  ' A hexagon edge=',f11.6,' A')
1005  format(' Hexagonal prism (skewed) length=',f11.6,
     -  ' A Obtuse angle=',f8.2,' deg',/,' Obtuse axis length=',f11.6,
     -  ' A Cartesian axis length=',f11.6,' A')
1006  format(' Truncated octahedron',/,
     -  ' Distance of square face from the center=',f11.6,' A',/,
     -  ' Distance of hexagonal face from the center=',f11.6,' A',/,
     -  ' Charmm     cell X-parameter=',f11.6,' A',/,
     -  ' Amber/NAMD cell X-parameter=',f11.6,' A')
1008  format(' Diameter of the close-packed sphere=',f11.6,' A')
1009  format(' Edge length of the paralellepid=',f11.6,' A')
1010  format(' Radius of the boundary sphere=',f11.6,' A')
2000  format(' Volume=',f15.2,' A**3',' Number of waters that fit in=',
     -  i9)
2001  format(' Optimal volume=',f11.2,' A**3',
     -  ' Number of waters that fit in=',i6)
      end
      subroutine crorgn(edg,edge_gen,ioppbc,ndim,ncell,cell,cellalt,
     -  ixyzhex,rinscr,rcirc)
c#    MMC routine 064 lstmod: 09/12/90
c*****Generate the negative cell-center coordinates for the pbc routines
      dimension edg(3),edge_gen(3,3),cell(3,27),cellalt(3,27)
      common /pbcrotmat/ torot_ac(3,3),torot_ca(3,3),tofac_ac,tofac_ca
      dimension y(3),x(3),yx(3),yy(3),ixyzhex(3),cx(3),cy(3),cz(3)
      data edgex /0.0/,edgey /0.0/,edge /0.0/,edgep /0.0/,d /0.0/
      if (ioppbc .eq. -1) return
c     print *,'CRORGN ioppbc=',ioppbc,' edg=',edg
      onethird=1.0/3.0
      sq22p3=sqrt(2.0)*2.0/3.0
      sq3=sqrt(3.0)
      sq3p2=sq3/2.0
      sq2p3=sqrt(2.0/3.0)
      if (ioppbc .eq. 1) then
c       Cubic
        edgex=edg(1)
        edgey=edg(1)
        edge=edg(1)
      else if (ioppbc .eq. 2) then
c       Rectangular
        edgex=edg(1)
        edgey=edg(2)
        edge=edg(3)
      else if (ioppbc .eq. 3) then
c       Face-centered cubic
        edge=edg(1)
      else if (ioppbc .eq. 4) then
c       Hexagonal prizm (regular)
        edgex=edg(1)
        edge=edg(2)
      else if (ioppbc .eq. 5) then
c       Hexagonal prizm (skewed)
        edgep=edg(1)
        edgex=edg(3)
        edgey=edg(2)
      else if (ioppbc .eq. 6 .or. ioppbc .eq. 7) then
c       Truncated octahedron
cDAN    edge=edg(1)*2.0*sqrt(2.0)
        edge=edg(1)
      else if (ioppbc .eq. 8) then
c       Hexagonal close packed
        d=edg(1)
      else if (ioppbc .eq. 9) then
c       Octahedral
        call zeroit(cx,3)
        cx(1)=edg(1)
c       do k=1,3
c         cy(k)=cx(k)*onethird-edge_gen(k,2)*sq22p3
c       end do
c       solve (ez.ex)=e**2/3; (ez.ey)=-e**2/3; (ez.ez)=e**2
c       cz(3)=edg(1)
c       cz(1)=(edg(1)**2/3.0*(cy(2)+cx(2))+edg(1)*(cy(3)-cx(3)))/
c    -    (cx(1)*cy(2)-cy(1)*cx(2))
c       cz(2)=(-edg(1)**2/3.0-cz(1)*cy(1)-cz(3)*cy(3))/cy(2)
c       csum=cz(1)**2+cz(2)**2+cz(3)**2
c       fac=edg(1)/sqrt(csum)
c       do k=1,3
c         cz(k)=cz(k)*fac
c       end do
        cy(1)=-edg(1)/3.0
        cy(2)=edg(1)*sq22p3
        cy(3)=0.0
        cz(1)=edg(1)/3.0
        cz(2)=cy(2)/2.0
        cz(3)=edg(1)*sq2p3
        call trnsfr(edge_gen(1,1),cx,3)
        call trnsfr(edge_gen(1,2),cy,3)
        call trnsfr(edge_gen(1,3),cz,3)
c        write (6,9877) edge_gen
      else if (ioppbc .eq. 11) then
c       Sphere
        d=edg(1)
      end if
      threp2=1.5
c     cell will contain the negative of the respective cell center coords
      call zeroit(cell,3*27)
c     print *,'IOPPBC=',ioppbc
      go to (10,10,30,40,50,60,60,80,90,100,110),ioppbc
      print *,'PROGRAM ERROR: invalid ioppbc in crorgn=',ioppbc
      stop
c-----Siple cubic or rectangular
10    ncell=27
      y(1)=0.
      y(2)=edge
      y(3)=- edge
      yx(1)=0.0
      yx(2)=edgex
      yx(3)=-edgex
      yy(1)=0.0
      yy(2)=edgey
      yy(3)=-edgey
      ii=0
      do i=1,ndim
        x(3)=y(i)
        do k=1,ndim
          x(2)=yy(k)
          do l=1,ndim
            x(1)=yx(l)
            ii=ii+1
            do j=1,3
              cell(j,ii)=x(j)
            end do
          end do
        end do
      end do
      rcirc=sqrt(edgex**2+edgey**2+edge**2)/2.0
      rinscr=amin1(edgex,edgey,edge)/2
      go to 999
c-----Face-centered cubic
30    ncell=19
      do i=2,5
        cell(2,i)=-edge
        cell(3,i)=-edge
      end do
      cell(2,2)=edge
      cell(3,2)=edge
      cell(2,4)=edge
      cell(3,5)=edge
      do i=2,5
        cell(1,4+i)=cell(2,I)
        cell(3,4+i)=cell(3,i)
        cell(1,8+i)=cell(2,I)
        cell(2,8+i)=cell(3,i)
      end do
      cell(1,14)=-2.0*edge
      cell(1,15)=-cell(1,14)
      cell(2,16)=cell(1,14)
      cell(2,17)=-cell(2,16)
      cell(3,18)=cell(1,14)
      cell(3,19)=-cell(3,18)
      rcirc=edge
      rinscr=edge/sqrt(2.0)
      go to 999
c-----Hexagonal prism (regular)
40    continue
      ncell=21
c     Vertex of the hexagon along the ixyzhex(2) axis
      cell(ixyzhex(3),2)=-edge*sq3p2
      cell(ixyzhex(2),2)=-edge*threp2
      cell(ixyzhex(3),3)=-edge*sq3
      cell(ixyzhex(3),4)=-edge*sq3p2
      cell(ixyzhex(2),4)=edge*threp2
      do k=5,7
        l=9-k
        cell(ixyzhex(2),k)=cell(ixyzhex(2),l)
        cell(ixyzhex(3),k)=-cell(ixyzhex(3),l)
      end do
      do k=1,7
        l1=k+7
        l2=k+14
        cell(ixyzhex(1),l1)=edgex
        cell(ixyzhex(1),l2)=-edgex
        cell(ixyzhex(2),l1)=cell(ixyzhex(2),k)
        cell(ixyzhex(2),l2)=cell(ixyzhex(2),k)
        cell(ixyzhex(3),l1)=cell(ixyzhex(3),k)
        cell(ixyzhex(3),l2)=cell(ixyzhex(3),k)
      end do
      rcirc=sqrt((edgex/2.0)**2+edge**2)
      rinscr=amin1(edgex/2.0,edge*sq3p2)
      go to 999
c-----Hexagonal prism (skewed)
50    continue
      ncell=21
      w=sqrt(edgey**2-edgex**2/4.0)
      h=(w-edgex/(2.0*sqrt(3.0)))/2.0
c     Vertex of the hexagon along the ixyzhex(2) axis
      cell(ixyzhex(3),2)=-edgex/2.0
      cell(ixyzhex(2),2)=-w
      cell(ixyzhex(3),3)=-edgex
      cell(ixyzhex(3),4)=cell(ixyzhex(3),2)
      cell(ixyzhex(2),4)=-cell(ixyzhex(2),2)
      do k=5,7
        l=9-k
        cell(ixyzhex(2),k)=cell(ixyzhex(2),l)
        cell(ixyzhex(3),k)=-cell(ixyzhex(3),l)
      end do
      do k=1,7
        l1=k+7
        l2=k+14
        cell(ixyzhex(1),l1)=edgep
        cell(ixyzhex(1),l2)=-edgep
        cell(ixyzhex(2),l1)=cell(ixyzhex(2),k)
        cell(ixyzhex(2),l2)=cell(ixyzhex(2),k)
        cell(ixyzhex(3),l1)=cell(ixyzhex(3),k)
        cell(ixyzhex(3),l2)=cell(ixyzhex(3),k)
      end do
      rcirc=sqrt((edgep/2.0)**2+amax1((w-h)**2,(edgex/2.0)**2+h**2))
      rinscr=amin1(edgep,edgex,w-h)/2.0
      go to 999
c-----Truncated octahedon
60    ncell=15
c     Truncated face transforms
c     print *,'CRORG edge=',edge,' ncell=',ncell
      do i=2,6,2
        cell(i/2,i) =2.0*edge
        cell(i/2,i+1) = -2.0*edge
      end do
c     +/-z, xy face transforms
      ic=7
      do ix=1,2
        do iy=1,2
          do iz=1,2
            ic=ic+1
            cell(1,ic)=(-1)**(ix)*edge
            cell(2,ic)=(-1)**(iy)*edge
            cell(3,ic)=(-1)**(iz)*edge
          end do
        end do
      end do
      if (ioppbc .eq. 7) then
        call trnsfr(cellalt,cell,ncell*3)
        call rotate_c(cell,ncell,torot_ca,cell,'CRORGN',6)
      end if
      rcirc=edge*sqrt(5.0)/2.0
      rinscr=edge
      go to 999
c-----Hexagonal close packed
c     Neighbour cells in the hexagonal plane
80    ncell=19
      cell(1,2)=d
      cell(1,3)=d/2.0
      cell(2,3)=d*sq3p2
      cell(1,4)=d/2.0
      cell(2,4)=-d*sq3p2
      cell(1,5)=-d
      cell(1,6)=-d/2.0
      cell(2,6)=d*sq3p2
      cell(1,7)=-d/2.0
      cell(2,7)=-d*sq3p2
c     Neighbour cells above with touching face
      cell(2,8)=d/sq3
      cell(1,9)=d/2.0
      cell(2,9)=-d/(2.0*sq3)
      cell(1,10)=-d/2.0
      cell(2,10)=-d/(2.0*sq3)
c     Neighbour cells above with touching vertex
      cell(2,11)=-d*2.0/sq3
      cell(1,12)=d
      cell(2,12)=+d/sq3
      cell(1,13)=-d
      cell(2,13)=d/sq3
      call trnsfr(cell(1,14),cell(1,8),18)
      do k=8,13
        cell(1,k+6)=cell(1,k)
        cell(2,k+6)=cell(2,k)
        cell(3,k)=d*sq2p3
        cell(3,k+6)=-cell(3,k)
      end do
      rcirc=d*3.0/(sqrt(5.0)*2.0)
      rinscr=d/2.0
      go to 999
c-----Octahedral
90    ncell=1
c      write (6,9877) edge_gen
c9877  format(' E_G: ',3(3f8.4,1x))
      do ix=-1,1
        do iy=-1,1
          do iz=-1,1
            if (ix .ne. 0 .or. iy .ne. 0 .or. iz .ne. 0) then
              ncell=ncell+1
              do k=1,3
                cell(k,ncell)=ix*edge_gen(k,1)+iy*edge_gen(k,2)+
     -            iz*edge_gen(k,3)
              end do
            end if
          end do
        end do
      end do
      if (ncell .ne. 27) then
        print *,'PROGRAM ERROR: ncell=',ncell,' (instead of 27)'
        stop
      end if
      do k=1,3
        cz(k)=(edge_gen(k,1)+edge_gen(k,2)+edge_gen(k,3))/2.0
      end do
      rinscr=edg(1)*onethird/2.0
      rcirc=sqrt(scprod(cz,cz))
      go to 999
c-----Input cell centers
100   ncell=1
      rinscr=0.0
      rcirc=0.0
      go to 999
c-----Sphere
110   ncell=1
      rinscr=d
      rcirc=d
999   return
      end
      subroutine updatecell(inptrajtyp,edge)
      dimension edge(3)
      real*8 xtlabc,xtlabc0
      common /boxdat/ xtlabc(6),xtlabc0(6),box(3),box0(3),edge_gen(3,3),
     -  cell0(3,27),cell(3,27),cellalt(3,27),
     -  ncell,ioppbc,noboxinfoar,noboxinfow,noboxrep,
     -  istuner,iboxtypfound,ixcrd(3),ixang(3),ixyzhex(3),
     -  ixyzhextraj(3),isizewarn
      character*1 xyz
      common /axislab/ xyz(3)
      real*8 cellfac
      dimension cellfac(3),ixyzhextrajcharmm(3)
      data ixyzhextrajcharmm /3,2,1/
      if (ioppbc .eq. 5) then
c       For skewed hexagons, proportionality does not hold
        if (ixyzhextraj(1) .eq. 0) then
          call trnsfi(ixyzhextraj,ixyzhextrajcharmm,3)
          write (6,1000) xyz(ixyzhextraj(1)),'hexagon prism axis'
          write (6,1000) xyz(ixyzhextraj(2)),
     -      'axis crossing a hexagon vertex'
          print *,'If this is wrong, modify the subroutine updatecell'
        end if
        if (inptrajtyp .eq. 1) then
          do k=1,3
            edge(k)=xtlabc(ixcrd(ixyzhextraj(k)))
          end do
        else
          do k=1,3
            edge(k)=box(ixyzhextraj(k))
          end do
        end if
        call crorgn(edge,edge_gen,ioppbc,3,ncell,cell,cellalt,
     -    ixyzhex,rins,rc)
      else
        if (inptrajtyp .eq. 1) then
          do k=1,3
            cellfac(k)=xtlabc(ixcrd(k))/xtlabc0(ixcrd(k))
          end do
        else
          do k=1,3
            cellfac(k)=box(k)/box0(k)
          end do
        end if
        do ic=1,ncell
          do k=1,3
            cell(k,ic)=cell0(k,ic)*cellfac(k)
          end do
        end do
      end if
c      write (6,7671) xtlabc0,xtlabc,
c     -  ((cell0(k,ii),k=1,3),ii=ncell-1,ncell),
c     -  ((cell(k,ii),k=1,3),ii=ncell-1,ncell)
c7671   format(' xtlabc0=',6f12.8,/,' xtlabc=',6f12.8,/,
c     -  ' cell0i',6f12.8,' cell=',6f12.8)
       return
1000  format(' NOTE: trajectory assumes ',a,' to be the ',a)
      end
      subroutine genimdist(crm,cell,ncell1,ncell,icmin,rmin2)
      dimension crm(3),cell(3,27)
c     print *,'GENIMDIST ncell,ncell1=',ncell,ncell1
      rmin2=1000000.0
      icmin=0
      do ic=ncell1,ncell
        r2=dist2(crm,cell(1,ic))
        if (r2 .lt. rmin2) then
          rmin2=r2
          icmin=ic
        end if
      end do
      if (icmin .eq. 0) then
        write (6,1717) crm,((i,cell(k,i),k=1,3),i=ncell1,ncell)
1717    format(' ERROR: ic=0 for crm=',3f10.5,/,(' cell',i3,'=',3f10.5))
        stop
      end if
      return
      end
      subroutine genimdist123dim(crm,cell,ncell1,ncell,ixyzexcld,
     -  ixyzincld,icmin,rmin2)
      dimension crm(3),cell(3,27)
c     print *,'GENIMDIST123 ncell,ncell1,ixyzexcld,ixyzincld=',
c    -  ncell,ncell1,ixyzexcld,ixyzincld
      if (ixyzincld+ixyzexcld .eq. 0) then
        call genimdist(crm,cell,ncell1,ncell,icmin,rmin2)
      else if (ixyzexcld .gt. 0) then
c       2D PBC
        rmin2=1000000.0
        do ic=ncell1,ncell
c         Compare only with cells in the 2D plane
          if (cell(ixyzexcld,ic) .eq. 0.0) then
            r2=dist2(crm,cell(1,ic))
            if (r2 .lt. rmin2) then
              rmin2=r2
              icmin=ic
            end if
          end if
        end do
      else
c       1D PBC
        rmin2=1000000.0
        do ic=ncell1,ncell
c         Compare only with cells along the 1D axis
          nz=0
          do k=1,3
            if (k .ne. ixyzincld) then
              if (cell(k,ic) .eq. 0.0) nz=nz+1
            end if
          end do
          if (nz .eq. 2) then
            r2=(crm(ixyzincld)-cell(ixyzincld,ic))**2
            if (r2 .lt. rmin2) then
              rmin2=r2
              icmin=ic
            end if
          end if
        end do
      end if
c     print *,'ICMIN=',icmin
c      write (77,1717) ncell1,ncell,crm,(cell(k,1),k=1,3),rmin2
c1717  format(' ncell1,ncell=',2i3,' crm=',3f10.5,' cell=',3f10.5,
c    -  ' rmin2=',f10.5)
      return
      end
      function distminck(c,ih,n,nnh,cell,cellalt,ioppbc,ncell,
     -  iclose,jclose)
      dimension c(3,n),ih(n),cell(3,27),cellalt(3,27)
c     Find closest image-image distance
      dimension d(3)
      closest=100000.
      do ii=2,nnh
        i=ih(ii)
        ii1=ii-1
        do jj=1,ii1
          j=ih(jj)
          do k=1,3
            d(k)=c(k,i)-c(k,j)
          end do
          if (ioppbc .eq. 7) then
            call genimdist(d,cellalt,2,ncell,icmin,sum)
          else
            call genimdist(d,cell,2,ncell,icmin,sum)
          end if
          if (sum .lt. closest) then
            closest=sum
            iclose=ii
            jclose=jj
          end if
        end do
      end do
      distminck=sqrt(closest)
      return
      end
      function distminimg(c,ih,n,nnh,edge,ioppbc,cell,ncell,ixyzhex,
     -  iclose,jclose)
      dimension c(3,n),ih(n),edge(3),cell(3,27),ixyzhex(3)
      dimension edgesq(3),edge2(3),d(3),dc123(3),summ(7)
      common /numbers/ sq3,sq3inv,sq3p2,sq2p3
      data ef1 /0.0/,ef2 /0.0/,ef3 /0.0/,ef4 /0.0/,eh1 /0.0/,eh2 /0.0/,
     -  eh3 /0.0/,eh4 /0.0/,eh5 /0.0/,eh6 /0.0/,eh7 /0.0/,w /0.0/,
     -  et1 /0.0/,et2 /0.0/,et3 /0.0/,et4 /0.0/,edghalf /0.0/,
     -  edgep /0.0/,edgep2 /0.0/,edgex /0.0/,edgex2 /0.0/,edgpsq3 /0.0/,
     -  edgsq3p2 /0.0/,edgsq2p3 /0.0/,edgp2sq3 /0.0/,edg2psq3 /0.0/
c     Find closest image-image distance
c     print *,'DISTMIN ioppbc,ncell=',ioppbc,ncell
c     print *,'DISTMIN edge1,2=',edge(1),edge(2)
      if (ioppbc .eq. 3) then
c       Face-centered cubic
        ef1=2.0*edge(1)
        ef2=4.0*edge(1)
        ef3=2.0*edge(1)**2
        ef4=4.0*edge(1)**2
      else if (ioppbc .eq. 4) then
c       Hexagonal prizm
        eh1=2.0*sqrt(3.0)*edge(2)
        eh2=3.0*edge(2)**2
        eh3=4.0*edge(2)**2
        eh4=3.0*edge(2)
        eh5=sqrt(3.0)*edge(2)
        eh6=2.0*edge(1)
        eh7=edge(1)**2
      else if (ioppbc .eq. 5) then
c       Skewed hexagonal prizm
        edgep=edge(1)
        edgep2=edgep/2.0
        edgey=edge(2)
        edgex=edge(3)
        edgex2=edgex/2.0
        w=sqrt(edgey**2-edgex**2/4.0)
      else if (ioppbc .eq. 6 .or. ioppbc .eq. 7) then
c       Truncated octahedron
        et1=4.0*edge(1)
        et2=4.0*edge(1)**2
        et3=2.0*edge(1)
        et4=3.0*edge(1)**2
      else if (ioppbc .eq. 1) then
c       Cubic
        do k=1,3
          edgesq(k)=edge(1)**2
          edge2(k)=2.0*edge(1)
        end do
      else if (ioppbc .eq. 8) then
c       Hexagonal close-packed
        edghalf=edge(1)/2.0
        edgsq3p2=edge(1)*sq3p2
        edgsq2p3=edge(1)*sqrt(2.0/3.0)
        edgp2sq3=edge(1)/(2.0*sq3)
        edgpsq3=edge(1)/sq3
        edg2psq3=edge(1)/sq3p2
      else
c       Rectangular
        do k=1,3
          edgesq(k)=edge(k)**2
          edge2(k)=2.0*edge(k)
        end do
      end if
c     print *,'edge=',edge
c     print *,'edgesq=',edgesq
c     print *,'edge2=',edge2
c     write (6,6755) ((c(k,i),k=1,3),i=1,n)
c6755  format(' C=',3f10.5,3x,3f10.5)
c     print *,'DISTMIN ioppbc,edgex,edgep,w=',ioppbc,edgex,edgep,w
      closest=100000.
      do 10 ii=2,nnh
        i=ih(ii)
        ii1=ii-1
        do 11 jj=1,ii1
          j=ih(jj)
          dc1=c(1,i)-c(1,j)
          dc2=c(2,i)-c(2,j)
          dc3=c(3,i)-c(3,j)
          sum=dc1**2+dc2**2+dc3**2
          if (ioppbc .eq. 3) then
c           Face-centered cubic
            d1=abs(dc1)
            if (abs(dc2) .gt. d1) d1=abs(dc2)
            if (abs(dc3) .gt. d1) d1=abs(dc3)
            d1=-d1*ef2+ef4
            d2=abs(dc1)+abs(dc2)
            if (abs(dc2)+abs(dc3) .gt. d2)
     -        d2=abs(dc2)+abs(dc3)
            if (abs(dc1)+abs(dc3) .gt. d2)
     -        d2=abs(dc1)+abs(dc3)
            d2=-d2*ef1+ef3
            if (d1 .lt. d2) then
              sum=sum+d1
            else
              sum=sum+d2
            end if
          else if (ioppbc .eq. 4 .or. ioppbc .eq. 5) then
c           Hexagonal prizm, prism along ixyzhex(1) ax, vertex on ixyzhex(2) ax
            dc123(1)=dc1
            dc123(2)=dc2
            dc123(3)=dc3
            dcc1=abs(dc123(ixyzhex(1)))
            dcc2=abs(dc123(ixyzhex(2)))
            dcc3=abs(dc123(ixyzhex(3)))
            if (ioppbc .eq. 4) then
c             Regular hexagon
              d1=amin1(-dcc3*eh1+eh2,-dcc2*eh4-dcc3*eh5+eh2)
              d2=-dcc1*eh6+eh7
              if (d1 .lt. 0.0) sum=sum+d1
              if (d2 .lt. 0.0) sum=sum+d2
              if (d1 .ge. 0.0 .and. d2 .ge. 0.) sum=sum+amin1(d1,d2)
            else if (ioppbc .eq. 5) then
c             Skewed hexagonal prizm
              sum=(dcc3-edgex)**2+dcc2**2
              sum2=(dcc3-edgex2)**2+(dcc2-w)**2
              if (sum2 .lt. sum) sum=sum2
              if (dcc1 .le. edgep2) then
                sum=sum+dcc1**2
              else
                sum=sum+(dcc1-edgep)**2
              end if
c             write (77,*) dcc1,dcc2,dcc3,sum,sum2
            end if
          else if (ioppbc .eq. 1 .or. ioppbc .eq. 2) then
c           Rectangular
            diff1=edge(1)*(edge(1)-2.0*abs(dc1))
            diff2=edge(2)*(edge(2)-2.0*abs(dc2))
            diff3=edge(3)*(edge(3)-2.0*abs(dc3))
            sum1=amin1(0.0,diff1)+amin1(0.0,diff2)+
     -           amin1(0.0,diff3)
            if (sum1 .lt. 0.0) then
              sum=sum+sum1
            else
              sum=sum+amin1(diff1,diff2,diff3)
            end if
          else if (ioppbc .eq. 6 .or. ioppbc .eq. 7) then
c           Truncated octahedron
            ad1=abs(dc1)
            ad2=abs(dc2)
            ad3=abs(dc3)
            dsum=ad1+ad2+ad3
            dmax=amax1(ad1,ad2,ad3)
            d1=-dmax*et1+et2
            d2=-dsum*et3+et4
            dminn=amin1(d1,d2)
            sum=sum+dminn
          else if (ioppbc .eq. 8) then
c           Hexagonal close-packed
            dax=abs(dc1)
            day=abs(dc2)
            daz=abs(dc3)
            dsx=dc1*dc1
            dsy=dc2*dc2
            dsz=dc3*dc3
            summ(1)=dsx+dsy+dsz
c           Distances from hexagonal plane neighbours
            dax2=(dax-edghalf)**2
            dax3=(dax-edge(1))**2
            day2=(day-edgsq3p2)**2
            summ(2)=dax2+day2+dsz
            summ(3)=dax3+dsy+dsz
c           Distances from face-touching upper neighbours
            day4=(dc2-edgpsq3)**2
            day5=(dc2+edgp2sq3)**2
            daz1=(daz-edgsq2p3)**2
            summ(4)=dsx+day4+daz1
            summ(5)=dax2+day5+daz1
c           Distances from vertex-touching upper neighbours
            day6=(dc2+edg2psq3)**2
            day7=(dc2-edgpsq3)**2
            summ(6)=dsx+day6+daz1
            summ(7)=dax3+day7+daz1
            sum=summ(2)
            icell=2
            do ic=3,7
              if (summ(ic) .lt. sum) icell=ic
              if (summ(ic) .lt. sum) sum=summ(ic)
            end do
          else if (ioppbc .eq. 0) then
c           Input pbc
            d(1)=dc1
            d(2)=dc2
            d(3)=dc3
            call genimdist(d,cell,2,ncell,icmin,sum)
          end if
          if (sum .lt. closest) then
            closest=sum
            iclose=ii
            jclose=jj
          end if
11      continue
10    continue
c     print *,'closest,edge(1)=',closest,edge(1)
      distminimg=sqrt(closest)
      return
      end
      subroutine distminsetup(edge,ioppbc)
      dimension edge(3)
      common /distmindata/ ef1,ef2,ef3,ef4,edgep,edgep2,edgey,edgex,
     -  edgex2,w,h,et1,et2,et3,et4,edge2(3),edghalf,edgsq3p2,edgp2sq3,
     -  edgsq2p3,edgpsq3,edg2psq3
      common /numbers/ sq3,sq3inv,sq3p2,sq2p3
      if (ioppbc .eq. 3) then
c       Face-centered cubic
        ef1=2.0*edge(1)
        ef2=4.0*edge(1)
        ef3=2.0*edge(1)**2
        ef4=4.0*edge(1)**2
      else if (ioppbc .eq. 4) then
c       Regular hexagonal prizm
        edgep=edge(1)
        edgep2=edgep/2.0
        w=edge(2)*1.5
        h=edge(2)/2.0
        edgex2=edge(2)*sq3p2
        edgex=edge(2)*sq3
      else if (ioppbc .eq. 5) then
c       Skewed hexagonal prizm
        edgep=edge(1)
        edgep2=edgep/2.0
        edgey=edge(2)
        edgex=edge(3)
        edgex2=edgex/2.0
        w=sqrt(edgey**2-edgex**2/4.0)
        h=(w-edgex/(2.0*sq3))/2.0
      else if (ioppbc .eq. 6 .or. ioppbc .eq. 7) then
c       Truncated octahedron
        et1=4.0*edge(1)
        et2=4.0*edge(1)**2
        et3=2.0*edge(1)
        et4=3.0*edge(1)**2
      else if (ioppbc .eq. 1) then
c       Cubic
        do k=1,3
          edge(k)=edge(1)
          edge2(k)=edge(1)/2.0
        end do
      else if (ioppbc .eq. 8) then
c       Hexagonal close-packed
        edghalf=edge(1)/2.0
        edgsq3p2=edge(1)*sq3p2
        edgsq2p3=edge(1)*sqrt(2.0/3.0)
        edgp2sq3=edge(1)/(2.0*sq3)
        edgpsq3=edge(1)/sq3
        edg2psq3=edge(1)/sq3p2
      else
c       Rectangular
        do k=1,3
          edge2(k)=edge(k)/2.0
        end do
      end if
      return
      end
      subroutine distmincalc(ioppbc,cell,ncell,ixyzhex,edge,dc1,dc2,
     -  dc3,icell,sum)
      dimension cell(3,ncell),ixyzhex(3),edge(3)
      common /distmindata/ ef1,ef2,ef3,ef4,edgep,edgep2,edgey,edgex,
     -  edgex2,w,h,et1,et2,et3,et4,edge2(3),edghalf,edgsq3p2,edgp2sq3,
     -  edgsq2p3,edgpsq3,edg2psq3
      common /numbers/ sq3,sq3inv,sq3p2,sq2p3
      dimension dc123(3),d(3),summ(7)
      if (ioppbc .eq. 3) then
c       Face-centered cubic
        sum=dc1**2+dc2**2+dc3**2
        icell=1
        d1=abs(dc1)
        if (abs(dc2) .gt. d1) d1=abs(dc2)
        if (abs(dc3) .gt. d1) d1=abs(dc3)
        d1=-d1*ef2+ef4
        d2=abs(dc1)+abs(dc2)
        if (abs(dc2)+abs(dc3) .gt. d2)
     -    d2=abs(dc2)+abs(dc3)
        if (abs(dc1)+abs(dc3) .gt. d2)
     -    d2=abs(dc1)+abs(dc3)
        d2=-d2*ef1+ef3
        if (d1 .lt. d2) then
          sum1=sum+d1
        else
          sum1=sum+d2
        end if
        if (sum .gt. sum1) then
          sum=sum1
          icell=2
        end if
      else if (ioppbc .eq. 4 .or. ioppbc .eq. 5) then
c       Hexagonal prizm, prism along ixyzhex(1) ax, vertex on ixyzhex(2) ax
        dc123(1)=dc1
        dc123(2)=dc2
        dc123(3)=dc3
        dcc1=abs(dc123(ixyzhex(1)))
        dcc2=abs(dc123(ixyzhex(2)))
        dcc3=abs(dc123(ixyzhex(3)))
        icell=2
        if (dcc3 .gt. edgex2) then
c         Cell 6 or right side of cell 5
          if (h+sq3inv*(dcc3-edgex2) .le. dcc2) then
c           Cell 5
            dcc3=dcc3-edgex2
            dcc2=dcc2-w
          else
c           Cell 6
            dcc3=dcc3-edgex
          end if
        else
c         Cell 1 or left side of cell 5
          if (h+sq3inv*(edgex2-dcc3) .le. dcc2) then
c           Cell 5
            dcc3=dcc3-edgex2
            dcc2=dcc2-w
          else
            icell=1
          end if
        end if
        if (dcc1 .gt. edgep2) then
          dcc1=dcc1-edgep
          icell=2
        end if
        sum=dcc1**2+dcc2**2+dcc3**2
      else if (ioppbc .eq. 1 .or. ioppbc .eq. 2) then
c       Rectangular
        dcc1=abs(dc1)
        dcc2=abs(dc2)
        dcc3=abs(dc3)
        icell=1
        if (dcc1 .gt. edge2(1)) then
          dcc1=dcc1-edge(1)
          icell=2
        end if
        if (dcc2 .gt. edge2(2)) then
          dcc2=dcc2-edge(2)
          icell=2
        end if
        if (dcc3 .gt. edge2(3)) then
          dcc3=dcc3-edge(3)
          icell=2
        end if
        sum=dcc1**2+dcc2**2+dcc3**2
      else if (ioppbc .eq. 6) then
c       Truncated octahedron, axes normal to the square faces
        sum=dc1**2+dc2**2+dc3**2
        icell=1
        ad1=abs(dc1)
        ad2=abs(dc2)
        ad3=abs(dc3)
        dsum=ad1+ad2+ad3
        dmax=amax1(ad1,ad2,ad3)
        d1=-dmax*et1+et2
        d2=-dsum*et3+et4
        dminn=amin1(d1,d2)
        if (dminn .lt. 0.0) then
          sum=sum+dminn
          icell=2
        end if
      else if (ioppbc .eq. 6 .or. ioppbc .eq. 7) then
c       Truncated octahedron, X axis normal to a hexagon face
        icell=1
        d(1)=dc1
        d(2)=dc2
        d(3)=dc3
        call genimdist(d,cell,1,ncell,icmin,rmin2)
        if (icmin .gt. 1) icell=2
      else if (ioppbc .eq. 8) then
c       Hexagonal close-packed
        dax=abs(dc1)
        day=abs(dc2)
        daz=abs(dc3)
        dsx=dc1*dc1
        dsy=dc2*dc2
        dsz=dc3*dc3
        summ(1)=dsx+dsy+dsz
c       Distances from hexagonal plane neighbours
        dax2=(dax-edghalf)**2
        dax3=(dax-edge(1))**2
        day2=(day-edgsq3p2)**2
        summ(2)=dax2+day2+dsz
        summ(3)=dax3+dsy+dsz
c       Distances from face-touching upper neighbours
        day4=(dc2-edgpsq3)**2
        day5=(dc2+edgp2sq3)**2
        daz1=(daz-edgsq2p3)**2
        summ(4)=dsx+day4+daz1
        summ(5)=dax2+day5+daz1
c       Distances from vertex-touching upper neighbours
        day6=(dc2+edg2psq3)**2
        day7=(dc2-edgpsq3)**2
        summ(6)=dsx+day6+daz1
        summ(7)=dax3+day7+daz1
        sum=summ(1)
        icell=1
        do ic=2,7
          if (summ(ic) .lt. sum) then
            sum=summ(ic)
            icell=ic
           end if
        end do
      else if (ioppbc .eq. 0) then
c       Input pbc
        d(1)=dc1
        d(2)=dc2
        d(3)=dc3
        call genimdist(d,cell,1,ncell,icmin,sum)
      end if
c       Check
c       d(1)=dc1
c       d(2)=dc2
c       d(3)=dc3
c       call genimdist(d,cell,1,ncell,icmin,sumx)
c       if (abs(sum-sumx) .gt. 0.1 .or.
c    -           icmin .eq. 1 .and. icell  .gt. 1 .or.
c    -           icmin .gt. 1 .and. icell  .eq. 1)
c    -     print *,'DMC ERROR: sum,x=',sum,sumx,
c    -    ' icmin,icell=',icmin,icell
      return
      end
      function touch(c,ih,n,nnh,edge,ioppbc,cell,ncell,ixyzhex,angle,
     -  rot,mintyp,i2dopt,cnew)
      dimension c(3,n),ih(n),edge(3),cell(3,27),
     -  angle(3),rot(3,3),cnew(3,n),ixyzhex(3)
      dimension xyzmin(3),xyzmax(3),centinp(3)
c     print *,'Touch angle=',angle
      if (i2dopt .eq. 0) then
        call euler(rot,angle(1),angle(2),angle(3))
      else
        sfi=sin(angle(1))
        cfi=cos(angle(1))
        call zeroit(rot,9)
        rot(i2dopt,i2dopt)=1.0
        ix=mod(i2dopt,3)+1
        iy=mod(i2dopt+1,3)+1
        rot(ix,ix)=cfi
        rot(ix,iy)=sfi
        rot(iy,ix)=-sfi
        rot(iy,iy)=cfi
      end if
c     call chkort(rot)
c      write (6,7711) rot
c7711  format(/,3(3f10.5,/))
      call rotate_c(c,n,rot,cnew,'TOUCH',5)
      if (mintyp .eq. 1) then
c       Minimize image-image distances
        touch=-distminimg(cnew,ih,n,nnh,edge,ioppbc,cell,ncell,ixyzhex,
     -    inn,jnn)
      else if (mintyp .eq. 2) then
c       Minimize bounding cube
        call extension(cnew,ih,nnh,1,n,xyzmin,xyzmax,centinp,0,0,v)
        touch=amax1(xyzmax(1)-xyzmin(1),xyzmax(2)-xyzmin(2),
     -    xyzmax(3)-xyzmin(3))
      else
c       Minimize bounding rectangle's volume
        call extension(cnew,ih,nnh,1,n,xyzmin,xyzmax,centinp,0,0,touch)
c       touch=(xyzmax(1)-xyzmin(1))*(xyzmax(2)-xyzmin(2))*
c    -    (xyzmax(3)-xyzmin(3))
      end if
      return
      end
      subroutine extension(c,ih,nnh,nstart,n,cmin,cmax,c0,iprint,
     -  ivcheck,vol)
      dimension c(3,n),ih(n),cmin(3),cmax(3),c0(3)
      character*1 xyz
      common /axislab/ xyz(3)
c     Find an approximate center first
c     write (06,*) 'EXTENSION nstart,n=',nstart,n,' nnh=',nnh
      do k=1,3
        cmin(k)=1.e+25
        cmax(k)=-1.e+25
      end do
      do k=1,3
        if (nnh .gt. 0) then
          do ii=nstart,nnh
            i=ih(ii)
            if (c(k,i) .lt. cmin(k)) cmin(k)=c(k,i)
            if (c(k,i) .gt. cmax(k)) cmax(k)=c(k,i)
c           if (iprint .gt. 1) write (77,7711) ii,i,k,c(k,i)
          end do
        else
          do i=nstart,n
            if (c(k,i) .lt. cmin(k)) cmin(k)=c(k,i)
            if (c(k,i) .gt. cmax(k)) cmax(k)=c(k,i)
c           if (iprint .gt. 1) write (77,7711) i,i,k,c(k,i)
          end do
        end if
        c0(k)=(cmax(k)+cmin(k))/2.0
c7711    format(2i5,' c',i1,'=',f10.5)
      end do
      vol=1.0
      do k=1,3
        vol=vol*(cmax(k)-cmin(k))
      end do
      if (iprint .gt. 0)
     -  write (6,1000) (xyz(k),cmin(k),c0(k),cmax(k),k=1,3),vol
      if (ivcheck .eq. 1) then
        do k=1,3
          imax=cmax(k)
          if (imax .eq. 9999) write (6,1001) xyz(k)
        end do
        if (vol/n .gt. 1000.0) then
          write (6,1002) vol,n
          if (iprint .eq. 0)
     -      write (6,1000) (xyz(k),cmin(k),c0(k),cmax(k),k=1,3)
          call askstop(0)
        end if
      end if
      return
1000  format(3(' Smallest, middle and largest ',a1,
     -  ' coordinate values=',3f9.4,/),
     -  ' Volume of enclosing rectangle=',f12.2)
1001  format(' WARNING: input structure contains ',a1,' coordinate ',
     -  'value(s) of 9999.0',/,10x,'indicating undefined values')
1002  format(' WARNING: initial enclosing rectangle volume (',e12.4,
     -  ' for',i7,' atoms)',/,8x,'suggests corrupted input structure')
      end
      subroutine shiftmol(c,n,c0,cnew,fac)
      dimension c(3,n),cnew(3,n),c0(3),c00(3)
C     Center the molecule at c0
c     print *,'SHIFTMOL n=',n,' fac=',fac,' c0=',c0
      call trnsfr(c00,c0,3)
      do k=1,3
        do i=1,n
         cnew(k,i)=c(k,i)+fac*c00(k)
        end do
      end do
      return
      end
      subroutine check_rotmat(rot,lab,llab,ifail)
      dimension rot(3,3)
      character*(*) lab
      common /rotwarn/ nrotwarn,nrottest,devmax
      dimension u(3,3)
      data u /1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0/
c     Check the rotation matrix
      ifail=0
      nrottest=nrottest+1
      do i=1,3
        do j=1,3
          sum=0.0
          do k=1,3
            sum=sum+rot(i,k)*rot(j,k)
          end do
          if (abs(sum-u(i,j)) .gt. 0.99) then
            ifail=1
            write (6,1000) 'PROGRAM ERROR',lab(1:llab),i,j,sum
          else if (abs(sum-u(i,j)) .gt. 0.1) then
            if (nrotwarn .lt. 00)
     -        write (6,1000) 'WARNING',lab(1:llab),i,j,sum
            nrotwarn=nrotwarn+1
            if (devmax .lt. abs(sum-u(i,j))) devmax=abs(sum-u(i,j))
          end if
        end do
      end do
      if (ifail .gt. 0) then
        write (6,1001) rot
c       stop
      end if
      return
1000  format(1x,a,': rotation matrix error in call ',a,/,
     -  ' SUM rot(',i1,',k)*rot(',i1,',k)=',e12.5)
1001  format(' The rotation matrix:',(/,3e13.5))
      end
      subroutine rotate_c(c,n,rot,cnew,lab,llab)
      dimension c(3,n),rot(3,3),cnew(3,n),cn(3)
      character*(*) lab
      call check_rotmat(rot,lab,llab,ifail)
c     Orient the molecule
      do im=1,n
        cn(1)=rot(1,1)*c(1,im)+rot(1,2)*c(2,im)+rot(1,3)*c(3,im)
        cn(2)=rot(2,1)*c(1,im)+rot(2,2)*c(2,im)+rot(2,3)*c(3,im)
        cn(3)=rot(3,1)*c(1,im)+rot(3,2)*c(2,im)+rot(3,3)*c(3,im)
        call trnsfr(cnew(1,im),cn,3)
c       cnew(1,im)=cn1
c       cnew(2,im)=cn2
c       cnew(3,im)=cn3
      end do
      return
      end
      subroutine transrot(c,ct,atw,atwtemp,rot,xyzmin,edge_gen,
     -  molsltlim,nmolslt,nmolsltnoion,minresflag,n,nslt,
     -  nslv,npbc,ixyzhex,nneig,ineig,molresflag,ixres,
     -  it1,it2,igl,iaskshift,nconf,nosegid,pi,maxrsd,maxneig,
     -  mxat)
      dimension c(3,mxat),ct(3,mxat),atw(mxat),atwtemp(mxat),
     -  edge_gen(3,3),nneig(mxat),ineig(maxneig,mxat),
     -  molresflag(maxrsd),ixres(mxat),rot(3,3),xyzmin(3),it1(mxat),
     -  it2(mxat),molsltlim(3,maxrsd),ixyzhex(3),crep(3)
      character*1 xyz,ans
      common /axislab/ xyz(3)
      dimension edge(3),cell(3,27),cellalt(3,27),x(3),y(3),z(3),cent(3),
     -  c00(3)
c     print *,'TRANSROT maxrsd,mxat=',maxrsd,mxat
      ans=' '
      do while (ans .ne. 'q')
        if (iaskshift .eq. 1) then
          call quiz(ans,itranstyp,' ',' ',0,
     -      '(additional) conformation transformation type',45,0,5,6,
     -      igl,00)
        else
          ans='r'
        end if
        if (ans .eq. 's' .or. ans .eq. 'p' .or. ans .eq. 'a') then
c         Shift (first)
          if (ans .eq. 's') then
            do k=1,3
              call getreal('Value to add to the '//xyz(k)//
     -          ' coordinates',32,0.0,xyzmin(k),0,0)
            end do
          else
            call getint('Index of atom to be shifted',27,1,1,n,ias,0)
            if (ias .gt. nslt)
     -        print *,'WARNING: atom ',ias,' is a solvent atom'
            do k=1,3
              call getreal('New '//xyz(k)//
     -          ' coordinate of the selected atom',37,0.0,xyzmin(k),0,0)
              xyzmin(k)=xyzmin(k)-c(k,ias)
            end do
          end if
          call shiftmol(c,n,xyzmin,c,+1.0)
          write (6,1002) xyzmin
        end if
        if (ans .eq. 'c' .or. ans .eq. 'p') then
c         Now reset into the PBC cell
          call setpbccell(' ',0,edge,edge_gen,cell,ncell,cellalt,
     -      ixyzhex,npbc,ioppbc,iusepbc,vol,nw,rinscr,rcirc,1,
     -      igl)
          call setrepats(nmolslt,molsltlim,nslt,nneig,ineig,
     -      molresflag,minresflag,it1,it2,maxneig,maxrsd,igl)
          call setpbcdim(ioppbc,ixyzhex,ixyzexcld,ixyzincld,xyz,igl)
          if (nosegid .eq. 1) print *,'WARNING: PDB file had no ',
     -      'segment ID - solute is considered a single molecule'
          if (ans .eq. 'c') then
c           Centering was requested
c           Set atwtmp to zero for molecular ions
            do ia=1,nslt
              atwtemp(ia)=atw(ia)
              if (molresflag(ixres(ia)) .gt. minresflag) atwtemp(ia)=0.0
            end do
            if (ioppbc .eq. 6 .or. ioppbc .eq. 7)
     -        call askyn('Do you want to try both TO orientations',40,
     -          -1,1,icellalt,137)
            call systemcenter(n,nmolslt,nmolsltnoion,molsltlim,c,ct,it1,
     -        atwtemp,cell,ncell,cellalt,icellalt,0,0,nslt,nslv,0,0,
     -        imcent,nconf,mxat,maxrsd)
          else
c           Reset after shift
            do is=1,nmolslt
              natoms=molsltlim(2,is)-molsltlim(1,is)+1
              if (molsltlim(3,is) .eq. 0) then
                call cofms(c(1,molsltlim(1,is)),crep,natoms,atw)
              else
                call trnsfr(crep,c(1,molsltlim(3,is)),3)
              end if
              call pbcreset(c(1,molsltlim(1,is)),natoms,crep,
     -          cell,ncell,0,0,img)
            end do
            nsw=(n-nslt)/nslv
            do iw=1,nsw
              call pbcreset(c(1,nslt+(iw-1)*nslv+1),nslv,
     -          c(1,nslt+(iw-1)*nslv+1),cell,ncell,0,0,img)
            end do
          end if
        else if (ans .eq. 'r') then
c         Rotate by an input angle
          call genrot(rot,pi,iax,angle,igl)
          if (iax .eq. -1) then
            call unitmat(rot)
            ans='q'
          else
            call rotate_c(c,n,rot,c,'TRANSROT',8)
            if (iax .eq. 0) write (6,1000) rot
            if (iax .gt. 0) write (6,1001) xyz(iax),angle
          end if
        else if (ans .eq. 'b') then
          call getint('Atom index to put at the origin',31,1,1,nslt,
     -      iacent,000)
          call getint('Atom index to put on the X axis',31,1,1,nslt,
     -      iaxax,000)
          call getint('Atom index to put in the X-Y plane',34,1,1,nslt,
     -      iaxyplane,000)
          call trnsfr(xyzmin,c(1,iacent),3)
          call shiftmol(c,n,xyzmin,c,-1.0)
          call trnsfr(x,c(1,iaxax),3)
          call norm(x,1.0)
          call trnsfr(y,c(1,iaxyplane),3)
          call vprd(x,y,z)
          call vprd(z,x,y)
          call norm(y,1.0)
          call norm(z,1.0)
          do k=1,3
            rot(1,k)=x(k)
            rot(2,k)=y(k)
            rot(3,k)=z(k)
          end do
          write (6,1000) ((rot(i,j),j=1,3),i=1,3)
          call rotate_c(c,n,rot,c,'TRANSROTb',9)
        else if (ans .eq. 'l') then
          deffac=1.54/0.83
          print *,'Default factor converts ChemAxon SDF file units to ',
     -      'Angstrom'
          call getreal('Factor to multiply the coordinates with',39,
     -      deffac,scfac,1,000)
          do ia=1,n
            do k=1,3
              c(k,ia)=scfac*c(k,ia)
            end do
          end do
        else if (ans .eq. 'e') then
c         Separate molecular complexes
          if (n .gt. nslt) then
            print *,'System includes solvents that will be deleted'
            call askstop(1)
            n=nslt
          else
            call getreal(
     -        'Distance increment from the center of centers',45,5.0,
     -        dincr,0,000)
            call setrepats(nmolslt,molsltlim,nslt,nneig,ineig,
     -        molresflag,minresflag,it1,it2,maxneig,maxrsd,igl)
            call zeroit(cent,3)
            do im=1,nmolslt
              if (molsltlim(3,im) .gt. 0) then
                call trnsfr(ct(1,im),c(1,molsltlim(3,im)),3)
              else if (molsltlim(3,im) .eq. 0) then
                call extension(c,it1,0,molsltlim(1,im),
     -            molsltlim(2,im),x,y,c00,0,0,v)
              else
                call zeroit(x,3)
                do ia=molsltlim(1,im),molsltlim(2,im)
                  do k=1,3
                    x(k)=x(k)+c(k,ia)
                  end do
                end do
                do k=1,3
                  ct(k,im)=x(k)/(molsltlim(2,im)-molsltlim(1,im)+1)
                end do
              end if
              do k=1,3
                cent(k)=cent(k)+ct(k,im)
              end do
            end do
            do k=1,3
              cent(k)=cent(k)/nmolslt
            end do
            write (6,1003) cent
            do im=1,nmolslt
              r2=0.0
              do k=1,3
                x(k)=ct(k,im)-cent(k)
                r2=r2+x(k)**2
              end do
              write (6,1004) im,x
              r2=sqrt(r2)
              do k=1,3
                y(k)=cent(k)+x(k)*(r2+dincr)/r2
              end do
              write (6,1005) im,y
              do ia=molsltlim(1,im),molsltlim(2,im)
                do k=1,3
                  c(k,ia)=c(k,ia)+(y(k)-ct(k,im))
                end do
              end do
            end do
          end if
        end if
      end do
      return
1000  format(' System was rotated with the rotation matrix:',/,
     -  (10x,3f11.7))
1001  format(' System was rotated arount the ',a1,'-axis by',f8.1,
     -  ' deg')
1002  format(' System was translated by <',2(f9.3,','),f9.3,'> A')
1003  format(' Center of centers;',3f10.5)
1004  format(' im=',i4,' center vector=',3f10.5)
1005  format(' im=',i4,' shifted center vector=',3f10.5)
      end
      subroutine setpbcdim(ioppbc,ixyzhex,ixyzexcld,ixyzincld,xyz,
     -  igl)
      dimension ixyzhex(3)
      character*1 xyz(3),ans
      ixyzexcld=0
      ixyzincld=0
      if (ioppbc .ne. 3 .and. ioppbc .ne. 5 .and.
     -    ioppbc .ne. 6 .and. ioppbc .ne. 7 .and.
     -    ioppbc .ne. 9 .and. ioppbc .ne. -1) then
        call getint('Number of PBC dimensions',24,3,1,3,npbcdim,110)
        if (npbcdim .eq. 2) then
          if (ioppbc .eq. 4 .or. ioppbc .eq. 5) then
            ixyzexcld=ixyzhex(1)
            print *,'Hexagonal prism - exluded axis:',xyz(ixyzexcld)
          else
            call quiz(ans,ixyzexcld,' ',
     -        'to exclude from the PBC calculation',-35,'axis',4,
     -        0,5,6,igl,0)
          end if
        else if (npbcdim .eq. 1) then
          if (ioppbc .eq. 4 .or. ioppbc .eq. 5) then
            ixyzincld=ixyzhex(1)
            print *,'Hexagonal prism - included axis:',xyz(ixyzincld)
          else
            call quiz(ans,ixyzincld,' ',
     -        'to include in the PBC calculation',-33,'axis',4,
     -         0,5,6,igl,0)
          end if
        end if
      end if
      return
      end
      subroutine euler(r,fi,ps,th)
c#    MMC routine 097 lstmod: 10/10/90
c*****Generate an orientation matrix from the 3 euler angles
      dimension r(3,3)
c     this subroutine prepares a rotation matrix
c     eq(4-47) of Goldstein (r=a)
      sfi=sin(fi)
      cfi=cos(fi)
      sps=sin(ps)
      cps=cos(ps)
      sth=sin(th)
      cth=cos(th)
      r(1,1)=cps*cfi-cth*sfi*sps
      r(2,1)=-sps*cfi-cth*sfi*cps
      r(3,1)=sth*sfi
      r(1,2)=cps*sfi+cth*cfi*sps
      r(2,2)=-sps*sfi+cth*cfi*cps
      r(3,2)=-sth*cfi
      r(1,3)=sth*sps
      r(2,3)=sth*cps
      r(3,3)=cth
      return
      end
      subroutine ranort(r,i2dopt)
c#    MMC routine 097 lstmod: 10/10/90
c*****Generate an orientation matrix from the uniform distribution
c     from the 3 Euler angles (i2dopt=0) or a random orientation, coresponding
c     to a random rotation around axis i2dopt (i2dopt .gt. 0)
      dimension r(3,3),rn(3)
      if (i2dopt .eq. 0) then
c       eq(4-47) of Goldstein (r=a)
        call randpx(3,rn)
        fir=rn(1)*3.141592*2.0
        Psr=rn(3)*3.141592*2.0
        Cth=-1.0+2.0*Rn(2)
        sth=sqrt(1.0-Cth*cth)
        sfi=sin(fir)
        cfi=cos(fir)
        sps=sin(psr)
        cps=cos(psr)
        r(1,1)=cps*cfi-cth*sfi*sps
        r(2,1)=-sps*cfi-cth*sfi*cps
        r(3,1)=sth*sfi
        r(1,2)=cps*sfi+cth*cfi*sps
        r(2,2)=-sps*sfi+cth*cfi*cps
        r(3,2)=-sth*cfi
        r(1,3)=sth*sps
        r(2,3)=sth*cps
        r(3,3)=cth
      else
        call randpx(1,rn)
        fir=rn(1)*3.141592*2.0
        sfi=sin(fir)
        cfi=cos(fir)
        call zeroit(r,9)
        r(i2dopt,i2dopt)=1.0
        ix=mod(i2dopt,3)+1
        iy=mod(i2dopt+1,3)+1
        r(ix,ix)=cfi
        r(ix,iy)=sfi
        r(iy,ix)=-sfi
        r(iy,iy)=cfi
      end if
      return
      end
      subroutine unitmat(r)
      dimension r(3,3)
      do i=1,3
        do j=1,3
          r(i,j)=0.0
        end do
        r(i,i)=1.0
      end do
      return
      end
      subroutine rot90(ix,r)
      dimension r(3,3)
c     Generate rotation matrix for 90 degree rotation around the ix axis
      call unitmat(r)
      iy=mod(ix,3)+1
      iz=mod(ix+1,3)+1
      r(iy,iy)=0.0
      r(iz,iz)=0.0
      r(iy,iz)=1.0
      r(iz,iy)=-1.0
      return
      end
      subroutine randpx_init(iseed)
c*****Set the seed of the random number generator (for reproducibility)
      integer*4 ixo
      common /rangen/ ixo
      ixo=iseed
      return
      end
      subroutine randpx(n,rno)
c#    MMC routine 429 lstmod: 10/04/86
c*****Congruential random number generator, Forsythe's constants
      integer*4 ixo,iy
      common /rangen/ ixo
      dimension rno(n)
      do i=1,n
        iy=ixo*314159269+453806245
c       Eliminate bits over 31
        iy=ibclr(iy,31)
        rno(i)=float(iy)/2.1474836E+09
        ixo=iy
      end do
      return
      end
      subroutine scramble(ix,n)
      dimension ix(n)
      dimension rand(1)
      call indexit(ix,1,n,0)
      left=n
      do i=1,n
        call randpx(1,rand)
        is1=i+rand(1)*left
        ix0=ix(is1)
        ix(is1)=ix(i)
        ix(i)=ix0
        left=left-1
      end do
      return
      end
      subroutine chkort(rot)
      dimension rot(3,3),rt(3,3)
c     Check rot for orthogonality
      do i=1,3
        do j=1,3
          sum=0.0
          do k=1,3
            sum=sum+rot(i,k)*rot(j,k)
          end do
          rt(i,j)=sum
        end do
      end do
      write (6,1000) rt
1000  format(' Orthogonality check:'/,(3f10.6))
      return
      end
      function dist2(c1,c2)
      dimension c1(3),c2(3)
      dist2=0.0
      do k=1,3
        dist2=dist2+(c1(k)-c2(k))**2
      end do
      return
      end
      function dist2n(c1,c2,n)
      dimension c1(3,n),c2(3,n)
      dist2n=0.0
      do i=1,n
        do k=1,3
          dist2n=dist2n+(c1(k,i)-c2(k,i))**2
         end do
       end do
      return
      end
      function scprod(a,b)
C*****Computes the scalar product a and b
      dimension a(3),b(3)
      scprod=a(1)*b(1)+a(2)*b(2)+a(3)*b(3)
      return
      end
      real*8 function dscprod(a,b)
C*****Computes the scalar product a and b
      real*8 a(3),b(3)
      dscprod=a(1)*b(1)+a(2)*b(2)+a(3)*b(3)
      return
      end
      subroutine norm(d,fac)
      dimension d(3)
c     Normalize d
      sum=0.0
      do k=1,3
        sum=sum+d(k)**2
      end do
      if (sum .gt. 0.0) then
        do k=1,3
          d(k)=fac*d(k)/sqrt(sum)
        end do
      end if
      return
      end
      subroutine arrsum(a,b,c,n)
c*****c=a+b
      dimension a(n),b(n),c(n)
      do i=1,n
        c(i)=a(i)+b(i)
      end do
      return
      end
      subroutine arrdiff(a,b,c,n)
c*****c=a-b
      dimension a(n),b(n),c(n)
      do i=1,n
        c(i)=a(i)-b(i)
      end do
      return
      end
      subroutine darrdiff(a,b,c,n)
c*****c=a-b
      real*8 a(n),b(n),c(n)
      do i=1,n
        c(i)=a(i)-b(i)
      end do
      return
      end
      subroutine arrdistsd(a1,a2,dist,dist2)
c#    MMC routine 277 lstmod: 03/29/00
c*****dist2 = sum(ai-bi)**2
      real*8 a1,a2,dist,dist2
      real*8 x,y,z
      dimension a1(3),a2(3)
      x=a1(1)-a2(1)
      y=a1(2)-a2(2)
      z=a1(3)-a2(3)
      dist2=x*x+y*y+z*z
      dist=dsqrt(dist2)
      return
      end
      subroutine trnsfr(a,b,n)
c*****Real array transfer
      dimension a(n),b(n)
      do i=1,n
        a(i)=b(i)
      end do
      return
      end
      subroutine trnsfi(ia,ib,n)
c*****Fast integer array transfer
      dimension ia(n),ib(n)
      do i=1,n
        ia(i)=ib(i)
      end do
      return
      end
      subroutine trnsfrd(a,b,n)
c*****Fast array transfer
      real*8 a(n),b(n)
      do i=1,n
        a(i)=b(i)
      end do
      return
      end
      subroutine copyintgreal(intgv,realv,itor)
c*****Copy the bitpattern between an integer and a real
      if (itor .eq. 0) then
c       Put the real into the integer
        call copyirr(realv,0)
        call copyiri(intgv,1)
      else
c       Put the integer into the real
        call copyiri(intgv,0)
        call copyirr(realv,1)
      end if
      return
      end
      subroutine copyirr(realv,iread)
      common /janus/ realvar
      if (iread .eq. 1) realv=realvar
      if (iread .eq. 0) realvar=realv
      return
      end
      subroutine copyiri(intgv,iread)
      common /janus/ intgvar
      if (iread .eq. 1) intgv=intgvar
      if (iread .eq. 0) intgvar=intgv
      return
      end
      subroutine lastchar(line,ifc,len)
      character*(*) line
c     Finds the last nonblank in line
      do i=1,len
        ifc=len-i+1
        if (line(ifc:ifc) .ne. ' ')  return
      end do
      if (ifc .eq. 1 .and. line(1:1) .eq. ' ') ifc=0
      return
      end
      subroutine findchar(char,line,ic,len)
      character*1 char
      character*(*) line
c     Finds the next character char in line
c     print *,'FINDCHAR char=',char
      do while (line(ic:ic) .ne. char .and. ic .lt. len)
        ic=ic+1
      end do
      return
      end
      subroutine nextchar(line,ifc,len)
      character*(*) line
c     Finds the next nonblank in line
      character*1 tab,ctrlM
      common /tab/ tab,ctrlM
      if (ifc .gt. len-1) return
      ifc1=ifc
      do i=ifc1,len-1
        ifc=i
c       if (line(i:i) .eq. ' ') print *,'nextc i=',i,' blank'
c       if (line(i:i) .eq. tab) print *,'nextc i=',i,' tab'
        if (line(i:i) .ne. ' ' .and. line(i:i) .ne. tab) then
c         if (line(i:i) .eq. '!') ifc=len
          return
        end if
      end do
      ifc=len
      return
      end
      subroutine nextblank(line,ifc,len)
      character*(*) line
c     Finds the next blank in line
      character*1 tab,ctrlM
      common /tab/ tab,ctrlM
      if (ifc .gt. len-1) return
      ifc1=ifc
      do i=ifc1,len-1
        ifc=i
        if (line(i:i) .eq. ' ' .or. line(i:i) .eq. tab) then
c         if (line(i:i) .eq. '!') ifc=len
          return
        end if
      end do
      ifc=len
      return
      end
      subroutine nextstring(line,ifc,ic1,ic2,len)
      character*(*) line
      call nextchar(line,ifc,len)
      if (line(ifc:ifc) .eq. '"') then
c       Look for closing quote
        ifc=ifc+1
        ic1=ifc
        call findchar('"',line,ifc,len)
        if (ifc .eq. len) then
          print *,'No closing quote was found'
          stop
        end if
        ic2=ifc-1
        ifc=ifc+1
      else
        ic1=ifc
        call nextblank(line,ifc,len)
        ic2=ifc-1
      end if
      return
      end
      subroutine laststring(line,icf,icl,lline,len)
      character*(*) line
      ic=1
      icl=1
      do while (icl .lt. lline)
        call nextstring(line,ic,icf,icl,len)
        ic=icl+1
      end do
      return
      end
      subroutine opt2d(c,cnew,ih,n,nslt,nnh,edge,ioppbc,cell,ncell,
     -  ixyzhex,angle,rot,ftol,mintyp,i2dopt,iter)
      dimension c(3,n),cnew(3,n),ih(n),edge(3),cell(3,27),rot(3,3),
     -  angle(3),ixyzhex(3)
c     print *,'--- 2D optimization started'
      al=0.0
      angle(1)=al
      dl=touch(c,ih,nslt,nnh,edge,ioppbc,cell,ncell,ixyzhex,angle,rot,
     -  mintyp,i2dopt,cnew)
c     print *,'Initial touch=',dl,' i2dopt=',i2dopt
      ar=0.1
      angle(1)=ar
      dr=touch(c,ih,nslt,nnh,edge,ioppbc,cell,ncell,ixyzhex,angle,rot,
     -  mintyp,i2dopt,cnew)
      am=(al+ar)/2.0
      angle(1)=am
      dm=touch(c,ih,nslt,nnh,edge,ioppbc,cell,ncell,ixyzhex,angle,rot,
     -  mintyp,i2dopt,cnew)
      iter=0
c     print *,'al,am,ar=',al,am,ar
c     print *,'dl,dm,dr=',dl,dm,dr
      do while (abs(dl-dr) .gt. ftol)
        iter=iter+1
        if (dm .le. dl .and. dm .le. dr) then
c         Middle is the lowest
          if (dl .lt. dr) then
            ar=am
            am=(al+ar)/2.0
            dr=dm
          else
            al=am
            am=(al+ar)/2.0
            dl=dm
          end if
          angle(1)=am
          dm=touch(c,ih,nslt,nnh,edge,ioppbc,cell,ncell,ixyzhex,
     -      angle,rot,mintyp,i2dopt,cnew)
        else if (dl .le. dm .and. dl .le. dr) then
c         Left is the lowest
          d=-(am-al)
          ar=am
          dr=dm
          am=al
          dm=dl
          al=am+d
          angle(1)=al
          dl=touch(c,ih,nslt,nnh,edge,ioppbc,cell,ncell,ixyzhex,
     -      angle,rot,mintyp,i2dopt,cnew)
        else
c         Right is the lowest
          d=+(ar-am)
          al=am
          dl=dm
          am=ar
          dm=dr
          ar=am+d
          angle(1)=ar
          dr=touch(c,ih,nslt,nnh,edge,ioppbc,cell,ncell,ixyzhex,
     -      angle,rot,mintyp,i2dopt,cnew)
        end if
        if (mod(iter,05) .eq. 0) write (6,1000) iter,dm,abs(dl-dr),ftol
      end do
      return
1000  format(' 2D opt it',i5,' dm=',f9.5,' |dl-dr|=',f11.6,' tol=',f9.6)
      end
      subroutine fixup(rc,co,cn,n,aw)
      dimension rc(3,n),co(3,n),cn(3,n),aw(n)
c     The molecule co will be replaced by a molecule having the same
c     internal geometry as rc with the com's coinciding and the best
c     orientational overlap
      dimension como(3),a(3,3),b(3,3),orient(3,3)
c     Obtain  orientation of co
c     print *,'fixup n=',n
c     write (6,1002) co
c1002  format(' co=',/,(3f10.5))
      call cofms(co,como,n,aw)
      call trnsfr(a,rc,9)
      do i=1,3
        do j=1,3
          b(i,j)=co(i,j)-como(i)
        end do
      end do
      call ormat(orient,a,b,n,1)
      call rotate_c(rc,n,orient,cn,'FIXUP',5)
      call shiftmol(cn,n,como,cn,1.0)
      return
      end
      subroutine makewat(c,na,roh,ahohd,radtodeg)
      dimension c(3,na)
c     Create a standard water
      do i=1,na
        c(i,1)=0.0
        c(3,i)=0.0
      end do
      ahoh=ahohd/(radtodeg*2.0)
      xw=roh*cos(ahoh)
      yw=roh*sin(ahoh)
      c(1,2)=xw
      c(1,3)=xw
      c(2,2)=yw
      c(2,3)=-yw
      return
      end
      subroutine grelcd(cs,csr,natms,aw)
c#    MMC routine 017 lstmod: before 07/15/85
c*****compute the c.o.m. centered coordinates from cs into csr
      dimension cs(3,natms),csr(3,natms),aw(natms),cmcrd(3)
      call cofms(cs,cmcrd,natms,aw)
      do i=1,natms
        do k=1,3
          csr(k,i)=cs(k,i)-cmcrd(k)
        end do
      end do
      return
      end
      subroutine cofms(csa,rmass,natm,aw)
c#    MMC routine 021 lstmod: 06/18/93
c*****compute center of mass from global atomic coordinates
      dimension csa(3,natm),rmass(3),aw(natm)
c     print *,'COFMS natm=',natm
c     print *,'COFMS aw=',aw
c     write (6,1003) csa
c1003  format(' csa=',/,(3f10.5))
      rmx=0.
      rmy=0.
      rmz=0.
      wmol=0.
      do i=1,natm
        wmol=wmol+aw(i)
        rmx=rmx+aw(i)*csa(1,i)
        rmy=rmy+aw(i)*csa(2,i)
        rmz=rmz+aw(i)*csa(3,i)
      end do
      if (wmol .eq. 0.0) wmol=1.0
      rmass(1)=rmx/wmol
      rmass(2)=rmy/wmol
      rmass(3)=rmz/wmol
      return
      end
      subroutine ormat(orm,a,b,natoms,iverb)
c#    MMC routine 022 lstmod: 12/08/86
c     3-atom part originally written by P.K. Mehrotra.
C*****Compute the rotation matrix orm  by solving the following equation
c      b=orm.a
c     ++++++++++++++++++++++++++++++++++++++
c     a - coordinates of the molecule before rotation ( local system)
c     b - coordinates of the molecule after rotation (global syetm).
C         important - only rotation , no translation.
C     ++++++++++++++++++++++++++++++
c     It is assumed that the coordinates of the molecule are given
c     columnwise, i.e., the coordinates of the atom 1 constitute
c     the first column, coordinates of the atom 2 constitute the
c     the second column, etc.
C     the elements of a and b are preserved.
      dimension a(3,3),b(3,3),orm(3,3),d(3,3),e(3,3)
c     Choose the first atom as the origin
c     print *,'ORMAT iverb,natm=',iverb,natoms
      if (natoms .eq. 1) go to 40
c     Generate three specific orthogonal vectors in lab frame
      if (natoms .eq. 2) go to 20
      do i=1,3
        do k=1,3
          d(k,i)=a(k,i)-a(k,1)
          e(k,i)=b(k,i)-b(k,1)
        end do
      end do
      call vprod(d,2,3,1)
      call vprod(d,1,2,3)
      call vprod(e,2,3,1)
      call vprod(e,1,2,3)
c     Check for colinearity of the atoms
      dsum=0.0
      do k=1,3
        dsum=dsum+abs(d(k,1))
      end do
      if (dsum .gt. 1.e-6) go to 30
c     switch to two-atom algorithm
      if (iverb .gt. 0) write (6,1000)
c     Diatomic
20    dsum=0.0
      do k=1,3
        d(k,1)=a(k,2)-a(k,1)
        dsum=dsum+abs(d(k,1))
        e(k,1)=b(k,2)-b(k,1)
        d(k,2)=0.0
        e(k,2)=0.0
      end do
C     Create the second vector as perpendicular to the bond
c     If the two atoms coincide,generate unit matrix
      if (dsum .gt. 1.e-6) go to 25
      if (iverb .gt. 0) write (6,1002)
      go to 40
25    do k=1,3
        if (abs(d(k,1)) .le. 1.e-7) then
c         Zero component found
          d(k,2)=1.0
          go to 23
        end if
      end do
c     No zero component
      d(2,2)=1.0
      d(3,2)=-d(2,1)/d(3,1)
23    call vprod(d,1,2,3)
      do k=1,3
        if (abs(e(k,1)) .le. 1.e-7) then
c         Zero component found
          e(k,2)=1.0
          go to 26
        end if
      end do
c     No zero component
      e(2,2)=1.0
      e(3,2)=-e(2,1)/e(3,1)
26    call vprod(e,1,2,3)
30    call mnorm(d)
      call mnorm(e)
c     Now, d=orm*e, thus orm=d*inv(e) and
c     The inverse of an orthonormal matrix is its transpose
      do i=1,3
        do j=1,3
          sum=0.0
          do k=1,3
            sum=sum+e(i,k)*d(j,k)
          end do
          orm(i,j)=sum
        end do
      end do
      return
40    call unitmat(orm)
      return
1000  format(1x,20('-'),' NOTE: the first three solute atoms are on',
     -  ' the same line - two-atom algorithm will be used',/,
     -  22x,'check if solute atoms should be rearranged')
1002  format(1x,20('-'),' NOTE: the two atoms of a diatomic solute ',
     -  'coincide - unit matrix will be used as orientation matrix')
      end
      subroutine matprod(r1,r2,r3)
      dimension r1(3,3),r2(3,3),r3(3,3),r(3,3)
      do i=1,3
        do j=1,3
          rr=0.0
          do k=1,3
            rr=rr+r1(i,k)*r2(k,j)
          end do
          r(i,j)=rr
        end do
      end do
      call trnsfr(r3,r,9)
      return
      end
      subroutine dsmatvec(rot,din,dout)
      real*8 din(3),dout(3),d(3)
      dimension rot(3,3)
      do k=1,3
        rr=0.0
        do i=1,3
          rr=rr+din(i)*rot(k,i)
        end do
        d(k)=rr
      end do
      call trnsfrd(dout,d,3)
      return
      end
      subroutine vprod(r,i,j,k)
c#    MMC routine 025 lstmod: 02/06/86
c*****Computes the vector product of the columns i and j into k
      dimension r(3,3)
      r(1,k)=r(2,i)*r(3,j)-r(2,j)*r(3,i)
      r(2,k)=r(3,i)*r(1,j)-r(3,j)*r(1,i)
      r(3,k)=r(1,i)*r(2,j)-r(1,j)*r(2,i)
      return
      end
      subroutine vprd(a,b,c)
c#    MMC routine  61 lstmod: 02/06/86
c*****Computes the vector product a x b and saves it into c
      dimension a(3),b(3),c(3)
      c(1)=a(2)*b(3)-b(2)*a(3)
      c(2)=a(3)*b(1)-b(3)*a(1)
      c(3)=a(1)*b(2)-b(1)*a(2)
      return
      end
      subroutine dvprd(a,b,c)
c#    MMC routine 048  lstmod: 11/13/90
c*****Computes the vector product a x b and saves it into c
      implicit real*8(a-h,o-z)
      dimension a(3),b(3),c(3)
      c(1)=a(2)*b(3)-b(2)*a(3)
      c(2)=a(3)*b(1)-b(3)*a(1)
      c(3)=a(1)*b(2)-b(1)*a(2)
      return
      end
      subroutine mnorm(r)
C*****Normalizes the matrix r
      dimension r(3,3)
      do i=1,3
        rr=0.0
        do k=1,3
          rr=rr+r(k,i)**2
        end do
        rr=sqrt(rr)
        do k=1,3
          r(k,i)=r(k,i)/rr
        end do
      end do
      return
      end
      subroutine dmnorm(r)
c#    MMC routine 052 lstmod: 11/13/90
c*****Normalizes the matrix r
      real*8 r,rr
      dimension r(3,3)
      do i=1,3
        rr=0.0
        do k=1,3
          rr=rr+r(k,i)**2
        end do
        rr=sqrt(sngl(rr))
        do k=1,3
          r(k,i)=r(k,i)/rr
        end do
      end do
      return
      end
      subroutine indexit(index,ifirst,ilast,incr)
      dimension index(ilast)
      do i=ifirst,ilast
        index(i)=i+incr
      end do
      return
      end
      subroutine reverseindex(indexrev,indexorig,ifres,ifirst,ilast,max)
      dimension indexrev(max),indexorig(max),ifres(max)
      call zeroiti(indexrev,0,max)
      do i=ifirst,ilast
        indexrev(indexorig(ifres(i)))=i
      end do
      return
      end
      subroutine zeroit(a,n)
      dimension a(n)
      do k=1,n
        a(k)=0.0
      end do
      return
      end
      subroutine zeroitd(a,n)
      real*8 a(n)
      do k=1,n
        a(k)=0.0
      end do
      return
      end
      subroutine zeroiti(ia,i0,n)
      dimension ia(n)
      do k=i0+1,n
        ia(k)=0
      end do
      return
      end
      subroutine zeroiti2(ia,i0,n)
      integer*2 ia(n)
      do k=i0+1,n
        ia(k)=0
      end do
      return
      end
      subroutine angdistw(c1,c2,c3,roh1,roh2,rhh,ahoh)
c*****Calculate the angle c2-c1-c3 and distance c1-c2; c1-c3
      dimension c1(3),c2(3),c3(3)
      real*8 cosa,rroh1,rroh2,droh1,droh2
      rroh1=(c1(1)-c2(1))**2+(c1(2)-c2(2))**2+(c1(3)-c2(3))**2
      rroh2=(c1(1)-c3(1))**2+(c1(2)-c3(2))**2+(c1(3)-c3(3))**2
      rrhh=(c2(1)-c3(1))**2+(c2(2)-c3(2))**2+(c2(3)-c3(3))**2
      droh1=dsqrt(rroh1)
      droh2=dsqrt(rroh2)
      rhh=sqrt(rrhh)
      cosa=(rroh1+rroh2-rrhh)/(2.d0*droh1*droh2)
      ahoh=dacoscheck(cosa,ccc,1,6,'ANGDISTW')
      roh1=droh1
      roh2=droh2
      return
      end
      subroutine changeprot(resnam,resnam1,iaaconv)
c     if iaaconv=1 convert from 1-digit to 3 digit AA code
c     if iaaconv=2 convert from 3-digit to 1 digit AA code
      character*8 resnam
      character*1 aanames1,resnam1
      character*2 mmodtoamb
      character*3 aanames3
      common /atnamcon/ mmodtoamb(100),aanames1(58),aanames3(58),
     -  naanames,nnanames,nnammnames,nnames,ixwatnam
      inf=1
      inl=naanames+nnanames
      if (iaaconv .eq. 1) then
        resnam='***     '
        do i=inf,inl
          if (resnam1 .eq. aanames1(i)) then
            resnam(1:3)=aanames3(i)
            return
          end if
        end do
      else if (iaaconv .eq. 2) then
        resnam1='*'
        call leftadjustn(resnam,resnam,8)
        do i=inf,inl
          if (resnam(1:3) .eq. aanames3(i)) then
            resnam1=aanames1(i)
            return
          end if
        end do
      else
        print *,'PROGRAM ERROR: invalid iaaconv in changeprot=',iaaconv
      end if
      return
      end
      subroutine atnamtoatnum(atomnam,mmctype)
c     Determine atomic number from an atomname
      character*8 atomnam
      character*1 anam1(20)
      character* 132 line
      data anam1 /'H',3*' ','B','C','N','O','F',5*' ','P','S',
     -  3*' ','K'/
      line(1:5)=atomnam
      line(6:6)='X'
      ic=1
      call nextchar(line,ic,132)
      if (ic .le. 8) then
        do i=1,20
          if (atomnam(ic:ic) .eq. anam1(i)) then
             mmctype=i
             return
          end if
        end do
      end if
      mmctype=0
      return
      end
      subroutine nninit(nneig,nhbneig,ineig,nhneig,nnneig,ncneig,
     -  nsneig,npneig,nfirst,n,ihbinit,maxng)
      dimension nneig(n),ineig(maxng,n),nhbneig(n),nhneig(n),
     -  nnneig(n),ncneig(n),nsneig(n),npneig(n)
      if (ihbinit .eq. 1) then
        do i=nfirst,n
          call zeroiti(ineig(1,i),0,maxng)
          nhbneig(i)=0
        end do
      end if
      do i=nfirst,n
        nhneig(i)=0
        ncneig(i)=0
        nnneig(i)=0
        nsneig(i)=0
        npneig(i)=0
        nneig(i)=0
      end do
      return
      end
      subroutine nnlist(nslt,islvw,nslv,n,iatnum,ifchrg,c,nneig,nneiga,
     -  nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,line,irescol1,
     -  irescol2,inamcol1,inamcol2,index,nconfig,innlist,
     -  molresflag,hblimfac,angmin,ihbondcalc,indices,nbox,isegno,
     -  ixres,maxrepconf,nowarn,radtodeg,maxbox,maxng,maxrsd,maxrec)
      dimension nneig(n),ineig(maxng,n),iatnum(n),c(3,n),nhbneig(n),
     -  nneiga(n),nhneig(n),nnneig(n),ncneig(n),nsneig(n),npneig(n),
     -  molresflag(maxrsd),index(n),indices(maxbox,maxrec),nbox(maxrec),
     -  isegno(n),ixres(n),ifchrg(n)
      character* 132 line(maxrec)
      character*4 atnami
      character*8 resnami
c     Set up neighbour list
      character*4 namfcg
      common /connatdat/ ramax(99),ramax2(99),hlimfac,ianfg(99),
     -  namfcg(100),nrmw
      common /clonedat/ nclone,iaclnf(1000),iaclnl(1000),ncopcln(1000)
c     print *,'NNLIST n,nslt,islvw,innlist=',n,nslt,islvw,innlist
      if (innlist .gt. 0) then
        return
      else
        innlist=1
      end if
      do i=1,99
        ramax2(i)=ramax(i)**2
      end do
      call nninit(nneig,nhbneig,ineig,nhneig,nnneig,ncneig,
     -  nsneig,npneig,1,n,1,maxng)
c     Generate connectivity for solvents
      numsolv=(n-nslt)/nslv
c     print *,'NNLIST n,nslt,nslv,numsolv=',n,nslt,nslv,numsolv
      do is=1,numsolv
        call nnlist0o(nslt+(is-1)*nslv+1,nslt+is*nslv,iatnum,c,nneig,
     -    nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,line,
     -    irescol1,irescol2,inamcol1,inamcol2,index,maxng,hblimfac,
     -    maxrec)
      end do
      LEVTEST=0
      ntestclone=0
      nhb=nslt
      if (ihbondcalc .eq. 1) nhb=n
      if (nclone .eq. 0) then
        call nnlist0(1,nhb,nslt,islvw,iatnum,ifchrg,c,nneig,
     -    nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,line,
     -    irescol1,irescol2,inamcol1,inamcol2,index,maxng,
     -    hblimfac,angmin,ihbondcalc,indices,nbox,isegno,ifail,
     -    radtodeg,maxbox,maxrec,LEVTEST)
      else
        call nnlist0(1,iaclnf(1)-1,nslt,islvw,iatnum,ifchrg,c,nneig,
     -    nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,line,
     -    irescol1,irescol2,inamcol1,inamcol2,index,maxng,
     -    hblimfac,angmin,ihbondcalc,indices,nbox,isegno,ifail,
     -    radtodeg,maxbox,maxrec,LEVTEST)
        ifirst=iaclnf(1)
        ntestclone=ifirst-1
        do ic=1,nclone
c         Create list separately for the clones
          ilast=ifirst+iaclnl(ic)-iaclnf(ic)
          call nnlist0(ifirst,ilast,nslt,islvw,iatnum,ifchrg,c,nneig,
     -      nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,
     -      line,irescol1,irescol2,inamcol1,inamcol2,index,maxng,
     -      hblimfac,angmin,ihbondcalc,indices,nbox,
     -      isegno,ifail,radtodeg,maxbox,maxrec,LEVTEST)
c        Copy cloned nn info
         do id=2,ncopcln(ic)
           do ia=ifirst,ilast
             ianew=ia+(id-1)*(ilast-ifirst+1)
             nneig(ianew)=nneig(ia)
             nneiga(ianew)=nneiga(ia)
             nhbneig(ianew)=nhbneig(ia)
             nhneig(ianew)=nhneig(ia)
             nnneig(ianew)=nnneig(ia)
             nsneig(ianew)=nsneig(ia)
             npneig(ianew)=npneig(ia)
             call trnsfi(ineig(1,ianew),ineig(1,ia),maxng)
           end do
         end do
         ifirst=ifirst+ncopcln(ic)*(ilast-ifirst+1)
         ilast=ifirst-1
        end do
        if (ilast .lt. nslt)
     -    call nnlist0(ilast+1,nslt,nslt,islvw,iatnum,ifchrg,c,nneig,
     -      nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,
     -      line,irescol1,irescol2,inamcol1,inamcol2,index,maxng,
     -      hblimfac,angmin,ihbondcalc,indices,nbox,
     -      isegno,ifail,radtodeg,maxbox,maxrec,LEVTEST)
        nclone=0
      end if
      if (LEVTEST .gt. 0) then
c       Repeat for test
        ntest=nslt
        if (ntestclone .gt. 0) ntest=ntestclone
        print *,'NN comparison test  for ',ntest,' atoms'
        do i=1,ntest
          write (77,7811) i,(ineig(j,i),j=1,maxng)
        end do
        call nninit(nneig,nhbneig,ineig,nhneig,nnneig,ncneig,
     -    nsneig,npneig,1,ntest,1,maxng)
        call nnlist0o(1,ntest,iatnum,c,nneig,nhbneig,
     -    ineig,nhneig,nnneig,ncneig,nsneig,npneig,line,irescol1,
     -    irescol2,inamcol1,inamcol2,index,maxng,hblimfac,maxrec)
        do i=1,ntest
          write (78,7811) i,(ineig(j,i),j=1,maxng)
        end do
      end if
c     Save the pseudo-atom neighbours for the real atoms
      do i=1,n
        nneiga(i)=nneig(i)
      end do
c     Functional group search will not see the pseudo-atom neighbours
      do i=1,n
        if (iatnum(i) .ge. 88 .and. iatnum(i) .le. 90 .and.
     -      nneig(i) .gt. 0) then
c         Pseudo atom found
          nn=nneig(i)
          do in=1,nn
            ia=ineig(in,i)
            if (ia .lt. 88 .or. ia .gt. 90) then
c             Add i to the neighbour list of ia
              nneig(ia)=nneig(ia)+1
              ineig(nneig(ia),ia)=i
            end if
          end do
        end if
      end do
      nlim=n
      if (nslv .eq. 1) nlim=nslt
c     Check for unconnected atoms not already made a molecule
      if (nowarn .eq. 0) then
        nslvmsg=0
        do ia=1,nlim
          if (nneig(ia) .eq. 0 .and. molresflag(ixres(ia)) .lt. 2) then
            imol1=0
            if (ia .eq. 1) then
              if (isegno(ia) .ne. isegno(ia+1)) imol1=1
            else if (ia .eq. nlim) then
              if (isegno(ia) .ne. isegno(ia-1)) imol1=1
            else
              if (isegno(ia) .ne. isegno(ia-1) .and.
     -            isegno(ia) .ne. isegno(ia+1)) imol1=1
            end if
            if (imol1 .eq. 0 .and. ramax2(iatnum(ia)) .gt. 0.0) then
              if (nslvmsg .le. 25) then
                if (inamcol2 .ge. inamcol1) then
                  resnami='     '
                  resnami=line(index(ia))(irescol1:irescol2)
                  atnami=line(index(ia))(inamcol1:inamcol2)
                  if (resnami(1:3) .ne. 'HOH' .and.
     -                nconfig .le. maxrepconf)
     -              write (6,2003) ia,atnami,resnami,iatnum(ia)
                else
                  if (nconfig .le. maxrepconf)
     -              write (6,2002) ia,iatnum(ia)
                end if
                if (nslvmsg .eq. 25)
     -            print *,'Solvent related warnings are turned off'
              else
              end if
              if (ia .gt. nslt)nslvmsg=nslvmsg+1
            end if
          end if
        end do
        if (nslvmsg .gt. 25) write (6,2001) nslvmsg
      end if
      return
2001  format(' WARNING: A total of ',i7,' solvent atoms had no bonds')
2002  format(' WARNING: atom ',i6,' (atomic #=',i2,
     -  ') has no bonds at all')
2003  format(' WARNING: atom ',i6,' (',a4,1x,a6,', atomic #=',i2,
     -  ') has no bonds at all')
7811  format(i6,' in=',(20i6))
      end
      subroutine nnlist0(nfirst,n,nslt,islvw,iatnum,ifchrg,c,nneig,
     -  nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,line,
     -  irescol1,irescol2,inamcol1,inamcol2,index,maxng,
     -  hblimfac,angmin,ihbondcalc,indices,nbox,isegno,ifail,radtodeg,
     -  maxbox,maxrec,LEVTEST)
      dimension nneig(n),ineig(maxng,n),iatnum(n),ifchrg(n),c(3,n),
     -  nhbneig(n),nhneig(n),nnneig(n),ncneig(n),nsneig(n),
     -  npneig(n),index(n),indices(maxbox,maxrec),nbox(maxrec),isegno(n)
      common /connatdat/ ramax(99),ramax2(99),hlimfac,ianfg(99),
     -  namfcg(100),nrmw
      character* 132 line(maxrec)
c     print *,'NNL0 n,nslt,islvw,ihbondcalc=',n,nslt,islvw,ihbondcalc
      ifail=0
      if (n .lt. nfirst) return
      if (n .eq. 1) then
        nneig(1)=0
        nhbneig(1)=0
        return
      end if
      nn=0
      do ia=nfirst,n
        if (isegno(ia) .eq. -1) nn=nn+1
      end do
      if (nn .gt. 0 .or. ihbondcalc .eq. 1) then
c       LES structure, call nnlist00 with the whole range
        call nnlist00(nfirst,n,nslt,islvw,iatnum,ifchrg,c,nneig,nhbneig,
     -    ineig,nhneig,nnneig,ncneig,nsneig,npneig,line,irescol1,
     -    irescol2,inamcol1,inamcol2,index,maxng,hblimfac,angmin,
     -    indices,nbox,isegno,ifail,radtodeg,maxbox,maxrec,LEVTEST)
        if (ifail .gt. 0) go to 2000
        return
      else
c       Call the actual near neighbour search by segments
        isg=isegno(nfirst)
        ifat=nfirst
        ilat=nfirst
        do while (isg .le. isegno(n))
c         Find limits of the next segment
          do while (isegno(ilat) .eq. isg .and. ilat .lt. n)
            ilat=ilat+1
          end do
          if (isegno(ilat-1) .ne. isegno(ilat) .and. ilat .le. n)
     -       ilat=ilat-1
          if (ilat .lt. n) then
c           If segments are not contiguous, just call nnlist00 for
c           the whole range
            if (isegno(ilat+1) .ne. isegno(ilat)+1) then
              write (6,1000) ilat,isegno(ilat),ilat+1,isegno(ilat+1)
              call nninit(nneig,nhbneig,ineig,nhneig,nnneig,ncneig,
     -          nsneig,npneig,nfirst,n,1,maxng)
              call nnlist00(nfirst,n,nslt,islvw,iatnum,ifchrg,c,nneig,
     -          nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,line,
     -          irescol1,irescol2,inamcol1,inamcol2,index,maxng,
     -          hblimfac,angmin,indices,nbox,isegno,ifail,radtodeg,
     -          maxbox,maxrec,LEVTEST)
              if (ifail .gt. 0) go to 2000
              return
            end if
          end if
          isg=isg+1
          call nnlist00(ifat,ilat,nslt,islvw,iatnum,ifchrg,c,nneig,
     -      nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,
     -      line,irescol1,irescol2,inamcol1,inamcol2,index,maxng,
     -      hblimfac,angmin,indices,nbox,isegno,ifail,radtodeg,maxbox,
     -      maxrec,LEVTEST)
          ifat=ilat+1
          ilat=ilat+1
        end do
      end if
      if (ifail .eq. 0) return
2000  call nninit(nneig,nhbneig,ineig,nhneig,nnneig,ncneig,
     -  nsneig,npneig,nfirst,n,1,maxng)
      call nnlist0o(nfirst,n,iatnum,c,nneig,nhbneig,ineig,nhneig,nnneig,
     -  ncneig,nsneig,npneig,line,irescol1,irescol2,inamcol1,inamcol2,
     -  index,maxng,hblimfac,maxrec)
      return
1000  format(' Segments are not contiguous: isegno(',i5,')=',i4,
     -  ' isegno(',i5,')=',i4)
      end
      subroutine nnlist00(nfirst,n,nslt,islvw,iatnum,ifchrg,c,nneig,
     -  nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,line,
     -  irescol1,irescol2,inamcol1,inamcol2,index,maxng,hblimfac,angmin,
     -  indices,nbox,isegno,ifail,radtodeg,maxbox,maxrec,LEVTEST)
      dimension nneig(n),ineig(maxng,n),iatnum(n),ifchrg(n),c(3,n),
     -  nhbneig(n),nhneig(n),nnneig(n),ncneig(n),nsneig(n),
     -  npneig(n),index(n),indices(maxbox,maxrec),nbox(maxrec),isegno(n)
      common /connatdat/ ramax(99),ramax2(99),hlimfac,ianfg(99),
     -  namfcg(100),nrmw
      character* 132 line(maxrec)
      character*4 atnami,atnamj
      character*8 resnami,resnamj
      dimension nxyz(3),ix(3),xyzmin(3),xyzmax(3),centinp(3),
     -  nh12(4)
c     Set up neighbour list using linked cells
c     nhneig, ncneig,nnneig,nsneig,npneig:
c     Number of H, C, N, S, P neighbours, resp.
c     print *,'NNLIST00 nfirst,n,nslt,islvw=',nfirst,n,nslt,islvw
      ifail=0
      if (n .lt. nfirst) return
c     Find minimum and maximum atomic radius and extents of the molecule
      ra2max=ramax2(iatnum(1))
      ra2min=ra2max
      do i=nfirst,n
c       write (77,*) 'nnlist00 i,n,iatnum(i)=',i,n,iatnum(i)
        if (ra2min .gt. ramax2(iatnum(i))) ra2min=ramax2(iatnum(i))
        if (ra2max .lt. ramax2(iatnum(i))) ra2max=ramax2(iatnum(i))
      end do
      ramn=sqrt(ra2min)
      ramx=sqrt(ra2max)
      if (ramx .lt. 0.01) then
        if (nrmw .eq. 0)
     -    print *,'WARNING: no atomic number could be deduced'
        ramx=0.5
        nrmw=nrmw+1
      end if
      div=ramx*sqrt(hblimfac)+0.01
      call extension(c,nneig,0,nfirst,n,xyzmin,xyzmax,centinp,0,0,v)
      do k=1,3
        nxyz(k)=(xyzmax(k)-xyzmin(k))/div+1
      end do
      if (LEVTEST .gt. 0)
     -  write (88,1000) ramn,ramx,div,nx,nxy,nxyz,xyzmin,xyzmax
      ngrid=nxyz(1)*nxyz(2)*nxyz(3)
      do while (ngrid .gt. maxrec)
c       Increase gridsize to reduce the number of boxes under maxrec
        divo=div
        div=div*(float(ngrid)/float(maxrec))**(1.0/3.0) + 0.1
        print *,'Grid size increased from ',divo,' to ',div,
     -    ' - increase MAXREC to ',ngrid,' to avoid it'
        do k=1,3
          nxyz(k)=(xyzmax(k)-xyzmin(k))/div+1
        end do
        ngrid=nxyz(1)*nxyz(2)*nxyz(3)
      end do
      if (LEVTEST .gt. 0)
     -  write (88,1000) ramn,ramx,div,nx,nxy,nxyz,xyzmin,xyzmax
      call zeroiti(nbox,0,ngrid)
      nx=nxyz(1)
      nxy=nxyz(1)*nxyz(2)
      maxboxcount=0
      do i=nfirst,n
        if (isegno(i) .ne. -1) then
          do k=1,3
            ix(k)=(c(k,i)-xyzmin(k))/div+1
          end do
c         Save i into the box represented by the indices ix(1-3)
          indexi=ix(1)+nx*(ix(2)-1)+nxy*(ix(3)-1)
          if (LEVTEST .gt. 1) write (88,1001) i,indexi,ix
          nbox(indexi)=nbox(indexi)+1
          if (nbox(indexi) .le. maxbox) then
            indices(nbox(indexi),indexi)=i
          else
            print *,'Too many atoms in a box - ',
     -        'increase maxbox or MAXREC and recompile'
            print *,'Slow bond generator will be used for now'
            ifail=1
            return
          end if
        end if
      end do
c     Loop on the boxes
      do i1=1,nxyz(1)
        do i2=1,nxyz(2)
          do i3=1,nxyz(3)
            indexi=i1+nx*(i2-1)+nxy*(i3-1)
            ni=nbox(indexi)
            if (LEVTEST .gt. 2) write (88,1002) i1,i2,i3,indexi,ni
            if (ni .gt. 0) then
              do j1=max0(1,i1-1),i1
                do j2=max0(1,i2-1),min0(nxyz(2),i2+(i1-j1))
                  j3lim=i3
                  if (i1 .gt. j1 .or. i2. gt. j2) j3lim=j3lim+1
                  do j3=max0(1,i3-1),min0(j3lim,nxyz(3))
                    indexj=j1+nx*(j2-1)+nxy*(j3-1)
                    nj=nbox(indexj)
c                   ni, nj are the number of atoms in the box (i1,i2,i3) and
c                   (j1,j2,j3)
                    if (indexi .eq. indexj) then
                      ij=0
                    else
                      ij=1
                    end if
                    if (LEVTEST .gt. 2)
     -                write (88,1012) j1,j2,j3,indexj,nj
                    do jj=1,nj
                      j=indices(jj,indexj)
                      if (inamcol2 .ge. inamcol1) then
                        resnamj='     '
                        resnamj=line(index(j))(irescol1:irescol2)
                        atnamj=line(index(j))(inamcol1:inamcol2)
                      end if
                      ii1=1
                      if (ij .eq. 0) ii1=jj+1
                      do ii=ii1,ni
                        i=indices(ii,indexi)
                        numhyd=0
                        if (iatnum(j) .eq. 1) numhyd=1
                        if (iatnum(i) .eq. 1) numhyd=numhyd+1
                        if (numhyd .lt. 2 .and. ramax2(iatnum(i))*
     -                      ramax2(iatnum(j)) .gt. 0.0) then
c                         At most one hydrogen
                          r2=dist2(c(1,i),c(1,j))
                          rlm=amax1(ramax2(iatnum(i)),ramax2(iatnum(j)))
                          if (numhyd .eq. 1) rlm=rlm*hlimfac
                          if (r2 .le. rlm .and.
     -                        ifchrg(i)+ifchrg(j) .eq. 0) then
c                           Bond found. Bonds to electron, charge or lone pair
c                           are not saved in the 'real' atoms' list here.
                            if (i .le. nslt .or. j .le. nslt) then
c                             Solvent-solvent connectivity is already done
                              call savebond(i,j,iatnum,nneig,ineig,
     -                          nhbneig,nhneig,ncneig,nnneig,npneig,
     -                          nsneig,resnamj,atnamj,maxng,n,0,
     -                          inamcol1,inamcol2,LEVTEST)
                              resnami='     '
                              resnami=line(index(i))(irescol1:irescol2)
                              atnami=line(index(i))(inamcol1:inamcol2)
                              call savebond(j,i,iatnum,nneig,ineig,
     -                          nhbneig,nhneig,ncneig,nnneig,npneig,
     -                          nsneig,resnami,atnami,maxng,n,0,
     -                          inamcol1,inamcol2,LEVTEST)
                            end if
                          else if (numhyd .eq. 1) then
c                           No bond, but may be hydrogen bond
                            if (iatnum(i)*iatnum(j) .ne. 6 .and.
     -                          ifchrg(i)+ifchrg(j) .eq. 0) then
c                             No H-C or H-+
                              rlimhb=rlm*(hblimfac/hlimfac)
c                             slv-slv bond only allowed for water bridge calc
c??                           Hbond with C between slt-slv?? - removed!!
                              if (islvw .eq. 2 .or.
     -                            i .le. nslt .or. j .le. nslt)
     -                          call maybehbond(r2,i,j,nneig,nhbneig,
     -                            ineig,inamcol1,inamcol2,rlimhb,atnami,
     -                            resnami,n,maxng)
                            end if
                          else if (numhyd .eq. 0 .and. islvw .gt. 0)then
                            if (i .gt. nslt .and. ifchrg(j) .gt. 0 .or.
     -                          j .gt. nslt .and. ifchrg(i) .gt. 0) then
                              rlimhb=rlm*hblimfac
                              call maybehbond(r2,i,j,nneig,nhbneig,
     -                          ineig,inamcol1,inamcol2,rlimhb,atnami,
     -                          resnami,n,maxng)
c                        print *,'MAYBE H-+:',i,j,nhbneig(i),nhbneig(j)
c                        print *,'MAYBE H-+: r2=',r2,' rlimhb=',rlimhb
                            end if
                          end if
                        end if
                      end do
                    end do
                  end do
                end do
              end do
            end if
          end do
        end do
      end do
c     Now screen the H-bonds for the angle
      do ia=nfirst,n
        if (iatnum(ia) .eq. 1) then
c         Atom ia is always the H of the H bond
          nhbng=nhbneig(ia)
          do ja=1,nhbneig(ia)
            ihb=ineig(maxng+1-ja,ia)
            if (ihb .gt. 0) then
              if (nneig(ia) .ne. 1) print *,'WARNING: Hbond donor ',
     -          ia,' has more than one bond'
              ihbdel=0
              call checkhbclose(c,n,ia,ihb,'hydrogen bonded',15,ihbdel)
c             ihb0 is the heavy atom of the donor H
              ihb0=0
              nng=nneig(ia)
              do while (nng .gt. 0)
                ihb0=ineig(nng,ia)
                if (iatnum(ineig(nng,ia)) .eq. 1)  then
                  ihb0=ineig(nng,ia)
                  nng=0
                end if
                nng=nng-1
              end do
              if (ihb0 .gt. 0 .and. ihbdel .eq. 0) then
                call checkhbclose(c,n,ia,ihb0,
     -            'hydrogen bonded',15,ihbdel)
                call checkhbclose(c,n,ihb0,ihb,
     -            'hydrogen-bond donor bond',24,ihbdel)
              end if
              if (ihb0 .gt. 0 .and. ihbdel .eq. 0) then
                call angdistw(c(1,ia),c(1,ihb),c(1,ihb0),rHB,rb,rab,ang)
                ang=ang*radtodeg
              else
c               Hydrogen had no heavy atom bonded to it - discard
                ang=angmin-1.0
              end if
              if (ang .lt. angmin) then
c               Remove ihb from the HB list of ia
c               write (77,*) 'rHB,rb,rab=',rHB,rb,rab
                ineig(maxng+1-ja,ia)=0
c               Remove ia from the HB list of ihb
                nremia=0
                do ii=maxng+1-nhbneig(ihb),maxng
                  if (ineig(ii,ihb) .eq. ia) then
                    ineig(ii,ihb)=0
                    nremia=1
                  end if
                end do
                if (nremia .eq. 0) then
                  print *,'PROGRAM ERROR: atom ',ia,
     -            ' is not on the HB list of atom',ihb
                  write (6,*) '(trying to remove) ',ihb,' ihb:',
     -              (ineig(maxng-in+1,ihb),in=1,nhbneig(ihb))
                end if
              end if
            end if
          end do
        else if (ifchrg(ia) .gt. 0 .and. islvw .gt. 0) then
c         Cation - only H-bonds to water oxygen
          nhbng=nhbneig(ia)
          do ja=1,nhbneig(ia)
            ihb=ineig(maxng+1-ja,ia)
            if (ihb .gt. 0) then
c             Not dropped yet
              idrop=0
              if (iatnum(ihb) .eq. 1) then
                idrop=1
              else
                if (ihb .le. nslt) print *,'PROGRAM ERROR: atom ',ia,
     -            ' is a cation but is ','H-bonded to a non-solvent'
                if (iatnum(ihb) .ne. 8) print *,'PROGRAM ERROR: atom ',
     -            ia,' is H-bonded to a cation but is not an oxygen'
                nnh=0
                do in=1,nneig(ihb)
                  jn=ineig(in,ihb)
                  if (iatnum(jn) .eq. 1) then
                    nnh=nnh+1
                    nh12(nnh)=jn
                  end if
                end do
                if (nnh .ne. 2) print *,'WARNING: water oxygen ',
     -            ihb,' has ',nnh,' hydrogens bonded to it'
c               write (77,*) 'ia,ihb,nh12=',ia,ihb,nh12
                call angdistw(c(1,ihb),c(1,ia),c(1,nh12(1)),rHB,rb,
     -            rab,ang)
                ang=ang*radtodeg
                if (ang .lt. angmin) then
                  call angdistw(c(1,ihb),c(1,ia),c(1,nh12(2)),rHB,rb,
     -              rab,ang)
                  ang=ang*radtodeg
                end if
                if (ang .lt. angmin) idrop=2
              end if
              if (idrop .gt. 0) then
C               Drop
                print *,'DROP cation bond ',ia,' - ',ihb,
     -            ' idrop=',idrop,' ang=',ang
                ineig(maxng+1-ja,ia)=0
c               Remove ia from the HB list of ihb
                nremia=0
                do ii=maxng+1-nhbneig(ihb),maxng
                  if (ineig(ii,ihb) .eq. ia) then
                    ineig(ii,ihb)=0
                    nremia=1
                  end if
                end do
                if (nremia .eq. 0) then
                  print *,'PROGRAM ERROR: atom ',ia,
     -            ' is not on the HB list of atom',ihb
                  write (6,*) '(trying to remove) ',ihb,' ihb:',
     -              (ineig(maxng-in+1,ihb),in=1,nhbneig(ihb))
                end if
              end if
            end if
          end do
        end if
      end do
c     Now condense the list to fill in the zeros
      do ia=nfirst,n
        ndel=0
        do ja=1,nhbneig(ia)
          if (ineig(maxng-ja+1,ia) .eq. 0) then
            ndel=ndel+1
          else
            ineig(maxng-ja+1+ndel,ia)=ineig(maxng-ja+1,ia)
          end if
        end do
        nhbneig(ia)=nhbneig(ia)-ndel
      end do
      call checkhblist(n,ineig,nhbneig,maxng)
      return
1000  format(' NNLIST00 ramn,ramx,div=',3f7.2,' nx,nxy=',2i8,
     -  ' nxyz=',3i4,/,' xyzmin=',3f10.5,' xyzmax=',3f10.5)
1001  format(' NNLIST00 i,indexi=',2i6,' ix=',3i4)
1002  format(' NNLIST00 i1,2,3=',3i4,' indexi=',i6,' ni=',i4)
1012  format(' NNLIST00 j1,2,3=',3i4,' indexj=',i6,' nj=',i4)
      end
      subroutine nnlisthph_sltb(n,ianchor2,iselfanc,indexa,iatnum,nneig,
     -  n14neig,nhbneig,ineig,c,rhphmax,isltb,isegno,nosamseg,indices,
     -  nbox,ifail,maxng,maxbox,maxrec)
      dimension indexa(n),iatnum(n),nneig(n),n14neig(n),nhbneig(n),
     -  ineig(maxng,n),c(3,n),isegno(n),indices(maxbox,maxrec),
     -  nbox(maxrec)
      dimension nxyz(3),ix(3),xyzmin(3),xyzmax(3),centinp(3)
c     Set up hydrophobic bond list using linked cells
c     print *,'NNLISTHPH_SLTB n,nosamseg,iselfanc,rhphmax=',
c    -  n,nosamseg,iselfanc,rhphmax
c     indexa(ia)=1: Anchor atom
c     indexa(ia)=-1: Non-anchor atom, but qualifies for HPH bond/salt bridge
      LEVTEST=0
      rhphmax2=rhphmax**2
      ifail=0
      call extension(c,nneig,0,1,n,xyzmin,xyzmax,centinp,0,1,v)
      div=rhphmax+0.001
      do k=1,3
        nxyz(k)=(xyzmax(k)-xyzmin(k))/div+1
      end do
      if (LEVTEST .gt. 0)
     -  write (88,1000) rhphmax,div,nx,nxy,nxyz,xyzmin,xyzmax
      ngrid=nxyz(1)*nxyz(2)*nxyz(3)
      do while (ngrid .gt. maxrec)
c       Increase gridsize to reduce the number of boxes under maxrec
        divo=div
        div=div*(float(ngrid)/float(maxrec))**(1.0/3.0) + 0.1
        print *,'Grid size increased from ',divo,' to ',div,
     -    ' - increase MAXREC to ',ngrid,' to avoid it'
        do k=1,3
          nxyz(k)=(xyzmax(k)-xyzmin(k))/div+1
        end do
        ngrid=nxyz(1)*nxyz(2)*nxyz(3)
      end do
      if (LEVTEST .gt. 0)
     -  write (88,1000) rhphmax,div,nx,nxy,nxyz,xyzmin,xyzmax
      call zeroiti(nbox,0,ngrid)
      nx=nxyz(1)
      nxy=nxyz(1)*nxyz(2)
      maxboxcount=0
      do ia=1,n
        if (indexa (ia) .ne. 0) then
          do k=1,3
            ix(k)=(c(k,ia)-xyzmin(k))/div+1
          end do
c         Save ia into the box represented by the indices ix(1-3)
          indexi=ix(1)+nx*(ix(2)-1)+nxy*(ix(3)-1)
          if (LEVTEST .gt. 1) write (88,1001) ia,indexi,ix
          nbox(indexi)=nbox(indexi)+1
          if (nbox(indexi) .le. maxbox) then
            indices(nbox(indexi),indexi)=ia
          else
            print *,'Too many atoms in a box - ',
     -        'increase maxbox or MAXREC and recompile'
            print *,'Slow bond generator will be used for now'
            ifail=1
            return
          end if
        end if
      end do
c     All hydrophobic carbons are indexed in the grid
c     Loop on the boxes
      call zeroiti(nneig,0,n)
      call zeroiti(nhbneig,0,n)
      do i1=1,nxyz(1)
        do i2=1,nxyz(2)
          do i3=1,nxyz(3)
            indexi=i1+nx*(i2-1)+nxy*(i3-1)
            ni=nbox(indexi)
            if (LEVTEST .gt. 2) write (88,1002) i1,i2,i3,indexi,ni
            if (ni .gt. 0) then
              do j1=max0(1,i1-1),i1
                do j2=max0(1,i2-1),min0(nxyz(2),i2+(i1-j1))
                  j3lim=i3
                  if (i1 .gt. j1 .or. i2. gt. j2) j3lim=j3lim+1
                  do j3=max0(1,i3-1),min0(j3lim,nxyz(3))
                    indexj=j1+nx*(j2-1)+nxy*(j3-1)
                    nj=nbox(indexj)
c                   ni, nj are the number of atoms in the box (i1,i2,i3) and
c                   (j1,j2,j3)
                    if (indexi .eq. indexj) then
                      ij=0
                    else
                      ij=1
                    end if
                    if (LEVTEST .gt. 2)
     -                write (88,1003) j1,j2,j3,indexj,nj
                    do jj=1,nj
                      ja=indices(jj,indexj)
                      ii1=1
                      if (ij .eq. 0) ii1=jj+1
                      do ii=ii1,ni
                        ia=indices(ii,indexi)
                        idoit=0
                        if (indexa(ia) .gt. 0 .and.
     -                      indexa(ja) .gt. 0) then
                          if (iselfanc .eq. 1) idoit=1
                        else if (indexa(ia)*indexa(ja) .lt. 0) then
                          if (ianchor2 .eq. 0) idoit=1
                        end if
                        if (nosamseg .eq. 1 .and.
     -                      isegno(ia) .eq. isegno(ja)) idoit=0
                        if (isltb .eq. 2) then
c                         Salt bridge - exclude carbons
                          if (idoit .eq. 1) then
                            if (iatnum(ia) .eq. 6 .or.
     -                          iatnum(ja) .eq. 6) idoit=0
                          end if
                        end if
                        if (idoit .eq. 1) then
c                         Make sure ia and ja far enough apart in topology
                          do in=1,n14neig(ia)
                            if (ja .eq. ineig(in,ia)) idoit=0
                          end do
c                         write (77,7211) ia,ja,idoit,
c    -                      (ineig(in,ia),in=1,n14neig(ia))
c7211                      format(' ia,ja,idoit=',3i5,' in(ia)=',6i5)
                        end if
                        if (idoit .eq. 1) then
                          r2=dist2(c(1,ia),c(1,ja))
                          if (r2 .le. rhphmax2) then
c                           Bond found
                            if (nhbneig(ia) .eq. maxng .or.
     -                          nhbneig(ia) .eq. maxng) then
                              write (6,2000) maxng
                              ifail=1
                              return
                            else
                              nhbneig(ia)=nhbneig(ia)+1
                              ineig(maxng-nhbneig(ia)+1,ia)=ja
                              nhbneig(ja)=nhbneig(ja)+1
                              ineig(maxng-nhbneig(ja)+1,ja)=ia
                            end if
                          end if
                        end if
                      end do
                    end do
                  end do
                end do
              end do
            end if
          end do
        end do
      end do
      if (LEVTEST .gt. 0) then
        do ia=1,n
          if (nhbneig(ia) .gt. 0) then
            write (88,1004) ia,(ineig(maxng-ja+1,ia),ja=1,nhbneig(ia))
          end if
        end do
      end if
      return
1000  format(' NNLISTHPH rhphmax,div=',2f10.5,' nx,nxy=',2i4,
     -  ' nxyz=',3i4,/,' xyzmin=',3f10.5,' xyzmax=',3f10.5)
1001  format(' NNLISTHPH i,indexi=',2i6,' ix=',3i4)
1002  format(' NNLISTHPH i1,2,3=',3i4,' indexi=',i6,' ni=',i4)
1003  format(' NNLISTHPH j1,2,3=',3i4,' indexj=',i6,' nj=',i4)
1004  format(' NNLISTHPH ia=',i4,' nhblist:',100i4)
2000  format(' ERROR: Maximum number of hydrophobic neighbors (',i3,
     -  ') is exceeded')
      end
      subroutine maybehbond(r2,i,j,nneig,nhbneig,ineig,inamcol1,
     -  inamcol2,rlimhb,atnami,resnami,n,maxng)
      dimension nneig(n),nhbneig(n),ineig(maxng,n)
      character*4 atnami
      character*8 resnami
      if (r2 .lt. rlimhb) then
        maxngij=max0(nneig(i)+nhbneig(i),nneig(j)+nhbneig(j))
        if (maxngij .lt. maxng) then
c         Hydrogen bond found
          ineig(maxng-nhbneig(i),i)=j
          nhbneig(i)=nhbneig(i)+1
          ineig(maxng-nhbneig(j),j)=i
          nhbneig(j)=nhbneig(j)+1
        else
          if (inamcol2 .lt. inamcol1) then
            write (6,2000) i,maxng
          else
             write (6,2001) i,atnami,resnami,maxng
          end if
          write (6,2002) maxngij
        end if
      end if
      return
2000  format(' ERROR: atom',i6,' has more than ',i2,' neighbours',
     -  ' and hydrogen bonds')
2001  format(' ERROR: atom',i6,' (',a4,a6,') has more than ',i2,
     -  ' neighbours and hydrogen bonds')
2002  format(' - redimension the program with more than ',i3,
     -  ' neighbours')
      end
      subroutine checkhbclose(c,n,i1,i2,label,llabel,ihbdel)
      dimension c(3,n)
      character*(*) label
      dij2=dist2(c(1,i1),c(1,i2))
      if (dij2 .lt. 0.5) then
        if (dij2 .lt. 0.001) then
          write (6,1000) 'ERROR',i1,i2,label(1:llabel),sqrt(dij2)
          ihbdel=1
        else
          write (6,1000) 'WARNING',i1,i2,label(1:llabel),sqrt(dij2),
     -      ' - hydrogen bond is deleted'
        end if
      end if
      return
1000  format(1x,a,': atoms ',i6,' and ',i6,' are listed as ',a,/,
     -  ' but are only',f8.5,' A apart',a)
      end
      subroutine nnlistsim(nfirst,n,c,nneig,ineig,indices,nbox,
     -  rcut,ifail,maxng,nnlistlen,maxbox,maxrec,LEVTEST)
      dimension nneig(n),ineig(maxng,nnlistlen),c(3,n),
     -  indices(maxbox,maxrec),nbox(maxrec)
      dimension nxyz(3),ix(3),xyzmin(3),xyzmax(3),centinp(3)
c     Set up neighbour list using linked cells
c     print *,'NNLS maxng,nnlistlen,maxbox=',maxng,nnlistlen,maxbox
      if (n .gt. nnlistlen) then
        print *,'Redimension the program with maxat > ',10*n
        ifail=1
        return
      end if
      div=rcut+0.1
      rcut2=rcut**2
      ifail=0
      if (n .lt. nfirst) return
      call extension(c,nneig,0,nfirst,n,xyzmin,xyzmax,centinp,0,0,v)
      call zeroiti(nneig,0,n)
      do k=1,3
        nxyz(k)=(xyzmax(k)-xyzmin(k))/div+1
      end do
      nx=nxyz(1)
      nxy=nxyz(1)*nxyz(2)
      if (LEVTEST .gt. 0)
     -  write (88,1000) div,nx,nxy,nxyz,xyzmin,xyzmax
      ngrid=nxyz(1)*nxyz(2)*nxyz(3)
      do while (ngrid .gt. maxrec)
c       Increase gridsize to reduce the number of boxes under maxrec
        divo=div
        div=div*(float(ngrid)/float(maxrec))**(1.0/3.0) + 0.1
        print *,'Grid size increased from ',divo,' to ',div,
     -    ' - increase maxrec to ',ngrid,' to avoid it'
        do k=1,3
          nxyz(k)=(xyzmax(k)-xyzmin(k))/div+1
        end do
        ngrid=nxyz(1)*nxyz(2)*nxyz(3)
      end do
      nx=nxyz(1)
      nxy=nxyz(1)*nxyz(2)
      if (LEVTEST .gt. 0)
     -  write (88,1000) div,nx,nxy,nxyz,xyzmin,xyzmax
      call zeroiti(nbox,0,ngrid)
      nboxmax=0
      do i=nfirst,n
         do k=1,3
           ix(k)=(c(k,i)-xyzmin(k))/div+1
         end do
c        Save i into the box represented by the indices ix(1-3)
         indexi=ix(1)+nx*(ix(2)-1)+nxy*(ix(3)-1)
         if (LEVTEST .gt. 1) write (88,1001) i,indexi,ix
         nbox(indexi)=nbox(indexi)+1
         if (nboxmax .lt. nbox(indexi)) nboxmax=nbox(indexi)
         if (nbox(indexi) .le. maxbox) then
           indices(nbox(indexi),indexi)=i
         else
           ifail=1
         end if
      end do
c     print *,'nboxmax=',nboxmax
      if (ifail .gt. 0) then
        print *,'Too many atoms in a box - ',
     -    'increase maxbox or MAXREC and recompile'
        return
      end if
c     Loop on the boxes
      do i1=1,nxyz(1)
        do i2=1,nxyz(2)
          do i3=1,nxyz(3)
            indexi=i1+nx*(i2-1)+nxy*(i3-1)
            ni=nbox(indexi)
            if (LEVTEST .gt. 2) write (88,1002) i1,i2,i3,indexi,ni
            if (ni .gt. 0) then
              do j1=max0(1,i1-1),i1
                do j2=max0(1,i2-1),min0(nxyz(2),i2+(i1-j1))
                  j3lim=i3
                  if (i1 .gt. j1 .or. i2. gt. j2) j3lim=j3lim+1
                  do j3=max0(1,i3-1),min0(j3lim,nxyz(3))
                    indexj=j1+nx*(j2-1)+nxy*(j3-1)
                    nj=nbox(indexj)
c                   ni, nj are the number of atoms in the box (i1,i2,i3) and
c                   (j1,j2,j3)
                    if (i1 .eq. j1 .and. i2 .eq. j2 .and.
     -                  i3 .eq. j3) then
                      ij=0
                    else
                      ij=1
                    end if
                    if (LEVTEST .gt. 2)
     -                write (88,1012) j1,j2,j3,indexj,nj
                    do jj=1,nj
                      j=indices(jj,indexj)
                      ii1=1
                      if (ij .eq. 0) ii1=jj+1
                      do ii=ii1,ni
                        i=indices(ii,indexi)
                        r2=dist2(c(1,i),c(1,j))
                        if (r2 .le. rcut2) then
c                         Bond found.
                          if (nneig(i) .lt. maxng .and.
     -                        nneig(j) .lt. maxng) then
                          nneig(i)=nneig(i)+1
                          ineig(nneig(i),i)=j
                          nneig(j)=nneig(j)+1
                          ineig(nneig(j),j)=i
                          else
                            print *,'Redimension the program for more',
     -                        ' neighbors in nnlistsim'
                            ifail=1
                            return
                          end if
                        end if
                      end do
                    end do
                  end do
                end do
              end do
            end if
          end do
        end do
      end do
      maxnn=0
      do i=nfirst,n
        if (nneig(i) .gt. maxnn) maxnn=nneig(i)
      end do
c     print *,'maxnn=',maxnn
      return
1000  format(' NNLISTSIM div=',f10.5,' nx,nxy=',2i4,
     -  ' nxyz=',3i4,/,' xyzmin=',3f10.5,' xyzmax=',3f10.5)
1001  format(' NNLISTSIM i,indexi=',2i6,' ix=',3i4)
1002  format(' NNLISTSIM i1,2,3=',3i4,' indexi=',i6,' ni=',i4)
1012  format(' NNLISTSIM j1,2,3=',3i4,' indexj=',i6,' nj=',i4)
      end
      subroutine decidebondcut(ian1,ian2,rlim)
      common /connatdat/ ramax(99),ramax2(99),hlimfac,ianfg(99),
     -  namfcg(100),nrmw
      rlim=amax1(ramax2(ian1),ramax2(ian2))
      if (ian1 .eq. 1 .or. ian2 .eq. 1) rlim=rlim*hlimfac
      return
      end
      subroutine savebond(i,j,iatnum,nneig,ineig,nhbneig,nhneig,
     -  ncneig,nnneig,npneig,nsneig,resnamj,atnamj,maxng,n,nosort,
     -  inamcol1,inamcol2,LEVTEST)
      dimension nneig(n),ineig(maxng,n),iatnum(n),nhbneig(n),
     -  nhneig(n),nnneig(n),ncneig(n),nsneig(n),npneig(n)
      character*4 atnamj
      character*8 resnamj
c     Save atom i as the neighbor of atom j
      if (LEVTEST .gt. 0) write (88,*) 'SAVEBOND i,j,=',i,j
      if (iatnum(j) .ge. 88 .and. iatnum(j) .le. 90 .or.
     -     iatnum(i) .lt. 88 .or. iatnum(i) .gt. 90) then
         maxngij=max0(nneig(i)+nhbneig(i),nneig(j)+nhbneig(j))
        if (maxngij .lt. maxng) then
          if (nneig(j) .gt. 0 .and. nosort .eq. 0) then
c           Keep the neighbor list sorted
            if (i .gt. ineig(nneig(j),j)) then
              ineig(nneig(j)+1,j)=i
            else
              nnj=nneig(j)
              do inn=1,nnj
                in=nnj-inn+1
                if (i .gt. ineig(in,j)) go to 11
              end do
              in=0
11            in0=in+1
              do inn=in0,nnj
                in=nnj-inn+in0
                ineig(in+1,j)=ineig(in,j)
              end do
              ineig(in0,j)=i
            end if
          else
            ineig(nneig(j)+1,j)=i
          end if
          nneig(j)=nneig(j)+1
          if (iatnum(i) .eq. 1) nhneig(j)=nhneig(j)+1
          if (iatnum(i) .eq. 6) ncneig(j)=ncneig(j)+1
          if (iatnum(i) .eq. 7) nnneig(j)=nnneig(j)+1
          if (iatnum(i) .eq. 16) nsneig(j)=nsneig(i)+1
          if (iatnum(i) .eq. 15) npneig(j)=npneig(i)+1
        else
          if (inamcol2 .ge. inamcol1) then
            write (6,2001) j,atnamj,resnamj,maxng
          else
            write (6,2000) j,maxng
          end if
          write (6,2002) maxngij
        end if
      end if
      return
2000  format(' ERROR: atom',i6,' has more than ',i2,' neighbours',
     -  ' and hydrogen bonds')
2001  format(' ERROR: atom',i6,' (',a4,a6,') has more than ',i2,
     -  ' neighbours and hydrogen bonds')
2002  format(' - redimension the program with more than ',i3,
     -  ' neighbours')
      end
      subroutine nnlistslv(nfirst,n,iatnum,c,nneig,nhneig,ineig,maxng)
      dimension nneig(n),nhneig(n),ineig(maxng,n),iatnum(n),c(3,n)
      call zeroiti(nneig,nfirst-1,n)
      do i=nfirst,n
        do j=i+1,n
          r2=dist2(c(1,i),c(1,j))
          call decidebondcut(iatnum(i),iatnum(j),rlim)
          if (r2 .le. rlim .and. iatnum(i)+iatnum(j) .gt. 2) then
            nneig(i)=nneig(i)+1
            nneig(j)=nneig(j)+1
            ineig(nneig(i),i)=j
            ineig(nneig(j),j)=i
            if (iatnum(i) .eq. 1) nhneig(j)=nhneig(j)+1
            if (iatnum(j) .eq. 1) nhneig(i)=nhneig(i)+1
          end if
        end do
      end do
      return
      end
      subroutine nnlist0o(nfirst,n,iatnum,c,nneig,nhbneig,ineig,nhneig,
     -  nnneig,ncneig,nsneig,npneig,line,irescol1,irescol2,inamcol1,
     -  inamcol2,index,maxng,hblimfac,maxrec)
      dimension nneig(n),ineig(maxng,n),iatnum(n),c(3,n),nhbneig(n),
     -  nhneig(n),nnneig(n),ncneig(n),nsneig(n),npneig(n),index(n)
      common /connatdat/ ramax(99),ramax2(99),hlimfac,ianfg(99),
     -  namfcg(100),nrmw
      character* 132 line(maxrec)
      character*4 atnami
      character*8 resnami
c     Set up neighbour list using the trivial algorithm
c     nhneig, ncneig,nnneig,nsneig,npneig:
c     Number of H, C, N, S, P neighbours, resp.
      if (n .eq. nfirst) return
      do i=nfirst,n
        if (inamcol2 .ge. inamcol1) then
          resnami='     '
          resnami=line(index(i))(irescol1:irescol2)
          atnami=line(index(i))(inamcol1:inamcol2)
        end if
        j1=i+1
c       write (77,7711) i,iatnum(i),ramax(iatnum(i)),ramax2(iatnum(i))
c7711    format(i5,' iano=',i2,' ramax,2=',2f10.5)
        do j=j1,n
          r2=dist2(c(1,i),c(1,j))
          call decidebondcut(iatnum(i),iatnum(j),rlim)
          if (r2 .le. rlim .and. iatnum(i)+iatnum(j) .gt. 2 .and.
     -        ramax2(iatnum(i))*ramax2(iatnum(j)) .gt. 0.0) then
c           Bond found. Bonds to electron, charge or lone pair are not
c           saved in the 'real' atoms' list here.
            call savebond(j,i,iatnum,nneig,ineig,nhbneig,nhneig,ncneig,
     -        nnneig,npneig,nsneig,resnami,atnami,maxng,n,1,
     -        inamcol1,inamcol2,0)
            call savebond(i,j,iatnum,nneig,ineig,nhbneig,nhneig,ncneig,
     -        nnneig,npneig,nsneig,resnami,atnami,maxng,n,1,
     -        inamcol1,inamcol2,0)
          else if (iatnum(i)  .eq. 1 .and. iatnum(j) .gt. 1 .and.
     -             iatnum(j) .ne. 6 .or.
     -             iatnum(j)  .eq. 1 .and. iatnum(i) .gt. 1 .and.
     -             iatnum(i) .ne. 6 )  then
c           No bond, check if hydrogen bond
            if (r2 .lt. rlim*(hblimfac/hlimfac)) then
              if (max0(nneig(i)+nhbneig(i),nneig(j)+nhbneig(j)) .lt.
     -            maxng) then
c               Hydrogen bond found
                ineig(maxng-nhbneig(i),i)=j
                nhbneig(i)=nhbneig(i)+1
                ineig(maxng-nhbneig(j),j)=i
                nhbneig(j)=nhbneig(j)+1
              else
                if (inamcol2 .lt. inamcol1)
     -            write (6,2000) i,maxng
                if (inamcol2 .ge. inamcol1)
     -            write (6,2001) i,atnami,resnami,maxng
                write (6,2002)
              end if
            end if
          end if
        end do
      end do
      return
2000  format(' ERROR: atom',i6,' has more than ',i2,' neighbours',
     -  ' and hydrogen bonds')
2001  format(' ERROR: atom',i6,' (',a4,a6,') has more than ',i2,
     -  ' neighbours and hydrogen bonds')
2002  format(' - redimension the program')
      end
      subroutine bondcheck(iout,nfirst,n,iatnum,nneig,ineig,maxng,c,
     -  maxdist,line,irescol1,irescol2,inamcol1,inamcol2,index,rlim,
     -  nerr,maxrec)
      dimension nneig(n),ineig(maxng,n),c(3,n),iatnum(n),index(n),
     -  rlim(maxng)
      character* 132 line(maxrec)
      character*2 iatnm2
      common /atnam/ aw(99),nval(99),nvalmax(99),mmofan(99),
     -  mmatno(64),iatnm2(99)
c     Check for atoms exceeding their valence
      nerr=0
      nvalence=-1
      do i=nfirst,n
        if (iatnum(i) .gt. 0) nvalence=nval(iatnum(i))
        if (nneig(i) .gt. nvalence .and. nvalence .gt. 0) then
          do jj=1,nneig(i)
            j=ineig(jj,i)
            call decidebondcut(iatnum(i),iatnum(j),rlim(jj))
            rlim(jj)=sqrt(rlim(jj))
          end do
          write (iout,1000) i,iatnm2(iatnum(i)),
     -      line(index(i))(irescol1:irescol2),
     -      line(index(i))(inamcol1:inamcol2),nvalence,
     -      (ineig(j,i),line(index(ineig(j,i)))(irescol1:irescol2),
     -      line(index(ineig(j,i)))(inamcol1:inamcol2),
     -      sqrt(dist2(c(1,i),c(1,ineig(j,i)))),rlim(j),j=1,nneig(i))
          nerr=nerr+1
        end if
      end do
c     Check for bonded atoms far apart
      do i=nfirst,n
        do jj=1,nneig(i)
          j=ineig(jj,i)
          if (iabs(i-j) .gt. maxdist .and. i .lt. j .and.
     -        (iatnum(i) .ne. 32 .or. iatnum(j) .ne. 32)) then
            write (iout,1001) i,line(index(i))(irescol1:irescol2),
     -        line(index(i))(inamcol1:inamcol2),
     -        j,line(index(j))(irescol1:irescol2),
     -        line(index(j))(inamcol1:inamcol2),maxdist
            nerr=nerr+1
          end if
        end do
      end do
      return
1000  format(' Atom',i7,1x,a2,' (',a4,1x,a4,') has more than',i2,
     -  ' bonds:',/,('   Bond to',i6,' (',a4,1x,a4,') d=',f4.2,
     -  ' A (threshold=',f4.2,' A)'))
1001  format(' Bond exists between atoms',i6,' (',a4,1x,a4,') and ',
     -  i6,' (',a4,1x,a4,')',/,' but they are more than ',i4,
     -  ' atoms apart')
      end
      subroutine contactlist(iout,nslt,n,iatnum,c,line,irescol1,
     -  irescol2,inamcol1,inamcol2,index,ctlimfac,bondminfac,
     -  isltonly,naslv,nneig,ineig,isegno,ioppbc,cell,ncell,edge,
     -  ixyzhex,molsltlim,nmolslt,nerr,maxng,maxrec)
      character* 132 line(maxrec)
      dimension iatnum(n),c(3,n),index(n),nneig(n),ineig(maxng,n),
     -  isegno(n),cell(3,ncell),edge(3),ixyzhex(3),molsltlim(3,nmolslt)
      common /connatdat/ ramax(99),ramax2(99),hlimfac,ianfg(99),
     -  namfcg(100),nrmw
      character*2 iatnm2
      common /atnam/ aw(99),nval(99),nvalmax(99),mmofan(99),
     -  mmatno(64),iatnm2(99)
      dimension rij(3)
      character*4 pbclab
      character*4 atnami
      character*8 resnami
      dimension rpbc(3)
c     Check solute topology
      nbshort=0
      rminshort=1000.0
      nerr=0
      do i=1,nslt
c       Check bonds if they are too short
        if ((iatnum(i) .lt. 88 .or. iatnum(i) .gt. 90)
     -      .and. isegno(i) .ge. 0) then
          if (inamcol2 .ge. inamcol1) then
            resnami='     '
            resnami=line(index(i))(irescol1:irescol2)
            atnami=line(index(i))(inamcol1:inamcol2)
          end if
          do jj=1,nneig(i)
            j=ineig(jj,i)
            if (j .gt. i) then
              r2=dist2(c(1,i),c(1,j))
              call decidebondcut(iatnum(i),iatnum(j),rlim)
              rlim=rlim*bondminfac
              if (r2 .lt. rlim) then
c               Too short bond found.
                nerr=nerr+1
                r=sqrt(r2)
                if (inamcol2 .lt. inamcol1) then
                  write (iout,2002) i,iatnm2(iatnum(i)),j,
     -              iatnm2(iatnum(j)),r,sqrt(rlim)
                else
                  write (iout,2003) i,resnami,atnami,j,
     -              line(index(j))(irescol1:irescol2),
     -              line(index(j))(inamcol1:inamcol2),
     -              r,sqrt(rlim)
                end if
                nbshort=nbshort+1
                if (rminshort .gt. r) rminshort=r
              end if
            end if
          end do
        end if
      end do
      if (ioppbc .ge. 0) call distminsetup(edge,ioppbc)
      ncsltintra=0
      ncsltinter=0
      ncsltinterpbc=0
      rminsltintra=1000.0
      rminsltinter=1000.0
      rminsltinterpbc=1000.0
      do im=1,nmolslt
c       Check for close approach
        do i=molsltlim(1,im),molsltlim(2,im)
          if ((iatnum(i) .lt. 88 .or. iatnum(i) .gt. 90)
     -        .and. isegno(i) .ge. 0) then
            if (inamcol2 .ge. inamcol1) then
              resnami='     '
              resnami=line(index(i))(irescol1:irescol2)
              atnami=line(index(i))(inamcol1:inamcol2)
            end if
c           Check solute intramolecular NB distances
            do j=i+1,molsltlim(2,im)
              if ((iatnum(j) .lt. 88 .or. iatnum(j) .gt. 90)
     -            .and. isegno(j) .ge. 0) then
                ibonded=0
                do in=1,nneig(i)
                  if (j .eq. ineig(in,i)) ibonded=1
                end do
                if (ibonded .eq. 0) then
                  r2=dist2(c(1,i),c(1,j))
                  call decidebondcut(iatnum(i),iatnum(j),rlim)
                  rlimct=rlim*ctlimfac
                  if (r2 .le. rlimct) then
c                   Contact between atoms found.
                    nerr=nerr+1
                    r=sqrt(r2)
                    if (inamcol2 .lt. inamcol1) then
                      write (iout,2000) 'Slt NB ',i,
     -                  iatnm2(iatnum(i)),j,iatnm2(iatnum(j)),
     -                  r,sqrt(rlimct)
                    else
                      write (iout,2001) 'Slt NB ',i,resnami,atnami,j,
     -                  line(index(j))(irescol1:irescol2),
     -                  line(index(j))(inamcol1:inamcol2),
     -                  r,sqrt(rlimct)
                    end if
                    ncsltintra=ncsltintra+1
                    if (rminsltintra .gt. r) rminsltintra=r
                  end if
                end if
              end if
            end do
c           Check solute intermolecular distances
            do jm=im+1,nmolslt
              do j=molsltlim(1,jm),molsltlim(2,jm)
                if ((iatnum(j) .lt. 88 .or. iatnum(j) .gt. 90)
     -              .and. isegno(j) .ge. 0) then
                  pbclab='    '
                  if (ioppbc .ge. 0) then
c                   Check for images
                    call arrdiff(c(1,i),c(1,j),rpbc,3)
                    call distmincalc(ioppbc,cell,ncell,ixyzhex,edge,
     -                rpbc(1),rpbc(2),rpbc(3),icmin,r2)
                    if (icmin .gt. 1) pbclab=' PBC'
                  else
                    r2=dist2(c(1,i),c(1,j))
                  end if
                  call decidebondcut(iatnum(i),iatnum(j),rlim)
                  rlimct=rlim*ctlimfac
                  if (r2 .le. rlimct) then
c                   Contact between atoms found.
                    nerr=nerr+1
                    r=sqrt(r2)
                    if (inamcol2 .lt. inamcol1) then
                      write (iout,2000) 'Slt-Slt',i,
     -                  iatnm2(iatnum(i)),j,iatnm2(iatnum(j)),
     -                  r,sqrt(rlimct),pbclab
                    else
                      write (iout,2001) 'Slt-Slt',i,resnami,
     -                  atnami,j,line(index(j))(irescol1:irescol2),
     -                  line(index(j))(inamcol1:inamcol2),
     -                  r,sqrt(rlimct),pbclab
                    end if
                    if (pbclab .eq. ' PBC') then
                      ncsltinterpbc=ncsltinterpbc+1
                      if (rminsltinterpbc .gt. r) rminsltinterpbc=r
                    else
                      ncsltinter=ncsltinter+1
                      if (rminsltinter .gt. r) rminsltinter=r
                    end if
                    if (ioppbc .gt. 0) then
                      call arrdiff(c(1,i),c(1,j),rij,3)
                      call genimdist(rij,cell,1,ncell,icminn,rmin2)
                      if (abs(rmin2-r2) .gt. 0.1 .or.
     -                   icmin .eq. 1 .and. icminn .gt. 1 .or.
     -                   icmin .gt. 1 .and. icminn .eq. 1)
     -                  write (iout,2009) sqrt(rmin2),r2,icmin,icminn
                    end if
                  end if
                end if
              end do
            end do
          end if
        end do
      end do
      if (isltonly .eq. 1) go to 999
c     Check for solute-solvent contacts
      nsv=(n-nslt)/naslv
      ncsltslv=0
      ncsltslvpbc=0
      rminsltslv=1000.0
      rminsltslvpbc=1000.0
      do ia=1,nslt
        do jm=1,nsv
          pbclab='    '
          icmin=1
          jm0=nslt+(jm-1)*naslv
          call arrdiff(c(1,ia),c(1,jm0+1),rpbc,3)
          if (ioppbc .ge. 0) then
c           Check for images
            call distmincalc(ioppbc,cell,ncell,ixyzhex,edge,
     -        rpbc(1),rpbc(2),rpbc(3),icmin,r2)
            if (icmin .gt. 1) pbclab=' PBC'
          else
            r2=rpbc(1)**2+rpbc(2)**2+rpbc(3)**2
          end if
          isvclose=1
          if (r2 .lt. 25.0) then
c           General image search to get neighbor cell no (could be improved)
            if (pbclab .eq. ' PBC') call genimdist(rpbc,cell,
     -        1,ncell,icminw,rmin2)
            do ja=2,naslv
              call arrdiff(c(1,ia),c(1,jm0+ja),rpbc,3)
              if (pbclab .eq. ' PBC') then
                do k=1,3
                  rpbc(k)=rpbc(k)-cell(k,icminw)
                end do
              end if
              r2j=rpbc(1)**2+rpbc(2)**2+rpbc(3)**2
              if (r2j .lt. r2) then
                r2=r2j
                isvclose=ja
              end if
            end do
            ja=jm0+isvclose
            call decidebondcut(iatnum(ia),iatnum(ja),rlim)
            rlimct=rlim*ctlimfac
            if (r2 .lt. rlimct) then
              r=sqrt(r2)
              nerr=nerr+1
              if (inamcol2 .lt. inamcol1) then
                write (iout,2005) ia,iatnm2(ia),jm,ja,iatnm2(ja),
     -           r,sqrt(rlimct),pbclab
              else
                write (iout,2006) ia,line(index(ia))(irescol1:irescol2),
     -            line(index(ia))(inamcol1:inamcol2),ja,
     -            iatnm2(iatnum(ja)),jm,r,sqrt(rlimct),pbclab
              end if
              if (pbclab .eq. ' PBC') then
                ncsltslvpbc=ncsltslvpbc+1
                if (rminsltslvpbc .gt. r) rminsltslvpbc=r
              else
                ncsltslv=ncsltslv+1
                if (rminsltslv .gt. r) rminsltslv=r
              end if
              if (ioppbc .gt. 0) then
                call arrdiff(c(1,ia),c(1,ja),rij,3)
                call genimdist(rij,cell,1,ncell,icminn,rmin2)
                if (abs(rmin2-r2) .gt. 0.1 .or.
     -             icmin .eq. 1 .and. icminn .gt. 1 .or.
     -             icmin .gt. 1 .and. icminn .eq. 1)
     -            write (iout,2009) sqrt(rmin2),r2,icmin,icminn
              end if
            end if
          end if
        end do
      end do
c     Check for solvent-solvent contacts
      ncslvslv=0
      ncslvslvpbc=0
      rminslvslv=1000.0
      rminslvslvpbc=1000.0
      do im=1,nsv
        im0=nslt+(im-1)*naslv
        do jm=im+1,nsv
          jm0=nslt+(jm-1)*naslv
          call arrdiff(c(1,im0+1),c(1,jm0+1),rpbc,3)
          icmin=1
          pbclab='    '
          if (ioppbc .ge. 0) then
c           Check for images
            call distmincalc(ioppbc,cell,ncell,ixyzhex,edge,
     -        rpbc(1),rpbc(2),rpbc(3),icmin,r2)
            if (icmin .gt. 1) pbclab=' PBC'
          else
            r2=rpbc(1)**2+rpbc(2)**2+rpbc(3)**2
          end if
          isvclose=1
          jsvclose=1
          if (r2 .lt. 25.0) then
            if (pbclab .eq. ' PBC') call genimdist(rpbc,cell,
     -        1,ncell,icminw,rmin2)
            do ia=1,naslv
              do ja=1,naslv
                call arrdiff(c(1,im0+ia),c(1,jm0+ja),rpbc,3)
                if (pbclab .eq. ' PBC') then
                  do k=1,3
                    rpbc(k)=rpbc(k)-cell(k,icminw)
                  end do
                end if
                r2j=rpbc(1)**2+rpbc(2)**2+rpbc(3)**2
                if (r2j .lt. r2) then
                  r2=r2j
                  isvclose=ia
                  jsvclose=ja
                end if
              end do
              iac=im0+isvclose
              jac=jm0+jsvclose
              call decidebondcut(iatnum(iac),iatnum(jac),rlim)
              rlimct=rlim*ctlimfac
              r=sqrt(r2)
              if (r2 .lt. rlimct) then
                 nerr=nerr+1
                write (iout,2007) iac,iatnm2(iatnum(iac)),im,jac,
     -            iatnm2(iatnum(jac)),jm,r,sqrt(rlimct),pbclab
                if (pbclab .eq. ' PBC') then
                  ncslvslvpbc=ncslvslvpbc+1
                  if (rminslvslvpbc .gt. r) rminslvslvpbc=r
                else
                  ncslvslv=ncslvslv+1
                  if (rminslvslv .gt. r) rminslvslv=r
                end if
                if (ioppbc .gt. 0) then
                  call arrdiff(c(1,iac),c(1,jac),rij,3)
                  call genimdist(rij,cell,1,ncell,icminn,rmin2)
                  if (abs(rmin2-r2) .gt. 0.1 .or.
     -               icmin .eq. 1 .and. icminn .gt. 1 .or.
     -               icmin .gt. 1 .and. icminn .eq. 1)
     -              write (iout,2009) sqrt(rmin2),r2,icmin,icminn
                end if
              end if
            end do
          end if
        end do
      end do
999   if (rminshort .eq. 1000.0) rminshort=0.0
      write (iout,2008) 'short bonds',nbshort,rminshort
      if (rminsltintra .eq. 1000.0) rminsltintra=0.0
      write (iout,2008) 'solute intramolecular clashes',
     -  ncsltintra,rminsltintra
      if (nmolslt .gt. 1) then
        if (rminsltinter .eq. 1000.0) rminsltinter=0.0
        write (iout,2008) 'solute intermolecular non-PBC clashes',
     -    ncsltinter,rminsltinter
        if (rminsltinterpbc .eq. 1000.0) rminsltinterpbc=0.0
        if (ioppbc .ge. 0)
     -    write (iout,2008) 'solute intermolecular PBC clashes',
     -    ncsltinterpbc,rminsltinterpbc
      end if
      if (isltonly .eq. 0) then
        if (rminsltslv .eq. 1000.0) rminsltslv=0.0
        write (iout,2008) 'solute -solvent non-PBC clashes',
     -    ncsltslv,rminsltslv
        if (rminslvslv .eq. 1000.0) rminslvslv=0.0
        write (iout,2008) 'solvent-solvent non-PBC clashes',
     -    ncslvslv,rminslvslv
        if (ioppbc .ge. 0) then
          if (rminsltslvpbc .eq. 1000.0) rminsltslvpbc=0.0
          write (iout,2008) 'solute -solvent PBC clashes',
     -      ncsltslvpbc,rminsltslvpbc
          if (rminslvslvpbc .eq. 1000.0) rminslvslvpbc=0.0
          write (iout,2008) 'solvent-solvent PBC clashes',
     -      ncslvslvpbc,rminslvslvpbc
        end if
      end if
      return
2000  format(1x,a,' clash: d[',i5,' (',a2,') - ',i5,'(',a2,')]=',
     -  f4.2,' A (<',f4.2,')',a)
2001  format(1x,a,' clash: d[',i5,' (',a4,1x,a5,') - ',i5,
     -  ' (',(a4,1x,a4),')]=',f4.2,' A (<',f4.2,')',a)
2002  format(' Too short bond: d[',i5,' (',a2,') - ',i5,'(',a2,')]=',
     -  f6.2,' A (<',f4.2,')')
2003  format(' Too short bond: d[',i5,' (',a4,1x,a5,') - ',
     -  i5,'(',a4,1x,a5,')]=',f4.2,' A (<',f4.2,')')
2005  format(' Solvent clash: d(',i5,1x,a2,' - ',
     -  i7,1x,a2,' slv #',i6,')=',f4.2,' A (<',f4.2,')',a)
2006  format(' Solvent clash: d(',i5,1x,a4,1x,a4,' - ',
     -  i7,1x,a2,' slv #',i6,')=',f4.2,' A (<',f4.2,')',a)
2007  format(' Solvent clash: d(',i7,1x,a2,' #',i6,' - ',
     -  i7,1x,a2,' #',i6,')=',f4.2,' A (<',f4.2,')',a)
2008  format(' Number of ',a,' found=',i7,' Min=',f4.2,' A')
2009  format(' PROGRAM ERROR: r(check)=',f9.4,' r(calc)=',f9.4,
     -  ' icmin,n=',2i3)
      end
      subroutine filterbonds(n,nbfound,nhbdist,nhbpers,itrackf,itrackl,
     -  maxlenon,maxlenoff,iframeunit,framefac,nframe,indexbond,
     -  label,llabel,line,index,inamcol1,inamcol2,irescol1,irescol2,
     -  iresno,isegno,ixres,ixresno,ixsegno,ifres,numres,ianc_anc,isc,
     -  bondtype,lbondtype,percmin,percmax,minresdist,maxresdist,
     -  nochange,percbond,iuselaston,iaucw,temp,it1,it2,it3,it4,irrix,
     -  itemp1,iout,igl,maxrec,maxrsd,mxbonds,mxframes,mxcopy)
      dimension index(maxrec),nhbdist(mxbonds),nhbpers(mxbonds),
     -  itrackf(mxbonds),itrackl(mxbonds),maxlenon(mxbonds),
     -  maxlenoff(mxbonds),indexbond(mxbonds),iresno(maxrec),
     -  isegno(maxrec),ixres(maxrec),ixresno(maxrsd),ixsegno(maxrsd),
     -  ifres(maxrec),ianc_anc(mxbonds),isc(maxrec),percbond(maxrec),
     -  temp(maxrec),it1(mxbonds),it2(mxbonds),it3(mxbonds),
     -  it4(mxbonds),irrix(maxrec),itemp1(maxrec)
      character*(*) label,bondtype
      character*80 bond
      character*132 line(maxrec)
      parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
      parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
     -  (9*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
      common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),ing(MAX2D,MAX2D),
     -  ihbpair(2,MAXBONDS),ihb_pair_res(3,MAXBONDS),ihbtores(MAXBONDS),
     -  iusepair(MAXBONDS),a1(MAXBONDS),a2(MAXBONDS),fill(IFILL2)
      dimension limperc(6),nplim(6),npbsum(6),lauc_type(5)
      character*1 ans
      character*6 bondlab
      character*60 auc_type(5)
      data auc_type /
     -  'AUC data generation is ended at the last ON state',
     -  'AUC data generation is ended at the last frame of the track',
     -  'Track is padded with additional zeros',
     -  'Track is padded by reusing the last stretch of the track',
     -  'Track is padded by random 0/1 string, p(1)=fraction on'/,
     -  lauc_type /49,59,37,56,54/
      data limperc /1,2,5,10,20,50/
c     print *,'FILTERBOND NBFOUND=',nbfound
      nochange=1
      call getreal('MINimum percentage presence',27,0.0,percmin,1,7)
      call getreal('MAXimum percentage presence',27,100.0,percmax,1,7)
      if (percmin .gt. 0.0 .or. percmax .lt. 100.0) then
        nochange=0
        write (iout,1000) label(1:llabel),percmin,percmax
      end if
      call getint('MINimum residue-residue sequence distance',41,
     -  0,1,0,minresdist,8)
      call getint('MAXimum residue-residue sequence distance',41,
     -  numres-1,1,0,maxresdist,8)
      if (minresdist .gt. 0 .or. maxresdist .lt. numres-1) then
        nochange=0
        write (iout,1001) label(1:llabel),minresdist,maxresdist
      end if
      do ip=1,6
        nplim(ip)=max0(1,nframe/(100/limperc(ip)))
        npbsum(ip)=0
      end do
      nhbsum=0
      nbb=0
      naa=0
      call zeroit(percbond,n)
      do ii=1,nbfound
        i=indexbond(ii)
        temp(i)=100.0*float(nhbdist(i))/float(nframe)
        nhbsum=nhbsum+nhbdist(i)
        do ip=1,6
          if (nhbdist(i) .gt. nplim(ip)) npbsum(ip)=npbsum(ip)+1
        end do
        if (ianc_anc(i) .eq. 1) naa=naa+1
        if (isc(ihbpair(1,i))*isc(ihbpair(2,i)) .eq. 0) nbb=nbb+1
      end do
      do ip=1,6
        write (iout,1007) limperc(ip),npbsum(ip)
      end do
      if (naa .gt. 0) write (iout,1008)
      if (nbb .gt. 0) write (iout,1009)
      nhbsumtot=nhbsum
      iallkept=1
      if (nochange .eq. 0) then
        ndel=0
        nmindel=0
        nmaxdel=0
        nmindistdel=0
        nmaxdistdel=0
        do ii=1,nbfound
          i=indexbond(ii)
          p=temp(i)
          iresdist=iabs(ixres(ihbpair(1,i))-ixres(ihbpair(2,i)))
          if (iresdist .lt. minresdist .or. iresdist .gt. maxresdist
     -      .or. p .lt. percmin .or. p .gt. percmax) then
            ndel=ndel+1
            if (p .lt. percmin) then
              nmindel=nmindel+1
              it1(nmindel)=i
            else if (p .gt. percmax) then
              nmaxdel=nmaxdel+1
              it2(nmaxdel)=i
            end if
            if (iresdist .lt. minresdist) then
              nmindistdel=nmindistdel+1
              it3(nmindistdel)=i
            else if (iresdist .gt. maxresdist) then
              nmaxdistdel=nmaxdistdel+1
              it4(nmaxdistdel)=i
            end if
          else
            indexbond(ii-ndel)=indexbond(ii)
          end if
        end do
        iallkept=0
        if (ndel .gt. 0) then
          nbfound=nbfound-ndel
          if (nmindel .gt. 0) then
            write (iout,1002) 'infrequent',nmindel
            do ib=1,nmindel
              call bonddescr(it1(ib),ihbpair,line,index,iresno,isegno,
     -          inamcol1,inamcol2,irescol1,irescol2,bond,lbond,bondlab,
     -          lbondlab,nbb,ianc_anc,isc,ia1,ia2,ir1,ir2,maxrec,
     -          MAXBONDS)
              write (iout,1005) ib,it1(ib),bond(1:lbond),temp(it1(ib)),
     -          bondlab(1:lbondlab)
              nhbsum=nhbsum-nhbdist(it1(ib))
            end do
          end if
          if (nmaxdel .gt. 0) then
            write (iout,1002) 'persistent',nmaxdel
            do ib=1,nmaxdel
              call bonddescr(it2(ib),ihbpair,line,index,iresno,isegno,
     -          inamcol1,inamcol2,irescol1,irescol2,bond,lbond,bondlab,
     -          lbondlab,nbb,ianc_anc,isc,ia1,ia2,ir1,ir2,maxrec,
     -          MAXBONDS)
              write (iout,1005) ib,it2(ib),bond(1:lbond),temp(it2(ib)),
     -          bondlab(1:lbondlab)
              nhbsum=nhbsum-nhbdist(it2(ib))
            end do
          end if
          if (nmindistdel .gt. 0) then
            write (iout,1002) 'close',nmindistdel
            do ib=1,nmindistdel
              call bonddescr(it3(ib),ihbpair,line,index,iresno,isegno,
     -          inamcol1,inamcol2,irescol1,irescol2,bond,lbond,bondlab,
     -          lbondlab,nbb,ianc_anc,isc,ia1,ia2,ir1,ir2,maxrec,
     -          MAXBONDS)
              write (iout,1005) ib,it3(ib),bond(1:lbond),temp(it3(ib)),
     -          bondlab(1:lbondlab)
              nhbsum=nhbsum-nhbdist(it3(ib))
            end do
          end if
          if (nmaxdistdel .gt. 0) then
            write (iout,1002) 'distant',nmaxdistdel
            do ib=1,nmaxdistdel
              call bonddescr(it4(ib),ihbpair,line,index,iresno,isegno,
     -          inamcol1,inamcol2,irescol1,irescol2,bond,lbond,bondlab,
     -          lbondlab,nbb,ianc_anc,isc,ia1,ia2,ir1,ir2,maxrec,
     -          MAXBONDS)
              write (iout,1005) ib,it4(ib),bond(1:lbond),temp(it4(ib)),
     -          bondlab(1:lbondlab)
              nhbsum=nhbsum-nhbdist(it4(ib))
            end do
          end if
          write (6,1003) label(1:llabel),nbfound
          write (iout,1003) label(1:llabel),nbfound
        else
          write (iout,*) 'All bonds are kept'
          iallkept=1
        end if
      end if
      call zeroiti(irrix,0,n)
      call zeroiti(itemp1,0,numres)
      write (iout,1004)
      call persistence(1,1,1,1,1,1,iframeunit,framefac,nframe,1,
     -  iuselaston,1,iout)
      call askyn('Do you want to calculate bond autocorrelation',45,
     -  1,-1,iauc,0)
      iaucw=0
      loffmin=0
      iauctype=0
      nseg_scr=0
      nreusemax=nframe
      if (iauc .eq. 1) then
c       Establish details
        call quiz(ans,iauctype,'o',' ',0,
     -    'autocorrelation calculation mode',32,0,5,6,igl,000)
        write (iout,1013) auc_type(iauctype)(1:lauc_type(iauctype))
        lastframeinp=0
        if (iauctype .gt. 2) then
          call getint('Frame number to pad the tracks to',33,
     -      mxframes,1,mxframes,lastframeinp,000)
          write (iout,1014) lastframeinp
        end if
        if (iauctype .gt. 3) then
          write (6,1015)
          call getint(
     -      'Length of the off stretch to shift to zero padding',50,
     -      mxframes,1,mxframes,loffmin,000)
          if (loffmin .lt. mxframes) write (iout,1016) loffmin
          if (iauctype .eq. 4) then
            call getint('Maximum number of frames to reuse',33,nframe,
     -        1,nframe,nreusemax,000)
            if (nreusemax .lt. nframe) write (iout,1017) nreusemax
            call getint(
     -        'Number of segments to scramble before reusing a track',
     -        53,0,1,100,nseg_scr,000)
            if (nseg_scr .gt. 0) write (iout,1012) nseg_scr
          end if
        end if
        call askyn(
     -    'Do you want to write the full autocorrelation functions',55,
     -    1,-1,iaucw,0)
      end if
      nauc_extra=0
      do ib=1,nbfound
        i=indexbond(ib)
        call bonddescr(i,ihbpair,line,index,iresno,isegno,inamcol1,
     -    inamcol2,irescol1,irescol2,bond,lbond,bondlab,lbondlab,nbb,
     -    ianc_anc,isc,ia1,ia2,ir1,ir2,maxrec,MAXBONDS)
        irrix(ia1)=irrix(ia1)+nhbdist(i)
        irrix(ia2)=irrix(ia2)+nhbdist(i)
        itemp1(ir1)=itemp1(ir1)+nhbdist(i)
        itemp1(ir2)=itemp1(ir2)+nhbdist(i)
c        write (06,9781) ib,i,nhbpers(i),nhbdist(i)
c9781    format(' i=',i5,' ib=',i5,'  nhbpers=',i5,' nhbdist=',i5)
        write (iout,1005) ib,i,bond(1:lbond),temp(i),bondlab(1:lbondlab)
        call persistence(nhbdist(i),nhbpers(i),itrackf(i),itrackl(i),
     -    maxlenon(i),maxlenoff(i),iframeunit,framefac,nframe,0,
     -    iuselaston,0,iout)
        if (iuselaston .eq. 1) then
          lentrack=itrackl(i)-itrackf(i)+1
        else
          lentrack=nframe-itrackf(i)+1
        end if
        percon=float(nhbdist(i))/float(lentrack)
         if (iauc .gt. 0) call autocorr(ib,i,30,iframeunit,framefac,
     -     iauctype,lastframeinp,nreusemax,percon,loffmin,nseg_scr,
     -     nauc_extra,iout)
      end do
      if (nauc_extra .gt. 0) then
        write (6,1018) mxcopy,nauc_extra,mxcopy+nauc_extra
        write (iout,1018) mxcopy,nauc_extra,mxcopy+nauc_extra
      end if
      do ia=1,n
        percbond(ia)=float(irrix(ia))/float(nframe)
      end do
      write (iout,1006) bondtype(1:lbondtype),'=',
     -  float(nhbsumtot)/float(nframe)
      if (iallkept .eq. 0) write (iout,1006) bondtype(1:lbondtype),
     -  ' without the deleted ones=',float(nhbsum)/float(nframe)
      do ia=1,n
        ir=ixres(ia)
        if (irrix(ia) .gt. 0) write (iout,1011) 
     -    line(index(ia))(inamcol1:inamcol2),ia,
     -    line(index(ifres(ir)))(irescol1:irescol2),ixresno(ir),
     -    ixsegno(ir),float(irrix(ia))/float(nframe)
      end do
      do ir=1,numres
        if (itemp1(ir) .gt. 0) write (iout,1010)
     -    line(index(ifres(ir)))(irescol1:irescol2),ixresno(ir),
     -    ixsegno(ir),float(itemp1(ir))/float(nframe)
      end do
      return
1000  format(' Plotting and correlation calculation will exclude ',a,
     -  ' bonds that are',/,5x,'present in less than ',f6.1,
     -  ' % of the time or more than ',f6.1,'% of the time')
1001  format(' Plotting and correlation calculation will exclude ',a,
     -  ' bonds whose',/,5x,'residue-residue distance is less than ',i4,
     -  ' or greater than ',i5)
1002  format(' Number of ',a,' bonds filtered out=',i5,' :')
1003  format(' Number of ',a,' bonds left after filtering=',i5)
1004  format(/,' List of bonds whose history is plotted')
1005  format(' B#',i5,' (',i5,')',a,f6.1,' %',a)
1006  format(' Total number of ',a,' bonds per frame',a,f6.1)
1007  format(' # of bonds occuring more than ',i3,'% of time:',i4)
1008  format(' Lines ending with AA describe anchor-anchor bonds')
1009  format(' Labels BB,SS,BS,SB refer to backbone-backbone, ',
     -  'sidechain-sidechain,',/,
     -  ' backbone-sidechain, sidechain-backbone bonds, resp.')
1010  format(' Residue ',a,i5,' C/S',i2,': <Nbond>/frame=',f6.4)
1011  format(' Atom ',a,i7,' Residue ',a,i5,' C/S',i2,
     -  ': <Nbond>/frame=',f6.4)
1012  format(' Reused tracks will be scrambled in ',i4,' segments')
1013  format(1x,a)
1014  format(' Tracks will be extended until frame number ',i6)
1015  format(' If the trajectory ended well before the last frame then',
     -  ' 0 padding will be used')
1016  format(' If the end of the trajectory contains an all 0 stretch ',
     -  'longer than',i7,' than',/,' the padding will switch to 0s')
1017  format(' Reused tracks will be limited to the last',i6,' frames ',
     -  'of each track')
1018  format(' NOTE: number of AUCs exceeds limit (',i5,') by',i5,/,
     -  7x,'Increase the parameter MAXCOPY to',i5)
      end
      subroutine bonddescr(ib,ihbpair,line,index,iresno,isegno,
     -  inamcol1,inamcol2,irescol1,irescol2,bond,lbond,bondlab,
     -  lbondlab,nbb,ianc_anc,isc,ia1,ia2,ir1,ir2,maxrec,maxbonds)
      dimension ihbpair(2,maxbonds),index(maxrec),iresno(maxrec),
     -  isegno(maxrec),ianc_anc(maxbonds),isc(maxrec)
      character*132 line(maxrec)
      character*(*) bondlab
      character*2 sc_lab(2,2)
      character*(*) bond
      data sc_lab /'BB','SB','BS','SS'/
      ia1=ihbpair(1,ib)
      ia2=ihbpair(2,ib)
      ir1=iresno(ia1)
      ir2=iresno(ia2)
      write (bond,1000)
     -    line(index(ia1))(inamcol1:inamcol2),
     -    line(index(ia1))(irescol1:irescol2),ir1,isegno(ia1),
     -    line(index(ia2))(inamcol1:inamcol2),
     -    line(index(ia2))(irescol1:irescol2),ir2,isegno(ia2)
      lbond=2*(inamcol2-inamcol1+irescol2-irescol1+2)+26
      lbondlab=1
      bondlab=' '
      if (nbb .gt. 0) then
        bondlab(lbondlab+1:lbondlab+3)=
     -    sc_lab(isc(ihbpair(1,ib))+1,isc(ihbpair(2,ib))+1)
          lbondlab=lbondlab+2
        end if
        if (ianc_anc(ib) .eq. 1) then
          bondlab(lbondlab+1:lbondlab+3)=' AA'
          lbondlab=lbondlab+3
        end if
      return
1000  format(1x,a,1x,a,i4,' C/S',i2,' - ',a,1x,a,i4,' C/S',i2)
      end
      subroutine persistence(nhbdist,nhbpers,itf,itl,maxlenon,
     -  maxlenoff,iframeunit,framefac,nframe,ihead,iuselaston,iwauc,
     -  iout)
      dimension lfrunit(4)
      character*6 frunit(4)
      data frunit /'frames','ps    ','ns    ','ms    '/,lfrunit/6,2,2,2/
      if (ihead .eq. 1) then
        if (iuselaston .eq. 1) write (iout,1000)
        if (iuselaston .eq. 0) write (iout,1001)
        write (iout,1002) 
        if (iframeunit .eq. 1) then
          write (iout,1010) nframe
          if (iwauc .eq. 1) write (iout,1004) max0(1,nframe/20)
        else
          write (iout,1008) nframe*framefac,
     -      frunit(iframeunit)(1:lfrunit(iframeunit))
          if (iwauc .eq. 1) write (iout,1009) 10*framefac,
     -      frunit(iframeunit)(1:lfrunit(iframeunit)),
     -      max0(1,nframe/20)*framefac,
     -      frunit(iframeunit)(1:lfrunit(iframeunit))
        end if
        return
      end if
      if (iuselaston .eq. 1) lentrack=itl-itf+1
      if (iuselaston .eq. 0) lentrack=nframe-itf+1
      rlenb=float(nhbdist)/float(nhbpers+1)
      rlenoff=float(lentrack-nhbdist)/float(nhbpers)
      percbreak=100.0*float(lentrack-nhbdist)/float(lentrack)
      write (iout,1003) nhbpers,percbreak,lentrack,nhbdist,itf,itl
      write (iout,1005) rlenb,rlenoff,maxlenon,maxlenoff,frunit(1)
      if (iframeunit .eq. 2) write (iout,1007) rlenb*framefac,
     -  rlenoff*framefac,maxlenon*framefac,maxlenoff*framefac,
     -  frunit(iframeunit)(1:lfrunit(iframeunit))
      if (iframeunit .gt. 2) write (iout,1006) rlenb*framefac,
     -  rlenoff*framefac,maxlenon*framefac,maxlenoff*framefac,
     -  frunit(iframeunit)(1:lfrunit(iframeunit))
      return
1000  format(' Ltrack: #of frames between first on to the last on')
1001  format(' Ltrack: #of frames between first on to the last frame')
1002  format(' Non: # frames the bond was on; Nbreak: Number of breaks',
     -  /,' <Lon>,<Loff>: Average length of a contiguous on and ',
     -  'off track, resp.',/,' Lon(max),Loff(max): longest contiguous ',
     -  'on and off track, resp.',/,' %break: ',
     -  '100*(Ltrack-Non)/Ltrack')
1003  format('   Nbreak=',i5,' %off=',f5.1,' Ltrack=',i5,' Non=',i5,
     -  ' First on=',i5,' Last on=',i5)
1004  format(' AUC(1-10): Bond autocorrelation for the first 10 frames',
     -  /,' AUC(incr): Bond autocorrelation at ',i6,' frame intervals')
1005  format(' <Lon>=',f9.1,' <Loff>=',f9.1,' Lon(max)=',i9,
     -  ' Loff(max)=',i9,1x,a)
1006  format(' <Lon>=',f9.4,' <Loff>=',f9.4,' Lon(max)=',f9.4,
     -  ' Loff(max)=',f9.4,1x,a)
1007  format(' <Lon>=',f9.2,' <Loff>=',f9.2,' Lon(max)=',f9.2,
     -  ' Loff(max)=',f9.2,1x,a)
1008  format(' Length of the trajectory analyzed=',f10.2,1x,a)
1009  format(' AUC(1-10): Bond autocorrelation for the first',f8.2,1x,a,
     -  /,' AUC(incr): Bond autocorrelation at',f8.2,1x,a,' intervals')
1010  format(' Number of frames analyzed=',i5)
      end
      subroutine printbondlist(iangpr,itorpr,n1,n2,nstta,cslt,nneig,
     -  ineig,line,inamcol1,inamcol2,irescol1,irescol2,iresncol1,
     -  iresncol2,index,cv,ichiral,maxneig,radtodeg,iout,maxrec)
c#    MMC routine  98/b lstmod: 06/21/05
c*****List bonds, angles, torsions as requested
      character* 132 line(maxrec)
      dimension cslt(3,nstta),nneig(nstta),ineig(maxneig,nstta),
     -  index(nstta),cv(nstta),ichiral(nstta)
      character*8 lab
      data lab /' CHIRAL '/
      dimension ang(28),iang(2,28)
      do ia=n1,n2
        if (nneig(ia) .ne. 1) then
          do in=1,nneig(ia)
            cv(in)=sqrt(dist2(cslt(1,ia),cslt(1,ineig(in,ia))))
            if (cv(in) .lt. 0.1) then
              write (iout,2265) ineig(in,ia)
            end if
          end do
          llab=1
          if (ichiral(ia) .gt. 0) llab=8
          write (iout,2148) ia,line(index(ia))(inamcol1:inamcol2),
     -      line(index(ia))(iresncol1:iresncol2),
     -      line(index(ia))(irescol1:irescol2),lab(1:llab),nneig(ia)
          write (iout,2149) (ineig(in,ia),
     -      line(index(ineig(in,ia)))(inamcol1:inamcol2),
     -      line(index(ineig(in,ia)))(irescol1:irescol2),
     -      line(index(ineig(in,ia)))(iresncol1:iresncol2),cv(in),
     -      in=1,nneig(ia))
        end if
        if (iangpr .eq. 1 .and. nneig(ia) .ge. 2) then
c         Generate angle list
          nnlim=min0(8,nneig(ia))
          nang=0
          do in1=1,nnlim
            do in2=in1+1,nnlim
              nang=nang+1
              ang(nang)=radtodeg*angleijk(cslt,nstta,ineig(in1,ia),ia,
     -          ineig(in2,ia),iout)
              iang(1,nang)=ineig(in1,ia)
              iang(2,nang)=ineig(in2,ia)
            end do
          end do
          write (iout,2142) (iang(1,i),ia,iang(2,i),ang(i),i=1,nang)
        end if
        if (itorpr .eq. 1) then
c         Generate torsion angle list
          do in=1,nneig(ia)
            inj=ineig(in,ia)
            if (inj .gt. in) then
              nnlim1=min0(8,nneig(ia)+1)
              nnlim2=min0(8,nneig(inj)+1)
              nang=0
              do in1=1,nnlim1
                inn1=ineig(in1,ia)
                if (inn1 .ne. inj) then
                  do in2=in1+1,nnlim2
                    inn2=ineig(in2,inj)
                    if (inn2 .ne. ia) then
                      nang=nang+1
c                     ang(nang)=dihangl(cslt(1,inn1),cslt(1,ia),
c    -                  cslt(1,inj),cslt(1,inn2),1,iout)
                      ang(nang)=dihangl(cslt,inn1,ia,inj,inn2,0,maxrec)
                      iang(1,nang)=inn1
                      iang(2,nang)=inn2
                    end if
                  end do
                end if
              end do
              write (iout,2182) (' ',iang(1,i),ia,inj,iang(2,i),
     -          radtodeg*ang(i),i=1,nang)
            end if
          end do
        end if
      end do
      return
2142  format(3('  Angle(',i5,'-',i5,'-',i5,')=',f8.3,' deg'))
2148  format(i6,' (',a,1x,a,1x,a,')',a,'-',i3,' neighbours:')
2149  format((7x,2(i5,' (',a,1x,a,1x,a,') r=',f6.4,' A')))
2182  format(3(a,' Torsion(',i5,'-',i5,'-',i5,'-',i5,')=',f7.2,' deg'))
2265  format(' ----- WARNING: unphysically short bond with atom',i7)
      end
      subroutine findfg(n0,n,ian,nfgmem,ifgstr,ifgaix,indxfg,
     -  ixfg,ifgtyp,itypfg,nfg,iout,nneig,nneigh,nneiga,ineig,iwfg,
     -  inpcrdtyp,ioins,ic1,ic2,ir1,ir2,irn1,irn2,line,index,maxng,
     -  maxrec)
c#    MMC routine 164 lstmod: 07/11/96
c*****Assigns the appropriate fg types to the atoms in c
      dimension nneig(n),ineig(maxng,n),nneigh(n),nneiga(n),
     -  ian(n),nfgmem(n),ifgstr(n),ifgaix(n),ixfg(n),
     -  indxfg(n),ifgtyp(n),itypfg(n),index(n)
      character* 132 line(maxrec)
      character*2 iatnm2
      common /atnam/ aw(99),nval(99),nvalmax(99),mmofan(99),
     -  mmatno(64),iatnm2(99)
      character*1 sp
      character*4 namfcg
      common /connatdat/ ramax(99),ramax2(99),hlimfac,ianfg(99),
     -  namfcg(100),nrmw
      dimension in12(2)
      data sp /' '/,ityp /0/
c     c(1,i) : coordinates of atom i
c     n : number of atoms in c
c     icl(i) : type af atom i
c     ian(i) : atomic number of atom i
c     nfg: number of functional groups found
c     nfgmem(i): number of atoms in fcg i
c     ifgstr(i): start of member list for fcg i in indxat
c     itypfg(i): functional group type of atom i
c     ifgtyp(i): the functional group type if the i-th fcg before sorting
c     indxfg(i): the i-th atom belongs to the indxfg(i)-th fcg
c     ifgaix(i): the original index of the i-th atom in the atomlist
c     ixfg(ig) : the ig-th functional group after sorting
c     sorted by functional groups
c     nneig(i) : number of neighbours of atom i
c     ineig(1,i) : list of neighbours of atom i
c     nneigh(i) : number of hydrogen neighbours of atom i
      nfg=0
      nverr=0
      call zeroiti(itypfg,n0-1,n)
c     Check for "valence errors"
      nverr=0
      do i=n0,n
        if (nneiga(i) .gt. nval(ian(i)) .and. nval(ian(i)) .gt. 0) then
          if (inpcrdtyp .le. ioins) then
            write (iout,1001)
     -        i,line(index(i))(ic1:ic2),line(index(i))(ir1:ir2),
     -        line(index(i))(irn1:irn2),ian(i),nneiga(i),
     -        (ineig(j,i),line(index(ineig(j,i)))(ic1:ic2),
     -        line(index(ineig(j,i)))(ir1:ir2),
     -        line(index(ineig(j,i)))(irn1:irn2),j=1,nneiga(i))
          else
            write (iout,1002) i,ian(i),nneiga(i),
     -      (ineig(j,i),j=1,nneiga(i))
          end if
          itypfg(i)=100
          nfg=nfg+1
          indxfg(i)=nfg
          nverr=nverr+1
        end if
      end do
      if (nverr .gt. 0) then
        call askyn('Do you want to break any bond',29,1,1,ibreak,0)
        if (ibreak .gt. 0) then
          do while (.true.)
            call getintline(
     -        'Atomindices of the bond to be broken (0,0 to quit)',50,
     -        1,n,in12,2,00)
            if (in12(1) .eq. 0 .and. in12(2) .eq. 0) go to  100
            call breakbond(in12(1),in12(2),n0,n,nneig,ineig,nneiga,
     -        nneigh,ian,ifail,maxng)
            call breakbond(in12(2),in12(1),n0,n,nneig,ineig,nneiga,
     -        nneigh,ian,ifail,maxng)
          end do
        end if
      end if
c     if (nverr .gt. 0) go to 120
c     Search for O and P first
100   do i=n0,n
        if (ian(i) .eq. 8 .and. itypfg(i) .eq. 0 .and.
     -       nneiga(i) .gt. 0) then
c         Oxygen found
c          print *,'i,nneiga(i),ineig(1,i)=',i,nneiga(i),ineig(1,i)
          if (nneiga(i) .eq. 1 .and. ian(ineig(1,i)) .eq. 6) then
            inn1=ineig(1,i)
            nnn1=nneiga(inn1)
            noxy=0
            do j=1,nnn1
              if (ian(ineig(j,inn1)) .eq. 8 .and.
     -          nneiga(ineig(j,inn1)) .eq. 1) noxy=noxy+1
            end do
            if (noxy .eq. 2) then
c             COO- found typ=27
              nfg=nfg+1
              indxfg(inn1)=nfg
              itypfg(inn1)=27
              do j=1,nnn1
                in=ineig(j,inn1)
                if (ian(in) .eq. 8 .and. nneiga(in) .eq. 1 .and.
     -              itypfg(in) .eq. 0) then
                  indxfg(in)=nfg
                  itypfg(in)=27
                end if
              end do
            else
c             >C=O found,  typ=17
              nfg=nfg+1
              indxfg(i)=nfg
              indxfg(inn1)=nfg
              itypfg(i)=17
              itypfg(inn1)=17
            end if
          else if (nneiga(i) .eq. 2 .and. nneigh(i) .eq. 0) then
c           Ester oxygen found, typ=19 or 20 (for phospho ester)
            nfg=nfg+1
            indxfg(i)=nfg
            if (ian(ineig(1,i)) .ne. 15 .and. ian(ineig(2,i)) .ne. 15)
     -        itypfg(i)=19
            if (ian(ineig(1,i)) .eq. 15 .or. ian(ineig(2,i)) .eq. 15)
     -        itypfg(i)=20
          else if (nneiga(i) .eq. 2 .and. nneigh(i) .eq. 1) then
c           -OH found, typ=21
            nfg=nfg+1
            indxfg(i)=nfg
            itypfg(i)=21
            nn=nneiga(i)
            do j=1,nn
              in=ineig(j,i)
              if (ian(in) .eq. 1 .and. itypfg(in) .eq. 0) then
                indxfg(ineig(j,i))=nfg
                itypfg(ineig(j,i))=21
              end if
            end do
          end if
        else if (ian(i) .eq. 15 .and. itypfg(i) .eq. 0) then
c         Phosphorus found  (>PO2 : ityp 22)
          nfg=nfg+1
          indxfg(i)=nfg
          itypfg(i)=22
          iong=0
          nn=nneiga(i)
          do j=1,nn
            in=ineig(j,i)
            if (ian(in) .eq. 8 .and. itypfg(in) .eq. 0 .and.
     -        nneiga(in) .eq. 1) then
              iong=iong+1
              indxfg(in)=nfg
              itypfg(in)=22
            end if
          end do
          if (iong .ne. 2) write (iout,1000) i,iong
        end if
      end do
c     Search for carbon and nitrogen next
      do i=n0,n
        if (ian(i) .eq. 6 .and. itypfg(i) .eq. 0) then
c         Unassigned carbon found
          nfg=nfg+1
          ityp=(10-(nneiga(i)*(nneiga(i)+1))/2)+nneigh(i)+1
          if (ityp .lt. 0) ityp=99
          indxfg(i)=nfg
          itypfg(i)=ityp
          nn=nneiga(i)
          if (nn .gt. 0) then
            do j=1,nn
              in=ineig(j,i)
              if (ian(in) .eq. 1 .and. itypfg(in) .eq. 0) then
                indxfg(in)=nfg
                itypfg(in)=ityp
              end if
            end do
          end if
        else if (ian(i) .eq. 7 .and. itypfg(i) .eq. 0) then
c         Unassigned nitrogen found
          nfg=nfg+1
          if (nneiga(i) .lt. 4)
     -      ityp=(6-(nneiga(i)*(nneiga(i)+1))/2)+nneigh(i)+11
c         Four neighbours, assumed to be positively charged
          if (nneiga(i) .eq. 4) ityp=23+nneigh(i)
          indxfg(i)=nfg
          itypfg(i)=ityp
          nn=nneiga(i)
          if (nn .gt. 0) then
            do j=1,nn
              in=ineig(j,i)
              if (ian(in) .eq. 1 .and. itypfg(in) .eq. 0) then
                indxfg(in)=nfg
                itypfg(in)=ityp
              end if
            end do
          end if
        end if
      end do
c     Label hydrogens on carbonyl
      do i=n0,n
        if (itypfg(i) .eq. 0 .and. nneiga(i) .gt. 0) then
c         Hydrogen on a C=O is type 18
          if (ian(i) .eq. 1 .and. itypfg(ineig(1,i)) .eq. 17) then
            nfg=nfg+1
            indxfg(i)=nfg
            itypfg(i)=18
          end if
        end if
      end do
c     Search for -S- (type 28) and -SH (type 29)
      do i=n0,n
        if (itypfg(i) .eq. 0 .and. ian(i) .eq. 16) then
c         Sulphur found
          if (nneiga(i) .eq. 2) then
c           -S-, -SH or HSH found
            if (nneigh(i) .gt. 0) then
c             -SH or HSH found
              itp=29
              nfg=nfg+1
              indxfg(i)=nfg
              itypfg(i)=itp
              do ing=1,2
                in=ineig(ing,i)
                if (ian(in) .eq. 1 .and. itypfg(in) .eq. 0) then
                  indxfg(in)=nfg
                  itypfg(in)=itp
                end if
              end do
            else
c             -S- found
              nfg=nfg+1
              indxfg(i)=nfg
              itypfg(i)=28
            end if
          end if
        end if
      end do
c     Assign the single atom funcional groups
      do i=n0,n
        if (itypfg(i) .eq. 0) then
          ianfgi=ianfg(ian(i))
          if (ianfgi .gt. 0) then
c           If no neighbours, must be an ion
            if (nneiga(i) .eq. 0) ianfgi=ianfgi+1
            nfg=nfg+1
            indxfg(i)=nfg
            itypfg(i)=ianfgi
          end if
        end if
      end do
c     Label all unassigned atoms
      do i=n0,n
        if (itypfg(i) .eq. 0) then
          nfg=nfg+1
          indxfg(i)=nfg
          itypfg(i)=99
        end if
      end do
c     Sort atoms by functional groups
      nmem=0
      do if=1,nfg
        ifgstr(if)=nmem+1
        do ia=n0,n
          if (indxfg(ia) .eq. if) then
            nmem=nmem+1
            ifgaix(nmem)=ia
          end if
          nfgmem(if)=nmem-ifgstr(if)+1
        end do
        ifgtyp(if)=itypfg(ifgaix(ifgstr(if)))
      end do
c     index (sort) fcg's by type
      nfgn=0
      do it=1,100
        do if=1,nfg
          if (ifgtyp(if) .eq. it) then
            nfgn=nfgn+1
            ixfg(nfgn)=if
          end if
        end do
      end do
c      if (nfg .gt. 1) then
cc       Sort functional groups
c        do 50 i=1,nfg
c          j1=i+1
c          do 50 j=j1,nfg
c            if (ifgtyp(i) .gt. ifgtyp(j)) then
c              ii=ifgtyp(i)
c              ifgtyp(i)=ifgtyp(j)
c              ifgtyp(j)=ii
c              ii=ifgstr(i)
c              ifgstr(i)=ifgstr(j)
c              ifgstr(j)=ii
c              ii=nfgmem(i)
c              nfgmem(i)=nfgmem(j)
c              nfgmem(j)=ii
c            end if
c50      continue
c      end if
      if (iwfg .gt. 0) then
c       Print list
        do igg=1,nfg
          ig=ixfg(igg)
          ig1=ifgstr(ig)
          ig2=ig1+nfgmem(ig)-1
          do iat=ig1,ig2
            iaa=ifgaix(iat)
            nna=nneig(iaa)
            if (inpcrdtyp .le. ioins) then
              write (iwfg,2045) igg,namfcg(ifgtyp(ig)),
     -          iaa,line(index(iaa))(ic1:ic2),
     -          line(index(iaa))(ir1:ir2),
     -          line(index(iaa))(irn1:irn2),(ineig(in,iaa),
     -          line(index(ineig(in,iaa)))(ic1:ic2),
     -          line(index(ineig(in,iaa)))(ir1:ir2),
     -          line(index(ineig(in,iaa)))(irn1:irn2),in=1,nna)
            else
              write (iwfg,2044) igg,namfcg(ifgtyp(ig)),
     -          iaa,iatnm2(ian(iaa)),(sp,ineig(in,iaa),
     -          iatnm2(ian(ineig(in,iaa))),in=1,nna)
            end if
          end do
        end do
      end if
      return
1000  format(' ERROR: phosporus(',i4,') has',i2,' oxygens')
1001  format(' ERROR: atom',i6,' (',a,1x,a,1x,a,' atomic no=',i2,')',
     -    ' has',i3,' neighbours: ',/,3(i6,' (',a,1x,a,1x,a,') '))
1002  format(' ERROR: atom',i6,', atomic no=',i2,
     -    ' has',i3,' neighbours: ',(10i6))
2044  format(' Fg',i6,2x,a4,' (',i5,1x,a2,')',' neighbours:',a1,
     -  '(',i5,1x,a2,')',a1,'(',i5,1x,a2,')',a1,'(',i5,1x,a2,')',a1,
     -  /,(5x,5('(',i5,1x,a2,')',a1)))
2045  format(' Fg',i6,2x,a4,' (',i5,1x,a4,1x,a4,1x,a,') Neigbours:',/,
     -  (9x,3('(',i5,1x,a4,1x,a4,1x,a,') ')))
      end
      subroutine breakbond(i1,i2,n0,n,nneig,ineig,nneiga,nneigh,ian,
     -  ifail,maxng)
      dimension nneig(n),ineig(maxng,n),nneiga(n),nneigh(n),ian(n)
      ifail=0
      if (i1 .lt. n0 .or. i1 .gt. n .or.
     -    i2 .lt. n0 .or. i2 .gt. n) then
        print *,'ERROR: invalid atomindices: ',i1,i2
        ifail=1
        return
      end if
      idel=0
      do in=1,nneiga(i1)
        if (ineig(in,i1) .eq. i2) idel=in
      end do
      if (idel .eq. 0) then
        write (6,1000) i2,i1
        ifail=1
      else
        if (ian(ineig(idel,i1)) .eq. 1) nneigh(i1)=nneigh(i1)-1
        do in=idel+1,nneig(i1)
          ineig(in-1,i1)=ineig(in,i1)
        end do
        nneig(i1)=nneig(i1)-1
        nneiga(i1)=nneiga(i1)-1
      end if
      return
1000  format(' ERROR: atom ',i5,' is not on the neighbour list of atom',
     -  i6)
      end
      subroutine bondord(iatnum,mmtype,nattot,nneig,ineig,nhneig,ibnd,
     -  maxneig,c,index,nntemp,nvalx,inc1,inc2,irc1,irc2,line,nconfig,
     -  maxrepconf,maxrec)
c     Establish the bond orders for Macromodel format (as best as possible)
      dimension c(3,nattot),iatnum(nattot),mmtype(nattot),nneig(nattot),
     -  ineig(maxneig,nattot),nhneig(nattot),ibnd(maxneig,nattot),
     -  index(nattot),nntemp(nattot),nvalx(nattot)
      character* 132 line(maxrec)
      character*2 iatnm2
      common /atnam/ aw(99),nval(99),nvalmax(99),mmofan(99),
     -  mmatno(64),iatnm2(99)
      character*4 dbonds(3,100),dbres(100),thisres,thisresl,
     -  atnaml,atnam1l
      character*8 resnam
      dimension ifres(100),ilres(100)
      real*8 cosa
      data jmin /0/
c     For residue dbres(1,i) there is a double bond between atoms
c     dbres(2,i) and dbres(3,i)
c     All names leftadjusted
      data dbonds /'TYR ','CG  ','CD1 ','TYR ','CE1 ','CZ  ',
     -  'TYR ','CE2 ','CD2 ','PHE ','CG  ','CD1 ',
     -  'PHE ','CE1 ','CZ  ','PHE ','CE2 ','CD2 ',
     -  'HSD ','CG  ','CD2 ',
     -  'TRP ','CG  ','CD1 ','TRP ','CD2 ','CE2 ',
     -  'TRP ','CZ2 ','CH2 ','TRP ','CZ3 ','CE3 ',
     -  'ADE ','C4  ','C5  ','GUA ','C4  ','C5  ',
     -  'CYT ','C5  ','C6  ','THY ','C5  ','C6  ',
     -  'URA ','C5  ','C6  ',
     -  252*'    '/,resnam /'     '/
c     Scan dbond list to find a list of special residues
      thisres='****'
      ndres=0
      do i=1,100
        if (thisres .ne. dbonds(1,i)) then
c         New residue in the double bond list
          thisres=dbonds(1,i)
          ndres=ndres+1
          dbres(ndres)=thisres
          ifres(ndres)=i
          if (ndres .gt. 1) ilres(ndres-1)=i-1
        end if
      end do
      ndres=ndres-1
      if (nconfig .eq. 1) then
        print  *,'Built in double bond list:'
        do i=1,ndres
          write (6,1101) i,dbres(i),
     -      (dbonds(2,j),dbonds(3,j),j=ifres(i),ilres(i))
        end do
      end if
c     Find hybridization
      ncgeneric=0
      do i=1,nattot
        mmtype(i)=0
c        write (77,9857) i,iatnum(i),(ineig(j,i),j=1,nneig(i))
c9857    format(i5,' atnum=',i3,' ing=',20i5)
        if (iatnum(i) .eq. 6 .or. iatnum(i) .eq. 7) then
          if (nneig(i) .eq. 4 .or.
     -        (iatnum(i) .eq. 7 .and. nneig(i) .eq. 3)) then
            mmtype(i)=3
          else if (nneig(i) .gt. 1) then
            angav=0
            do in=1,nneig(i)
c             Calculate angle betwen in-th and (in+1)th neigbor
              d1s=0.0
              d2s=0.0
              d12s=0.0
              in1=in+1
              if (in1 .gt. nneig(i)) in1=1
              do k=1,3
                dx1=c(k,ineig(in,i))-c(k,i)
                dx2=c(k,ineig(in1,i))-c(k,i)
                d1s=d1s+dx1*dx1
                d2s=d2s+dx2*dx2
                d12s=d12s+dx1*dx2
              end do
              cosa=dble(d12s)/sqrt(d1s*d2s)
              ang=(180.0/3.141592)*dacoscheck(cosa,ccc,1,6,'BONDORD')
              angav=angav+ang
            end do
            angav=angav/nneig(i)
            if (angav .gt. 150.0) then
              mmtype(i)=1
            else if (angav .gt. 117.0) then
              mmtype(i)=2
            else
              mmtype(i)=3
            end if
c            write (199,7171) i,line(index(i))(inc1:inc2),angav,mmtype(i)
c7171        format(i5,2x,a4,' angle=',f8.3,' mmtype(i)=',i2)
          else
            if (iatnum(ineig(1,i)) .eq. 16) then
              mmtype(i)=6
            else
              mmtype(i)=14
              ncgeneric=ncgeneric+1
            end if
          end if
        end if
      end do
c     See end-node carbons and nitrogens
      do i=1,nattot
        if (nneig(i) .eq. 1 .and.
     -    (iatnum(i) .eq. 6 .or. iatnum(i) .eq. 7)) then
          if (mmtype(ineig(1,i)) .eq. 1 .or.
     -        mmtype(ineig(1,i)) .eq. 2) then
            if (iatnum(i) .eq. 6) mmtype(i)=2
            if (iatnum(i) .eq. 7) mmtype(i)=1
          end if
          if (mmtype(ineig(1,i)) .eq. 3) mmtype(i)=3
        end if
      end do
c     Find bond orders
      do i=1,nattot
        if (nval(iatnum(i)) .le. 0)
     -    write (6,2005) i,iatnum(i),nval(iatnum(i))
c       nvalx is the excess valence
        nvalx(i)=nval(iatnum(i))-nneig(i)
        if (nvalx(i) .lt. 0) then
          if (nvalx(i)+(nvalmax(iatnum(i))-nval(iatnum(i))) .lt. 0 .and.
     -        nconfig .lt. maxrepconf) write (6,2001) i,line(index(i))
     -        (inc1:inc2),nneig(i),nval(iatnum(i)),iatnum(i)
          nvalx(i)=0
        else if (iatnum(i) .eq. 6 .and. nneig(i) .gt. 1 .and.
     -    nneig(i) .lt. 4 .and. nhneig(i) .eq. 0) then
c         For carbons than might be united atoms, deduce united atoms
c         Do end node atoms last
          if (nneig(i) .eq. 3) then
            if (mmtype(i) .eq. 3) nvalx(i)=nvalx(i)-1
          else if (nneig(i) .eq. 2) then
            if (mmtype(i) .eq. 2) nvalx(i)=nvalx(i)-1
            if (mmtype(i) .eq. 3) nvalx(i)=nvalx(i)-2
          end if
        end if
      end do
c     Look at end-node carbons
      do i=1,nattot
        if (iatnum(i) .eq. 6 .and. nneig(i) .eq. 1) then
          if (mmtype(ineig(1,i)) .eq. 1 .or.
     -        mmtype(ineig(1,i)) .eq. 2) nvalx(i)=nvalx(i)-2
          if (mmtype(ineig(1,i)) .eq. 3) nvalx(i)=nvalx(i)-3
        end if
      end do
c     Initialize bond orders to one
      do i=1,nattot
        nntemp(i)=nneig(i)
        do j=1,nneig(i)
          ibnd(j,i)=1
        end do
      end do
c     Scan the atom list to add the explicitly given double bonds
      thisres='****'
      do i=1,nattot
        resnam='        '
        resnam=line(index(i))(irc1:irc2)
        imod=0
        if (resnam(1:4) .ne. thisres) then
c         New residue
          thisres=resnam(1:4)
          call leftadjust4(thisres,thisresl)
          if (thisresl(1:2)  .eq. 'HS') thisresl='HSD '
c         See if there is double bond in the list for this residue
          do ir=1,ndres
            if (thisresl .eq. dbres(ir)) then
              imod=ir
              go to 1100
            end if
          end do
        end if
1100    if (imod .gt. 0) then
          call leftadjust4(line(index(i))(inc1:inc2),atnaml)
          do irl=ifres(imod),ilres(imod)
c           Check if atom (i) is in the dblist
            if (atnaml .eq. dbonds(2,irl)) then
c             Check the bonds of atom i against the list
              do j=1,nneig(i)
                in1=ineig(j,i)
                call leftadjust4(line(index(in1))(inc1:inc2),atnam1l)
                if (atnam1l .eq. dbonds(3,irl)) then
c                 Match found
                  ibnd(j,i)=ibnd(j,i)+1
                  nvalx(i)=nvalx(i)-1
c                 print *,'Added i,in1=',i,in1
                  do jj=1,nneig(in1)
                    if (ineig(jj,in1) .eq. i) then
                      ibnd(jj,in1)=ibnd(jj,in1)+1
                      nvalx(in1)=nvalx(in1)-1
                      go to 1200
                    end if
                  end do
                  print *,'Cant add reverse bond i,in1=',i,in1
                end if
              end do
            end if
          end do
        end if
1200    continue
      end do
      if (nconfig .eq. 1) write (6,2002)
c     Take care of atoms with one neighbours first, in an iterative fashion
      naddtot=0
      nvalerr=0
300   nadd=0
      do i=1,nattot
        if (nntemp(i) .eq. 1) then
          ii=i
200       in1=ineig(1,ii)
          nn1=nntemp(in1)
          do j=1,nn1
            if (ineig(j,in1) .eq. ii) jn1=j
          end do
          if (nvalx(ii) .gt. 0 .and. nvalx(in1) .gt. 0) then
c           Multiple terminal bond found, add to bond orders
            ndel=min0(nvalx(ii),nvalx(in1))
            nadd=nadd+ndel
            nvalx(ii)=nvalx(ii)-ndel
            nvalx(in1)=nvalx(in1)-ndel
            ibnd(1,ii)=ibnd(1,ii)+ndel
            ibnd(jn1,in1)=ibnd(jn1,in1)+ndel
c           Drop atom from further consideration
            if (nvalx(ii) .gt. 0) then
              nvalx(ii)=-nvalx(ii)
              nvalerr=nvalerr+1
            end if
            call swapng(ineig,ibnd,in1,jn1,nn1,nattot,maxneig)
            nntemp(ii)=0
            nntemp(in1)=nntemp(in1)-1
            if (nntemp(in1) .eq. 1) then
c             Immediate neigbour became an end node - repeat
              ii=in1
              go to 200
            end if
          end if
        end if
      end do
      naddtot=naddtot+nadd
      if (nadd .gt. 0) go to 300
      if (naddtot .gt. 0 .and. nconfig .le. maxrepconf)
     -   print *,naddtot,' tree bond orders added'
c     At this point only atoms in loops are left
      nadd=0
      do 310 i=1,nattot
        if (nvalx(i) .gt. 0) then
c         Distribute additional bond orders
          nn=nneig(i)
c         Find the neigbor with the lowest bond order
          ibomin=1000
          do j=1,nn
            if (nvalx(ineig(j,i)) .gt. 0 .and. ibomin .gt.
     -          ibnd(j,i)) then
              ibomin=ibnd(j,i)
              jmin=j
            end if
          end do
          if (ibomin .lt. 1000) then
            nadd=nadd+1
            ibnd(jmin,i)=ibnd(jmin,i)+1
            jn=ineig(jmin,i)
            nnj=nneig(jn)
            do k=1,nnj
              if (ineig(k,jn) .eq. i) ibnd(k,jn)=ibnd(k,jn)+1
            end do
            nvalx(i)=nvalx(i)-1
            nvalx(jn)=nvalx(jn)-1
            if (nvalx(i) .eq. 0) go to 310
          end if
        end if
310   continue
      if (nadd .gt. 0 .and. nconfig .le. maxrepconf)
     -  print *,nadd,' loop bond orders added'
c     Now see atoms with nvalmax > nval (like N)
      nadd=0
      do i=1,nattot
        if (nvalmax(iatnum(i)) .gt. nval(iatnum(i))) then
          if (nneig(i) .lt. nvalmax(iatnum(i))) then
            ibosum=0
            do in=1,nneig(i)
              ibosum=ibosum+ibnd(in,i)
            end do
            if (nvalx(i) .ge. 0) nvalx(i)=nvalmax(iatnum(i))-ibosum
            if (ibosum .lt. nvalmax(iatnum(i))) then
c             Check if any neighbor has unsatisfied valence
              do in=1,nneig(i)
                i1=ineig(in,i)
                if (nvalx(i1) .gt. 0) then
c                 Increase bond order of i-i1)
                  ibnd(in,i)=ibnd(in,i)+1
                  do in1=1,nneig(i1)
                    if (ineig(in1,i1) .eq. i)
     -                ibnd(in1,i1)=ibnd(in1,i1)+1
                  end do
                  nvalx(i1)=nvalx(i1)-1
                  if (nvalx(i) .gt. 0) nvalx(i)=nvalx(i)-1
                  nadd=nadd+1
                end if
              end do
            end if
          end if
        end if
      end do
      if (nadd .gt. 0) print *,nadd,' N+ type bond orders added'
      nswap=0
400   nvxe=0
      do i=1,nattot
        if (nvalx(i) .gt. nvalmax(iatnum(i))-nval(iatnum(i))) then
          nvxe=nvxe+1
        end if
      end do
      if (nvxe .gt. 0) then
c       See if loop double bonds can be swapped around
        nadd=0
        do i=1,nattot
c          write (77,9571) i,(ineig(j,i),j=1,nneig(i))
c9571      format(i4,' ing=',20i5)
          if (nvalx(i) .gt. 0 .and. iatnum(i) .ne. 7) then
c           Scan neighbor for atoms with multiple bond
            do in=1,nntemp(i)
              i1=ineig(in,i)
c             write (77,*) 'i,in,i1=',i,in,i1
              do in1=1,nntemp(i1)
                i2=ineig(in1,i1)
c                write (77,*) 'i,in1,i2=',i,in1,i2
                if (ibnd(in1,i1) .gt. 1 .and. i2 .ne. i) then
c                 Multiple bond was found in the neighborhood: i1-i2
c                 Check if i2 has a neighbor with unsatisfied valence
                  do in2=1,nntemp(i2)
                    i3=ineig(in2,i2)
c                   write (77,*) 'i,in2,i3=',i,in2,i3
                    if (i3 .ne. i1 .and. nvalx(i3) .gt. 0) then
c                     Decrement bond order of i1-i2; increment i-i1 and i2-i3
c                     First move the neig info to their new place
                      call swapng(ineig,ibnd,i2,in2,nntemp(i2),nattot,
     -                  maxneig)
                      do in3=1,nntemp(i3)
                        if (ineig(in3,i3) .eq. i2) call
     -                    swapng(ineig,ibnd,i3,in3,nntemp(i3),nattot,
     -                      maxneig)
                      end do
c                       write (77,*) 'i,i3,nntemp(i3)=',i,i3,nntemp(i3)
                      ibnd(nntemp(i3),i3)=ibnd(nntemp(i3),i3)+1
                      nvalx(i3)=nvalx(i3)-1
                      nntemp(i3)=nntemp(i3)-1
                      call swapng(ineig,ibnd,i,in1,nntemp(i),nattot,
     -                  maxneig)
                      do in21=1,nntemp(i1)
                        if (ineig(in21,i1) .eq. i) call
     -                    swapng(ineig,ibnd,i,in21,nntemp(i1),nattot,
     -                  maxneig)
                      end do
                      ibnd(nntemp(i),i)=ibnd(nntemp(i),i)+1
                      nvalx(i)=nvalx(i)-1
                      nntemp(i)=nntemp(i)-1
                      nadd=nadd+1
                      go to 410
                    end if
                  end do
                end if
              end do
            end do
          end if
410       continue
        end do
        nswap=nswap+nadd
        if (nadd .gt. 0) go to 400
      end if
      if (nswap .gt. 0) print *,nswap,' bond orders added by swapping'
      nvxe=0
      do i=1,nattot
        if (nvalx(i) .gt. nvalmax(iatnum(i))-nval(iatnum(i))) then
          nvxe=nvxe+1
        end if
      end do
      if (nconfig .lt. maxrepconf) write (6,2000) nvxe
c      do i=1,nattot
c        write (100,7711) i,iatnum(i),nneig(i),nvalx(i),
c     -      (ineig(j,i),ibnd(j,i),j=1,nneig(i))
c7711    format(i4,' atno=',i3,' nn=',i2,' nvalx=',i3,
c     -    ' ineig,iibnd=',6(i4,i2,2x))
c      end do
c     Finally, set atomtypes
      do i=1,nattot
        if (iatnum(i) .eq. 6) then
          nunsatur=mmtype(i)+1-nneig(i)
          if (nunsatur .gt. 0) then
c           Unsaturated carbon --> united atom
            if (mmtype(i) .eq. 3) mmtype(i)=3+nunsatur
            if (mmtype(i) .eq. 2) mmtype(i)=6+nunsatur
            if (mmtype(i) .eq. 1) mmtype(i)=9+nunsatur
          end if
c         Saturated carbon's atomtype is just the hybridization number
        else if (iatnum(i) .eq. 7) then
          if (mmtype(i) .eq. 3) then
            if (nneig(i) .eq. 4) then
              mmtype(i)=32
            else if (nneig(i) .eq. 3) then
              mmtype(i)=26
            else if (nneig(i) .eq. 2) then
              mmtype(i)=27
            else if (nneig(i) .eq. 1) then
              mmtype(i)=28
            end if
          else if (mmtype(i) .eq. 2) then
            if (nneig(i) .eq. 3) then
              mmtype(i)=31
            else if (nneig(i) .eq. 2) then
              mmtype(i)=25
            else if (nneig(i) .eq. 1) then
              mmtype(i)=30
            end if
          else if (mmtype(i) .eq. 1) then
            mmtype(i)=24
          end if
        else if (iatnum(i) .eq. 8) then
          if (nneig(i) .eq. 1 .and. ibnd(1,i) .eq. 2) then
            mmtype(i)=15
          else
            mmtype(i)=mmofan(iatnum(i))
          end if
        else if (iatnum(i) .eq. 1) then
          if (nneig(i) .lt. 1) then
            write (6,2003) i
            mmtype(i)=mmofan(iatnum(i))
          else
            if (iatnum(ineig(1,i)) .eq. 8) then
              mmtype(i)=42
            else if (iatnum(ineig(1,i)) .eq. 7) then
              mmtype(i)=43
            else if (iatnum(ineig(1,i)) .eq. 6 .or.
     -          iatnum(ineig(1,i)) .eq. 15 .or.
     -          iatnum(ineig(1,i)) .eq. 16) then
              mmtype(i)=41
            else
              mmtype(i)=mmofan(iatnum(i))
            end if
          end if
        else
          mmtype(i)=mmofan(iatnum(i))
        end if
      end do
      do i=1,nattot
        if (mmtype(i) .eq.  0) write (6,2004) i,iatnum(i),nneig(i)
      end do
      if (ncgeneric .gt. 0)
     -  print *,'WARNING:',ncgeneric,' carbon types were set to generic'
      return
c1201  format(1x,i3,6(1x,i5,1x,i1))
1101  format(i4,1x,a4,3x,10(' (',a4,'- ',a4,')'))
2000  format(' Number of atoms with unsatisfied valence=',i6)
2001  format(' WARNING: no of neigbours of atom',i5,'(',a4,')=',i2,
     -  ' exceeds valence (',i1,') ',' atno=',i4)
2002  format(' Bond orders will be determined by a simple algorithm',/,
     -  '   - possibly some multiple bonds will not be recognized',/,
     -  '   - for example, united atoms may not recognized as such')
2003  format(' WARNING: Hydrogen ',i6,' has no bond')
2004  format(' ERROR: Atom ',i5,' has no atomtype. ',/,
     -  8x,'Atomic number=',i3,' Number of neigbors=',i3)
2005  format(' ERROR: Atom ',i5,' atomic number ',i3,' has invalid ',
     -  'valence:',i3)
      end
      subroutine findbackbone(n0,n,iwout,nneig,ineig,
     -  nneiga,ineiga,in1,in2,ir1,ir2,line,blankline,index,iback,
     -  isideback,iparent,list,maxng,maxbox,maxrec)
c#    Based on MMC findcent
c*****Finds the backbone of a molecule
      dimension nneig(n),nneiga(n),ineig(maxng,n),ineiga(maxbox,n),
     -  index(n),iback(n),isideback(n),iparent(n),list(n)
      character* 132 line(maxrec),blankline,linep
c     First grow neigbour list from n0
c     print *,'FINDBACKBONE n0,n,maxbox=',n0,n,maxbox
      ifirst=n0
      ilast=0
      ibb=0
      do while (ilast .lt. n)
        write (iwout,1005)
        call growchain(n0,n,0,ifirst,ial,nsteps,nneig,ineig,
     -    list,iparent,iback,ilast,maxng)
c       Now grow from ial
        call growchain(n0,n,0,ial,iaf,lbackb,nneig,ineig,
     -    list,iparent,iback,iii,maxng)
c       Save nn list for manipulations
        do ia=n0,n
          nneiga(ia)=nneig(ia)
          call trnsfi(ineiga(1,ia),ineig(1,ia),nneig(ia))
        end do
c       Drop backbone atoms from nn list to avoid loopbacks
        do ia=1,lbackb
          iba=iback(ia)
          if (ia .gt. 1) then
            do in=1,nneiga(iba)
              if (ineiga(in,iba) .eq. iback(ia-1)) then
                ineiga(in,iba)=ineiga(nneiga(iba),iba)
                nneiga(iba)=nneiga(iba)-1
                go to 201
              end if
            end do
          end if
201       if (ia .lt. lbackb) then
            do in=1,nneiga(iba)
              if (ineiga(in,iba) .eq. iback(ia+1)) then
                ineiga(in,iba)=ineiga(nneiga(iba),iba)
                nneiga(iba)=nneiga(iba)-1
                go to 202
              end if
            end do
          end if
202       continue
        end do
        do ia=1,lbackb
          iba=iback(ia)
          do in=1,nneiga(iba)
            ina=ineiga(in,iba)
            do ja=1,nneiga(ina)
              if (ineiga(ja,ina) .eq. iba) then
                ineiga(ja,ina)=ineiga(nneiga(ina),ina)
                nneiga(ina)=nneiga(ina)-1
                go to 200
              end if
            end do
200         continue
          end do
        end do
c        do ia=n0,n
c          write (77,6733) ia,(ineiga(i,ia),i=1,nneiga(ia))
c6733      format(i5,' reduced nn=',30i4)
c        end do
        do ia=1,lbackb
c         If there is a sidechain, get its backbone too
          iba=iback(ia)
          ibn1=0
          lchainmax=0
          do in=1,nneiga(iba)
            ibna=ineiga(in,iba)
            if (nneiga(ibna) .gt. 0) then
c             write (77,*) 'ia,in,ib,ibna=',ia,in,ib,ibna
              call growchain(n0,n,iba,ibna,ial,nsteps,nneiga,ineiga,
     -          list,iparent,isideback,iii,maxbox)
              if (lchainmax .lt. nsteps) then
                lchainmax=nsteps
                ichainmax=ibna
              end if
            else if (ibn1 .eq. 0) then
c             (First) monovalent neighbor
              ibn1=ibna
            end if
          end do
          if (lchainmax .gt. 0) then
c           Get the chain from ichainmax
c           write (77,*) 'Longest sidechain:'
            call growchain(n0,n,iba,ichainmax,ial,nsteps,nneiga,ineiga,
     -        list,iparent,isideback,iii,maxbox)
          end if
c         Print line(s)
          linep=blankline
          ibb=ibb+1
          write (linep(20:26),1003) ibb
          write (linep(27:44),1000) iba,
     -      line(index(iba))(ir1:ir2),line(index(iba))(in1:in2)
          if (ibn1 .gt. 0) then
            write (linep(1:18),1000) ibn1,
     -        line(index(ibn1))(ir1:ir2),line(index(ibn1))(in1:in2)
            linep(18:18)='-'
          end if
          if (lchainmax .gt. 0) then
            ic0=44
            do ic=1,lchainmax
              icis=isideback(lchainmax-ic+1)
c             write (linep(ic0+1:ic0+18),1001) icis,
              write (linep(ic0+1:ic0+18),1000) icis,
     -          line(index(icis))(ir1:ir2),line(index(icis))(in1:in2)
              linep(ic0:ic0)='-'
              ic0=ic0+18
              if (mod(ic,2) .eq. 0 .and. ic .ne. lchainmax) then
                write (iwout,1002) linep(1:79)
                linep=blankline
                ic0=44
              end if
            end do
          end if
          write (iwout,1002) linep(1:79)
        end do
        if (ilast .ne. n) write (iwout,1004)
        ifirst=ilast+1
      end do
      return
1000  format(i5,' (',a4,a5,') ')
c1001  format(' -',i4,' (',a4,a5,') ')
1002  format(a)
1003  format('BB',i4,':')
1004  format(/,'New backbone start',/)
1005  format(/,' Backbone search ',/,
     -  ' BB  seqno: atomindex (residue name atom name)')
      end
      subroutine growchain(n0,n,n00,iaf,ial,nsteps,nneig,ineig,
     -  list,iparent,ichain,imax,maxng)
      dimension nneig(n),ineig(maxng,n),list(n),iparent(n),ichain(n)
c     write (77, *) 'GROWCHAIN n0,n,n00,iaf=',n0,n,n00,iaf
c     write (77, *) 'GROWCHAIN nforbid,iaforbid=',nforbid,iaforbid
      nsteps=0
      imax=0
      call zeroiti(iparent,n0-1,n)
      if (n00 .ne. 0) iparent(n00)=n00
      iparent(iaf)=iaf
      ic=iaf
      ilistf=1
      ilistl=1
      list(ilistf)=ic
      imax=ic
      do while (ilistl .ge. ilistf)
        nsteps=nsteps+1
        ilist=ilistl
        do il=ilistf,ilistl
          ic=list(il)
          do in=1,nneig(ic)
            ia=ineig(in,ic)
            if (ia .ge. n0 .and. ia .le. n) then
c             Consider only atoms within the range
              if (iparent(ia) .eq. 0) then
                iparent(ia)=ic
                ilist =ilist+1
                list(ilist)=ia
                if (ia .gt. imax) imax=ia
              end if
            end if
          end do
        end do
        ilistf=ilistl+1
        ilistl=ilist
      end do
c     nsteps is the number of vertices on the longest path, backtrack
      ial=list(ilist)
      ic=ial
      ichain(1)=ic
      do ia=2,nsteps+1
        ic=iparent(ic)
        ichain(ia)=ic
      end do
c      write (77,1000) n00,iaf,(ichain(ia),ia=1,nsteps+1)
c1000  format(' n00,iaf=',2i4,(' chain:',25i4))
      return
      end
      subroutine swapng(ineig,ibnd,ia,n1,n2,n,maxng)
      dimension ineig(maxng,n),ibnd(maxng,n)
c     Swap i-ia bond to the from n1 to n2 position
      if (n1 .lt. n2) then
        call swapi4(ineig(n1,ia),ineig(n2,ia))
c       ii=ineig(n1,ia)
c       ineig(n1,ia)=ineig(n2,ia)
c       ineig(n2,ia)=ii
        call swapi4(ibnd(n1,ia),ibnd(n2,ia))
c       ii=ibnd(n1,ia)
c       ibnd(n1,ia)=ibnd(n2,ia)
c       ibnd(n2,ia)=ii
      end if
      return
      end
      subroutine swapi4(i1,i2)
      ii=i1
      i1=i2
      i2=ii
      return
      end
      function lenchar(char,ic1,lenmax)
      character*(*) char
      ic=ic1
      call nextblank(char,ic,lenmax)
      lenchar=ic-1
      return
      end
      function ianum(inmm,nowarn,len)
      character*(*) inmm
      character*8 inm,inm1
      character*2 iatnm2
      common /atnam/ aw(99),nval(99),nvalmax(99),mmofan(99),
     -  mmatno(64),iatnm2(99)
      nbl=0
      do ic=1,len
        if (inmm(ic:ic) .eq. ' ') nbl=nbl+1
      end do
      if (nbl .eq. len) then
c       No atomname --> carbon
        ianum=6
        return
      end if
      inm(1:len)=inmm(1:len)
c     Shift to the left if first char is blank or a number
      nshft=0
      do while ((idigit(inm(1:1),1) .eq. 1 .or.
     -           inm(1:1) .eq. ' ') .and. nshft .le. len)
        nshft=nshft+1
        do i=1,len-1
          j=i+1
          inm1(i:i)=inm(j:j)
        end do
        inm=inm1
        inm(len:len)=' '
      end do
c     Set deuteriums to hydrogens
      if (inm(1:1) .eq. 'D') then
        ianum=1
        return
      end if
c     Check for the first two characters at first
      do i=1,40
        if (inm(1:2) .eq. iatnm2(i)) then
          ianum=i
          return
        end if
      end do
c     Check first characters only
      do i=1,40
        if (iatnm2(i)(2:2) .eq. ' ') then
          if (iatnm2(i)(1:1) .eq. inm(1:1)) then
            ianum=i
            return
          end if
        end if
      end do
      if (inm(1:1) .eq. 'W') then
c       Assume water
        ianum=8
        return
      end if
      if (nowarn .eq. 0) write (6,*)
     -  'ERROR: could not find atomic number for atom name ', inmm
      ianum=99
      return
      end
      function iabc(char)
      character*1 char
      character*1 abc,digits,hexdigits
      common /charactersets/ ihex(25),abc(62),digits(14),hexdigits(25)
      do i=1,52
        if (char .eq. abc(i)) then
          iabc=i
          return
        end if
      end do
      iabc=0
      return
      end
      function idigit(charx,ityp)
      character*1 charx
      character*1 abc,digits,hexdigits
      common /charactersets/ ihex(25),abc(62),digits(14),hexdigits(25)
c     ityp=0: allow space, +, -, ., ; ityp=1: only 0-9 is allowed
      idigit=0
      maxdig=10+(ityp-1)*4
      do i=1,maxdig
        if (charx .eq. digits(i)) then
          idigit=1
          return
        end if
      end do
      return
      end
      function ishexadecimal(stringtocheck,nchar)
      character*(*) stringtocheck
      character*1 abc,digits,hexdigits
      common /charactersets/ ihex(25),abc(62),digits(14),hexdigits(25)
      ishexadecimal=0
      do ic=1,nchar
        do i=1,25
          if (stringtocheck(ic:ic) .eq. hexdigits(i)) then
            ishexadecimal=1
            return
          end if
        end do
      end do
      return
      end
      function iconvhex(hexstring,nchar)
      character*(*) hexstring
      character*1 abc,digits,hexdigits
      common /charactersets/ ihex(25),abc(62),digits(14),hexdigits(25)
      character*1 ch1
      iconvhex=0
      iexp=0
      call lastchar(hexstring,ilc,nchar)
      do ic=ilc,1,-1
        ch1=hexstring(ic:ic)
        if (hexstring(ic:ic) .eq. '+') then
          return
        else if (hexstring(ic:ic) .eq. '-') then
          iconvhex=-iconvhex
          return
        else
          idig=-1
          do i=1,25
            if (ch1 .eq. hexdigits(i)) idig=ihex(i)
          end do
          if (idig .eq. -1)
     -      print *,'ERROR: invalid hexadecimal:',hexstring(1:nchar)
          iconvhex=iconvhex+idig*16**iexp
          iexp=iexp+1
        end if
      end do
      return
      end
      function isinteger(r,ndig,qoffset)
      ifac=10**ndig
      rfac=r*ifac
      if (rfac .gt. 0.0) rfac=rfac+0.1
      if (rfac .lt. 0.0) rfac=rfac-0.1
      irfac=int(rfac)
      isinteger=0
      if (mod(irfac,ifac) .eq. 0) isinteger=1
      rint=anint(r)
      qoffset=r-rint
      return
      end
      function ispdb(inpcrdtyp)
      character*5 crdext
      common /iotypes/ iocha,iochaex,iobpdb,iocpdb,ioa3pdb,ioa4pdb,
     -  iommod,iommc,iommc4,iogro,iomol2,iomae,ioins,ionxyz,
     -  iosxyz,iosxyzrq,iograsp,iofull,lext(17),crdext(17)
      ispdb=0
      if (inpcrdtyp .eq. iobpdb .or. inpcrdtyp .eq. iocpdb) ispdb=1
      if (inpcrdtyp .eq. ioa3pdb .or. inpcrdtyp .eq. ioa4pdb) ispdb=2
      return
      end
      function ischarmm(inpcrdtyp)
      character*5 crdext
      common /iotypes/ iocha,iochaex,iobpdb,iocpdb,ioa3pdb,ioa4pdb,
     -  iommod,iommc,iommc4,iogro,iomol2,iomae,ioins,ionxyz,
     -  iosxyz,iosxyzrq,iograsp,iofull,lext(17),crdext(17)
      ischarmm=0
      if (inpcrdtyp .eq. iocha .or. inpcrdtyp .eq. iochaex) ischarmm=1
      return
      end
      function isbonded(ia,ja,nneig,ineig,n,maxneig)
      dimension nneig(n),ineig(maxneig,n)
      isbonded=0
      do in=1,nneig(ia)
        if (ineig(in,ia) .eq. ja) then
          isbonded=1
          return
        end if
      end do
      return
      end
      subroutine sortatresrtf(line,n,nslt,index,indexn,indexo,isegno,
     -  itemp1,irescol1,irescol2,iresncol1,iresncol2,isegcol1,isegcol2,
     -  inamcol1,inamcol2,inpcrdtyp,nconfig,maxrec)
      character* 132 line(maxrec)
      dimension isegno(n),index(n),indexo(n),indexn(maxrec),itemp1(n)
c*****Sort atoms within a residue to follow an RTF order
      character*4 ires,reso,resn,atnam,sego,segn
      character*8 convdat
      character*200 sfilename
      common /savedat/ mxresdat,maxcondat,ifst(1000),ilst(1000),
     -  nres,iresgen,lsfilename,ires(1000),convdat(7,10000),sfilename
      character*5 crdext
      common /iotypes/ iocha,iochaex,iobpdb,iocpdb,ioa3pdb,ioa4pdb,
     -  iommod,iommc,iommc4,iogro,iomol2,iomae,ioins,ionxyz,
     -  iosxyz,iosxyzrq,iograsp,iofull,lext(17),crdext(17)
c     print *,'sortatresrtf n=',n
      nresproc=0
      natproc=0
      reso='    '
      sego='    '
      ireso=0
      nresnotfound=0
      ifaslt=1
      call trnsfi(indexo,index,n)
      call zeroiti(indexn,0,n)
      lench=irescol2-irescol1+1
      lens=isegcol2-isegcol1+1
      numlen=iresncol2-iresncol1+1
      do ia=1,n
        resn=line(index(ia))(irescol1:irescol2)
        segn=line(index(ia))(isegcol1:isegcol2)
        if (numlen .eq. 5) then
          read (line(index(ia))(iresncol1:iresncol2),1000,err=999) iresn
        else if (numlen .eq. 4) then
          read (line(index(ia))(iresncol1:iresncol2),1001,err=999) iresn
        else
          print *,'Invalid resnum length=',numlen
          stop
        end if
        if (ia .eq. n .or. iresn .ne. ireso .or.
     -      segn(1:lens) .ne. sego(1:lens)) then
c         End of residue found
          ilaslt=ia-1
          if (ia .eq. n) ilaslt=n
          nats=ilaslt-ifaslt+1
          if (nresproc .gt. 0) then
c           Find the residue
            call findname(reso,ires,1,nres,ix,lench)
c           print *,'nresproc,reso,ix=',nresproc,reso,ix
            if (ix .gt. 0) then
c             Check the number of atoms
              ifadb=ifst(ix)
              iladb=ilst(ix)
              natsdb=iladb-ifadb+1
              if (nats .ne. natsdb) write (6,2000) reso,nats,natsdb
c             Sort the residue
c              write (77,7712) ifadb,iladb,
c      -         (convdat(2,i)(1:4),i=ifadb,iladb)
c7712          format('ifadb,iladb=',2i4,' convdat2=',/(10a5,/))
              nnotfound=0
              natsdbfound=0
              do iaa=ifaslt,ilaslt
                atnam=line(index(iaa))(inamcol1:inamcol2)
                call leftadjust4(atnam,atnam)
                if (idigit(atnam(1:1),1) .eq. 1)
     -            call regularpdb(atnam,atnam,-1)
c               write (77,*) 'iaa,resnam,atnam=',iaa,reso,'*',atnam,'*'
                do ira=ifadb,iladb
                  if (atnam .eq. convdat(2,ira)(1:4)) then
                    indexn(ira-ifadb+ifaslt)=iaa
                    natsdbfound=natsdbfound+1
                    go to 100
                  end if
                end do
                write (6,2001) iaa,
     -            line(index(iaa))(inamcol1:inamcol2),reso
                nnotfound=nnotfound+1
                itemp1(nnotfound)=iaa
100             continue
              end do
              if (natsdbfound .lt. natsdb)
     -          write (6,2003) reso,natsdbfound,natsdb
              if (nnotfound .gt. 0) then
c6577  format(1x,a,' ifaslt,ilaslt=',2i5,' indexn:',(/,10i5))
c                write (6,6577) 'Before compacting',ifaslt,ilaslt,
c     -            (indexn(iaa),iaa=ifaslt,ilaslt)
c               First compact the index list
                ndel=0
                do iaa=ifaslt,ifaslt+iladb-ifadb+1
                  if (indexn(iaa) .gt. 0) then
                    indexn(iaa-ndel)=indexn(iaa)
                    if (ndel .gt. 0) indexn(iaa)=0
                  else
                    ndel=ndel+1
                  end if
                end do
                nmoved=0
                do iaa=ifaslt,ilaslt
                  if (indexn(iaa) .eq. 0) then
                    nmoved=nmoved+1
                    indexn(ilaslt-nnotfound+nmoved)=itemp1(nmoved)
                  end if
                end do
              end if
            else if (n .le. nslt) then
              nresnotfound=nresnotfound+1
              call indexit(indexn,ifaslt,ilaslt,0)
            end if
          end if
          nresproc=nresproc+1
          sego=segn
          reso=resn
          ireso=iresn
          ifaslt=ilaslt+1
        end if
      end do
      if (nresnotfound .gt. 0) print *,
     -  'The number of residues not found in the database=',nresnotfound
c     Now, indexn contains the new order (from 1 to n) or zero for
c     database atoms that were found no match.
c6711  format(1x,a,/,(30i4))
c      write (6,6711) 'index',(index(i),i=1,n)
c      write (6,6711) 'indexn',(indexn(i),i=1,n)
c     Check for missed atoms
      ndel=0
      do ia=1,n
        if (indexn(ia) .eq. 0) then
          ndel=ndel+1
          print *,'PROGRAM ERROR: atom ',ia,' is misplaced'
        end if
      end do
      if (ndel .gt. 0) then
        print *,'PROGRAM ERROR:',ndel,' atoms were not taken care of'
        print *,'- aborting rearrangement'
        return
      end if
c      write (6,6711) 'Cond indexn',(indexn(i),i=1,n)
      do ia=1,n
        index(ia)=indexo(indexn(ia))
c       isegno should be the same within residues
        isegno(ia)=isegno(indexn(ia))
      end do
c      write (6,6711) 'Cond index',(index(i),i=1,n)
      if (ndel .gt. 0) print *,'Number of atom records deleted=',ndel
      if (inpcrdtyp .eq. iommod) then
c       Macromodel, rerrange the connectivity
        do ia=1,n
          do ib=1,6
            ic1=6+(ib-1)*8
            ic2=ic1+4
c           write (6,888) ia,ib,ic1,ic2,iold
c888        format(' ia,ib=',2i3,' ic1,2=',2i3,' iold=',i3)
            read (line(index(ia))(ic1:ic2),1000) iold
            if (iold .gt. 0)
     -        write (line(index(ia))(ic1:ic2),1000) indexn(iold)
          end do
        end do
      end if
      if (nconfig .eq. 1) then
        print *,'Number of residues processed=',nresproc-1
        if (nresnotfound .gt. 0) then
           print *,'WARNING: ',nresnotfound,
     -     ' solute residues were not found in the RTF info file'
          call askstop(0)
        end if
      end if
      return
999   write (6,2002) ia,index(ia),line(index(ia))(iresncol1:iresncol2)
      stop
1000  format(i5)
1001  format(i4)
2000  format(' WARNING: number of atoms in the input residue ',a4,/,
     -  ' differs from the number in the RTF info file:',i5,' vs',i5)
2001  format(' No match was found for atom ',i4,2x,a4,' residue ',a4,/,
     -  ' - it will be moved to the end of this residue')
2002  format(' ERROR: invalid residue number for atom no',i5,
     - ' line no',i5,':',a)
2003  format(' WARNING: not all atoms in the input residue ',a4,/,
     -  ' were matched to the RTF info file:',i5,' vs',i5)
      end
      subroutine PDBtommc(resn,atomn,ptype,char,indx,gcent,igr,
     -  ideoxymmc,ifile,nunknown,nunknownr)
      character*1 gcent,ans1
      character*4 ptype
      character*8 resn,resnam,atomn,atomnam
      character*4 ires
      character*8 convdat,grpinfo
      character*200 sfilename
      common /savedat/ mxresdat,maxcondat,ifst(1000),ilst(1000),
     -  nres,iresgen,lsfilename,ires(1000),convdat(7,10000),sfilename
c     print *,'PDBtommc resn=',resn,' atomn=',atomn
      ptype='****'
      char=0.0
      gcent=' '
      igr=0
      call leftadjustn(atomn,atomnam,8)
      call leftadjustn(resn,resnam,8)
c     If residue name/atom name not found, check alternatives
      if (ifile .eq. 2) then
c       Original Amber
        if (resnam .eq. 'ADE     ' .or. resnam .eq. 'GUA     ' .or.
     -    resnam .eq. 'CYT     ') then
          if (ideoxymmc .eq. -1) then
c           Ask if oxy or deoxy NA
            call getname(ans1,len,
     -        'Nucleic acid type (D for Deoxy, R Oxy)',38,1,0)
            ideoxymmc=1
            if (ans1 .eq. 'r' .or. ans1 .eq. 'R') ideoxymmc=0
          end if
          resnam(2:4)=resnam(1:3)
          if (ideoxymmc .eq. 0) resnam(1:1)='R'
          if (ideoxymmc .eq. 1) resnam(1:1)='D'
        else if (resnam .eq. 'THY  ') then
          ideoxymmc=1
          resnam='DTHY    '
        else if (resnam .eq. 'URA     ') then
          resnam='RURA    '
          ideoxymmc=0
        end if
      else if (ifile .eq. 3) then
c       Amber 94
      else if (ifile .eq. 4) then
c       Charmm
      end if
c???
c     if (idigit(atomnam(1:1),1) .eq. 1) then
c       atomnam(1:4)=atomnam(2:5)
c       atomnam(5:5)=' '
c     end if
      do i=1,nres
c       write (77,*) 'resnam,ires(i)=',resnam,ires(i),' if,l=',ifst(i),ilst(i)
        if (resnam(1:4) .eq. ires(i)) then
          do j=ifst(i),ilst(i)
c            write (77,1077)
c     -        resnam,atomnam,convdat(1,j)(1:4),convdat(2,j)(1:4)
c1077        format(' rn,an=',a4,',',a4,'*',' cd1,2=',a4,',',a4,'*')
            if (atomnam(1:4) .eq. convdat(2,j)(1:4)) then
              ptype=convdat(3,j)(1:4)
              read (convdat(4,j),1001) char
              grpinfo=convdat(5,j)
              go to 100
            end if
          end do
c         If not found, try ACE, NME or DPOM or RPOM
c         since Amber uses these groups as different residues
          do ii=1,nres
            if (ires(ii) .eq. 'ACE ' .or. ires(ii) .eq. 'NME ' .or.
     -          (ires(ii)(2:4) .eq. 'POM' .and.
     -           ires(ii)(1:1) .eq. resnam(1:1))) then
              do j=ifst(ii),ilst(ii)
                if (atomnam(1:4) .eq. convdat(2,j)(1:4)) then
                  ptype=convdat(3,j)(1:4)
                  read (convdat(4,j),1001) char
                  grpinfo=convdat(5,j)
                  go to 100
                end if
              end do
            end if
          end do
          if (iresgen .gt. 0) then
c           Check if there are residue-name independent atomnames
            do j=ifst(iresgen),ilst(iresgen)
              if (atomnam(1:4) .eq. convdat(2,j)(1:4)) then
                ptype=convdat(3,j)(1:4)
                read (convdat(4,j),1001) char
                grpinfo=convdat(5,j)
                go to 100
              end if
            end do
          end if
          write (6,2000) atomnam,resnam,indx
          nunknown=nunknown+1
          return
100       if (grpinfo(1:5) .eq. 'GROUP') then
            read(grpinfo(6:6),1003) igcnt
            if (igcnt .eq. 1) gcent='G'
            read(grpinfo(7:8),1004) igr
          end if
          return
        end if
      end do
      write (6,2001) resnam
      nunknownr=nunknownr+1
      return
1001  format(f8.0)
1003  format(i1)
1004  format(i2)
2000  format(' ERROR: atomname=',a5,' resname=',a5,' (',i5,')',
     -  ' not found in conversion table')
2001  format(' ERROR: resname=',a4,' not found in conversion ',
     -  'table')
      end
      subroutine getconvdat(ifflist,ilflist,ncol,nconvdat,iconvtyp,
     -  n,line,index,inamcol1,inamcol2,nnamcol,irescol1,irescol2,
     -  igrpinfo,maxrec)
      character* 132 line(maxrec)
      dimension index(n)
      character*1 ans1
      character*80 inpline
      character*4 ires
      character*8 convdat
      character*200 sfilename
      common /savedat/ mxresdat,maxcondat,ifst(1000),ilst(1000),
     -  nres,iresgen,lsfilename,ires(1000),convdat(7,10000),sfilename
      character*8 atnam
      character*200 filenames(5)
      dimension iconvtyps(5),lfilenames(5)
      data lfilenames /18,15,11,13,13/,iconvtyps /2,1,1,1,2/
      data filenames /'cha_prot19_rtf.dat',
     -  'amb_prot_ua.dat','amb_all.dat','amb_all94.dat','cha_all22.dat'/
      character*57 RTFtyps
      common /explainRTF/ RTFtyps(4)
      if (ilflist .gt. 5) then
        print *,'PROGRAM ERROR: conversion list limit=',ilflist,' > 5'
        stop
      end if
      nleadsp=0
      nleaddigit=0
      igrpinfo=0
      do ia=1,n
        atnam(1:nnamcol)=line(index(ia))(inamcol1:inamcol2)
        if (atnam(1:1) .eq. ' ') nleadsp=nleadsp+1
        if (idigit(atnam(1:1),1) .eq. 1) nleaddigit=nleaddigit+1
      end do
      write (6,2006) RTFtyps
      write (6,2007) -1,'User-supplied',' ','RTF file'
      write (6,2007) 0,'User-supplied',
     -  ' conversion data file ','in Simulaid format'
      do i=ifflist,ilflist
        write (6,2007) i,'Simulaid-supplied ',
     -    'conversion data file ',filenames(i)(1:lfilenames(i))
      end do
120   call getint('The number corresponding to your choice',39,999999,
     -  0,ilflist,ifile,49)
      iconvtyp=0
      if (ifile .eq. 0) then
        call getname(sfilename,lsfilename,'Name of the conversion file',
     -    26,200,0)
        if (ncol .gt. 2) call quiz(ans1,iconvtyp,' ',' ',0,
     -    'PF label type',13,0,5,6,igl,00)
      else if (ifile .ge. ifflist) then
        sfilename=filenames(ifile)
        lsfilename=lfilenames(ifile)
        iconvtyp=iconvtyps(ifile)
      else if (ifile .ne. -1) then
        print *,'Invalid number'
        go to 120
      end if
      nconvdat=0
      ntypedat=0
      if (ifile .ge. 0) then
c       Read in conversion information
        iuconv=80
        call openfile(iuconv,0,'conversion information',22,'OLD',
     -    sfilename,lsfilename,notfnd,1,1,0,0,0)
        write (6,2005) sfilename(1:lsfilename)
        do while (.true.)
          read (iuconv,1001,end=110) inpline
          nconvdat=nconvdat+1
c         write (77,*) nconvdat,inpline
          if (nconvdat .lt. maxcondat) then
            read (inpline,*,err=999) (convdat(k,nconvdat),k=1,ncol)
          else
            write (6,2001) maxcondat
            stop
          end if
        end do
999     write (6,2000) i,inpline
        stop
110     close (iuconv)
        print *,'Number of conversions read=',nconvdat
      end if
      if (ifile .ge. 0)
     -    call askyn('Do you want to read RTF file(s) (too)',
     -      37,1,-1,ichrtf,0)
      if (ichrtf .eq. 1 .or. ifile .lt. 0) then
        call getrtfdat(nconvdat,5,iconvtyp,ntypedat)
      end if
c      do i=1,nconvdat
c        write (77,7711) i,(convdat(k,i),k=1,ncol)
c7711    format(i5,5(2x,a8))
c      end do
c     Find the residue limits in convdat
      nres=1
      iresgen=0
      ires(nres)=convdat(1,1)(1:4)
      ifst(nres)=1
      do i=2,nconvdat
        if (convdat(1,i) .ne. convdat(1,i-1)) then
c         New residue found
          ilst(nres)=i-1
          nres=nres+1
          if (nres .gt. mxresdat) then
            write (6,2004) mxresdat,sfilename(1:lsfilename)
            stop
          end if
          ires(nres)=convdat(1,i)(1:4)
          ifst(nres)=i
          if (ires(nres) .eq. '    ') iresgen=nres
        end if
      end do
      ilst(nres)=nconvdat
c     write (77,*) 'iresgen,nconvdat,nres=',iresgen,nconvdat,nres
c     do ii=1,nres
c       write (77,*) ii,ires(ii),ifst(ii),ilst(ii)
c     end do
      nleadspcd=0
      nleaddigitcd=0
      do i=2,nconvdat
        if (convdat(2,1)(1:1) .eq. ' ') nleadspcd=nleadspcd+1
        if (idigit(convdat(2,1)(1:1),1) .eq. 1)
     -    nleaddigitcd=nleaddigitcd+1
        if (convdat(5,nconvdat)(1:5) .eq. 'GROUP') igrpinfo=1
      end do
      ipdbin=0
      if (float(nleaddigit)/float(n) .gt. 0.01) ipdbin=1
      ipdbcd=0
      if (float(nleaddigitcd)/float(nconvdat) .gt. 0.01) ipdbcd=1
      if (ipdbin .eq. 1 .and. ipdbcd .eq. 0) then
        write (6,2002)
        call askyn('Do you want to de-regularize them',33,1,1,idereg,0)
        if (idereg .eq. 1) then
          call fixrecform(line,index,n,3,inamcol1,inamcol2,
     -      irescol1,irescol2,maxrec)
        end if
      end if
      return
1001  format(a80)
2000  format(' ERROR: invalid conversion data record, record no:',
     -  i5,':',a)
2001  format(' ERROR: Data file has more than',i5,' lines')
2002  format(' Input names appear to be in regular PDB format ',
     -  '(e.g., 2HG1)',/,'but the conversion data do not (i.e., HG12)')
2004  format(' ERROR: Maximum number of different residues ',
     -  '(',i4,') is exceeded in file',/,5x,a)
2005  format(' Residue and atomname conversion table is in file ',a)
2006  format(/,' Conversion information can be obtained from ',/,
     -  3x,'a) conversion data files (see list below) and/or',/,
     -  3x,'b) RTF file(s) ',/,4(a,/),
     -  /,' Current options:')
2007  format(i3,2x,a,a,a)
      end
      subroutine getrtfdat(nconvdat,ncol,iconvtyp,ntypedat)
      character*80 linep,linech,lineprev
      character*4 ires,resnam,atnam,atnamo,potnam,attyp
      character*200 sfilename,rtffile,parmfile
      character*8 convdat
      common /savedat/ mxresdat,maxcondat,ifst(1000),ilst(1000),
     -  nres,iresgen,lsfilename,ires(1000),convdat(7,10000),sfilename
      character*1 lc
      dimension sig(1000),eps(1000),attyp(1000)
      data ictyp /0/,igrprev /0/,numat /0/
C     Read Charmm Amber or Gromacs topology (RTF) file
      nconvdat0=nconvdat
      iconvtyp=0
200   namlena=0
      call openfile(15,0,'RTF',3,'old',rtffile,namlena,notfnd,0,1,1,0,0)
c     First figure out if Amber, Charmm, or Gromacs
      ifound=0
      nlread=0
      do while (ifound .eq. 0)
        read (15,1000,end=999) linech
        ic=1
        if (linech(1:1) .eq. ' ') call nextchar(linech,ic,80)
        if (linech(ic:ic+3) .eq. 'DONE') then
          ifound=1
          ictyp=1
          write (6,2002) 'Amber'
        else if (linech(ic:ic+3) .eq. 'RESI' .or.
     -           linech(ic:ic+3) .eq. 'PRES') then
          ifound=1
          ictyp=2
          write (6,2002) 'Charmm'
        else if (linech(ic:ic) .eq. '[') then
          ifound=1
          ictyp=3
          write (6,2002) 'Gromacs'
          print *,'NOTE: only four-character names are used for now'
        end if
      end do
      if (iconvtyp .gt. 0) then
        if (iconvtyp .ne. ictyp) then
          write (6,2003)
          iconvtyp=0
        end if
      else
        iconvtyp=ictyp
      end if
      rewind 15
      if (iconvtyp .eq. 1) then
c       Read Amber RTF
        read (15,1000) linech
        read (15,1000) linech
        ic=1
        call nextblank(linech,ic,80)
        write (6,2004) linech(1:ic-1)
        read (15,1000) linech
        nlread=3
        do while (linech(1:4) .ne. 'STOP')
          read (15,1000,end=999) linech
          read (15,1000,end=999) linech
          nlread=nlread+2
          ic=1
          if (linech(1:1) .ne. ' ') icinc=-1
          if (linech(ic:ic) .eq. ' ') call nextchar(linech,ic,80)
          resnam=linech(ic:ic+3)
          read (15,1000) linech
          read (15,1000) linech
          read (15,1000) linech
          nlread=nlread+3
          atnam='xxxx'
          atnamo=atnam
c         write (77,*) 'resnam=',resnam
          do while (atnam .ne. '    ')
            call blankout(linech,1,80)
            read (15,1000) linech
            nlread=nlread+1
            ic=1
            call nextchar(linech,ic,80)
            if (ic .eq. 80) then
              atnam='    '
            else
              call nextblank(linech,ic,80)
              call nextchar(linech,ic,80)
              atnam=linech(ic:ic+3)
c             write (77,*) 'atnam=',atnam
              if (atnam .ne. atnamo .and. atnam .ne. 'DUMM') then
                nconvdat=nconvdat+1
                do icl=1,ncol
                  convdat(icl,nconvdat)='        '
                end do
c               Residue name
                convdat(1,nconvdat)(1:4)=resnam
c               Atom name
                convdat(2,nconvdat)(1:4)=atnam
c               Atom type
                call nextblank(linech,ic,80)
                call nextchar(linech,ic,80)
                convdat(3,nconvdat)(1:2)=linech(ic:ic+1)
                do is=1,8
                  call nextblank(linech,ic,80)
                  call nextchar(linech,ic,80)
                end do
                ic1=ic
                call nextblank(linech,ic,80)
c               Charge
                convdat(4,nconvdat)(1:ic-ic1)=linech(ic1:ic-1)
                write (convdat(5,nconvdat),2001) 1,1
                atnamo=atnam
c               write (77,7711)nconvdat,(convdat(ic,nconvdat),ic=1,ncol)
c7711            format(i5,7(1x,'|',a8,'|'))
              end if
            end if
          end do
c         Search for DONE
          do while (linech(1:4) .ne. 'DONE')
            read (15,1000) linech
            nlread=nlread+1
          end do
          read (15,1000,end=999) linech
          nlread=nlread+1
        end do
      else if (iconvtyp .eq. 2) then
c       Read Charmm RTF
        igr=0
        newgr=1
        do while (.true.)
          read (15,1000,end=999) linech
          nlread=nlread+1
          ic=1
          if (linech(1:1) .eq. ' ') call nextchar(linech,ic,80)
          if (linech(ic:ic+3) .eq. 'RESI' .or.
     -        linech(ic:ic+3) .eq. 'PRES') igr=0
          if (linech(ic:ic+3) .eq. 'GROU') then
            igr=igr+1
            newgr=1
          else if (linech(ic:ic+3) .eq. 'ATOM') then
            nconvdat=nconvdat+1
            do icol=1,ncol
              convdat(icol,nconvdat)='        '
            end do
c           Residue name
            convdat(1,nconvdat)(1:4)=resnam
c           Atom name
            ic=ic+4
            call nextchar(linech,ic,80)
            convdat(2,nconvdat)(1:4)=linech(ic:ic+3)
            ic=ic+4
c           Atom type
            call nextchar(linech,ic,80)
            convdat(3,nconvdat)(1:4)=linech(ic:ic+3)
            ic=ic+4
            ic0=ic
            lc=linech(ic:ic)
            do while (idigit(lc,2) .eq. 1 .and. ic .lt. ic0+14)
              ic=ic+1
              lc=linech(ic:ic)
            end do
            if (ic-ic0 .gt. 2) then
              call readreal(linech,ic0,ic-1,charge)
            else
              charge=0.0
              write (6,2006) (convdat(k,nconvdat)(1:4),k=1,3)
            end if
            write (convdat(4,nconvdat),2000) charge
            write (convdat(5,nconvdat),2001) newgr,igr
            if (newgr .eq. 1) newgr=0
          else if (linech(ic:ic+3) .eq. 'RESI' .or.
     -             linech(ic:ic+3) .eq. 'PRES') then
c           print *,'RES ',resnam,' done'
            resnam='    '
            ic=ic+4
            call nextchar(linech,ic,80)
            icl=ic
            call nextblank(linech,ic,80)
            resnam=linech(icl:ic-1)
          end if
        end do
      else
c       Read Gromacs RTF (.rtp) files
        lookres=1
        do while (.true.)
          call blankout(linech,1,80)
          read (15,1000,end=999) linech
          nlread=nlread+1
          ic=1
          if (linech(ic:ic) .eq. ' ') call nextchar(linech,ic,80)
100       if (lookres .eq. 1) then
            if (linech(ic:ic) .eq. '[') then
              call nextblank(linech,ic,80)
              call nextchar(linech,ic,80)
              if (linech(ic:ic+4) .eq. 'atoms') then
c               Residue found
                igrprev=0
                ic=1
                call getname4(ic,lineprev,resnam,80,1)
                call getname4(ic,lineprev,resnam,80,1)
                lookres=0
                numat=0
              end if
              lineprev=linech
            end if
          else
c           Read record
            if (linech(ic:ic) .eq. '[') then
c             Residue ended
              lookres=1
              lineprev=linech
              if (numat .eq. 1) go to 100
            else
              call getname4(ic,linech,atnam,80,1)
              call getname4(ic,linech,potnam,80,-1)
              if (ic .gt. 72) then
c               Residue ended
                lookres=1
              else
                nconvdat=nconvdat+1
                numat=numat+1
                do icol=1,ncol
                  convdat(icol,nconvdat)='        '
                end do
c               Residue name
                convdat(1,nconvdat)(1:4)=resnam
c               Atom name
                convdat(2,nconvdat)(1:4)=atnam
c               Atom type
                convdat(3,nconvdat)(1:4)=potnam
                call nextchar(linech,ic,80)
                icf=ic
                call nextblank(linech,ic,80)
                read (linech(icf:ic-1),*,err=900) charge
                write (convdat(4,nconvdat),2000) charge
                call nextchar(linech,ic,80)
c               print *,'names=',resnam,atnam,potnam
c               print *,'charge=',charge,' ic=',ic,' lic=',linech(ic:ic)
                read (linech(ic:ic),*,err=900) igr
                newgr=0
                if (igr .ne. igrprev) newgr=1
                write (convdat(5,nconvdat),2001) newgr,igr
                igrprev=igr
              end if
            end if
          end if
        end do
      end if
999   close (15)
      print *,'Finished reading',nlread,' lines'
      if (ictyp .eq. 0) then
        print *,'ERROR: file ',rtffile(1:namlena),' is not an RTF file'
      else
        print *,'Number of conversions read from this file=',
     -    nconvdat-nconvdat0
      end if
      call askyn('Do you have an other RTF file',29,1,0,morefile,0)
      if (morefile .eq. 1) go to 200
      if (ncol .gt. 5) then
        ntypedat=0
300     namlenp=0
        call openfile(16,0,'PARAM',5,'old',parmfile,namlenp,notfnd,
     -    0,1,1,0,0)
c       Extract L-J eps and sigma values for atomtypes
        if (ictyp .eq. 1) then
c         Amber
          print *,'Amber parameter file read is not implemented yet'
        else if (ictyp .eq. 2) then
c         Charmm
          linep(1:4)='    '
          do while (linep(1:4) .ne. 'NONB')
            read (16,1000) linep
          end do
          call lastchar(linep,ic,80)
c         Skip continuation line(s)
          lc=linep(ic:ic)
          do while (lc .eq. '-')
            read (16,1000) linep
            call lastchar(linep,ic,80)
            lc=linep(ic:ic)
          end do
c         Keep reading until blank line is found
          do while (ic .gt. 1)
            linep(1:1)=' '
            read (16,1000,end=998) linep
            icf=1
            call nextchar(linep,icf,80)
            if (icf .lt. 80) then
c             Read record
              ntypedat=ntypedat+1
              attyp(ntypedat)=linep(icf:icf+3)
c             Skip one number
              icf=icf+3
              call nextchar(linep,icf,80)
              call nextblank(linep,icf,80)
c             Read eps
              call nextchar(linep,icf,80)
              icl=icf
              call nextblank(linep,icl,80)
              call readreal(linep,icf,icl-1,epsilon)
c             Read sigma
              icf=icl
              call nextchar(linep,icf,80)
              icl=icf
              call nextblank(linep,icl,80)
              call readreal(linep,icf,icl-1,sigma)
              eps(ntypedat)=-epsilon
              sig(ntypedat)=2.0*sigma/2.0**(1.0/6.0)
c             write (77,*) 'ntypedat,eps,sig=',
c    -            ntypedat,eps(ntypedat),sig(ntypedat)
            end if
            call lastchar(linep,ic,80)
            if (ic .eq. 1 .and. linep(1:1) .eq. '!') ic=2
          end do
          print *,'Read ',ntypedat,' nonbonded parameters'
        else if (ictyp .eq. 3) then
c         Gromacs
          print *,'Gromacs parameter file read is not implemented yet'
        end if
998     close (16)
        call askyn('Do you have an other PARAM file',31,1,0,morefile,0)
        if (morefile .eq. 1) go to 300
c       write (77,2006) (attyp(i),eps(i),sig(i),i=1,ntypedat)
c2006  format(' Atom type   Eps     sigma',/,(5x,a4,2x,f8.4,f8.4))
        notype=0
        do ic=1,nconvdat
c         Find type, extract eps & sigma
          do it=1,ntypedat
            if (convdat(3,ic)(1:4) .eq. attyp(it)) then
              write (convdat(6,ic),2000) eps(it)
              write (convdat(7,ic),2000) sig(it)
              go to 980
            end if
            notype=notype+1
            write (convdat(6,ic),2000) 0.0
            write (convdat(7,ic),2000) 0.0
          end do
980       continue
        end do
        if (notype .gt. 0) print *,'WARNING: ',notype,
     -  ' atoms in the RTF file have no LJ parameters'
      end if
c     write (77,*) 'nconvdat=',nconvdat
c     do ncd=1,nconvdat
c       write (77,7711) ncd,(convdat(ic,ncd),ic=1,ncol)
c     end do
c7711  format(i5,7(1x,'|',a8,'|'))
      return
900   write (6,2005) linech,resnam,atnam,potnam,charge,igr
1000  format(a)
2000  format(f8.4)
2001  format('GROUP',i1,i2)
2002  format(' RTF file is in ',a,' format')
2003  format(' ERROR: RTF file  format is incompatible with the ',
     -  'conversion file read')
2004  format(' Amber database name:',a)
2005  format(' ERROR in Gromacs atom record :',/,a,/,' resnam=',
     -  a4,' atnam=',a4,' potnam=',a4,' charge=',f7.4,' igr=',i2)
2006  format(' WARNING: residue ',a,' atom ',a,' type ',a,
     -  ' has no charge entry (0 is assumed)')
      end
      subroutine find_ambertyp(inpt,flag,lflag,form,lform)
      character*(*)flag,form
      character*80 liner
      rewind inpt
      liner(1:1)=' '
      do while (liner(1:lflag) .ne. flag(1:lflag))
        read(inpt,1010,end=100) liner
      end do
      call blankout(liner,1,80)
      read(inpt,1010,end=100) liner
      if (liner(1:7) .eq. '%FORMAT') then
        call lastchar(liner,lc,80)
        form=liner(8:lc)
        lform=lc-7
      end if
      return
100   print *,'Format not found after flag ',flag(1:lflag)
1010  format(a)
      stop
      end
      subroutine findname(name,list,ifrst,lenlist,ix,lench)
      character*(*) name,list
      dimension list(lenlist)
      ix=0
c     write (6,*) 'FINDNAME ifrst,lenlist,name=',ifrst,lenlist,name
c      write (77,7711) (list(i),i=1,lenlist)
c7711  format(10a5)
      do i=ifrst,lenlist
        if (name(1:lench) .eq. list(i)(1:lench)) then
          ix=i
          return
        end if
      end do
      return
      end
      subroutine checkdupnames(namelist,lnamelist,n,label,llabel,idup)
      character*(*) namelist,label
      dimension namelist(n)
c     Checks list of names for duplicates
      idup=0
      do i=2,n
        call findname(namelist(i),namelist,1,i-1,ix,lnamelist)
        if (ix .gt. 0) then
          idup=1
          if (llabel .gt. 0) write (6,1000) label(1:llabel),
     -        i,ix,namelist(i)(1:lnamelist)
        end if
      end do
      return
1000  format(' Duplicate found in list ',a,
     -  ': list(',i4,')=list(',i4,')=',a)
      end
      subroutine maketraj(nconfig,maxconf,c,c1,rprox,cv,ih,nslt,n,naslv,
     -  islvw,ntitltr,trtitle,line,inpcrdtyp,newinp,inptrajtyp,
     -  ioutrajtyp,mmctrajtyp,iout,iatnum,ifchrg,innlist,iresno,ixres,
     -  atnames,resnames,segnames,charge,isegno,marker,ntitlin,title,
     -  ireseq,iresnrestart,iresidrestart,nneig,nneiga,nhbneig,ineig,
     -  nhneig,nnneig,ncneig,nsneig,npneig,numres,numslv,resnamslv,
     -  blankline,mmtype,ibnd,index,indexn,indexo,indexs,icntrl,icntrlr,
     -  ifree,molresflag,idupl,ireorder,icellfound,natsdel,nwrmax,
     -  hblimfac,angmin,iqspaceask,keeprem,iwriteatsym,radtodeg,etot,
     -  noheadchange,maxrepconf,maxng,mxres,maxrec)
      dimension icntrl(20),icntrlr(20),ifree(n)
      character*80 trtitle(32)
      character* 132 line(maxrec),blankline
      character*80 title
      character*4 segnames(mxres)
      character*8 resnamslv,atnames(maxrec),resnames(mxres)
      character*6 marker(16)
      dimension c(3,maxrec),c1(3,maxrec),rprox(maxrec),cv(maxrec),
     -  ih(maxrec),nneig(maxrec),ineig(maxng,maxrec),iatnum(maxrec),
     -  ifchrg(maxrec),charge(maxrec),nhbneig(maxrec),nneiga(maxrec),
     -  nhneig(maxrec),nnneig(maxrec),ncneig(maxrec),nsneig(maxrec),
     -  npneig(maxrec),isegno(maxrec),iresno(maxrec),ixres(maxrec),
     -  mmtype(maxrec),ibnd(maxng,maxrec),index(maxrec),indexn(maxrec),
     -  indexo(maxrec),indexs(maxrec),molresflag(mxres),idupl(mxres)
      character*5 crdext
      common /iotypes/ iocha,iochaex,iobpdb,iocpdb,ioa3pdb,ioa4pdb,
     -  iommod,iommc,iommc4,iogro,iomol2,iomae,ioins,ionxyz,
     -  iosxyz,iosxyzrq,iograsp,iofull,lext(17),crdext(17)
      real*8 xtlabc,xtlabc0
      common /boxdat/ xtlabc(6),xtlabc0(6),box(3),box0(3),edge_gen(3,3),
     -  cell0(3,27),cell(3,27),cellalt(3,27),
     -  ncell,ioppbc,noboxinfoar,noboxinfow,noboxrep,
     -  istuner,iboxtypfound,ixcrd(3),ixang(3),ixyzhex(3),
     -  ixyzhextraj(3),isizewarn
      character*1 xyz
      common /axislab/ xyz(3)
      common /saveinfo/ nwrite,nfreeatwrite
      character*4 pflsv(100)
      character*8 namesv(100)
      dimension cmin(3),cmax(3),shiftmmc(3),iasv(100),qsv(100)
      real*8 detot
      data ifsavdef /1/,incrtdef /1/,ifsavvdef/0/,ichvers /27/,
     -  nfixatdef /0/,tsfsdef /1.0/,ndegfree /0/
      character*4 charmmheader(2)
      character*11 charmmheadname(2)
      data charmmheader/'CORD','VELD'/
      data charmmheadname/'coordinates','velocities '/
c     print *,'MAKETRAJ nslt,n,naslv=',nslt,n,naslv
c     print *,'MAKETRAJ ioutrajtyp,ioppbc,icntrlr(11)=',
c    -  ioutrajtyp,ioppbc,icntrlr(11)
      limic11=1
      if (nconfig .eq. 1) then
        limic11=0
        nwrite=n-natsdel
        if (natsdel .gt. 0)
     -    print *,'Number of atoms written in a configuration=',nwrite
c       Create and write header
        if (ioppbc .eq. -1) then
          do k=1,3
            box0(k)=999.0
            box(k)=999.0
          end do
          noboxinfow=1
        else
          noboxinfow=0
        end if
c       Decide about cell info writing
        iboxdef=-1
        if (iboxtypfound .gt. 0) iboxdef=1
        if ((ioutrajtyp .eq. 1 .or. ioutrajtyp .eq. 3) .and.
     -       ioppbc .ge. 0)
     -    call askyn('Do you want box information written',35,
     -      0,iboxdef,noboxinfow,0)
        if (ioutrajtyp .eq. 1) then
c         Charmm
          if (noheadchange .eq. 0) then
            if (noboxinfow .eq. 0) then
              icntrl(11)=1
              if (ioppbc .ge. 0) then
                irepdef=-1
                if (iboxtypfound .gt. 1) irepdef=1
                write (6,1104)
                call askyn('Do you want repeated box information',36,
     -            0,irepdef,noboxrep,0)
                if (noboxrep .eq. 0) icntrl(11)=2
              end if
              if (noboxinfoar .eq. -1) then
c               Input box size
                print *,'Only rectangular box input is implemented'
                do k=1,3
                  call getreal(
     -              'Box dimension in the '//xyz(k)//' direction',32,
     -              999999.0,xk,1,0)
                  xtlabc(ixcrd(k))=xk
                  xtlabc(ixang(k))=90.0d0
                end do
              end if
            else
              icntrl(11)=0
              call zeroitd(xtlabc,6)
            end if
          else
            icntrl(11)=icntrlr(11)
          end if
        else if (ioutrajtyp .eq. 2) then
c         Amber
          noboxrep=1
          irepdef=-1
          if (iboxtypfound .gt. 1) irepdef=1
          if (ioppbc .ge. 0) then
            call askyn('Do you want repeated box information',36,
     -        0,irepdef,noboxrep,127)
          end if
          if (inptrajtyp .eq. 1. and. icntrl(11) .ne. -1) then
c           Use Charmm box size
            do k=1,3
              box(k)=xtlabc(ixcrd(k))
            end do
          else if (icellfound .eq. 0 .and. ioppbc .ge. 0) then
c           Input box size
            do k=1,3
              call getreal(
     -          'Initial box dimension in the '//xyz(k)//' direction',
     -          40,999999.0,box(k),1,0)
            end do
          end if
        end if
        if (ioutrajtyp .eq. 1) then
c         Charmm
          icntrl(1)=maxconf
          if (inptrajtyp .eq. 1) then
            incrtdef=icntrlr(2)
            ifsavdef=icntrlr(3)
            ifsavvdef=icntrlr(5)
            ndegfree=icntrlr(8)
            nfixatdef=icntrlr(9)
            ichvers=icntrlr(20)
c           call copybits(icntrlr(10),tsakma)
            call copyintgreal(icntrlr(10),tsakma,1)
            tsfsdef=tsakma*48.88821
          end if
          if (noheadchange .eq. 0) then
            call getint('Number of fixed atoms to put in the header',
     -        42,nfixatdef,1,n,icntrl(9),50)
            call getint(
     -        'Coordinate saving frequency to put in the header',48,
     -        ifsavdef,1,0,icntrl(3),50)
            call getint('Previous run steps to put in the header',39,
     -        incrtdef,1,0,icntrl(2),50)
            call getint(
     -        'Velocity saving frequency to put in the header',46,
     -        ifsavvdef,1,0,icntrl(5),50)
            call getint('Charmm version to put in the header',35,
     -        ichvers,1,40,icntrl(20),50)
            call getreal('Time step/fs to put in the header',33,tsfsdef,
     -        tsfs,1,0)
            tsakma=tsfs/48.88821
c           call copybits(tsakma,icntrl(10))
            call copyintgreal(icntrl(10),tsakma,0)
            icntrl(4)=maxconf*ifsavdef
            print *,'Number of creation steps=',icntrl(4)
            call askyn(
     -       'Do you want to create a velocity trajectory (VELD)',50,
     -       1,-1,icharmmheader,0)
            icharmmheader=icharmmheader+1
            write (6,1103) charmmheadname(icharmmheader),
     -        charmmheader(icharmmheader)
          else
            icntrl(2)=icntrlr(2)
            icntrl(3)=icntrlr(3)
            icntrl(5)=icntrlr(5)
            icntrl(8)=icntrlr(8)
            icntrl(9)=icntrlr(9)
            icntrl(10)=icntrlr(10)
            icntrl(20)=icntrlr(20)
            icharmmheader=1
          end if
          nfreeat=n-icntrl(9)
          nfreeatwrite=nfreeat
          nfadel=0
          if (natsdel .gt. 0) then
c           See if nfreeat has to be reduced when solvents are dropped
            if (ioutrajtyp .eq. 1 .and. icntrl(9) .gt. 0) then
              nfadel=0
              do ia=1,nfreeat
                if (indexs(ifree(ia)) .eq. 0) then
                  nfadel=nfadel+1
                else
                  ifree(ia-nfadel)=ifree(ia)
                end if
              end do
              nfreeatwrite=nfreeat-nfadel
            end if
          end if
          if (inptrajtyp .eq. 1) then
            if (natsdel .gt. 0) ndegfree=ndegfree-3*nfadel
          else
            ndegfree=nfreeatwrite*3-6
          end if
          icntrl(8)=ndegfree
          write (iout) charmmheader(icharmmheader),icntrl
          write (iout) ntitltr,(trtitle(i),i=1,ntitltr)
          write (iout) nwrite
          if (icntrl(9) .gt. 0) write (iout) (ifree(i),i=1,nfreeatwrite)
        else if (ioutrajtyp .eq. 2) then
c         Amber
          write (iout,1000) trtitle(1)
        else if (ioutrajtyp .eq. 3) then
c         MMC
c         if (naslv .eq. 3) then
c           call getint('Number of solvent atoms per solvent molecule',
c    -        44,999999,1,0,naslv,0)
c         end if
          call extension(c,ih,0,1,nslt,cmin,cmax,shiftmmc,0,0,v)
          write (6,1101) shiftmmc
        else if (ioutrajtyp .gt. 5) then
          print *,'PROGRAM ERROR: invalid trajectory type:',
     -      ioutrajtyp
        end if
      end if
      if (ireorder .gt. 0) then
c       Create array with new order
        ndel=0
        do i=1,nwrmax
          if (indexs(i) .gt. 0) then
            do k=1,3
              c1(k,i-ndel)=c(k,indexs(i))
            end do
          else
            ndel=ndel+1
          end if
        end do
        nwrite=nwrmax-ndel
      end if
      if (ioutrajtyp .eq. 1) then
c       Charmm
c       print *,'MAKETRAJ icntrl(11),limic11=',icntrl(11),limic11
        if (icntrl(11) .gt. limic11) write (iout) xtlabc
        if (ireorder .eq. 0) then
          if (icntrl(9) .eq. 0 .or. nconfig .eq. 1) then
            do k=1,3
              write (iout) (c(k,i),i=1,nwrite)
            end do
          else
            do k=1,3
              write (iout) (c(k,ifree(i)),i=1,nfreeatwrite)
            end do
          end if
        else
          if (icntrl(9) .eq. 0 .or. nconfig .eq. 1) then
            do k=1,3
              write (iout) (c1(k,i),i=1,nwrite)
            end do
          else
            do k=1,3
              write (iout) (c1(k,ifree(i)),i=1,nfreeatwrite)
            end do
          end if
        end if
      else if (ioutrajtyp .eq. 2) then
c       Amber
        if (ireorder .eq. 0) then
          write (iout,1001) ((c(k,i),k=1,3),i=1,nwrite)
        else
          write (iout,1001) ((c1(k,i),k=1,3),i=1,nwrite)
        end if
        if (nconfig .eq. 1 .or. noboxrep .eq. 0) write (iout,1001) box
      else if (ioutrajtyp .eq. 3) then
c       MMC
        if (mmctrajtyp .eq. 1) then
          detot=etot
          nwat=(n-nslt)/naslv
          write (iout) nwat,n,1.0d0,nconfig,0,
     -      0,0,1,nslt,detot,0.d0,0.d0,0.d0,0.d0,0.0
          if (ireorder .eq. 0) then
            write (iout) ((c(k,i),k=1,3),i=1,n)
          else
            write (iout) ((c1(k,i),k=1,3),i=1,n)
          end if
          if (noboxinfow .eq. 0) write (iout) box
        else
          print *,'Non-binary MMC trajectory write is not implemented'
          stop
        end if
      else if (ioutrajtyp .eq. 4 .or.
     -         (ioutrajtyp .eq. 5 .and. nconfig .eq. 1)) then
c       Macromodel
        inptp=inpcrdtyp
        inpcrdtyporg=inpcrdtyp
        if (nconfig .gt. 1 .and. newinp .eq. 0) then
          inptp=iommod
        end if
        call writeconf(iout,inptp,iommod,inpcrdtyporg,nwrite,nwrite,
     -    nslt,naslv,islvw,iasv,namesv,qsv,pflsv,1,1,0,iatnum,ifchrg,
     -    nconfig,innlist,c,rprox,cv,ixres,iresno,atnames,resnames,
     -    segnames,charge,isegno,marker,ntitlin,0,title,ireseq,
     -    iresnrestart,iresidrestart,nneig,nneiga,nhbneig,ineig,nhneig,
     -    nnneig,ncneig,nsneig,npneig,numres,numslv,resnamslv,line,
     -    blankline,mmtype,ibnd,index,indexn,indexo,0,molresflag,
     -    idupl,hblimfac,angmin,0,1,0,0,nconfig-1,5,iqspaceask,
     -    0,1,0.0,0,0,0,keeprem,iwriteatsym,radtodeg,maxrepconf,maxng,
     -    mxres,maxrec)
      else
c       Just write the shortened version (Xcluster)
        write (iout,1010) -n,title,((c(k,i),k=1,3),i=1,n)
      end if
      return
1000  format(a80)
1001  format(10f8.3)
1010  format(i5,a,/,(5x,3f12.5))
1101  format(' The system will be shifted by ',3f10.5)
1103  format(' Trajectory is assumed to contain ',a,' (header:',a,')')
1104  format(' For Charmm 27 and higher versions cell information can ',
     -  'be stored ',/,' for each frame. This is required for (T,P,N) ',
     -  'runs')
      end
cDB      subroutine debug_c(nframe,line,index,nslt,cell,ncell,
cDB     -  ish1,ish2,ishr1,ishr2,maxrec)
cDB      character* 132 line(maxrec)
cDB      dimension index(maxrec),cell(3,ncell)
cDB      common /DEBUG/ cx0(3,10000),
cDB     -  cx1(3,10000),cx2(3,10000),cx3(3,10000),cx4(3,10000)
cDB      character*80 file,linew
cDB      file(1:9)='debug.pdb'
cDB      lfile=9
cDB      if (nframe .eq. 1)
cDB     -  call openfile(77,0,' ',1,'new',file,lfile,notfound,0,1,1,0,0)
cDB      write (77,1002) 'MODEL',(nframe-1)*5+1
cDB      do i=1,nslt
cDB        linew=line(index(i))(1:80)
cDB        write (linew(31:54),1001) (cx0(k,i),k=1,3)
cDB        write (77,1000) linew
cDB      end do
cDB      write (77,1000) 'ENDMDL'
cDB      write (77,1002) 'MODEL',(nframe-1)*5+2
cDB      do i=1,nslt
cDB        linew=line(index(i))(1:80)
cDB        write (linew(31:54),1001) (cx1(k,i),k=1,3)
cDB        write (77,1000) linew
cDB      end do
cDB      write (77,1000) 'ENDMDL'
cDB      write (77,1002) 'MODEL',(nframe-1)*5+3
cDB      do i=1,nslt
cDB        linew=line(index(i))(1:80)
cDB        write (linew(31:54),1001) (cx2(k,i),k=1,3)
cDB        write (77,1000) linew
cDB      end do
cDB      write (77,1000) 'ENDMDL'
cDB      write (77,1002) 'MODEL',(nframe-1)*5+4
cDB      do i=1,nslt
cDB        linew=line(index(i))(1:80)
cDB        write (linew(31:54),1001) (cx3(k,i),k=1,3)
cDB        write (77,1000) linew
cDB      end do
cDB      write (77,1000) 'ENDMDL'
cDB      write (77,1002) 'MODEL',5*nframe
cDB      do i=1,nslt
cDB        linew=line(index(i))(1:80)
cDB        write (linew(31:54),1001) (cx4(k,i),k=1,3)
cDB        write (77,1000) linew
cDB      end do
cDB      write (77,1000) 'ENDMDL'
cDB      lfile=13
cDB      if (nframe .eq. 1)
cDB     -  call openfile(78,0,' ',1,'new','debug_img.pdb',lfile,notfound,
cDB     -    0,1,1,0,0)
cDB      do img=1,ncell
cDB        write (78,1002) 'MODEL',(nframe-1)*ncell+img
cDB        do i=ish1,ish2
cDB          linew=line(index(i))(1:80)
cDB          write (linew(31:54),1001) (cx4(k,i)-cell(k,img),k=1,3)
cDB          write (78,1000) linew
cDB        end do
cDB        do i=ishr1,ishr2
cDB          linew=line(index(i))(1:80)
cDB          write (linew(31:54),1001) (cx4(k,i),k=1,3)
cDB          write (78,1000) linew
cDB        end do
cDB        write (78,1000) 'ENDMDL'
cDB      end do
cDB      return
cDB1000  format(a)
cDB1002  format(a,i5)
cDB1001  format(3f8.3)
cDB      end
      subroutine convtraj(ioutrajtyp,inptrajtyp,mmctrajtyp,inpcrdtyp,n,
     -  nslt,naslv,islvw,iatnum,ifchrg,innlist,ih,c,co,c1,c2,rprox,cv,
     -  iresno,ixres,ifres,ilres,ires_ref,ifres_ref,ilres_ref,atnames,
     -  resnames,segnames,charge,isegno,isegno_ref,segid4,ixseg1,ixseg2,
     -  marker,asterisk,ntitlin,title,ireseq,iresnrestart,iresidrestart,
     -  inamcol1,inamcol2,irescol1,irescol2,iseqncol1,iseqncol2,is1,is2,
     -  iqcol1,iqcol2,idcol,nneig,nneiga,nhbneig,ineig,nhneig,nnneig,
     -  ncneig,nsneig,npneig,numres,numslv,resnamslv,line,blankline,
     -  mmtype,ibnd,index,indexn,indexo,indexs,indexdel,index1,index2,
     -  indexsup,atw,edge,ifree,namin,namout,resin,resout,icntrl,
     -  icntrlw,iha,molresflag,atwtemp,temp,idupl,hblimfac,angmin,
     -  iconfsel,numsel,nextconfsel,molsltlim,nmolslt,nmolsltnoion,
     -  nooptquiz,minresflag,iqspaceask,isuperimpask,iwriteatsym,
     -  radtodeg,tofac,irepcall,ipbcinp,iwriteonly,maxconfsel,
     -  maxrepconf,igl,pi,maxrsd,maxng,maxrec)
      character*1 asterisk
      character*4 segnames(maxrsd),segid4(maxrsd)
      character* 132 line(maxrec),blankline
      character*80 title,lineinp,trtitle(32)
      dimension iconfsel(maxconfsel)
      dimension icntrl(20),icntrlw(20),molsltlim(3,maxrsd)
      dimension nneig(maxrec),ineig(maxng,maxrec),iatnum(maxrec),
     -  ifchrg(maxrec),c(3,maxrec),co(maxrec),c1(3,maxrec),c2(maxrec),
     -  rprox(maxrec),cv(maxrec),charge(maxrec),nhbneig(maxrec),
     -  nneiga(maxrec),nhneig(maxrec),nnneig(maxrec),ncneig(maxrec),
     -  nsneig(maxrec),npneig(maxrec),isegno(maxrec),isegno_ref(maxrec),
     -  ixseg1(maxrsd),ixseg2(maxrsd),iresno(maxrec),ixres(maxrec),
     -  ifres(maxrec),ilres(maxrec),ires_ref(maxrec),ifres_ref(maxrec),
     -  ilres_ref(maxrec),mmtype(maxrec),ibnd(maxng,maxrec),
     -  index(maxrec),indexn(maxrec),indexo(maxrec),indexs(maxrec),
     -  indexdel(maxrec),index1(maxrec),index2(maxrec),indexsup(maxrec),
     -  atw(maxrec),temp(maxrec),edge(3),ifree(maxrec),ih(maxrec),
     -  molresflag(maxrsd),atwtemp(maxrec),idupl(maxrsd)
      character*4 namin(maxrec),namout(maxrec),
     -  resin(maxrec),resout(maxrec)
      real*8 xtlabc,xtlabc0
      common /boxdat/ xtlabc(6),xtlabc0(6),box(3),box0(3),edge_gen(3,3),
     -  cell0(3,27),cell(3,27),cellalt(3,27),
     -  ncell,ioppbc,noboxinfoar,noboxinfow,noboxrep,
     -  istuner,iboxtypfound,ixcrd(3),ixang(3),ixyzhex(3),
     -  ixyzhextraj(3),isizewarn
      common /pbcrotmat/ torot_ac(3,3),torot_ca(3,3),tofac_ac,tofac_ca
      character*200 trajnam,outfile
      common /trajname/ trajnam,outfile,ltrajnam,namleno
      common /columnlim/ incol(17),iidcol(17),iialtcol(17),
     -  iinamcol(2,17),iirescol(2,17),iiccol(2,17),iiresncol(2,17),
     -  iiseqncol(2,17),iisegcol(2,17),iiresidcol(2,17),iiqcol(2,17),
     -  iipotcol(2,17),iiocccol(2,17),iichemcol(2,17)
      character*5 crdext
      common /iotypes/ iocha,iochaex,iobpdb,iocpdb,ioa3pdb,ioa4pdb,
     -  iommod,iommc,iommc4,iogro,iomol2,iomae,ioins,ionxyz,
     -  iosxyz,iosxyzrq,iograsp,iofull,lext(17),crdext(17)
      character*8 resnamslv,atnames(maxrec),resnames(maxrsd)
      character*6 marker(16)
      character*1 xyz
      common /axislab/ xyz(3)
      character*11 trajformatname
      common /trajectory/ nmmccheck,iftrajtyp(6),trajformatname(6)
      dimension edgexyz(3),trajrot(3,3),shiftpbc(3),c0(3),crm(3),
     -  rot(3,3)
      character*200 reffile
      character*1 ans,seqtyp,reftyp,chainid,chainid_prev
      character*4 resnam4,atnam4,resnam4n,atnam4n,segid,segid_prev
      character*8 resold,namold
      data inpt /70/,iout /71/,namleno /0/,isort /0/,ishiftpbc /0/,
     -  ishiftocrn /0/,ishiftocnt /0/,ifirst /1/, ilast /999999/,
     -  increment /1/,edgexyz /3*0.0/,iacent /0/,itrajsuperimp /0/
c     print *,'CONVTRAJ ioutrajtyp,inptrajtyp,inpcrdtyp,n=',
c    -  ioutrajtyp,inptrajtyp,inpcrdtyp,n
      iusepbc=0
      icellalt=0
      etot=0.0
      call indexit(indexs,1,n,0)
      nnamcol=inamcol2-inamcol1+1
      nrescol=irescol2-irescol1+1
      natsdel=0
      do ia=1,nslt
        atwtemp(ia)=atw(ia)
        if (molresflag(ixres(ia)) .gt. minresflag) atwtemp(ia)=0.0
      end do
c     Conversion - set up sorting
      ans='u'
103   if (nooptquiz .eq. 0) call quiz(ans,isort,'u',' ',0,
     -  'output atom order',17,0,5,6,igl,82)
      nomatch=0
      if (ans .eq. 'u') then
c       Leave atom order unchanged
        ireorder=0
        if (inptrajtyp .ne. ioutrajtyp .and. iwriteonly .eq. 1)
     -    write (6,1014)
        call indexit(indexs,1,n,0)
        nwrmax=n
        iedit=0
        if (nooptquiz .eq. 0)
     -    call askyn('Do you want to select atoms to write',36,1,-1,
     -      iedit,00)
        if (iedit .gt. 0) then
          call select(line,nrecdel,idcol,asterisk,n,nslt,index,ixres,
     -      is1,is2,iseqncol1,iseqncol2,inamcol1,inamcol2,irescol1,
     -      irescol2,iqcol1,iqcol2,charge,iatnum,nneig,ineig,indexdel,
     -      6,igl,maxng,maxrec)
          natsdel=0
          nwrmax=0
          do ia=1,n
            if (indexdel(ia) .eq. 1) then
              indexs(ia)=0
              natsdel=natsdel+1
            else
              nwrmax=ia
            end if
          end do
          if (natsdel .gt. 0) then
            ireorder=1
            write (6,1001) natsdel,n-natsdel,nwrmax
          else
            write (6,*) 'NOTE: all atoms are kept'
          end if
        end if
      else if (ans .eq. 'r') then
        ireorder=1
        nwrmax=n
c       Read index file
        call quiz(seqtyp,ieqtyp,'s',' ',0,'sequence file type',18,0,5,6,
     -    igl,119)
        call zeroiti(indexn,0,n)
        lreffile=0
        if (seqtyp .eq. 's') then
c         Open the .sort file
          call openfile(69,0,'index',5,'old',reffile,lreffile,
     -      notfnd,1,1,1,0,0)
          if (notfnd .gt. 0) go to 103
          do ia=1,n
            read(69,1007,end=300) indexs(ia)
            if (indexs(ia) .eq. 0) then
              nomatch=nomatch+1
              write (6,1002) ia
            else
              indexn(indexs(ia))=1
            end if
          end do
        else if (seqtyp .eq. 'p') then
c         Read new order from a PDB file' ATOM records
c         Open the .pdb file
          call openfile(69,0,'index PDB',9,'old',reffile,lreffile,
     -      notfnd,1,1,1,0,0)
          if (notfnd .gt. 0) go to 103
          ia=0
          do while (.true.)
            read(69,1000,end=410) lineinp
            if (lineinp(1:4) .eq. 'ATOM' .or.
     -          lineinp(1:6) .eq. 'HETATM') then
              ia=ia+1
              read (lineinp(7:11),*) indexs(ia)
              if (indexs(ia) .eq. 0) then
                nomatch=nomatch+1
                write (6,1002) ia
              else
                indexn(indexs(ia))=ia
              end if
            end if
          end do
410       if (ia .eq. 0) then
            write (6,1024) reffile(1:lreffile),'PDB'
            go to 103
          end if
          print *,'Read ',ia,' atom records'
        else if (seqtyp .eq. 'c' .or. seqtyp .eq. 'l') then
c         Open the Charmm .CRD file
          call openfile(69,0,'index CRD',9,'old',reffile,lreffile,
     -      notfnd,1,1,1,0,0)
          if (notfnd .gt. 0) go to 103
          nl=0
          do while (lineinp(1:1) .eq. '*' .or. nl .eq. 0)
            read(69,1000,end=500) lineinp
            nl=nl+1
          end do
          if (nl .eq. 1) then
            write (6,1024) reffile(1:lreffile),'Charmm'
            go to 103
          end if
500       if (seqtyp .eq. 'c') read (lineinp(1:5),*) natread
          if (seqtyp .eq. 'l') read (lineinp(1:10),*) natread
          print *,'Reading ',natread,' atom reacords'
          do ia=1,natread
            read(69,1000,end=400) lineinp
            if (seqtyp .eq. 'c') read (lineinp(1:5),*) indexs(ia)
            if (seqtyp .eq. 'l') read (lineinp(1:10),*) indexs(ia)
            if (indexs(ia) .eq. 0) then
              nomatch=nomatch+1
              write (6,1002) ia
            else
              indexn(indexs(ia))=ia
            end if
          end do
        end if
400     nz=0
        do ia=1,n
          if (indexn(ia) .eq. 0) then
            nz=nz+1
            write (6,1005) ia
          end if
        end do
        close (69)
        if (nomatch .gt. 0) write (6,1006) nomatch,reffile(1:lreffile)
        if (nz .gt .0) then
          write (6,1004) nz,reffile(1:lreffile)
          stop
        end if
      else if (ioutrajtyp .gt. 3) then
        print *,'Sorry, this option currently only works with PDB or ',
     -    'Charmm or binary MMC files'
        stop
      else
c       Make a match
        ireorder=1
        nwrmax=n
c       Read output structure for atom and residue name info
        print *,'Specify a structure with the output ordering'
        lreffile=0
        call openfile(69,0,'reference order',15,'old',reffile,lreffile,
     -    notfnd,1,1,1,0,0)
        if (reffile(lreffile-3:lreffile) .eq. '.pdb') then
          ireftyp=iobpdb
          print *,'PDB format assumed'
        else if (reffile(lreffile-3:lreffile) .eq. '.CRD') then
          ireftyp=iocha
          print *,'Charmm CRD format assumed'
        else
          call quiz(reftyp,ireftyp,' ','template',7,
     -      'file form (PDB or CRD)',22,0,5,6,igl,0)
        end if
        if (ireftyp .eq. iocha .or. ireftyp .eq. iochaex) then
c         Charmm .CRD
          nccol=4
          lineinp(1:1)='*'
          segid_prev='    '
          nsegm=0
          do while (lineinp(1:1) .eq. '*')
            read (69,1000,end=1069) lineinp
          end do
          if (ireftyp .eq. iocha) call readint(lineinp,1,5,nref,4)
          if (ireftyp .eq. iochaex) call readint(lineinp,1,10,nref,4)
          do ia=1,nref
            read (69,1000,end=1069) lineinp
            resout(ia)='    '
            resout(ia)(1:nrescol)=
     -        lineinp(iirescol(1,ireftyp):iirescol(2,ireftyp))
            namout(ia)=lineinp(iinamcol(1,ireftyp):iinamcol(2,ireftyp))
            read (lineinp(iiresncol(1,ireftyp):iiresncol(2,ireftyp)),*)
     -        ires_ref(ia)
            segid='    '
            segid=lineinp(iisegcol(1,ireftyp):iisegcol(2,ireftyp))
            if (segid .ne. segid_prev) then
              nsegm=nsegm+1
              segid_prev=segid
            end if
            isegno_ref(ia)=nsegm
          end do
        else
c         PDB
          nccol=1
          nref=0
          chainid_prev=' '
          nsegm=0
          do while (.true.)
            read (69,1000,end=101) lineinp
            if (lineinp(1:4) .eq. 'ATOM' .or.
     -          (iha .eq. 1 .and. lineinp(1:6) .eq. 'HETATM')) then
              nref=nref+1
              resout(nref)='    '
              resout(nref)(1:nrescol)=
     -          lineinp(iirescol(1,ireftyp):iirescol(2,ireftyp))
              namout(nref)=
     -          lineinp(iinamcol(1,ireftyp):iinamcol(2,ireftyp))
              read (lineinp(iiresncol(1,ireftyp):iiresncol(2,ireftyp)),
     -          *) ires_ref(nref)
              chainid=lineinp(iisegcol(1,ireftyp):iisegcol(2,ireftyp))
              if (chainid .ne. chainid_prev) then
                nsegm=nsegm+1
                chainid_prev=chainid
              end if
              isegno_ref(nref)=nsegm
            end if
          end do
        end if
101     close (69)
        if (nref .gt. n) then
          write (6,1018) nref,n
          stop
        end if
        call getdupindex(nsegm,segid4,ixseg2)
        print *,'Establishing the input and output name conventions'
        call initnamconv(noconv)
c       Convert input names to output's convention
        nrecdel=0
        nrch=0
        nach=0
        isegno_prev=0
        nsegm=0
        do ia=1,n
          if (isegno(ia) .ne. isegno_prev) then
            nsegm=nsegm+1
            segid4(nsegm)='    '
            segid4(nsegm)=line(index(ia))
     -        (iisegcol(1,inpcrdtyp):iisegcol(2,inpcrdtyp))
            isegno_prev=isegno(ia)
          end if
          resold='     '
          resold(1:nrescol)=line(index(ia))(irescol1:irescol2)
          namold='     '
          namold(1:nnamcol)=line(index(ia))(inamcol1:inamcol2)
          atnam4=namold(1:4)
          if (namold(5:5) .ne. ' ') atnam4=namold(2:5)
          resnam4=resold(1:4)
          if (resold(5:5) .ne. ' ') resnam4=resold(2:5)
          if (noconv .eq. 0) then
            call namconv(nrescol,resnam4,atnam4,resnam4n,atnam4n,nrch,
     -        nach,line(index(ia)),idcol,nrecdel)
            resin(ia)=resnam4n
            namin(ia)=atnam4n
          else
           resin(ia)=resnam4
           namin(ia)=atnam4
          end if
        end do
        call getdupindex(nsegm,segid4,ixseg1)
c       cv and rprox will not be used in maketraj/writeconf calls
        call residue_contig(n,iresno,isegno,index1,ixseg1,cv,indexn,
     -    indexs,indexdel,rprox,maxrsd,maxrec)
        call set_res_lim(iresno,n,ifres,ilres,nres,index1,1,maxrsd,
     -    maxrec)
c        do ir=1,nres
c          do ia=ifres(ir),ilres(ir)
c            write (77,8751) ir,ia,index1(ia),resin(index1(ia))
c8751        format(' ir=',i4,' ia=',i6,' index1=',i6,' resin=',a)
c          end do
c        end do
        call residue_contig(nref,ires_ref,isegno_ref,index2,ixseg2,cv,
     -    indexn,indexs,indexdel,rprox,maxrsd,maxrec)
        call set_res_lim(ires_ref,nref,ifres_ref,ilres_ref,nres_ref,
     -    index2,1,maxrsd,maxrec)
c        do ir=1,nres_ref
c          do ia=ifres_ref(ir),ilres_ref(ir)
c            write (78,8752) ir,ia,index2(ia),resout(index2(ia))
c8752        format(' ir=',i4,' ia=',i6,' index2=',i6,' resout=',a)
c          end do
c        end do
c       Set up matching array
        reffile=reffile(1:lreffile)//'.sort'
        lreffile=lreffile+5
        call openfile(69,0,'order',5,'new',reffile,lreffile,notfnd,
     -    0,1,1,0,0)
        call zeroiti(indexn,0,n)
        call zeroiti(indexs,0,n)
        ir_ref_prev=0
        ir_ref=1
        ifres_ref(nres_ref+1)=ifres_ref(nres_ref)
        do ir=1,nres
c         Find the next matching residue in the template
          ir_ref=ir_ref_prev+1
c         print *,'Start checking ir,ir_ref=',ir,ir_ref
          do while (resin(index1(ifres(ir))) .ne.
     -              resout(index2(ifres_ref(ir_ref)))
     -      .and. ir_ref .le. nres_ref)
            ir_ref=ir_ref+1
          end do
          if (resin(index1(ifres(ir))) .ne.
     -        resout(index2(ifres_ref(ir_ref)))) go to 210
          ir_ref_prev=ir_ref
          do iaa=ifres(ir),ilres(ir)
            ia=index1(iaa)
            do jaa=ifres_ref(ir_ref),ilres_ref(ir_ref)
              ja=index2(jaa)
              if (indexn(ja) .eq. 0) then
                if (namin(ia) .eq. namout(ja)) then
                  indexn(ja)=ia
                  go to 200
                end if
              end if
            end do
            nomatch=nomatch+1
c           if (ia .le. nref) write (6,1020) ia,resin(ia),namin(ia)
200         continue
          end do
        end do
210     if (ir_ref .gt. nres_ref) write (6,1010) ir
        do ia=1,n
          indexs(ia)=indexn(ia)
        end do
        noorder=0
        do ia=2,nref
          if (indexs(ia) .ne. indexs(ia)+1) noorder=noorder+1
        end do
        if (noorder .eq. 0) then
          print *,'NOTE: matching kept the original atom order'
          if (n .eq. nref) ireorder=0
        end if
        do ia=1,n
          if (indexs(ia) .gt. 0) then
            lineinp=line(index(indexs(ia)))(1:80)
            resold='     '
            resold(1:nrescol)=lineinp(irescol1:irescol2)
            namold='     '
            namold(1:nnamcol)=lineinp(inamcol1:inamcol2)
            write (69,1021) ia,resout(ia),namout(ia),
     -        resold, namold,indexs(ia)
          else
            write (69,1021) ia,resout(ia),namout(ia),
     -        '****','****',indexs(ia)
          end if
        end do
        write (6,1023) reffile(1:lreffile)
        close (69)
        if (nomatch .gt. 0) then
          write (6,1008) nomatch,reffile(1:lreffile)
          print *,'You may try to modify ',reffile(1:lreffile),
     -      ' and use it to specify the new order'
          call askyn('Do you want to try matching again',33,1,1,newm,0)
          if (newm .gt. 0) go to 103
          print *,'Output trajectory will contain only the matched ',
     -      'atoms'
        else
          print *,'All atoms matched successfully'
        end if
      end if
      call opentraj(c,1,inpt,inptrajtyp,n,ntitltr,trtitle,
     -  inpcrdtyp,ifirst,ilast,increment,maxconf,
     -  ninconf,noutconf,natom,nfreeat,ifree,icntrl,1,mmctrajtyp,
     -  trajnam,ltrajnam,'input trajectory',16,iconfsel,numsel,
     -  1-irepcall,0,0,0,icellfound,notfnd,0,0,0,maxconfsel,maxrec)
102   if (irepcall .eq. 0) then
        if (icellfound .eq. 1) then
          write (6,1012)
          call askyn('Do you want to override the cell size/shape',43,
     -      1,-1,ipbcinp,0)
        end if
        if (ipbcinp .eq. 1 .or. icellfound .eq. 0) then
          call setpbccell('',0,edge,edge_gen,cell,ncell,cellalt,
     -      ixyzhex,npbc,ioppbc,iusepbc,vol,nw,rinscr,rcirc,0,igl)
          call trnsfr(cell0,cell,3*ncell)
        end if
      end if
      irot_to=0
      if (icellfound .eq. 1 .and. ipbcinp .eq. 0) then
c       Generate cell info from trajectory cell sizes
        if (irepcall .eq. 0) call pbctype(ioppbc,npbc,ixyzhex,0,igl)
        if (inptrajtyp .eq. 1) then
          if (ioppbc .eq. 5) then
c           Skewed hexagon
            edge(1)=xtlabc0(ixcrd(3))
            edge(2)=xtlabc0(ixcrd(2))
            edge(3)=xtlabc0(ixcrd(1))
            if (ioutrajtyp .ne. inptrajtyp) print *,'WARNING: Skewed ',
     -        'hexagon cell parameters will not be properly converted'
          else
            do k=1,3
              edge(k)=xtlabc0(ixcrd(k))
            end do
          end if
        else
          call trnsfr(edge,box0,3)
        end if
        tofac=1.0
        ichangeconv=0
        if (ioppbc .eq. 6) then
          call askyn(
     -      'Is the input PBC TO cell in the Amber convention',48,1,-1,
     -      ichangeconv,0)
          if (ichangeconv .eq. 1) then
c           TO,  Amber to Charmm
            irot_to=-1
            tofac=tofac_ac
            write (6,1013) 'Charmm'
          end if
        else if (ioppbc .eq. 7) then
          call askyn(
     -      'Is the input PBC TO cell in the Charmm convention',49,1,-1,
     -      ichangeconv,0)
          if (ichangeconv .eq. 1) then
c           TO, Charmm to Amber
            irot_to=1
            tofac=tofac_ca
            write (6,1013) 'Amber'
          end if
        end if
        if (ichangeconv .eq. 0 .and. (ioppbc .eq. 6 .or. ioppbc .eq. 7))
     -    write (6,*) 'NOTE: TO cell orientation read will be kept'
        if (ioppbc .eq. 6) then
          do k=1,3
            edgexyz(k)=edge(k)/2.0
          end do
        else if (ioppbc .eq. 7) then
          do k=1,3
            edgexyz(k)=tofac_ac*edge(k)/2.0
          end do
        else
          call trnsfr(edgexyz,edge,3)
        end if
c       Recreate the cell from the first frame's cell size
        call crorgn(edgexyz,edge_gen,ioppbc,3,ncell,cell,cellalt,
     -    ixyzhex,rinscr,rcirc)
        call trnsfr(cell0,cell,3*ncell)
        write (6,1016) edgexyz
        if (ioppbc .gt. 0) iusepbc=1
      end if
      if (ioppbc .eq. 6 .and. inptrajtyp .eq. 2) then
        print *,'Truncated Octahedron type conflicts with input ',
     -    'trajectory type'
        call askyn('Do you want to continue',23,1,-1,icont,20)
        if (icont .eq. 0) go to 102
      end if
      itrajrot=0
      call unitmat(trajrot)
      if (nooptquiz .eq. 0) then
        if (irot_to .ne. 0) write (6,1015)
        call askyn(
     -    'Do you want to rotate each snapshot of the trajectory',
     -    53,1,-1,itrajrot,97)
        if (itrajrot .gt. 0) then
          itrajsuperimp=0
          call genrot(trajrot,pi,iax,angle,igl)
        else if (isuperimpask .eq. 1) then
          call askyn(
     -   'Do you want to superimpose each frame to the input structure',
     -      60,1,-1,itrajsuperimp,0)
          if (itrajsuperimp .gt. 0) then
            call askyn('Do you want to select atoms for overlay',39,
     -          1,-1,ieditoverlay,69)
            if (ieditoverlay .gt. 0) then
              call select(line,nrecdel,idcol,asterisk,n,nslt,index,
     -          ixres,is1,is2,iseqncol1,iseqncol2,inamcol1,inamcol2,
     -          irescol1,irescol2,iqcol1,iqcol2,charge,iatnum,
     -          nneig,ineig,indexdel,6,igl,maxng,maxrec)
c             indexdel: 0 for atoms to use for the overlay, 1 for the rest
c             print *,'nfinalov=',nfinalov
c             write (6,9173) (indexdel(i),i=1,nfinalov)
c9173          format(80i1)
              call masktolist(indexsup,indexdel,n,nfinalov,0)
            else
c             Get a condensed list of atoms selected to write
              ndel=0
              do ia=1,nwrmax
                if (indexs(ia) .eq. 0) then
                  ndel=ndel+1
                else
                  indexsup(ia-ndel)=indexs(ia)
                end if
              end do
              nfinalov=nwrmax-ndel
c             print *,'nfinalov=',nfinalov,' nwrmax=',nwrmax,' nd=',ndel
            end if
          endif
        end if
        ipbcreset=0
        if (itrajsuperimp .eq. 1) then
          call trnsfr(co,c,3*n)
        else if (iusepbc .gt. 0) then
          call askyn(
     -      'Do you want to reset all molecules into the PBC cell',52,
     -      -1,1,ipbcreset,0)
        else
          call setpbccell(
     -      'Do you want to reset all molecules into the PBC cell',52,
     -      edge,edge_gen,cell,ncell,cellalt,ixyzhex,npbc,
     -      ioppbc,ipbcreset,vol,nw,rinscr,rcirc,0,igl)
          call trnsfr(cell0,cell,3*ncell)
        end if
        if (ipbcreset .gt. 0 .and.
     -      (ioppbc .eq. 6 .or. ioppbc .eq. 7)) then
          call askyn('Do you want to try both TO orientations',39, -1,1,
     -      icellalt,137)
        end if
      end if
      if (irot_to .eq. -1) then
        call matprod(trajrot,torot_ac,trajrot)
        itrajrot=1
      else if (irot_to .eq. 1) then
        itrajrot=1
        call matprod(trajrot,torot_ca,trajrot)
        itrajrot=1
      end if
      imcenter=0
      if (ipbcreset .gt. 0) then
        call setpbcdim(ioppbc,ixyzhex,ixyzexcld,ixyzincld,xyz,igl)
        call setrepats(nmolslt,molsltlim,nslt,nneig,ineig,
     -    molresflag,minresflag,indexn,indexo,maxng,maxrsd,igl)
        call quiz(ans,iansrun,'o',' ',0,
     -    'origin of the modified cell',27,0,5,6,igl,0)
        if (ans .eq. 'o') then
          ishiftpbc=0
        else if (ans .eq. 'c') then
          do k=1,3
            call getreal('Component '//xyz(k),10+1,0.0,shiftpbc(k),0,0)
          end do
          ishiftpbc=1
        else if (ans .eq. 'a') then
          call getint('Atom index of the atom to be at the center',42,
     -      1,1,n,iacent,0)
          ishiftpbc=2
        end if
        if (ans .ne. 'a' .and. nmolslt .gt. 1) then
          call askyn(
     -      'Do you want to set the first solute molecule to center',54,
     -        1,-1,imcenterset,0)
          if (imcenterset .eq. 1) call getint('Solute molecule number',
     -      22,1,1,nmolslt,imcenter,0)
        end if
        call  prtcell(ioppbc,edge,edge_gen,r,vol,nw,1)
      else if (ioppbc .eq. 1 .or. ioppbc .eq. 2) then
        idef=+1
        if (inptrajtyp .eq. ioutrajtyp) idef=-1
        if (ioutrajtyp .eq. 2 .and. nooptquiz .eq. 0) then
c         Option to shift center to box corner
          call askyn(
     -      'Do you want to shift the origin to the box corner',
     -      49,1,idef,ishiftocrn,0)
          if (ishiftocrn .gt. 0) shfac=+1.0
        end if
        if (ishiftocrn .eq. 0 .and. inptrajtyp .eq. 2) then
c         Option to shift center from box corner
          call askyn(
     -      'Do you want to shift the origin to the box center',
     -      49,1,idef,ishiftocnt,0)
          if (ishiftocnt .gt. 0) shfac=-1.0
        end if
      end if
      do k=1,3
        box(k)=edge(k)
        xtlabc(ixcrd(k))=edge(k)
        xtlabc(ixang(k))=90.0
        edgexyz(k)=edge(k)/2.0
      end do
      if (noboxinfoar .eq. 0 .and. ipbcreset .eq. 1)
     -  write (6,1009)
      if (numsel .gt. 0) nextconfsel=1
      ifttyp=iftrajtyp(ioutrajtyp)
      if (ioutrajtyp .eq. 3 .and. mmctrajtyp .eq. 1) ifttyp=2
      call openfile(iout,0,'output trajectory',17,'new',outfile,namleno,
     -  notfnd,0,ifttyp,1,0,0)
      nntest=0
      nr50=0
      nr50t=0
      do while (ninconf .lt. ilast)
c       Read a conformation
        call readtraj(inpt,inptrajtyp,mmctrajtyp,n,naslv,nwatr,nslt,
     -    trajformatname(inptrajtyp),ntitltr,trtitle,trajnam,ltrajnam,
     -    natom,nfreeat,ifree,icntrl,c,ninconf,noutconf,
     -    increment,inpcrdtyp,ietot,etot,ifail,ifirst,ilast,iconfsel,
     -    numsel,maxrepconf,nmc,tofac,maxconf,maxconfsel,maxrec)
c       r12=sqrt(dist2(c(1,molsltlim(3,1)),c(1,molsltlim(3,2))))
c       if (r12 .gt. 40.0) then
c         write (77,*) 'NMC=',nmc,' R12=',r12
c         nr50=nr50+1
c       end if
        if (ifail .gt. 0) stop
        icsel=0
        if (numsel .eq. 0) then
          if (ninconf .ge. ifirst .and.
     -      mod(ninconf-ifirst,increment) .eq. 0) icsel=1
          ifpr=ifirst
        else
c         See if this configuration is on the list
          ifpr=iconfsel(nextconfsel)
          if (ninconf .eq. ifpr) then
            icsel=1
            nextconfsel=nextconfsel+1
          else if (ifpr .eq. 0) then
c           List exhausted
            ninconf=ilast+1
          end if
        end if
        if (ninconf .eq. 1 .and. ifpr .gt. 25) print *,
     -    'Searching for first configuration to write - wait ...'
        if (icsel .gt. 0) then
c         Write a (converted) conformation
          noutconf=noutconf+1
          if (nntest .eq. 0) then
            call comparetop(c,n,nneig,ineig,iatnum,innlist,nslt,
     -        naslv,cell,ncell,ioppbc,maxng,maxrec)
            nntest=1
          end if
          if (itrajsuperimp .gt. 0) then
            call bestoverlay(nfinalov,indexsup,indexsup,co,c,atw,0.d0,
     -        c1,c2,temp,rot,c0,crm,0,0.001,0,maxrec)
            call shiftmol(c,n,crm,c1,-1.0)
            call rotate_c(c1,n,rot,c2,'OVERLAY',7)
            call shiftmol(c2,n,c0,c,+1.0)
          else if (itrajrot .gt. 0) then
            call rotate_c(c,n,trajrot,c,'CONVTRAJ',8)
          end if
          if (ishiftocrn+ishiftocnt .ne. 0)
     -      call shiftmol(c,n,edgexyz,c,shfac)
          if (ipbcreset .eq. 1) then
c           Reset into PBC
            if (noboxinfoar .eq. 0) call updatecell(inptrajtyp,edge)
            call systemcenter(n,nmolslt,nmolsltnoion,molsltlim,c,c2,
     -        indexn,atwtemp,cell,ncell,cellalt,icellalt,ixyzexcld,
     -        ixyzincld,nslt,naslv,iacent,imcenter,imcenter_set,
     -        noutconf,maxrec,maxrsd)
c           r12=sqrt(dist2(c(1,molsltlim(3,1)),c(1,molsltlim(3,2))))
c           if (r12 .gt. 40.0) then
c             write (78,*) 'NMC=',nmc,' R12=',r12
c             nr50t=nr50t+1
c           end if
cDB            call debug_c(noutconf,line,index,nslt,cell,ncell,
cDB     -        molsltlim(1,1),molsltlim(2,1),
cDB     -        molsltlim(1,2),molsltlim(2,2),maxrec)
          end if
          if (ntitltr .lt. 30) then
            trtitle(ntitltr+1)=
     -        'Simulaid converted the trajectory in file'
            trtitle(ntitltr+2)=trajnam(1:ltrajnam)
            ntitltr=ntitltr+2
          end if
          call maketraj(noutconf,maxconf,c,c1,rprox,cv,ih,nslt,n,naslv,
     -      islvw,ntitltr,trtitle,line,inpcrdtyp,0,inptrajtyp,
     -      ioutrajtyp,mmctrajtyp,iout,iatnum,ifchrg,innlist,iresno,
     -      ixres,atnames,resnames,segnames,charge,isegno,marker,
     -      ntitlin,title,ireseq,iresnrestart,iresidrestart,nneig,
     -      nneiga,nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,
     -      numres,numslv,resnamslv,blankline,mmtype,ibnd,index,indexn,
     -      indexo,indexs,icntrlw,icntrl,ifree,molresflag,idupl,
     -      ireorder,icellfound,natsdel,nwrmax,hblimfac,angmin,
     -      iqspaceask,keeprem,iwriteatsym,radtodeg,etot,nooptquiz,
     -      maxrepconf,maxng,mxres,maxrec)
          if (nextconfsel .gt. numsel) go to 9999
        end if
        if (ilast .ne. 999999 .and. ilast .ge. 1000) then
          ilast10=ilast/10
          if (mod(ninconf,ilast10) .eq. 0)
     -      print *,(ninconf/ilast10)*10,'% done'
        end if
      end do
c     write (6,*) 'NR50=',nr50,' NR50t=',nr50t
      return
300   write (6,1003) ia,reffile(1:lreffile),nomatch
      return
9999  write (6,1011) noutconf
      return
1069  write (6,1019)
      stop
1000  format(a)
1001  format(' Editing deleted',i7,' atoms. Number of atoms left=',i8,
     -  /,' Highest index of kept atoms=',i8)
1002  format(' Target atom',i6,' has no original atom assigned to it')
1003  format(' ERROR: file ',a,' contained only',i7,' matches',/,
     -  8x,'Number of missing matches found=',i5)
1004  format(' ERROR:',i5,' original atoms are unassigned in file ',a)
1005  format(' Original atom',i6,' is not assigned a new index')
1006  format(' NOTE:',i5,' target atoms missing matches in file ',a,/,
     -  6x,'- output trajectory will contain only the matcehd atoms')
1007  format(59x,i7)
1008  format(' Matching failed for ',i5,' atoms',/,
     -  ' NOTE: see the file ',a,' for more info.',/,
     -  7x,'You can edit this file to complete the matches')
1009  format(' Note: Make sure that the PBC information read from ',
     -  'the trajectory',/,
     -  ' is in the same convention as the PBC size specified above')
1010  format(' WARNING: run out of template residues at the',i6,'-th',
     -  ' input residue')
1011  format(' Completed writing of the new trajectory with ',i6,
     -  ' configurations')
1012  format(' Periodic cell information was found')
1013  format(' NOTE: TO cell will be rotated to conform to the ',a,
     -  ' convention')
1014  format(' WARNING: trajectory interconversion leaves ',
     -  'the atom order unchanged')
1015  format(' NOTE: periodic cell will be rotated to follow Charmm vs',
     -  ' Amber/NAMD convention',/,7x,'You can add an additional ',
     -  'rotation.')
1016  format(' Cell parameters are set from the trajectory to',/,3f10.5)
c1017  format(' Nconf=',i8,' rc1,rcmin1=',f7.1,f8.1,' rc2,rcmin2=',
c     -  f7.1,f8.1,/,' n11-2,n21-2=',i4,3i5,' vtot1=',f10.1,' vtot2=',
c     -  f10.2,' rmsd1=',f7.1,' rmsd2=',f7.1,' isw=',i1,/)
1018  format(' ERROR: number of atoms in the reference system (',
     -  i5,')',/,8x,'is more than the input system (',i5,')')
1019  format(' ERROR: reference configuration file is incomplete')
c1020  format(' ERROR: no match for atom ',i5,' res=',a5,' name=',
c     -  a5)
1021  format(' Target: #=',i7,' R=',a5,' N=',a5,
     -       ' Orig: R=',a5,' N=',a5,' #=',i7)
1023  format(' Matching found between the two structures is written ',
     -  'to file:',/,5x,a)
1024  format(' ERROR: file ',a,' is not a ',a,' file')
      end
      subroutine set_res_lim(ires,n,ifres,ilres,nres,index,iuseindex,
     -  maxres,maxn)
      dimension ires(maxn),ifres(maxres),ilres(maxres),index(maxn)
c     print *,'SET_RES_LIM n=',n
      if (iuseindex .eq. 0) call indexit(index,1,n,0)
      ifres(1)=1
      iresprev=ires(index(1))
      nres=1
      do ia=2,n
        if (ires(index(ia)) .ne. iresprev) then
          ilres(nres)=ia-1
          nres=nres+1
          ifres(nres)=ia
          iresprev=ires(index(ia))
        end if
      end do
      ilres(nres)=n
      return
      end
      subroutine residue_contig(n,ires,isegno,index,ixseg,r,ifa,ila,
     -  itmp,tmp,maxres,max)
      dimension ires(max),isegno(max),index(max),ixseg(maxres),r(max),
     -  ifa(max),ila(max),itmp(max),tmp(max)
c     print *,'RESIDUE_CONTIG n=',n
      call indexit(index,1,n,0)
      do i=1,n
        r(i)=(max+1)*ixseg(isegno(i))+ires(i)+1
      end do
      call mrgsrt(6,index,r,n,ifa,ila,itmp,tmp,max)
      return
      end
      subroutine getdupindex(nsegm,segid4,index)
      character*4 segid4(nsegm)
      dimension index(nsegm)
c     print *,'GETDUPINDEX nsegm=',nsegm
      call indexit(index,1,nsegm,0)
      do is=2,nsegm
        do iss=1,is-1
          if (segid4(is) .eq. segid4(iss)) index(is)=iss
        end do
      end do
      return
      end
      subroutine splittraj_MMC_Amb(inptrajtyp,mmctrajtyp,inpcrdtyp,
     -  nslt,naslv,c,icntrl,ifree,iconfsel,title,trtitle,indexn,indexo,
     -  indexs,maxconfsel,maxrepconf,maxrec)
      character*80 title,trtitle(32)
      dimension iconfsel(maxconfsel)
      dimension icntrl(20)
      dimension c(3,maxrec),indexn(maxrec),indexo(maxrec),
     -  indexs(maxrec),ifree(maxrec)
      real*8 xtlabc,xtlabc0
      common /boxdat/ xtlabc(6),xtlabc0(6),box(3),box0(3),edge_gen(3,3),
     -  cell0(3,27),cell(3,27),cellalt(3,27),
     -  ncell,ioppbc,noboxinfoar,noboxinfow,noboxrep,
     -  istuner,iboxtypfound,ixcrd(3),ixang(3),ixyzhex(3),
     -  ixyzhextraj(3),isizewarn
      character*200 trajnam,outfile
      common /trajname/ trajnam,outfile,ltrajnam,namleno
      character*11 trajformatname
      common /trajectory/ nmmccheck,iftrajtyp(6),trajformatname(6)
      character*1 xyz
      common /axislab/ xyz(3)
c     print *,'SPLITTRAJ inptrajtyp,mmctrajtyp=',
c    -  inptrajtyp,mmctrajtyp
      if (inptrajtyp .ne. 3) then
        print *,'PROGRAM ERROR: input trajectory type is not MMC but ',
     -    trajformatname(inptrajtyp)
        return
      end if
      numsel=0
      inpt=51
      ifirst=1
      ilast=999999
      call opentraj(c,1,inpt,inptrajtyp,n,ntitltr,trtitle,
     -  inpcrdtyp,ifirst,ilast,increment,maxconf,
     -  ninconf,noutconf,natom,nfreeat,ifree,icntrl,1,mmctrajtyp,
     -  trajnam,ltrajnam,'input trajectory',16,iconfsel,numsel,
     -  0,0,0,0,icellfound,notfnd,0,0,0,maxconfsel,maxrec)
      ninconf0=ninconf
      if (noboxinfoar .eq. 0) then
        print *,'(T,P,N) run has constant number of solvents'
        return
      end if
      call askyn('Do you want to give the box size',32,0,1,nobox,0)
      if (nobox .eq. 0) then
        do k=1,3
          call getreal(
     -      'Box coordinate in the '//xyz(k)//' direction (A)',37,
     -      999999.0,box0(k),1,0)
        end do
        nobox=0
        print *,'Box information is written after the first frame only'
      else
        print *,'No box information is written'
      end if
      ifail=0
      call zeroiti(indexs,0,maxrec)
      do while (ninconf .lt. ilast .and. ifail .eq. 0)
c       Read a conformation
        call readtraj(inpt,inptrajtyp,mmctrajtyp,n,naslv,nwatr,nslt,
     -    trajformatname(inptrajtyp),ntitltr,trtitle,trajnam,ltrajnam,
     -    natom,nfreeat,ifree,icntrl,c,ninconf,noutconf,
     -    increment,inpcrdtyp,ietot,etot,ifail,ifirst,ilast,iconfsel,
     -    numsel,maxrepconf,nmc,tofac,maxconf,maxconfsel,maxrec)
        numsolv=(n-nslt)/naslv
        indexs(numsolv+1)=indexs(numsolv+1)+1
      end do
      call findlim(indexs,ifst,ilst,maxrec)
      write (6,1001) ifst-1,ilst-1
      do it=ifst,ilst
c       Open output trajectory files
        if (indexs(it) .gt. 0) then
          indexo(it)=52+(it-ifst)
          lroot=ltrajnam
          if (trajnam(ltrajnam-3:ltrajnam) .eq. '.hst') lroot=lroot-4
          outfile=trajnam
          lroot=lroot+1
          outfile(lroot:lroot)='_'
          loutfile=lroot+1
          call writeint(outfile,loutfile,it-1,lenw)
          outfile(loutfile:loutfile+3)='.trj'
          loutfile=loutfile+3
          open (unit=indexo(it),status='NEW',form='FORMATTED',
     -      file=outfile(1:loutfile),iostat=iopen)
          if (iopen .eq. 0) then
            print *,'File ',outfile(1:loutfile),' opened'
          else
            print *,'Problem opening file ',outfile(1:loutfile)
            return
          end if
          write (title(60:79),1004) it
          write (indexo(it),1000) title
        end if
      end do
      rewind inpt
      ninconf=ninconf0
      ifail=0
      call zeroiti(indexn,ifst-1,ilst)
      do while (ninconf .lt. ilast .and. ifail .eq. 0)
c       Read a conformation
        call readtraj(inpt,inptrajtyp,mmctrajtyp,n,naslv,nwatr,nslt,
     -    trajformatname(inptrajtyp),ntitltr,trtitle,trajnam,ltrajnam,
     -    natom,nfreeat,ifree,icntrl,c,ninconf,noutconf,
     -    increment,inpcrdtyp,ietot,etot,ifail,ifirst,ilast,iconfsel,
     -    numsel,maxrepconf,nmc,tofac,maxconf,maxconfsel,maxrec)
        numsolv=(n-nslt)/naslv
        indexn(numsolv+1)=indexn(numsolv+1)+1
        iout=indexo(numsolv+1)
        write (iout,1003) ((c(k,i),k=1,3),i=1,n)
        if (indexn(numsolv+1) .eq. 1 .and. nobox .eq. 0)
     -    write (iout,1003) box0
        if (ilast .ne. 999999 .and. ilast .ge. 1000) then
          ilast10=ilast/10
          if (mod(ninconf,ilast10) .eq. 0)
     -      print *,(ninconf/ilast10)*10,'% done'
        end if
      end do
      do it=ifst,ilst
        write (6,1002) it-1,indexs(it)
        close (indexo(it))
      end do
      close (inpt)
      return
1000  format(a)
1001  format(' The number of solvents range from ',i5,' to ',i5)
1002  format(' Completed writing of trajectory of ',i5,' solvents ',
     -  'with ',i6,' configurations')
1003  format(10f8.3)
1004  format(' # of solvents=',i5)
      end
C@GL      subroutine animatetraj(idmol,inptrajtyp,mmctrajtyp,n,nslt,naslv,
C@GL     -  resnamslv,iatnum,isc,c,co,c1,nneig,nhneig,nhbneig,ineig,innlist,
C@GL     -  isegno,ih,nnh,ifree,icntrl,segid4,nsegcol,nsegslt,inamcol1,
C@GL     -  inamcol2,ireorient,iacent,icentgra,centgra,tofac,maxng,maxrec)
C@GL      character*4 segid4(1000)
C@GL      character*8 resnamslv
C@GL      dimension centgra(3)
C@GL      real*8 xtlabc,xtlabc0
C@GL      common /boxdat/ xtlabc(6),xtlabc0(6),box(3),box0(3),edge_gen(3,3),
C@GL     -  cell0(3,27),cell(3,27),cellalt(3,27),
C@GL     -  ncell,ioppbc,noboxinfoar,noboxinfow,noboxrep,
C@GL     -  istuner,iboxtypfound,ixcrd(3),ixang(3),ixyzhex(3),
C@GL     -  ixyzhextraj(3),isizewarn
C@GL      common /pbcrotmat/ torot_ac(3,3),torot_ca(3,3),tofac_ac,tofac_ca
C@GL      character*5 crdext
C@GL      common /iotypes/ iocha,iochaex,iobpdb,iocpdb,ioa3pdb,ioa4pdb,
C@GL     -  iommod,iommc,iommc4,iogro,iomol2,iomae,ioins,ionxyz,
C@GL     -  iosxyz,iosxyzrq,iograsp,iofull,lext(17),crdext(17)
C@GL      dimension nneig(maxrec),nhneig(maxrec),nhbneig(maxrec),
C@GL     -  ineig(maxng,maxrec),iatnum(maxrec),isc(maxrec),c(3,maxrec),
C@GL     -  co(3,maxrec),c1(maxrec),isegno(maxrec),ih(maxrec),ifree(maxrec)
C@GL      character*11 trajformatname
C@GL      common /trajectory/ nmmccheck,iftrajtyp(6),trajformatname(6)
C@GL      common /graphics/ igl,npixx,npixy,maxpixx,maxpixy,idwmain,idwplot,
C@GL      common /rotmat/ matrot0(4,4),matrot(4,4),nomat0
C@GL      character*200 trajnam,trajnam2
C@GL      common /trajname/ trajnam,trajnam2,ltrajnam,ltrajnam2
C@GL      character*80 trtitle(32)
C@GL      character*4 pflsv(100)
C@GL      character*8 namesv(100)
C@GL      dimension icntrl(20),cmin(3),cmax(3),c0(3),iasv(100),
C@GL     -  qsv(100),ccref(3,3),cc(3,3),rot(3,3),centinp(3),
C@GL     -  boxmin(3),boxmax(3)
C@GL      character*4 seghigh
C@GL      real*8 xx
C@GL      data ifirst /1/, ilast /999999/, increment /1/, numwait /10/,
C@GL     -  irept /1/, inpt /70/,iclrmin /1/, iclrmax /4/, centinp /3*0.0/
C@GL      xx=0.d0
C@GL      nmax=n
C@GL      iaskatnum=0
C@GL      islv=0
C@GL      if (n .gt. nslt) then
C@GL        call askyn('Do you want the solvents also',29,1,1,islv,0)
C@GL      else
C@GL        call askyn('Do you want the solvents also (if any)',38,1,1,islv,
C@GL     -    0)
C@GL      end if
C@GL      iseghigh=0
C@GL      istopfreq=ilast-ifirst+1
C@GL      numsel=-1
C@GL      iverbose=1
C@GL100   call opentraj(c,irept,inpt,inptrajtyp,n,ntitltr,trtitle,
C@GL     -  inpcrdtyp,ifirst,ilast,increment,maxconf,ninconf,noutconf,
C@GL     -  natom,nfreeat,ifree,icntrl,1,mmctrajtyp,trajnam,ltrajnam,
C@GL     -  'trajectory',10,iconfsel,numsel,iverbose,0,0,0,icellfound,
C@GL     -  notfnd,0,0,0,maxconfsel,maxrec)
C@GL      if (iverbose .eq. 1 .and. noboxinfoar .eq. 0 .and. ioppbc .lt. 0)
C@GL     -  call pbctype(ioppbc,npbc,ixyzhex,0,1)
C@GL      iverbose=0
C@GL      call getint('Freqeuency of pausing the animation',35,istopfreq,
C@GL     -  1,0,istopfreq,51)
C@GL      if (nsegslt .gt. 1) then
C@GL        if (iseghigh .eq. 0) then
C@GL          call askyn('Do you want to highlight a segment',34,1,-1,ihs,0)
C@GL        else
C@GL          call askyn('Do you want to highlight a different segment',
C@GL     -      44,1,-1,ihs,0)
C@GL        end if
C@GL        if (ihs .eq. 1) then
C@GL102       call getname(seghigh,len,'Segment/chain ID to highlight',29,
C@GL     -      4,0)
C@GL          do is=1,nsegslt
C@GL            if (seghigh(1:nsegcol) .eq. segid4(is)(1:nsegcol))
C@GL     -        iseghigh=is
C@GL          end do
C@GL          if (iseghigh .eq. 0) then
C@GL            print *,'Segment ID ',seghigh,' is not found'
C@GL            if (nsegcol .gt. 1)
C@GL     -        print *,'Make sure all',nsegcol,' characters are given'
C@GL            go to 102
C@GL          end if
C@GL        end if
C@GL      end if
C@GL      ifail=0
C@GL      if (mmctrajtyp .eq. 4) then
C@GL        inamcol1=13
C@GL        inamcol2=inamcol1+3
C@GL      else if (mmctrajtyp .eq. 5) then
C@GL        inamcol1=17
C@GL        inamcol2=inamcol1+3
C@GL      end if
C@GL      nntest=0
C@GL      do while (ninconf .lt. ilast .and. ifail .eq. 0)
C@GL        if (ninconf .gt. 0) then
C@GLc         Restore full solute before manipulations since not all atoms are r
C@GL          if (inptrajtyp .eq. 1 .and. icntrl(9) .gt. 0)
C@GL     -      call trnsfr(c,c1,3*nslt)
C@GL        end if
C@GLc       Read a conformation
C@GL        call readtraj(inpt,inptrajtyp,mmctrajtyp,n,naslv,nwatr,nslt,
C@GL     -    trajformatname(inptrajtyp),ntitltr,trtitle,trajnam,ltrajnam,
C@GL     -    natom,nfreeat,ifree,icntrl,c,ninconf,noutconf,
C@GL     -    increment,inpcrdtyp,ietot,etot,ifail,ifirst,ilast,iconfsel,
C@GL     -    numsel,maxrepconf,nmc,tofac,maxconf,maxconfsel,maxrec)
C@GLc!!     TO box size update is not done!
C@GL        if (ioppbc .eq. 7) then
C@GL          do k=1,3
C@GL            box(k)=box(k)*tofac
C@GL          end do
C@GL        end if
C@GL        if (ninconf .eq. 1) then
C@GL          if (inptrajtyp .eq. 1 .and. icntrl(9) .gt. 0 .and.
C@GL     -        ireorient .eq. 0 .and. icentgra .eq. 1)
C@GL     -      call trnsfr(c1,c,3*nslt)
C@GL        end if
C@GL        if (nntest .eq. 0) then
C@GL          call comparetop(c,n,nneig,ineig,iatnum,innlist,nslt,naslv,
C@GL     -      cell,ncell,ioppbc,maxng,maxrec)
C@GL          nntest=1
C@GL        end if
C@GL        if (islv .eq. 0) then
C@GL          ndraw=min0(n,nslt)
C@GL        else
C@GL          ndraw=n
C@GL        end if
C@GLc       print *,'ndraw,islv,n,nslt=',ndraw,islv,n,nslt
C@GL        if (ndraw .gt. nmax) then
C@GL          nmax0=nmax
C@GLc         Generate additional solvent neighbour maps
C@GL          call updatesolvents(iaskatnum,0,nmax,ndraw,naslv,iasv,
C@GL     -      namesv,resnamslv,qsv,pflsv,iwat,iatnum,ninconf,0,maxrec)
C@GL          ia=nmax0
C@GL          if (iwat .eq. 0) then
C@GLc           General solvent - calculate nnlist
C@GL            do while (ia .lt. ndraw)
C@GL              call nnlistslv(ia+1,ia+naslv,iatnum,c,nneig,nhneig,
C@GL     -          ineig,maxng)
C@GL              ia=ia+naslv
C@GL            end do
C@GL          else
C@GL            do while (ia .lt. ndraw)
C@GL              nneig(ia+1)=2
C@GL              nneig(ia+2)=1
C@GL              nneig(ia+3)=1
C@GL              ineig(1,ia+1)=ia+2
C@GL              ineig(2,ia+1)=ia+3
C@GL              ineig(1,ia+2)=ia+1
C@GL              ineig(1,ia+3)=ia+1
C@GL              nhneig(ia+1)=2
C@GL              nhneig(ia+2)=0
C@GL              nhneig(ia+3)=0
C@GL              ia=ia+naslv
C@GL            end do
C@GL          end if
C@GL        end if
C@GL        if (ifail .eq. 0 .and. ninconf .ge. ifirst .and.
C@GL     -    mod(ninconf-ifirst,increment) .eq. 0) then
C@GLc         Draw a conformation
C@GL          if (ireorient .eq. 1) then
C@GL            if (noutconf .eq. 0) then
C@GLc             Save reference atoms
C@GL              call trnsfr(ccref(1,1),c(1,iacent),3)
C@GL              call trnsfr(ccref(1,2),c(1,ineig(1,iacent)),3)
C@GL              call trnsfr(ccref(1,3),c(1,ineig(2,iacent)),3)
C@GL              call shiftmol(c,ndraw,ccref,c,-1.0)
C@GL            else
C@GLc             Reorient the system
C@GL              call shiftmol(c,ndraw,c(1,iacent),c,-1.0)
C@GL              call trnsfr(cc(1,1),c(1,iacent),3)
C@GL              call trnsfr(cc(1,2),c(1,ineig(1,iacent)),3)
C@GL              call trnsfr(cc(1,3),c(1,ineig(2,iacent)),3)
C@GL              call ormat(rot,cc,ccref,3,1)
C@GL              call rotate_c(c,ndraw,rot,c,'DRAW',4)
C@GL            end if
C@GL          end if
C@GL          noutconf=noutconf+1
C@GL          if (noutconf .eq. 1 .and. irept .eq. 1) then
C@GL            if (noboxinfoar .eq. 1 .or. ioppbc .eq. -1) then
C@GL              call extension(c,ih,nnh,1,ndraw,cmin,cmax,c0,0,1)
C@GL              wx1=amax1(abs(cmin(1)-centgra(1)),abs(cmax(1)-centgra(1)))
C@GL              wy1=amax1(abs(cmin(2)-centgra(2)),abs(cmax(2)-centgra(2)))
C@GL              wz1=amax1(abs(cmin(3)-centgra(3)),abs(cmax(3)-centgra(3)))
C@GL              wxx=amax1(wx1,amax1(wx1,wy1,wz1))
C@GL            else
C@GL              call crorgn(box,edge_gen,ioppbc,3,ncell,cell,cellalt,
C@GL     -          ixyzhex,rinscr,rcirc)
C@GL              call trnsfr(boxmin,box,3)
C@GL              call trnsfr(boxmax,box,3)
C@GL              wxx=rcirc
C@GL            end if
C@GL            wx=wxx*1.1
C@GL            wy=wx
C@GL            wz=wx
C@GL            wxdr=wx
C@GL            call ortho(-wx,wx,-wy,wy,-wz,wz)
C@GL             nomat0=1
C@GL            call getrotmat(matrot0,nomat0,'TRAJ')
C@GL          else
C@GL            if (noboxinfoar .eq. 0 .and. ioppbc .ge. 0) then
C@GLc             Update limiting box sizes
C@GL              if (box(1) .lt. boxmin(1)) call trnsfr(boxmin,box,3)
C@GL              if (box(1) .gt. boxmax(1)) call trnsfr(boxmax,box,3)
C@GL            end if
C@GL          end if
C@GL          call setcolor(0)
C@GL          call clear
C@GL          nomat=1
C@GL          call getrotmat(matrot,nomat,'TRAJ')
C@GL          call drawseqn(idseqn,ninconf)
C@GL          call drawmol(idmol,c,iatnum,isc,ndraw,nslt,nneig,nhneig,ineig,
C@GL     -      isegno,iseghigh,maxng,trajnam,ltrajnam,0,0,0,0,
C@GL     -      icentgra,centgra,nhbneig,0)
C@GLc         call drawaxes(idaxes,0.05,0)
C@GL          if (noboxinfoar .eq. 0 .and. ioppbc .ge. 0) then
C@GLc           Regenerate cell info, draw cell
C@GL            call crorgn(boxmin,edge_gen,ioppbc,3,ncell,cell,cellalt,
C@GL     -        ixyzhex,rinscr,rcirc)
C@GL            call drawpbc(boxmin,edge_gen,ioppbc,ixyzhex,centinp,0,
C@GL     -        idpbc,iclrmin,2,0,rot,0.0,0)
C@GL            call crorgn(boxmax,edge_gen,ioppbc,3,ncell,cell,cellalt,
C@GL     -        ixyzhex,rinscr,rcirc)
C@GL            call drawpbc(boxmax,edge_gen,ioppbc,ixyzhex,centinp,1,
C@GL     -        idpbc,iclrmax,2,0,rot,0.0,0)
C@GL          end if
C@GL          call swapbu
C@GL          if (mod(noutconf,istopfreq) .eq. 0) then
C@GLc           Stop for manipulations
C@GL            nstep=0
C@GLc           if (icentgra .gt. 0) then
C@GLc             do i=1,ndraw
C@GLc               do k=1,3
C@GLc                 c(k,i)=c(k,i)-centgra(k)
C@GLc               end do
C@GLc             end do
C@GLc             call trnsfr(co,c,3*ndraw)
C@GLc           end if
C@GL            do while (nstep .ge. 0)
C@GL              call askrot(nstep)
C@GL              nomat=1
C@GL              call getrotmat(matrot,nomat,'ASKR')
C@GL              call setcolor(0)
C@GL              call clear()
C@GL              call drawmol(idmol,c,iatnum,isc,ndraw,nslt,nneig,nhneig,
C@GL     -          ineig,isegno,iseghigh,maxng,trajnam,ltrajnam,0,0,0,0,
C@GL     -                 0,centgra,nhbneig,0)
C@GLc     -          icentgra,centgra,nhbneig,0)
C@GLc                 if (icentgra .gt. 0) call trnsfr(c,co,3*ndraw)
C@GL              call drawaxes(idaxes,0.05,0)
C@GL              if (noboxinfoar .eq. 0 .and. ioppbc .ge. 0) then
C@GLc               Regenerate cell info, draw cell
C@GL                call crorgn(boxmin,edge_gen,ioppbc,3,ncell,cell,cellalt,
C@GL     -            ixyzhex,rinscr,rcirc)
C@GL                call drawpbc(boxmin,edge_gen,ioppbc,ixyzhex,centinp,0,
C@GL     -            idpbc,iclrmin,2,0,rot,0.0,0)
C@GL                call crorgn(boxmax,edge_gen,ioppbc,3,ncell,cell,cellalt,
C@GL     -            ixyzhex,rinscr,rcirc)
C@GL                call drawpbc(boxmax,edge_gen,ioppbc,ixyzhex,centinp,1,
C@GL     -            idpbc,iclrmax,2,0,rot,0.0,0)
C@GL              end if
C@GL              call swapbu
C@GL            end do
C@GL          else
C@GL            call waitframe(numwait,xx)
C@GL          end if
C@GL        end if
C@GL      end do
C@GL      close(inpt)
C@GL      if (ifail .gt. 0) ilast=ninconf
C@GL      write (6,1011) noutconf
C@GL      if (noboxinfoar .eq. 0 .and. ioppbc .ge. 0)
C@GL     -   write (6,1012) boxmin,boxmax
C@GL      call getint('Repeat with new wait length (0 to stop)',39,
C@GL     -  numwait,1,0,numwait,52)
C@GL      irept=irept+1
C@GL      if (numwait .gt. 0) then
C@GL        nstep=0
C@GL        if (icentgra .gt. 0) then
C@GLc         do i=1,ndraw
C@GLc           do k=1,3
C@GLc             c(k,i)=c(k,i)+centgra(k)
C@GLc           end do
C@GLc         end do
C@GLc?        call trnsfr(co,c,3*ndraw)
C@GL          call trnsfr(c,co,3*ndraw)
C@GL        end if
C@GL        do while (nstep .ge. 0)
C@GL          call askrot(nstep)
C@GL          nomat=1
C@GL          call getrotmat(matrot,nomat,'ASKR')
C@GL          call setcolor(0)
C@GL          call clear()
C@GL          call drawmol(idmol,c,iatnum,isc,ndraw,nslt,nneig,nhneig,ineig,
C@GL     -      isegno,iseghigh,maxng,trajnam,ltrajnam,0,0,0,0,
C@GL     -      icentgra,centgra,nhbneig,0)
C@GL              if (icentgra .gt. 0) call trnsfr(c,co,3*ndraw)
C@GL          call drawaxes(idaxes,0.05,0)
C@GL          if (noboxinfoar .eq. 0 .and. ioppbc .ge. 0) then
C@GLc           Regenerate cell info, draw cell
C@GL            call crorgn(boxmin,edge_gen,ioppbc,3,ncell,cell,cellalt,
C@GL     -        ixyzhex,rinscr,rcirc)
C@GL            call drawpbc(boxmin,edge_gen.ioppbc,ixyzhex,centinp,0,idpbc,
C@GL     -        iclrmin,0,rot,2,0.0,0)
C@GL            call crorgn(boxmax,edge_gen,ioppbc,3,ncell,cell,cellalt,
C@GL     -        ixyzhex,rinscr,rcirc)
C@GL            call drawpbc(boxmax,edge_gen.ioppbc,ixyzhex,centinp,1,idpbc,
C@GL     -        iclrmax,0,rot,2,0.0,0)
C@GL          call swapbu
C@GL          end if
C@GL        end do
C@GL        go to 100
C@GL      end if
C@GL      if (xx .lt. 0.d0) print *,'Wait sum (ignore it)=',xx
C@GL      return
C@GL1011  format(' Completed animating new trajectory with ',i6,
C@GL     -  ' configurations')
C@GL1012  format(' Smallest box=',3f10.5,/,' Largest  box=',3f10.5)
C@GL      end
      subroutine waitframe(numwait,xx)
      real*8 xx
      do i=1,numwait*10000
        xx=xx+alog(sqrt(float(i)))
      end do
      return
      end
      subroutine savepdb(iu,label,llabel,c,n,mod)
      character*(*) label
      dimension c(3,n)
      parameter (MAXREC=200000)
      character*132 line(MAXREC)
      dimension index(MAXREC)
      common /line_crd/ line,index
      if (mod .le. 1) then
        open(unit=iu,status='new',file=label(1:llabel),iostat=iopen,
     -    form='formatted')
        if (iopen .gt. 0) 
     -    open(unit=iu,status='old',file=label(1:llabel),iostat=iopen,
     -        form='formatted')
        if (iopen .eq. 0) then
          print *,'File ',label(1:llabel),' opened'
        else
          return
        end if
        write (iu,1002) label(1:llabel)
      end if
      if (mod .gt. 0) write (iu,1003) mod
      do ia=1,n
        write (line(index(ia))(31:54),1001) (c(k,ia),k=1,3)
        call lastchar(line(index(ia)),lc,132)
        write (iu,1000) line(index(ia))(1:lc)
      end do
      if (mod .gt. 0) then
        write (iu,1004) 
      else
        close(iu)
      end if
      return
1000  format(a)
1001  format(3f8.2)
1002  format('REMARK ',a)
1003  format('MODEL ',i4)
1004  format('ENDMDL')
      end
      subroutine systemcenter(n,nmolslt,nmolsltnoion,molsltlim,c,ct,it1,
     -  atw,cell,ncell,cellalt,icellalt,ixyzexcld,ixyzincld,nslt,naslv,
     -  iacent,imcenter_r,imcenter,nconf,mxat,maxrsd)
      dimension c(3,mxat),ct(3,mxat),molsltlim(3,maxrsd),cell(3,ncell),
     -  cellalt(3,ncell),it1(mxat),atw(mxat)
      dimension c00(3),c0(3),cmin(3),cmax(3)
cDB      common /DEBUG/ cx0(3,10000),
cDB     -  cx1(3,10000),cx2(3,10000),cx3(3,10000),cx4(3,10000)
c     print *,'SYSTEMCENT n,nmolslt,nslt,naslv=',n,nmolslt,nslt,naslv
c     print *,'SYSTEMCENT nmolsltnoion,iacent,maxrsd,mxat=',
c    -  nmolsltnoion,iacent,maxrsd,mxat
c     print *,'SYSTEMCENT ncell,ixyzexcld,ixyzincld=',
c    -  ncell,ixyzexcld,ixyzincld
c     write (78,*) 'SYSTEMCENT'
c     write (78,8822) (im,(molsltlim(k,im),k=1,3),im=1,nmolslt)
c8822 format(' im=',i4,' molsltlim=',3i6)
c     Bring together the solute molecules
c     Find the center of the first solute molecule and shift it to <0,0,0>
cDB      call trnsfr(cx0,c,3*nslt)
      imcenter=imcenter_r
c     print *,'IACENT,IMCENTER=',iacent,imcenter
      if (iacent .eq. 0) then
        if (nconf .le. 1) then
          ndrop=0
          do ia=1,nslt
            if (atw(ia) .eq. 0.0) ndrop=ndrop+1
          end do
          print *,'Solute centering will use ',nslt-ndrop,' atoms'
        end if
        if (imcenter .eq. 0) then
c         Center around the largest solute molecule's center
          maxmolats=0
          do im=1,nmolslt
            nmem=molsltlim(2,im)-molsltlim(1,im)+1
            if (nmem .gt. maxmolats) then
              maxmolats=nmem
              imcenter=im
            end if
          end do
        end if
        if (molsltlim(3,imcenter) .eq. 0) then
          call extension(c,it1,0,molsltlim(1,imcenter),
     -      molsltlim(2,imcenter),cmin,cmax,c00,0,1,v)
          ncentspec=0
        else if (molsltlim(3,imcenter) .eq. -1) then
cxx       Calculate COM
          call zeroit(c00,3)
          atwsum=0.0
          do ia=molsltlim(1,imcenter),molsltlim(2,imcenter)
            do k=1,3
              c00(k)=c00(k)+atw(ia)*c(k,ia)
            end do
            atwsum=atwsum+atw(ia)
          end do
          if (atwsum .gt. 0.0) then
            do k=1,3
              c00(k)=c00(k)/atwsum
            end do
          end if
        else
          call trnsfr(c00,c(1,molsltlim(3,imcenter)),3)
          ncentspec=1
        end if
        if (nconf .le. 1 .and. nmolslt .gt. 1)
     -    write (6,1001) 'molecule',imcenter
      else
        if (iacent .gt. molsltlim(2,nmolslt)) then
          write (6,1002) iacent,molsltlim(2,nmolslt)
          stop
        end if
        call trnsfr(c00,c(1,iacent),3)
        imcenter=1
        do while (molsltlim(2,imcenter) .lt. iacent)
          imcenter=imcenter+1
        end do
        if (nconf .le. 1) write (6,1001) 'atom',iacent
      end if
      if (ixyzexcld .gt. 0) c00(ixyzexcld)=0.0
      if (ixyzincld .gt. 0) then
        do k=1,3
          if (k .ne. ixyzincld) c00(k)=0.0
        end do
      end if
      call shiftmol(c,n,c00,c,-1.0)
cDB      call trnsfr(cx1,c,3*nslt)
c     call savepdb(88,'MOLEC_IMCENTER_CENTERED.pdb',27,c,n,0)
      noshift=0
      nmolfst=1
      call molreset(nmolfst,nmolslt,nmolshift,c,ct,molsltlim,it1,
     -  cell,ncell,cellalt,icellalt,imcenter,maxrsd,mxat)
c     call savepdb(88,'AFTER_MOLRESET.pdb',18,c,n,0)
cDB      call trnsfr(cx2,c,3*nslt)
c     print *,'After  molreset'
c     do is=nmolfst,nmolslt
c       write (6,*) 'molsltlim=',molsltlim(3,is)
c       call extension(c,it1,0,molsltlim(1,is),molsltlim(2,is),
c    -      cmin,cmax,c0,1,0,v)
c     end do
c     Repeat, to bring in 2nd neighbor cell members
c     call molreset(nmolfst,nmolslt,nmolshift,c,ct,molsltlim,it1,
c    -  cell,ncell,cellalt,icellalt,imcenter,maxrsd,mxat)
      if (noshift .eq. 1 .and. nmolshift .gt. 0 .and. nconf .le. 10)
     -  print *,'WARNING: ',nmolshift,' centered molecules were ',
     -    'shifted again after recentering'
      nsltnoion=molsltlim(2,nmolsltnoion)
c     call extension(c,it1,0,1,nsltnoion,cmin,cmax,c0,0,0,v)
      if (iacent .eq. 0 .and. noshift .eq. 0 .and. nmolslt .gt. 1) then
        if (nsltnoion .gt. 0) then
          call cofms(c,c0,nsltnoion,atw)
          call shiftmol(c,n,c0,c,-1.0)
          call arrsum(c0,c00,c0,3)
          if (nconf .le. 1) write (6,1000) c0
          nmolfst=1
          noshift=1
          call ionreset(nmolfst,nmolslt,nmolshift,c,molsltlim,it1,atw,
     -      cell,ncell,ixyzexcld,ixyzincld,maxrsd,mxat)
        end if
      end if
cDB      call trnsfr(cx3,c,3*nslt)
c     Check for ions outside the cell
      nreset=0
      do is=nmolsltnoion+1,nmolslt
        call pbcreset(c(1,molsltlim(1,is)),
     -    molsltlim(2,is)-molsltlim(1,is)+1,c(1,molsltlim(1,is)),
     -    cell,ncell,ixyzexcld,ixyzincld,img)
        if (img .gt. 1) then
          nreset=nreset+1
          call pbcreset(c(1,molsltlim(1,is)),
     -      molsltlim(2,is)-molsltlim(1,is)+1,c(1,molsltlim(1,is)),
     -      cell,ncell,ixyzexcld,ixyzincld,img)
        end if
      end do
cDB      call trnsfr(cx4,c,3*nslt)
c     Reset solvents
      nsw=(n-nslt)/naslv
      do iw=1,nsw
        call extension(c,it1,0,nslt+(iw-1)*naslv+1,nslt+iw*naslv,
     -    cmin,cmax,c0,0,0,v)
cx      call pbcreset(c(1,nslt+(iw-1)*naslv+1),naslv,c0,
cx   -    cell,ncell,ixyzexcld,ixyzincld,img)
        call genimdist(c0,cell,1,ncell,img,d2)
        if (img .gt. 1)
     -    call shiftmol(c(1,nslt+(iw-1)*naslv+1),naslv,cell(1,img),
     -      c(1,nslt+(iw-1)*naslv+1),-1.0)
      end do
      return
1000  format(' Aggregated solute molecules are shifted by ',3f8.3,
     -  ' A')
1001  format(' Solute is centered around solute ',a,i6)
1002  format(' ERROR: solute center requested (',i8,') is outside the ',
     -  'solute atom range (1 - ',i8,')')
      end
      subroutine molreset(nmolfst,nmolslt,nmolshift,c,ct,molsltlim,it1,
     -  cell,ncell,cellalt,icellalt,imcenter,maxrsd,mxat)
      dimension c(3,mxat),ct(3,mxat),molsltlim(3,maxrsd),it1(mxat),
     -  cell(3,ncell),cellalt(3,ncell)
      dimension c0(3),cmin(3),cmax(3),cmincent(3),cmaxcent(3),
     -  cmin12sav(3),cmax12sav(3),cmin12(3),cmax12(3)
c     print *,'MOLRESET ncell=',ncell
      call extension(c,it1,0,molsltlim(1,imcenter),
     -  molsltlim(2,imcenter),cmincent,cmaxcent,c0,0,0,v)
      nmolshift=0
c     imgw=0
      do im=nmolfst,nmolslt
        ialtopt=0
        if (im .ne. imcenter) then
          ichange=1
          do while (ichange .gt. 0)
            call extension(c,it1,0,molsltlim(1,im),molsltlim(2,im),
     -        cmin,cmax,c0,0,0,v)
            call combinevol(cmin,cmax,cmincent,cmaxcent,cmin12sav,
     -        cmax12sav,volmin)
c             write (6,8733) 1,cmin,cmax,cmincent,cmaxcent,cmin12sav,
c    -          cmax12sav,volmin
            imgopt=1
c           imgw=imgw+1
c           call savepdb(89,'MOLRESET.pdb',12,c,molsltlim(2,nmolslt),
c    -        imgw)
            do img=2,ncell
              call trnsfr(ct,c,3*molsltlim(2,nmolslt))
              call shiftmol(c(1,molsltlim(1,im)),
     -          molsltlim(2,im)-molsltlim(1,im)+1,cell(1,img),
     -          ct(1,molsltlim(1,im)),-1.0)
c             imgw=imgw+1
c             call savepdb(89,'MOLRESET.pdb',12,ct,molsltlim(2,nmolslt),
c    -          imgw)
              call extension(ct,it1,0,molsltlim(1,im),molsltlim(2,im),
     -          cmin,cmax,c0,0,0,v)
              call combinevol(cmin,cmax,cmincent,cmaxcent,cmin12,cmax12,
     -          vol)
c              write (6,8733) img,cmin,cmax,cmincent,cmaxcent,cmin12,
c     -          cmax12,vol
c8733          format(' IMG=',i2,' CMIN=',3f8.2,' CMAX=',3f8.2,/,
c     -               ' CMINCENT=',3f8.2,' CMAXCENT=',3f8.2,/,
c     -               ' CMIN12=',3f8.2,' CMAX12=',3f8.2,' VOL=',f12.2)
              if (vol .lt. volmin) then
                volmin=vol
                call trnsfr(cmin12sav,cmin12,3)
                call trnsfr(cmax12sav,cmax12,3)
                imgopt=img
              end if
c             write (6,9888) img,vol,imgopt,volmin
c9888         format(' IMG=',i2,' V=',f12.3,' IMGOPT=',i2,
c    -        ' VOLMN=',f12.3)
            end do
            do k=1,3
              cmincent(k)=amin1(cmincent(k),cmin12sav(k))
              cmaxcent(k)=amax1(cmaxcent(k),cmax12sav(k))
            end do
            if (icellalt .gt. 0) then
c             Try the alternate (TO) cell orientation
              do img=2,ncell
                call trnsfr(ct,c,3*molsltlim(2,nmolslt))
                call shiftmol(c(1,molsltlim(1,im)),
     -            molsltlim(2,im)-molsltlim(1,im)+1,cell(1,img),
     -            ct(1,molsltlim(1,im)),-1.0)
                call extension(ct,it1,0,molsltlim(1,im),molsltlim(2,im),
     -            cmin,cmax,c0,0,0,v)
                call combinevol(cmin,cmax,cmincent,cmaxcent,cmin12,
     -            cmax12,vol)
                if (vol .lt. volmin) then
                  volmin=vol
                  call trnsfr(cmin12sav,cmin12,3)
                  call trnsfr(cmax12sav,cmax12,3)
                  imgopt=img
                  ialtopt=1
                end if
              end do
            end if
c           print *,'IMGOPT=',imgopt
            if (imgopt .gt. 1) then
              ichange=1
              if (ialtopt .eq. 0) then
                call shiftmol(c(1,molsltlim(1,im)),
     -            molsltlim(2,im)-molsltlim(1,im)+1,cell(1,imgopt),
     -            c(1,molsltlim(1,im)),-1.0)
              else
                call shiftmol(c(1,molsltlim(1,im)),
     -            molsltlim(2,im)-molsltlim(1,im)+1,cellalt(1,imgopt),
     -            c(1,molsltlim(1,im)),-1.0)
              end if
            else
              ichange=0
            end if
          end do
        end if
      end do
c     close (89)
      return
      end
      subroutine combinevol(cmin1,cmax1,cmin2,cmax2,cmin12,cmax12,vol)
      dimension cmin1(3),cmax1(3),cmin2(3),cmax2(3),cmin12(3),cmax12(3)
      vol=1.0
      do k=1,3
        cmin12(k)=amin1(cmin1(k),cmin2(k))
        cmax12(k)=amax1(cmax1(k),cmax2(k))
        vol=vol*(cmax12(k)-cmin12(k))
      end do
      return
      end
      subroutine ionreset(nmolfst,nmolslt,nmolshift,c,molsltlim,it1,atw,
     -  cell,ncell,ixyzexcld,ixyzincld,maxrsd,mxat)
      dimension c(3,mxat),molsltlim(3,maxrsd),it1(mxat),atw(mxat),
     -  cell(3,ncell)
      dimension c0(3),cmin(3),cmax(3)
c     print *,'MOLRESET ncell,ixyzexcld,ixyzincld=',
c    -  ncell,ixyzexcld,ixyzincld
      nmolshift=0
      do is=nmolfst,nmolslt
        if (molsltlim(3,is) .eq. 0) then
          call extension(c,it1,0,molsltlim(1,is),molsltlim(2,is),
     -      cmin,cmax,c0,0,0,v)
        else if (molsltlim(3,is) .eq. -1) then
          call cofms(c(1,molsltlim(1,is)),c0,
     -      molsltlim(2,is)-molsltlim(1,is)+1,atw)
        else
          call trnsfr(c0,c(1,molsltlim(3,is)),3)
        end if
        call genimdist123dim(c0,cell,1,ncell,ixyzexcld,ixyzincld,
     -    img,rmin2)
        nrep=0
        do while (img .gt. 1 .and. nrep .lt. 10)
c         if (is .lt. 4) print *,'MOLRESET is=',is,' img=',img
          call shiftmol(c(1,molsltlim(1,is)),
     -      molsltlim(2,is)-molsltlim(1,is)+1,cell(1,img),
     -      c(1,molsltlim(1,is)),-1.0)
          if (img .gt. 1) nmolshift=nmolshift+1
c         See if image is now in the central cell
          call shiftmol(c0,1,cell(1,img),c0,-1.0)
          call genimdist123dim(c0,cell,1,ncell,ixyzexcld,ixyzincld,
     -      img,rmin2)
          nrep=nrep+1
        end do
      end do
      return
      end
      subroutine setrepats(nsegslt,molsltlim,nslt,nneig,ineig,
     -  molresflag,minresflag,it1,it2,maxneig,maxrsd,igl)
      dimension molsltlim(3,maxrsd),nneig(nslt),ineig(maxneig,nslt),
     -  it1(nslt),it2(nslt),molresflag(maxrsd)
      dimension moltyp(3)
      character*1 ctyp
      character*41 question
c     print *,'SETREPATS  maxneig,maxrsd,igl=', maxneig,maxrsd,igl
c     Establish solute molecule centers (if required)
      call zeroiti(moltyp,0,3)
      do is=1,nsegslt
        moltyp(molresflag(is)+1)=moltyp(molresflag(is)+1)+1
      end do
      if (moltyp(3) .gt. 0 .and. minresflag .eq. 0) then
        call askyn(
     - 'Do you want to include the molecular residues in the centering',
     -    62,1,1,molrescent,80)
        if (molrescent .eq. 1) minresflag=minresflag+1
      end if
c     molsltlim(1,im), molslt(2,im): first and last atom of solute molecule im
c     molsltlim(3,im): atom number of topological center;
c                    zero if geom center was selected; -1 if COM is selected
      if (nsegslt .le. 1) then
        nsegslt=1
        molsltlim(1,1)=1
        molsltlim(2,1)=nslt
        molsltlim(3,1)=0
      end if
c     Optionally establish representative atoms
      call quiz(ctyp,ictyp,'g',' ',0,'molecular center',16,0,5,6,igl,25)
      if (ctyp .eq. 'g') then
        do is=1,nsegslt
          molsltlim(3,is)=0
        end do
      else if (ctyp .eq. 'c') then
        do is=1,nsegslt
          molsltlim(3,is)=-1
        end do
      else
        iout=6
        do is=1,nsegslt
          if (ctyp .eq. 't' .and. is .le. 5) iout=6
          call findtcent(ineig,nneig,it1,it2,molsltlim(1,is),
     -      molsltlim(2,is),molsltlim(3,is),iout,maxneig,nslt)
          if (ctyp .eq. 't' .and. is .eq. 6) then
            print *,'Topology center list truncated'
            iout=0
          end if
        end do
        if (ctyp .eq. 'i') then
          do is=1,nsegslt
            write (question,1000) is
100         call getint(question,41,molsltlim(3,is),1,molsltlim(2,is),
     -        molsltlim(3,is),0)
            if (molsltlim(3,is) .lt. molsltlim(1,is) .or.
     -          molsltlim(3,is) .gt. molsltlim(2,is)) then
              print *,'Invalid number'
              go to 100
            end if
          end do
        end if
      end if
      return
1000  format('PBC center atom for solute molecule #',i4)
      end
      subroutine findtcent(ineig,nneig,iparent,list,n0,n,icent,
     -  iout,maxneig,maxat)
c#    MMC routine 463 lstmod: 01/20/05
c*****Find the topology center of a molecule
      dimension ineig(maxneig,maxat),nneig(maxat),list(maxat),
     -  iparent(maxat)
      data ilist /0/
c     print *,'FINDTCENT n0,n,maxneig,maxat=',n0,n,maxneig,maxat
      if (n .eq. n0) then
        icent=n0
        return
      end if
      do ir=1,2
        nsteps=0
        do i=n0,n
          iparent(i)=0
        end do
        if (ir .eq. 1) then
c         First grow neigbour list from n0
          ic=n0
        else
c         Now grow from list(ilist)
          ic=list(ilist)
        end if
        iparent(ic)=ic
        ilistf=1
        ilistl=1
        list(ilistf)=ic
        do while (ilistl .ge. ilistf)
          nsteps=nsteps+1
          ilist=ilistl
          do il=ilistf,ilistl
            ic=list(il)
            do in=1,nneig(ic)
              ia=ineig(in,ic)
              if (ia .ge. n0 .and. ia .le. n) then
c               Consider only atoms within the range
                if (iparent(ia) .eq. 0) then
                  iparent(ia)=ic
                  ilist =ilist+1
                  list(ilist)=ia
                end if
              end if
            end do
          end do
          ilistf=ilistl+1
          ilistl=ilist
        end do
c       Now list(ilist) is one of the farthest from ic
c       write (77,1000) n0,n,ir,list(ilist),nsteps
c1000  format(' FINDCENT: Center search for atoms ',i5,' - ',i5,
c     -  ': run',i2,' End point: ',i5,' Steps: ',i4)
      end do
c     nsteps is the number of vertices on the longest path, backtrack
c     nsteps/2 to get the center
      ic=list(ilist)
      do ia=1,nsteps/2
        ic=iparent(ic)
      end do
      icent=ic
      if (iout .gt. 0) write (iout,1001) icent,n0,n
      return
1001  format(' Center found:',i5,' in atom range [',i5,',',i6,']')
      end
      subroutine updatesolvents(iaskatnum,iaskname,nmax,n,naslv,iasv,
     -  namesv,resnamslv,qsv,pflsv,iwat,iatnum,nconf,iotyp,maxrec)
      character*4 pflsv(100)
      character*8 namesv,resnamslv
      dimension iasv(100),namesv(100),qsv(100),iatnum(maxrec)
      character*5 crdext
      character*80 question
      common /iotypes/ iocha,iochaex,iobpdb,iocpdb,ioa3pdb,ioa4pdb,
     -  iommod,iommc,iommc4,iogro,iomol2,iomae,ioins,ionxyz,
     -  iosxyz,iosxyzrq,iograsp,iofull,lext(17),crdext(17)
c     print *,'UPDATESOLVENTS nmax,n,naslv=',nmax,n,naslv
      if (iaskatnum .eq. 0) then
        call askyn('Is the solvent water (O,H,H)',28,1,1,iwat,0)
        if (iwat .eq. 1) then
          naslv=3
          iasv(1)=8
          iasv(2)=1
          iasv(3)=1
          namesv(1)='OH2  '
          namesv(2)='H1   '
          namesv(3)='H2   '
          call getreal('Oxygen charge',13,-0.834,qox,0,0)
          qsv(1)=qox
          qsv(2)=-qox/2.0
          qsv(3)=-qox/2.0
          if (iotyp .eq. ioins .or. iotyp .eq. iommc) then
            if (iotyp .eq. iommc)
     -        print *,"TIP3P oxygen is 'OT' and hydrogen is 'HT'"
            if (iotyp .eq. ioins)
     -        print *,"CVFF oxygen is 'o*' and hydrogen is 'h*'"
            pflsv(1)='    '
            question='Atomtype label for water oxygen'
            call getname(pflsv(1),len,question,31,4,0)
            pflsv(2)='    '
            question(26:32)='hydrogen'
            call getname(pflsv(2),len,question,32,4,0)
            pflsv(3)=pflsv(2)
          end if
        else
          call getint('Number of atoms in a solvent molecule',37,
     -      999999,1,0,naslv,0)
          do i=1,naslv
            question='Atomic number for solvent atom   '
            write (question(31:33),1000) i
            call getint(question,33,999999,1,99,iasv(i),00)
            if (iaskname .eq. 1) then
              question='Atom name for solvent atom   '
              write (question(27:29),1000) i
              call getname(namesv(i),len,question,29,5,0)
              iasv(i)=ianum(namesv(i),0,len)
              call getreal('Charge',9,999999.0,qsv(i),0,0)
              if (iotyp .eq. ioins .or. iotyp .eq. iommc) then
              question='Atom type label for solvent atom   '
              write (question(33:35),1000) i
              call getname(pflsv(i),len,question,35,4,0)
              end if
            end if
          end do
        end if
        if (iaskname .eq. 1 .and. resnamslv .eq. '     ')
     -    call getname(resnamslv,len,'Residue name of the solvent',27,
     -      5,0)
        iaskatnum=1
      end if
      if (mod(n-nmax,naslv) .ne. 0) then
        if (nconf .lt. 10) then
          write (6,1003) naslv,n,nmax
          call askstop(0)
        end if
      end if
      ia=nmax
      nmax=n
      do while (ia .lt. n)
        do ias=1,naslv
          iatnum(ia+ias)=iasv(ias)
        end do
        ia=ia+naslv
      end do
      return
1000  format(i3)
1003  format(' WARNING: extra atoms dont form full solvents',/,
     -  ' Number of atoms/solvent=',i5,/,
     -  ' Total number of atoms=',i10,/,
     -  ' Number of already existing atoms=',i10)
      end
      subroutine unpacktraj(inptrajtyp,mmctrajtyp,inpcrdtyp,iotyp,
     -  inpcrdtyporg,n,nslt,naslv,islvw,numres,numslv,resnamslv,iatnum,
     -  ifchrg,ixres,atnames,resnames,segnames,marker,ireseq,
     -  iresnrestart,iresidrestart,c,rprox,cv,charge,ntitlin,title,
     -  nneig,nneiga,nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,
     -  isegno,iresno,line,blankline,ifree,icntrl,innlist,mmtype,ibnd,
     -  index,indexn,indexo,molresflag,hblimfac,angmin,ioppbc,cell,
     -  ncell,ionefile,iwhead,imodel,numsel,iconfsel,idupl,nclstmem,
     -  numconsec,incr_fileno,nextconfsel,iqspaceask,keeprem,radtodeg,
     -  ioverallconf,maxconfsel,maxrepconf,maxng,maxrsd,maxrec,mx2d)
      character* 132 line(maxrec),blankline
      dimension nneig(maxrec),ineig(maxng,maxrec),iatnum(maxrec),
     -  ifchrg(maxrec),ixres(maxrec),c(3,maxrec),rprox(maxrec),
     -  cv(maxrec),nhbneig(maxrec),nneiga(maxrec),isegno(maxrec),
     -  iresno(maxrec),ifree(maxrec),charge(maxrec),nhneig(maxrec),
     -  nnneig(maxrec),ncneig(maxrec),nsneig(maxrec),npneig(maxrec),
     -  mmtype(maxrec),ibnd(maxng,maxrec),index(maxrec),indexn(maxrec),
     -  indexo(maxrec),molresflag(maxrsd),iconfsel(maxconfsel),
     -  idupl(maxrsd),nclstmem(mx2d),cell(3,ncell)
      character*4 pflsv(100),segnames(maxrsd)
      character*8 resnamslv,atnames(maxrec),resnames(maxrsd),namesv(100)
      character*6 marker(16)
      character*80 trtitle(32),title
      character*200 inpfile
      dimension icntrl(20)
      character*5 crdext
      common /iotypes/ iocha,iochaex,iobpdb,iocpdb,ioa3pdb,ioa4pdb,
     -  iommod,iommc,iommc4,iogro,iomol2,iomae,ioins,ionxyz,
     -  iosxyz,iosxyzrq,iograsp,iofull,lext(17),crdext(17)
      character*200 trajnam,outfile
      common /trajname/ trajnam,outfile,ltrajnam,namleno
      character*11 trajformatname
      common /trajectory/ nmmccheck,iftrajtyp(6),trajformatname(6)
      dimension iasv(100),qsv(100)
      data ifirst /1/,ilast /999999/,increment /1/,inpt /70/
c     print *,'UNPACKTRAJ inptrajtyp,mmctrajtyp=',inptrajtyp,mmctrajtyp
      nmax0=n
      nmax=n
      if (numsel .gt. 0) write (6,1010) (iconfsel(i),i=1,numsel)
      call opentraj(c,1,inpt,inptrajtyp,n,ntitltr,trtitle,
     -  inpcrdtyp,ifirst,ilast,increment,maxconf,ninconf,noutconf,
     -  natom,nfreeat,ifree,icntrl,1,mmctrajtyp,trajnam,ltrajnam,
     -  'trajectory',10,iconfsel,numsel,1,0,0,0,icellfound,notfnd,0,
     -  0,0,maxconfsel,maxrec)
      if (ionefile .eq. 0) then
        call getname(inpfile,namleni,
     -    'Output coordinate file (without the extension)',46,200,0)
        ic=namleni+1
        inpfile(ic:ic)='.'
        inpfile(ic+1:ic+3)=crdext(iotyp)
        namleni=namleni+4
      else
        call getname(inpfile,namleni,'Output coordinate file',22,200,0)
      end if
      ifail=0
      iaskatnum=0
      nntest=0
      nclustermem=0
      do while (ninconf .lt. ilast .and. ifail .eq. 0)
c       Read a conformation
        call readtraj(inpt,inptrajtyp,mmctrajtyp,n,naslv,nwatr,nslt,
     -    trajformatname(inptrajtyp),ntitltr,trtitle,trajnam,ltrajnam,
     -    natom,nfreeat,ifree,icntrl,c,ninconf,noutconf,
     -    increment,inpcrdtyp,ietot,etot,ifail,ifirst,ilast,iconfsel,
     -    numsel,maxrepconf,nmc,1.0,maxconf,maxconfsel,maxrec)
        if (ifail .eq. 0) then
          if (nntest .eq. 0) then
            call comparetop(c,n,nneig,ineig,iatnum,innlist,n,1,
     -        cell,ncell,ioppbc,maxng,maxrec)
            nntest=1
          end if
          ifilenum=0
          if (numsel .gt. 0) then
c           List-directed unpacking - check list
            if (ninconf .eq. iconfsel(nextconfsel)) then
c             Selection found - increment nextconfsel
              ifilenum=ninconf
              nclustermem=nclstmem(nextconfsel)
              if (nextconfsel .lt. min0(numsel,maxconfsel))
     -          nextconfsel=nextconfsel+1
            else if (iconfsel(nextconfsel) .eq. 0) then
              ifail=1
            end if
          else
c           Full unpacking
            if (ninconf .ge. ifirst .and.
     -        mod(ninconf-ifirst,increment) .eq. 0)
     -          ifilenum=noutconf+incr_fileno+1
          end if
          if (ifilenum .gt. 0) then
c           Write a conformation
            noutconf=noutconf+1
            ifnumw=ifilenum
            if (numconsec .gt. 0) ifnumw=noutconf
            if (noutconf .eq. 1 .or. ionefile .eq. 0) then
              if (ionefile .eq. 0) then
                call filenamenum(inpfile,namleni,outfile,nl1,ifnumw,+2)
              else
                outfile=inpfile
                nl1=namleni
              end if
              call openfile(20,0,'output',6,'new',outfile,nl1,
     -          notfnd,2,1,1,0,ioverallconf)
              if (notfnd .eq. 1) then
                write (6,1012) outfile(1:nl1)
                call askyn(
     -            'Do you want to overwrite all existing files',43,1,-1,
     -            ioverallconf,0)
                if (ioverallconf .eq. 0) stop
                call openfile(20,0,'output',6,'new',outfile,nl1,
     -            notfnd,2,1,1,0,ioverallconf)
              end if
            end if
            iwheadp=iwhead
            if (noutconf .eq. 1) iwheadp=1
            if (n .gt. nmax) then
c             Add extra solvents
              nmax0=nmax
              call updatesolvents(iaskatnum,1,nmax,n,naslv,iasv,namesv,
     -          resnamslv,qsv,pflsv,iwat,iatnum,noutconf,iotyp,maxrec)
            end if
            call writeconf(20,inpcrdtyp,iotyp,inpcrdtyporg,nmax0,n,nslt,
     -        naslv,islvw,iasv,namesv,qsv,pflsv,1,iwheadp,imodel,iatnum,
     -        ifchrg,noutconf,innlist,c,rprox,cv,ixres,iresno,atnames,
     -        resnames,segnames,charge,isegno,marker,ntitlin,0,title,
     -        ireseq,iresnrestart,iresidrestart,nneig,nneiga,nhbneig,
     -        ineig,nhneig,nnneig,ncneig,nsneig,npneig,numres,numslv,
     -        resnamslv,line,blankline,mmtype,ibnd,index,indexn,indexo,
     -        0,molresflag,idupl,hblimfac,angmin,0,1,0,0,
     -        noutconf-1,5,iqspaceask,0,ifilenum,etot,ietot,nclustermem,
     -        0,keeprem,iwriteatsym,radtodeg,maxrepconf,maxng,maxrsd,
     -        maxrec)
            if (ionefile .eq. 0) close (20)
            if (noutconf .eq. 1) inpcrdtyp=iotyp
          end if
        end if
      end do
      if (ionefile .eq. 1) close (20)
      close(inpt)
      write (6,1011) noutconf
      return
1010  format(' Unpacking trajectory frames ',(/,10i7))
1011  format(' Completed unpacking trajectory into ',i6,
     -  ' configurations')
1012  format(' Problem opening file ',a)
      end
      subroutine opentraj(c,irept,inpt,inptrajtyp,n,ntitltr,trtitle,
     -  inpcrdtyp,ifirst,ilast,increment,maxconf,ninconf,noutconf,
     -  natom,nfreeat,ifree,icntrl,iaskalways,mmctrajtyp,inpfile,
     -  namlent,prompt,lprompt,iconfsel,numsel,iverb,notitprint,
     -  icont_traj,idatapath,icellfound,notfnd,iconfirmname,
     -  iopen_rep,iout_lim,maxconfsel,maxrec)
      dimension c(3,maxrec),ifree(maxrec)
      character*(*) prompt
      character*80 trtitle(32)
      character*200 inpfile
      dimension iconfsel(maxconfsel)
      character*4 chhd
      character*11 trajformatname
      common /trajectory/ nmmccheck,iftrajtyp(6),trajformatname(6)
      real*8 xtlabc,xtlabc0
      common /boxdat/ xtlabc(6),xtlabc0(6),box(3),box0(3),edge_gen(3,3),
     -  cell0(3,27),cell(3,27),cellalt(3,27),
     -  ncell,ioppbc,noboxinfoar,noboxinfow,noboxrep,
     -  istuner,iboxtypfound,ixcrd(3),ixang(3),ixyzhex(3),
     -  ixyzhextraj(3),isizewarn
      real*8 xtlabct
      dimension xtlabct(7),z(10),zz(10),edg(3),icntrl(20)
      character*5 crdext
      common /iotypes/ iocha,iochaex,iobpdb,iocpdb,ioa3pdb,ioa4pdb,
     -  iommod,iommc,iommc4,iogro,iomol2,iomae,ioins,ionxyz,
     -  iosxyz,iosxyzrq,iograsp,iofull,lext(17),crdext(17)
      character*12 recordn
c     print *,'OPENTRAJ iverb,notitprint,irept,iopen_rep=',
c    -  iverb,notitprint,irept,iopen_rep
c     print *,'OPENTRAJ inptrajtyp,mmctrajtyp=',inptrajtyp,mmctrajtyp,
c    -  ' ifirst,ilast=',ifirst,ilast
c     print *,'OPENTRAJ icont_traj=',icont_traj,' IOUT_LIM=',iout_lim
      call blankout(recordn,1,12)
      icellfound=0
      icrorg=0
      if (inptrajtyp .eq. 0) then
        print *,'PROGRAM ERROR: missing trajectory type for ',
     -    prompt(1:lprompt)
        stop
      end if
      ntry=0
      iform=iftrajtyp(inptrajtyp)
      if (mmctrajtyp .eq. 1) iform=2
      noecho=0
      if (iverb .eq. 0) noecho=1
      if (iconfirmname .gt. 0 .and. namlent .gt. 0) then
        print *,'Input trajectory file name=',inpfile(1:namlent)
        call askyn('Do you want to change it',24,1,-1,newn,0)
        if (newn .gt. 0) namlent=0
        iconfirmname=0
      end if
100   call openfile(inpt,0,prompt,lprompt,'old',inpfile,namlent,notfnd,
     -  idatapath,iform,1,noecho,0)
      if (notfnd .eq. 1) return
      rewind inpt
      if (icont_traj .eq. 0) then
        ninconf=0
        noutconf=0
      end if
      ntitltr=0
      if (inptrajtyp .eq. 1) then
c       Open a Charmm trajectory
        recordn='chhd,icntrl '
        chhd='    '
        call zeroiti(icntrl,0,20)
        read(inpt,err=1098,end=1099) chhd,icntrl
        if (chhd .ne. 'CORD') then
          print *,'ERROR:header label is not CORD: ',chhd
          go to 1099
        end if
        recordn='title       '
        read (inpt,err=1098,end=1099) ntitltr
c       print *,'Number of title lines=',ntitltr
        if (ntitltr .lt. 1 .or. ntitltr .gt. 32) then
          print *,'WARNING: invalid number of title lines:',
     -      ntitltr
          ntitltr=0
        else
          do i=1,ntitltr
            call blankout(trtitle(i),1,ntitltr)
          end do
          rewind inpt
          read (inpt)
          read (inpt,err=1098,end=1099) ntitltr,
     -      (trtitle(i),i=1,ntitltr)
        end if
        if (notitprint .eq. 0) then
          if (trtitle(1)(1:21) .eq. 'Created by DCD plugin') then
            print *,'Trajectory written by VMD'
          else 
            if (ntitltr .gt. 1) then
              if (trtitle(ntitltr-1)(1:8) .eq. 'Simulaid') then
                print *,trtitle(ntitltr-1)
                print *,trtitle(ntitltr)
              end if
            end if
            if (ntitltr .eq. 2) then
c             Check for NAMD origin
              ic=0
              do while (ic .lt. 65 .and.
     -                  trtitle(1)(ic+1:ic+15) .ne. 'CREATED BY NAMD')
                ic=ic+1
              end do
              if (trtitle(1)(ic+1:ic+15) .eq. 'CREATED BY NAMD')
     -          print *,'Trajectory written by NAMD'
            end if
          end if
        end if
        read(inpt,err=1098,end=1099) natom
        if (iverb .gt. 0 .and. natom .ne. n) then
          write (6,1020) natom,n
          call askstop(1)
        end if
        nfreeat = natom - icntrl(9)
        if (chhd .ne. 'CORD') then
          write (6,1003) chhd
          namlent=0
          go to 100
        end if
        if (iverb .gt. 0)
     -    write (6,1001) icntrl(1),nfreeat,icntrl(5),icntrl(20)
        if (n .ne. natom) then
          write (6,1002) n,natom
          call askstop(0)
          n=natom
        end if
c       Free atom array
        recordn='ifree       '
        if (icntrl(9) .gt. 0)
     -    read (inpt,err=1098,end=1099) (ifree(i),i=1,nfreeat)
c       Test for presence of cell information
        icell=0
        recordn='cell info1'
        xtlabct(7)=999999.9
        read (inpt,err=200,end=200) xtlabct
c       Rewind and skip back (to be on the safe side)
200     rewind inpt
        read(inpt)
        read(inpt)
        read(inpt)
        if (icntrl(9) .gt. 0) read(inpt)
        read (inpt,err=200,end=200) (xtlabct(i),i=1,6)
        if (xtlabct(7) .eq. 999999.9) then
c         Cell information was found
          noboxinfoar=0
          icellfound=1
          iboxtypfound=1
          icell=1
          call trnsfrd(xtlabc,xtlabct,6)
          call trnsfrd(xtlabc0,xtlabct,6)
          if (iverb .gt. 0 .or. ioppbc .eq. 4 .or. ioppbc .eq. 5) then
            write (6,1007) 'size',(xtlabc0(ixcrd(k)),k=1,3)
            write (6,1007) 'angle/cos',(xtlabc0(ixang(k)),k=1,3)
          end if
          if (ioppbc .eq. 1 .or. ioppbc .eq. 2) then
            do k=1,3
              edg(k)=xtlabc0(ixcrd(k))
            end do
            icrorg=1
          else if (ioppbc .eq. 5) then
c           Skewed hexagon
            edg(1)=xtlabc0(ixcrd(3))
            edg(2)=xtlabc0(ixcrd(2))
            edg(3)=xtlabc0(ixcrd(1))
            icrorg=1
          end if
c         Test for cell data before 2nd config
          recordn='1st config'
          read(inpt,err=1098,end=1099)
          read(inpt,err=1098,end=1099)
          read(inpt,err=1098,end=1099)
          xtlabct(7)=999999.9
          recordn='cell info2'
          read(inpt,err=201,end=201) xtlabct
201       if (xtlabct(7) .eq. 999999.9) then
            icell=2
            if (iverb .gt. 0)
     -        print *,'Cell information is read for each configuration'
            iboxtypfound=2
          else
            if (iverb .gt. 0)
     -        print *,'Cell information is read only at start'
          end if
          if (icntrl(11) .eq. 0) then
            print *,'Suspect: icntrl(11)=',icntrl(11)
          end if
        else
          if (iverb .gt. 0) then
            print *,'No cell information'
            if (icntrl(11) .ne. 0)
     -        print *,'Suspect: icntrl(11)=',icntrl(11)
          end if
          noboxinfoar=1
        end if
        icntrl(11)=icell
c       Reposition trajectory
        rewind inpt
        read(inpt)
        read(inpt)
        read(inpt)
        if (icntrl(9) .gt. 0) read(inpt)
      else if (inptrajtyp .eq. 2) then
c       Open an Amber trajectory
        if (nmmccheck .eq. 0 .and. inpcrdtyp .eq. iommc) then
          write (6,1021) n
          call askyn('Do you want to change it (to include solvents)',
     -      46,1,-1,newn,0)
          if (newn .eq. 1) call getint('New number of atoms',19,1,1,
     -      maxrec,n,0)
          nmmccheck=1
        else if (iverb .gt. 0) then
          write (6,1021) n
        end if
        recordn='title       '
        read (inpt,1000,err=1098,end=1099) trtitle(1)
        ntitltr=1
        if (iverb .gt. 0) write (6,1010) trtitle(1)
c       Find first box info record
        recordn='first struc.'
        nleft=3*n
        do while (nleft .gt. 0)
          nread=min0(10,nleft)
          read (inpt,1012,err=1098,end=1097) (z(i),i=1,nread)
          nleft=nleft-10
        end do
        noboxinfoar=1
        iboxtypfound=1
        call zeroit(z,10)
        read (inpt,1012,err=1098,end=1097) (z(i),i=1,10)
        call countzeros(z,10,nzero1)
c       Check if box info was present after the 2nd config.
        nzero2=0
        if (nzero1 .ge. 7) then
          icellfound=1
          noboxinfoar=0
c         Save the first box and skip to the end of the second frame
          call trnsfr(box0,z,3)
c         See if there is second box info
          recordn='secnd struc.'
          nleft=3*n
          do while (nleft .gt. 0)
            nread=min0(10,nleft)
            read (inpt,1012,err=1098,end=1097) (zz(i),i=1,nread)
            nleft=nleft-10
          end do
          call zeroit(zz,10)
          read (inpt,1012,err=1098,end=1097) (zz(i),i=1,10)
          call countzeros(zz,10,nzero2)
          if (nzero2 .ge. 7) then
            noboxrep=0
            iboxtypfound=2
            if (iverb .gt. 0) print *,'Box information was found after',
     -        ' each structure'
          else if (iverb .gt. 0) then
            print *,'NOTE: Box information appears to be missing after',
     -        ' the first structure'
          end if
        else if (iverb .gt. 0) then
          print *,'No box information was found at all'
          iboxtypfound=0
        end if
        if (nzero1 .gt. 7 .and. iverb .gt. 0)
     -    write (6,1006) 'First',(z(k),k=1,3)
        if (nzero2 .gt. 7 .and. iverb .gt. 0)
     -    write (6,1006) 'Second',(zz(k),k=1,3)
c       Reposition trajectory
        rewind inpt
        read (inpt,1000) trtitle(1)
      else if (inptrajtyp .ge. 3 .and. inptrajtyp .le. 5) then
        ntitltr=0
        if (inptrajtyp .eq. 3) then
c         MMC trajectory
          if (noboxinfoar .eq. -1 .and. mmctrajtyp .ne. 1)
     -      call askyn('Is the trajectory from a (T,P,N) run',
     -        36,0,-1,noboxinfoar,0)
          if (mmctrajtyp .eq. 1) then
            call binhst_type(inpt,c,ibox,istuner,ieof,6,maxrec)
            if (ieof .gt. 0) call askstop(1)
            if (iopen_rep .eq. 0) then
              if (ibox .gt. 0) print *,'Box information was found'
              if (istuner .gt. 0) print *,'Tuning information was found'
              if (ibox+istuner .eq. 0)
     -          print *,'Neither tuning nor box information was found'
            end if
            if (noboxinfoar .ne. -1 .and. noboxinfoar .ne. 1-ibox) then
              write (6,1008)
              call askstop(1)
            end if
            noboxinfoar=1-ibox
            read (inpt,err=1098,end=1999) nwat,natoms
            read (inpt,err=1098,end=1999)
            read (inpt,err=1098,end=1999) box0
1999        rewind inpt
            if (iverb .gt. 0) write (6,1011) natoms,nwat
            if (iverb .gt. 0 .and. natoms .ne. n) then
              write (6,1020) natoms,n
              call askstop(1)
            end if
          end if
          icellfound=1-noboxinfoar
          if (noboxinfoar .eq. 0) iboxtypfound=2
        end if
        trtitle(1)(1:27)='Trajectory generated by MMC'
      else if (inptrajtyp .eq. 6) then
c       Amber CDF
        print *,'Under implementation'
        stop
      else if (inptrajtyp .gt. 6) then
        print *,'Trajectory input type ',inptrajtyp,' is not yet done'
        stop
      end if
      if (iverb .gt. 0) then
        write (6,1013) trajformatname(inptrajtyp),inpfile(1:namlent)
        if (ntitltr .gt. 0)
     -    write (6,1014) (trtitle(i)(1:79),i=1,ntitltr)
      end if
      if (irept .eq. 1) then
        if (icrorg .eq. 1) then
          if (ioppbc .lt. 0) then
c           Set PBC to cubic, ask for size
            print *,'PBC type is unknown - it is set to cubic'
            ioppbc=1
            npbc=1
            call pbcsize(ioppbc,edg,npbc)
          end if
c         Recreate the cell from the first frame's cell size
          call crorgn(edg,edge_gen,ioppbc,3,ncell,cell,cellalt,
     -      ixyzhex,rinscr,rcirc)
          call trnsfr(cell0,cell,3*ncell)
          write (6,1016) edg
        else if (ncell .gt. 0) then
          call trnsfr(cell0,cell,3*ncell)
          if (isizewarn .eq. 1) write (6,1015)
          isizewarn=0
        end if
      end if
      if (icont_traj .eq. 0) then
        if (irept .eq. 1 .or. iaskalways .eq. 1) then
          if (numsel .eq. 0) then
c           See if a list is given for snapshots to be read
            call askyn('Do you have a list of configurations to read',
     -        44,1,-1,igetlist,0)
            if (igetlist .eq. 1) then
              call getlist(iconfsel,numsel,1,999999,1,maxconfsel)
              maxconf=numsel
            end if
          else
            maxconf=numsel
          end if
          if (numsel .eq. 0) then
            idefl=ilast
            ideff=max0(1,ifirst)
            if (inptrajtyp .eq. 1) idefl=icntrl(1)
            call getrange(ifirst,ideff,ilast,idefl,increment,1,
     -        'structure to use from trajectory',32,0,0)
            if (ilast .eq. 0) ilast=999999
            maxconf=(ilast-ifirst)/increment+1
            print *,'Number of configurations to use=',maxconf
          end if
          if (iout_lim .gt. 0) then
            if (numsel .gt. 0) then
              write (iout_lim,1009) (iconfsel(i),i=1,numsel)
            else
              write (iout_lim,1017) ifirst,ilast,increment
            end if
          end if
        end if
      end if
      icntrl(3)=icntrl(3)*increment
      return
1097  print *,'Amber trajectory must contain at least 3 structures'
      return
1098  write (6,1004) trajformatname(inptrajtyp),'invalid'
      print *,'Problem occured while trying to read ',recordn
      if (inptrajtyp .eq. 1) then
        print *,'chhd=',chhd
        print *,'icntrl=',icntrl
        print *,'ntitltr=',ntitltr
      end if
      namlent=0
      ntry=ntry+1
      if (ntry .lt. 3) go to 100
      stop
1099  write (6,1004) trajformatname(inptrajtyp),'incomplete'
      if (recordn(1:2) .ne. '  ')
     -  print *,'Problem occured while trying to read ',recordn
      namlent=0
      if (inptrajtyp .eq. 1) write (6,1005)
      write (6,1019) inpfile(1:namlent)
      ntry=ntry+1
      if (ntry .lt. 3) go to 100
      stop
1000  format(a)
1001  format(' Number of data sets: ',i7,/,
     -  ' Number of free atoms=',i7,' Number of fixed atoms=',i7,/,
     -  ' Charmm version=',i4)
1002  format(' WARNING: The number of atoms inputted (',i8,
     -  ') is different from',/,10x,'the number of atoms on the ',
     -  'Charmm trajectory file (',i8,')',/,10x,'The trajectory ',
     -  'file value will be used')
1003  format(' WARNING: Charm trajectory file 4-character ',
     -  'header is incorrect: ',a4,' should be CORD',/,
     -  ' Make sure that Simulaid is compiled with the same byte order',
     -  ' as the DCD file')
1004  format(' ERROR: ',a,' trajectory file entry is ',a)
1005  format(' Make sure Simulaid was compiled with the same byte ',
     -  'order',/,' as the trajectory file was run')
1006  format(' WARNING: ',a,' box information includes zero edges:',
     -  3f7.2)
1007  format(' Initial PBC box ',a,' information:',3f12.6)
1008  format(' Conflicting box information - probable progam error')
1009  format(' Frame numbers selected to be used:',/,(10i6))
1010  format(' Amber trajectory file title:',/,1x,a)
1011  format(' MMC binary trajectory - number of atoms=',i10,
     -  ' Number of solvents=',i8)
1012  format(10f8.3)
1013  format(1x,a,' trajectory file ',a,' opened')
1014  format(' Title:',/,(1x,a))
1015  format(' Make sure that the PBC size read is IDENTICAL to ',
     -  'the size of the first frame')
1016  format(' Cell edges are set from the trajectory to',/,3f10.5)
1017  format(' First frame to use=',i6,/,' Last frame to use=',i6,/,
     -  ' Increment=',i5)
1019  format(' Trajectory file opened: ',a)
1020  format(' WARNING: number of atoms found (',i8,') differs from ',
     -  'the',/,10x,'number of atoms expected (',i8,')')
1021  format(' Opening Amber trajectory, number of atoms per structure',
     -  '=',i8)
      end
      subroutine binhst_read(ihist,c,etoto,nmc,nwatr,ieof,iout,
     -  maxat)
      dimension c(3,maxat)
      real*8 etoto
c     Read header and coordinate record from a binary history file
      real*8 uusfacd,tesi(4)
c     print *,'BINHST_READ maxat=',maxat
      ieof=0
      read (ihist,end=888,err=888) nwatr,natomsr,uusfacd,nmc,nidmc,
     -  niaccp,ndaccp,ia0,ia1,etoto,tesi,cplpar
      nmolecr=nwatr+1
      nsvp=0
      if (nwatr .gt. 0) nsvp=(natomsr-(ia1-ia0+1))/nwatr
      if (nwatr .gt. 0) then
        read (ihist,end=999,err=999) ((c(k,ii),k=1,3),ii=ia0,ia1),
     -    (((c(k,ia1+(i-1)*nsvp+j),k=1,3),j=1,nsvp),i=1,nwatr)
      else
        read (ihist,end=999,err=999) ((c(k,ii),k=1,3),ii=ia0,ia1)
      end if
      return
888   ieof=1
      if (iout .gt. 0) write(iout,*) 'File header is truncated'
      return
999   ieof=2
      if (iout .gt. 0)
     -   write(iout,*) 'First coordinate record is in error'
      return
c2000  format(' nwat,nats=',2i11,' nmc=',i10,' ia0,ia1=',2i6,
c     -  ' nsv=',i2,/,
c     -  ' etot=',e13.5,' tesi=',4e12.5,/,' cplpar=',e12.5)
      end
      subroutine binhst_type(ihist,c,ibox,istuner,ieof,iout,
     -  maxat)
      dimension c(3,maxat)
c     Determine if MMC binary trajectory file has box and/or tuning info
      real*8 etoto
      dimension test5(5),test4(4),test3(3)
      character*4 chhd
c     print *,'BINHST_TYPE maxat=',maxat
c     Check for mistaken Charrm dcd
      read (ihist,end=888,err=888) chhd
      if (chhd .eq. 'CORD' .or. chhd .eq. 'VELD') then
        print *,'Trajectory is a Charmm DCD file'
        stop
      end if
      rewind ihist
      ieof=0
      istuner=0
      ibox=0
      call binhst_read(ihist,c,etoto,nmc,nwatr,ieof,0,maxat)
      read (ihist,end=100,err=100) test5
c     New header was found
      rewind ihist
      return
c     Tuning and/or box record found
100   rewind ihist
      call binhst_read(ihist,c,etoto,nmc,nwatr,ieof,0,maxat)
      read (ihist,end=200,err=200) test4
c     Tuning record was found - no box info
      istuner=1
      rewind ihist
      return
200   rewind ihist
c     There must be box information
      ibox=1
      call binhst_read(ihist,c,etoto,nmc,nwatr,ieof,0,maxat)
      read (ihist,end=888,err=888) test3
      read (ihist,end=300,err=300) test5
c     No tuning info
      rewind ihist
      return
300   rewind ihist
c     There is be tuning iformation too information
      istuner=1
888   ieof=1
      if (iout .gt. 0)
     -   write(iout,*) 'First box info record is in error'
      return
      end
      subroutine countzeros(z,n,nzero)
      dimension z(n)
      nzero=0
      do i=1,n
        if (z(i) .eq. 0.0) nzero=nzero+1
      end do
      return
      end
      subroutine readtraj(inpt,inptrajtyp,mmctrajtyp,n,naslv,nwatr,nslt,
     -  trajformatname,ntitltr,trtitle,trajnam,ltrajnam,natom,
     -  nfreeat,ifree,icntrl,c,ninconf,noutconf,increment,inpcrdtyp,
     -  ietotread,etot,ifail,ifirst,ilast,iconfsel,numsel,maxrepconf,
     -  nmc,tofac,maxconf,maxconfsel,maxrec)
      dimension c(3,maxrec),ifree(maxrec),icntrl(20),
     -  iconfsel(maxconfsel)
      character*11 trajformatname
      character*80 trtitle(32)
      character* 132 line
      character* 200 trajnam,trajnam_n(2)
      real*8 xtlabc,xtlabc0
      common /boxdat/ xtlabc(6),xtlabc0(6),box(3),box0(3),edge_gen(3,3),
     -  cell0(3,27),cell(3,27),cellalt(3,27),
     -  ncell,ioppbc,noboxinfoar,noboxinfow,noboxrep,
     -  istuner,iboxtypfound,ixcrd(3),ixang(3),ixyzhex(3),
     -  ixyzhextraj(3),isizewarn
      character*1 separatorchar
      common /filenuminfo/ iaskunderscore,separatorchar
      character*1 xyz
      common /axislab/ xyz(3)
      real*8 db(6)
      dimension istune(4),ltrajnam_n(2)
      data k /0/
c     print *,'READTRAJ inpt=',inpt,' nslt,n=',nslt,n
      ifail=0
      ncol=80
      etot=0.0
      ninconf=ninconf+1
      iverbconf=1
      if (ninconf .gt. maxrepconf) iverbconf=0
      ietotread=0
      if (inptrajtyp .eq. 1) then
        ncol=0
        if (ninconf .eq. 1) then
          limic11=0
          if (natom .gt. n) then
            n=natom
            write (6,1009) n
          end if
        else
          limic11=1
        end if
        if (icntrl(11) .gt. limic11) then
          read(inpt,err=1095,end=1099) (xtlabc(j),j=1,6)
          do k=1,3
            box(k)=xtlabc(ixcrd(k))*tofac
          end do
          noboxinfoar=0
        else
          noboxinfoar=1
        end if
        if (icntrl(9) .gt. 0 .and. ninconf .gt. 1) then
          do k=1,3
            read(inpt,err=1096,end=1099) (c(k,ifree(j)),j=1,nfreeat)
          end do
        else
          do k=1,3
            read(inpt,err=1098,end=1099) (c(k,j),j=1,natom)
          end do
        end if
        nmc=nmc+1
      else if (inptrajtyp .eq. 2) then
        read (inpt,1012,err=1098,end=1099) ((c(k,i),k=1,3),i=1,n)
        if (noboxinfoar .eq. 0) then
          read (inpt,1012,err=1098,end=1099) box
        end if
c       Just use input edge info
        do k=1,3
          xtlabc(ixcrd(k))=box(k)
          xtlabc(ixang(k))=90.0
        end do
        nmc=nmc+1
      else if (inptrajtyp .eq. 3) then
        nsvp=min0(naslv,3)
        ncol=0
        if (mmctrajtyp .eq. 1) then
c         Binary MMC
          read (inpt,err=2099,end=1099) nwatr,natr,db(1),nmc,nidmc,
     -      i3,i4,ia0,ia1,(db(i),i=2,6),r1
          etot=db(2)
          ietotread=1
          if (nwatr .lt. 0 .or. natr .lt. 0 .or. nmc .lt. 0
     -      .or. nwatr .gt. maxrec/naslv .or. natr .gt. maxrec) then
            write (6,1013)
            stop
          end if
          read (inpt,err=2099,end=1099)
     -      ((c(k,j),k=1,3),j=ia0,ia1),(((c(k,ia1+(i-1)*naslv+j),
     -      k=1,3),j=1,nsvp),i=1,nwatr)
          if (noboxinfoar .eq. 0) read (inpt,err=2099,end=1099) box
          if (istuner .gt. 0) then
c           Skip tuning info
            read (inpt,err=2099,end=1099) istune
            if (istune(1)+istune(2) .gt. 0)read (inpt,err=2099,end=1099)
            if (istune(3) .gt. 0) read (inpt,err=2099,end=1099)
            if (istune(4) .gt. 0) read (inpt,err=2099,end=1099)
          end if
          n=nslt+nwatr*naslv
        else if (mmctrajtyp .eq. 2 .or. mmctrajtyp .eq. 3) then
          read (inpt,1000,end=1099) line(1:80)
          read (line(1:80),1019,err=1097)
     -      natomp,nmolec,n,ia0,ia1,nmc,cplpar
          n=nslt+(nmolec-1)*naslv
          if (mmctrajtyp .eq. 2) then
c           ASCII MMC
            do i=ia0,ia1
              read (inpt,1000,end=1099) line(1:80)
              read (line(1:80),1017,err=1098) (c(k,i),k=1,3)
            end do
            do iw=2,nmolec
              do j=1,nsvp
                read (inpt,1000,end=1099) line(1:80)
                read (line(1:80),1017,err=1098)
     -            (c(k,nslt-2*naslv+iw*naslv+j),k=1,3)
              end do
            end do
          else if (mmctrajtyp .eq. 3) then
c           Annotated ASCII MMC
            do i=ia0,ia1
              read (inpt,1000,end=1099) line(1:80)
              read (line(1:80),1018,err=1098) (c(k,i),k=1,3)
            end do
            do iw=2,nmolec
              do j=1,nsvp
                read (inpt,1000,end=1099) line(1:80)
                read (line(1:80),1018,err=1098)
     -            (c(k,nslt-2*naslv+iw*naslv+j),k=1,3)
              end do
            end do
          end if
          read (inpt,1015,end=1099) db(1)
          read (inpt,1000,end=1099)
          etot=db(1)
          ietotread=1
          if (noboxinfoar .eq. 0) read (inpt,1010,end=1099) box
        else if (mmctrajtyp .eq. 4) then
c         PDB
          nmc=nmc+1
          nr=0
          line(1:3)='   '
          do while (line(1:3) .ne. 'END')
            call blankout(line,1,80)
            read (inpt,1000,end=1100) line(1:80)
            if (line(1:4) .eq. 'ATOM' .or. line(1:6) .eq. 'HETATM') then
              nr=nr+1
              read (line(31:54),1011,err=1098) (c(k,nr),k=1,3)
            else
              call checkforetot(6,line,ninconf,etot,ietotread,iverbconf)
            end if
          end do
1100      n=nr
          if (n .eq. 0) then
            if (nr .gt. 0) write (6,1020) ninconf
            ifail=1
            return
          end if
        else if (mmctrajtyp .eq. 5) then
c         Charmm CRD
          call blankout(line,1,80)
          read (inpt,1000,end=1099) line(1:80)
          do while (line(1:1) .eq. '*')
            call checkforetot(1,line,ninconf,etot,ietotread,iverbconf)
            read (inpt,1000,end=1099) line(1:80)
          end do
          read(line(1:5),1002,err=1098) n
          do i=1,n
            read (inpt,1000,end=1099) line(1:80)
            read (line(1:50),1003,err=1098) (c(k,i),k=1,3)
          end do
          nmc=nmc+1
        end if
      else if (inptrajtyp .eq. 6) then
c       Amber CDF

        nmc=nmc+1
      else if (inptrajtyp .eq. 4 .or.
     -  inptrajtyp .eq. 5 .and. ninconf .eq. 1) then
        ncol=132
        read (inpt,1000,err=1098,end=1099) trtitle(1)
        do i=1,n
          read (inpt,1001,err=1098,end=1099) line
          read (line(53:88),1016,err=1098) (c(k,i),k=1,3)
        end do
        nmc=nmc+1
      else if (inptrajtyp .eq. 5 .and. ninconf .gt. 1) then
        ncol=132
        read (inpt,1000,err=1098,end=1099) line
        do i=1,n
          read (inpt,1000,err=1098,end=1099) line
          read (line(6:41),1016,err=1098) (c(k,i),k=1,3)
        end do
        nmc=nmc+1
      end if
      if (inptrajtyp .gt. 1) then
c       Just in case, generate Charmm edges
        do k=1,3
          xtlabc(ixcrd(k))=box(k)*tofac
          xtlabc(ixang(k))=90.0
        end do
      end if
      return
1095  write (6,1004) ninconf,trajformatname,' xtal   '
      if (ncol .gt. 0) write (6,1006) line(1:ncol)
      ifail=1
      return
1096  write (6,1004) ninconf,trajformatname,' coordinate ',xyz(k)
      write (6,*) 'nfreeat,natom=',nfreeat,natom
      if (ncol .gt. 0) write (6,1006) line(1:ncol)
      ifail=1
      return
1097  write (6,1004) ninconf,trajformatname,' header '
      if (ncol .gt. 0) write (6,1006) line(1:ncol)
      ifail=1
      return
1098  write (6,1004) ninconf,trajformatname,' coordinate ',xyz(k)
      if (ncol .gt. 0) write (6,1006) line(1:ncol)
      ifail=1
      return
1099  if (ilast .eq. 999999) then
        write (6,1008) trajformatname,ninconf-1
        ilast=ninconf-1
c       print *,'n,nslt=',n,nslt
      else
c       Generate the next trajectory name
        call nextnames(trajnam,ltrajnam,trajnam_n,ltrajnam_n,ntraj)
        ntry=0
        do while (ntry .lt. ntraj)
          ntry=ntry+1
          call opentraj(c,1,inpt,inptrajtyp,n,ntitltr,trtitle,inpcrdtyp,
     -      ifirst,ilast,increment,maxconf,ninconf,noutconf,natom,
     -      nfreeat,ifree,icntrl,1,mmctrajtyp,trajnam_n(ntry),
     -      ltrajnam_n(ntry),'input trajectory',16,iconfsel,numsel,
     -      0,1,1,2,icellfound,notfnd,0,0,0,maxconfsel,maxrec)
          if (notfnd .eq. 0) then
            trajnam=trajnam_n(ntry)
            ltrajnam=ltrajnam_n(ntry)
            write (6,1014) trajnam(1:ltrajnam)
            ntry=ntraj
          end if
        end do
        if (notfnd .gt. 0) then
          write (6,1005) trajformatname,ninconf,
     -     (trajnam_n(ntry)(1:ltrajnam_n(ntry)),ntry=1,ntraj)
          if (ncol .gt. 0) write (6,1007) line(1:ncol)
          ifail=1
        end if
      end if
      return
2099  print *,'ERROR: invalid binary MMC record found - ending scan'
      ifail=1
      return
1000  format(a80)
1001  format(a132)
1002  format(i5)
1003  format(20x,3f10.0)
1004  format(' ERROR: configuration #',i5,' of the ',a6,
     -  ' trajectory has invalid',a,'input ',a)
1005  format(' ERROR: ',a6,' trajectory unexpectedly ended',/,
     -  8x,'End was found while reading configuration #',i5,/,
     -  ' If the trajectory is in segments, possible names are ',/,
     -  (1x,a))
1006  format(' Line read:',/,a)
1007  format(' Last line read:',/,a)
1008  format(1x,a6,' trajectory was found to contain ',i5,
     -  ' configurations')
1009  format(' Number of atoms set to ',i6,' from the Charmm ',
     -  'trajectory')
1010  format(9x,3f10.0)
1011  format(3f8.0)
1012  format(10f8.3)
1013  format(' ERROR: invalid atom/molecule numbers indicate that',/,
     -  8x,'MMC binary trajectory does not have box info saved',/,
     -  ' - restart without asking for drawing the box')
1014  format(' Next trajectory segment ',a,' opened')
1015  format(19x,e16.6)
1016  format(3f12.5)
1017  format(3f15.5)
1018  format(5x,3f15.5)
1019  format(i6,9x,i6,8x,i6,7x,2i6,5x,i9,4x,f8.0)
1020  format(' ERROR: no ATOM or HETATM record was found when reading',
     -  ' configuration',i6)
      end
      subroutine nextnames(trajnam,ltrajnam,trajnam_n,ltrajnam_n,ntraj)
      character*200 trajnam,trajnam_n(2)
      character*80 ext
      dimension ltrajnam_n(2)
c     Find out run number/version number category and generate new name options
      do i=1,2
        trajnam_n(i)=trajnam
      end do
      lc=ltrajnam
      do while (trajnam(lc:lc) .ne. '.')
        lc=lc-1
      end do
      lext=ltrajnam-lc+1
      ext(1:lext)=trajnam(lc:ltrajnam)
      lc=lc-1
      lv2=lc
      do while (trajnam(lc:lc) .ne. '.' .and.
     -          trajnam(lc:lc) .ne. '_' .and. lc .gt. 1)
        lc=lc-1
      end do
      if (lc .ge. lv2) go to 100
      read (trajnam(lc+1:lv2),*,err=100) nr
      len_nr=lv2-lc
c     Number read
      if (trajnam(lc:lc) .eq. '.') then
c       x.nr.ext
        lr=lc+1
        ntraj=2
        lc=lv2+2
        trajnam_n(1)(lv2+1:lc)='_2'
        trajnam_n(1)(lc+1:lc+lext)=ext(1:lext)
        ltrajnam_n(1)=lc+lext
        nr=nr+1
        call writeint(trajnam_n(2),lr,nr,len)
        lc=lr-1
        trajnam_n(2)(lc+1:lc+lext)=ext(1:lext)
        ltrajnam_n(2)=lc+lext
      else
        nv=nr
c       x.$_nv.ext
        lr2=lc-1
        do while (trajnam(lc:lc) .ne. '.' .and. lc .gt. 1)
          lc=lc-1
        end do
        lr=lc+1
        if (lc .ge. lr2) go to 200
        read (trajnam(lc+1:lr2),*,err=200) nr
c       x.nr_nv.ext
        nv0=nv
        ntraj=2
        nv=nv+1
        lc=lv2-len_nr+1
        print *,'lv2,lc=',lv2,lc
        call writeint(trajnam_n(1),lc,nv,len)
        lc=lc-1
        trajnam_n(1)(lc+1:lc+lext)=ext(1:lext)
        ltrajnam_n(1)=lc+lext
        nr=nr+1
        lr0=lr
        call writeint(trajnam_n(2),lr,nr,len)
        trajnam_n(2)(lr:lr)='_'
        lr=lr+1
        call writeint(trajnam_n(2),lr,nv0,len)
        lc=lr-1
        trajnam_n(2)(lc+1:lc+lext)=ext(1:lext)
        ltrajnam_n(2)=lc+lext
      end if
      return
200   continue
c     x_nv.ext
      ntraj=2
      lc=lr2+3
      trajnam_n(1)(lr2+1:lc)='.2_'
      lc=lc+1
      call writeint(trajnam_n(1),lc,nv,len)
      lc=lc-1
      trajnam_n(1)(lc+1:lc+lext)=ext(1:lext)
      ltrajnam_n(1)=lc+lext
      lc=lv2
      nv=nv+1
      call writeint(trajnam_n(2),lc,nv,len)
      lc=lc-1
      trajnam_n(2)(lc+1:lc+lext)=ext(1:lext)
      ltrajnam_n(2)=lc+lext
      return
c     x.ext
100   ntraj=2
      lc=lv2+2
      trajnam_n(1)(lv2+1:lc)='.2'
      trajnam_n(1)(lc+1:lc+lext)=ext(1:lext)
      ltrajnam_n(1)=lc+lext
      trajnam_n(2)(lv2+1:lc)='_2'
      trajnam_n(2)(lc+1:lc+lext)=ext(1:lext)
      ltrajnam_n(2)=lc+lext
      return
      end
      subroutine trajlimtest(nframe,MAXFRAMES)
      if (nframe .gt. MAXFRAMES) then
        write (6,1004)
        stop
      end if
1004  format(' Calculation stopped since this option is limited to ',
     -  'reading ',i8,' frames',/,' Recompile with larger value of ',
     -  'the parameter MAXFRAMES')
      end
      subroutine checkforetot(lmarker,line,iconf,etot,ietot,iverb)
      character* 132 line
c     print *,'DB ECHECK lmarker=',lmarker,' line=',line(1:40)
      icol=lmarker+1
      call nextchar(line,icol,80)
      if (icol .gt. 80) return
      icol1=icol
      call nextblank(line,icol,80)
      icol=0
      if (line(icol1:icol1+1) .eq. 'E=') then
        icol=icol1+2
      else if (line(icol1:icol1+6) .eq. 'energy=' .or.
     -    line(icol1:icol1+6) .eq. 'Energy=') then
        icol=icol1+7
      end if
      if (icol .gt. icol1) then
        call nextchar(line,icol,80)
        icol1=icol
        call nextblank(line,icol,80)
        read (line(icol1:icol-1),*,err=100) etot
        ietot=1
        if (iverb .gt. 0)
     -    print *,' Structure ',iconf,' Energy read=',etot
      end if
      return
100   print *,'ERROR: invalid energy value:',line(icol1:icol-1)
      return
      end
      subroutine comparetop(c,n,nneig,ineig,iatnum,innlist,nslt,nslv,
     -  cell,ncell,ioppbc,maxng,mxat)
      dimension c(3,mxat),nneig(mxat),ineig(maxng,mxat),iatnum(mxat),
     -  cell(3,ncell)
      common /connatdat/ ramax(99),ramax2(99),hlimfac,ianfg(99),
     -  namfcg(100),nrmw
c     Check if list of neighbors actually represent bonded pairs
c     print *,'COMPARETOP n,nslt,nslv,ncell=',n,nslt,nslv,ncell
      if (innlist .lt. 0) return
      if (innlist .eq. 0) then
        print *,'PROGRAM ERROR: no neighbour list in topology check'
        return
      end if
      hlimfac=0.7
      discrepmax=0.0
      nfail=0
      do ia=1,n
        do jja=1,nneig(ia)
          ja=ineig(jja,ia)
          if (ja .gt. ia) then
            r2=dist2(c(1,ia),c(1,ja))
            rlm=amax1(ramax2(iatnum(ia)),ramax2(iatnum(ja)))*1.2
            if (iatnum(ia) .eq. 1 .or. iatnum(ja) .eq. 1)
     -         rlm=rlm*hlimfac
            if (r2 .gt. rlm) then
              nfail=nfail+1
              if (nfail .le. 25) write (6,1000) ia,ja,sqrt(r2)
              if (r2 .gt. discrepmax) discrepmax=r2
            end if
          end if
        end do
      end do
      if (nfail .gt. 0) write (6,1001) nfail,sqrt(discrepmax)
      percout=0.0
      if (ioppbc .gt. 0 .and. n-nslt .gt. 100) then
c       See how many solvents are outside the cell
        nout=0
        numslv=(n-nslt)/nslv
        do iw=1,numslv
          call genimdist(c(1,nslt+(iw-1)*nslv+1),cell,1,ncell,img,d2)
          if (img .gt. 1) nout=nout+1
        end do
        if (nout .gt. 0) write (6,1002) nout
        percout=float(100*nout)/float(numslv)
        if (percout .gt. 2.0)
     -    print *,'The PBC cell may have been incorrectly specified'
      end if
      if (nfail .gt. 0 .or. percout .gt. 2.0) then
        call askstop(1)
      else
        print *,'First frame topology and solvent PBC checks passed'
      end if
      return
1000  format(' Atoms',i6,' and ',i6,' are bonded in the input ',
     -  'structure but ',/,6x,'they are ',f6.2,' A apart in the ',
     -  'first frame of the trajectory')
1001  format(' There were ',i6,' discrepancies',/,
     -  ' The largest discrepancy=',f8.2,' A',/,
     -  ' Large discrepancies usually arise when the structure file',/,
     -  ' does not correspond to the trajectory.')
1002  format(i6,' solvents appear to be outside the periodic cell')
      end
      subroutine makeoniom(inpcrdtyp,inpfile,outfiletmp,namleni,
     -  namlentmp,n,nslt,naslv,islvw,c,index,iatnum,ifchrg,indexn,
     -  indexo,indexs,mmtype,isegno,ixres,ih,ibnd,ifgtyp,nneig,nneiga,
     -  nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,molresflag,
     -  hblimfac,angmin,ipotcol1,ipotcol2,iqcol1,iqcol2,irescol1,
     -  irescol2,nrescol,inamcol1,inamcol2,nnamcol,maxrepconf,innlist,
     -  nconfig,line,radtodeg,igl,maxng,maxrsd,maxrec)
      character*200 inpfile,outfiletmp
      character* 132 line(maxrec),ansline
      dimension c(3,n),index(n),iatnum(n),ifchrg(n),indexn(n),indexo(n),
     -  indexs(n),mmtype(n),isegno(n),ixres(n),ih(n),ibnd(maxng,maxrec),
     -  ifgtyp(maxrec),nneig(n),ineig(maxng,n),nhbneig(n),nneiga(n),
     -  nhneig(n),nnneig(n),ncneig(n),nsneig(n),npneig(n),
     -  molresflag(maxrsd)
      character*1 aanames1
      character*2 mmodtoamb
      character*3 aanames3
      common /atnamcon/ mmodtoamb(100),aanames1(58),aanames3(58),
     -  naanames,nnanames,nnammnames,nnames,ixwatnam
      character*2 iatnm2
      common /atnam/ aw(99),nval(99),nvalmax(99),mmofan(99),
     -  mmatno(64),iatnm2(99)
      character*5 crdext
      common /iotypes/ iocha,iochaex,iobpdb,iocpdb,ioa3pdb,ioa4pdb,
     -  iommod,iommc,iommc4,iogro,iomol2,iomae,ioins,ionxyz,
     -  iosxyz,iosxyzrq,iograsp,iofull,lext(17),crdext(17)
      dimension ihml(3),qhmlsum(3),nonredlist(6)
      character*1 HMtyp,gcent,hml(3),s1
      character*2 ambtyp
      character*4 potnam
      character*8 resnam,atomnam
      character*80 prtline
      data hml /'H','M','L'/
c     Generate output filenames
      call changeext(inpfile,outfiletmp,namleni,namlentmp,'onm',3,0,0)
      nosolv=1
      if (n .gt. nslt)
     -  call askyn('Do you want to include the solvents too',39,0,-1,
     -    nosolv,0)
      nats=nslt
      if (nosolv .eq. 0) nats=n
      print *,'ONIOM input file: ',outfiletmp(1:namlentmp)
      call openfile(21,0,' ',1,'new',outfiletmp,namlentmp,notfnd,
     -  0,1,1,0,0)
      call quiz(HMtyp,iHMtyp,' ','ONIOM',5,'region definition mode',22,
     -  0,5,6,igl,0)
      if (HMtyp .eq. 'l') then
        print *,'Specify list of H atoms'
        call getlist(indexn,nhigh,1,nslt,1,nslt)
        print *,'Specify list of M atoms'
        call getlist(indexo,nmid,1,nslt,1,nslt)
      else if (HMtyp .eq. 's') then
        call getint('Atom number at the center of the quantum part',45,
     -    1,1,nslt,iqcent,56)
        call getreal('Radius of the H region',22,5.0,rh,1,56)
        call getreal('Radius of the M region',22,10.0,rm,1,56)
      end if
      do i=1,3
        ansline(1:37)='Do you want to keep the '//hml(i)//' layer fixed'
        call askyn(ansline(1:37),37,1,-1,ihml(i),0)
      end do
      if (ipotcol1*iqcol1 .gt. 0) then
        mmcformat=1
      else
        mmcformat=2
      end if
      potnam='    '
      resnam='        '
      nunknown=0
      nunknownr=0
      qsum=0.0
      qslt=0.0
      natprt=0
      iconvfile=0
      ideoxymmc=-1
      if (inpcrdtyp .gt. ioins) then
        print *,'ERROR: input format does not have atom names'
        stop
      end if
      if (iqcent .gt. 0) then
        nhigh=0
        nmid=0
        nlow=0
        do ia=1,nats
          if (dist2(c(1,iqcent),c(1,ia)) .le. rh**2) then
            ih(ia)=1
            nhigh=nhigh+1
            indexn(nhigh)=ia
          else if (dist2(c(1,iqcent),c(1,ia)) .le. rm**2) then
            ih(ia)=3
            nmid=nmid+1
          else
            ih(ia)=5
            nlow=nlow+1
          end if
        end do
        call zeroiti(mmtype,0,nats)
        call askyn('Do you want to prevent non C-C bond break',41,1,-1,
     -    icconly,0)
        if (icconly .eq. 1) then
          call nnlist(nslt,nslt,naslv,n,iatnum,ifchrg,c,nneig,nneiga,
     -      nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,line,
     -      irescol1,irescol2,inamcol1,inamcol2,index,nconfig,innlist,
     -      molresflag,hblimfac,angmin,0,ibnd,ifgtyp,isegno,ixres,
     -      maxrepconf,0,radtodeg,maxng,maxng,maxrsd,maxrec)
          nhighprev=nhigh
          nhighprev0=nhigh
          iscan=1
          do while (iscan .eq. 1)
            do iaa=1,nhighprev
              ia=indexn(iaa)
              do jaa=1,nneig(ia)
                ja=ineig(jaa,ia)
                if (ih(ja) .ne. 1 .and.
     -              (iatnum(ia) .ne. 6 .or. iatnum(ja) .ne. 6)) then
c                 Add ja to the inner list
                  if (ih(ja) .eq. 3) nmid=nmid-1
                  if (ih(ja) .eq. 5) nlow=nlow-1
                  nhigh=nhigh+1
                  indexn(nhigh)=ja
                  ih(ja)=1
                end if
              end do
            end do
            if (nhigh .eq. nhighprev) iscan=0
            nhighprev=nhigh
          end do
          print *,'Added ',nhigh-nhighprev0,' atoms to H list to avoid',
     -      ' breaking non C-C bonds'
          do iaa=1,nhigh
            ia=indexn(iaa)
            do jaa=1,nneig(ia)
              ja=ineig(jaa,ia)
              if (ih(ja) .ne. 1) mmtype(ia)=ja
            end do
          end do
        end if
        nm=0
        do ia=1,nats
          if (ih(ia) .eq. 3) then
            nm=nm+1
            indexo(nm)=ia
          end if
        end do
        if (nm .ne. nmid) print *,'PROGRAM ERROR nm NE nmid:',nm,nmid
        if (icconly .eq. 1) then
          nmidprev=nmid
          nmidprev0=nmid
          iscan=1
          do while (iscan .eq. 1)
            do iaa=1,nmidprev
              ia=indexo(iaa)
              do jaa=1,nneig(ia)
                ja=ineig(jaa,ia)
                if (ih(ja) .gt. 3 .and.
     -              (iatnum(ia) .ne. 6 .or. iatnum(ja) .ne. 6)) then
c                 Add ja to the inner list
                  nlow=nlow-1
                  nmid=nmid+1
                  indexo(nmid)=ja
                  ih(ja)=3
                end if
              end do
            end do
            if (nmid .eq. nmidprev) iscan=0
            nmidprev=nmid
          end do
          print *,'Added ',nmid-nmidprev0,' atoms to M list to avoid',
     -      ' breaking non C-C bonds'
          do iaa=1,nmid
            ia=indexo(iaa)
            do jaa=1,nneig(ia)
              ja=ineig(jaa,ia)
              if (ih(ja) .eq. 5) mmtype(ia)=ja
            end do
          end do
        end if
      else
        do ia=1,nats
          ih(ia)=5
        end do
        do ia=1,nhigh
          ih(indexn(ia))=1
        end do
        do ia=1,nmid
          ih(indexo(ia))=3
        end do
      end if
      call trnsfi(indexs,indexn,nhigh)
      call trnsfi(indexs(nhigh+1),indexo(nhigh+1),nmid)
      ia=nhigh+nmid
c     indexn,indexo,indexs contain the list of H, and M, atoms, resp.
      if (iord .eq. 1) then
        do iaa=1,nats
          if (ih(iaa) .eq. 5) then
            ia=ia+1
            indexs(ia)=iaa
          end if
        end do
        if (ia .ne. nats) print *,'PROGRAM ERROR: ia NE nats:',ia,nats
c       indexs contains the atomindices sorted by H, M, L
      else
        call indexit(indexs,1,nats,0)
      end if
      potnam='    '
      resnam='        '
      nunknown=0
      nunknownr=0
      qsum=0.0
      qslt=0.0
      natprt=0
      nfix=0
      iconvfile=0
      ideoxymmc=-1
      call askyn('Do you want to reorder by ONIOM type',36,1,-1,iord,0)
      if (nconfig .eq. 1)
     -  call getconvdat(2,5,5,nconvdat,iconvtyp,n,line,index,
     -    inamcol1,inamcol2,nnamcol,irescol1,irescol2,igrpinfo,maxrec)
      call zeroit(qhmlsum,3)
      do iaa=1,nats
        ia=indexs(iaa)
        atomnam(1:nnamcol)=line(index(ia))(inamcol1:inamcol2)
        if (iqcol1 .gt. 0)
     -    call readreal(line(index(ia)),iqcol1,iqcol2,qslt)
        resnam(1:nrescol)=line(index(ia))(irescol1:irescol2)
        if (nrescol .gt. 3) call blankout(resnam,4,nrescol)
        if (nrescol .gt. 4) call leftadjustn(resnam,resnam,nrescol)
        if (mmcformat .eq. 1) then
          if (inpcrdtyp .eq. ioins) then
            ambtyp=line(index(ia))(ipotcol1:ipotcol2)
          else if (inpcrdtyp .eq. iommod) then
            call readint(line(index(ia)),ipotcol1,ipotcol2,mmodtyp,4)
            ambtyp=mmodtoamb(mmodtyp)
          end if
          potnam(1:2)=ambtyp
        else if (mmcformat .eq. 2) then
          call PDBtommc(resnam,atomnam,potnam,qslt,ia,gcent,igr,
     -      ideoxymmc,iconvfile,nunknown,nunknownr)
        end if
c_C-CT-q   3f13.7,2x,a1
c          ^ col 21
        layer=(ih(ia)+1)/2
        s1=hml(layer)
        qhmlsum(layer)=qhmlsum(layer)+qslt
        ncol=62
        write (prtline,1266) (c(k,ia),k=1,3),s1
        if (mmtype(ia) .ne. 0) then
          prtline(63:64)=' H'
          write (prtline(65:70),1011) indexs(mmtype(ia))
          ncol=ncol+8
        end if
        ian=max0(1,ianum(atomnam,0,nnamcol))
        prtline(2:3)=iatnm2(ian)
        ic=4
        if (prtline(3:3) .eq. ' ') ic=ic-1
        prtline(ic:ic)='-'
        prtline(ic+1:ic+4)=potnam
        icn=ic+4
        do while (ic .le. icn .and. prtline(ic:ic) .ne. ' ')
          ic=ic+1
        end do
        prtline(ic:ic)='-'
        if (qslt .lt. 0.0) then
          write (prtline(ic+1:ic+7),1267) qslt
          ic=ic+7
        else
          write (prtline(ic+1:ic+6),1268) qslt
          ic=ic+6
        end if
        qsum=qsum+qslt
        layer=(ih(ia)+1)/2
        if (ihml(layer) .eq. 1) then
          nfix=nfix+1
          prtline(ic+2:ic+3)='-1'
        end if
        natprt=natprt+1
        write (21,1010) prtline(1:ncol)
      end do
      call askyn('Do you want to generate topology input too',42,
     -  1,-1,itop,0)
      if (itop .eq. 1) then
        call nnlist(nslt,islvw,naslv,n,iatnum,ifchrg,c,nneig,nneiga,
     -    nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,line,
     -    irescol1,irescol2,inamcol1,inamcol2,index,nconfig,innlist,
     -    molresflag,hblimfac,angmin,0,ibnd,ifgtyp,isegno,ixres,
     -    maxrepconf,0,radtodeg,maxng,maxng,maxrsd,maxrec)
        call bondord(iatnum,mmtype,n,nneig,ineig,nhneig,ibnd,maxng,c,
     -    index,ncneig,nsneig,inamcol1,inamcol2,irescol1,irescol2,line,
     -    nconfig,maxrepconf,maxrec)
        if (nosolv .eq. 0) then
          call askyn('Do you want to add H-H bonds to the solvent',43,
     -      1,-1,ihh,0)
          if (ihh .eq. 1) then
            nw=(n-nslt)/naslv
            do iw=1,nw
              incr=nslt+(iw-1)*naslv
              do ia1=incr+1,incr+naslv-1
                atomnam(1:nnamcol)=line(index(ia1))(inamcol1:inamcol2)
                ian1=max0(1,ianum(atomnam,0,nnamcol))
                do ia2=ia1+1,incr+naslv
                  atomnam(1:nnamcol)=line(index(ia2))(inamcol1:inamcol2)
                  ian2=max0(1,ianum(atomnam,0,nnamcol))
                  if (ian1 .eq. 1 .and. ian2 .eq. 1) then
                    nneig(ia1)=nneig(ia1)+1
                    nneig(ia2)=nneig(ia2)+1
                    ineig(nneig(ia1),ia1)=ia2
                    ineig(nneig(ia2),ia2)=ia1
                    ibnd(nneig(ia1),ia1)=1
                    ibnd(nneig(ia2),ia2)=1
                  end if
                end do
              end do
            end do
          end if
        end if
        write (21,1010)
        do iaa=1,n
          ia=indexs(iaa)
          nn=nneig(ia)
          if (nn .gt. 6) then
            write (6,1270) ia,nn,(ineig(indexs(ja),ia),ja=1,nn)
            nn=6
          else
            nng=0
            do in=1,nn
              if (ineig(indexs(in),ia) .gt. ia) then
                nng=nng+1
                nonredlist(nng)=indexs(in)
              end if
            end do
            write (21,1260) ia,
     -      (ineig(nonredlist(ja),ia),ibnd(nonredlist(ja),ia),ja=1,nng)
          end if
        end do
      end if
      close(21)
      write (6,1269) outfiletmp(1:namlentmp),
     -  nhigh,nmid,nlow,qhmlsum,qsum,nunknown,natprt,nfix
      call trnsfi(isegno,ih,n)
      return
1010  format(a)
1011  format(i6)
1260  format(i5,6(i6,i3,'.0'))
1266  format(20x,3f13.7,2x,a1)
1267  format(f7.4)
1268  format(f6.4)
1269  format(' Oniom input file is written to file ',/,7x,a,/
     -  ' Number of atoms in the high, middle and low regions:',3i7,/,
     -  ' Charge sums: H=',f8.4,' M=',f8.4,' L=',f8.4,' Total=',f8.4,
     -  /,' Number of unassigned atoms=',i5,/,
     -  ' Total number of atoms printed=',i6,/,
     -  ' Number of atoms kept fixed=',i6)
1270  format(' ERROR: Atom ',i5,' has more than 6 neigbours - ',
     -  '(format has to be changed):',/,(10i8))
      end
      subroutine makeamsol(n,c,iatnum,nneig,ineig,iqcol1,iqcol2,line,
     -  index,indexn,inpcrdtyp,nconfig,iout,maxng,maxrec)
      dimension c(3,n),iatnum(n),nneig(n),ineig(maxng,n),
     -  index(n),indexn(n)
      character* 132 line(maxrec)
      character*2 iatnm2
      common /atnam/ aw(99),nval(99),nvalmax(99),mmofan(99),
     -  mmatno(64),iatnm2(99)
      character*5 crdext
      common /iotypes/ iocha,iochaex,iobpdb,iocpdb,ioa3pdb,ioa4pdb,
     -  iommod,iommc,iommc4,iogro,iomol2,iomae,ioins,ionxyz,
     -  iosxyz,iosxyzrq,iograsp,iofull,lext(17),crdext(17)
      print *,'Generating Amsol 3.5 input config no=',nconfig
c     Obtain charges (if available)
      iqsum=0
      if (iqcol1 .gt. 0) then
        qsum=0.0
        do ia=1,n
          call readreal(line(index(ia)),iqcol1,iqcol2,qslt)
          qsum=qsum+qslt
        end do
        if (qsum .gt.  0.0) iqsum=qsum+0.1
        if (qsum .lt.  0.0) iqsum=qsum-0.1
        print *,'Total charge on the molecule is assumed to be ',iqsum,
     -  ' CHECK!'
      else
        call getint('The charge on the molecule',26,999999,1,0,iqsum,0)
      end if
c     Obtain SM1A atomtypes
      do i=1,n
        indexn(i)=99
      end do
      do i=1,n
        if (nneig(i) .gt. 0) then
          if (iatnum(i) .eq. 1) then
            if (iatnum(ineig(1,i)) .eq. 6) indexn(i)=1
            if (iatnum(ineig(1,i)) .eq. 7) indexn(i)=2
            if (iatnum(ineig(1,i)) .eq. 8) indexn(i)=3
            if (iatnum(ineig(1,i)) .eq. 16) indexn(i)=4
            if (iatnum(ineig(1,i)) .eq. 15) indexn(i)=14
          else if (iatnum(i) .eq. 6) then
            indexn(i)=1
          else if (iatnum(i) .eq. 7) then
            if (nneig(i) .ge. 3) indexn(i)=5
            if (nneig(i) .le. 2) indexn(i)=6
          else if (iatnum(i) .eq. 8) then
            if (nneig(i) .eq. 1) indexn(i)=8
            if (nneig(i) .eq. 2) indexn(i)=7
          else if (iatnum(i) .eq. 9) then
            indexn(i)=9
          else if (iatnum(i) .eq. 16) then
            indexn(i)=10
          else if (iatnum(i) .eq. 17) then
            indexn(i)=11
          else if (iatnum(i) .eq. 35) then
            indexn(i)=12
          else if (iatnum(i) .eq. 53) then
            indexn(i)=13
          else if (iatnum(i) .eq. 15) then
            indexn(i)=14
          end if
        end if
      end do
      nunknown=0
      do i=1,n
        if (indexn(i) .eq. 99) nunknown=nunknown+1
      end do
      if (nunknown .gt. 0)
     -  print *,'WARNING: ',nunknown,' atoms have no SM1A type'
      write (iout,2049) iqsum
c     Write header
      do i=1,2
        if (ischarmm(inpcrdtyp) .eq. 1 .and. line(i)(1:1) .eq. '*')
     -    call writeline(iout,line(i),2,81,0)
        if ((ispdb(inpcrdtyp) .gt. 0) .and.
     -    (line(i)(1:6) .eq. 'REMARK' .or. line(i)(1:6) .eq. 'HEADER'))
     -       call writeline(iout,line(i),8,87,0)
        if (inpcrdtyp .eq. iommod .and. i .eq. 1) then
           call writeline(iout,line(i),7,86,0)
           call writeline(iout,line(i),87,132,0)
        end if
        if (inpcrdtyp .ge. ioins)
     -    write (iout,*)'Input generated by Simulaid'
      end do
c     Write coordinates
      write (iout,2050) (iatnm2(iatnum(i)),(c(k,i),k=1,3),i=1,n)
      write (iout,*)
      write (iout,1005) (indexn(i),i=1,n)
      close (iout)
      return
1005  format(i3)
2049  format('AM1 SM1A T=20000 1SCF XYZ CHARGE=',i2)
2050  format((a5,3(f10.5,' 0')))
      end
      subroutine analyze(nconfig,inpcrdtyp,inpcrdtyporg,ianaltyp,
     -  extnam1,analfile,inpfile,namleni,line,index,n,nslt,nmolslt,
     -  numres,numresslt,c,atw,rprox,cv,charge,iatnum,ifchrg,ncl,nneig,
     -  nneiga,nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,mmtype,
     -  molsltlim,isegno,ih,ifgtyp,molresflag,cres,chn,c2,temp,
     -  ibnd,indexn,indexo,indexs,indexa,indexdel,ifree,icntrl,indexov,
     -  indexrmsd,itemp1,itemp2,itemp3,itemp4,irrix,naslv,islvw,innlist,
     -  hblimfac,angmin,iresno,ixres,ixresno,ixsegno,ifres,ilres,irepav,
     -  irepmx,irepeng,irepkm,irescol1,irescol2,iresncol1,iresncol2,
     -  inamcol1,inamcol2,iqcol1,iqcol2,idcol,segid4,resnamslv,atnames,
     -  resnames,irescount1,irescount2,irescount3,listrefres,listnegres,
     -  segnames,ianc_anc,dssplab,idistdssp,marker,iwhead,nsegslt,isc,
     -  reportqmin,
C@GL     -  icg,wintitl,lwint,
     -  ntitlin,ntitlinw,title,version,iresnrestart,iresidrestart,
     -  blankline,label2d,inptrajtyp,mmctrajtyp,itraj,ireorient,centgra,
     -  iconfsel,numsel,nclstmem,iresshift,lastanal,ifixq,nhbdist,iwt,
     -  rlim,iqspaceask,icharges,iallheavy,keeprem,pi,radtodeg,asterisk,
     -  maxconfsel,maxrepconf,maxng,maxbox,mxbonds,maxrsd,maxrec,
     -  maxrec10,maxrcorr,mx2d)
      dimension nneig(maxrec),ineig(maxng,maxrec),iatnum(maxrec),
     -  c(3,maxrec10),atw(maxrec),cv(maxrec),charge(maxrec),
     -  nhbneig(maxrec),nneiga(maxrec),nhneig(maxrec),nnneig(maxrec),
     -  ncneig(maxrec),nsneig(maxrec),npneig(maxrec),index(maxrec),
     -  ifgtyp(maxrec),molresflag(maxrsd),isegno(maxrec),ifchrg(maxrec),
     -  mmtype(maxrec),iresno(maxrec),ixres(maxrec),ixresno(maxrsd),
     -  ixsegno(maxrsd),ifres(maxrsd),ilres(maxrsd),irepav(mx2d),
     -  irepmx(mx2d),irepeng(mx2d),irepkm(mx2d),irescount1(maxrsd),
     -  irescount2(maxrsd),irescount3(maxrsd),listrefres(maxrsd),
     -  listnegres(maxrsd),ih(maxrec),cres(3,maxrec10),chn(3,maxrec),
     -  c2(3,maxrec),temp(maxrec),ibnd(maxbox,maxrec),ifree(maxrec),
     -  indexov(maxrec),indexrmsd(maxrec),itemp1(maxrec),itemp2(maxrec),
     -  itemp3(maxrec),itemp4(maxrec),irrix(maxrec),indexn(maxrec),
     -  indexo(maxrec),indexs(maxrec),indexa(maxrec),indexdel(maxrec),
     -  iconfsel(maxconfsel),nclstmem(mx2d),idistdssp(9,maxrsd),
     -  icntrl(20),centgra(3),molsltlim(3,maxrsd),ianc_anc(mxbonds),
     -  nhbdist(mxbonds),iwt(mx2d),rlim(maxng),rprox(maxrec),isc(maxrec)
C@GL      character*80 wintitl
      character*1 asterisk,dssplab(maxrsd)
      character*4 segid4(nsegslt),segnames(maxrsd),extnam1,extnam2,
     -  extnam3,extinp
      character*8 resnam,rn,resnamslv,atnames(maxrec),resnames(maxrsd)
      character*6 marker(16),extinp6
      character*8 version
      character*24 askcolcode
      character*80 label2d(mx2d),trackfile
      character*200 inpfile,analfile,analfile1,analfile2,analfile3,
     -  analfile4,inpstatfile
      character* 132 line(maxrec),blankline
      character*2 iatnm2
      common /atnam/ aw(99),nval(99),nvalmax(99),mmofan(99),
     -  mmatno(64),iatnm2(99)
      character*11 trajformatname
      common /trajectory/ nmmccheck,iftrajtyp(6),trajformatname(6)
      character*200 trajnam,trajnam1,trajnam2,trajnamr1,trajnamr2
      common /trajname/ trajnam,trajnam2,ltrajnam,ltrajnam2
      character*80 title,trtitle(32)
      character*4 namfcg
      character*4 tanames
      character*8 tnames
      common /tordat/ ntorn,tanames(4,28),tnames(28)
      common /connatdat/ ramax(99),ramax2(99),hlimfac,ianfg(99),
     -  namfcg(100),nrmw
      real*8 xtlabc,xtlabc0
      common /boxdat/ xtlabc(6),xtlabc0(6),box(3),box0(3),edge_gen(3,3),
     -  cell0(3,27),cell(3,27),cellalt(3,27),
     -  ncell,ioppbc,noboxinfoar,noboxinfow,noboxrep,
     -  istuner,iboxtypfound,ixcrd(3),ixang(3),ixyzhex(3),
     -  ixyzhextraj(3),isizewarn
      common /colorinfo/ ncolcode,maxcolcode
      common /graphics/ igl,npixx,npixy,maxpixx,maxpixy,idwmain,idwplot,
     -  wx,wy,wz,wxdr
      common /rotmat/ matrot0(4,4),matrot(4,4),nomat0
      character*1 xyz
      common /axislab/ xyz(3)
      common /columnlim/ incol(17),iidcol(17),iialtcol(17),
     -  iinamcol(2,17),iirescol(2,17),iiccol(2,17),iiresncol(2,17),
     -  iiseqncol(2,17),iisegcol(2,17),iiresidcol(2,17),iiqcol(2,17),
     -  iipotcol(2,17),iiocccol(2,17),iichemcol(2,17)
      character*5 crdext
      common /iotypes/ iocha,iochaex,iobpdb,iocpdb,ioa3pdb,ioa4pdb,
     -  iommod,iommc,iommc4,iogro,iomol2,iomae,ioins,ionxyz,
     -  iosxyz,iosxyzrq,iograsp,iofull,lext(17),crdext(17)
      dimension edge(3),evals0(3),evecs0(3,3)
      character*4 pflsv(100)
      character*8 namesv(100)
      character*9 decidebend
      character*27 qq
      parameter (MAXBRIDGEATOM=8000,MAXBRIDGETYPE=500,MAXBRIDGELEN=4)
c     Maximum number of bridge anchor atoms: MAXBRDIGEATOM
c     Maximum number of bridge destination atoms: MAXBRDIGETYPE
c     Maximum number of H bonds in a bridge:  MAXBRIDGELEN
      common /bridges/ ianchor(MAXBRIDGEATOM),
     -  nbridgetype(MAXBRIDGELEN,MAXBRIDGEATOM),
     -  ibridgetype(MAXBRIDGETYPE,MAXBRIDGELEN,MAXBRIDGEATOM),
     -  lpath(MAXBRIDGETYPE,MAXBRIDGELEN,MAXBRIDGEATOM)
      parameter (MAXDDISTR=200,MAXCDLIST=2000,MAXDDBIN=20)
c     Maximum number of atom pairs to calculate the distance distribution
      dimension listpairdist(2,MAXDDISTR),npairdist(MAXDDBIN,MAXDDISTR),
     -  pairdistsum(MAXDDISTR),pairdistsum2(MAXDDISTR),
     -  pairdistwsum(2,MAXDDISTR),pairdistminmax(2,MAXDDISTR),
     -  iclustermem(MAXCDLIST),ifstclst1(MAXDDISTR),
     -  ifstclst2(MAXDDISTR),ilstclst2(MAXDDISTR)
      character*1 typc
      character*21 ssname
      common /dsspnames/ lssname(9),ssname(9),typc(9)
c     Pseudorotation calculation
      parameter (MAXRING=50)
      real*8 sinpsrs,cospsrs,qpsrs,qpsr2s,zavs,zsqs
      dimension sinpsrs(MAXRING),cospsrs(MAXRING),qpsr(MAXRING),
     -  qpsrs(MAXRING),qpsr2s(MAXRING)
      dimension psr(MAXRING),ix5(MAXRING),zring(MAXRING),rring(MAXRING)
      dimension iasv(100),qsv(100),ixlist(99),idelseg(1000),ialist(15),
     -  icatlist(15),psr5(5),itypsse(200),ifsse(200),ilsse(200)
c     All arrays in prokink are of length MAXHX
      parameter (MAXHX=50)
      common /prokink/ icab(MAXHX),icaa(MAXHX),icb(MAXHX),ica(MAXHX),
     -  inb(MAXHX),ina(MAXHX),icapr,icpr,inpr,nra,nrb,icbpr,icgpr,icdpr,
     -  iprintpk
      common /analparm/ nsltref_f,nsltref_l,rcut_cv,icvtyp
c     All arrays are of length maxframe=MAXFRAMES > MAX2D !!
      parameter (MAXFRAMES=50000,MAXCOPY=600)
      parameter (MAXCOPY1=MAXCOPY-1)
      common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
     -  increment,increment2,res(2,MAXFRAMES,MAXCOPY1),
     -  xyplot(2,MAXFRAMES),x0(MAXCOPY),y0(MAXCOPY),nxselres,
     -  ixselres(MAXCOPY)
      common /logging/ logfile,ipredict
      character*1 separatorchar
      common /filenuminfo/ iaskunderscore,separatorchar
c     Array of lenght maxconfsel (set to MAXFRAMES)
      dimension iconfsel2(MAXFRAMES),rplot(MAXFRAMES)
c     Helix axis analysis arrays
      parameter (MAXNHX=16)
c     Arrays of length involving MAXNHX
      dimension anglechange(MAXHX,MAXNHX),anglechangeref(MAXHX,MAXNHX),
     -  angles(3,MAXNHX),anglesn(3,MAXNHX),helixlen(MAXNHX),
     -  helixlen0(MAXNHX),rcirc(MAXNHX),turnperres(MAXNHX),
     -  ireshx1(MAXNHX),ireshx2(MAXNHX),iseghx(MAXNHX),nreshx(MAXNHX),
     -  icaahx(MAXHX,MAXNHX),indexaxhx(3,MAXNHX)
      real*8 calph0(3,MAXHX,MAXNHX),perpvec0(3,MAXHX,MAXNHX),
     -  camod(3,MAXHX,MAXNHX),axfact(MAXHX,MAXNHX),
     -  calph(3,MAXHX,MAXNHX),perpvec(3,MAXHX,MAXNHX),
     -  axisdir(3,MAXNHX),axisini(3,MAXNHX),axisend(3,MAXNHX),
     -  helixcent(3,MAXNHX),circ(3,MAXNHX),axisdir0(3,MAXNHX), 
     -  axisini0(3,MAXNHX),axisend0(3,MAXNHX),helixcent0(3,MAXNHX),
     -  rn0(3,MAXNHX),rnorm(3,MAXNHX),rms,ddd,sinphisum,cosphisum,
     -  sinpsisum,cospsisum,atwsum
      character*1 axdirchar(MAXNHX)
C@GL      real*8 xx
      dimension crmslt0(3),crmslt(3),rot(3,3),trajrot(3,3),nhelixok(3),
     -  dr(3),caref(3),caprev1(3),caprev2(3),
     -  drincr(3),drimg(3),com1(3),com2(3),indexax(3),atws(1000),
     -  dip1(3),sdxyx1(3),lbondname(4)
      parameter (MAXDISTR=1000,MAXDISTRN=10)
      dimension nframes_err(MAXDISTRN),err(MAXDISTR),rmsfav(MAXDISTR),
     -  dtemp1(MAXDISTRN),dtemp2(MAXDISTRN)
      real*8 distrerr(MAXDISTRN,MAXDISTR),rmsfsum(MAXDISTR),
     -  xcum(MAXDISTRN)
      character*1 analtyp,analinp,psrtyp,ansrun,marks(9),unit,ans
      character*4 ext1(40),ext2(40),ext3(40),atnam,bbats(6)
      character*8 brslv
      character*6 hxoklab(3)
      character*7 mark0,mark1,mark2
      character*11 xtrajlabs(4),xtrajlab
      character*12 run_res(5)
      character*18 bondname(4)
      character*20 helixcklab
      character*30 shiftlab
      character*80 question
      character*80 linein,pstitle,system
      character*34 anglab,distlab
      character*36 restitle
      character*22 atomdist
      character*25 prokinklab(5),helixang(6),helixrlab(14),rmsdlab(4),
     -  ramalab(MAXCOPY1),printrlab(10),volumelab(4)
      character*29 resrange
      character*30 talab(MAXCOPY1)
      character*80 plotdescr
      character*100 hostname
      dimension lprokinklab(5),lhelixang(6),lhelixrlab(14),lrmsdlab(4),
     -  lramalab(MAXCOPY1),lprintrlab(10),lvolumelab(4),icntrlsave(20),
     -  ltalab(MAXCOPY1),ixtor1234(4,MAXCOPY1)
      parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
      dimension it1(MAXBONDS),it2(MAXBONDS),it3(MAXBONDS),it4(MAXBONDS),
     -  it5(MAXBONDS),ixclst(MAXBONDS),index2d(MAXBONDS),
     -  ifhb2d(MAXBONDS),ilhb2d(MAXBONDS),ifa_s(MAXBONDS),
     -  ila_s(MAXBONDS),rmsdlim(MAXBONDS),value(MAXBONDS),engcl(MAX2D),
     -  ifclst1(MAX2D),ilclst1(MAX2D),index2d1(MAX2D),nsimclst1(MAX2D),
     -  ifclst2(MAX2D),ilclst2(MAX2D),index2d2(MAX2D),nsimclst2(MAX2D),
     -  irepmx1(MAX2D),irepmx2(MAX2D),ixshuffle(MAX2D),
     -  ixshuffleref(MAX2D),xtraj(MAXFRAMES)
      data marks /'*','+','#','|','@','%','x','-','='/
      data bondname /'hydrogen bond','hydrophobic bond','salt bridge',
     -  'heavy atom contact'/
      data lbondname /13,16,11,18/
      data shiftlab /'Helix shift in the Z direction'/
      data prokinklab /'Bend angle','Wobble','Face shift',
     -  'Wobble-Face shift','Pseudorotation phase'/
      data lprokinklab /10,6,10,22,20/
      data helixang /'Global helix X tilt-angle',
     -  'Global helix Y-tilt angle','Global helix Z-tilt angle',
     -  'Helix rotation','Local helix tilt angle','Turn angle per res.'/
      data lhelixang /25,25,25,14,16,19/
      data helixrlab /'Helix length','Curvature radius',
     -  'Total displacement (cent)','X-displacement (cent)',
     -  'Y-displacement (cent)','Z-displacement (cent)',
     -  'Normal-to-bend drift (X)','Normal-to-bend drift (Y)',
     -  'X-displacement (start)','Y-displacement (start)',
     -  'Z-displacement (start)','X-displacement (end)',
     -  'Y-displacement (end)','Z-displacement (end)'/
      data lhelixrlab /12,16,25,3*21,2*24,3*22,3*20/
      data rmsdlab /'RMSD (overlaid)   ','Max dev (overlaid)',
     -              'RMSD              ','Maximum deviation '/
      data lrmsdlab /17,19,4,19/,ltalab /MAXCOPY1*30/,
     -  ramalab/MAXCOPY1*'Residue                  '/,
     -  lramalab /MAXCOPY1*25/
      data volumelab /'V(solvent-excluded shell)',
     -  'V(first solvation shell)','V(solute)','V(interface)'/
      data lvolumelab /25,24,9,12/
      data ext1 /'.nnl','.n14','.fcg','.bnd','.hbn','.hpn','.stb',
     -    '.rsd','.dst','.cnt','.psr','.pkn','.hph','.cvl','.cvr',
     -    '.dss','.hbr','.ram','.dih','.phi','.axd','.rms','.rd2',
     -    '.rdx','.cor','.add','.svl','.pca','.rgh','.sum','.adj',
     -    '.ang','.mld','.ctb',4*'    ','.sdr','    '/
      data ext2 /'    ','    ','.bbn','    ','.ps ','.ps ','.ps ',
     -    '.rsm','.ps ','    ','    ','.ps ','    ','    ','.ps ',
     -    '.ps ','    ','.ps ','.ps ','    ','.ps ','.ps ','.ps ',
     -    '.ps ','.ps ','    ','.ps ','.ps ','.ps ','    ','.ps ',
     -    '.ps ','.mlc','.ps ',4*'    ','.ps ','    '/
      data ext3 /7*'    ','.rmp',9*'    ','.rdp',3*'    ','.rmf',
     -  10*'    ','    ',7*'    '/
      data bbats /'O   ',' O  ','H   ',' H  ','HN  ',' HN '/,nbbats /6/
      data hxoklab /'intact','broken','frayed'/
      data xtrajlabs /' N(frames) ','Picoseconds','Nanoseconds',
     -  'Miliseconds'/,nframes_err /MAXDISTRN*0/
      data run_res /' ???        ','Correlated  ','Uncorrelated',
     -  'Correlated  ', '>>>         '/
C@GL#include <fgl.h>
C@GL#include <fdevice.h>
      data ifirst /1/, ilast /999999/,ifirst2 /1/, ilast2 /999999/,
     -  nframetotmin /50/,maxdevplot /0/,iunmatchplot /0/,
     -  nhneigmin /0/,numsel2 /0/,noprol /0/
c     print *,'ANALYZE start'
c     ianaltyp=1:  (S) Neighbor, bond, angle and torsion list
c     ianaltyp=2:  (S) 1-4 statistics
c     ianaltyp=3:  (S) Functional group and backbone list
c     ianaltyp=4:  (S) Bond length statistics
c     ianaltyp=5:  (S) Hydrogen-bond list
c     ianaltyp=6:  (S) Hydrophobic bond list
c     ianaltyp=7:  (S) Salt bridge list
c     ianaltyp=8:  (S) Calculate residue distances
c     ianaltyp=9:  (S) Calculate a PBC-adjusted distance
c     ianaltyp=10: (S) Check for potentially unphysical contacts
c     ianaltyp=11: (S) Pseudorotation angle calculation
c     ianaltyp=12: (S) Calculate Proline kinks
c     ianaltyp=13: (S) Hydropathy labeling
c     ianaltyp=14: (S) Circular variance labeling of solute and solvent
c     ianaltyp=15: (S) Circular variance residue-residue plot
c     ianaltyp=16: (S) DSSP secondary structure assignment
c     ianaltyp=17: (S) Hydrogen-bond bridge analysis
c     ianaltyp=18: (S) Ramachandran plot
c     ianaltyp=19: (S) Torsion dial plots
c     ianaltyp=20: (S) Delphi map annotation
c     ianaltyp=21: (S) Helix axis directions
c     ianaltyp=22: (T) 1-D RMSD and residue RMS fluctuations
c     ianaltyp=23: (T) 2-D RMSD
c     ianaltyp=24: (T) Cross RMSD
c     ianaltyp=25: (T) Residue correlation matrix calculation
c     ianaltyp=26: (S) Atom-atom distance (distribution) calculation
c     ianaltyp=27: (S) Solvation shell volume calculation
c     ianaltyp=28: (S) Principal axis calculation
c     ianaltyp=29: (S) Radius and dipole calculation
c     ianaltyp=30: (S) Summarize Amber energy partition table
c     ianaltyp=31: (S) Adjacency matrix analysis
c     ianaltyp=32: (S) Angle dial plots
c     ianaltyp=33: (S) Molecule-molecule distance list
c     ianaltyp=34: (T) Heavy atom contact list
c     ianaltyp=35: (S) Calculate eigenvectors from input matrix
c     ianaltyp=36: (S) Compare residue-residue average distance matrices
c     ianaltyp=37: (S) Compare residue-residue bond matrices
c     ianaltyp=38: (S) Compare residue RMSF values
c     ianaltyp=39: (T) Atom-atom SD from trajectroy
      call testconst(0,1,2,0.0,1.0,2.0,6,nfail,1,'ANST')
      nmc=0
      maxcolcode=8
      iaskcolcode=0
      increment=1
      increment2=1
c     do ir=1,numresslt
c       write (77,*) 'ir=',ir,' iresf,l=',ifres(ir),ilres(ir)
c       do ia=ifres(ir),ilres(ir)
c         write (77,*) line(index(ia))(1:78)
c       end do
c     end do
c     stop
      call indexit(ixshuffle,1,MAX2D,0)
      call indexit(ixshuffleref,1,MAX2D,0)
      do i=1,MAXFRAMES
        xtraj(i)=i
      end do
      nanos=0
      ncolcode=maxcolcode
      write (askcolcode,2152) maxcolcode
      ireseq=-1
      nframesign=0
      nextconfsel=0
c     print *,'numsel,maxconfsel=',numsel,maxconfsel
c     print *,'maxrepconf,maxng,maxbox=',maxrepconf,maxng,maxbox
c     print *,'maxrec,maxrsd=',maxrec,maxrsd
      iseqncol1=iiseqncol(1,inpcrdtyp)
      iseqncol2=iiseqncol(2,inpcrdtyp)
      is1=iisegcol(1,inpcrdtyp)
      is2=iisegcol(2,inpcrdtyp)
      nrescol=irescol2-irescol1+1
      nnamcol=inamcol2-inamcol1+1
      nsegcol=is2-is1+1
      innlistorig=innlist
      call trnsfr(cres,c,3*n)
      ifc=1
      call nextchar(title,ifc,1000)
      call lastchar(title,ltitle,80)
      call blankout(question,1,80)
      question(1:ltitle-ifc+1)=title(ifc:ltitle)
      title=question
      ltitle=ltitle-ifc+1
      ltitle76=min0(ltitle,76)
      natsorig=n
      nsegm=isegno(nslt)
      numanal=0
      iallrama=0
      iconfirmname=0
      iuseinp=0
      limresrange=0
      nhxres=15
      nfravgd=0
      nfravgt=0
9000  idsspcheck=0
      ltrajnam2=0
      noprintconf=0
      iread2d=0
      etot2=0.0
      itypavg=0
      rmsdplotmax=0.0
      nfreqsd=0
      rmsfdplotmaxlotmax=0.0
      isdtyp=1
      ireadtracks=0
      ilastframe=0
      nbfound=0
      nbresfound=0
      nosamseg=0
      if (nconfig .eq. 1) then
        call getatnumlist(n,iatnum,ifchrg,ialist,icatlist,ixlist,nanos)
c       Get residue name list
        ires=0
        nres=0
        do ia=1,n
          if (iresno(ia) .ne. ires) then
            ires=iresno(ia)
            nres=nres+1
            resnames(nres)(1:irescol2-irescol1+1)=
     -        line(index(ia))(irescol1:irescol2)
          end if
        end do
        namleno=0
        namleno1=0
        namleno2=0
        extnam2='    '
        hbf0=hblimfac
        angm0=angmin
        listbridge=0
      end if
9002  if (nconfig .eq. 1) then
        numanal=numanal+1
9003    call quiz(analinp,ityp,' ',' ',0,'configuration analysis',22,
     -    0,5,6,igl,0)
        if (analinp .eq. 'q') return
        analtyp=analinp
        if (analinp .eq. 'g') then
          call quiz(analtyp,ityp,' ',' ',0,
     -      'topology/geometry analysis',26,0,5,6,igl,0)
          ianaltyp=ityp
          if (ityp .eq. 5) ianaltyp=34
        else if (analinp .eq. 'b') then
          call quiz(analtyp,ityp,' ',' ',0,'bond tracking',13,
     -      0,5,6,igl,0)
          if (analtyp .eq. 'h') ianaltyp=5
          if (analtyp .eq. 'p') ianaltyp=6
          if (analtyp .eq. 's') ianaltyp=7
          if (analtyp .eq. 'b') ianaltyp=17
          if (analtyp .eq. 'c') ianaltyp=34
          if (analtyp .eq. 'm') ianaltyp=37
        else if (analinp .eq. 'y') then
          call quiz(analtyp,ityp,' ',' ',0,
     -      'atomic property calculation',27,0,5,6,igl,101)
          if (analtyp .eq. 'y') ianaltyp=13
          if (analtyp .eq. 'c') ianaltyp=14
          if (analtyp .eq. 'p') ianaltyp=20
        else if (analinp .eq. 'o') then
          call quiz(analtyp,ityp,' ',' ',0,
     -      'molecular property calculation',30,0,5,6,igl,102)
          ianaltyp=26+ityp
          if (analtyp .eq. 'b') then
            if (ispdb(inpcrdtyp) .eq. 0) then
              print *,'B factors are only used for PDB input'
            else
              print *,'B-factor segment averages are printed above'
            end if
            go to 9003
          end if
        else if (analinp .eq. 'm') then
          call quiz(analtyp,ityp,' ',' ',0,'RMSD calculation',16,
     -      0,5,6,igl,0)
          ianaltyp=21+ityp
          if (analtyp .eq. 'd') ianaltyp=38
        else if (analinp .eq. 'u') then
          call quiz(analtyp,ityp,' ',' ',0,'distance analysis',17,
     -      0,5,6,igl,0)
          if (analtyp .eq. 'e') ianaltyp=8
          if (analtyp .eq. 'l') ianaltyp=33
          if (analtyp .eq. 'm') ianaltyp=31
          if (analtyp .eq. 'u') ianaltyp=9
          if (analtyp .eq. 't') ianaltyp=26
          if (analtyp .eq. 's') ianaltyp=39
          if (analtyp .eq. 'c') ianaltyp=10
          if (analtyp .eq. 'o') ianaltyp=36
        else
          if (analtyp .eq. 'a') ianaltyp=18
          if (analtyp .eq. 'i') ianaltyp=32
          if (analtyp .eq. 't') ianaltyp=19
          if (analtyp .eq. 'k') ianaltyp=12
          if (analtyp .eq. 'x') ianaltyp=21
          if (analtyp .eq. 'p') ianaltyp=11
          if (analtyp .eq. 's') ianaltyp=16
          if (analtyp .eq. 'v') ianaltyp=15
          ireadcov=0
          if (analtyp .eq. 'n') then
            call askyn('Do you have an input covariance matrix',38,1,-1,
     -        ireadcov,000)
            if (ireadcov .eq. 1) then
              ianaltyp=35
            else
              ianaltyp=25
            end if
          end if
          if (analtyp .eq. 'd') ianaltyp=30
        end if
        call blankout(resrange,1,29)
        if (analtyp .eq. 'q') go to 9003
        lastanal=ianaltyp
        if (ianaltyp .eq.  34) then
c         Update bond thresholds
          print *,'Changing bond threshold (ramax) for selected atom ',
     -      'types'
          ian=2
          do while (ian .gt. 0)
            call getint('Atomic number for threshold change',34,0,1,99,
     -        ian,0)
            if (ian .gt. 0) then
              write (linein,2115) iatnm2(ian)
              call getreal(linein,10,ramax(ian),ramaxnew,1,000)
              ramax(ian)=ramaxnew
            end if
          end do
        end if
        if (ianaltyp .eq.  3 .or. ianaltyp .eq. 15 .or.
     -      ianaltyp .eq. 30 .or. 
     -      ianaltyp .eq. 35 .or. ianaltyp .eq. 36 .or.
     -      ianaltyp .eq. 37 .or. ianaltyp .eq. 38) then
c         These options do not work on trajectories
          itraj=0
        else if (ianaltyp .eq. 22 .or. ianaltyp .eq. 23 .or.
     -           ianaltyp .eq. 24 .or. ianaltyp .eq. 25 .or.
     -           ianaltyp .eq. 19 .or. ianaltyp .eq. 32 .or.
     -           ianaltyp .eq. 39) then
c         These options only work on trajectories
          itraj=1
          if (ianaltyp .eq. 22) write (6,2013)
        else
          itrajdef=-1
          if ((ianaltyp .ge. 5 .and. ianaltyp .le. 7) .or.
     -         ianaltyp .eq. 9 .or. ianaltyp .eq. 16 .or.
     -         ianaltyp .eq. 18 .or. ianaltyp .eq. 26) itrajdef=+1
          call askyn('Do you want to analyze a trajectory',35,1,
     -      itrajdef,itraj,0)
          if (itraj .eq. 0) iaskcolcode=0
        end if
        ncl=0
        framefac=1.0
        iframeunit=1
        xtrajlab=xtrajlabs(iframeunit)
        if (itraj .eq. 1) then
          if (ianaltyp .eq. 05 .or. ianaltyp .eq. 06 .or.
     -        ianaltyp .eq. 07 .or. ianaltyp .eq. 09 .or.
     -        ianaltyp .eq. 16 .or. ianaltyp .eq. 18 .or.
     -        ianaltyp .eq. 21 .or. ianaltyp .eq. 22 .or.
     -        ianaltyp .eq. 23 .or. ianaltyp .eq. 24 .or.
     -        ianaltyp .eq. 27 .or. ianaltyp .eq. 28 .or.
     -        ianaltyp .eq. 29 .or. ianaltyp .eq. 39) then
            call quiz(unit,iframeunit,'f',' ',0,'trajectory unit',15,
     -        0,5,6,igl,0)
            if (iframeunit .gt. 1) then
              xtrajlab=xtrajlabs(iframeunit)
              linein(1:11)=xtrajlab
              linein(12:31)=' per frames analyzed'
              call getreal(linein,22,1.0,framefac,1,113)
              if (ianaltyp .eq. 24) print *,'NOTE: ',
     -         'same time interval is assumed for both trajectories'
              do i=1,MAXFRAMES
                xtraj(i)=i*framefac
              end do
            end if
          end if
        end if
        do ia=1,n
          if (inpcrdtyp .le. ioins) then
            atw(ia)=aw(iatnum(ia))
          else
            atw(ia)=1.0
          end if
          rprox(ia)=1.0
        end do
        if (ianaltyp .eq.  5 .or. ianaltyp .eq.  6  .or.
     -      ianaltyp .eq.  7 .or. ianaltyp .eq. 17 .or.
     -      ianaltyp .eq. 29) then
          if (inpcrdtyp .lt. ioa3pdb) then
            if (icharges .eq. 0) then
              ll=27
              linein(1:ll)='Do you have charges in the '
              if (ischarmm(inpcrdtyp) .eq. 1) then
                linein(ll+1:ll+13)='weight column'
                call askyn(linein,ll+13,1,-1,icharges,0)
              else
                linein(ll+1:ll+25)='temperature factor column'
                call askyn(linein,ll+25,1,-1,icharges,0)
              end if
            end if
            if (icharges .eq. 0) then
              call quiz(ans,ians,'n',' ',0,'charge input',12,0,5,6,
     -          igl,0)
              if (ans .ne. 'n') then
                nread=nslt
                if (n .gt. nslt) then
                  call askyn('Do you have charges for the solvents too',
     -              40,1,1,isv,000)
                  if (isv .eq. 1) nread=n
                end if
                call readcharges(ans,11,nread,charge,iatnum,nerr)
                if (nerr .eq. 0) icharges=2
              end if
            end if
            if (icharges .gt. 0) then
              call checkreschargesum(nslt,iresno,isegno,line,index,
     -          irescol1,irescol2,iresncol1,iresncol2,is1,is2,iqcol1,
     -          iqcol2,charge,molsltlim,'residue',7,resnames,ifres,
     -          ixres,itemp1,itemp2,nreschrg,iallzero,iallnonpos,
     -          iallnonneg,icharges,ifixq,reportqmin,maxrsd,maxrec)
              if (iallzero+iallnonpos+iallnonneg .gt. 0) icharges=0
            else
              write (6,2035)
              call askstop(1)
            end if
          end if
        end if
        if (innlist .lt. innlistorig)
     -    call nnlist(n,islvw,naslv,n,iatnum,ifchrg,c,nneig,nneiga,
     -      nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,line,
     -      irescol1,irescol2,inamcol1,inamcol2,index,nconfig,innlist,
     -      molresflag,hblimfac,angmin,0,ibnd,indexo,isegno,ixres,
     -      maxrepconf,0,radtodeg,maxbox,maxng,maxrsd,maxrec)
        itrajrot=0
        ifailbond=0
        lpstitle=0
        npspages=0
        ipspage=0
        xm=800.0
        ym=900.0
        nframe=0
        numwait=10
        nrep=0
        iw0=0
        iw1=0
        iw2=0
        iw4=0
        iw5=0
        iedit=0
        ndprow=0
        ndials=0
        noplotdist=0
        iskip2dplot=0
        ietotsaved=0
        ibondcorr=0
        iresbondcorr=0
        ibondprint=0
        call zeroiti(nhbdist,0,mxbonds)
        extnam1=ext1(ianaltyp)
        extnam2=ext2(ianaltyp)
        extnam3=ext3(ianaltyp)
        call indexit(indexs,1,MAX2D,0)
        call indexit(index2d,1,MAX2D,0)
        call indexit(ixclst,1,MAX2D,0)
        if (itraj .eq. 0) then
          if (ianaltyp .eq.  9 .or. ianaltyp .eq. 11) extnam1='    '
          if (ianaltyp .eq. 16 .or. ianaltyp .eq. 21 .or.
     -        ianaltyp .eq. 27 .or. ianaltyp .eq. 29) extnam2='    '
          if (ianaltyp .eq. 20) then
            call askyn('Do you want to write a grid potential file',42,
     -        1,-1,igridfile,0)
            if (igridfile .eq. 1) extnam2='.grd'
          end if
        end if
        if (ianaltyp .eq. 23 .or. ianaltyp .eq. 24) then
          if (nslt .gt. 200 .and. n/nslt .ge. 2) then
            write (6,2030)
            call askstop(0)
          end if
          if (ianaltyp .eq. 23) call askyn(
     -      'Do you want to read an existing .rd2 file',41,
     -       1,-1,iread2d,90)
          if (ianaltyp .eq. 24) call askyn(
     -      'Do you want to read existing .rd2 and .rdx files',48,
     -       1,-1,iread2d,91)
          if (iread2d .gt. 0) then
            iw4=44
            itraj=0
            extnam2='    '
          end if
        end if
        if (itraj .eq. 1) then
          nres=ixres(n)
          if (n .gt. nslt .or. inpcrdtyp .eq. iommc) then
c           Extend arrays with more solvents than the input has
            nadd=min0(maxrsd-nres-1,(maxrec-index(n))/naslv-1)
c           print *,'nadd=',nadd,' iasv=',iatnum(nslt+1),iatnum(nslt+2),
c    -         iatnum(nslt+3)
            print *,'Generating information for ',nadd,' additional ',
     -         'solvents for possible use'
            if (n .eq. nslt) then
              linein(1:45)=
     -          'Number of atoms in a solvent (     ) molecule'
              linein(31:35)=resnamslv
              if (resnamslv(1:3) .eq. 'HOH' .or.
     -            resnamslv(1:3) .eq. 'TIP') then
                naslv=3
                iatnum(nslt+1)=8
                iatnum(nslt+2)=1
                iatnum(nslt+3)=1
                charge(nslt+1)=-0.834
                charge(nslt+2)=0.417
                charge(nslt+3)=0.417
              else
                call getint(linein,45,999999,1,0,naslv,0)
                linein(1:32)='Atomic number of solvent atom 00'
                do ia=1,naslv
                  write (linein(1:32),2091) ia
                  call getint(linein,32,999999,1,99,iatnum(nslt+ia),0)
                  write (linein(1:32),2092) ia
                  if (icharges .gt. 0)
     -              call getreal(linein,22,0.0,charge(nslt+ia),0,0)
                end do
              end if
            end if
            do is=1,nadd
              nres=nres+1
              resnames(nres)=resnamslv
              do ia=1,naslv
                iatnum(n+(is-1)*naslv+ia)=iatnum(nslt+ia)
                charge(n+(is-1)*naslv+ia)=charge(nslt+ia)
                index(n+(is-1)*naslv+ia)=index(n)+(is-1)*naslv+ia
                line(index(n+(is-1)*naslv+ia))=line(index(nslt+ia))
                ixres(n+(is-1)*naslv+ia)=nres
              end do
            end do
          end if
          if (analtyp .eq. 'g' .or. analtyp .eq. 'b' .or.
     -        analtyp .eq. 'y' .or. analtyp .eq. 'o' .or.
     -        analtyp .eq. 'm' .or. analtyp .eq. 'x') then
            call askyn(
     -        'Do you want to rotate each frame of the trajectory',50,
     -        1,-1,itrajrot,0)
            if (itrajrot .gt. 0) call genrot(trajrot,pi,iax,angle,igl)
          end if
        end if
        mark0=' '
        lmark0=1
        mark1=' '
        lmark1=1
        mark2=' '
        lmark2=1
        analfile=inpfile
        if (extnam1 .ne. '    ') then
c         Open output file(s)
          iw0=40
          if (namleno .ne. 0) close (iw0)
          namleno=namleni
c         Remove coordinate extension
          extinp=analfile(namleno-3:namleno)
          if (extinp .eq. '.pdb' .or. extinp .eq. '.PDB' .or.
     -        extinp .eq. '.crd' .or. extinp .eq. '.CRD' .or.
     -        extinp .eq. '.dat' .or. extinp .eq. '.DAT' .or.
     -        extinp .eq. '.mae' .or. extinp .eq. '.slt') then
            namleno=namleno-4
          else if (extinp .eq. 'mol2') then
            namleno=namleno-5
          else
            extinp6=analfile(namleno-5:namleno)
            if (extinp6 .eq. '.pdbqs' .or. extinp6 .eq. '.PDBQS' .or.
     -          extinp6 .eq. '.pdbqt' .or. extinp6 .eq. '.PDBQT')
     -        namleno=namleno-6
          end if
          analfile(namleno+1:namleno+4)=extnam1
          namleno=namleno+4
c         If output is a pdb file, add .pdb extension
          if (extnam1 .eq. '.cvl' .or. extnam1 .eq. '.hph') then
            analfile(namleno+1:namleno+4)='.pdb'
            namleno=namleno+4
            mark0='REMARK '
            lmark0=7
          end if
          if (ianaltyp .eq. 14 .or. ianaltyp .eq. 15) then
c           Select circular variance type
            call quiz(ansrun,icvtyp,'o',' ',0,
     -        'circular variance type',22,0,5,6,igl,0)
              if (icvtyp .eq. 2) then
                analfile(namleno:namleno)='w'
                analfile1(namleno1-3:namleno1-3)='w'
              end if
          end if
          if (iread2d .gt. 0) then
            analfile4=analfile
            lanalfile4=namleno
            analfile(namleno-3:namleno+2)='_a.rd2'
            namleno=namleno+2
            write (6,2036) analfile(1:namleno)
          end if
          call openfile(iw0,0,'analysis',8,'new',analfile,namleno,
     -      notfnd,0,1,1,0,0)
          call datprt(iw0,version,1,mark0,lmark0,hostname,lhostname,
     -      iheadnode,0)
          if (extnam2 .ne. '    ') then
            iw1=41
            if (namleno1 .ne. 0) close (iw1)
            namleno1=namleno
            analfile1=analfile(1:namleno)
            if (extnam2 .ne. '.ps ') then
c             Replace extension
              analfile1(namleno-3:namleno)=extnam2
              namleno1=namleno
            else
c             Second file is PS - append the .ps to the name
              analfile1(namleno+1:namleno+3)='.ps'
              namleno1=namleno+3
              mark1='% '
              lmark1=2
            end if
            call openfile(iw1,0,'analysis',8,'new',analfile1,namleno1,
     -        notfnd,0,1,1,0,0)
            if (extnam2 .ne. '.grd' .and. extnam2 .ne. '.ps ')
     -        call datprt(iw1,version,1,mark1,lmark1,hostname,lhostname,
     -          iheadnode,0)
          end if
          if (extnam3 .ne. '    ') then
            if (namleno2 .ne. 0) close (iw2)
            iw2=42
            namleno2=namleno
            analfile2=analfile(1:namleno)
            analfile2(namleno-3:namleno)=extnam3
            namleno2=namleno
            if (extnam3 .eq. '.rdp') then
              analfile2(namleno2+1:namleno2+3)='.ps'
              namleno2=namleno2+3
            end if
          end if
        end if
        call datprt(6,version,1,' ',1,hostname,lhostname,iheadnode,1)
        if (ianaltyp .eq. 23 .or. ianaltyp .eq. 24 .or.
     -      ianaltyp .eq. 25) then
          if (iheadnode .eq. 1 .and. iread2d .eq. 0) write (6,2037)
        end if
        if (ianaltyp .eq.  1) then
          write (6,2024) analfile(1:namleno)
          call askyn('Do you want to print bond angles',32,1,-1,iangpr,
     -      0)
          call askyn('Do you want to print torsion angles',35,1,-1,
     -      itorpr,0)
          call findchiral(nslt,iatnum,nneig,nhneig,ineig,indexa,maxng)
        else if (ianaltyp .eq.  2) then
          write (6,2000) analfile(1:namleno)
        else if (ianaltyp .eq. 18) then
          if (inpcrdtyp .gt. ioins) then
            print *,'ERROR: this input format does not carry atom names'
            return
          end if
          if (iresno(nslt) .gt. maxframe) then
            write (6,2074) maxframe,'residues',' '
            return
          end if
          write (6,2019) 'Psi and phi angles',analfile(1:namleno)
          write (6,2019) 'Ramachandran plot (Postscript)',
     -      analfile1(1:namleno1)
          xm=500.0
          ym=620.0
          if (itraj .eq. 0) then
            call openps(iw1,xm,ym,title,ltitle76,'Ramachandran plot',
     -        17,analfile,namleni,analfile,0,1,ipspage)
            write (6,2086) 'residue',' ',' ',nres
          else
            pstitle='Ramachandran plot'
            lpstitle=17
            write (6,2086) 'frame',' max(frame)'
            nxselres=0
            maxrp=(maxpres-1)/2
            if (nres .le. maxrp) then
              call askyn('Do you want dial plots for all residues',39,
     -          1,-1,ialldial,0)
              if (ialldial .eq. 1) then
                call indexit(ixselres,1,nres,0)
                nxselres=nres
              end if
            else
              ialldial=0
              print *,'Maximum number of dial plots can be ',
     -          'tracked=',maxrp
              call getint('Number of residues to track',27,0,1,maxrp,
     -          nxselres,0)
            end if
            if (nxselres .gt. 0) then
              question(1:38)='Phi & Psi dial pair #   residue number'
              do ix=1,nxselres
                write (question(22:23),2001) ix
8003            isegix=1
                if (ialldial .eq. 0) then
                  if (nsegm .gt. 1) then
                    isegdef=999999
                    question(25:31)='segment'
                    call getint(question,38,isegdef,1,nsegm,isegix,00)
                    isegdef=isegix
                    question(25:31)='residue'
                  end if
                  call getint(question,38,999999,1,nres,iresix,00)
                  call findsegres(isegno,iresno,ixres,1,nslt,isegix,
     -              iresix,iaf,ixselres(ix),ifail)
                  if (inpcrdtyp .le. ioins)
     -              write (6,2111) isegix,iresix,
     -                resnames(ixselres(ix))(1:nrescol)
                end if
                irfound=0
                icafound=0
                do ia=1,nslt
                  if (iresno(ia) .eq. ixselres(ix)) then
                    irfound=1
                    atnam=line(index(ia))(inamcol1:inamcol1+3)
                    call leftadjust4(atnam,atnam)
                    if (atnam .eq. 'CA  ') icafound=ia
                  end if
                end do
                if (icafound*irfound .eq. 0) then
                  if (irfound .eq. 0) then
                    print *,'Residue # ',ixselres(ix),' is not found'
                  else
                    print *,'Residue # ',ixselres(ix),' has no CA atom'
                  end if
                  if (ialldial .eq. 0) go to 8003
                  ixselres(ix)=0
                else
                  call ca_to_bb(icafound,iresno,nneig,ineig,index,line,
     -              inamcol1,i1,i2,i4,i5,ires,iprotein,
     -              maxng,maxrec)
                  if (iprotein .eq. 0) then
                    write (6,2104) ixselres(ix)
                    if (ialldial .eq. 0) go to 8003
                    ixselres(ix)=0
                  end if
                end if
              end do
              if (ialldial .eq. 1) then
                ndel=0
                do ix=1,nxselres
                  if (ixselres(ix) .eq. 0) then
                    ndel=ndel+1
                  else
                    ixselres(ix-ndel)=ixselres(ix)
                  end if
                end do
              end if
              nxselres=nxselres-1
              if (nxselres .gt. 1)
     -          call getint('Number of dials to draw in a line',33,
     -            min0(4,nxselres),1,12,ndprow,55)
              ix0=8
              if (ndprow .gt. 4) ix0=4
              if (ndprow .gt. 8) ix0=2
              do ix=1,nxselres
                write (ramalab(2*ix-1)(ix0:ix0+13),2023)
     -            ixselres(ix),resnames(ixselres(ix)),'Phi'
                write (ramalab(2*ix)(ix0:ix0+13),2023) ixselres(ix),
     -            resnames(ixselres(ix)),'Psi'
                lramalab(2*ix-1)=ix0+13
                lramalab(2*ix)=ix0+13
              end do
              call openfile(iw2,0,'dial plot',9,'new',analfile2,
     -          namleno2,notfnd,0,1,1,0,0)
              call datprt(iw0,version,1,mark0,lmark0,hostname,lhostname,
     -          iheadnode,0)
              write (6,2019) 'Phi and Psi dial plots',
     -          analfile2(1:namleno2)
              call askyn(
     -         'Do you want the Ramachandran plot with all residues',51,
     -            1,-1,iallrama,0)
            else
              print *,'Only the Ramachandran plot will be prepared ',
     -          'using all residues'
              iallrama=1
            end if
            call ramachandran_init(n,ixres)
          end if
        else if (ianaltyp .eq. 19 .or. ianaltyp .eq. 32) then
          write (6,2019) 'Selected angles',analfile(1:namleno)
          xm=500.0
          ym=620.0
          if (itraj .eq. 1) then
            write (6,2019) 'Dial plots for the selected angles',
     -        analfile1(1:namleno1)
          end if
          if (ianaltyp .eq. 19) then
c           Torsion angles
            call torslistinp(ixtor1234,talab,ltalab,ntorsel,inpcrdtyp,
     -        ioins,line,index,n,nslt,iatnum,nneig,ineig,nhneig,
     -        ixres,ixresno,irescol1,irescol2,
     -        inamcol1,inamcol2,igl,maxng,maxrsd,maxrec,MAXCOPY1)
            ndials=ntorsel
          else
c           Bond angles
            call getint('Number of angles to track',25,0,1,49,
     -        nangsel,0)
            do it=1,nangsel
8004          question(1:35)='Angle   , atomindices ( 3 numbers )'
              write (question(6:8),2043) it
              call getintline(question,35,1,nslt,ixtor1234(1,it),3,0)
              if (inpcrdtyp .le. ioins)
     -          write (6,2039) 'A',(ixtor1234(k,it),
     -            line(index(ixtor1234(k,it)))(inamcol1:inamcol2),
     -            line(index(ixtor1234(k,it)))(irescol1:irescol2),
     -          k=1,3)
c             print *,' ixtor:', (ixtor1234(k,it),k=1,4)
              nerr=0
              do k=2,3
                if (isbonded(ixtor1234(k-1,it),ixtor1234(k,it),
     -              nneig,ineig,n,maxng) .eq. 0) then
                  write (6,2066) (ixtor1234(kk,it),kk=k-1,k),' NOT '
                  nerr=nerr+1
                end if
              end do
              if (isbonded(ixtor1234(1,it),ixtor1234(3,it),
     -            nneig,ineig,n,maxng) .eq. 1) then
                write (6,2066) ixtor1234(1,it),ixtor1234(3,it),' '
                nerr=nerr+1
              end if
              if (nerr .gt. 0) then
                call askyn('Do you want to use this angle',29,1,-1,iok,
     -            0)
                if (iok. eq. 0) go to 8004
              end if
              call blankout(talab(it),1,30)
              if (inpcrdtyp .gt. ioins) then
                write (talab(it),2067) 'A',it,(ixtor1234(k,it),k=1,3)
              else
                write (talab(it),2108)
     -            (line(index(ixtor1234(kk,it)))(inamcol1:inamcol1+3),
     -            kk=1,2),line(index(ifres(ixres(ixtor1234(2,it)))))
     -             (irescol1:irescol2),
     -            line(index(ixtor1234(3,it)))(inamcol1:inamcol1+3)
              end if
              ltalab(it)=25
            end do
            ndials=nangsel
          end if
          if (ndials .gt. 1) then
            call getint('Number of dials to draw in a line',33,
     -            min0(ndials,3),1,12,ndprow,55)
            call askyn(
     -      'Do you want to calculate correlations between angles',52,
     -        0,-1,itorcorr,0)
          else
            ndprow=1
            itorcorr=0
          end if
        else if (ianaltyp .eq.  3) then
          write (6,2019) 'Functional group and bond lists',
     -      analfile(1:namleno)
          write (6,2019) 'Backbone atoms',analfile1(1:namleno1)
        else if (ianaltyp .eq.  4) then
          write (6,2019) 'Bond lengths',analfile(1:namleno)
        else if (ianaltyp .eq. 17) then
c         Hydrogen-bond bridge analysis
          write (6,2002) 'ed bridge ',analfile(1:namleno)
          call getreal('H-bond length tolerance factor',30,hbf0,
     -      hblimfac,1,23)
          call getreal('A-H...B angle minimum accepted',30,angm0,
     -      angmin,1,24)
          brslv=resnamslv
          nabr=naslv
          if (islvw .eq. 1) islvw=2
          if (nslt .eq. n) then
901         call readname('Bridge residue name',19,blankline,nrescol,
     -        ' ',0,brslv,100)
            if (brslv(1:nrescol) .ne. resnamslv(1:nrescol)) then
c             Check if residue exists, find # of atoms
              ia=1
              ir=1
              do while (resnames(ir)(1:nrescol) .ne. brslv(1:nrescol)
     -           .and. ia .lt. nslt)
                ia=ia+1
                ir=ixres(ia)
              end do
              if (resnames(ir)(1:nrescol) .eq. brslv(1:nrescol)) then
                iaf=ia
                do while (resnames(ir)(1:nrescol) .eq. brslv(1:nrescol)
     -             .and. ia .lt. nslt)
                  ia=ia+1
                  ir=ixres(ia)
                end do
                nabr=ia-iaf
                if (resnames(ir)(1:nrescol) .eq. brslv(1:nrescol))
     -            nabr=nabr+1
              else
                print *,'ERROR: residue ',brslv(1:nrescol),' not found'
                go to 901
              end if
            end if
          end if
          write (6,2042) brslv(1:nrescol),brslv(1:nrescol),nabr
          write (iw0,2042) brslv(1:nrescol),brslv(1:nrescol),nabr
          call getint('Maximum number of bridge residues in a bridge',
     -      45,MAXBRIDGELEN-1,1,MAXBRIDGELEN-1,maxbridgemem,0)
          call gethbanchordef(line,index,nslt,ixres,iresno,
     -      iatnum,indexa,indexn,nanchor,ianchor,iiqcol(1,inpcrdtyp),
     -      iiqcol(2,inpcrdtyp),inpcrdtyp,iobpdb,iocpdb,bbats,nbbats,
     -      icharges,qmin,igl,iw0,irescol1,irescol2,inamcol1,inamcol2,
     -      resnames,brslv,nrescol,segid4,molsltlim,nsegslt,isegno,isc,
     -      'Bridge',6,ianchor2,iselfanc,nosamseg,iqfsel2,22,ifail,
     -      maxrsd,maxrec,MAXBRIDGEATOM)
          if (ifail .eq. 1) go to 9005
          call zeroiti(nbridgetype,0,nanchor*MAXBRIDGELEN)
          ipb=2*itraj+1
          call askyn('Do you want to print the bridges',32,1,ipb,
     -      listbridge,0)
          print *,'Bridge of length 1 is a solute-solute hydrogen bond'
          call getint('Minimum length of bridge to list',32,1,1,
     -      maxbridgemem,minbridgelenprint,000)
          if (itraj .eq. 1) then
            call getint('Minimum percent of frames present to list',32,
     -        0,1,100,minbridgepercprint,000)
          else
            minbridgepercprint=0
          end if
          write (iw0,*)
          call zeroiti(lpath,0,MAXBRIDGETYPE*MAXBRIDGELEN*
     -      MAXBRIDGEATOM)
        else if (ianaltyp .ge.  5 .and. ianaltyp .le. 7 .or.
     -           ianaltyp .eq. 34) then
          npspages=3
          if (itraj .eq. 1) then
            ibondtype=ianaltyp-4
            if (ianaltyp .eq. 34) ibondtype=4
            if (iallheavy .eq. 1 .and. ibondtype .eq. 2) then
              print *,'There are no hydrogens in the structure'
              call askstop(1)
            end if
            linein='Do you want to calculate '//
     -        bondname(ibondtype)(1:lbondname(ibondtype))//
     -        ' correlation'
            llinein=37+lbondname(ibondtype)
            call askyn(linein,llinein,1,-1,ibondcorr,0)
            if (ibondcorr .gt. 0) npspages=npspages+1
            linein='Do you want to calculate residue-aggregated '//
     -        'bond correlation'
            llinein=60
            call askyn(linein,llinein,1,-1,iresbondcorr,0)
            if (iresbondcorr .gt. 0) npspages=npspages+1
            linein='Do you want to print every '//
     -        bondname(ibondtype)(1:lbondname(ibondtype))
            llinein=27+lbondname(ibondtype)
            call askyn(linein,llinein,1,-1,ibondprint,0)
            if (ibondprint .eq. 1 .and. ibondtype .eq. 1)
     -      write (iw0,2141)
            noprintconf=1-ibondprint
            iaskcolcode=1
            call askyn(
     -        'Do you want to read previously generated bond tracks',52,
     -        1,-1,ireadtracks,0)
            if (ireadtracks .gt. 0) then
              ifail=1
              do while (ifail .gt. 0)
                call getname(trackfile,ltrackfile,'Name of track file',
     -            18,80,0)
                iout_track=92
                call openfile(iout_track,0,'previously written track',
     -            24,'old',trackfile,ltrackfile,notfnd,0,1,1,0,0)
                call readtrack(iout_track,iw0,30,nbfound,nbresfound,
     -            nres2d,ixres,trackfile,ltrackfile,trajnam,ltrajnam,
     -            ianc_anc,ifail,maxrec)
              end do
              xtrajlab=xtrajlabs(iframeunit)
              ibondtype=min0(4,ianaltyp-1)
              npspages=2
              go to 3001
            end if 
          end if 
          if (ianaltyp .eq.  5) then
c           Set up H bond analysis
            write (6,2002) ' ',analfile(1:namleno)
            call getreal('H-bond length tolerance factor',30,hbf0,
     -        hblimfac,1,23)
            call getreal('A-H...B angle minimum accepted',30,angm0,
     -        angmin,1,24)
            nres2d=ixres(n)
            if (n .gt. nslt) then
              call askyn('Do you want to include the solvents',35,1,-1,
     -          isolvent,0)
              if (isolvent .eq. 0) nres2d=ixres(nslt)
            end if
            write (6,2140)
            do i=1,nanos
              if (icatlist(i) .eq. 0) then
                if (ialist(i) .ne. 1 .and. ialist(i) .ne. 6)
     -            write (6,2142) iatnm2(ialist(i)),
     -              sqrt(ramax2(ialist(i))*hblimfac)
              else if (islvw .gt. 0) then
                write (6,2143)
     -            iatnm2(ialist(i)),sqrt(ramax2(ialist(i))*hblimfac)
              end if
            end do
            if (itraj .eq. 1) then
              call gethbanchordef(line,index,nslt,ixres,iresno,iatnum,
     -          indexa,indexn,nanchor,ianchor,iiqcol(1,inpcrdtyp),
     -          iiqcol(2,inpcrdtyp),inpcrdtyp,iobpdb,iocpdb,bbats,
     -          nbbats,icharges,qmin,igl,iw0,irescol1,irescol2,inamcol1,
     -          inamcol2,resnames,'      ',nrescol,segid4,molsltlim,
     -          nsegslt,isegno,isc,'Hydrogen bond',13,ianchor2,iselfanc,
     -          nosamseg,iqfsel2,72,ifail,maxrsd,maxrec,MAXBRIDGEATOM)
              if (ifail .eq. 1) go to 9005
              call indexit(it3,1,MAXBONDS,0)
              call indexit(it4,1,MAXBONDS,0)
              iaskcolcode=1
            end if
            innlist=0
          else if (ianaltyp .eq.  6) then
c           Set up hydrophobic contact analysis
            write (6,2107) 'Hydrophobic bond list',analfile(1:namleno)
            call getreal('Hydrophopbic bond length limit',30,5.0,
     -        rhphmax,1,76)
            call getint('Minimum number of carbon-bonded hydrogens',41,
     -        1,1,4,nhneigmin,77)
            call gethphanchordef(line,index,nslt,iresno,iatnum,indexa,
     -        indexn,indexo,nneig,ineig,nhneig,nhneigmin,nanchor,
     -        ianchor,ianchor2,iselfanc,nosamseg,iallheavy,iqcol1,
     -        iqcol2,inpcrdtyp,iobpdb,iocpdb,icharges,igl,iw0,irescol1,
     -        irescol2,inamcol1,inamcol2,segid4,molsltlim,nsegslt,
     -        isegno,ifail,maxng,maxrec,MAXBRIDGEATOM)
            if (ifail .eq. 1) go to 9005
            call extend_nnlist(nneig,ineig,npneig,nslt,maxng,maxrec)
c            do ia=1,nslt
c              atnam=line(index(ia))(inamcol1:inamcol1+3)
c              write (77,7719) ia,atnam,nneig(ia),npneig(ia),
c     -          (ineig(in,ia),in=1,npneig(ia))
c            end do
c7719        format(i5,1x,a,' nn=',i3,' nnp=',i6,' in=',(10i5))
            nres2d=ixres(nslt)
            innlist=0
          else if (ianaltyp .eq.  7) then
c           Set up salt-bridge contact analysis
            write (6,2107) 'Salt-bridge list',analfile(1:namleno)
            call getreal('Salt-bridge length limit',24,5.0,rsltbmax,1,2)
            call getsltbanchordef(line,index,nslt,iresno,iatnum,indexa,
     -        indexn,indexo,nhneig,ineig,nanchor,ianchor,ianchor2,
     -        iselfanc,nosamseg,iqcol1,iqcol2,inpcrdtyp,iobpdb,iocpdb,
     -        igl,iw0,irescol1,irescol2,inamcol1,inamcol2,segid4,
     -        molsltlim,nsegslt,isegno,ifail,maxng,maxrec,MAXBRIDGEATOM)
            if (ifail .eq. 1) go to 9005
            call extend_nnlist(nneig,ineig,npneig,nslt,maxng,maxrec)
            nres2d=ixres(nslt)
            innlist=0
          else if (ianaltyp .eq.  34) then
c           Set up heavy-atom contact analysis
            write (6,2107) 'Heavy-atom contact list',analfile(1:namleno)
            call getreal('Heavy-atom distance threshold',29,5.0,
     -        rhphmax,1,76)
            call gethphanchordef(line,index,nslt,iresno,iatnum,indexa,
     -        indexn,indexo,nneig,ineig,nhneig,nhneigmin,nanchor,
     -        ianchor,ianchor2,iselfanc,nosamseg,iallheavy,iqcol1,
     -        iqcol2,npcrdtyp,iobpdb,iocpdb,icharges,igl,iw0,irescol1,
     -        irescol2,inamcol1,inamcol2,segid4,molsltlim,nsegslt,
     -        isegno,ifail,maxng,maxrec,MAXBRIDGEATOM)
            if (ifail .eq. 1) go to 9005
            call extend_nnlist(nneig,ineig,npneig,nslt,maxng,maxrec)
c            do ia=1,nslt
c              atnam=line(index(ia))(inamcol1:inamcol1+3)
c              write (77,7719) ia,atnam,nneig(ia),npneig(ia),
c     -          (ineig(in,ia),in=1,npneig(ia))
c            end do
c7719        format(i5,1x,a,' nn=',i3,' nnp=',i6,' in=',(10i5))
            npspages=2
            if (itraj .eq. 1) then
              ibondcorr=0
              call askyn('Do you want to print the heavy-atom contacts',
     -          44,1,+1,ihphprint,0)
              noprintconf=1-ihphprint
              iaskcolcode=1
            end if
            nres2d=ixres(nslt)
            ibondtype=4
            innlist=0
          end if
        else if (ianaltyp .eq. 8) then
c         Set up residue contact list calculation
          if (inpcrdtyp .gt. ioins) then
            print *,'Input format does not have residue information'
            go to 9002
          end if
          call modrepats
          call getreal('Threshold distance with representative atoms',
     -      44,10.0,resdistlim,1,38)
          call getreal('Threshold distance with closest approach',40,
     -      10.0,resapplim,1,39)
          call askyn(
     -      'Do you want to ignore hydrogens for the closest approach',
     -      56,1,1,ignoreh,106)
          if (iresshift .gt. 0) write (6,2029)
          isegdef1=1
          call getresrange(nsegm,indexs,isegno,ixres,iresno,ifres,
     -      'reference residue to use',24,numresslt,nslt,irefres1,
     -      irefres2,isegdef1,irefseg1,irefseg2,listrefres,nrefres,
     -      nrefrange,0,0,maxrsd,maxrec,111)
          write (6,*)
          if (isegdef1 .gt. 0) isegdef2=nsegm
          if (isegdef1 .eq. nsegm) isegdef2=1
          call getresrange(nsegm,indexs,isegno,ixres,iresno,ifres,
     -      'neighbourhood residue to use',28,numresslt,nslt,
     -      inegres1,inegres2,isegdef2,inegseg1,inegseg2,listnegres,
     -      nnegres,nnegrange,0,0,maxrsd,maxrec,111)
          write (6,2050) 'representative',analfile(1:namleno)
          write (6,2050) 'closest',analfile1(1:namleno1)
          if (itraj .gt. 0) then
            if (irefres2-irefres1 .lt. MAX2D .and.
     -         inegres2-inegres1 .lt. MAX2D) then
              print *,'By default, average distances are based on the ',
     -          'representative atoms'
              itypavg=1
              call askyn(
     -          'Do you want to average the contact distances instead',
     -           52,1,-1,iusecont,000)
              itypavg=itypavg+iusecont
              npspages=1
              iw4=44
              if (itypavg .eq. 1) then
                analfile4=analfile
                namleno4=namleno
              else
                analfile4=analfile1
                namleno4=namleno1
              end if
              analfile4(namleno4+1:namleno4+3)='.ps'
              namleno4=namleno4+3
              call openfile(iw4,0,'average distance matrix',23,'new',
     -          analfile4,namleno4,notfnd,0,1,1,0,0)
              call openps(iw4,500.0,500.0,' ',1,' ',1,inpfile,0,
     -          inpfile,0,1,ipspage)
            else
              write (6,2112) MAX2D
            end if
          end if
          increst=0
          incsolvrr=0
          numresrr=numres
          idisjoint=1
          if (inegres1 .le. irefres2 .and. inegres2 .ge. irefres1) then
            match=0
            do irr=1,nrefres
              do irn=1,nnegres
                if (listrefres(irr) .eq. listnegres(irn)) match=1
              end do
            end do
            idistjoint=1-match
          end if
          if (idisjoint .eq. 1) then
c           The ranges are disjoint
            call openfile(iw2,0,'contact list',12,'new',analfile2,
     -        namleno2,notfnd,0,1,1,0,0)
            call datprt(iw2,version,1,mark0,lmark0,hostname,lhostname,
     -        iheadnode,0)
            write (6,2050) 'contact',analfile2(1:namleno2)
            call askyn(
     -        'Do you want all neighbors of the interface residues',51,
     -        1,1,increst,57)
            if (n .gt. nslt .and. increst .eq. 1) then
              call askyn('Do you want to include solvent neighbors',40,
     -          1,-1,incsolvrr,0)
              if (incsolvrr .eq. 0) then
                numresrr=numresslt
                incsolvrr=-1
              end if
            end if
          else
            print *,'NOTE: residue ranges overlap; no contact list ',
     -        'will be generated'
            iw2=0
          end if
          call zeroiti(irescount1,0,numresslt)
          call zeroiti(irescount2,0,numresslt)
          call zeroiti(irescount3,0,numresslt)
          irefresinc=ixresno(ixres(molsltlim(1,irefseg1)))-
     -      ixres(molsltlim(1,irefseg1))
          inegresinc=ixresno(ixres(molsltlim(1,inegseg1)))-
     -      ixres(molsltlim(1,inegseg1))
        else if (ianaltyp .eq. 33) then
c         Set up molecule-molecule distance calculation
          if (nmolslt .eq. 1) then
            write (6,*) 'Solute is a single molecule'
            go to 9003
          end if
          write (6,2120) 'COM-COM distance',analfile(1:namleno)
          write (6,2120) 'closest distance',analfile1(1:namleno1)
          call askyn(
     -      'Do you want to ignore hydrogens for the closest approach',
     -      56,1,1,ignoreh,106)
          write (iw0,2121) 'center-of-mass distance'
          write (iw1,2121) 'closest approach'
        else if (ianaltyp .eq. 36 .or. ianaltyp .eq. 37 .or.
     -           ianaltyp .eq. 38) then
          iwpdb=0
          if (iresshift .gt. 0) write (6,2156)
          if (ianaltyp .eq. 36) then
c           Compare two residue distance matrices
            call compare_rrdist(resnames,nrescol,itemp1,temp,irefres1,
     -        irefres2,analfile4,lanalfile4,igl,maxrsd)
            call askyn(
     -        'Do you want to write a PDB file with average changes',52,
     -         1,0,iwpdb,0)
          else if (ianaltyp .eq. 37) then
c           Compare two residue bond (HB, SB, or HP) matrices from Simulaid log
            nres=ixres(nslt)
            call compare_bondmat(resnames,nrescol,itemp1,temp,nres,
     -        analfile4,lanalfile4,igl,maxrsd)
            irefres1=1
            irefres2=nres
            call askyn(
     -        'Do you want to write a PDB file with cumulative changes',
     -         55,1,0,iwpdb,0)
          else
c           Compare two residue RMSF lists from Simulaid log
            call askyn(
     -        'Do you want to write a PDB file with the differences',52,
     -        1,0,iwpdb,0)
            siglev=0.0
            if (iwpdb .eq. 1) call getreal(
     -        'Significance level threshold to set to 0 the difference',
     -        55,0.05,siglev,1,000)
            call compare_rmsf(resnames,nrescol,siglev,temp,analfile4,
     -        lanalfile4,irefres1,irefres2,maxrsd)
          end if
          if (iwpdb .gt. 0) then
            do ir=irefres1,irefres2
              do ia=ifres(ir),ilres(ir)
                cv(ia)=temp(ir)
              end do
            end do
            analfile4(lanalfile4:lanalfile4+2)='db'
            lanalfile4=lanalfile4+1
            iw4=44
            call openfile(iw4,0,'Avg difference labeled PDB',26,
     -        'new',analfile4,lanalfile4,notfnd,0,1,1,0,0)
            call writeconf(iw4,inpcrdtyp,iobpdb,inpcrdtyporg,
     -        nslt,nslt,nslt,naslv,islvw,iasv,namesv,qsv,pflsv,1,
     -        iwhead,0,iatnum,ifchrg,nconfig,innlist,c,rprox,cv,ixres,
     -        iresno,atnames,resnames,segnames,charge,isegno,marker,
     -        ntitlin,ntitlinw,title,ireseq,iresnrestart,iresidrestart,
     -        nneig,nneiga,nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,
     -        npneig,numres,numslv,resnamslv,line,blankline,mmtype,ibnd,
     -        index,indexn,indexo,1,molresflag,irescount3,hblimfac,
     -        angmin,0,1,1,1,0,3,iqspaceask,ianaltyp,0,0.0,0,0,0,
     -        keeprem,iwriteatsym,radtodeg,maxrepconf,maxng,maxrsd,
     -        maxrec)
            close (iw4)
          end if
        else if (ianaltyp .eq. 31) then
c         Set up adjacency matrix-based analysis
          if (inpcrdtyp .gt. ioins) then
            print *,'Input format does not have residue information'
            go to 9002
          end if
          write (6,2046) analfile(1:namleno)
          call quiz(analtyp,idtyp,' ',' ',0,
     -      'residue distance definition',27,0,5,6,igl,0)
          if (analtyp .eq. 'r') then
            resdistdef=7.5
            call modrepats
            ignoreh=0
            irepuse=1
          else
            call askyn(
     -       'Do you want to ignore hydrogens for the closest approach',
     -        56,1,1,ignoreh,106)
            irepuse=0
            resdistdef=5.0
          end if
          call getreal('Threshold distance',18,resdistdef,resdistlim,1,
     -      38)
          call quiz(analtyp,iadjtyp,' ',' ',0,'adjacency analysis',18,
     -      0,5,6,igl,108)
          call getint('Highest exponent to raise the adjacency matrix',
     -      46,1,1,100,nexpmax,0)
          call getint('Power interval to plot',22,1,1,100,npint,0)
          call askyn(
     -      'Do you want to scale the column sums to [0,1] range',51,
     -      1,1,iscalesum,000)
          isegdef=1
          call getresrange(nsegm,indexs,isegno,ixres,iresno,ifres,
     -      'residue to use',14,numresslt,nslt,ires1,ires2,isegdef,
     -      iseg1,iseg2,listrefres,nresref,nrange,1,1,maxrsd,maxrec,000)
          call askyn('Do you want to mark residues',28,1,0,imarkres,109)
          if (imarkres .eq. 1) then
            iw4=44
            namleno4=0
            call openfile(iw4,0,'residue mark',12,'old',analfile4,
     -        namleno4,notfound,3,1,1,0,0)
            read (iw4,2044,end=771) (itemp4(i-ires1+1),i=ires1,ires2)
 771        close (iw4)
            nmarks=0
            do ii=ires1,ires2
              i=ii-ires1+1
              if (itemp4(i) .gt. nmarks) nmarks=itemp4(i)
            end do
            if (ipredict .eq. 0) then
              do imark=1,nmarks
                write (6,2056) imark
                read (5,2095) marks(imark)
              end do
            else
              write (6,2045) (i,marks(i),i=1,9)
            end if
          end if
          npspages=1
          call openps(iw1,xm,ym,title,ltitle76,
     -      'Adjacency matrix analysis',25,inpfile,namleni,inpfile,0,1,
     -      ipspage)
        else if (ianaltyp .eq.  9) then
c         Set up distance measuring
          if (itraj .eq. 1)
     -       write (6,2019) 'Distances measured',analfile(1:namleno)
          write (6,2047)
          call getint('First  atom number',18,1,1,n,ia1,0)
          call getint('Second atom number',18,1,1,n,ia2,0)
          ifirstref=0
          if (itraj .eq. 1) then
            if (ia1 .eq. ia2) then
              ifirstref=1
            else
              call askyn(
     -          'Is the first atom fixed on the input structure',46,
     -          1,-1,ifirstref,0)
            end if
            print *,'Progression of distance vector will be plotted ',
     -        'projected to a coordinate plane'
            call readax('Axis normal to the plane (1,2,3)',32,3,idax,
     -        indexax)
          end if
          if (ia1 .eq. ia1) then
            write (atomdist,2052) ia1
            pstitle(1:15)=atomdist
            lpstitle=15
          else
            write (atomdist,2053) ia1,ia2
            pstitle(1:22)=atomdist
            lpstitle=22
          end if
          npspages=4
          if (inpcrdtyp .le. ioins) then
            ir1=iresno(ia1)
            ir2=iresno(ia2)
            write (6,2057) ia1,ir1,line(index(ia1))(inamcol1:inamcol2),
     -        line(index(ia1))(irescol1:irescol2),
     -        ia2,ir2,line(index(ia2))(inamcol1:inamcol2),
     -        line(index(ia2))(irescol1:irescol2)
            if (itraj .eq. 1) write (iw0,2057) ia1,ir1,
     -        line(index(ia1))(inamcol1:inamcol2),
     -        line(index(ia1))(irescol1:irescol2),
     -        ia2,ir2,line(index(ia2))(inamcol1:inamcol2),
     -        line(index(ia2))(irescol1:irescol2)
          else
            write (6,2058) ia1,ia2
            if (itraj .eq. 1) write (iw0,2058) ia1,ia2
          end if
          if (ifirstref .eq. 1) then
            write (iw0,2051) inpfile(1:namleni)
            write (6,2051) inpfile(1:namleni)
            call trnsfr(caref,cres(1,ia1),3)
          end if
          call setpbccell('Do you want to use periodic images',34,
     -      edge,edge_gen,cell,ncell,cellalt,ixyzhex,npbc,
     -      ioppbc,iusepbc,vol,nw,rinscr,rcirc,0,igl)
          if (iusepbc .ge. 0) then
            if (ifirstref .eq. 1) then
              call pbcdist(caref,c(1,ia2),ia1,ia2,cell,ncell,-iw0,
     -          1,img,drincr,dimg)
              call zeroit(drimg,3)
              call arrdiff(drimg,cell(1,img),drimg,3)
            end if
          else
            ncell=1
          end if
          xm=800.0
          ym=900.0
        else if (ianaltyp .eq. 10) then
c         Set up check for unphysical features
          write (6,2019) 'List of suspicious contacts',
     -      analfile(1:namleno)
          call getreal('CTFAC',5,1.4,ctfac,1,62)
          call getreal('MINFAC',6,0.4,bondminfac,1,62)
          call getint('MAXDIST',7,min0(nslt,50),1,nslt,maxdist,62)
          isltonly=1
          if (n .gt. 2000) print *,'NOTE: This check is SLOW'
          if (nslt .lt. n)
     -      call askyn('Do you want to include the solvents',
     -        35,0,-1,isltonly,0)
          if (nsegslt .gt. 3 .and. ischarmm(inpcrdtyp) .eq. 1) then
            call askyn('Do you have LES segments',24,1,-1,iles,0)
            if (iles .eq. 1) then
              qq='Is segment      a duplicate'
              do is=1,nsegslt
                qq(12:15)=segid4(is)
                call askyn(qq,27,1,-1,idelseg(is),0)
              end do
            end if
           write (6,2114)
          end if
          call setmolres(ifres,ilres,isegno,molresflag,
     -      molsltlim,nrescol,irescol1,irescol2,resnames,numresslt,
     -      nmolslt,nsegslt,nmolsltnoion,minresflag,index,indexa,indexs,
     -      line,maxrsd,maxrec)
          call setpbccell('Do you want to use periodic images',34,
     -      edge,edge_gen,cell,ncell,cellalt,ixyzhex,npbc,
     -      ioppbc,iusepbc,vol,nw,rinscr,rcirc,0,igl)
          write (iw0,2061) ctfac,bondminfac,maxdist
          call printbondthres(ialist,nanos,ctfac,bondminfac,
     -      iatnm2,ramax,iw0)
          if (iusepbc .ge. 0) then
            write (iw0,*) 'Intermolecular distances include PBC images'
            call prtcell(ioppbc,edge,edge_gen,r,vol,nw,-iw0)
          end if
          if (nslt .gt. 1000) print *,'Wait ...'
        else if (ianaltyp .eq. 11) then
c         Psudorot calc
          if (itraj .eq. 1) then
            call getring(line,index,ix5,irescol1,irescol2,inamcol1,
     -        inamcol2,nslt,numres,iresring,iresno,ifres,ilres,nmem,
     -        psrtyp,0,incgen,iapex,igl,MAXRING,maxrec)
            write (6,2019) 'Pseudorotation angles',analfile(1:namleno)
          end if
        else if (ianaltyp .eq. 12) then
          write (6,2071) analfile(1:namleno)
          extnam1='.pkn'
          iprintpk=0
          irespro=0
          if (iresshift .gt. 0) write (6,2029)
          if (nsegm .gt. 1) then
9083        call getint('Segment number of helix',23,1,1,
     -        nsegm,isegpkhx,0)
            call findrange(isegno,1,nslt,isegpkhx,ifseghx,ilseghx,
     -        'segment',7,ifail)
            if (ifail .gt. 0) go to 9083
          else
            ifseghx=1
            ilseghx=nslt
          end if
          do while (irespro .eq. 0)
            call getint('Residue number of the kink (Proline)',36,
     -        0,1,iresno(nslt),irespro,0)
            call findresnum(iresno,ixres,irespro,ifseghx,ilseghx,ia,
     -        irfound)
          end do
          ial=ia-1
          irespro=irfound
          resnam(1:nrescol)=line(index(ia))(irescol1:irescol2)
          call leftadjustn(resnam,rn,8)
          noprol=0
          if (rn(1:3) .ne. 'PRO') then
            print *,'NOTE: residue ',irespro,
     -        ' is not a proline but a ',resnam(1:nrescol)
            noprol=1
            iflatproline=0
          else
            call askyn('Do you want to project the proline to a plane',
     -        45,1,-1,iflatproline,96)
          end if
9082      call getint('Number of helix residues before the kink',40,
     -      7,1,MAXHX-1,nrb,0)
          call getint('Number of helix residues after  the kink',40,
     -      7,1,MAXHX-1,nra,0)
          if (nra .lt. 4 .or. nrb .lt. 4) then
            print *,'Minimum helix length is four '
            go to 9082
          end if
          icaonly=-1
          call findprotbackbone(line,index,iresno,ia,inamcol1,
     -      icapr,icpr,inpr,icbpr,icgpr,icdpr,nslt,icaonly,maxrec)
          write (6,2158) 'Proline',0,
     -      line(index(ia-1))(irescol1:irescol2),iresno(ia-1),
     -      icapr,icpr,inpr
          icaa(1)=icapr
          ica(1)=icpr
          ina(1)=inpr
c         icab(1)=icapr
c         icb(1)=icpr
c         inb(1)=inpr
          do ir=1,nra
            call findprotbackbone(line,index,iresno,ia,inamcol1,
     -        icaa(ir+1),ica(ir+1),ina(ir+1),icbx,icgx,icdx,
     -        nslt,icaonly,maxrec)
            write (6,2158) 'After  ',ir,
     -        line(index(ia-1))(irescol1:irescol2),iresno(ia-1),
     -        icaa(ir),ica(ir),ina(ir)
          end do
          do ir=1,nrb
            ia=ial
            ires=iresno(ial)
            do while (iresno(ia) .eq. ires .and. ia .gt. 1)
              ia=ia-1
            end do
            ial=ia
            ia=ia+1
            call findprotbackbone(line,index,iresno,ia,inamcol1,
     -        icab(ir),icb(ir),inb(ir),icbx,icgx,icdx,nslt,
     -        icaonly,maxrec)
            write (6,2158) 'Before ',ir,
     -        line(index(ia-1))(irescol1:irescol2),iresno(ia-1),
     -        icab(ir),icb(ir),inb(ir)
          end do
          print *,"Kink residue (proline) will be added only to the ",
     -      "helix 'after'"
          if (noprol .eq. 0) then
            call getring(line,index,ix5,irescol1,irescol2,inamcol1,
     -        inamcol2,nslt,numres,irespro,iresno,ifres,ilres,nmem,
     -        'p',1,incgen,iapex,igl,MAXRING,maxrec)
            if (nmem .eq. 0)
     -        print *,'Pseudorotation angle calculation is canceled'
          end if
          write (iw0,2077)
          write (iw0,2015) irespro-nrb,irespro+nra,isegpkhx
          write (resrange(1:22),2087) irespro-nrb,irespro+nra
          write (iw0,2083) irespro
          if (itraj .eq. 1) then
c           Open Prokink dial window, initialize trajectory accumulators
            ndials=5
            if (nmem .eq. 0) ndials=ndials-1
          end if
          nomat0=1
        else if (ianaltyp .eq. 21) then
9194      call getint('Number of helices to analyze',28,1,1,MAXNHX,nhx,
     -      0)
          npspages=nhx*11+1
          if (nhxres*nhx .gt. MAXCOPY1) then
            write (6,2161) nhxres*nhx,MAXCOPY1
            go to 9194
          end if
          do ihx=1,nhx
c           Helix axis directions
            if (nhx .gt. 1) write (6,2159) ihx
            if (nsegm .gt. 1) then
9183          call getint('Segment number of helix',23,1,1,
     -          nsegm,iseghx(ihx),0)
              call findrange(isegno,1,nslt,iseghx(ihx),ifseghx,ilseghx,
     -          'segment',7,ifail)
              if (ifail .gt. 0) go to 9183
            else
              ifseghx=1
              ilseghx=nslt
            end if
            if (iresshift .gt. 0) write (6,2029)
9182        call getrange(ireshx1(ihx),999999,ireshx2(ihx),999999,incr,
     -        0,'helix residue',13,iresno(ilseghx),0)
            if (ireshx1(ihx) .lt. iresno(ifseghx)) then
              write (6,2123) 'less',iresno(ifseghx)
              go to 9182
            end if
            if (ireshx2(ihx) .gt. iresno(ilseghx)) then
              write (6,2123) 'greater',iresno(ifseghx)
              go to 9182
            end if
            nreshx(ihx)=ireshx2(ihx)-ireshx1(ihx)+1
            if (nreshx(ihx) .lt. 4) then
              print *,'Minimum helix length is four '
              go to 9182
            else if (nreshx(ihx) .gt. MAXHX-1) then
              print *,'Maximum helix length is ',MAXHX-1
              go to 9182
            end if
            print *
            icaonly=0
            do ir=ireshx1(ihx),ireshx2(ihx)
              ir0=ir
              call findresnum(iresno,ixres,ir0,ifseghx,ilseghx,ia,
     -          irfound)
              if (ir0 .eq. 0) go to 9182
              ir1=ir-ireshx1(ihx)+1
              ia=ifres(irfound)
              call findprotbackbone(line,index,iresno,ia,
     -          inamcol1,icaahx(ir1,ihx),ica(ir1),ina(ir1),icbx,icgx,
     -          icdx,nslt,icaonly,maxrec)
              write (6,2158) ' ',ir,
     -          line(index(icaahx(ir1,ihx)))(irescol1:irescol2),
     -          iresno(icaahx(ir1,ihx)),icaahx(ir1,ihx),ica(ir1),
     -          ina(ir1)
            end do
            call readax(
     -        'Coordinate axis most parallel to helix (1-2-3)',
     -        46,3,ihax,indexaxhx(1,ihx))
            axdirchar(ihx)=xyz(ihax)
9184        call getint(
     -        'Number of residues to ignore for rotation at each end',
     -        53,0,1,0,incrot,0)
            if (ireshx2(ihx)-ireshx1(ihx)+1-2*incrot .lt. 4) then
              print *,'ERROR: too few residues remain to form a helix'
              go to 9184
            end if
          end do
          ndials=6
          idebughx=0
          call askyn('Do you want debug output',24,1,-1,idebughx,0)
          if (idebughx .gt. 0) then
            call askyn('Do you want to skip bend analysis',33,1,-1,ibx,
     -        0)
            if (ibx .gt. 0) idebughx=idebughx+1
          end if
          if (idebughx .lt. 2) call getreal(
     -      'Minimum distance (in A) from axis to count as bend',50,
     -      0.0,axtol,1,0)
          write (iw0,2004) axtol
          write (iw0,2007)
          do ihx=1,nhx
            write (iw0,2015) ihx,ireshx1(ihx),ireshx2(ihx),iseghx(ihx)
          end do
          if (itraj .eq. 1) then
            linein(1:45)='Do you want to subtract the solute COM shift '
            linein(46:65)='from the helix shift'
            call askyn(linein,65,1,1,isubcrm,0)
            linein(1:41)='Do you want to overlay each frame on the '
            linein(42:60)='reference structure'
            call askyn(linein,60,1,1,ioverlay,0)
            if (ioverlay .gt. 0 .and. nsegslt .gt. 1) then
              linein(1:43)='Do you want to overlay each solute molecule'
              linein(44:54)=' separately'
              call askyn(linein,54,1,1,ioverlaym,0)
              if (ioverlaym .gt. 0) ioverlay=ioverlay+1
            end if
            if (idebughx .gt. 0) then
              linein(1:40)='Do you want to reorient each helix onto '
              linein(41:59)='the reference helix'
              call askyn(linein,59,1,1,ireorienthx,0)
            else
              ireorienthx=1
            end if
            idsspcheck=0
            if (icaonly .lt. 1)
     -        call askyn('Do you want to run DSSP check on each frame',
     -          43,1,1,idsspcheck,0)
            call zeroiti(nhelixok,0,3)
            if (idsspcheck .eq. 1) 
     -        write (iw0,2016) (typc(i),ssname(i)(1:lssname(i)),i=1,9)
          end if
          if (igl .eq. 1 .and. itraj .eq. 1) write (6,2070)
        else if (ianaltyp .eq. 13) then
c         Set up hydropathy labeling
          write (6,2076) 'Hydropathy scale',analfile(1:namleno)
          ihydtyp=0
        else if (ianaltyp .eq. 20) then
          innlist=0
c         Set up Delphi potential labeling
          nl2=0
          call openfile(50,0,'Delphi potential map file',25,'old',
     -      analfile2,nl2,notfnd,0,2,1,0,0)
          call readmap(50,xstart,ystart,zstart,gx,gy,gz,ngx,ngy,ngz,
     -      nconf,c2,maxrec)
          igincr=0
          do while (igincr .lt. 1)
            call getint('Increment to use in reading the potential map',
     -         45,1,1,ngx,igincr,47)
            if (igincr .lt. 1) print *,'Invalid'
          end do
          if (igincr .gt. 1) write (6,2026) igincr
          write (6,2076) 'Delphi potentials',analfile(1:namleno)
          call askyn(
     -      'Do you want to exclude/interpolate grids near atoms',51,
     -      1,-1,iexcl,63)
          if (iexcl .gt. 0) then
            call getreal('Minimum distance between an atom and a grid',
     -        43,1.0,rnear,1,63)
            call askyn(
     -        'Do you want to interpolate the excluded grid values',51,
     -        1,-1,interpol,0)
          end if
          call askyn('Do you want to query the potential map',40,1,-1,
     -      iquery,64)
          iw2=0
          iw3=0
          if (igridfile+iquery .eq. 0) then
            print *,'No action requested'
          else
            if (igridfile .gt. 0) then
              write (6,2076) 'Delphi grid potentials',
     -          analfile1(1:namleno1)
              write (iw1,2027) 'Delphi grid potentials'
c             Open 2nd grid PDB file
              iw2=iw1+1
              analfile2=analfile1
              analfile2(namleno1:namleno1)='0'
              write (6,2076)
     -          'Delphi grid potentials without excluded grids',
     -          analfile2(1:namleno1)
              call openfile(iw2,0,'grid',4,'new',analfile2,namleno1,
     -          notfnd,0,1,1,0,0)
              write (iw2,2027)
     -          'Delphi grid potentials without excluded grids'
              if (interpol .gt. 0) then
                iw3=iw2+1
                analfile3=analfile1
                analfile3(namleno1:namleno1)='1'
                write (6,2076)
     -          'Delphi grid potentials, interpolating excluded grids',
     -            analfile3(1:namleno1)
                call openfile(iw3,0,'grid',4,'new',analfile3,namleno1,
     -            notfnd,0,1,1,0,0)
                write (iw3,2027)
     -            'Delphi grid potentials, interpolating excluded grids'
              end if
            end if
            call delphigrid(iw1,iw2,iw3,c,n,nslt,xstart,ystart,zstart,
     -        gx,gy,gz,ngx,ngy,ngz,igincr,rnear,igridfile,iexcl,
     -        iquery,interpol)
            if (iw1 .gt. 0) close (iw1)
            if (iw2 .gt. 0) close (iw2)
            if (iw3 .gt. 0) close (iw3)
            if (iexcl .gt. 0) call readmap(50,xstart,ystart,zstart,
     -        gx,gy,gz,ngx,ngy,ngz,nconf,c2,maxrec)
          end if
        else if (ianaltyp .eq. 14) then
c         Set up circular variance labeling calculation
          write (6,2076) 'Circular variances',analfile(1:namleno)
          nsltref_f=1
          nsltref_f=nslt
          call getrange(nsltref_f,1,nsltref_l,nslt,incr,0,
     -      'solute atom to include in the CV calculation',44,nslt,000)
          call getreal(
     -      'Distance cutoff for the circular variance calculation',
     -      53,10.0,rcut_cv,1,66)
          islvrep=1
          if (n .gt. nslt) then
            if (naslv .gt. 1)
     -        call getint('Index of the representative solvent atom',
     -          40,1,1,naslv,islvrep,25)
            call askyn('Do you want to sort solvents by CV',34,1,+1,
     -        isortslv,0)
            if (isortslv .gt. 0) then
              write (6,2105)
              call getreal('CV threshold to count the # of solvents',
     -          39,0.5,cvlim,1,67)
            end if
          end if
        else if (ianaltyp .eq. 15) then
c         Set up circular variance map calculation
          write (6,2075) 'Circular variance',analfile(1:namleno),
     -      analfile1(1:namleno1)
          xm=500.0
          ym=800.0
          call openps(iw1,xm,ym-20,title,ltitle76,
     -      'Circular variance map',21,inpfile,namleni,inpfile,0,1,
     -      ipspage)
          iaskcolcode=1
          npspages=1
        else if (ianaltyp .eq. 16) then
c         Set up DSSP calculation
          write (6,2019)
     -      'Secondary structure assignment according to DSSP',
     -      analfile(1:namleno)
          if (itraj .eq. 1) write (6,2019)
     -       'Secondary structure plot',analfile1(1:namleno1)
          write (iw0,2003) 
          if (itraj .eq. 1) then
            call getrange(ifrdssp,1,ilrdssp,numresslt,incr,0,
     -        'residue sequence number to plot',31,numresslt,0)
            if (iresshift .gt. 0) then
              write (6,2117) 'first',ixresno(ifrdssp)
              write (6,2117) 'last ',ixresno(ilrdssp)
              call askyn(
     -          'Do you want to use the actual residue # on the Y axis',
     -          53,1,-1,iuseinp,0)
            end if
            call askyn(
     -        'Do you want to calculate turn information (see GW Rose)',
     -        55,1,-1,irose,0)
            iwrose=iw0*irose
          else
            ifrdssp=1
            ilrdssp=numresslt
            iwrose=0
          end if
          if (iuseinp .eq. 1) then
            call trnsfi(indexdel,ixresno,numresslt)
            do i=numresslt+1,maxrec
              indexdel(i)=indexdel(numresslt)+(i-numresslt)
            end do
          end if
          if (iuseinp .eq. 0) call indexit(indexdel,1,numresslt,0)
          call zeroiti(idistdssp,0,9*maxrsd)
          ncolcode=8
          innlist=0
        else if (ianaltyp .eq. 22 .or. ianaltyp .eq. 23 .or.
     -           ianaltyp .eq. 24) then
c         Set up RMSD calculations
          iaskcolcode=1
          call zeroiti(indexdel,0,n)
          call indexit(indexov,1,nslt,0)
          nfinalov=nslt
          if (ianaltyp .eq. 23 .or. ianaltyp .eq. 24) then
            absdevmin=100000.0
            absdevmax=0.0
            innlist=0
            xm_2d=600.0
            ym_2d=775.0
            xm=xm_2d
            ym=ym_2d
          end if
          noopt2d=0
          if (iread2d .eq. 0) then
            if (ianaltyp .eq. 23 .or. ianaltyp .eq. 24) then
              write (iw0,2084)
              call askyn(
     -          'Do you want to superimpose first the frames',43,
     -          0,+1,noopt2d,0)
              if (noopt2d .eq. 0) write (iw0,2116)
     -          'after obtaining the best fit with the Kabsch method'
              if (noopt2d .eq. 1) write (iw0,2116)
     -           'without superimposition'
              write (iw0,*)
              rmsdmin=0.0
              call getreal(
     -          'MAXimum of the RMSD scale (default: actual maximum)',
     -          51,0.0,rmsdmax,1,53)
            end if
            if (noopt2d .eq. 0) then
              call askyn('Do you want to select atoms for overlay',39,
     -          1,-1,iedit,69)
              if (iedit .gt. 0) then
                nrecdel=0
                call select(line,nrecdel,idcol,asterisk,n,nslt,index,
     -            ixres,is1,is2,iseqncol1,iseqncol2,inamcol1,inamcol2,
     -            irescol1,irescol2,iqcol1,iqcol2,charge,iatnum,
     -            nneig,ineig,indexdel,iw0,igl,maxng,maxrec)
c               indexdel: 0 for atoms to use for the overlay, 1 for the rest
                call masktolist(indexov,indexdel,nslt,nfinalov,0)
              end if
            end if
c           indexov contains the list of atoms used for overlay
            iqincr=0
            if (nfinalov .eq. nslt) iqincr=1
            call quiz(ans,icalctyp,'a',' ',0,
     -        'atoms for RMSD calculation',26,iqincr,5,6,igl,0)
            if (ans .eq. 'a') then
              call indexit(indexrmsd,1,nslt,0)
              nfinalrmsd=nslt
            else if (ans .eq. 'o') then
              call trnsfi(indexrmsd,indexov,nfinalov)
              nfinalrmsd=nfinalov
            else
              nrecdel=0
              call zeroiti(indexdel,0,n)
              call select(line,nrecdel,idcol,asterisk,n,nslt,index,
     -          ixres,is1,is2,iseqncol1,iseqncol2,inamcol1,inamcol2,
     -          irescol1,irescol2,iqcol1,iqcol2,charge,iatnum,nneig,
     -          ineig,indexdel,iw0,igl,maxng,maxrec)
              call masktolist(indexrmsd,indexdel,nslt,nfinalrmsd,0)
            end if
            if (nfinalrmsd .lt. nslt) limresrange=1
c           indexrmsd contains the list of atoms used for overlay
            if (nfinalov .lt. nslt) then
              write (6,2153) 'overlay',nfinalov,nslt
              write (iw0,2153) 'overlay',nfinalov,nslt,';',
     -          (indexov(i),i=1,nfinalov)
            else if (noopt2d .eq. 0) then
              write (6,2154) 'overlay'
              write (iw0,2154) 'overlay'
            end if
            if (nfinalrmsd .lt. nslt) then
              write (6,2153) 'RMSD',nfinalrmsd,nslt
              write (iw0,2153) 'RMSD',nfinalrmsd,nslt,';',
     -          (indexrmsd(i),i=1,nfinalrmsd)
            else
              write (6,2154) 'RMSD'
              write (iw0,2154) 'RMSD'
            end if
            atwsum=0.d0
            do iaa=1,nfinalov
              ia=indexov(iaa)
              atw(ia)=aw(iatnum(ia))
              atwsum=atwsum+atw(ia)
              end do
          end if
          if (ianaltyp .eq. 22) then
            call askyn('Do you want to plot also the maximum deviation',
     -        46,1,-1,maxdevplot,0)
            call askyn('Do you want to plot without overlay',35,1,-1,
     -        iunmatchplot,0)
            write (iw0,2082)
            npspages=1+iunmatchplot
            if (inptrajtyp .eq. 3) npspages=npspages+1
            call getreal(
     -        'MAXimum of the RMSD scale (default: actual maximum)',
     -        51,0.0,rmsdplotmax,1,0)
            if (numresslt .le. MAXDISTR) then
              call zeroitd(rmsfsum,numresslt)
              call getreal(
     -          'MAXimum of the RMSF scale (default: actual maximum)',
     -          51,0.0,rmsfplotmax,1,0)
              call getint('Frequency of plotting error bars',32,
     -          max0(1,numresslt/10),1,max0(1,numresslt/2),nfreqsd,0)
            else
              write (6,2062) numresslt,MAXDISTR
              npdpages=npspages-1
            end if
          end if
          if (ianaltyp .eq. 23) then
c           2D RMSD
            call askyn(
     -        'Do you want to also plot the RMSD distributions',47,
     -        0,+1,noplotdist,93)
            ireplot=0
            if (iread2d .eq. 0) then
              pstitle='2-D RMSD map'
              lpstitle=12
              npspages=3
              call askyn('Do you want RMSD-based clustering',33,
     -          1,+1,irmsdclust,0)
              call askyn('Do you want to skip plotting the matrix',39,
     -          1,-1,iskip2dplot,121)
              if (irmsdclust .gt. 0)
     -          call askyn(
     -            'Do you want an RMSD map rearranged by clusters',46,
     -            1,1,ireplot,0)
            else
              irmsdclust=0
c             Read 2-d RMSD map, run clustering
              lq=32+lanalfile4
              question(1:lq)='Input rd2 file name: '
     -          //analfile4(1:lanalfile4)//' - is it OK'
              call askyn(question,lq,1,1,ians,00)
              if (ians .eq. 0) lanalfile4=0
              call openfile(iw4,0,'previously written .rd2',23,
     -          'old',analfile4,lanalfile4,notfnd,3,1,1,0,0)
              extnam2='    '
              write (6,2107) 'Clustering results',analfile(1:namleno)
              write (iw0,2064) analfile4(1:namlen4)
              call read_2drmsd(iw4,system,lsystem,trajnam,ltrajnam,
     -          trajnam2,ltrajnam2,1,rmsdmn,rmsdmx,nframe,
     -          nframex,nframey,ietotsaved,0,limresrange)
              nframeref=nframe
              close(iw4)
c             Run clustering
              call indexit(iconfsel,1,MAX2D,0)
              call indexit(ixclst,1,MAX2D,0)
              call askyn(
     -          'Do you want an RMSD map rearranged by clusters',46,
     -          1,1,ireplot,0)
              call clusterdistr(nframe,iw0,rmsdlim,rmsdmn,rmsdmx,
     -          nhbdist,it1,it2,it3,itemp4,indexn,indexo,ncl,indexa,
     -          iconfsel,ixclst,it4,value,ifa_s,ila_s,ih,cv,0.0,rdclust,
     -          res(1,1,11),ietotsaved,'RMSD',4,1,1,irepav,irepmx,
     -          irepeng,irepkm,engcl,c,chn,c2,1,27,iclstyp,iwt,0,
     -          label2d,80,0,1,1,1,igl,mx2d,maxframe)
              do i=1,ncl
                nclstmem(i)=indexo(i)-indexn(i)+1
              end do
              call trnsfi(ixshuffle,iconfsel,MAX2D)
c             iconfsel contains the sorted cluster members
c             indexn, indexo contain the cluster limits
              call countsim(indexn,indexo,iconfsel,ncl,rdclust,rmsdsim,
     -          nsimclst1,iw0,mx2d)
              call askyn('Do you want to replot the input RMSD map',40,
     -          1,-1,ireplotinp,0)
              if (ireplot .eq. 0) call askyn(
     -          'Do you want an RMSD map rearranged by clusters',46,
     -          1,1,ireplot,0)
              if (ireplot+ireplotinp .gt. 0) then
                call getint(askcolcode,24,maxcolcode,1,maxcolcode,
     -            ncolcode,95)
c               Generate plot file name
                pstitle='2-D RMSD map'
                lpstitle=12
                npspages=2
                analfile2=analfile
                analfile2(namleni-2:namleni+6)='rd2_sh.ps'
                namleno2=namleni+6
                write (6,2107)
     -            pstitle(1:lpstitle)//' and membership plot',
     -            analfile2(1:namleno2)
                iw1=iw0+1
                call openfile(iw1,0,'(shuffled) RMSD map',19,
     -            'new',analfile2,namleno2,notfnd,0,1,1,0,0)
                call openps(iw1,xm_2d,ym_2d,title(1:76),76,pstitle,
     -            lpstitle,trajnam,ltrajnam,analfile4(1:lanalfile4),
     -            lanalfile4,npspages,ipspage)
                if (ireplot .eq. 1) then
                  call indexit(it3,1,MAX2d,0)
                  call plot2drmsd(nrep,iw0,iw1,xtraj,maxrec,title,
     -              'Frames sorted by clusters',25,trajnam,ltrajnam,
     -              trajnam,0,xtrajlab,11,increment,increment,ncolcode,
     -              maxcolcode,iedit,noopt2d,limresrange,0,rmsdmin,
     -              rmsdmax,absdevmin,absdevmax,rmsdmn,rmsdmx,indexa,
     -              it3,ixshuffle,ixshuffle,indexo,ncl,indexo,ncl,
     -              ym_2d,it1,it2,temp,1,1,noplotdist,0,1,1,ipspage,0)
                end if
                if (ncl .gt. 0)
     -            call clusterplot(iw1,xtraj,value,indexn,indexo,ncl,
     -              ixclst,nframe,trajnam,ltrajnam,xtrajlab,11,ipspage,
     -              ireplotinp,mx2d)
                call indexit(ixshuffle,1,MAX2D,0)
                if (ireplotinp .eq. 1) then
                  call indexit(it3,1,MAX2d,0)
                  call plothead(iw1,xm_2d,ym_2d,title(1:76),76,
     -              'RMSD file read:'//analfile4(1:lanalfile4),
     -              lanalfile4+15,trajnam,ltrajnam,'',0)
                  call plot2drmsd(nrep,iw0,iw1,xtraj,maxrec,title,
     -              'Input RMSD matrix',17,trajnam,ltrajnam,
     -              trajnam,0,xtrajlab,11,increment,increment,ncolcode,
     -              maxcolcode,iedit,noopt2d,limresrange,0,rmsdmin,
     -              rmsdmax,absdevmin,absdevmax,rmsdmn,rmsdmx,indexa,
     -              it3,ixshuffle,ixshuffle,indexo,0,indexo,0,
     -              ym_2d,it1,it2,temp,1,1,noplotdist,0,1,1,ipspage,0)
                end if
              end if
              go to 9005
            end if
            call indexit(iconfsel,1,MAX2D,0)
          else if (ianaltyp .eq. 24) then
c           Cross RMSD
            call getreal(
     -        'MINimum of the RMSD scale (default: actual minimum)',
     -        51,0.0,rmsdmin,1,53)
            if (iread2d .eq. 0) then
              call askyn('Do you want to find matching structures',39,
     -          1,-1,matchconf,0)
              call getreal('MAXimum RMSD for similarity statistics',38,
     -          2.5,rmsdsim,1,86)
              if (rmsdsim .gt. 0) matchconf=1
              pstitle='Cross RMSD map'
              lpstitle=14
              npspages=2
              call indexit(iconfsel,1,MAX2D,0)
            else
c             Read RMSD maps and try to match them
              notfnd=1
              do while (notfnd .gt. 0)
                call getname(analfile4,namlen4,
     -            'Name of .rd2 file from the first trajectory',43,
     -             200,0)
                call openfile(iw4,0,'previously written .rd2',23,
     -            'old',analfile4,namlen4,notfnd,0,1,1,0,0)
              end do
              write (iw0,2064) analfile4(1:namlen4)
              call read_2drmsd(iw4,system,lsystem,trajnam1,ltrajnam1,
     -          trajnam2,ltrajnam2x,1,rmsdmn,rmsdmx,nframe1,nframex,
     -          nframey,ietotsaved,0,limresrange)
              close (iw4)
c             Run clustering
              write (6,2107) 'Clustering results',analfile(1:namleno)
              call indexit(index2d1,1,MAX2D,0)
              call indexit(ixclst,1,MAX2D,0)
              call clusterdistr(nframe1,iw0,rmsdlim,rmsdmn,rmsdmx,
     -          nhbdist,it1,it2,it3,itemp4,ifclst1,ilclst1,ncl1,indexa,
     -          index2d1,ixclst,it4,value,ifa_s,ila_s,ih,cv,0.0,
     -          rdclust,res(1,1,11),ietotsaved,'RMSD',4,1,1,irepav,
     -          irepmx,irepeng,irepkm,engcl,c,chn,c2,1,27,iclstyp,iwt,0,
     -          label2d,80,0,1,1,1,igl,mx2d,maxframe)
              call trnsfi(irepmx1,irepmx,MAX2D)
              call trnsfi(ixshuffle,index2d1,MAX2D)
              call countsim(ifclst1,ilclst1,index2d1,ncl1,rdclust,
     -          rmsdsim1,nsimclst1,iw0,mx2d)
              namlen4=0
              notfnd=1
              do while (notfnd .gt. 0)
                call getname(analfile4,namlen4,
     -            'Name of .rd2 file from the second trajectory',44,
     -             200,0)
                call openfile(iw4,0,'previously written .rd2',23,
     -            'old',analfile4,namlen4,notfnd,0,1,1,0,0)
              end do
              write (iw0,2064) analfile4(1:namlen4)
              call read_2drmsd(iw4,system,lsystem,trajnam2,ltrajnam2,
     -          trajnam2,ltrajnam2x,1,rmsdmn,rmsdmx,nframe2,
     -          nframex,nframey,ietotsaved2,0,limresrange)
              close (iw4)
c             Run clustering
              call indexit(index2d2,1,MAX2D,0)
              call indexit(ixclst,1,MAX2D,0)
              call clusterdistr(nframe2,iw0,rmsdlim,rmsdmn,rmsdmx,
     -          nhbdist,it1,it2,it3,itemp4,ifclst2,ilclst2,ncl2,indexa,
     -          index2d2,ixclst,it4,value,ifa_s,ila_s,ih,cv,0.0,
     -          rdclust,res(1,1,11),ietotsaved,'RMSD',4,1,1,irepav,
     -          irepmx,irepeng,irepkm,engcl,c,chn,c2,1,27,iclstyp,iwt,0,
     -          label2d,80,0,1,1,1,igl,mx2d,maxframe)
              call trnsfi(irepmx2,irepmx,MAX2D)
              call trnsfi(ixshuffleref,index2d2,MAX2D)
              call countsim(ifclst2,ilclst2,index2d2,ncl2,rmsdsim1,
     -          rmsdsim2,nsimclst2,iw0,mx2d)
              namlen4=0
              notfnd=1
              do while (notfnd .gt. 0)
                call getname(analfile4,namlen4,
     -            'Name of the previously written .rdx file',40,200,0)
                analfile=inpfile
                analfile(namleni+1:namleni+4)='.rdx'
                call openfile(iw4,0,'previously written .rdx',23,
     -            'old',analfile4,namlen4,notfnd,0,1,1,0,0)
                extnam2='    '
              end do
              call read_2drmsd(iw4,system,lsystem,trajnamr1,ltrajnamr1,
     -          trajnamr2,ltrajnamr2,0,rmsdmn,rmsdmx,nframe2x,nframex,
     -          nframey,ietotsaved,0,limresrange)
              nframe=nframex
              nframeref=nframey
              write (iw0,2064) analfile4(1:namlen4)
              nerr=0
              if (trajnamr1(1:ltrajnamr1) .ne. trajnam1(1:ltrajnam1))
     -            then
                write (6,2063) 'first',trajnamr1(1:ltrajnamr1),
     -            trajnam1(1:ltrajnam1)
                nerr=nerr+1
              end if
              if (trajnamr2(1:ltrajnamr2) .ne. trajnam2(1:ltrajnam2))
     -            then
                write (6,2063) 'second',trajnamr2(1:ltrajnamr2),
     -            trajnam2(1:ltrajnam2)
                nerr=nerr+1
              end if
              if (nframex .ne. nframe1 .or. nframey .ne. nframe2) then
                write (6,2106) nframex,nframey,nframe1,nframe2
                nerr=nerr+1
              end if
              if (nerr .gt. 0) call askstop(1)
              call askyn(
     -          'Do you want a cross-RMSD map rearranged by clusters',
     -            51,1,1,ireplot,0)
              if (ireplot .eq. 1) then
c               Generate plot file name
                call getint(askcolcode,24,maxcolcode,1,maxcolcode,
     -            ncolcode,95)
                pstitle='Cluster-ordered cross RMSD map'
                lpstitle=30
                npspages=2
                analfile2=analfile
                analfile2(namleni-2:namleni+6)='rdx_sh.ps'
                namleno2=namleni+6
                write (6,2107) pstitle(1:lpstitle),analfile2(1:namleno2)
                iw1=iw0+1
                call openfile(iw1,0,'shuffled cross-RMSD map',23,
     -            'new',analfile2,namleno2,notfnd,0,1,1,0,0)
                call openps(iw1,xm_2d,ym_2d,title(1:76),76,pstitle,
     -            lpstitle,trajnam,ltrajnam,trajnam2,ltrajnam2,npspages,
     -            ipspage)
                call plot2drmsd(nrep,iw0,iw1,xtraj,maxrec,title,
     -            'Frames sorted by clusters',25,trajnamr1,ltrajnamr1,
     -            trajnamr2,ltrajnamr2,xtrajlab,11,increment,increment,
     -            ncolcode,maxcolcode,iedit,noopt2d,limresrange,0,
     -            rmsdmin,rmsdmax,absdevmin,absdevmax,rmsdmn,rmsdmx,
     -            indexa,iconfsel,ixshuffle,ixshuffleref,ilclst1,ncl1,
     -            ilclst2,ncl2,ym_2d,it1,it2,temp,1,0,noplotdist,0,1,1,
     -            ipspage,0)
                call indexit(ixshuffle,1,MAX2D,0)
              end if
              call countsimx(ifclst1,ilclst1,index2d1,ncl1,
     -          ifclst2,ilclst2,index2d2,ncl2,rmsdsim1,iw0,mx2d)
              write (iw0,*)
              call getreal('Maximum RMSD for mapping',24,rmsdsim1,
     -          rmsdmapmax,1,87)
              call mapclustx(2,ifclst1,ilclst1,irepmx1,ncl1,
     -          ifclst2,ilclst2,index2d2,ncl2,it1,it2,
     -          rmsdmapmax,nframe2,trajnam1,ltrajnam1,
     -          trajnam2,ltrajnam2,iw0,mx2d)
              write (iw0,*)
              call mapclustx(1,ifclst2,ilclst2,irepmx2,ncl2,
     -          ifclst1,ilclst1,index2d1,ncl1,it1,it2,
     -          rmsdmapmax,nframe1,trajnam1,ltrajnam1,
     -          trajnam2,ltrajnam2,iw0,mx2d)
              go to 9005
            end if
          end if
          if (iread2d .eq. 0 .and. ianaltyp .gt. 22) write (6,2075)
     -        'RMSD',analfile(1:namleno),analfile1(1:namleno1)
        else if (ianaltyp .eq. 25) then
c         Residue correlation matrix calculation
9185      call getrange(ifrcorr,1,ilrcorr,ixres(nslt),incrres,1,
     -      'residue to calculate correlation and covariance map',51,
     -       numres,0)
          if ((ilrcorr-ifrcorr+1)/incrres+1 .gt. maxrcorr) then
            write (6,2096) maxrcorr,maxrcorr
            go to 9185
          end if
          iucorrmat=0
          call askyn(
     -      'Do you also want to calculate eigenvalues, eigenvectors',
     -      55,1,-1,ieig,125)
          if (ieig .eq. 1) iucorrmat=46
          call askyn('Do you also want to plot the covariance matrix',
     -      46,1,-1,icovmatplot,0)
          call modrepats
          ncorr=0
          do ir=ifrcorr,ilrcorr,incrres
            ncorr=ncorr+1
            indexs(ncorr)=ir
            call findat(indexa(ncorr),ifres(ir),ilres(ir),line,index,
     -        irescol1,inamcol1,MAXREC)
          end do
          ncolcode=0
          pstitle=' '
          lpstitle=0
          npspages=2
          ym=800.0
          write (iw0,*) 'Residue covariance and correlation matrix ',
     -     'calculation over a trajectory'
        else if (ianaltyp .eq. 35) then
c         Input covariance matrix to get eigenvectors, eigenvalues
          call askyn('Is the covariance matrix file binary',36,1,-1,
     -      ibin,000)
          if (ibin .eq. 0) then
            call askyn('Is the matrix broken into 5 numbers/line',40,
     -        1,-1,i5num,000)
            iformcov=2+i5num
          else
            iformcov=1
          end if
          iw0=40
          iw1=iw0+1
          notfound=1
          do while (notfound .gt. 0)
            call openfile(iw1,0,'input',5,'old',analfile1,lanalfile1,
     -        notfound,0,ibin+1,1,0,0)
            if (notfound .eq. 1) lanalfile1=0
          end do
          call openfile(iw0,0,'output',6,'new',analfile,lanalfile,
     -      notfoundout,0,1,1,0,0)
          if (notfoundout .gt. 0) return
          call askyn('Do you want annotated output',28,1,1,iannout,128)
          call normalmodes(ncorr,iw1,trajnam,ltrajnam,0,iformcov,iw0,
     -      iannout,ierr,index2d,value,ifa_s,ila_s,it1,rmsdlim,MAXBONDS)
          if (ierr .gt. 0) return
          go to 9005
        else if (ianaltyp .eq. 26) then
c         Atom-atom distance distribution calculation
          write (iw0,2028)
          call askyn(
     -      'Do you want to calculate distances between atom clusters',
     -      56,1,-1,iclusterdist,105)
          if (iclusterdist .eq. 0) then
            write (6,2028) ' Enter atom pair indices'
            call getlist(listpairdist,npairs,1,nslt,2,MAXDDISTR)
          else
            call getclusterpairs(npairs,iclustermem,ifstclst1,ifstclst2,
     -        ilstclst2,nslt,0,MAXDDISTR,MAXCDLIST)
          end if
          call zeroit(pairdistsum,npairs)
          call zeroit(pairdistwsum,2*npairs)
          call zeroit(pairdistsum2,npairs)
          call zeroiti(npairdist,0,10*npairs)
          call getreal('Maximum distance to calculate distribution',42,
     -      10.0,rmaxpair,1,65)
          pairgrid=rmaxpair/float(MAXDDBIN)
          do ip=1,npairs
            pairdistminmax(1,ip)=10000.0
            pairdistminmax(2,ip)=-pairdistminmax(1,ip)
          end do
        else if (ianaltyp .eq. 39) then
c         Atom-atom distance SD calculation
          write (iw0,2119)
          write (6,2019) 'Atom-atom distances and SDs',
     -      analfile(1:namleno)
          call select(line,nrecdel,idcol,asterisk,n,nslt,index,
     -      ixres,is1,is2,iseqncol1,iseqncol2,inamcol1,inamcol2,
     -      irescol1,irescol2,iqcol1,iqcol2,charge,iatnum,
     -      nneig,ineig,indexdel,6,igl,maxng,maxrec)
c           indexdel: 0 for atoms to use, 1 for the rest
          call masktolist(ianchor,indexdel,nslt,nanchor,0)
          call quiz(ans,isdtyp,'n',' ',0,'SD normalization',16,0,5,6,
     -        igl,0)
          xm_2d=600.0
          ym_2d=775.0
          pstitle='Atom-Atom distance SD plot'
          lpstitle=26
          call openps(iw1,xm_2d,ym_2d,title(1:76),76,pstitle,
     -      lpstitle,trajnam,ltrajnam,' ',0,npspages,ipspage)
        else if (ianaltyp .eq. 27) then
c         Solvation shell volume calculation
          call getreal('Solvent radius',14,1.4,rsolv,1,0)
          nranddef=20000*(rsolv/1.4)**2
          call getint('Number of random points for volume calculation',
     -      46,nranddef,1,0,nrand,33)
          write (iw0,2025) rsolv,nrand
          levout=0
          call getint('Print level',11,0,0,0,levout,0)
          nframetotmin=10
          write (6,2019) 'Calculated volumes',analfile(1:namleno)
          if (itraj .eq. 1) write (6,2019) analfile1(1:namleno1)
        else if (ianaltyp .eq. 28) then
c         Principal axis calculation
          print *,'Select atoms for principal axis calculation'
          call select(line,nrecdel,idcol,asterisk,n,nslt,index,ixres,
     -      is1,is2,iseqncol1,iseqncol2,inamcol1,inamcol2,irescol1,
     -      irescol2,iqcol1,iqcol2,charge,iatnum,nneig,ineig,indexdel,
     -      0,igl,maxng,maxrec)
          call masktolist(indexa,indexdel,n,natspax,0)
          write (6,2099)
          ic=44
          call condenselist(indexa,natspax,ic,6)
          write (iw0,2099)
          ic=44
          call condenselist(indexa,natspax,ic,iw0)
          write (6,2097) analfile(1:namleno)
          if (itraj .eq. 1) then
            write (6,2098)
            call askyn('Do you want to use the input structure instead',
     -        46,1,-1,inputref,0)
            xm=800.0
            ym=500.0
            write (6,2019) 'Evolution and distribution plots',
     -        analfile1(1:namleno1)
c           pstitle='Principal axis evolution'
c           lpstitle=24
          end if
        else if (ianaltyp .eq. 29) then
c         Radius of gyration, hydrodynamic radius, com, dipole moment
          print *,'Select the atoms for the calculation'
          call select(line,nrecdel,idcol,asterisk,n,nslt,index,ixres,
     -      is1,is2,iseqncol1,iseqncol2,inamcol1,inamcol2,
     -      irescol1,irescol2,iqcol1,iqcol2,charge,iatnum,nneig,ineig,
     -      indexdel,0,igl,MAXNEIG,MAXREC)
          call masktolist(indexa,indexdel,n,ngyrats,0)
          write (6,2100)
          ic=12
          call condenselist(indexa,ngyrats,ic,6)
          write (6,2107) analfile(1:namleno)
          if (itraj .eq. 1) then
            xm=800.0
            ym=500.0
            write (6,2019) 'Evolution and distribution plots',
     -        analfile1(1:namleno1)
c           pstitle='Gyration and hydrodynamic radii evolution'
c           lpstitle=41
          end if
          write (iw0,2100)
          ic=12
          call condenselist(indexa,ngyrats,ic,iw0)
        else if (ianaltyp .eq. 30) then
c         Summarize Amber energy partitioning table
          write (6,2019) 'Extracted tables and calculated correlations',
     -       analfile(1:namleno)
          namlenstatfile=0
          call openfile(20,0,'statistics',10,'old',inpstatfile,
     -      namlenstatfile,notfnd,0,1,1,0,0)
          call summarize_amber(20,iw0,itemp1,itemp2,temp,cv,itemp3,
     -      itemp4,resnames,nrescol,temp,cv,indexn,indexa,maxrsd,maxrec)
          go to 9005
        else
          write (6,2041) analtyp
          go to 9002
        end if
c         pstitle='Principal axis calculation'
c         lpstitle=26
c!!       Early openps and landscape conflict!
        if (iw0 .gt. 0 .and. ianaltyp .ne. 35) then
          if (title(1:4) .ne. '@#$%') write (iw0,2014) mark0(1:lmark0),
     -      mark0(1:lmark0),mark0(1:lmark0),title(1:ltitle)
          if (itraj .eq. 0) write (iw0,2006)
     -      mark0(1:lmark0),'Structure',inpfile(1:namleni)
          if (itraj .eq. 1) write (iw0,2118) inpfile(1:namleni)
        end if
        if (ianaltyp .ne. 29 .and. ianaltyp .ne. 35) then
          if (iw1 .gt. 0 .and.  extnam2 .ne. '.ps') then
            if (title(1:4) .ne. '@#$%') write (iw1,2014)mark1(1:lmark1),
     -        mark1(1:lmark1),mark1(1:lmark1),title(1:ltitle)
            if (itraj .eq. 0) write (iw1,2006)
     -        mark1(1:lmark1),'Structure',inpfile(1:namleni)
            if (itraj .eq. 1) write (iw1,2118) inpfile(1:namleni)
          end if
          if (iw2 .gt. 0 .and. ianaltyp .ne. 22) then
            if( analfile2(namleno2-2:namleno2) .ne. '.ps ') then
              if (title(1:4) .ne. '@#$%')
     -          write (iw2,2014)mark2(1:lmark2), mark2(1:lmark2),
     -            mark2(1:lmark2),title(1:ltitle)
              if (itraj .eq. 0) write (iw2,2006)
     -          mark2(1:lmark2),'Structure',inpfile(1:namleni)
              if (itraj .eq. 1) write (iw2,2118) inpfile(1:namleni)
            end if
          end if
        end if
      else
c       nconfig > 1
        if (iw0 .gt. 0) write (iw0,2055) nconfig,nconfig
        if (iw1 .gt. 0) write (iw1,2055) nconfi,nconfigg
        itraj=0
      end if
      if (iaskcolcode .eq. 1)
     -  call getint(askcolcode,24,maxcolcode,1,maxcolcode,ncolcode,95)
3001  if (itraj .eq. 0) then
c       Analysis of single conformations
        if (ianaltyp .eq.  1) then
c---------(S) Neighbor, bond, angle and torsion list
          call printbondlist(iangpr,itorpr,1,nslt,nslt,c,nneig,ineig,
     -      line,inamcol1,inamcol2,irescol1,irescol2,iresncol1,
     -      iresncol2,index,cv,indexa,maxng,radtodeg,iw0,maxrec)
        else if (ianaltyp .eq.  2) then
c---------(S) 1-4 statistics
          call stat14(c,n,nneig,ineig,index,line,nconfig,pi,iatnm2,
     -      irescol1,irescol2,inamcol1,inamcol2,inpcrdtyp,ioins,iw0,
     -      maxrepconf,maxng,maxrec)
        else if (ianaltyp .eq.  3) then
C---------(S) Functional group analysis, backbone plot
          call findfg(1,n,iatnum,mmtype,indexo,indexn,nhbneig,ih,ifgtyp,
     -      ibnd,nfg,6,nneig,nhneig,nneiga,ineig,iw0,inpcrdtyp,ioins,
     -      inamcol1,inamcol2,irescol1,irescol2,iresncol1,iresncol2,
     -      line,index,maxng,maxrec)
          call findbackbone(1,nslt,iw1,nneig,ineig,nneiga,
     -      ibnd,inamcol1,inamcol2,irescol1,irescol2,line,blankline,
     -      index,indexn,indexo,indexs,ifree,maxng,maxbox,maxrec)
        else if (ianaltyp .eq.  4) then
c---------(S) Bond length statistics
          call bondlenstat(c,n,iatnum,nneig,ineig,iatnm2,nconfig,
     -      nanos,ixlist,ialist,iw0,inpcrdtyp,ioins,inamcol1,inamcol2,
     -      irescol1,irescol2,line,index,radtodeg,maxrepconf,maxng,
     -      maxrec)
        else if (ianaltyp .eq.  5) then
c---------(S) Hydrogen-bond list
          call hblist(c,n,nslt,islvw,naslv,iatnum,ifchrg,isegno,nneig,
     -      nneiga,nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,
     -      ixres,nconfig,hbf0,angm0,molresflag,hblimfac,angmin,
     -      iw0,inamcol1,inamcol2,irescol1,irescol2,iresncol1,
     -      iresncol2,blankline,line,index,indexn,ibnd,indexo,isolvent,
     -      1,0,nosamseg,radtodeg,maxrepconf,maxng,maxbox,maxrsd,maxrec)
C@GL          call displaymol(idmol,idaxes,c,c2,n,nslt,iatnum,nneig,ineig,
C@GL     -      nhneig,nhbneig,isegno,isc,inpfile,namleni,icg,centgra,
C@GL     -      nconfig,maxng)
          if (ireorient .gt. 0) call zeroit(centgra,3)
        else if (ianaltyp .eq.  6 .or. ianaltyp .eq. 34) then
c---------(S) Hydrophobic bond or heavy atom contact list
          call nnlisthph_sltb(nslt,ianchor2,iselfanc,indexa,iatnum,
     -      nneig,npneig,nhbneig,ineig,c,rhphmax,0,isegno,nosamseg,ibnd,
     -      indexo,ifail,maxng,maxng,maxrec)
          call hph_sltblist(c,nslt,nhbneig,ineig,iw0,inamcol1,inamcol2,
     -      irescol1,irescol2,iresncol1,iresncol2,line,index,'C-C',3,
     -      maxng)
        else if (ianaltyp .eq.  7) then
c---------(S) Salt bridge list
          call nnlisthph_sltb(nslt,ianchor2,iselfanc,indexa,iatnum,
     -      nneig,npneig,nhbneig,ineig,c,rsltbmax,1,isegno,nosamseg,
     -      ibnd,indexo,ifail,maxng,maxng,maxrec)
          call hph_sltblist(c,nslt,nhbneig,ineig,iw0,
     -      inamcol1,inamcol2,irescol1,irescol2,iresncol1,iresncol2,
     -      line,index,'+..-',4,maxng)
        else if (ianaltyp .eq.  8) then
c---------(S) Calculate residue-residue distances
          call rrdist(c,n,nres,ixresno,iresno,ixres,resnames,ifres,
     -      ilres,increst,incsolvrr,irefres1,irefres2,irefseg1,irefseg2,
     -      irefresinc,resdistlim,inegres1,inegres2,inegseg1,inegseg2,
     -      inegresinc,resapplim,listrefres,nrefres,nrefrange,l
     -      istnegres,nnegres,nnegrange,iatnum,ignoreh,0,0,iw0,iw1,iw2,
     -      irescol1,irescol2,inamcol1,inamcol2,is1,is2,irescount1,
     -      irescount2,irescount3,line,index,indexn,indexo,indexs,
     -      indexa,itemp1,itemp2,temp,cv,maxrec,maxrsd)
        else if (ianaltyp .eq.  33) then
c---------(S) Calculate molecule-molecule distance matrix
            call mmdist(c,n,atw,iatnum,nmolslt,molsltlim,c2,temp,
     -        ignoreh,iw0,iw1)
        else if (ianaltyp .eq. 31) then
c---------(S) Calculate adjacency-matrix based analysis
          call rrconn(c,n,ires1,ires2,ifres,ilres,iatnum,ignoreh,
     -      irepuse,iadjtyp,iscalesum,resdistlim,nexpmax,npint,ipspage,
     -      npspages,iw0,iw1,line,index,irescol1,inamcol1,
     -      imarkres,marks,itemp4,itemp1,itemp2,itemp3,
     -      temp,inpfile,namleni,analfile4,namleno4,maxrec)
        else if (ianaltyp .eq.  9) then
c---------(S) Calculate a distance
          call pbcdist(c(1,ia1),c(1,ia2),ia1,ia2,cell,ncell,0,0,
     -      img,dr,d)
        else if (ianaltyp .eq. 10) then
c---------(S) Check for potentially unphysical contacts
          call checkunphys(c,nslt,n,naslv,islvw,iatnum,ifchrg,isegno,
     -      idelseg,indexo,nneig,nneiga,nhbneig,ineig,nhneig,nnneig,
     -      ncneig,nsneig,npneig,ixres,line,irescol1,irescol2,inamcol1,
     -      inamcol2,index,nconfig,innlist,molresflag,ioppbc,cell,ncell,
     -      edge,ixyzhex,molsltlim,nmolslt,hblimfac,angmin,ctfac,
     -      bondminfac,maxdist,iles,iw0,isltonly,ibnd,indexn,rlim,
     -      radtodeg,nerrunphys,maxrepconf,maxng,maxbox,maxrsd,maxrec)
          if (nerrunphys .eq. 0) write (6,*) 'Nothing untoward detected'
        else if (ianaltyp .eq. 11) then
c---------(S) Pseudorotation angle calculation
          write (6,2078)
          nmem=5
          do while (.true.)
            call getring(line,index,ix5,irescol1,irescol2,inamcol1,
     -        inamcol2,nslt,numres,iresring,iresno,ifres,ilres,nmem,
     -        psrtyp,0,incgen,iapex,igl,MAXRING,maxrec)
            if (nmem .eq. 0) go to 9001
            call pseudorot(c,n,ix5,nmem,nneig,ineig,psr5,psr,npsr,
     -        psrtyp,incgen,zring,rring,sinpsrs,cospsrs,qpsr,qpsrs,
     -        qpsr2s,zav,zsq,zavs,zsqs,1,6,0,radtodeg,maxng,maxrec)
            print *
          end do
        else if (ianaltyp .eq. 12) then
c---------(S) Calculate Proline kinks
          if (noprol .eq. 0)
     -      call pseudorot(c,n,ix5,nmem,nneig,ineig,psr5,psr,npsr,'p',
     -        incgen,zring,rring,sinpsrs,cospsrs,qpsr,qpsrs,qpsr2s,
     -        zav,zsq,zavs,zsqs,1,6,0,radtodeg,maxng,maxrec)
          if (nconfig .gt. 2) iprintpk=0
          call prokinkcalcla(1,c,nslt,bend,wobble,faceshift,
     -      rmsb,rmsa,
C@GL     -      nconfig,inpfile,namleni,noprol,
     -      iflatproline,ix5,radtodeg,MAXHX)
          if (noprol .eq. 0)
     -      call pseudorot(c,n,ix5,nmem,nneig,ineig,psr5,psr,npsr,'p',
     -        incgen,zring,rring,sinpsrs,cospsrs,qpsr,qpsrs,qpsr2s,
     -        zav,zsq,zavs,zsqs,0,6,0,radtodeg,maxng,maxrec)
          write (iw0,2072) nconfig,bend,wobble,faceshift,
     -      wobble-faceshift,psr(2),rmsb,rmsa
        else if (ianaltyp .eq. 13) then
c---------(S) Hydropathy labeling
          call hydropathylist(n,nslt,ixres,resnames,cv,ihydtyp,igl,
     -      maxrsd,maxrec)
          call writeconf(iw0,inpcrdtyp,inpcrdtyp,inpcrdtyporg,n,n,nslt,
     -      naslv,islvw,iasv,namesv,qsv,pflsv,1,iwhead,0,iatnum,ifchrg,
     -      nconfig,innlist,c,rprox,cv,ixres,iresno,atnames,resnames,
     -      segnames,charge,isegno,marker,ntitlin,ntitlinw,title,ireseq,
     -      iresnrestart,iresidrestart,nneig,nneiga,nhbneig,ineig,
     -      nhneig,nnneig,ncneig,nsneig,npneig,numres,numslv,resnamslv,
     -      line,blankline,mmtype,ibnd,index,indexn,indexo,1,molresflag,
     -      irescount3,hblimfac,angmin,0,1,1,1,0,2,iqspaceask,13,0,0.0,
     -      0,0,0,keeprem,iwriteatsym,radtodeg,maxrepconf,maxng,maxrsd,
     -      maxrec)
        else if (ianaltyp .eq. 14) then
c---------(S) Circular variance labeling of solute atoms and solvent molecules
          call cvlist(c,n,nslt,nsltref_f,nsltref_l,naslv,islvrep,icvtyp,
     -      rcut_cv,rprox,cv,itemp1,c2,temp,indexn,indexo,indexs,chn,
     -      isortslv,cvlim)
          call writeconf(iw0,inpcrdtyp,inpcrdtyp,inpcrdtyporg,n,n,nslt,
     -      naslv,islvw,iasv,namesv,qsv,pflsv,1,iwhead,0,iatnum,ifchrg,
     -      nconfig,innlist,c,rprox,cv,ixres,iresno,atnames,resnames,
     -      segnames,charge,isegno,marker,ntitlin,ntitlinw,title,ireseq,
     -      iresnrestart,iresidrestart,nneig,nneiga,nhbneig,ineig,
     -      nhneig,nnneig,ncneig,nsneig,npneig,numres,numslv,resnamslv,
     -      line,blankline,mmtype,ibnd,index,indexn,indexo,1,molresflag,
     -      irescount3,hblimfac,angmin,0,1,1,1,0,3,iqspaceask,14,0,0.0,
     -      0,0,0,keeprem,iwriteatsym,radtodeg,maxrepconf,maxng,maxrsd,
     -      maxrec)
        else if (ianaltyp .eq. 15) then
c---------(S) Circular varience residue-residue plot
          call cvplot(c,n,nslt,icvtyp,line,index,indexs,inamcol1,
     -      inamcol2,iresncol1,iresncol2,'CA      ',title,ltitle,
     -      ncolcode,maxcolcode,iw0,iw1,1,maxrec,ipspage)
        else if (ianaltyp .eq. 16) then
c---------(S) DSSP secondary structure assignment
          call dssp(c,1,n,nslt,line,index,inamcol1,inamcol2,iresncol1,
     -      iresncol2,nneig,ineig,nneiga,ibnd,indexn,indexo,npneig,
     -      nsneig,nnneig,dssplab,idistdssp,chn,c2,cv,indexs,indexa,
     -      nsse,itypsse,ifsse,ilsse,nconfig,iw0,0,1,ifail,radtodeg,
     -      maxrepconf,maxng*10,maxrec/10,maxng*20,maxrec/20,200,
     -      maxrsd,maxrec)
        else if (ianaltyp .eq. 17) then
c---------(S) Hydrogen-bond bridge analysis
          call hblist(c,n,nslt,islvw,naslv,iatnum,ifchrg,isegno,nneig,
     -      nneiga,nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,
     -      ixres,nframe,hbf0,angm0,molresflag,hblimfac,angmin,
     -      iw0,inamcol1,inamcol2,irescol1,irescol2,iresncol1,
     -      iresncol2,blankline,line,index,indexn,ibnd,indexo,1,0,1,
     -      nosamseg,radtodeg,maxrepconf,maxng,maxbox,maxrsd,maxrec)
          call hbbridge(nanchor,ianchor,indexa,ianchor2,iqfsel2,lpath,
     -      nbridgetype,ibridgetype,maxbridgemem,n,nhbneig,ineig,indexn,
     -      indexo,indexs,ixres,resnames,brslv,nabr,nrescol,0,ifail,
     -      listbridge,iw0,maxng,MAXBRIDGELEN,MAXBRIDGETYPE,
     -      minbridgelenprint,maxrsd,maxrec)
          call hbbridgeprint(nanchor,ianchor,lpath,nbridgetype,
     -      ibridgetype,maxbridgemem,line,index,iresno,inamcol1,
     -      inamcol2,irescol1,irescol2,hblimfac,angmin,inpfile,namleni,
     -      iw0,qmin,iqfsel2,brslv,nrescol,maxbondcount,maxhbtype,
     -      minbridgelenprint,0,1,MAXBRIDGELEN,MAXBRIDGETYPE,maxrec)
        else if (ianaltyp .eq. 18) then
c---------(S) Ramachandran plot
          call ramachandran(c,nslt,index,line,nconfig,pi,nresfound,
     -      iresno,ixres,irescol1,irescol2,inamcol1,iw0,
     -      maxng,maxrec)
          call ramachandranplot(nresfound,iw1,xm,iallrama)
        else if (ianaltyp .eq. 32) then
c---------(S) Angle dial plots
          call angledials(c,nslt,nangsel,ixtor1234,index,line,pi,
     -      irescol1,irescol2,inamcol1,inamcol2,iw0,maxrec)
        else if (ianaltyp .eq. 19) then
c---------(S) Torsion dial plots
          call torsiondials(c,nslt,ntorsel,ixtor1234,index,line,pi,
     -      irescol1,irescol2,inamcol1,inamcol2,iw0,maxrec)
        else if (ianaltyp .eq. 20) then
c---------(S) Delphi map annotation
          call delphilabel(c,n,nslt,xstart,ystart,zstart,gx,gy,gz,cv)
          call writeconf(iw0,inpcrdtyp,inpcrdtyp,inpcrdtyporg,n,n,nslt,
     -      naslv,islvw,iasv,namesv,qsv,pflsv,1,iwhead,0,iatnum,ifchrg,
     -      nconfig,innlist,c,rprox,cv,ixres,iresno,atnames,resnames,
     -      segnames,charge,isegno,marker,ntitlin,ntitlinw,title,ireseq,
     -      iresnrestart,iresidrestart,nneig,nneiga,nhbneig,ineig,
     -      nhneig,nnneig,ncneig,nsneig,npneig,numres,numslv,resnamslv,
     -      line,blankline,mmtype,ibnd,index,indexn,indexo,1,molresflag,
     -      irescount3,hblimfac,angmin,0,1,1,1,0,0,iqspaceask,20,0,0.0,
     -      0,0,0,keeprem,iwriteatsym,radtodeg,maxrepconf,maxng,maxrsd,
     -      maxrec)
        else if (ianaltyp .eq. 21) then
c---------(S) Helix axis directions
          do ihx=1,nhx
            call helixaxis(c,nslt,iw0,calph(1,1,ihx),axisdir(1,ihx),
     -        axisini(1,ihx),axisend(1,ihx),helixcent(1,ihx),
     -        perpvec(1,1,ihx),camod(1,1,ihx),anglechangeref(1,ihx),
     -        circ(1,ihx),rnorm(1,ihx),axfact(1,ihx),axtol,rot,rms,
     -        helixlen(ihx),angles(1,ihx),decidebend,nup,ndown,nrun,
     -        nnear,rcirc(ihx),turnperres(ihx),anglesn(1,ihx),0,incrot,
     -        nrep,0,nreshx(ihx),icaahx(1,ihx),ihx,nhxres,igl,idebughx,
     -        radtodeg,pi,MAXHX)
          end do
        else if (ianaltyp .eq. 26) then
c---------(S) Distance calculation
          if (iclusterdist .eq. 0) then
            call pairdistcalc(c,nslt,npairs,listpairdist,pairdistsum,
     -        pairdistsum2,pairdistwsum,npairdist,pairdistminmax,
     -        pairgrid,iw0,MAXDDBIN,MAXDDISTR)
          else
            call clusterdistcalc(c,nslt,npairs,iclustermem,
     -        ifstclst1,ifstclst2,ilstclst2,pairdistsum,pairdistsum2,
     -        pairdistwsum,npairdist,pairdistminmax,pairgrid,
     -        iw0,MAXDDBIN,MAXDDISTR,MAXCDLIST)
          end if
          call pairdistprint(nframe,npairs,listpairdist,iclusterdist,
     -      iclustermem,ifstclst1,ifstclst2,ilstclst2,pairdistsum,
     -      pairdistsum2,pairdistwsum,npairdist,pairdistminmax,
     -      pairgrid,rmaxpair,line,index,inamcol1,inamcol2,irescol1,
     -      irescol2,inpcrdtyp,ioins,iw0,nslt,MAXDDBIN,MAXDDISTR,
     -      MAXCDLIST,maxrec)
        else if (ianaltyp .eq. 27) then
c---------(S) Solvation shell volume calculation
          call volcalc(nrand,c,nslt,isegno,iatnum,nsegslt,cv,cres,chn,
     -      c2,atw,vmac,vshell,vint,vmacsd,vshellsd,vintsd,vfrstsh,
     -      vfrstshsd,rsolv,ih,indexn,indexo,indexs,indexa,1,iw0,levout,
     -      maxrec)
        else if (ianaltyp .eq. 28) then
c---------(S) Principal axis calculation
          call princax(c,c2,atw,temp,n,indexdel,evecs0,evals0,iw0,0,0,
     -      radtodeg,0)
        else if (ianaltyp .eq. 29) then
c---------(S) Radius and dipole calculation
            call molrad(c,indexa,ngyrats,iw0,MACREC)
            call celldipole(c,n,nslt,indexa,ngyrats,charge,icharges,atw,
     -        iw0,1)
        end if
9001    if (nconfig .eq. 1) go to 9005
      else
c       Trajectory scan
c       Open, initialize trajectory
        if (ireadtracks .eq. 0) call asktrajform(inptrajtyp,ioutrajtyp,
     -    mmctrajtyp,resnamslv,igl,-1,1)
        inpt=70
        iverbose=1
        notitprint=0
        iopen_rep=0
      end if
      irepscan=1
      nrepinc=0
      nframeread=0
      if (itraj .eq. 1 .and. ianaltyp .eq. 23) then
c       2D RMSD calculation
        irepscan=0
        ifail=0
        maxconf=999999
        do while (maxconf .gt. mx2d)
          if (maxconf .ne. 999999) write (6,2032) maxconf,mx2d,mx2d
          call opentraj(c,1,inpt,inptrajtyp,n,ntitltr,trtitle,
     -      inpcrdtyp,ifirst,ilast,increment,maxconf,ninconf,noutconf,
     -      natom,nfreeat,ifree,icntrl,0,mmctrajtyp,trajnam,ltrajnam,
     -      'trajectory',10,iconfsel,numsel,iverbose,notitprint,0,0,
     -      icellfound,notfnd,iconfirmname,iopen_rep,iw0,maxconfsel,
     -      maxrec)
        end do
        if (iw0 .gt. 0) write (iw0,2006) mark0(1:lmark0),
     -    'Trajectory',trajnam(1:ltrajnam)
        nframetot=(ilast-ifirst)/increment+1
        nframetot=nframetot*(nframetot-1)/2
        nframesign=nframetot/10
        ncmem=(maxrec10-n)/nslt+1
        write (6,2157) ncmem
        write (iw0,2157) ncmem
        nframe1=0
        nframe2d=0
        ic1=1
        ncop=0
        inpt2=71
        do while (ninconf .lt. ilast .and. ifail .eq. 0)
c         Read a conformation
          call readtraj(inpt,inptrajtyp,mmctrajtyp,n,naslv,nwatr,
     -      nslt,trajformatname(inptrajtyp),ntitltr,trtitle,trajnam,
     -      ltrajnam,natom,nfreeat,ifree,icntrl,c(1,ic1),ninconf,
     -      noutconf,increment,inpcrdtyp,ietotsaved,etot,ifail,ifirst,
     -      ilast,iconfsel,numsel,maxrepconf*irepscan,nmc,1.0,maxconf,
     -      maxconfsel,maxrec)
          icsel=0
          if (ifail .eq. 0) then
            nframeread=nframeread+1
            call selectconf(numsel,ninconf,ifirst,increment,
     -        iconfsel,nextconfsel,nframeref,icsel,ifail,maxconfsel)
          else
            ninconf=ilast
            nframetot=nframe
            if (nframeread .eq. 0) go to 9002
          end if
          if (icsel .eq. 1) then
            ic1=ic1+nslt
            ncop=ncop+1
            it1(ncop)=ninconf
            nframe1=nframe1+1
            res(1,nframe1,11)=etot2
            res(1,nframe1,11)=etot
          end if
          if (ninconf .eq. ilast .or. ncop .eq. ncmem) then
c           Calculate RMSD between the ncop structures in c
            do nc1=1,ncop
              nframe=nframe1-ncop+nc1
              ic1=(nc1-1)*nslt+1
              do nc2=nc1+1,ncop
                ic2=(nc2-1)*nslt+1
                nframeref=nframe1-ncop+nc2
                write (iw0,2055) nframe,it1(nc1),' ',nframeref
                call rmsd(c(1,ic2),c(1,ic1),nslt,nfinalov,nfinalrmsd,
     -            atw,atwsum,temp,chn,c2,indexov,indexov,noopt2d,iedit,
     -            1,limresrange,itemp1,indexrmsd,indexrmsd,rot,com1,
     -            com2,etot,etot2,iw0,devmax,devmaxnoopt,maxrec)
                if (absdevmin .gt. devmax) absdevmin=devmax
                if (absdevmax .lt. devmax) absdevmax=devmax
                nframe2d=nframe2d+1
                call progress_rep(0,nframe2d,nframesign)
              end do
            end do
c           print *,'Self block done nframe1=',nframe1
c           Open same trajectory and skip to nframeread+1
            ifirst=nframeread+1  
            nframe2=nframe1
            call opentraj(cres,0,inpt2,inptrajtyp,n,ntitltr,trtitle,
     -        inpcrdtyp,ifirst,ilast,increment,maxconf,ninconf2,
     -        noutconf,natom,nfreeat,ifree,icntrl,0,mmctrajtyp,trajnam,
     -        ltrajnam,'trajectory',10,iconfsel,numsel,0,
     -        notitprint,0,0,icellfound,notfnd,iconfirmname,iopen_rep,0,
     -        maxconfsel,maxrec)
            notitprint=1
            iopen_rep=1
c           Read blocks into cref and calculate RMSD with the c block
            ic2=1
            ncop2=0
            nframeread2=0
            ifail2=0
            do while (ninconf2 .lt. ilast .and. ifail2 .eq. 0)
c             Read a conformation
              call readtraj(inpt2,inptrajtyp,mmctrajtyp,n,naslv,nwatr,
     -          nslt,trajformatname(inptrajtyp),ntitltr,trtitle,trajnam,
     -          ltrajnam,natom,nfreeat,ifree,icntrl,cres(1,ic2),
     -          ninconf2,noutconf,increment,inpcrdtyp,ietotsaved,etot,
     -          ifail2,ifirst,ilast,iconfsel,numsel,maxrepconf*irepscan,
     -          nmc,1.0,maxconf,maxconfsel,maxrec)
              icsel=0
              if (ifail2 .eq. 0) then
                nframeread2=nframeread2+1
                call selectconf(numsel,ninconf2,ifirst,increment,
     -            iconfsel,nextconfsel,nframeref,icsel,ifail2,
     -            maxconfsel)
              end if
              if (icsel .eq. 1) then
                ic2=ic2+nslt
                ncop2=ncop2+1
                nframe2=nframe2+1
              end if
              if (ninconf2 .eq. ilast .or. ncop2 .eq. ncmem) then
c               RMSD calc between c and cres
                do nc1=1,ncop
                  ic1=(nc1-1)*nslt+1
                  nframe=nframe1-ncop+nc1
                  do nc2=1,ncop2
                    ic2=(nc2-1)*nslt+1
                    nframeref=nframe2-ncop2+nc2
                    write (iw0,2055) nframe,ninconf,' ',nframeref
                    call rmsd(cres(1,ic2),c(1,ic1),nslt,nfinalov,
     -                nfinalrmsd,atw,atwsum,temp,chn,c2,indexov,indexov,
     -                noopt2d,iedit,1,limresrange,itemp1,indexrmsd,
     -                indexrmsd,rot,com1,com2,etot,etot2,iw0,devmax,
     -                devmaxnoopt,maxrec)
                    if (absdevmin .gt. devmax) absdevmin=devmax
                    if (absdevmax .lt. devmax) absdevmax=devmax
                    nframe2d=nframe2d+1
                    call progress_rep(0,nframe2d,nframesign)
                  end do
                end do
c               print *,'Block pair done nframe1,2=',nframe1,nframe2
                ic2=1
                ncop2=0
              end if
            end do  
7000        close(inpt2)
            ic1=1
            ncop=0
          end if
        end do
        nframe=nframe1
        nframeref=nframe2+1
        close (inpt)
        write (iw0,2085)
        write (iw0,2020) trajnam(:ltrajnam),nframeread,nframe,ifirst-1
        if (lpstitle .gt. 0) call openps(iw1,xm,ym,title(1:76),76,
     -    pstitle,lpstitle,trajnam,ltrajnam,trajnam2,ltrajnam2,
     -    npspages,ipspage)
      end if
      if (itraj .eq. 1 .and. ianaltyp .ne. 23) then
        if (ireadtracks .gt. 0) go to 8006
        iopen_rep2=0
9072    nframeref=1
        nextconfsel2=2
        nframe2d=0
        nrep=nrep+1
9111    nframe=0
        nframeread=0
        ifail=0
        if (nrep .gt. 1 .or. nframeref .gt. 1) then
          iverbose=0
          nrepinc=1
        end if
        ninp=n
        separatorchar='_'
9006    call opentraj(c,nrep+nrepinc,inpt,inptrajtyp,n,ntitltr,trtitle,
     -    inpcrdtyp,ifirst,ilast,increment,maxconf,ninconf,noutconf,
     -    natom,nfreeat,ifree,icntrl,0,mmctrajtyp,trajnam,ltrajnam,
     -    'trajectory',10,iconfsel,numsel,iverbose,notitprint,0,0,
     -    icellfound,notfnd,iconfirmname,iopen_rep,iw0,maxconfsel,
     -    maxrec)
        iopen_rep=1
        nerr_int=max0(1,maxconf/MAXDISTRN)
        if (ianaltyp .eq. 24 .and. maxconf .gt. mx2d) then
          write (6,2032) maxconf,mx2d,mx2d
          go to 9006
        end if
        if (numsel .gt. 0) nextconfsel=1
        if (ianaltyp .eq. 16) then
c         Round of the max # of frames for plots
          maxtrajplot=ilast/increment
          call roundlimint(maxtrajplot,idiv,ndivdssp)
          maxtrajplot=idiv*ndivdssp
          print *,'maxtrajplot,idiv,ndivdssp=',
     -      maxtrajplot,idiv,ndivdssp
        else if (ianaltyp .eq. 23 .or. ianaltyp .eq. 24) then
          if (increment .gt.  2 .and. nslt .gt. 200) then
            write (6,2090)
            call askstop(0)
          end if
        end if
        notitprint=1
        if (ntitltr .gt. 0 .and. title(1:4) .eq. '@#$%') then
          title=trtitle(1)
          if (trtitle(1)(1:21) .eq. 'Created by DCD plugin')
     -      title=trtitle(2)
          call lastchar(title,ltitle,80)
        end if
        if (iw0 .gt. 0 .and. nframeref .eq. 1) write (iw0,2006)
     -    mark0(1:lmark0),'Trajectory',trajnam(1:ltrajnam)
        if (n .ne. ninp) then
          write (6,2034) ninp,n
          write (iw0,2034) ninp,n
          if (nrep .eq. 1 .and. nframe .eq. 0 .and. nframeref .eq. 1)
     -      call askstop(1)
        end if
        if (ianaltyp .eq. 24) then
c         Establish 2nd trajectory
          inpt2=80
          write (6,2022)
          call trnsfi(icntrlsave,icntrl,20)
          call opentraj(c,0,inpt2,inptrajtyp,n,ntitltr,trtitle,
     -      inpcrdtyp,ifirst2,ilast2,increment2,maxconf,ninconf2,
     -      noutconf,natom,nfreeat,ifree,icntrl,1,mmctrajtyp,
     -      trajnam2,ltrajnam2,'second trajectory',17,iconfsel2,
     -      numsel2,iverbose,1,0,0,icellfound,notfnd,0,iopen_rep2,0,
     -      maxconfsel,maxrec)
          iopen_rep2=1
          write (iw0,2006) mark0(1:lmark0),'Second trajectory',
     -      trajnam2(1:ltrajnam2)
          if (inptrajtyp .eq. 1 .and. (icntrl(5) .ne. icntrlsave(5)
     -      .or. icntrl(9) .ne. icntrlsave(9)
     -      .or. icntrl(11) .ne. icntrlsave(11))) then
            write (6,2040)
            close (inpt)
            close (inpt2)
            go to 9006
          end if
        end if
        if (nrep .eq. 1 .and. nframe .eq. 0 .and. nframeref .eq. 1)then
c         PS files with trajectory name
          if (lpstitle .gt. 0) call openps(iw1,xm,ym,title(1:76),76,
     -      pstitle,lpstitle,trajnam,ltrajnam,trajnam2,ltrajnam2,
     -      npspages,ipspage)
        end if
        if (nframeref .eq. 1) then
          if (ianaltyp .eq. 16 .and. ilast .eq. 999999) then
            call getint('Last configuration in the trajectory',36,
     -        999999,1,0,ilast,0)
          end if
          nframetot=999999
          if (ilast .ne. 999999) then
            nframetot=(ilast-ifirst)/increment+1
c           if (ianaltyp .eq. 23) nframetot=nframetot*(nframetot-1)/2
            nframesign=nframetot/10
          end if
          if (nframetot .gt. maxframe .and.
     -      (ianaltyp .eq. 12 .or. ianaltyp .eq. 21)) then
            if (ilast .ne. 999999) then
              write (6,2074) maxframe,'structures',' '
              close (inpt)
              return
            else
              write (6,2074) maxframe,'structures',' you may have to '
            end if
          end if
          if (ianaltyp .eq. 23 .and. increment .gt. 10 .and.
     -        ilast .gt. 1000) then
            write (6,2021)
            call askstop(0)
          end if
          if (nrep .le. 1) then
            if (ianaltyp .eq. 21 .or. ianaltyp .eq. 22)
     -         write (iw0,2012) inpfile(1:namleni)
            if (ianaltyp .eq. 21) then
              if (isubcrm+ioverlay .gt. 0) then
                if (ioverlay .eq. 0) write (iw0,2017)
                if (ioverlay .eq. 1) write (iw0,2018) ' '
                if (ioverlay .eq. 2)
     -            write (iw0,2018) ' by molecule'
                atwsum=0.d0
                do ia=1,nslt
                  atw(ia)=aw(iatnum(ia))
                  atwsum=atwsum+atw(ia)
                end do
                if (ioverlay .gt. 1) then
                  do is=1,nsegslt
                    atws(is)=0.0
                    do ia=molsltlim(1,is),molsltlim(2,is)
                      atws(is)=atws(is)+atw(ia)
                    end do
                  end do
                end if
                call cofms(cres,crmslt0,nslt,atw)
              end if
              write (iw0,2085)
              do ihx=1,nhx
                incrhx=(ihx-1)*nhxres
                write (iw0,2010)
                call helixaxis(cres,nslt,iw0,calph0(1,1,ihx),
     -            axisdir0(1,ihx),axisini0(1,ihx),axisend0(1,ihx),
     -            helixcent0(1,ihx),perpvec0(1,1,ihx),camod(1,1,ihx),
     -            anglechangeref(1,ihx),circ(1,ihx),rn0(1,ihx),
     -            axfact(1,ihx),axtol,rot,rms,helixlen0(ihx),
     -            angles(1,ihx),decidebend,nup,ndown,nrun,nnear,
     -            rcirc(ihx),turnperres(ihx),anglesn(1,ihx),0,incrot,
     -            nrep,0,nreshx(ihx),icaahx(1,ihx),ihx,nhxres,igl,
     -            idebughx,radtodeg,pi,MAXHX)
c               Calculate reference turn angles
                do ir=2,(ireshx2(ihx)-ireshx1(ihx)+1)
                  call angcomp(perpvec0(1,ir-1,ihx),axisdir0(1,ihx),
     -              perpvec0(1,ir,ihx),anglechangeref(ir,ihx))
                  if (anglechangeref(ir,ihx) .lt. 0.0)
     -              anglechangeref(ir,ihx)=anglechangeref(ir,ihx)+2.0*pi
                end do
c               Shift the helix so that the start is at the origin
                do ir=1,(ireshx2(ihx)-ireshx1(ihx)+1)
                  call dvdif(calph0(1,ir,ihx),axisini0(1,ihx),
     -            calph0(1,ir,ihx))
                end do
              end do
              if (nhx .gt. 0) then
                call multihelix(iw0,nhx,nhxres,radtodeg)
              end if
            end if
          end if
          write (iw0,2005)
          write (6,2081) maxrepconf
        end if
c       Open, read and analyze trajectory
        nntest=0
cx      print *,'Start scan nmc=',nmc
        ilastframe=0
        do while (ninconf .lt. ilast .and. ifail .eq. 0)
c         Read a conformation
          call readtraj(inpt,inptrajtyp,mmctrajtyp,n,naslv,nwatr,
     -      nslt,trajformatname(inptrajtyp),ntitltr,trtitle,trajnam,
     -      ltrajnam,natom,nfreeat,ifree,icntrl,c,ninconf,
     -      noutconf,increment,inpcrdtyp,ietotsaved,etot,ifail,ifirst,
     -      ilast,iconfsel,numsel,maxrepconf*irepscan,nmc,1.0,maxconf,
     -      maxconfsel,maxrec)
c         if (ianaltyp .eq. 23) irepscan=0
          icsel=0
          if (ifail .eq. 0) then
            nframeread=nframeread+1
            call selectconf(numsel,ninconf,ifirst,increment,
     -        iconfsel,nextconfsel,nframeref,icsel,ifail,maxconfsel)
          else
            ninconf=ilast
            nframetot=nframe
            if (nframeread .eq. 0) go to 9002
          end if
          if (nframe .gt. MAXFRAMES) write (6,2059) MAXFRAMES
          if (icsel .gt. 0) then
            nframe=nframe+1
c           print *,'Selected nmc=',nmc
            if (ianaltyp .eq.  9 .and. ioppbc .ge. 0) then
              if (nframe .eq. 1) then
                if (ifirstref .eq. 0 .and. ioppbc .ge. 0) then
                  call pbcdist(c(1,ia1),c(1,ia2),ia1,ia2,cell,ncell,
     -              -iw0,1,img,drincr,dimg)
                  call zeroit(drimg,3)
                  call arrdiff(drimg,cell(1,img),drimg,3)
                end if
              else if (noboxinfoar .eq. 0) then
c               Update box info (assuming isotropic box fluctuation)
                call updatecell(inptrajtyp,edge)
              end if
            end if
            if (nntest .eq. 0 .and. innlist .gt. 0) then
              call checknnlist(1,n,ineig,nneig,nerr,maxng)
              call comparetop(c,n,nneig,ineig,iatnum,innlist,nslt,naslv,
     -          cell,ncell,ioppbc,maxng,maxrec)
              nntest=1
            end if
            if (noprintconf .eq. 0 .and. ianaltyp .ne. 12 .and.
     -        (ianaltyp .ne. 17 .or. listbridge .eq. 1)) then
              if (iw0 .gt. 0 .and. ianaltyp .ne. 24)
     -            write (iw0,2055) nframe,ninconf
              if (iw1 .gt. 0 .and. extnam2 .ne. '.ps ') then
                write (iw1,2055) nframe,ninconf
              else if (iw2 .gt. 0 .and. ianaltyp .ne. 22) then
                if (analfile2(namleno2-2:namleno2) .ne. '.ps ')
     -            write (iw2,2055) nframe,ninconf
              end if
            end if
            if (itrajrot .gt. 0) call rotate_c(c,n,trajrot,c,
     -        'TRAJROT',7)
c           Configuration is ready, choose the analysis
cx          print *,'IANALTYP=',ianaltyp
            if (ianaltyp .eq.  1) then
c-------------(T) Neighbor, bond, angle and torsion list
              call printbondlist(iangpr,itorpr,1,nslt,nslt,c,nneig,
     -          ineig,line,inamcol1,inamcol2,irescol1,irescol2,
     -          iresncol1,iresncol2,index,cv,indexa,maxng,radtodeg,
     -          iw0,maxrec)
            else if (ianaltyp .eq.  2) then
c-------------(T) 1-4 statistics
              call stat14(c,n,nneig,ineig,index,line,nframe,pi,iatnm2,
     -          irescol1,irescol2,inamcol1,inamcol2,inpcrdtyp,ioins,iw0,
     -          maxrepconf,maxng,maxrec)
            else if (ianaltyp .eq.  3) then
C-------------(T) Functional group analysis
              call findfg(1,n,iatnum,mmtype,indexo,indexn,nhbneig,ih,
     -          ifgtyp,ibnd,nfg,6,nneig,nhneig,nneiga,ineig,iw0,
     -          inpcrdtyp,ioins,inamcol1,inamcol2,irescol1,irescol2,
     -          iresncol1,iresncol2,line,index,maxng,maxrec)
            else if (ianaltyp .eq.  4) then
c-------------(T) Bond length statistics
              call bondlenstat(c,n,iatnum,nneig,ineig,iatnm2,nframe,
     -          nanos,ixlist,ialist,iw0,inpcrdtyp,ioins,inamcol1,
     -          inamcol2,irescol1,irescol2,line,index,radtodeg,
     -          maxrepconf,maxng,maxrec)
            else if (ianaltyp .eq.  5) then
c-------------(T) Hydrogen-bond list
              call hblist(c,n,nslt,islvw,naslv,iatnum,ifchrg,isegno,
     -          nneig,nneiga,nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,
     -          npneig,ixres,nframe,hbf0,angm0,molresflag,hblimfac,
     -          angmin,iw0,inamcol1,inamcol2,irescol1,irescol2,
     -          iresncol1,iresncol2,blankline,line,index,indexn,ibnd,
     -          indexo,isolvent,ibondprint,1,nosamseg,radtodeg,
     -          maxrepconf,maxng,maxbox,maxrsd,maxrec)
              if (ifailbond .eq. 0) then
                call selectbond(ixres,nanchor,ianchor,indexa,ianchor2,
     -            iselfanc,iqfsel2,nhbneig,ineig,nbfound,nbresfound,
     -            nmc,nhbdist,'hydrogen',8,ianc_anc,it1,it2,
     -            ifailbond,iw0,maxng,maxrec,mxbonds)
              else
                go to 9005
              end if
            else if (ianaltyp .eq.  6 .or. ianaltyp .eq. 34) then
c-------------(T) Hydrophobic bond or heavy atom contact list
              call nnlisthph_sltb(nslt,ianchor2,iselfanc,indexa,iatnum,
     -          nneig, npneig,nhbneig,ineig,c,rhphmax,0,isegno,nosamseg,
     -          ibnd,indexo,ifail,maxng,maxng,maxrec)
              if (ihphprint .eq. 1)
     -          call hph_sltblist(c,nslt,nhbneig,ineig,iw0,
     -            inamcol1,inamcol2,irescol1,irescol2,iresncol1,
     -            iresncol2,line,index,'C-C',3,maxng)
              if (ifailbond .eq. 0) then
                call selectbond(ixres,nanchor,ianchor,indexa,ianchor2,
     -            iselfanc,0,nhbneig,ineig,nbfound,nbresfound,nmc,
     -            nhbdist,'hydrophobic',11,ianc_anc,it1,it2,
     -            ifailbond,iw0,maxng,maxrec,mxbonds)
              else
                go to 9005
              end if
            else if (ianaltyp .eq.  7) then
c-------------(T) Salt bridge list
              call nnlisthph_sltb(nslt,ianchor2,iselfanc,indexa,iatnum,
     -          nneig,npneig,nhbneig,ineig,c,rsltbmax,1,isegno,nosamseg,
     -          ibnd,indexo,ifail,maxng,maxng,maxrec)
              if (ibondprint .eq. 1)
     -          call hph_sltblist(c,nslt,nhbneig,ineig,iw0,inamcol1,
     -            inamcol2,irescol1,irescol2,iresncol1,iresncol2,line,
     -            index,'+..-',4,maxng)
              if (ifailbond .eq. 0) then
                call selectbond(ixres,nanchor,ianchor,indexa,ianchor2,
     -            iselfanc,0,nhbneig,ineig,nbfound,nbresfound,nmc,
     -            nhbdist,'salt-bridge',11,ianc_anc,it1,it2,ifailbond,
     -            iw0,maxng,maxrec,mxbonds)
              else
                go to 9005
              end if
            else if (ianaltyp .eq.  8) then
c-------------(T) Calculate residue-residue distances
              call rrdist(c,n,nres,ixresno,iresno,ixres,resnames,ifres,
     -          ilres,increst,incsolvrr,irefres1,irefres2,irefseg1,
     -          irefseg2,irefresinc,resdistlim,inegres1,inegres2,
     -          inegseg1,inegseg2,inegresinc,resapplim,listrefres,
     -          nrefres,nrefrange,listnegres,nnegres,nnegrange,iatnum,
     -          ignoreh,nframe,itypavg,iw0,iw1,iw2,irescol1,irescol2,
     -          inamcol1,inamcol2,is1,is2,irescount1,irescount2,
     -          irescount3,line,index,indexn,indexo,indexs,indexa,
     -          itemp1,itemp2,temp,cv,maxrec,maxrsd)
            else if (ianaltyp .eq.  33) then
c-------------(T) Calculate molecule-molecule distance matrix
                call mmdist(c,n,atw,iatnum,nmolslt,molsltlim,c2,temp,
     -            ignoreh,iw0,iw1)
            else if (ianaltyp .eq.  9) then
c-------------(T) Calculate a distance
              if (ifirstref .eq. 0) then
                if (nframe .gt. 1) then
c                 See if c(1,ia1) has not been reset to the cell
                  call pbcdist(caprev1,c(1,ia1),ia1,ia2,cell,ncell,-iw0,
     -              nframe,img,drincr,dimg)
                  if (img .gt. 1) then
c                   PBC change found
                    call arrsum(drimg,cell(1,img),drimg,3)
                  end if
c                 See if c(1,ia2) has not been reset to the cell
                  call pbcdist(caprev2,c(1,ia2),ia1,ia2,cell,ncell,-iw0,
     -              nframe,img,drincr,dimg)
                  if (img .gt. 1) then
c                   PBC change found
                    call arrdiff(drimg,cell(1,img),drimg,3)
                  end if
                end if
                call trnsfr(caprev1,c(1,ia1),3)
                call trnsfr(caprev2,c(1,ia2),3)
                call arrdiff(c(1,ia2),c(1,ia1),dr,3)
                call arrsum(dr,drimg,dr,3)
                d=sqrt(scprod(dr,dr))
                write (iw0,2049) nframe,
     -            ia1,(c(k,ia1),k=1,3),ia2,(c(k,ia2),k=1,3)
              else
                if (nframe .gt. 1) then
c                 See if c(1,ia2) has not been reset to the cell
                  call pbcdist(caprev2,c(1,ia2),ia1,ia2,cell,ncell,-iw0,
     -              nframe,img,drincr,dimg)
                  if (img .gt. 1) then
c                   PBC change found
                    call arrdiff(drimg,cell(1,img),drimg,3)
                  end if
                end if
                call trnsfr(caprev2,c(1,ia2),3)
                call arrdiff(c(1,ia2),caref,dr,3)
                call arrsum(dr,drimg,dr,3)
                dd=scprod(dr,dr)
                d=sqrt(dd)
                write (iw0,2048) nframe,ia2,(c(k,ia2),k=1,3)
              end if
              write (iw0,2054) nframe,d,dd,dr
              call trajlimtest(nframe,MAXFRAMES)
              res(1,nframe,1)=d
              res(2,nframe,1)=dr(idax)
              res(1,nframe,2)=dr(indexax(2))
              res(2,nframe,2)=dr(indexax(3))
              res(1,nframe,3)=dd
            else if (ianaltyp .eq. 10) then
c-------------(T) Check for potentially unphysical contacts
              call checkunphys(c,nslt,n,naslv,islvw,iatnum,ifchrg,
     -          isegno,idelseg,indexo,nneig,nneiga,nhbneig,ineig,nhneig,
     -          nnneig,ncneig,nsneig,npneig,ixres,line,irescol1,
     -          irescol2,inamcol1,inamcol2,index,nframe,innlist,
     -          molresflag,ioppbc,cell,ncell,edge,ixyzhex,molsltlim,
     -          nmolslt,hblimfac,angmin,ctfac,bondminfac,maxdist,iles,
     -          iw0,isltonly,ibnd,indexn,rlim,radtodeg,nerrunphys,
     -          maxrepconf,maxng,maxbox,maxrsd,maxrec)
            else if (ianaltyp .eq. 11) then
c-------------(T) Pseudorotation angle calculation
              call pseudorot(c,n,ix5,nmem,nneig,ineig,psr5,psr,npsr,
     -          psrtyp,incgen,zring,rring,sinpsrs,cospsrs,qpsr,qpsrs,
     -          qpsr2s,zav,zsq,zavs,zsqs,1,iw0,nframe,radtodeg,maxng,
     -          maxrec)
            else if (ianaltyp .eq. 12) then
c-------------(T) Calculate Proline kinks
C@GL              if (igl .eq. 1) call winset(idwmain)
              if (nframe .gt. maxframe) then
                write (6,2074) maxframe,'structures',' '
                go to 8002
              end if
              call prokinkcalcla(nrep,c,nslt,bend,wobble,
     -          faceshift,rmsb,rmsa,
C@GL     -          ninconf,trajnam,ltrajnam,noprol,
     -          iflatproline,ix5,radtodeg,MAXHX)
              call pseudorot(c,n,ix5,nmem,nneig,ineig,psr5,psr,npsr,
     -          'p',incgen,zring,rring,sinpsrs,cospsrs,qpsr,qpsrs,
     -          qpsr2s,zav,zsq,zavs,zsqs,0,6,nframe,radtodeg,maxng,
     -          maxrec)
              if (nrep .eq. 1) call savekinkdat(nmem,bend,wobble,
     -          faceshift,psr(2),radtodeg)
              if (nrep .le. 1) write (iw0,2072) ninconf,bend,wobble,
     -          faceshift,wobble-faceshift,psr(2),rmsb,rmsa
            else if (ianaltyp .eq. 13) then
c-------------(T) Hydropathy labeling
              call hydropathylist(n,nslt,ixres,resnames,cv,ihydtyp,igl,
     -          maxrsd,maxrec)
              call writeconf(iw0,inpcrdtyp,inpcrdtyp,inpcrdtyporg,n,n,
     -          nslt,naslv,islvw,iasv,namesv,qsv,pflsv,1,iwhead,0,
     -          iatnum,ifchrg,nframe,innlist,c,rprox,cv,ixres,iresno,
     -          atnames,resnames,segnames,charge,isegno,marker,ntitlin,
     -          ntitlinw,title,ireseq,iresnrestart,iresidrestart,nneig,
     -          nneiga,nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,
     -          numres,numslv,resnamslv,line,blankline,mmtype,ibnd,
     -          index,indexn,indexo,2,molresflag,irescount3,hblimfac,
     -          angmin,0,1,1,1,0,1,iqspaceask,13,1,0.0,0,0,0,keeprem,
     -          iwriteatsym,radtodeg,maxrepconf,maxng,maxrsd,maxrec)
            else if (ianaltyp .eq. 14) then
c-------------(T) Circular variance labeling of solute ats and solvent molecs
              call cvlist(c,n,nslt,nsltref_f,nsltref_l,naslv,islvrep,
     -          icvtyp,rcut_cv,rprox,cv,itemp1,c2,temp,indexn,indexo,
     -          indexs,chn,isortslv,cvlim)
              call writeconf(iw0,inpcrdtyp,inpcrdtyp,inpcrdtyporg,n,n,
     -          nslt,naslv,islvw,iasv,namesv,qsv,pflsv,1,iwhead,0,
     -          iatnum,ifchrg,nframe,innlist,c,rprox,cv,ixres,iresno,
     -          atnames,resnames,segnames,charge,isegno,marker,ntitlin,
     -          ntitlinw,title,ireseq,iresnrestart,iresidrestart,nneig,
     -          nneiga,nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,
     -          numres,numslv,resnamslv,line,blankline,mmtype,ibnd,
     -          index,indexn,indexo,1,molresflag,irescount3,hblimfac,
     -          angmin,0,1,1,1,0,3,iqspaceask,14,1,0.0,0,0,0,keeprem,
     -          iwriteatsym,radtodeg,maxrepconf,maxng,maxrsd,maxrec)
            else if (ianaltyp .eq. 16) then
c-------------(T) DSSP secondary structure assignment
              call dssp(c,1,n,nslt,line,index,inamcol1,inamcol2,
     -          iresncol1,iresncol2,nneig,ineig,nneiga,ibnd,indexn,
     -          indexo,npneig,nsneig,nnneig,dssplab,idistdssp,chn,c2,cv,
     -          indexs,indexa,nsse,itypsse,ifsse,ilsse,nframe,iw0,
     -          iwrose,nframe,ifail,dtodeg,maxrepconf,maxng*10,
     -          maxrec/10,maxng*20,maxrec/20,200,maxrsd,maxrec)
              if (ifail .gt. 0) go to 8002
              call plotdssp(iw1,ifsse,ilsse,itypsse,nsse,ninconf,
     -          maxtrajplot,framefac,ndivdssp,10,title(1:76),76,
     -          xtrajlab,11,'N(res)',6,nframe,ifrdssp,ilrdssp,indexdel)
            else if (ianaltyp .eq. 17) then
c-------------(T) Hydrogen-bond bridge analysis
              call hblist(c,n,nslt,islvw,naslv,iatnum,ifchrg,isegno,
     -          nneig,nneiga,nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,
     -          npneig,ixres,nframe,hbf0,angm0,molresflag,hblimfac,
     -          angmin,iw0,inamcol1,inamcol2,irescol1,irescol2,
     -          iresncol1,iresncol2,blankline,line,index,indexn,ibnd,
     -          indexo,1,0,1,nosamseg,radtodeg,maxrepconf,maxng,maxbox,
     -          maxrsd,maxrec)
              call hbbridge(nanchor,ianchor,indexa,ianchor2,iqfsel2,
     -          lpath,nbridgetype,ibridgetype,maxbridgemem,n,nhbneig,
     -          ineig,indexn,indexo,indexs,ixres,resnames,brslv,nabr,
     -          nrescol,nmc,ifailhbr,listbridge,iw0,maxng,MAXBRIDGELEN,
     -          MAXBRIDGETYPE,minbridgelenprint,maxrsd,maxrec)
              if (ifailhbr .eq. 1) go to 8002
            else if (ianaltyp .eq. 18) then
c-------------(T) Ramachandran plot
              call ramachandran(c,nslt,index,line,nframe,pi,nresfound,
     -          iresno,ixres,irescol1,irescol2,inamcol1,iw0,
     -          maxng,maxrec)
              call ramachandranplot(nresfound,iw1,xm,iallrama)
            else if (ianaltyp .eq. 32) then
c-------------(T) Angle dial plots
              call angledials(c,nslt,nangsel,ixtor1234,index,line,pi,
     -          irescol1,irescol2,inamcol1,inamcol2,iw0,maxrec)
            else if (ianaltyp .eq. 19) then
c-------------(T) Torsion dial plots
            call torsiondials(c,nslt,ntorsel,ixtor1234,index,line,pi,
     -        irescol1,irescol2,inamcol1,inamcol2,iw0,maxrec)
            else if (ianaltyp .eq. 20) then
c-------------(T) Delphi map labeling
              call delphilabel(c,n,nslt,xstart,ystart,zstart,gx,gy,gz,
     -          cv)
              call writeconf(iw0,inpcrdtyp,inpcrdtyp,inpcrdtyporg,n,n,
     -          nslt,naslv,islvw,iasv,namesv,qsv,pflsv,1,iwhead,0,
     -          iatnum,ifchrg,nframe,innlist,c,rprox,cv,ixres,iresno,
     -          atnames,resnames,segnames,charge,isegno,marker,ntitlin,
     -          ntitlinw,title,ireseq,iresnrestart,iresidrestart,nneig,
     -          nneiga,nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,
     -          numres,numslv,resnamslv,line,blankline,mmtype,ibnd,
     -          index,indexn,indexo,1,molresflag,irescount3,hblimfac,
     -          angmin,0,1,1,1,0,0,iqspaceask,20,1,0.0,0,0,0,keeprem,
     -          iwriteatsym,radtodeg,maxrepconf,maxng,maxrsd,maxrec)
            else if (ianaltyp .eq. 21) then
c-------------(T) Helix directions
C@GL              if (igl .eq. 1) call winset(idwmain)
cd77              write (77,*) ' ------------ Nframe=',nframe,' -----------'
              if (nrep .eq. 1)
     -          call soluteoverlay(isubcrm,ioverlay,nslt,nsegslt,c,cres,
     -            chn,c2,crmslt0,crmslt,atw,temp,molsltlim,indexs,
     -            idebughx,iw0,maxrsd,maxrec)
              do ihx=1,nhx
                call helixcomp(c,nslt,nreshx(ihx),calph0(1,1,ihx),
     -            axisdir0(1,ihx),perpvec0(1,1,ihx),axisini0(1,ihx),
     -            axisend0(1,ihx),helixcent0(1,ihx),crmslt0,rn0(1,ihx),
     -            camod(1,1,ihx),axfact,calph(1,1,ihx),axisdir(1,ihx),
     -            perpvec(1,1,ihx),axisini(1,ihx),axisend(1,ihx),
     -            helixcent(1,ihx),anglechange(1,ihx),
     -            anglechangeref(1,ihx),crmslt,axtol,iw0,torsion,
C@GL     -            inpfile,namleni,nframe,
     -            rotation,nrep,igl,indexaxhx(1,ihx),incrot,ireorienthx,
     -            idebughx,radtodeg,pi,c2,nreshx(ihx),icaahx(1,ihx),ihx,
     -            nhxres,MAXHX,maxrec)
                if (idsspcheck .eq. 1) then
                  call gethxlims(ireshx1(ihx),ireshx2(ihx),nslt,numres,
     -              iresno,ires11,ires22,iadssp1,iadssp2,maxrec)
                  if (nframe .eq. 1) then
                    call dssp(cres,iadssp1,n,iadssp2,line,index,
     -                inamcol1,inamcol2,iresncol1,iresncol2,nneig,ineig,
     -                nneiga,ibnd,indexn,indexo,npneig,nsneig,nnneig,
     -                dssplab,idistdssp,chn,c2,cv,indexs,indexa,nsse,
     -                itypsse,ifsse,ilsse,nframe,0,0,0,ifail,radtodeg,
     -                maxrepconf,maxng*10,maxrec/10,maxng*20,maxrec/20,
     -                200,maxrsd,maxrec)
                    lhelixcklab=9+11
                    write (helixcklab,2160) 'Reference h',ihx
                    call checkforhelix(ireshx1(ihx),ireshx2(ihx),ires11,
     -                dssplab,indexn,6,hxoklab,ihxok,helixcklab,
     -                lhelixcklab,maxrsd,maxrec)
                  else
                    call dssp(c,iadssp1,n,iadssp2,line,index,inamcol1,
     -                inamcol2,iresncol1,iresncol2,nneig,ineig,nneiga,
     -                ibnd,indexn,indexo,npneig,nsneig,nnneig,dssplab,
     -                idistdssp,chn,c2,cv,indexs,indexa,nsse,itypsse,
     -                ifsse,ilsse,nframe,0,0,0,ifail,radtodeg,
     -                maxrepconf,maxng*10,maxrec/10,maxng*20,
     -                maxrec/20,200,maxrsd,maxrec)
                    lhelixcklab=9+1
                    write (helixcklab,2160) 'H',ihx
                    call checkforhelix(ireshx1(ihx),ireshx2(ihx),ires11,
     -                dssplab,indexn,iw0,hxoklab,ihxok,helixcklab,
     -                lhelixcklab,maxrsd,maxrec)
                    nhelixok(ihxok)=nhelixok(ihxok)+1
                  end if
                end if
              end do
              if (nhx .gt. 0) then
                call multihelix(iw0,nhx,nhxres,radtodeg)
              end if
            else if (ianaltyp .eq. 22) then
c-------------(T) 1-D RMSD and residue RMS fluctuations
              nframeref=0
              call rmsd(cres,c,nslt,nfinalov,nfinalrmsd,atw,atwsum,temp,
     -          chn,c2,indexov,indexov,0,iedit,1,limresrange,itemp1,
     -          indexrmsd,indexrmsd,rot,com1,com2,etot,etot2,iw0,devmax,
     -          devmaxnoopt,maxrec)
              if (numresslt .le. MAXDISTR) then
                call rmsf(chn,c2,nslt,ifres,ilres,numresslt,rmsfsum)
                if (mod(nframe,nerr_int) .eq. 0 .or.
     -              nframe .eq. maxconf) then
                  ns=nframe/nerr_int
                  nframes_err(ns)=nframe
                  do ir=1,numresslt
                    distrerr(ns,ir)=rmsfsum(ir)
                  end do
                end if
              end if
            else if (ianaltyp .eq. 24) then
c-------------(T) RMSD map between trajectories
              call trnsfr(cres,c,3*nslt)
              nframeref=0
              ifail=0
              if (nframe .gt. 0)
     -          call opentraj(c,0,inpt2,inptrajtyp,n,ntitltr,trtitle,
     -            inpcrdtyp,ifirst2,ilast2,increment2,maxconf,
     -            ninconf2,noutconf,natom,nfreeat,ifree,icntrl,0,
     -            mmctrajtyp,trajnam2,ltrajnam2,'second trajectory',17,
     -            iconfsel,numsel2,0,1,0,0,icellfound,notfnd,0,
     -            iopen_rep,iw0,maxconfsel,maxrec)
              do while (ninconf2 .lt. ilast2 .and. ifail .eq. 0)
c               Get 2nd frames
                call readtraj(inpt2,inptrajtyp,mmctrajtyp,n,naslv,nwatr,
     -            nslt,trajformatname(inptrajtyp),ntitltr,trtitle,
     -            trajnam2,ltrajnam2,natom,nfreeat,ifree,icntrl,c,
     -            ninconf2,noutconf,increment,inpcrdtyp,ietot2,etot,
     -            ifail,ifirst,ilast,iconfsel,numsel,0,nmc2,1.0,maxconf,
     -            maxconfsel,maxrec)
                icsel2=0
                if (ifail .eq. 0) then
                  if (numsel .eq. 0) then
                    if (ninconf2 .ge. ifirst .and.
     -                mod(ninconf2-ifirst,increment2) .eq. 0) icsel2=1
                  else
c                   See if this configuration is on the list
                    if (ninconf2 .eq. iconfsel2(nextconfsel)) then
                      icsel2=1
                      nextconfsel=nextconfsel+1
                    else if (ninconf2 .gt. iconfsel(numsel)) then
                      ifail=1
                    end if
                  end if
                end if
                if (icsel2 .eq. 1) then
                  nframeref=nframeref+1
                  if (itrajrot .gt. 0) call rotate_c(c,n,trajrot,c,
     -              'TRAJROTX',8)
                  write (iw0,2055) nframe,ninconf,' ',nframeref
c                 Cross RMSD itemp2: indxov itemp3: indxrmsd
                  call rmsd(cres,c,nslt,nfinalov,nfinalrmsd,atw,
     -              atwsum,temp,chn,c2,indexov,indexov,noopt2d,iedit,0,
     -              limresrange,itemp1,indexrmsd,indexrmsd,rot,
     -              com1,com2,0.0,0.0,iw0,devmax,devmaxnoopt,maxrec)
                  if (absdevmin .gt. devmax) absdevmin=devmax
                  if (absdevmax .lt. devmax) absdevmax=devmax
                end if
                if (ninconf2 .ge. ilast2) ifail=1
              end do
              ifail=0
              close (inpt2)
            else if (ianaltyp .eq. 25) then
c-------------(T) Residue correlation calculation
              call residcorr(c,c,nslt,indexa,ncorr,nframe)
            else if (ianaltyp .eq. 26) then
c-------------(T) Atom-atom distribution calculation
              if (iclusterdist .eq. 0) then
                call pairdistcalc(c,nslt,npairs,listpairdist,
     -            pairdistsum,pairdistsum2,pairdistwsum,npairdist,
     -            pairdistminmax,pairgrid,iw0,MAXDDBIN,MAXDDISTR)
              else
                call clusterdistcalc(c,nslt,npairs,iclustermem,
     -            ifstclst1,ifstclst2,ilstclst2,pairdistsum,
     -            pairdistsum2,pairdistwsum,npairdist,pairdistminmax,
     -            pairgrid,iw0,MAXDDBIN,MAXDDISTR,MAXCDLIST)
              end if
            else if (ianaltyp .eq. 39) then
c-------------(T) Atom-atom distance SD calculation
              call atomdist_sd(c,nslt,ianchor,nanchor,nframe)
            else if (ianaltyp .eq. 27) then
c-------------(T) Solvation shell calculation
              call volcalc(nrand,c,nslt,isegno,iatnum,nsegslt,cv,cres,
     -          chn,c2,atw,vmac,vshell,vint,vmacsd,vshellsd,vintsd,
     -          vfrstsh,vfrstshsd,rsolv,ih,indexn,indexo,indexs,indexa,
     -          nframe,iw0,levout,maxrec)
              call trajlimtest(nframe,MAXFRAMES)
              res(1,nframe,1)=vshell
              res(2,nframe,1)=vfrstsh
              res(1,nframe,2)=vmac
              res(2,nframe,2)=vint
              res(1,nframe,3)=vshellsd
              res(2,nframe,3)=vfrstshsd
              res(1,nframe,4)=vmacsd
              res(2,nframe,4)=vintsd
            else if (ianaltyp .eq. 28) then
c-------------(T) Principal axis calculation
              if (nframe .eq. 1 .and. inputref .eq. 1)
     -          call princax(cres,c2,atw,temp,n,indexdel,evecs0,evals0,
     -            iw0,inputref,1,radtodeg,0)
              call princax(c,c2,atw,temp,n,indexdel,evecs0,evals0,iw0,
     -          inputref,0,radtodeg,0)
            else if (ianaltyp .eq. 29) then
c-------------(T) Radius and dipole calculation
              call molrad(c,indexa,ngyrats,iw0,MACREC)
              call celldipole(c,n,nslt,indexa,ngyrats,charge,icharges,
     -          atw,iw0,1)
            end if
            if (nframetot .gt. nframetotmin) then
c             Print progress report
              if (nframesign .gt. 0) then
                call progress_rep(nframe,nframe2d,nframesign)
              else
                nframetot=(ilast-ifirst+1)/increment
c               if (ianaltyp .eq. 23)
c    -            nframetot=nframetot*(nframetot-1)/2
                nframesign=nframetot/10
              end if
            end if
          end if
          if ((ninconf-ifirst)/increment .gt. 2) iprintpk=0
          ifirstscan=0
        end do
c       Trajectory scan done
c       if (ianaltyp .eq. 23) then
c         rewind inpt
c         ninconf=0
c         ifail=0
c         write (40,*) 'SCAN+ nframeref,maxframe=',nframeref,maxframe
c         if (nframeref .le. maxframe) go to 9111
c       end if
8002    close (inpt)
        nmw=0
        if (ianaltyp .eq. 12 .or. ianaltyp .eq. 21) then
          if (igl .eq. 1) then
            call getint('Repeat with new wait length (0 to stop)',39,
     -        numwait,1,0,nmw,0)
            if (maxframe .gt. nframe) maxframe=nframe
          end if
          nrep=nrep+1
          if (nmw .gt. 0) then
            numwait=nmw
            go to 9072
          end if
C@GL          call winclo(idwplot)
        end if
        if (iw0 .gt. 0) then
          write (iw0,2085)
          write (iw0,2020) trajnam(:ltrajnam),nframeread,nframe,ifirst-1
          if (ianaltyp .eq. 24) write (iw0,2065) nframeref
        end if
      end if
8006  if (itraj .eq. 1) then
        call testconst(0,1,2,0.0,1.0,2.0,6,nfail,1,'ANPO')
c       Post scan activities
        if (ntitlin .eq. 0 .and. ltitle .eq. 0) then
c         Use trajectory title
          title=trtitle(1)
        end if
        if (iw2 .gt. 0 .and. ianaltyp .ne. 22) then
          if (analfile2(namleno2-2:namleno2) .ne. '.ps ')
     -      write (iw2,2085)
        end if
        if (ianaltyp .eq. 12) then
          write (title,2069) irespro,nra,nrb
          call dialps(iw1,prokinklab,lprokinklab,title,ltitle,resrange,
     -      22,5,ndials,ndprow,nframe,pi,ipspage,0,nfravgd,0,0,0)
          write (6,2073) analfile1(1:namleno1)
          call trajstat(iw0,ndials,5,prokinklab,lprokinklab,0,1,0,
     -      rmsdlab,lrmsdlab,corr12,0,0,0,radtodeg)
        else if (ianaltyp .eq.  9 .or. ianaltyp .eq. 19 .or.
     -           ianaltyp .eq. 21 .or. ianaltyp .eq. 22 .or.
     -           ianaltyp .eq. 23 .or. ianaltyp .eq. 24 .or.
     -           ianaltyp .eq. 26 .or. ianaltyp .eq. 27 .or.
     -           ianaltyp .eq. 28 .or. ianaltyp .eq. 29 .or.
     -           ianaltyp .eq. 32 .or. ianaltyp .eq. 39) then
          if (ianaltyp .eq. 9) then
            irhx0=3+indexax(1)
            irhx1=3+indexax(2)
            irhx2=3+indexax(3)
            call arminmax2(res(1,1,1),nframe,2,armin1,armax1,
     -        armin2,armax2,0,2)
            call roundlim(armax1,y1div,ny1div)
            call plot2fun(iw1,2,xtraj,res(1,1,1),res(1,1,1),nframe,
     -        0.0,0.0,0,0.0,y1div,ny1div, 0.0,y2div,ny2div,title,80,
     -        atomdist,22,xtrajlab,11 ,'D',1,helixrlab(irhx0),
     -        lhelixrlab(irhx0),trajnam,ltrajnam,0,6,2,1,0,1,0,0,
     -        ipspage,1,1,0)
            call arminmax2(res(1,1,3),nframe,1,armin1,armax1,
     -        armin2,armax2,0,2)
            call roundlim(armax1,y1div,ny1div)
            call plot2fun(iw1,1,xtraj,res(1,1,3),res(1,1,3),nframe,
     -        0.0,0.0,0,0.0,y1div,ny1div, 0.0,y2div,ny2div,title,80,
     -        atomdist,22,xtrajlab,11 ,'D^2',3,
     -        'Total displacement square',25,trajnam,ltrajnam,0,6,
     -        2,1,0,1,0,0,ipspage,1,1,0)
            call arminmax2(res(1,1,2),nframe,2,armin1,armax1,
     -        armin2,armax2,0,2)
            ix=4.0*armin1
            if (armin1 .lt. 0.0) ix=ix-1
            xmn=float(ix)/4.0
            call roundlim(armax1-xmn,xdv,nxdv)
            iy=4.0*armin2
            if (armin2 .lt. 0.0) iy=iy-1
            ymn=float(iy)/4.0
            call roundlim(armax2-ymn,ydv,nydv)
            call plot2fun(iw1,2,xtraj,res(1,1,2),res(1,1,2),nframe,
     -        0.0,0.0,00,xmn,xdv,nxdv,ymn,ydv,nydv,title,80,atomdist,22,
     -        xtrajlab,11 ,helixrlab(irhx1),lhelixrlab(irhx1),
     -        helixrlab(irhx2),lhelixrlab(irhx2),trajnam,ltrajnam,
     -        0,6,2,1,0,1,0,0,ipspage,1,1,0)
            plotdescr='Progression of distance vector projected to the '
            plotdescr=plotdescr(1:48)//xyz(indexax(2))//'-'
            plotdescr=plotdescr(1:50)//xyz(indexax(3))//' plane'
            call plot2d(iw1,res(1,1,2),nframe,nfravgt,xmn,xdv,nxdv,
     -        ymn,ydv,nydv,title,80,plotdescr,56,atomdist,22,
     -        xyz(1),1,xyz(2),1,xtrajlab,11,0,0,6,1,ipspage,0,MAXFRAMES)
          else if (ianaltyp .eq. 21) then
            noopen=0
            noclose=1
            now6=0
            lresrange=22
            if (nhx .gt. 1) then
              now6=1
              lresrange=29
            end if
            do ihx=1,nhx
              write (resrange(1:22),2087) ireshx1(ihx),ireshx2(ihx)
              shiftlab(20:20)=axdirchar(ihx)
              if (nhx .gt. 1) write (resrange(23:29),2163) ihx
              incrhx=(ihx-1)*nhxres
              call dialps(iw1,helixang,lhelixang,title,ltitle,resrange,
     -          lresrange,5,ndials,ndprow,nframe,pi,ipspage,9,nfravgd,
     -          incrhx,noopen,1)
              noopen=1
              if (idsspcheck .gt. 0) then
                write (6,*)
                write (iw0,*)
                do k=1,3
                  if (nhx .eq. 1) write (6,2089) hxoklab(k),nhelixok(k)
                  write (iw0,2089) hxoklab(k),nhelixok(k)
                end do
              end if
              do k=1,3
                printrlab(k)=helixrlab(k)
                lprintrlab(k)=lhelixrlab(k)
              end do
              printrlab(4)=helixrlab(3+indexaxhx(1,ihx))
              lprintrlab(4)=lhelixrlab(3+indexaxhx(1,ihx))
              do k=1,2
                printrlab(4+k)=helixrlab(3+indexaxhx(k+1,ihx))
                lprintrlab(4+k)=lhelixrlab(3+indexaxhx(k+1,ihx))
                printrlab(6+k)=helixrlab(8+indexaxhx(k+1,ihx))
                lprintrlab(6+k)=lhelixrlab(8+indexaxhx(k+1,ihx))
                printrlab(8+k)=helixrlab(11+indexaxhx(k+1,ihx))
                lprintrlab(8+k)=lhelixrlab(11+indexaxhx(k+1,ihx))
              end do
              call trajstat(iw0,ndials,6,helixang,lhelixang,10,10,7,
     -          printrlab,lprintrlab,corr12,incrhx,0,now6,radtodeg)
              call arminmax2(res(1,1,incrhx+7),nframe,2,armin1,armax1,
     -          armin2,armax2,0,2)
              iy1=armin1
              y1mn=iy1
              id1=armax1-iy1+1
              if (mod(id1-iy1,2) .eq. 1 .or. id1. eq. 0) id1=id1+1
              y1div=float(id1)/10.0
              iy2=armin2
              if (armin2 .lt. 0.0) iy2=iy2-1
              y2mn=iy2
              call roundlim(armax2-y2mn,y2div,ny2div)
              call plot2fun(iw1,2,xtraj,res(1,1,incrhx+7),
     -          res(1,1,incrhx+7),nframe,0.0,0.0,00,y1mn,y1div,10,y2mn,
     -          y2div,ny2div,title,80,resrange,lresrange,xtrajlab,11,
     -          'Helix length',12,'Radius of fitted circle',23,trajnam,
     -          ltrajnam,0,6,2,1,0,1,0,0,ipspage,1,1,0)
              call arminmax2(res(1,1,incrhx+8),nframe,2,armin1,armax1,
     -          armin2,armax2,0,2)
              iy1=armin1
              y1mn=iy1
              call roundlim(armax1-y1mn,y1div,ny1div)
              iy2=4.0*armin2
              if (armin2 .lt. 0.0) iy2=iy2-1
              y2mn=float(iy2)/4.0
              call roundlim(armax2-y2mn,y2div,ny2div)
              call plot2fun(iw1,2,xtraj,res(1,1,incrhx+8),
     -          res(1,1,incrhx+8),nframe,0.0,0.0,00,y1mn,y1div,ny1div,
     -          y2mn,y2div,ny2div,title,80,resrange,lresrange,xtrajlab,
     -          11,'Total helix displacement',24,shiftlab,30,trajnam,
     -          ltrajnam,0,6,2,1,0,1,0,0,ipspage,1,1,0)
c             Plot the progress of the helix center in the plane of the other axes
              irhx1=3+indexaxhx(2,ihx)
              irhx2=3+indexaxhx(3,ihx)
              call arminmax2(res(1,1,incrhx+9),nframe,2,armin1,armax1,
     -          armin2,armax2,0,2)
              ix=4.0*armin1
              if (armin1 .lt. 0.0) ix=ix-1
              xmn=float(ix)/4.0
              call roundlim(armax1-xmn,xdv,nxdv)
              iy=4.0*armin2
              if (armin2 .lt. 0.0) iy=iy-1
              ymn=float(iy)/4.0
              call roundlim(armax2-ymn,ydv,nydv)
              call plot2fun(iw1,2,xtraj,res(1,1,incrhx+9),
     -          res(1,1,incrhx+9),nframe,0.0,0.0,00,xmn,xdv,nxdv,ymn,
     -          ydv,nydv,title,80,resrange,lresrange,xtrajlab,11,
     -          helixrlab(irhx1),lhelixrlab(irhx1),helixrlab(irhx2),
     -          lhelixrlab(irhx2),trajnam,ltrajnam,0,6,2,1,0,1,0,0,
     -          ipspage,1,1,0)
              plotdescr='Helix center track in the '//
     -          xyz(indexaxhx(2,ihx))//'-'
              plotdescr=plotdescr(1:28)//xyz(indexaxhx(3,ihx))//' plane'
              call plot2d(iw1,res(1,1,incrhx+9),nframe,nfravgt,xmn,
     -          xdv,nxdv,ymn,ydv,nydv,title,ltitle,plotdescr,35,
     -          resrange,lresrange,xyz(indexaxhx(2,ihx)),1,
     -          xyz(indexaxhx(3,ihx)),1,xtrajlab,11,0,0,6,0,ipspage,1,
     -          MAXFRAMES)
c             Plot the move of the helix start in the plane of the other axes
              irhx1=8+indexaxhx(2,ihx)
              irhx2=8+indexaxhx(3,ihx)
              call arminmax2(res(1,1,incrhx+10),nframe,2,armin1,armax1,
     -          armin2,armax2,0,2)
              ix=4.0*armin1
              if (armin1 .lt. 0.0) ix=ix-1
              xmn=float(ix)/4.0
              call roundlim(armax1-xmn,xdv,nxdv)
              iy=4.0*armin2
              if (armin2 .lt. 0.0) iy=iy-1
              ymn=float(iy)/4.0
              call roundlim(armax2-ymn,ydv,nydv)
              call plot2fun(iw1,2,xtraj,res(1,1,incrhx+10),
     -          res(1,1,incrhx+10),nframe,0.0,0.0,00,xmn,xdv,nxdv,ymn,
     -          ydv,nydv,title,80,resrange,lresrange,xtrajlab,11,
     -          helixrlab(irhx1),lhelixrlab(irhx1),helixrlab(irhx2),
     -          lhelixrlab(irhx2),trajnam,ltrajnam,0,6,2,1,0,1,0,0,
     -          ipspage,1,1,0)
              plotdescr(7:12)='start '
              call plot2d(iw1,res(1,1,incrhx+10),nframe,nfravgt,
     -          xmn,xdv,nxdv,ymn,ydv,nydv,title,ltitle,plotdescr,35,
     -          resrange,lresrange,xyz(indexaxhx(2,ihx)),1,
     -          xyz(indexaxhx(3,ihx)),1,xtrajlab,11,0,0,6,0,ipspage,1,
     -          MAXFRAMES)
c             Plot the progress of the helix end in the plane of the other axes
              irhx1=11+indexaxhx(2,ihx)
              irhx2=11+indexaxhx(3,ihx)
              call arminmax2(res(1,1,incrhx+11),nframe,2,armin1,armax1,
     -          armin2,armax2,0,2)
              ix=4.0*armin1
              if (armin1 .lt. 0.0) ix=ix-1
              xmn=float(ix)/4.0
              call roundlim(armax1-xmn,xdv,nxdv)
              iy=4.0*armin2
              if (armin2 .lt. 0.0) iy=iy-1
              ymn=float(iy)/4.0
              call roundlim(armax2-ymn,ydv,nydv)
              call plot2fun(iw1,2,xtraj,res(1,1,incrhx+11),
     -          res(1,1,incrhx+11),nframe,0.0,0.0,00,xmn,xdv,nxdv,ymn,
     -          ydv,nydv,title,80,resrange,lresrange,xtrajlab,11 ,
     -          helixrlab(irhx1),lhelixrlab(irhx1),helixrlab(irhx2),
     -          lhelixrlab(irhx2),trajnam,ltrajnam,0,6,2,1,0,1,0,0,
     -          ipspage,1,1,0)
              plotdescr(7:12)=' end  '
              call plot2d(iw1,res(1,1,incrhx+11),nframe,nfravgt,
     -          xmn,xdv,nxdv,ymn,ydv,nydv,title,ltitle,plotdescr,35,
     -          resrange,lresrange,xyz(indexaxhx(2,ihx)),1,
     -          xyz(indexaxhx(3,ihx)),1,xtrajlab,11,0,0,6,0,ipspage,1,
     -          MAXFRAMES)
c             Plot the progress of the helix plane normal's projection
              call arminmax2(res(1,1,incrhx+12),nframe,2,armin1,armax1,
     -          armin2,armax2,0,2)
              xmin=amin1(armin1,armin2,-armax1,-armax2)
              call roundlim(-10.0*xmin,xdv,nxdv)
              xdv=xdv/5.0
              nxdv=nxdv/2
              xmn=-xdv*nxdv
              nxdv=2*nxdv
              linein(1:lresrange)=resrange
              linein(lresrange+1:lresrange+33)=
     -          ' Helix axis is in the X direction'
              plotdescr='Track of the projection of the normal to the '
     -          //xyz(indexaxhx(2,ihx))//'-'//xyz(indexaxhx(3,ihx))//
     -          ' plane fitted to the helix bend'
              call plot2d(iw1,res(1,1,incrhx+12),nframe,nfravgt,
     -          xmn,xdv,nxdv,xmn,xdv,nxdv,title,ltitle,plotdescr,79,
     -          linein,lresrange+33,xyz(1),1,xyz(2),1,xtrajlab,11,0,0,
     -          6,0,ipspage,1,MAXFRAMES)
              do i=1,nframe
                scp_ax=res(1,1,incrhx+13)*res(1,i,incrhx+13)+
     -            res(2,1,incrhx+13)*res(2,i,incrhx+13)+
     -            res(1,1,incrhx+14)*res(1,i,incrhx+14)
                cv(i)=(180./3.141592)*dacoscheck(ddd,scp_ax,0,6,
     -            'HELIXAN')
              end do
              call arminmax2(cv,nframe,1,armin1,armax1,armin2,armax2,0,
     -          1)
              iy1=armin1
              y1mn=iy1
              call roundlim(armax1-y1mn,y1div,ny1div)
              iprt=0
              call plot2fun(iw1,1,xtraj,cv,cv,nframe,0.0,0.0,00,y1mn,
     -          y1div,ny1div,y2mn,y2div,ny2div,title,80,resrange,
     -          lresrange,xtrajlab,11,
     -          'Angle between start and current axes',36,shiftlab,30,
     -          trajnam,ltrajnam,iprt,iw0,1,1,0,1,0,0,ipspage,noclose,
     -          1,0)
            end do
            if (nhx .gt. 1) then
              incrhx=nhx*nhxres+1
              do ihx=1,nhx
                do jhx=ihx+1,nhx
                  call arminmax2(res(1,1,incrhx),nframe,2,armin1,
     -              armax1,armin2,armax2,0,2)
                  iy1=armin1
                  y1mn=iy1
                  id1=armax1-iy1+1
                  if (mod(id1-iy1,2) .eq. 1 .or. id1. eq. 0) id1=id1+1
                  y1div=float(id1)/10.0
                  iy2=armin2
                  if (armin2 .lt. 0.0) iy2=iy2-1
                  y2mn=iy2
                  call roundlim(armax2-y2mn,y2div,ny2div)
                  write (anglab,2162) 'Angle',ihx,jhx
                  write (distlab,2162) 'Distance',ihx,jhx
                  if (ihx .eq. nhx-1) noclose=0
                  call plot2fun(iw1,2,xtraj,res(1,1,incrhx),
     -              res(1,1,incrhx),nframe,0.0,0.0,00,y1mn,y1div,10,
     -              y2mn,y2div,ny2div,title,80,' ',1,xtrajlab,11,
     -              anglab,31,distlab,34,trajnam,ltrajnam,0,6,2,1,0,1,0,
     -              0,ipspage,noclose,1,0)
                  incrhx=incrhx+1
                end do
              end do
            end if
          else if (ianaltyp .eq. 19) then
c           Torsion angle dial plots
            call dialps(iw1,talab,ltalab,title,ltitle,
     -        'Torsion angle dial plots',24,5,ntorsel,ndprow,nframe,
     -        pi,ipspage,0,nfravgd,0,0,1)
            call trajstat(iw0,ntorsel,MAXCOPY1,talab,ltalab,0,1,0,
     -        rmsdlab,lrmsdlab,corr12,0,itorcorr,0,radtodeg)
          else if (ianaltyp .eq. 22) then
            call arminmax2(res(1,1,7),nframe,2,armin1,armax1,
     -        armin2,armax2,0,2)
            call roundlim(armax1,y1div,ny1div)
            rmsdmin=armin1
            rmsdmax=armax1
            if (rmsdplotmax .gt. 0.0) then
              ny1div=10
              y1div=rmsdplotmax/ny1div
            end if
            call plot2fun(iw1,maxdevplot+1,xtraj,res(1,1,7),res(1,1,7),
     -        nframe,0.0,0.0,00,0.0,y1div,ny1div, 0.0,y2div,ny2div,
     -        title,80,'Best overlap',12,xtrajlab,11 ,'RMSD',4,
     -        'Maximum deviation',17,trajnam,ltrajnam,0,6,2,1,0,1,0,3,
     -        ipspage,1,1,0)
            if (iunmatchplot .eq. 1) then
              call arminmax2(res(1,1,8),nframe,2,armin1,armax1,
     -          armin2,armax2,0,2)
              call roundlim(armax1,y1div,ny1div)
              call roundlim(armax2,y2div,ny2div)
              call plot2fun(iw1,maxdevplot+1,xtraj,res(1,1,8),
     -          res(1,1,8),nframe,0.0,0.0,00,0.0,y1div,ny1div,
     -          0.0,y2div,ny2div,title,80,
     -          'Comparison is done without overlay',34,xtrajlab,11 ,
     -          'RMSD',4,'Maximum deviation',17,trajnam,ltrajnam,
     -          0,6,2,1,0,1,0,0,ipspage,1,1,0)
            end if
            call trajstat(iw0,0,6,helixang,lhelixang,4,4,7,rmsdlab,
     -        lrmsdlab,corr12,0,0,0,radtodeg)
            if (inptrajtyp .eq. 3) then
              call correl(iw0,res(1,1,7),1,'RMSD',4,av1,sd1,res(1,1,9),
     -          1,'Energy',6,av2,sd2,corr,nframe,1,now6)
              call arminmax2(res(1,1,9),nframe,2,armin1,armax1,
     -          armin2,armax2,0,2)
              write (linein(1:48),2033) corr
              call scatterps(iw1,rmsdmin,rmsdmax,575.0,armin1,armax1,
     -          720.0,res(1,1,7),res(1,1,9),1,1,nframe,linein,48,1)
            end if
            if (numresslt .le. MAXDISTR) then
              nosd=0
              do i=1,MAXDISTRN
                xcum(i)=nframes_err(i)
c               print *,i,' nframes_err=',nframes_err(i)
              end do
              do ir=1,numresslt
                rmsfav(ir)=rmsfsum(ir)/float(nframe)
                cv(ir)=ir
                call btchmn(MAXDISTRN,0,1,xcum,distrerr(1,ir),dtemp1,
     -            dtemp2,'RMSF err',iw0,1,err(ir),itemp1(ir))
              end do
              write (iw0,2155) (ir,rmsfav(ir),err(ir),
     -          run_res(itemp1(ir)),ir=1,numresslt)
              if (rmsfplotmax .eq. 0.0) then
                call arminmax2(rmsfav,numresslt,1,armin1,armax1,
     -            armin2,armax2,0,1)
                call roundlim(armax1,y1div,ny1div)
              else
                 ny1div=10
                 y1div=rmsfplotmax/ny1div
              end if
              call getrange(ifstplot,1,ilstplot,numresslt,incr,0,
     -          'residue in the RMSF plot',24,numresslt,000)
              nresplot=ilstplot-ifstplot+1
              xmin=ifstplot-mod(ifstplot,10)
              call plot2fun(iw1,1,cv(ifstplot),rmsfav(ifstplot),err,
     -           nresplot,xmin,0.0,10,0.0,y1div,ny1div, 0.0,y2div,
     -           ny2div,title,80,'Residue RMSF',12,'N(res)',6,'RMSF',4,
     -           'Overlay',7,trajnam,ltrajnam,0,6,1,nosd,nfreqsd,1,0,0,
     -           ipspage,0,1,0)
              call askyn('Do you want to write a PDB file with RMSF',41,
     -          1,0,iwpdb,0)
              if (iwpdb .gt. 0) then
                do ir=numresslt,1,-1
                  do ia=ifres(ir),ilres(ir)
                    cv(ia)=rmsfav(ir)
                  end do
                end do
                analfile2(namleno2:namleno2)='f'
                analfile2(namleno2+1:namleno2+4)='.pdb'
                call openfile(iw2,0,'RMSF',4,'new',analfile2,namleno2+4,
     -            notfnd,0,1,1,0,0)
                write (6,2031) analfile2(1:namleno2+4)
                call writeconf(iw2,inpcrdtyp,inpcrdtyp,inpcrdtyporg,n,n,
     -            nslt,naslv,islvw,iasv,namesv,qsv,pflsv,1,iwhead,0,
     -            iatnum,ifchrg,nconfig,innlist,c,rprox,cv,ixres,iresno,
     -            atnames,resnames,segnames,charge,isegno,marker,
     -            ntitlin,ntitlinw,title,ireseq,iresnrestart,
     -            iresidrestart,nneig,nneiga,nhbneig,ineig,nhneig,
     -            nnneig,ncneig,nsneig,npneig,numres,numslv,resnamslv,
     -            line,blankline,mmtype,ibnd,index,indexn,indexo,1,
     -            molresflag,irescount3,hblimfac,angmin,0,1,1,1,0,3,
     -            iqspaceask,ianaltyp,0,0.0,0,0,0,keeprem,iwriteatsym,
     -            radtodeg,maxrepconf,maxng,maxrsd,maxrec)
              end if
            end if
          else if (ianaltyp .eq. 23) then
c           Prepare 2-D RMSD plot
            noclose=0
            if (irmsdclust .gt. 0) noclose=1
            nframeref=nframeref-1
            call plot2drmsd(nrep,iw0,iw1,xtraj,maxrec,title,'',0,
     -        trajnam,ltrajnam,trajnam,0,xtrajlab,11,increment,
     -        increment,ncolcode,maxcolcode,iedit,noopt2d,limresrange,
     -        0,rmsdmin,rmsdmax,absdevmin,absdevmax,rmsdmn,rmsdmx,
     -        indexa,indexs,ixshuffle,ixshuffle,indexa,0,indexa,0,
     -        ym_2d,it1,it2,temp,0,1,noplotdist,iskip2dplot,0,noclose,
     -        ipspage,1)
            if (irmsdclust .gt. 0) then
              inspect=0
              write (6,2068)
8010          call trnsfi(iconfsel,indexs,nframe)
              call clusterdistr(nframe,iw0,rmsdlim,rmsdmn,rmsdmx,
     -          nhbdist,it1,it2,it3,itemp4,indexn,indexo,ncl,indexa,
     -          iconfsel,ixclst,it4,value,ifa_s,ila_s,ih,cv,0.0,
     -          rdclust,res(1,1,11),ietotsaved,'RMSD',4,1,1,irepav,
     -          irepmx,irepeng,irepkm,engcl,c,chn,c2,1,26,iclstyp,iwt,0,
     -          label2d,80,0,1,1,1,igl,mx2d,maxframe)
c             iconfsel contains the sorted cluster members
c             indexn, indexo contain the cluster limits
              do i=1,ncl
                nclstmem(i)=indexo(i)-indexn(i)+1
              end do
              call countsim(indexn,indexo,iconfsel,ncl,rdclust,rmsdsim,
     -          nsimclst1,iw0,mx2d)
              if (ireplot .eq. 1) then
                call trnsfi(ixshuffle,iconfsel,MAX2D)
                call indexit(it3,1,MAX2D,0)
                if (inspect .eq. 1) then
                  call openfile(iw1,0,'analysis',8,'old',analfile1,
     -              namleno1,notfnd,0,1,1,0,0)
                  do while (.true.)
                    read (iw1,2005,end=8011) ans
                  end do
8011              continue
                end if
                call plot2drmsd(nrep,iw0,iw1,xtraj,maxrec,title,
     -            'Frames sorted by clusters',25,trajnam,ltrajnam,
     -            trajnam,0,xtrajlab,11,increment,increment,ncolcode,
     -            maxcolcode,iedit,noopt2d,limresrange,0,rmsdmin,
     -            rmsdmax,absdevmin,absdevmax,rmsdmn,rmsdmx,indexa,
     -            it3,ixshuffle,ixshuffle,indexo,ncl,indexo,ncl,
     -            ym_2d,it1,it2,temp,1,1,noplotdist,iskip2dplot,1,1,
     -            ipspage,0)
                call askyn('Do you want to inspect the clustered map'//
     -            ' and redo the clustering',64,1,-1,inspect,000)
                if (inspect .gt. 0) then
                  call clusterplot(iw1,xtraj,value,indexn,indexo,ncl,
     -              ixclst,nframe,trajnam,ltrajnam,xtrajlab,11,ipspage,
     -              0,mx2d)
                  close (iw1)
                  go to 8010
                end if
              end if
              call clusterplot(iw1,xtraj,value,indexn,indexo,ncl,ixclst,
     -          nframe,trajnam,ltrajnam,xtrajlab,11,ipspage,0,mx2d)
            end if
          else if (ianaltyp .eq. 24) then
c           Prepare cross RMSD plot
            call plot2drmsd(nrep,iw0,iw1,xtraj,maxrec,title,'',0,
     -        trajnam,ltrajnam,trajnam2,ltrajnam2,xtrajlab,11,increment,
     -        increment2,ncolcode,maxcolcode,iedit,noopt2d,limresrange,
     -        1,rmsdmin,rmsdmax,absdevmin,absdevmax,rmsdmn,rmsdmx,
     -        indexa,indexs,ixshuffle,ixshuffle,indexa,0,indexa,0,
     -        ym_2d,it1,it2,temp,0,0,noplotdist,0,0,0,ipspage,0)
            if (matchconf .eq. 1)
     -        call matchtraj(rmsdsim,iw0)
            write (6,2038)
            write (iw0,2038)
          else if (ianaltyp .eq. 26) then
c           Prepare distance distribution output
            call pairdistprint(nframe,npairs,listpairdist,iclusterdist,
     -        iclustermem,ifstclst1,ifstclst2,ilstclst2,pairdistsum,
     -        pairdistsum2,pairdistwsum,npairdist,pairdistminmax,
     -        pairgrid,rmaxpair,line,index,inamcol1,inamcol2,irescol1,
     -        irescol2,inpcrdtyp,ioins,iw0,nslt,MAXDDBIN,MAXDDISTR,
     -        MAXCDLIST,maxrec)
          else if (ianaltyp .eq. 39) then
c           Prepare distance SD matrix plot
            call plot_atomdist_sd(nslt,line,index,inamcol1,inamcol2,
     -        irescol1,irescol2,iresncol1,iresncol2,ianchor,nanchor,
     -        nframe,indexa,ixshuffle,xtraj,title,trajnam,ltrajnam,
     -        isdtyp,iw0,iw1,igl,ipspage,maxrec)
          else if (ianaltyp .eq. 27) then
            call trajstat(iw0,0,1,helixang,lhelixang,4,4,1,volumelab,
     -        lvolumelab,corr12,0,0,0,radtodeg)
            call arminmax2(res(1,1,1),nframe,2,armin1,armax1,
     -        armin2,armax2,0,2)
            call setdivxy(armin1,armax1,ny1div,y1div,y1min)
            call setdivxy(armin2,armax2,ny2div,y2div,y2min)
            write (linein,2148) nrand,corr12
            call plot2fun(iw1,2,xtraj,res(1,1,1),res(1,1,3),nframe,
     -        0.0,0.0,0,y1min,y1div,ny1div,y2min,y2div,ny2div,title,80,
     -        linein,70,xtrajlab,11 ,'V(solvent-excluded shell)',25,
     -        'V(first solvation shell)',24,trajnam,ltrajnam,0,6,2,00,0,
     -        1,0,4,ipspage,1,1,0)
            call arminmax2(res(1,1,2),nframe,2,armin21,armax21,
     -        armin22,armax22,0,2)
            linein(1:1)=' '
            call setdivxy(armin21,armax21,ny1div,y1div,y1min)
            call setdivxy(armin22,armax22,ny2div,y2div,y2min)
            call plot2fun(iw1,2,xtraj,res(1,1,2),res(1,1,4),nframe,
     -        0.0,0.0,0,y1min,y1div,ny1div,y2min,y2div,ny2div,title,80,
     -        linein,01,xtrajlab,11 ,'V(macromolecule)',16,
     -        'V(interface)',12,trajnam,ltrajnam,0,6,2,01,1,1,0,0,
     -        ipspage,1,1,0)
            nbin=max0(10,nframe/100)
            call zeroiti(indexo,0,nbin)
            range1=armax1-armin1
            call roundlim(range1,xdiv,nxdiv)
            nx1=armin1/xdiv
            xmin=nx1*xdiv
            facnorm=nbin/amax1(1.0,range1)
            do i=1,nframe
              ix=min0(nbin,int(facnorm*(res(1,i,1)-armin1))+1)
              indexo(ix)=indexo(ix)+1
            end do
            histmax=0.0
            do i=1,nbin
              cv(i)=xmin+(i-0.5)*range1/nbin
              charge(i)=indexo(i)
              if (charge(i) .gt. histmax) histmax=charge(i)
            end do
            call roundlim(histmax,y1div,ny1div)
            call plot2fun(iw1,1,cv,charge,res(1,1,3),nbin,xmin,xdiv,
     -        nxdiv,0.0,y1div,ny1div, 0.0,y2div,ny2div,title,80,linein,
     -        36,'V(solvent-excluded shell)',25,xtrajlab,11 ,' ',1,
     -        trajnam,ltrajnam,0,6,1,01,0,1,0,0,ipspage,1,1,0)
            call zeroiti(indexo,0,nbin)
            call setdivxy(armin2,armax2,nxdiv,xdiv,xmin)
            facnorm=nbin/amax1(1.0,armax2-armin2)
            do i=1,nframe
              ix=min0(nbin,int(facnorm*(res(2,i,1)-armin2))+1)
              indexo(ix)=indexo(ix)+1
            end do
            histmax=0.0
            do i=1,nbin
              cv(i)=xmin+(i-0.5)*(armax2-armin2)/nbin
              charge(i)=indexo(i)
              if (charge(i) .gt. histmax) histmax=charge(i)
            end do
            call roundlim(histmax,y2div,ny2div)
            call plot2fun(iw1,1,cv,charge,res(1,1,3),nbin,xmin,xdiv,
     -        nxdiv,0.0,y1div,ny1div, 0.0,y2div,ny2div,title,80,linein,
     -        36,'V(first solvation shell)',24,xtrajlab,11 ,' ',1,
     -        trajnam,ltrajnam,0,6,1,01,0,1,0,0,ipspage,0,1,0)
          else if (ianaltyp .eq. 28) then
c           Principal axis calculation
            call arminmax2(res(1,1,6),nframe,2,armin1,armax1,
     -        armin2,armax2,0,2)
            call setdivxy(armin1,armax1,ny1div,y1div,y1min)
            call setdivxy(armin2,armax2,ny2div,y2div,y2min)
            call setdivxy(0.0,xtraj(nframe),nxdiv,xdiv,xmin)
            write (linein,2101) 'first and second'
            call plot2fun(iw1,2,xtraj,res(1,1,6),res(1,1,6),nframe,xmin,
     -        xdiv,nxdiv,y1min,y1div,ny1div,y2min,y2div,ny2div,title,80,
     -        linein,66,xtrajlab,11 ,'First principal axis',20,
     -        'Second principal axis',21,trajnam,ltrajnam,0,6,2,1,0,1,0,
     -        2,ipspage,1,1,0)
            call arminmax2(res(1,1,7),nframe,1,armin1,armax1,
     -        armin2,armax2,0,2)
            call setdivxy(armin1,armax1,ny1div,y1div,y1min)
            write (linein,2101) 'third'
            call plot2fun(iw1,1,xtraj,res(1,1,7),res(1,1,7),nframe,xmin,
     -        xdiv,nxdiv,y1min,y1div,ny1div,y2min,y2div,ny2div,title,80,
     -        linein,55,xtrajlab,11 ,'Third principal axis',20,' ',1,
     -        trajnam,ltrajnam,0,6,2,1,0,1,0,0,ipspage,0,1,0)
          else if (ianaltyp .eq. 29) then
c           Molecular radii, moments of inertia and dipole moment calculation
            call averageres(nframe,res,1,1,MAXFRAMES,MAXCOPY1,rgav,rgsd)
            call averageres(nframe,res,1,2,MAXFRAMES,MAXCOPY1,rhav,rhsd)
            call averageres(nframe,res,2,2,MAXFRAMES,MAXCOPY1,rmxmn,
     -        rmxmnsd)
            write (iw0,2079) rgav,rgsd,1.0/rhav,rhsd,rmxmn
            call arminmax2(res(1,1,1),nframe,2,armin1,armax1,
     -        armin2,armax2,0,2)
            call setdivxy(armin1,armax1,ny1div,y1div,y1min)
            call setdivxy(armin2,armax2,ny2div,y2div,y2min)
            call setdivxy(0.0,xtraj(nframe),nxdiv,xdiv,xmin)
            noclose=0
            if (icharges .gt. 0) noclose=1
            call plot2fun(iw1,2,xtraj,res(1,1,1),res(1,1,1),nframe,xmin,
     -        xdiv,nxdiv,y1min,y1div,ny1div,y2min,y2div,ny2div,title,80,
     -        linein,00,xtrajlab,11 ,'Radius of gyration',18,
     -        'Hydrodynamic radius',19,trajnam,ltrajnam,0,6,2,1,0,1,0,1,
     -        ipspage,noclose,1,0)
            if (icharges .gt. 0) then
              call averageres(nframe,res,1,10,MAXFRAMES,MAXCOPY1,avcell,
     -          sdcell)
              call averageres(nframe,res,2,10,MAXFRAMES,MAXCOPY1,avslt,
     -          sdslt)
              write (iw0,2080) avcell,sdcell,avslt,sdslt
              call arminmax2(res(1,1,10),nframe,2,armin1,armax1,
     -          armin2,armax2,0,2)
              call setdivxy(armin1,armax1,ny1div,y1div,y1min)
              call setdivxy(armin2,armax2,ny2div,y2div,y2min)
              call averageres(nframe,res,1,11,MAXFRAMES,MAXCOPY1,
     -          dip1(1),sdxyx1(1))
              call averageres(nframe,res,2,11,MAXFRAMES,MAXCOPY1,
     -          dip1(2),sdxyx1(2))
              call averageres(nframe,res,1,12,MAXFRAMES,MAXCOPY1,
     -          dip1(3),sdxyx1(3))
              write (iw0,2088)
     -           'Total cell',(xyz(k),dip1(k),sdxyx1(k),k=1,3)
              nplot=1
              if (n .gt. nslt) then
                nplot=2
                call averageres(nframe,res,1,13,MAXFRAMES,MAXCOPY1,
     -          dip1(1),
     -            sdxyx1(1))
                call averageres(nframe,res,2,13,MAXFRAMES,MAXCOPY1,
     -          dip1(2),sdxyx1(2))
                call averageres(nframe,res,1,14,MAXFRAMES,MAXCOPY1,
     -          dip1(3),sdxyx1(3))
                write (iw0,2088)
     -            'Solute',(xyz(k),dip1(k),sdxyx1(k),k=1,3)
              end if
              call plot2fun(iw1,nplot,xtraj,res(1,1,10),res(1,1,10),
     -          nframe,xmin,xdiv,nxdiv,y1min,y1div,ny1div,y2min,y2div,
     -          ny2div,title,80,linein,00,xtrajlab,11,'Total dipole',
     -          12,'Solute dipole',13,trajnam,ltrajnam,0,6,2,1,0,1,0,0,
     -          ipspage,0,1,0)
              call correl(iw0,res(1,1,1),1,'Radius of gyration',18,
     -          av1,sd1,res(1,1,10),1,'Solute dipole',13,av2,sd2,corr,
     -          nframe,1,0)
            end if
          else if (ianaltyp .eq. 32) then
c           Angle dial plots
            call dialps(iw1,talab,ltalab,title,ltitle,
     -        'Angle dial plots',16,5,nangsel,ndprow,nframe,pi,ipspage,
     -        0,nfravgd,0,0,1)
            call trajstat(iw0,nangsel,MAXCOPY1,talab,ltalab,0,1,0,
     -        rmsdlab,lrmsdlab,corr12,0,itorcorr,0,radtodeg)
          end if
          if (iw1 .gt. 0) write (6,2073) analfile1(1:namleno1)
        else if (ianaltyp .eq. 8) then
c         Print contact count
          write (iw0,2113)
          write (iw1,2113)
          if (iw2 .gt. 0) write (iw2,2113)
          call blankout(linein,1,80)
c         print *,'NSEGCOL=',nsegcol
          do ir=1,numresslt
            if (irescount1(ir)+irescount2(ir)+irescount3(ir) .gt. 0)
     -          then
              write (linein,2114) ir,iresno(ifres(ir)),
     -          resnames(ir)(1:nrescol),
     -          segid4(isegno(ifres(ir)))(1:nsegcol),
     -          irescount1(ir),irescount2(ir),irescount3(ir)
              call lastchar(linein,lc,80)
              write (iw0,2005) linein(1:lc)
              write (iw1,2005) linein(1:lc)
              if (iw2 .gt. 0) write (iw2,2005) linein(1:lc)
            end if
          end do
          call print_rrdist(itypavg,nframe,irefres1,irefres2,inegres1,
     -      inegres2,listrefres,nrefres,listnegres,nnegres,nrescol,iw0,
     -      iw1,iw4,ipspage,resnames,inpfile,namleni,itemp1,igl,maxrsd)
          call askyn(
     -      'Do you want to write a PDB file with contact counts',51,1,
     -      0,iwpdb,0)
          if (iwpdb .gt. 0) then
            call quiz(ans,icontyp,' ',' ',0,'Contact type',12,0,5,6,
     -        igl,0)
            do ir=1,numresslt
              do ia=ifres(ir),ilres(ir)
                if (icontyp .eq. 1) then
                  cv(ia)=irescount1(ir)
                else if (icontyp .eq. 2) then
                  cv(ia)=irescount2(ir)
                else if (icontyp .eq. 3) then
                  cv(ia)=irescount3(ir)
                else if (icontyp .eq. 4) then
                  cv(ia)=irescount1(ir)+irescount2(ir)+irescount3(ir)
                end if
                rprox(ia)=1.0
              end do
            end do
            analfile4=analfile1
            analfile4(namleno1-2:namleno1+4)='cnt.pdb'
            iw4=44
            call openfile(iw4,0,'Contact-labeled PDB',19,
     -        'new',analfile4,namleno1+4,notfnd,0,1,1,0,0)
            call writeconf(iw4,inpcrdtyp,iobpdb,inpcrdtyporg,
     -        nslt,nslt,nslt,naslv,islvw,iasv,namesv,qsv,pflsv,1,
     -        iwhead,0,iatnum,ifchrg,nconfig,innlist,c,rprox,cv,ixres,
     -        iresno,atnames,resnames,segnames,charge,isegno,marker,
     -        ntitlin,ntitlinw,title,ireseq,iresnrestart,iresidrestart,
     -        nneig,nneiga,nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,
     -        npneig,numres,numslv,resnamslv,line,blankline,mmtype,ibnd,
     -        index,indexn,indexo,1,molresflag,irescount3,hblimfac,
     -        angmin,0,1,1,1,0,3,iqspaceask,90+icontyp,0,0.0,0,0,0,
     -        keeprem,iwriteatsym,radtodeg,maxrepconf,maxng,maxrsd,
     -        maxrec)
            close (iw4)
          end if
        else if (ianaltyp .eq. 12) then
          write (title,2069) irespro,nra,nrb
          call dialps(iw1,prokinklab,lprokinklab,title,ltitle,resrange,
     -      22,5,ndials,ndprow,nframe,pi,ipspage,0,nfravgd,0,0,0)
          write (6,2073) analfile1(1:namleno1)
          call trajstat(iw0,ndials,5,prokinklab,lprokinklab,0,1,0,
     -      rmsdlab,lrmsdlab,corr12,0,0,0,radtodeg)
        else if (ianaltyp .eq. 25) then
          call openps(iw1,xm,ym-30,title(1:76),76,
     -      ' ',1,trajnam,0,trajnam2,ltrajnam2,npspages,ipspage)
          call plotresidcorr(ncorr,nframe,indexa,indexs,
     -      ncolcode,maxcolcode,nrep,iw0,iw1,xm,ym,title,80,
     -      trajnam,ltrajnam,ipspage,iucorrmat,icovmatplot,cv,maxrec)
          if (iucorrmat .gt. 0) then
c           Calculate eigenvalues/eigenvectors
            close (iw0)
            analfile(namleno+1:namleno+4)='.eig'
            namleno=namleno+4
            write (6,2019) 'Eigenvalues and eigenvectors',
     -        analfile(1:namleno)
            call openfile(iw0,0,'eigenvalues & eigenvectors',26,'new',
     -        analfile,namleno,notfnd,0,1,1,0,0)
            call normalmodes(ncorr,iucorrmat,trajnam,ltrajnam,nframe,
     -        0,iw0,1,ierr,index2d,value,ifa_s,ila_s,it1,rmsdlim,
     -        MAXBONDS)
            close (iucorrmat,status='delete')
          end if
        else if (ianaltyp .eq. 16 .or. ianaltyp .eq. 18) then
          if (ianaltyp .eq. 18) then
            call rainbowscale(iw1,50,450,25,nframe,xtraj(nframe),0.0,
     -        0.0,xtrajlab,11)
            call dialps(iw2,ramalab,lramalab,title,ltitle,' ',0,5,
     -        2*nxselres,ndprow,nframe,pi,ipspage,0,nfravgd,0,0,0)
            close (iw2)
            call ramachandran_hist(nresfound,resnames,nrescol,iw0,1,0)
            call ramachandran_hist(nresfound,resnames,nrescol,iw0,0,1)
            iw3=iw2+1
            analfile3=analfile
            analfile3(namleno+1:namleno+7)='.trc.ps'
            namleno3=namleno+7
            write (6,2019) '2D traces on the psi-phi map',
     -        analfile3(1:namleno3)
            call openfile(iw3,0,'2D_Rama_trace',13,'new',analfile3,
     -         namleno3,notfnd,0,1,1,0,0)
            analfile2=analfile
            analfile2(namleno+1:namleno+7)='.auc.ps'
            namleno2=namleno+7
            write (6,2019) 'Psi-Phi autocorrelation functions',
     -        analfile2(1:namleno2)
            call openfile(iw2,0,'Psi-Phi autoc',13,'new',analfile2,
     -         namleno2,notfnd,0,1,1,0,0)
            restitle='Residue 00000 (     ) nconf=        '
            incrementac=1
            if (nframe .gt. 500) call getint(
     -        'Frame increment for autocorrelation calculation',47,1,1,
     -        nframe/2,incrementac,0)
            do i=1,nframe/(2*incrementac)
              rplot(i)=i*incrementac
            end do
            npspages=nxselres
            do ir=1,nxselres
              if (ir .eq. nxselres) noclose=0
              iresdr=ixselres(ir)
              write (restitle(9:13),2103) iresdr
              restitle(16:15+nrescol)=resnames(iresdr)(1:nrescol)
              sinphisum=0.d0
              cosphisum=0.d0
              sinpsisum=0.d0
              cospsisum=0.d0
              do i=1,nframe
                xyplot(1,i)=dacoscheck(ddd,res(1,i,2*ir-1),0,6,'RAMA')*
     -            radtodeg
                if (res(2,i,2*ir-1) .lt. 0) xyplot(1,i)=-xyplot(1,i)
                xyplot(2,i)=dacoscheck(ddd,res(1,i,2*ir),0,6,'RAMA')*
     -            radtodeg
                if (res(2,i,2*ir) .lt. 0) xyplot(2,i)=-xyplot(2,i)
                cosphisum=cosphisum+res(1,i,2*ir-1)
                sinphisum=sinphisum+res(2,i,2*ir-1)
                cospsisum=cospsisum+res(1,i,2*ir)
                sinpsisum=sinpsisum+res(2,i,2*ir)
              end do
              cosphisum=cosphisum/nframe
              sinphisum=sinphisum/nframe
              sqsum=sqrt(cosphisum**2+sinphisum**2)
              if (sqsum .eq. 0.0) sqsum=1.0
              cosphisum=cosphisum/sqsum
              cvphi=1.0-sqsum
              phiav=dacoscheck(cosphisum,cps,1,6,'PHIAV')*radtodeg
              if (sinphisum .lt. 0.d0) phiav=-phiav
              cospsisum=cospsisum/nframe
              sinpsisum=sinpsisum/nframe
              sqsum=sqrt(cospsisum**2+sinpsisum**2)
              if (sqsum .eq. 0.0) sqsum=1.0
              cospsisum=cospsisum/sqsum
              psiav=dacoscheck(cospsisum,cps,1,6,'PSIAV')*radtodeg
              if (sinpsisum .lt. 0.d0) psiav=-psiav
              cvpsi=1.0-sqsum
              write (6,2093) iresdr,resnames(iresdr)(1:nrescol),
     -          phiav,cvphi,psiav,cvpsi
              write (iw0,2093) iresdr,resnames(iresdr)(1:nrescol),
     -          phiav,cvphi,psiav,cvpsi
              call plot2d(iw3,xyplot,nframe,1,-180.0,30.0,12,
     -          -180.0,30.0,12,title,80,'2D trace on the psi-phi map',
     -          27,restitle,21,'Phi',3,'Psi',3,xtrajlab,11,1,0,6,
     -          npspages,ipspage3,1,MAXFRAMES)
              call resautocorr(ir,incrementac,ncf,xyplot)
              write (restitle(29:36),2094) ncf
              call plot2fun(iw2,1,rplot,xyplot,xyplot,ncf,0.0,0.0,0,
     -          0.0,0.1,10,0.0,0.1,10,
     -          'Psi-Phi autocorrelation function',32,restitle,36,
     -          xtrajlab,11,'Autocorrelation',15,' ',1,trajnam,
     -          ltrajnam,0,77,2,1,0,1,0,npspages,ipspage2,1,1,0)
              npspages=0
            end do
          end if
          write (iw1,*) 'showpage'
          close (iw1)
          if (ianaltyp .eq. 16) then
c           Print statistics
            write (iw0,2149) (typc(it),ssname(it)(1:lssname(it)),it=1,9)
            write (iw0,2150) (typc(it),it=1,9)
            write (iw0,2151)
     -         (ir,(idistdssp(it,ir),it=1,9),ir=ifrdssp,ilrdssp)
          end if
          close (iw2)
          close (iw3)
          if (igl .eq. 1) stop
        else if (ianaltyp .eq. 17) then
          call hbbridgeprint(nanchor,ianchor,lpath,nbridgetype,
     -      ibridgetype,maxbridgemem,line,index,iresno,inamcol1,
     -      inamcol2,irescol1,irescol2,hblimfac,angmin,inpfile,0,
     -      iw0,qmin,iqfsel2,brslv,nrescol,maxbondcount,maxhbtype,
     -      minbridgelenprint,minbridgepercprint,nframe,MAXBRIDGELEN,
     -      MAXBRIDGETYPE,maxrec)
        else if (ianaltyp .eq.  5) then
          call finalizebonds(n,nbfound,nbfoundorig,nbresfound,iw0,iw1,
     -      numres,npspages,ipspage,nres2d,ifirst,ilast,ibondcorr,
     -      iresbondcorr,nhneigmin,hblimfac,angmin,rhphmax,inamcol1,
     -      inamcol2,irescol1,irescol2,ifhb2d,ilhb2d,nhbdist,iframeunit,
     -      framefac,title,ltitle,trajnam,ltrajnam,xtrajlab,11,xtraj,
     -      value,ifa_s,ila_s,ih,cv,temp,index,iresno,ifres,isegno,
     -      atnames,resnames,ixres,ixresno,ixsegno,indexa,indexs,
     -      index2d,ianc_anc,isc,ixclst,irepav,irepmx,irepeng,irepkm,
     -      rmsdlim,engcl,it1,it2,it3,it4,it5,irrix,itemp1,itemp2,
     -      itemp3,itemp4,line,'hydrogen',8,ibondtype,label2d,iselfanc,
     -      ianchor2,iresshift,igl,ifailbond,ncolcode,maxcolcode,
     -      maxbondcount,MAXBONDS,maxrsd,MAXFRAMES,maxrec,mx2d)
        else if (ianaltyp .eq.  6) then
          call finalizebonds(n,nbfound,nbfoundorig,nbresfound,iw0,iw1,
     -      numres,npspages,ipspage,nres2d,ifirst,ilast,ibondcorr,
     -      iresbondcorr,nhneigmin,hblimfac,angmin,rhphmax,inamcol1,
     -      inamcol2,irescol1,irescol2,ifhb2d,ilhb2d,nhbdist,iframeunit,
     -      framefac,title,ltitle,trajnam,ltrajnam,xtrajlab,11,xtraj,
     -      value,ifa_s,ila_s,ih,cv,temp,index,iresno,ifres,isegno,
     -      atnames,resnames,ixres,ixresno,ixsegno,indexa,indexs,
     -      index2d,ianc_anc,isc,ixclst,irepav,irepmx,irepeng,irepkm,
     -      rmsdlim,engcl,it1,it2,it3,it4,it5,irrix,itemp1,itemp2,
     -      itemp3,itemp4,line,'hydrophobic',11,ibondtype,label2d,
     -      iselfanc,ianchor2,iresshift,igl,ifailbond,ncolcode,
     -      maxcolcode,maxbondcount,MAXBONDS,maxrsd,MAXFRAMES,maxrec,
     -      mx2d)
        else if (ianaltyp .eq.  34) then
          call finalizebonds(n,nbfound,nbfoundorig,nbresfound,iw0,iw1,
     -      numres,npspages,ipspage,nres2d,ifirst,ilast,ibondcorr,
     -      iresbondcorr,nhneigmin,hblimfac,angmin,rhphmax,inamcol1,
     -      inamcol2,irescol1,irescol2,ifhb2d,ilhb2d,nhbdist,iframeunit,
     -      framefac,title,ltitle,trajnam,ltrajnam,xtrajlab,11,xtraj,
     -      value,ifa_s,ila_s,ih,cv,temp,index,iresno,ifres,isegno,
     -      atnames,resnames,ixres,ixresno,ixsegno,indexa,indexs,
     -      index2d,ianc_anc,isc,ixclst,irepav,irepmx,irepeng,irepkm,
     -      rmsdlim,engcl,it1,it2,it3,it4,it5,irrix,itemp1,itemp2,
     -      itemp3,itemp4,line,'heavy-atom contact',18,ibondtype,
     -      label2d,iselfanc,ianchor2,iresshift,igl,ifailbond,ncolcode,
     -      maxcolcode,maxbondcount,MAXBONDS,maxrsd,MAXFRAMES,maxrec,
     -      mx2d)
        else if (ianaltyp .eq.  7) then
          call finalizebonds(n,nbfound,nbfoundorig,nbresfound,iw0,iw1,
     -      numres,npspages,ipspage,nres2d,ifirst,ilast,ibondcorr,
     -      iresbondcorr,nhneigmin,hblimfac,angmin,rsltbmax,inamcol1,
     -      inamcol2,irescol1,irescol2,ifhb2d,ilhb2d,nhbdist,iframeunit,
     -      framefac,title,ltitle,trajnam,ltrajnam,xtrajlab,11,xtraj,
     -      value,ifa_s,ila_s,ih,cv,temp,index,iresno,ifres,isegno,
     -      atnames,resnames,ixres,ixresno,ixsegno,indexa,indexs,
     -      index2d,ianc_anc,isc,ixclst,irepav,irepmx,irepeng,irepkm,
     -      rmsdlim,engcl,it1,it2,it3,it4,it5,irrix,itemp1,itemp2,
     -      itemp3,itemp4,line,'salt-bridge',11,ibondtype,label2d,
     -      iselfanc,ianchor2,iresshift,igl,ifailbond,ncolcode,
     -      maxcolcode,maxbondcount,MAXBONDS,maxrsd,MAXFRAMES,maxrec,
     -      mx2d)
        else if (ianaltyp .eq. 11) then
          zav=zavs/dfloat(nframe)
          zsd=dsqrt(dabs(zsqs/dfloat(nframe)-zav**2))
          write (6,2008) zav,zsd
          write (iw0,2008) zav,zsd
          pi=atan(1.0)*4.0
          write (6,2009)
          write (iw0,2009)
          do m=2,npsr
            sn=sinpsrs(m)/dfloat(nframe)
            cs=cospsrs(m)/dfloat(nframe)
            psr(m)=atansc(sn,cs,1,radtodeg)
            cvm=1.d0-dsqrt(sinpsrs(m)**2+cospsrs(m)**2)/dfloat(nframe)
            qpsrav=qpsrs(m)/dfloat(nframe)
            qsd=dsqrt(dabs(qpsr2s(m)/dfloat(nframe)-qpsrav**2))
            write (6,2011) m,psr(m),cvm,qpsrav,qsd
            write (iw0,2011) m,psr(m),cvm,qpsrav,qsd
          end do
        end if
        iout_track=0
        if (ianaltyp .eq. 5 .or. ianaltyp .eq. 6 .or.
     -      ianaltyp .eq. 7 .or. ianaltyp .eq. 34) then
          if (ireadtracks .eq. 0) then
            call askyn(
     -        'Do you want to write the bond tracks',36,1,-1,itrackw,0)
            if (itrackw .gt. 0) then
              call getname(trackfile,ltrackfile,
     -          'Name of the bond track file',27,80,000)
              iout_track=92
              call openfile(92,0,' ',1,'new',trackfile,ltrackfile,
     -          notfnd,0,1,1,0,0)
              call writetrack(iout_track,iw0,30,nbfoundorig,nres2d,
     -          trackfile,ltrackfile,trajnam,ltrajnam,ianc_anc)
            end if
          end if
          iwconn=0
          if (ilastframe .eq. 0) write (6,2122) 'input structure'
          if (ilastframe .eq. 1) write (6,2122)
     -      'last structure read from the trajectory file'
          question='Do you want a PDB file of the current structure '//
     -      'with % bonds'
          call askyn(question(1:60),60,1,-1,iwpdb,0)
          if (iwpdb .eq. 0) then
            call askyn('Do you want a PDB file with lines between the'//
     -        ' residue pairs',59,1,-1,iwconn,140)
          else
            call askyn(
     -        'Do you want to add lines between the residue pairs',50,
     -        1,-1,iwconn,140)
            iwpdb=1
          end if
          if (iwpdb .gt. 0) then
            call askyn(
     -        'Do you want percentages added to all atoms in a residue',
     -        55,1,-1,icperc,138)
            if (icperc .eq. 1) then
              do ir=1,numres
                sum=0.0
                do ia=ifres(ir),ilres(ir)
                  sum=sum+cv(ia)
                end do
                if (sum .gt. 0.0) then
                  do ia=ifres(ir),ilres(ir)
                    cv(ia)=sum
                  end do
                end if
              end do
            end if
            analfile4=analfile
            lanalfile4=namleno
            analfile4(lanalfile4-2:lanalfile4+4)='pcb.pdb'
            lanalfile4=lanalfile4+4
            iw4=44
            call openfile(iw4,0,'Percent bond labeled PDB',24,
     -        'new',analfile4,lanalfile4,notfnd,0,1,1,0,0)
            call writeconf(iw4,inpcrdtyp,iobpdb,inpcrdtyporg,
     -        nslt,nslt,nslt,naslv,islvw,iasv,namesv,qsv,pflsv,1,
     -        iwhead,0,iatnum,ifchrg,nconfig,innlist,c,rprox,cv,ixres,
     -        iresno,atnames,resnames,segnames,charge,isegno,marker,
     -        ntitlin,ntitlinw,title,ireseq,iresnrestart,iresidrestart,
     -        nneig,nneiga,nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,
     -        npneig,numres,numslv,resnamslv,line,blankline,mmtype,ibnd,
     -        index,indexn,indexo,1,molresflag,irescount3,hblimfac,
     -        angmin,0,1,1,1,0,3,iqspaceask,ianaltyp,0,0.0,0,0,1,
     -        keeprem,iwriteatsym,radtodeg,maxrepconf,maxng,maxrsd,
     -        maxrec)
            if (iwconn .gt. 0) then
              call writeconn(iw4,ifres,ilres,line,index,inamcol1,
     -          inamcol2,c,n,iresbondcorr,itemp4,nframe,iw0,mxbonds,
     -          maxrsd,maxrec)
            end if
            write (iw4,2005) 'END'
            close (iw4)
          end if
        end if
      end if
9005  write (iw0,*)
      call datprt(iw0,version,0,mark0,lmark0,hostname,lhostname,
     -  iheadnode,0)
      close (iw0)
      n=natsorig
      iconfirmname=1
      call testconst(0,1,2,0.0,1.0,2.0,6,nfail,1,'ANTD')
      go to 9000
      return
2000  format(/,' List of 1-4 neighbors, their distances and the ',
     -  'torsion angles will be',/,' written to ',a)
2001  format(i2)
2002  format(' Hydrogen-bond',a,'list will be written to file',/,
     -  5x,a)
2003  format(/,20x,' DSSP (Kabsch-Sander) ANALYSIS',/)
2004  format(/,20x,' HELIX ORIENTATION ANALYSIS',//,
     -  ' S and E: coordinates of the helix axis initial and ',
     -  'final points (in A)',/,
     -  ' RMS: diagnostic of the irregularities in the helix',/,
     -  ' Len: length of the helix (in A)',/,
     -  ' D: unit vector in the helix direction',/,
     -  ' D-X,D-Y,D-Z angles: the tilt angles of the helix w.r.t. the',
     -  ' laboratory frame',/,
     -  ' Shape: Bent, Random or Oscillating, ',
     -  'based on Nup/dn (nup, ndown), and Ncross',/,
     -  ' Tolerance for being on the axis=',f6.2,
     -  ' (Nax: number of CAs within tolerance)'/,
     -  ' Rc: radius of circle fitted to the alpha carbons',/
     -  ' TPR: turn angle/residue',/,
     -  ' C: coordinates of the center of mass of the helix',/,
     -  ' N-X,N-Y,N-Z angles: the tilt angles of the normal to the ',
     -  ' plane fitting',/,
     -  '    the alpha carbons w.r.t. the laboratory frame',/,
     -  ' Rotation: the angle of revolution of helix around ',
     -  'its axis from the start',/,
     -  ' Local tilt: angle between the first and current ',
     -  'helix axes',/,
     -  ' SD: fluctuation of the rotation angles calculated from ',
     -  'each alpha carbon',/,
     -  ' N/Nr angle: angle between the normals N in the ',
     -  'current and reference state',/)
2005  format(a)
2006  format(a,a,' file analyzed:',a)
2007  format(' Helix axis calculation Copyright 1996 Jon A.Christopher',
     -  ' and Thomas O. Baldwin.',/,
     -  25x,'Computers in Chemistry Vol. 20, pp 338-349 (1989)',/,
     -  ' Axes generated with the algorithm of Kahn ',/,
     -  25x,'Computers in Chemistry Vol 13, pp 185-189 (1989)',/)
2008  format(' Average mean distance from the ring plane=',f6.2,
     -  ' A SD=',f6.2)
2009  format(' Average general puckering coordinates ',
     -  '(Cramer & Pople)=',/,7x,'m   angle    CV      qm     SD')
2010  format(' Reference structure:')
2011  format(' SUM ',i3,f8.2,f7.4,2f8.4)
2012  format(' Reference structure file:',a)
2013  format(' Note: RMSD calculation is working with trajectory ',
     -  'scan only',/,' but a set of PDB or Charmm CRD files can be ',
     -  'read as MMC trajectories')
2014  format(a,/,a,'System:',/,a,a)
2015  format(' Residue range of the helix',i3,':',i5,' - ',i5,
     -  ' (segment ',i3,')')
2016  format(' Secondary structure element type:',/,
     -  7(9x,a1,': ',a,/),9x,'?',': Unrecognized',/)
2017  format(' The COM of each trajectory frame will be shifted to the',
     -  ' reference frame COM')
2018  format(' Each trajectory frame will be overlaid on the reference',
     -  ' structure',a)
2019  format(1x,a,' will be written to file ',/,5x,a)
2020  format(' Scan of trajectory ',a,' finished',/,
     -  ' Number of frames read=',i6,/,' Number of frames analyzed=',i6,
     -  /,' Number of frames skipped=',i6)
2021  format(/,' NOTE: map preparation would be much faster if you ',
     - 'used a trajectory',/,' that has only the frames for which ',
     - 'calculations are required.',/,' Use the trajectory conversion ',
     - 'option of Simulaid to do this')
2022  format(' NOTE: the 2nd trajectory has to be of the exact same ',
     -  'system as the first')
2023  format(i5,1x,a4,1x,a3)
2024  format(/,' List of neighbors, bondlengths, angles and torsions ',
     -  '(if requested) will be',/,' written to file ',a)
2025  format(' Solvent radius=',f7.2,' A',/,
     -  ' Number of random point generated=',i10)
2026  format(' Only every ',i2,'-th grid point will be used')
2027  format('REMARK ',a)
2028  format(' Calculation of distance distribution over selected atom',
     -  ' pairs',/,a)
2029  format(' NOTE: residue numbers refer to the actual number, not ',
     -  'to the sequence number')
2030  format(' WARNING: The presence of a large number of solvents ',
     -  'slows down the calculation',/,10x,'- you may want to ',
     -  'eliminate the solvents using the Edit option')
2031  format(' PDB file with RMSF as the B factor:',a)
2032  format(' ERROR: Number of frames to analyze (',i6,') exceeds ',
     -  'the limit (',i5,')',/,' Increase the inrement or recompile',
     -  ' with the parameter MAX2D > ',i5,/)
2033  format('RMSD (X) - Energy (Y) scatterplot. Corr=',f8.5)
2034  format(' Number of atoms changed from ',i6,' to ',i6,
     -  ' (trajectory)')
2035  format(' NOTE: lack of charge information may hamper the bond ',
     -  'definitions',/,7x,'- you may want to consider other structure',
     -  ' file formats')
2036  format(' Simulaid will try to open file ',a,/,
     -  10x,'to write the results on. If this is the file ',
     -  'that you want to read,',/,
     -  10x,'make sure not to overwrite it')
2037  format(' !!!!! WARNING: This calculation may be quite time ',
     -  'consuming',/,
     -  7x,'Please, log on to a compute node and restart')
2038  format(' To match clusters of the two trajectory, generate the ',
     -  '2D RMSD map for both',/,' and rerun the cross-RMSD ',
     -  'calculation using the already calculated',/,
     -  ' 2D RMSD and cross-RMSD maps')
2039  format(1x,a1,':',i5,' (',a,1x,a,')',3(' -',i5,' (',a,1x,a,')'))
2040  format(' ERROR: Number of atoms or free atoms or cell info type',
     -  ' is different in the two trajectories')
2041  format(1x,a,': Invalid selection, try again')
2042  format(' Bridge residue name=',a,' Number of atoms in residue ',a,
     -  '=',i3)
2043  format(i3)
2044  format(100i1)
2045  format(' Default marks will be used:',/,9(i2,': ',a1))
2046  format(' Adjacency-matrix analysis result will be written to ',
     -  'file',/,1x,a)
2047  format(' Enter the indices of the two atoms whose distance is ',
     -  'to be calculated/tracked',/,
     -  ' To track the diffusion of an atom, type the same index',
     -  ' for both atoms')
2048  format(' N=',i6,' c(',i5,')=',3f11.2,' A')
2049  format(' N=',i6,' c(',i5,')=',3f11.2,' c(',i5,')=',3f11.2,' A')
2050  format(/,' Residue neighbour list based on ',a,' atoms will be ',
     -  'written to',/,1x,a)
2051  format(' First atom is on the reference structure ',a)
2052  format(i5,' diffusion')
2053  format(i5,' - ',i5,' distance')
2054  format(' N=',i6,' D=',f11.2,' D^2=',f11.2,' r=',3f11.2,' A')
2055  format(/,' Config # ',i5,
     -  ' (inp config #: ',i10,')',a,' Ref # : ',i5)
2056  format(' Symbol for residue type ',i1,'=',$)
2057  format(' Calculating distance between atom',i6,' residue',i5,
     -  ' (',a5,a5,') and',/,' atom',i6,' residue',i5,' (',a5,a5,')')
2058  format(' Calculating distance between atoms',i6,' and',i6)
2059  format(' WARNING: number of frames exceeded the parameter ',
     -  'MAXFRAMES (',i8,')',/,10x,'Several analysis options fail when',
     -  ' this limit is passed')
2060  format(' 2D RMSD calculations stopped at nframe,nframeref=',2i6)
2061  format(' Check for unphysical distances',/,
     -  ' Clash threshold = Bondlength threshold * sqrt(',f8.4,')',/,
     -  ' Short bond threshold = Bondlength threshold * sqrt(',f8.4,')',
     -  /,' Index distance threshold for non-S atoms = ',i4)
2062  format(' NOTE: The number of solute residues (',i6,') exceeds ',
     -  'the limit (',i5,')',/,' Increase the parameter MAXDISTR and',
     -  ' recompile to calculate RMSF')
2063  format(' WARNING: ',a,' trajectory name (',a,')',/,8x,
     -  'is different from the trajectory name of the corresponding ',
     -  '2D-RMSD map',/,8x,'(',a,')')
2064  format(/,' RMSD values were read from file ',a)
2065  format(' Number of frames used from the second trajectory=',i6)
2066  format(' WARNING: atoms',i6,' and',i6,' are',a,'bonded',/,
     -  ' You can create bonds with the Edit option')
2067  format(a1,i2,' i:',i4,3('-',i4))
2068  format(' NOTE: after quitting clustering you will have the ',
     - 'option of inspecting',/,6x,' the map and repeat the clustering')
2069  format('Proline kink dials for residue',i5,
     -  ' Pre and post proline helix length=',2i3)
2070  format(' Animation will show:',/,' 1. Helix backbone',/,
     -  ' 2. Helix axis (x)',/,
     -  ' 3. Normal to the plane fitted to the backbone (N)',/
     -  ' 4. Radius from the backbone COM to the center of ',
     -  'the best fit circle')
2071  format(/,' Calculation of proline kink angles defined by ',
     -  'Visiers et al.',/,
     -  ' Note: kink residue does not have to be a proline',/,
     -  ' Axes generated with the algorithm of Kahn ',/,
     -  ' using the subroutines of J.A. Christopher & T.O. Baldwin',/,
     -  ' Angles are calculated with vector-algebra based code',/,
     -  ' Bend, angle, wobble angle and phase shift will',
     -  ' be written to file',/,1x,a)
2072  format(i6,' B=',f6.1,' W=',f6.1,' FS=',f6.1,' W-FS=',f6.1,
     -  ' PR=',f6.1,' axis RMS b,a=',f4.2,f5.2)
2073  format(' The Postscript plots will be written to the file',/,
     -  1x,a)
2074  format(' Plotting is limited to ',i6,1x,a,/,
     -  ' -',a,'increase the the arrays (maxframe)',/
     -  ,' in the common block /analres/')
2075  format(1x,a,' map values will be written to file',/,
     -  1x,a,/,' Postscript plot will be written to file',/,1x,a)
2076  format(1x,a,' will be written into the data column ',
     -  'in file',/,1x,a)
2077  format(/,20x,' PROLINE KINK CALCULATION',/,
     -  ' bend (B), wobble (W), phase shift (FS)',/,
     -  ' pseudorotation angle of the proline (PR)',/,' Goodness of ',
     -  ' the helices before and after the proline (axis RMS b,f)')
2078  format(/,' Calculation of pseudorotation angles')
2079  format(/,' Average radius of gyration=',f10.3,' S.D.=',f10.3,' A',
     -  /,' Average hydrodynamic radius=',f10.3,' S.D.(1/rHD)=',f10.3,/,
     -  ' Average ratio of the largest and smallest moments of ',
     -  'inertia=',f10.3)
2080  format(/,' Average cell dipole moment=',f10.3,' S.D.=',f10.3,/
     -  ' Average solute dipole moment=',f10.3,' S.D.=',f10.3,' au*A')
2081  format(/,' NOTE: warnings, summaries (if any) will be turned off',
     -  ' after the',i3,'-th frame')
2082  format(' Calculation of the RMSD from the input structure',/,
     -  ' both after obtaining the best fit with the Kabsch ',
     -  'method and without fitting',/)
2083  format(' Kink residue:',i5)
2084  format(' Calculation of the RMSD matrix between frames of a ',
     -  'trajectory')
2085  format(/,1x,78('-'))
2086  format(' Plot entries color coded by the ',a,' number:',/,
     -  ' Red-Yellow-Green-Cyan-Blue <--> 1 -',a,a,i5,')')
2087  format('Residues',i6,' -',i6)
2088  format(1x,a,' dipole components:',/,
     -  3(' dip',a,'=',f8.2,' +/-',f6.2))
2089  format(' Number of ',a,' helices: ',i7)
2090  format(' WARNING: The calculation would be significantly faster',
     -  ' if a trajectory were first',/,10x,'extracted with only the ',
     -  'frames needed.',/,10x,'- it can be done with the trajectory ',
     -  'conversion option')
2091  format('Atomic number of solvent atom ',i2)
2092  format('Partal charge of solvent atom ',i2)
2093  format(' Residue',i5,' (',a,') <Phi>=',f8.2,' CV=',f6.4,
     -  ' <Psi>=',f8.2,' CV=',f6.4)
2094  format(i8)
2095  format(a1)
2096  format(' Current dimensioning allows only for',i6,' * ',i6,
     -  ' matrix')
2097  format(' Principal axes calculated will be written to file',/,
     -  1x,a)
2098  format(' The reference conformation may be the first ',
     -  'conformation of the trajectory'/,' (this is the default) or ',
     -  'the structure inputted at the start')
2099  format(' Calculation of principal axes. Atoms used:',$)
2100  format(' Calculation of radii of gyration, hydrodynamic radius ',
     -  ' moments of inertia and',/,
     -  ' (when charges are available) and dipole moment',/
     -  ' Atoms used:',$)
2101  format('Angle between inital and current ',a,' principal axis')
2102  format(' Solute molecule',i4,' consists of only',i3,' atoms')
2103  format(i5)
2104  format(' Residue # ',i6,' has no full backbone - a bond may be ',
     -  'missing',/,' You can add bonds usind the Edit option')
2105  format(' Solvents will be sorted by increasing CV (out -> in)')
2106  format(' ERROR: dimensions of the cross-MSD matrix (',i5,' x ',i5,
     -  ')',/,8x,'differ from the lengths of the trajectories read:',
     -  2i6)
2107  format(' Radius of gyration, hydrodynamic radius moments of ',
     -  'inertia',/,' and (if charges are available) dipole moment ',
     -  'will be written to file'/,1x,a)
2108  format('A ',a4,'-',a4,'(',a4,') -',a4)

2111  format(' Segment',i4,' residue #',i5,' is ',a)
2112  format(' At least one of the residue ranges exceeds MAX2D (',i5,
     -  ')',/,' - no averages will be calculated')
2113  format(/,'List of the counts of different tyes of contacts',/)
2114  format(i5,' resid=',i5,' (',a,1x,a,') Nrepr=',i6,' Nclose=',i6,
     -  ' Ncontact=',i6)
2115  format(' Ramax(',a2,')')
2116  format(' RMSDs were calculated ',a)
2117  format(' Actual residue number of the ',a,' residue=',i6)
2118  format(' Reference structure file=',a)
2119  format(' Sigma-r plot (SD of interatomic distances'/,
     -  ' Hao Zhou, to be published')
2120  format(' Molecule-molecule distance matrix based on ',a,/,
     -  ' will be written to ',a)
2121  format(' Molecule-molecule distance matrix based on ',a,/)
2122  format(' Current structure is the ',a) 
2123  format(' ERROR: residue number can not be ',a,' than ',i5)
2140  format(' Potentially a hydrogen bond is formed between')
2141  format(10x,'Calculation of all hydrogen bonds',//,
     -  ' Each line describes a hydrogen bond, formed between ',
     -  ' acceptor A',/,' and donor H (bonded to the heavy atom D) ',
     -  'as follows:',/,5x,'Atom number, atom name, residue number, ',
     -  'residue name for donor atom H',/,
     -  5x,'Atom number, atom name, residue number, ',
     -  'residue name for acceptor atom A',/,
     -  5x,'Hydrogen bond length rHA; hydrogen bond angle D-H-A; and ',
     -  'distance rDA;',/,5x,'Hydrogen bond type X-Y, where X and Y ',
     -  'can be B, S, V, ?',/,5x,'indicating backbone, sidechain, ',
     -  'solvent or undetermined origin',/,
     -  ' For each hydrogen, only the two shortest bond will be ',
     -  'retained',/)
2142  format('   all ',a2,' atoms within',f6.2,' A of a hydrogen')
2143  format('   all ',a2,' atoms within',f6.2,' A of a water oxygen')
c2147  format(' WARNING: x and z cell change factors differ:',2f10.7,/,
c     -  10x,'Cell change may be anisotropic')
2148  format('Number of random points/cell=',i7,
     -  '    Correlation coefficient=',f6.3)
2149  format(/,' Distribution of the different SS elements:',/,
     -  (1x,a1,' : ',a))
2150  format(1x,'Residue #',9(4x,a1))
2151  format(i10,9i5)
2152  format('Number of colors ( <',i2,')')
2153  format(' Number of atoms used for ',a,' calculation:',i6,
     -  ' (out of',i6,')',a,' atom list:'/,(15i5))
2154  format(' All atoms are used for ',a,' calculation')
2155  format(i5,' RMSF',f6.2,' SD=',f6.2,' decide=',a)
2156  format(' NOTE: residue indices on the plot are residue SEQUENCE',
     -  ' numbers',/,7x,'- see the map to the reside and segment ',
     -  'numbers on the',/,7x,'output of the bond history calculation')
2157  format(' Number of frames read in a block=',i5)
2158  format(' Backbone ',a,' rn=',i5,' res=',a,i5,
     -  ' Atnos for CA, C, N=',3i6)
2159  format(' Specification of helix # ',i2)
2160  format(1x,a,'elix #',i2)
2161  format(' ERROR: number of data items (',i5,') exceeds limit (',
     -  i5,')',/,' - reduce the number of helices or increase the ',
     -  'parameter MAXCOPY1')
2162  format(a,' between helices ',i2,' and ',i2)
2163  format(' HX#',i3)
      end
      subroutine progress_rep(nframe,nframe2d,nframesign)
      nfr=max0(nframe,nframe2d)
      if (mod(nfr,nframesign) .eq. 0) then
        iperc=nfr/nframesign
        if (iperc .lt. 10) write (6,8099) iperc
      end if
8099  format(' Trajectory scan',i3,'0% done')
      end
      subroutine selectconf(numsel,ninconf,ifirst,increment,
     -  iconfsel,nextconfsel,nframeref,icsel,ifail,maxconfsel)
      dimension iconfsel(maxconfsel)
      if (numsel .eq. 0) then
        if (ninconf .ge. ifirst .and.
     -    mod(ninconf-ifirst,increment) .eq. 0) icsel=1
      else
c       See if this configuration is on the list
        if (ninconf .eq. iconfsel(nextconfsel)) then
          icsel=1
          nextconfsel=nextconfsel+1
        else if (ninconf .gt. iconfsel(numsel)) then
          if (nframeref .le. 1)
     -      write (6,2060) ninconf,iconfsel(numsel)
          ifail=1
        end if
      end if
      return
2060  format(' Structure read (',i9,') is beyond the last structure ',
     -  'requested:',i9,/,' Trajetory scan stopped')
      end
      subroutine torslistinp(ixtor1234,talab,ltalab,ntang,inpcrdtyp,
     -  ioins,line,index,n,nslt,iatnum,nneig,ineig,nhneig,ixres,
     -  ixresno,irescol1,irescol2,inamcol1,inamcol2,
     -  igl,maxng,maxrsd,maxrec,maxtors)
      dimension ixtor1234(4,maxtors),ltalab(maxtors)
      dimension nneig(n),ineig(maxng,n),iatnum(n),
     -  nhneig(n),index(n),ixres(maxrec),ixresno(maxrsd)
      character*30 talab(maxtors)
      character* 132 line(maxrec)
      character*1 ansrun
      character*4 atnami,atnamj
      character*8 resnam
      character*38 question
      call quiz(ansrun,iansrun,' ',' ',1,'torsion input list',18,0,
     -    5,6,igl,0)
      if (iansrun .lt. 5 .and. iansrun .ne. 3) then
        call askyn(
     -    'Do you want to include torsions moving hydrogens only',53,
     -    0,-1,nohrot,0)
      end if
      ic1=inamcol1
      ic2=inamcol2
      ir1=irescol1
      ir2=irescol2
      nrescol=ir2-ir1+1
      if (iansrun .lt. 5) then
        ntang=0
        do ia=1,nslt
          resnam(1:nrescol)=line(index(ia))(ir1:ir2)
          call leftadjust4(line(index(ia))(ic1:ic2),atnami)
          do j=1,nneig(ia)
            ja=ineig(j,ia)
            nhneig0=nhneig(ja)*nohrot
            if (ia .lt. ja .and. nneig(ia)-nhneig(ia) .gt. 1 .and.
     -          nneig(ja)-nhneig0 .gt. 1) then
              call leftadjust4(line(index(ja))(ic1:ic2),atnamj)
c             Bond ia-ja found (on a heavy atom chain when nohrot=1)
              call checktorbond(resnam,atnami,atnamj,fixbond,
     -          ipep,ican,icac,issb)
              ihfound=0
              if (iatnum(ia) .eq. 1 .or. iatnum(ja) .eq. 1) then
                write (6,2002) ia,resnam(1:nrescol),atnami,ja,
     -            line(index(ja))(ir1:ir2),atnamj
                ihfound=1
              end if
c             Loop and normal torsion stepsizes
              if (fixbond+ihfound .eq. 0) then
                dloop=30.0
                dtor=30.0
                if (iansrun .eq. 4
     -            .or. (iansrun .eq. 1 .and. ipep .eq. 0)
     -            .or. (iansrun .eq. 2 .and. ipep+ican+icac+issb .eq. 0)
     -            .or. (iansrun .eq. 3 .and. ican+icac .eq. 1)) then
                  if (ntang .eq. maxtors) then
                    write (6,1000) maxtors
                    go to 100
                  end if
                  ntang=ntang+1
c                 Bond ia-ja
                  do ii=1,nneig(ia)
                    iaa=ineig(ii,ia)
                    call leftadjust4(line(index(iaa))(ic1:ic2),atnami)
                    if (iatnum(iaa)*nohrot .ne. 1 .and.
     -                 (iansrun .ne. 3 .or. atnami .ne. 'CB  ')) then
                      do jj=1,nneig(ja)
                        jaa=ineig(jj,ja)
                        if (iatnum(jaa)*nohrot .ne. 1 .and.
     -                      jaa .ne. ia .and. iaa .ne. ja .and.
     -                      iaa .ne. jaa) then
                          ixtor1234(1,ntang)=iaa
                          ixtor1234(2,ntang)=ia
                          ixtor1234(3,ntang)=ja
                          ixtor1234(4,ntang)=jaa
                        end if
                      end do
                    end if
                  end do
                end if
              end if
            end if
          end do
        end do
100      print *,'Number of torsion angles generated=',ntang
      else
        call getint('Number of torsions to track',27,0,1,49,ntang,0)
        do it=1,ntang
8004      question='Angle   , atomindices ( 4 numbers )'
          nerr=0
          write (question(6:8),2043) it
          call getintline(question,35,1,nslt,ixtor1234(1,it),4,0)
          if (inpcrdtyp .le. ioins)
     -      write (6,2039) 'T',(ixtor1234(k,it),
     -        line(index(ixtor1234(k,it)))(inamcol1:inamcol2),
     -        line(index(ixtor1234(k,it)))(irescol1:irescol2),k=1,4)
c         print *,' ixtor:', (ixtor1234(k,it),k=1,4)
          nerr=0
          do k=2,4
            if (isbonded(ixtor1234(k-1,it),ixtor1234(k,it),
     -          nneig,ineig,n,maxng) .eq. 0) then
              write (6,2066) (ixtor1234(kk,it),kk=k-1,k),' NOT '
              nerr=nerr+1
            end if
          end do
          do k=3,4
            if (isbonded(ixtor1234(k-2,it),ixtor1234(k,it),
     -          nneig,ineig,n,maxng) .eq. 1) then
              write (6,2066) (ixtor1234(kk,it),kk=k-1,k),' '
              nerr=nerr+1
            end if
          end do
          if (isbonded(ixtor1234(1,it),ixtor1234(4,it),
     -        nneig,ineig,n,maxng) .eq. 1) then
            write (6,2066) ixtor1234(1,it),ixtor1234(4,it),' '
            nerr=nerr+1
          end if
          if (nerr .gt. 0) then
            call askyn('Do you want to use this angle',29,1,-1,iok,
     -        0)
            if (iok. eq. 0) go to 8004
          end if
        end do
      end if
      do it=1,ntang
        call blankout(talab(it),1,30)
        if (inpcrdtyp .le. ioins) write (talab(it),2069)
     -    (line(index(ixtor1234(k,it)))(inamcol1:inamcol1+3),k=1,3),
     -    line(index(ixtor1234(3,it)))(irescol1:irescol2),
     -    ixresno(ixres(ixtor1234(3,it))),
     -    line(index(ixtor1234(4,it)))(inamcol1:inamcol1+3)
        ltalab(it)=30
      end do
      return
1000  format(' ERROR: maximum number of torsions (',i4,') exceeded',/,
     -  'Redimension Simulaid with increased value of the parameter ',
     -  'MAXCOPY')
2002  format(' WARNING: bond ',i5,' (',a,1x,a,') - ',i5,' (',a,1x,a,
     -  ') inlcudes a hydrogen',/,
     -  10x,'Torsion dropped - check the solute geometry')
2043  format(i3)
2039  format(1x,a1,':',i5,' (',a,1x,a,')',3(' -',i5,' (',a,1x,a,')'))
2066  format(' WARNING: atoms',i6,' and',i6,' are',a,'bonded',/,
     -  ' You can create bonds with the Edit option')
2069  format(2(a4,'-'),a4,'(',a4,i5,')-',a4)
      end
      subroutine torsinp(nconfig,inpcrdtyp,itform,extnam,analfile,
     -  inpfile,namleni,line,index,n,nslt,c,iatnum,ifchrg,nneig,nneiga,
     -  nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,isegno,ixres,
     -  ibnd,indexo,naslv,islvw,innlist,molresflag,hblimfac,angmin,
     -  irescol1,irescol2,iresncol1,iresncol2,inamcol1,inamcol2,pi,
     -  radtodeg,maxrepconf,maxng,maxbox,maxrsd,maxrec)
      dimension nneig(n),ineig(maxng,n),iatnum(n),ifchrg(n),c(3,n),
     -  nhbneig(n),nneiga(n),nhneig(n),nnneig(n),ncneig(n),nsneig(n),
     -  npneig(n),index(n),indexo(n),isegno(n),ixres(n),
     -  molresflag(maxrsd),ibnd(maxbox,maxrec)
      character*1 ansrun
      character*4 extnam,lan(4),atnami,atnamj
      character*8 tname,resnam,rn
      character*200 inpfile,analfile
      character* 132 line(maxrec)
      character*2 iatnm2
      common /atnam/ aw(99),nval(99),nvalmax(99),mmofan(99),
     -  mmatno(64),iatnm2(99)
      character*11 trajformatname
      common /trajectory/ nmmccheck,iftrajtyp(6),trajformatname(6)
      character*200 trajnam,trajnam2
      common /trajname/ trajnam,trajnam2,ltrajnam,ltrajnam2
      character*4 namfcg
      character*4 tanames
      character*8 tnames
      common /tordat/ ntorn,tanames(4,28),tnames(28)
      common /connatdat/ ramax(99),ramax2(99),hlimfac,ianfg(99),
     -  namfcg(100),nrmw
      common /graphics/ igl,npixx,npixy,maxpixx,maxpixy,idwmain,idwplot,
     -  wx,wy,wz,wxdr
      common /rotmat/ matrot0(4,4),matrot(4,4),nomat0
      common /columnlim/ incol(17),iidcol(17),iialtcol(17),
     -  iinamcol(2,17),iirescol(2,17),iiccol(2,17),iiresncol(2,17),
     -  iiseqncol(2,17),iisegcol(2,17),iiresidcol(2,17),iiqcol(2,17),
     -  iipotcol(2,17),iiocccol(2,17),iichemcol(2,17)
      character*5 crdext
      common /iotypes/ iocha,iochaex,iobpdb,iocpdb,ioa3pdb,ioa4pdb,
     -  iommod,iommc,iommc4,iogro,iomol2,iomae,ioins,ionxyz,
     -  iosxyz,iosxyzrq,iograsp,iofull,lext(17),crdext(17)
      parameter (MAXHX=50)
      common /prokink/ icab(MAXHX),icaa(MAXHX),icb(MAXHX),ica(MAXHX),
     -  inb(MAXHX),ina(MAXHX),icapr,icpr,inpr,nra,nrb,icbpr,icgpr,icdpr,
     -  iprintpk
c     All arrays are of length maxframe
      parameter (MAXFRAMES=50000,MAXCOPY=600)
      parameter (MAXCOPY6=MAXCOPY-6)
      common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
     -  increment,increment2,bdxy(2,MAXFRAMES),wbxy(2,MAXFRAMES),
     -  fsxy(2,MAXFRAMES),wfsxy(2,MAXFRAMES),psxy(2,MAXFRAMES),
     -  turnpr(2,MAXFRAMES),scalardat(2,MAXFRAMES,MAXCOPY6),
     -  x0(MAXCOPY),y0(MAXCOPY),nxselres,ixselres(MAXCOPY)
C@GL#include <fgl.h>
C@GL#include <fdevice.h>
      nnamcol=inamcol2-inamcol1+1
      if (nconfig .eq. 1) then
        namleno=0
        call quiz(ansrun,iansrun,' ','syntax for',10,
     -    'torsion input generation',24,0,5,6,igl,0)
        if (ansrun .eq. 't') then
          itform=2
          extnam='.mmt'
        else if (ansrun .eq. 'p') then
          itform=3
          extnam='.mmp'
        else if (ansrun .eq. 'r') then
          itform=4
          extnam='.mcs'
        else if (ansrun .eq. 'i') then
          itform=5
          extnam='.mcp'
        else if (ansrun .eq. 'g') then
          itform=6
          extnam='.mcg'
        end if
c       if (extnam(2:3) .eq. 'mc') call askyn(
c    -      'Do you want to include torsions moving hydrogens only',53,
c    -      0,-1,nohrot,0)
        if (extnam(2:3) .eq. 'mc')
     -    call getint('Maximum number of terminal hydrogens to rotate',
     -      46,0,1,3,maxhrot,133)
        analfile=inpfile
        if (namleno .ne. 0) close (40)
        namleno=namleni
        analfile(namleno-3:namleno)=extnam
        call openfile(40,0,'analysis',8,'new',analfile,namleno,
     -    notfnd,0,1,1,0,0)
      else
        write (40,2055) nconfig
      end if
      ic1=inamcol1
      ic2=inamcol2
      ir1=iirescol(1,inpcrdtyp)
      ir2=iirescol(2,inpcrdtyp)
      nrescol=ir2-ir1+1
      call nnlist(nslt,islvw,naslv,n,iatnum,ifchrg,c,nneig,nneiga,
     -  nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,line,irescol1,
     -  irescol2,inamcol1,inamcol2,index,nconfig,innlist,molresflag,
     -  hblimfac,angmin,0,ibnd,indexo,isegno,ixres,maxrepconf,0,
     -  radtodeg,maxbox,maxng,maxrsd,maxrec)
      if (itform .ge. 4 .and. itform .le. 6) then
c       MMC protein torsion input
        if (nconfig .eq. 1) write (6,2001) 'MMC',analfile(1:namleno)
        ntorwr=0
        do ia=1,n
          if (iatnum(ia) .gt. 1 .and. nneig(ia) .gt. 1 .and.
     -      (nneig(ia)-nhneig(ia) .gt. 1 .or. nhneig(ia) .le. maxhrot))
     -      then
            resnam(1:nrescol)=line(index(ia))(ir1:ir2)
            call leftadjust4(line(index(ia))(ic1:ic2),atnami)
            do j=1,nneig(ia)
              ja=ineig(j,ia)
c             nhneig0=nhneig(ja)*nohrot
c             if (ia .lt. ja .and. nneig(ia)-nhneig(ia) .gt. 1 .and.
c    -            nneig(ja)-nhneig0 .gt. 1) then
              if (iatnum(ja) .gt. 1 .and. nneig(ja) .gt. 1 .and.
     -           ia .lt. ja .and. (nneig(ja)-nhneig(ja) .gt. 1 .or.
     -             nhneig(ja) .le. maxhrot))  then
                call leftadjust4(line(index(ja))(ic1:ic2),atnamj)
c               Bond ia-ja found (on a heavy atom chain when at most maxhrot
c               hydrogens are moved)
                call checktorbond(resnam,atnami,atnamj,fixbond,
     -            ipep,ican,icac,issb)
c               Loop and normal torsion stepsizes
                if (fixbond .eq. 0) then
                  dloop=30.0
                  dtor=30.0
                  if (itform .eq. 6 .or.
     -              (itform .eq. 4 .and. ipep+ican+icac+issb .eq. 0)
     -              .or. (itform .eq. 5 .and. ipep .eq. 0)) then
                    ntorwr=ntorwr+1
                    call readint(line(index(ia)),iresncol1,iresncol2,
     -                irna,2)
                    write (40,2051) ia,ja,dloop,dtor,ntorwr,
     -                irna,line(index(ia))(ir1:ir2),atnami,
     -                line(index(ja))(ir1:ir2),atnamj
                  end if
                end if
              end if
            end do
          end if
        end do
        if (nconfig .le. maxrepconf)
     -    print *,'Number of torsion angles written out=',ntorwr
      else
c       Macromodel torsion input
        if (nconfig .eq. 1)
     -    write (6,2001) 'Macromodel',analfile(1:namleno)
        ntorwr=0
        do ia=1,nslt
          do j=1,nneig(ia)
            ja=ineig(j,ia)
            if (ia .lt. ja) then
c             Bond ia-ja found
              do ii=1,nneig(ia)
                iaa=ineig(ii,ia)
                do jj=1,nneig(ja)
                  jaa=ineig(jj,ja)
                  if (jaa .ne. ia .and. iaa .ne. ja
     -                .and. iaa .ne. jaa) then
                    tors=dihangl(c,iaa,ia,ja,jaa,1,maxrec)*(180.0/pi)
                    tname='xxxxx'
                    if (inpcrdtyp .le. ioins) then
                      call leftadjust4(line(index(iaa))(ic1:ic2),lan(1))
                      call leftadjust4(line(index(ia))(ic1:ic2),lan(2))
                      call leftadjust4(line(index(ja))(ic1:ic2),lan(3))
                      call leftadjust4(line(index(jaa))(ic1:ic2),lan(4))
                      do i=1,ntorn
                        do k=1,4
                          if (lan(k) .ne. tanames(k,i)) go to 9011
                        end do
                        tname=tnames(i)
                        go to 9013
9011                    do k=1,4
                          if (lan(4-k+1) .ne. tanames(k,i)) go to 9012
                        end do
                        tname=tnames(i)
                        go to 9013
9012                    continue
                      end do
9013                  if (itform .eq. 3) then
c                       Protein, eliminate xxxxx, omega, and PRO phi,chi1,chi2
                        if (tname .eq. 'xxxxx' .or. tname .eq. 'omega')
     -                    then
                          tname='        '
                        else
                          resnam='        '
                          resnam(1:nrescol)=line(index(ia))(ir1:ir2)
                          call leftadjustn(resnam,rn,8)
                          if (rn .eq. 'PRO     ' .and.
     -                      (tname .eq. 'phi      ' .or.
     -                       tname .eq. 'chi1    '
     -                      .or. tname .eq. 'chi2    '))tname='        '
                        end if
                      end if
                      if (tname .ne. '        ') then
                        write (40,2053) iaa,ia,ja,jaa,tname,
     -                    line(index(iaa))(ic1:ic2),
     -                    line(index(iaa))(ir1:ir2),
     -                    line(index(ia))(ic1:ic2),
     -                    line(index(ia))(ir1:ir2),
     -                    line(index(ja))(ic1:ic2),
     -                    line(index(ja))(ir1:ir2),
     -                    line(index(jaa))(ic1:ic2),
     -                    line(index(jaa))(ir1:ir2),tors
                        ntorwr=ntorwr+1
                      end if
                    else
                      write (40,2054) iaa,ia,ja,jaa,tname
                      ntorwr=ntorwr+1
                    end if
                  end if
                end do
              end do
            end if
          end do
        end do
        if (nconfig .le. maxrepconf)
     -    print *,'Number of torsion angles written out=',ntorwr
        if (itform .eq. 3)
     -    print *,'Examine carefully if all the C and N terminal ',
     -    'torsions are present'
      end if
      return
2001  format(1x,a,' torsion input is written to ',a)
2051  format(2i5,2f10.4,i5,'    1       1.0     180.0 !',
     -  ' iresa=',i5,1x,a4,1x,a4,'-',a4,1x,a4)
2053  format(' ITOR',i8,3i7,'     0.0000   180.0000',23x,'!',a5,1x,
     -       3('(',a4,1x,a4,')-'),'(',a4,1x,a4,')',
     -  ' ta=',f7.1)
2054  format(' ITOR',i8,3i7,45x,a4)
2055  format(1x,79('-'),/,' Torsion input from configuration # ',i5)
      end
      subroutine gethbanchordef(line,index,nslt,ixres,iresno,
     -  iatnum,indexa,indexn,nanchor,ianchor,iiq1,iiq2,inpcrdtyp,
     -  iobpdb,iocpdb,bbats,nbbats,icharges,qmin,igl,iw0,irescol1,
     -  irescol2,inamcol1,inamcol2,resnames,brslv,nrescol,segid4,
     -  molsltlim,nsegslt,isegno,isc,label,llabel,ianchor2,iselfanc,
     -  nosamseg,iqfsel2,iquizhelp,ifail,maxrsd,maxrec,maxanchorlist)
      dimension index(maxrec),indexa(maxrec),indexn(maxrec),
     -  ixres(maxrec),iresno(maxrec),iatnum(maxrec),isc(maxrec),
     -  ianchor(maxanchorlist),molsltlim(3,maxrsd),isegno(maxrec)
      character*4 bbats(nbbats),segid4(nsegslt)
      character*8 resnames(maxrsd)
      character* 132 line(maxrec)
      character*(*) brslv,label
      character*4 atnam,bridgeats(200)
      character*1 ansrun
c     print *,'GETHBANCHORDEF maxanchorlist=',maxanchorlist
c     Establish solute atoms that are H-bond (chain) anchors
      nanchor=0
      iqsel=0
      iallsel=0
      qmin=0.0
9134  do while (.true.)
        call quiz(ansrun,iansrun,' ',label,llabel,'anchor atoms',12,
     -    0,5,6,igl,iquizhelp)
        ifail=0
        if (ansrun .eq. 'q') then
          go to 8000
        else if (ansrun .eq. 'a') then
c         Use all solute atoms
          iallsel=1
          if (nanchor .lt. maxanchorlist) then
            nanchor=nslt
          else
            write (6,2144) maxanchorlist,label(1:llabel)
            nanchor=maxanchorlist
            print *,'Only the first ',nanchor,' atoms will be anchors'
          end if
          call indexit(ianchor,1,nanchor,0)
          go to 8000
        else if (ansrun .eq. 'l') then
c         Input anchor list
          call getlist(indexn,nanchorr,1,nslt,1,maxanchorlist)
          call trnsfi(ianchor(nanchor+1),indexn,nanchorr)
          nanchor=nanchor+nanchorr
        else if (ansrun .eq. 'x') then
c         Input anchor range
          call getrange(ifirst,1,ilast,nslt,increment,0,
     -      'anchor atoms',12,nslt,0)
          nanchoradd=ilast-ifirst+1
          call indexit(ianchor,nanchor+1,nanchor+nanchoradd,
     -      ifirst-nanchor-1)
          nanchor=nanchor+nanchoradd
        else if (ansrun .eq. 'n' .or. ansrun .eq. 'r') then
c         Input anchor residue list or range
          if (nsegslt .gt. 1) then
            call getint('Segment number',14,1,1,nsegslt,iseganc,0)
            write (6,2143) segid4(iseganc),(molsltlim(i,iseganc),i=1,2)
          else
            iseganc=1
          end if
          ifss=molsltlim(1,iseganc)
          ilss=molsltlim(2,iseganc)
          if (ansrun .eq. 'n') then
c           Get list
            call getlist(indexn,nanchorres,ifss,ilss,1,maxanchorlist)
          else
c           Get range
            call getrange(ifirstres,iresno(ifss),ilastres,iresno(ilss),
     -        increment,0,'anchor residue',14,nslt,0)
            nanchorres=ilastres-ifirstres+1
            call indexit(indexn,1,nanchorres,ifirstres-1)
c            write (77,8711)ifirstres,iresno(ifss),ilastres,iresno(ilss),
c     -        (indexn(i),i=1,500)
c8711        format(' ifirstres,iresno(ifss),ilastres,iresno(ilss)=',4i5,
c     -        /,(20i4))
          end if
          nanchorr0=nanchor
          nanchorr=0
c         write (77,*) 'nanchor,nanchorres=',nanchor,nanchorres
          do ir=1,nanchorres
            iresanc=indexn(ir)
            call findrange(iresno,ifss,ilss,iresanc,ifsr,ilsr,'residue',
     -        7,ifail)
c           write (77,*) 'ir,ifsr,ilsr=',ir,ifsr,ilsr
            if (ifail .gt. 0) then
              write (6,2147) iresanc,ifss,ilss
            else
c             Add atoms ifsr - ilsr to the anchor list
              if (ilsr-ifsr+1+nanchor .gt. maxanchorlist) then
                print *,'Anchor list limit (',maxanchorlist,
     -            ') is reached'
                go to 9132
              else
c               Add atoms ifsr - ilsr to the anchor list
                natadd=ilsr-ifsr+1
c               write (77,*) 'nanchorr0,nanchorr,natadd=',
c    -            nanchorr0,nanchorr,natadd
                call indexit(ianchor,nanchorr0+nanchorr+1,
     -            nanchorr0+nanchorr+natadd,ifsr-nanchorr-1)
                nanchorr=nanchorr+natadd
c               write (77,8712) (ianchor(i),i=1,500)
c8712            format(' ianchor:',/,(20i4))
              end if
            end if
          end do
          nanchor=nanchor+nanchorr
        else if (ansrun .eq. 'b' .or. ansrun .eq. 't') then
          if (ansrun .eq. 'b') then
c           Select backbone atoms
            do i=1,nbbats
              bridgeats(i)=bbats(i)
            end do
            nbridgeats=nbbats
          else
c           Input atom name list
            call getnamelist(bridgeats,4,nbridgeats,'Anchor atom',11,
     -        200)
          end if
          write (6,7731) label(1:llabel),(bridgeats(i),i=1,nbridgeats)
          do ia=1,nslt
            if (resnames(ixres(ia))(1:nrescol) .ne.
     -          brslv(1:nrescol)) then
              atnam=line(index(ia))(inamcol1:inamcol1+3)
c             print *,'ia,atnam=',ia,atnam
              do it=1,nbridgeats
                if (atnam .eq. bridgeats(it)) then
c                 Anchor atom found
                  if (nanchor .lt. maxanchorlist) then
                    nanchor=nanchor+1
                    ianchor(nanchor)=ia
                    go to 9133
                  else
                    write (6,2144) maxanchorlist,label(1:llabel)
                    go to 9132
                  end if
                end if
              end do
9133          continue
            end if
          end do
        else
c         Select by partial charge
          iqsel=1
        end if
      end do
8000  call askyn('Do you want to omit protein backbone atoms',42,
     -    1,-1,iskipbb,0)
      iqfsel=0
      if (iqsel .eq. 0 .and. icharges .gt. 0) then
        call askyn('Do you want to filter the list by charge',40,
     -    1,-1,iqfsel,0)
      end if
      if (iskipbb+iqfsel .gt. 0) iallsel=0
      if (iqsel+iqfsel .gt. 0) then
        if (iiq1 .gt. iiq2) then
          print *,'This input format has no charge information'
          go to 9134
        end if
        if (ischarmm(inpcrdtyp) .eq. 1)
     -    print *,'Charges are read from the WEIGHT column'
        if (inpcrdtyp .eq. iobpdb .or. inpcrdtyp .eq. iocpdb) print *,
     -    'Charges are read from the TEMPERATURE FACTOR column'
        call getreal('Minimum (absolute) charge for an anchor atom',44,
     -    999999.0,qmin,1,0)
        call zeroiti(indexa,0,nslt)
        nzrq=0
        qsum=0.0
        do ia=1,nslt
          if (resnames(ixres(ia))(1:nrescol) .ne.
     -        brslv(1:nrescol)) then
            call readreal(line(index(ia)),iiq1,iiq2,qa)
            if (qa .eq. 0.0) nzrq=nzrq+1
            qsum=qsum+qa
            if (qa .lt. -qmin .or.
     -        (qa .gt. qmin .and. iatnum(ia) .eq. 1)) indexa(ia)=-1
          end if
        end do
        if (nzrq .eq. nslt) then
          print *,'Input structure had all zero charges'
          write (6,2145)
          go to 9134
        else
          print *,'Sum of solute charges read=',qsum
          if (nslt .gt. 10 .and. abs(qsum) .gt. alog(float(nslt)))
     -      write (6,2145)
        end if
        if (iqsel .eq. 1) then
c         Select from all solute atoms
          do ia=1,nslt
            if (indexa(ia) .eq. -1) then
              if (nanchor .lt. maxanchorlist) then
                nanchor=nanchor+1
                ianchor(nanchor)=ia
              else
                write (6,2144) maxanchorlist,label(1:llabel),' ',ia
                go to 9132
              end if
            end if
          end do
        else
c         Reduce list
          do iaa=1,nanchor
            if (indexa(ianchor(iaa)) .eq. 0) ianchor(iaa)=0
          end do
          ndel=0
          do ia=1,nanchor
            if (ianchor(ia) .eq. 0) then
              ndel=ndel+1
            else
              ianchor(ia-ndel)=ianchor(ia)
            end if
          end do
          nanchor=nanchor-ndel
          print *,'Number of anchor atoms filtered out=',ndel
          if (nanchor .eq. 0 .and. ndel .gt. 0) then
            print *,'PROBLEM: No anchor atoms were left after filtering'
            call askyn('Do you want to repeat the selection',35,
     -        1,+1,iselrep,0)
            if (iselrep .eq. 1) go to 9134
            ifail=1
            return
          end if
        end if
      end if
      write (iw0,*) label(1:llabel),' anchor atoms:'
      if (nanchor .gt. maxanchorlist) then
        write (6,2144) maxanchorlist,label(1:llabel),' ',ia
      end if
      if (iskipbb .gt. 0) then
        ndel=0
        do ia=1,nanchor
          ib=ianchor(ia)
          if (isc(ib) .eq. 0) then
c           BB atom - skip
            ndel=ndel+1
          else
             ianchor(ia-ndel)=ianchor(ia)
          end if
        end do
        if (ndel .gt. 0) then
          nanchor=nanchor-ndel
          write (6,2148) ndel,nanchor
          write (iw0,2148) ndel,nanchor
        end if
      end if
      do ia=1,nanchor
        ib=ianchor(ia)
        indexa(ib)=1
        write (iw0,2146) ia,line(index(ib))(irescol1:irescol2),
     -    iresno(ib),segid4(isegno(ib)),
     -    line(index(ib))(inamcol1:inamcol2),ib
      end do
      iqfsel2=0
      if (iqsel+iqfsel .gt. 0)
     -  call askyn(
     -    'Do you want to apply the charge filter to all atoms',51,
     -    1,+1,iqfsel2,0)
      call getanchormod(ianchor2,iselfanc,nosamseg,iallsel)
      return
9132  if (nanchor .eq. 0) then
        print *,'PROBLEM: No anchor atoms were found'
        call askyn('Do you want to repeat the selection',35,
     -    1,+1,iselrep,0)
        if (iselrep .eq. 1) go to 9134
        ifail=1
        return
      end if
      return
2143  format(' Segment ',a,' atom range [',i6,',',i6,') selected')
2144  format(' Progam is limited to ',i5,1x,a,' anchor ',
     -  'atoms.',/,' Redimension or break up the run ',a,/,
     -  ' Last solute atom used is the ',i6,'-th')
2145  format(' Most likely, the charge field does not contain the ',
     -  'charges')
2146  format(i5,' Residue=',a,' (',i5,') Chain/seg=',a,' Atom=',a,
     -  ' (',i6,')')
2147  format(' Residue',i6,' is not found in atom range [',i6,' - ',i6,
     -  '] - ignored')
2148  format(' Number of backbone atoms filtered out=',i5,/,
     -  ' Number of anchor atom left=',i5)
7731  format(1x,a,' anchor atom names:',/,(10(a4,1x)))
      end
      subroutine gethphanchordef(line,index,nslt,iresno,iatnum,
     -  indexa,indexn,indexo,nneig,ineig,nhneig,nhneigmin,nanchor,
     -  ianchor,ianchor2,iselfanc,nosamseg,iallheavy,iiq1,iiq2,
     -  inpcrdtyp,iobpdb,iocpdb,icharges,igl,iw0,irescol1,irescol2,
     -  inamcol1,inamcol2,segid4,molsltlim,nsegslt,isegno,ifail,maxneig,
     -  maxrec,maxanchorlist)
      dimension index(maxrec),indexa(maxrec),indexn(maxrec),
     -  indexo(maxrec),iresno(maxrec),iatnum(maxrec),
     -  ianchor(maxanchorlist),nneig(maxrec),ineig(maxneig,maxrec),
     -  nhneig(maxrec),molsltlim(3,nsegslt),isegno(maxrec)
      character*4 segid4(nsegslt)
      character* 132 line(maxrec)
      character*1 ansrun
c     Establish solute atoms that are hydrophobic bond  anchors
c     print *,'GETHPHANCHOR maxrec,maxanchorlist=',
c    -         maxrec,maxanchorlist
      nanchor=0
      iqsel=0
      qmin=0.0
      call zeroiti(indexa,0,nslt)
      nanchorr=0
      iall=1
9134  do while (.true.)
        call quiz(ansrun,iansrun,' ',' ',1,
     -    'hydrophobic/contact anchors',27,0,5,6,igl,75)
        ifail=0
        if (ansrun .eq. 'q') then
          if (nanchorr .eq. 0) then
            print *,'No selection was made - all eligible atoms will ',
     -        'be used'
            call indexit(indexn,1,nslt,0)
            nanchorr=nslt
          end if
          go to 8000
        else if (ansrun .eq. 'a') then
c         Use all eligible solute atoms
          call indexit(indexn,1,nslt,0)
          nanchorr=nslt
          go to 8000
        else if (ansrun .eq. 'l') then
c         Input anchor list
          call getlist(indexo,nanchoradd,1,nslt,1,maxanchorlist)
          call trnsfi(indexn(nanchorr+1),indexo,nanchoradd)
          nanchorr=nanchorr+nanchoradd
          iall=0
        else if (ansrun .eq. 'x') then
c         Input anchor range
          call getrange(ifirst,1,ilast,nslt,increment,0,
     -      'anchor atoms',12,nslt,0)
          nanchoradd=ilast-ifirst+1
          call indexit(indexn,nanchorr+1,nanchorr+nanchoradd,ifirst-1)
          nanchorr=nanchorr+nanchoradd
          iall=0
        else if (ansrun .eq. 'n' .or. ansrun .eq. 'r') then
c         Input anchor residue list or range
          if (nsegslt .gt. 1) then
            call getint('Segment number',14,1,1,nsegslt,iseganc,0)
            write (6,2143) segid4(iseganc),(molsltlim(i,iseganc),i=1,2)
          else
            iseganc=1
          end if
          ifss=molsltlim(1,iseganc)
          ilss=molsltlim(2,iseganc)
c         Input anchor residue list or range
          if (ansrun .eq. 'n') then
c           Get list
            call getlist(indexo,nanchorres,ifss,ilss,1,maxanchorlist)
          else
c           Get range
            call getrange(ifirstres,iresno(ifss),ilastres,iresno(ilss),
     -        increment,0,'anchor residue',14,nslt,0)
            nanchorres=ilastres-ifirstres+1
            call indexit(indexo,1,nanchorres,ifirstres-1)
          end if
          do ir=1,nanchorres
            iresanc=indexo(ir)
            call findrange(iresno,ifss,ilss,iresanc,ifsr,ilsr,'residue',
     -        7,ifail)
            if (ifail .gt. 0) then
              write (6,2147) iresanc,ifss,ilss
            else
c             Add atoms ifsr - ilsr to the anchor list
c             print *,'ir=',ir,' adding ',ifsr,' - ',ilsr
              natadd=ilsr-ifsr+1
              call indexit(indexn,nanchorr+1,nanchorr+natadd,
     -          ifsr-nanchorr-1)
              nanchorr=nanchorr+natadd
            end if
          end do
c         print *,'total number added to indexn=',nanchorr
          iall=0
        end if
      end do
8000  iqfsel=0
      if (icharges .gt. 0)
     -  call askyn('Do you want to filter the list by charge',40,
     -    1,-1,iqfsel,0)
      if (iqfsel .gt. 0) then
        if (iiq1 .gt. iiq2) then
          print *,'This input format has no charge information'
          iqfsel=0
        end if
        if (iqfsel.gt. 0) then
          if (ischarmm(inpcrdtyp) .eq. 1)
     -      print *,'Charges are read from the WEIGHT column'
          if (inpcrdtyp .eq. iobpdb .or. inpcrdtyp .eq. iocpdb) print *,
     -      'Charges are read from the TEMPERATURE FACTOR column'
          call getreal('Maximum (absolute) charge for an anchor atom',
     -      44,999999.0,qmax,1,0)
          iall=0
        end if
      end if
      if (iallheavy .eq. 1) then
c       indexa will be nonzero for heavy atoms, negative if not an anchor
        do ia=1,nslt
          if (iatnum(ia) .ne. 1) indexa(ia)=-1
        end do
      else
c       indexa will be nonzero for hydrophobic carbons, negative if not anchor
8010    nhpc=0
        do ia=1,nslt
          if (iatnum(ia) .eq. 6 .and. nhneig(ia) .ge. nhneigmin) then
            indexa(ia)=-1
            nhpc=nhpc+1
          end if
        end do
        if (nhneigmin .gt. 0 .and. nhpc .eq. 0) then
          print *,'No H bonded to C was found'
          call askyn('Do you want to just use all carbons',35,1,+1,i0,0)
          if (i0 .eq. 1) then
            nhneigmin=0
            go to 8010
          else
            ifail=1
            return
          end if
        end if
        icofil=0
        if (iallheavy .eq. 0)
     -    call askyn('Do you want to filter out >C=O and C-OH carbons',
     -      47,1,+1,icofil,0)
        if (icofil .gt. 0) then
          do ia=1,nslt
            if (indexa(ia) .lt. 0) then
              idrop=0
              do in=1,nneig(ia)
                inc=ineig(in,ia)
                if (iatnum(inc) .eq. 8) then
                  if (nneig(inc) .eq. 1 .or. nhneig(inc) .gt. 0) idrop=1
                end if
              end do
              if (idrop .eq. 1) indexa(ia)=0
            end if
          end do
        end if
      end if
      do ja=1,nanchorr
        ia=indexn(ja)
c       print *,'Anchor #',ja,'=',ia,' indexa(ia)=',indexa(ia),
c    -    ' iatnum(ia)=',iatnum(ia)
        if (indexa(ia) .ne. 0) then
          iasel=1
          if (iqfsel .gt. 0) then
            call readreal(line(index(ia)),iiq1,iiq2,qa)
            if (qa .lt. -qmax .or. qa .gt. qmax) iasel=0
          end if
          if (iasel .gt. 0) then
            indexa(ia)=-indexa(ia)
            if (nanchor .eq. maxanchorlist) then
              print *,'Anchor list limit (',maxanchorlist,
     -          ') is reached'
              nanchorr=ja
            else
              nanchor=nanchor+1
              ianchor(nanchor)=ia
            end if
          end if
        else if (ansrun .eq. 'l' .and. iallheavy .eq. 0) then
          print *,'NOTE: atom ',ia,' is not a hydrophobic carbon'
        end if
      end do
      if (nanchor .eq. 0) then
        print *,'PROBLEM: No anchor atoms were found'
        call askyn('Do you want to repeat the selection',35,
     -    1,+1,iselrep,0)
        if (iselrep .eq. 1) go to 9134
        ifail=1
        return
      end if
      write (iw0,*) 'Anchor atoms:'
      do ia=1,nanchor
        ib=ianchor(ia)
        write (iw0,2146) ia,line(index(ib))(irescol1:irescol2),
     -    iresno(ib),segid4(isegno(ib)),
     -    line(index(ib))(inamcol1:inamcol2),ib
      end do
      call getanchormod(ianchor2,iselfanc,nosamseg,iall)
      return
2143  format(' Segment ',a,' atom range [',i6,',',i6,') selected')
2146  format(i5,' Residue=',a,' (',i5,') Chain/seg=',a,' Atom=',a,
     -  ' (',i6,')')
2147  format(' Residue',i6,' is not found in atom range [',i6,' - ',i6,
     -  '] - ignored')
      end
      subroutine getsltbanchordef(line,index,nslt,iresno,iatnum,
     -  indexa,indexn,indexo,nhneig,ineig,nanchor,ianchor,ianchor2,
     -  iselfanc,nosamseg,iiq1,iiq2,inpcrdtyp,iobpdb,iocpdb,
     -  igl,iw0,irescol1,irescol2,inamcol1,inamcol2,segid4,molsltlim,
     -  nsegslt,isegno,ifail,maxneig,maxrec,maxanchorlist)
      dimension index(maxrec),indexa(maxrec),indexn(maxrec),
     -  indexo(maxrec),iresno(maxrec),iatnum(maxrec),
     -  ianchor(maxanchorlist),nhneig(maxrec),ineig(maxneig,maxrec),
     -  molsltlim(3,nsegslt),isegno(maxrec)
      character*4 segid4(nsegslt)
      character* 132 line(maxrec)
      character*1 ansrun
      character*8 saltatname(100),atnam
c     Establish solute atoms that are hydrophobic bond  anchors
c     print *,'GETHPHANCHOR maxneig,maxrec,maxanchorlist=',
c    -         maxneig,maxrec,maxanchorlist
      nsaltats=0
      qmin=0.0
      call zeroiti(indexa,0,nslt)
      call quiz(ansrun,iansrun,' ',' ',1,
     -  'salt-bridge definition mode',27,0,5,6,igl,0)
      if (ansrun .eq. 'c' .or. ansrun .eq. 'b') then
c       Atom selection by charge
        if (iiq1 .gt. iiq2) then
          print *,'This input format has no charge information'
        else
          if (ischarmm(inpcrdtyp) .eq. 1)
     -      print *,'Charges are read from the WEIGHT column'
          if (inpcrdtyp .eq. iobpdb .or. inpcrdtyp .eq. iocpdb) print *,
     -      'Charges are read from the TEMPERATURE FACTOR column'
          call getreal('Minimum (absolute) charge for an anchor atom',
     -      44,999999.0,qmin,1,0)
          do ia=1,nslt
            if (iatnum(ia) .ne. 1) then
              call readreal(line(index(ia)),iiq1,iiq2,qa)
              do in=1,nhneig(ia)
                call readreal(line(index(ineig(in,ia))),iiq1,iiq2,qh)
                qa=qa+qh
              end do
              if (abs(qa) .ge. qmin) then
                indexa(ia)=-1
                nsaltats=nsaltats+1
              end if
            end if
          end do
        end if
      end if
      if (ansrun .eq. 'l' .or. ansrun .eq. 'b') then
c       Atom selection by name
        lname=inamcol2-inamcol1+1
        call getnamelist(saltatname,lname,nsaltats,
     -    'Salt-bridge forming atom names',30,100)
        do ia=1,nslt
          atnam=line(index(ia))(inamcol1:inamcol2)
          call leftadjustn(atnam,atnam,8)
          do in=1,nsaltats
            if (atnam(1:lname) .eq. saltatname(in)(1:lname)) then
              if (indexa(ia) .eq. 0) then
                nsaltats=nsaltats+1
                indexa(ia)=-1
              end if
            end if
          end do
        end do
      end if
      if (nsaltats .eq. 0) then
        print *,'Solute contains no salt-bridge atoms'
        ifail=1
        return
      else
c       Replace hydrogens with their heavy atom
        ndel=0
        do ia=1,nsaltats
          if (indexa(ia) .eq. -1) then
            if (iatnum(ia) .eq. 1) then
              iah=ineig(1,ia)
              if (indexa(iah) .eq. 0) then
                indexa(iah)=-1
              else
                ndel=ndel+1
              end if
              indexa(ia)=0
            end if
          end if
        end do
        nsaltats=nsaltats-ndel
        write (6,2142) nsaltats
        write (iw0,2142) nsaltats
      end if
      nanchorr=0
      call zeroiti(indexn,0,nslt)
      iall=1
9134  do while (.true.)
        call quiz(ansrun,iansrun,' ',' ',1,'salt-bridge anchors',19,
     -    0,5,6,igl,75)
        ifail=0
        if (ansrun .eq. 'q') then
          go to 8000
        else if (ansrun .eq. 'a') then
          call indexit(indexn,1,nslt,0)
          nanchorr=nslt
          go to 8000
        else if (ansrun .eq. 'l') then
c         Input anchor list
          call getlist(indexo,nanchoradd,1,nslt,1,maxanchorlist)
          call trnsfi(indexn(nanchorr+1),indexo,nanchoradd)
          nanchorr=nanchorr+nanchoradd
          iall=0
        else if (ansrun .eq. 'n' .or. ansrun .eq. 'r') then
c         Input anchor residue list or range
          if (nsegslt .gt. 1) then
            call getint('Segment number',14,1,1,nsegslt,iseganc,0)
            write (6,2143) segid4(iseganc),(molsltlim(i,iseganc),i=1,2)
          else
            iseganc=1
          end if
          ifss=molsltlim(1,iseganc)
          ilss=molsltlim(2,iseganc)
          if (ansrun .eq. 'n') then
c           Get list
            call getlist(indexo,nanchorres,ifss,ilss,1,maxanchorlist)
          else
c           Get range
            call getrange(ifirstres,iresno(ifss),ilastres,iresno(ilss),
     -        increment,0,'anchor residue',14,nslt,0)
            nanchorres=ilastres-ifirstres+1
            call indexit(indexo,1,nanchorres,ifirstres-1)
          end if
          do ir=1,nanchorres
            iresanc=indexo(ir)
            call findrange(iresno,ifss,ilss,iresanc,ifsr,ilsr,'residue',
     -        7,ifail)
            if (ifail .gt. 0) then
              write (6,2147) iresanc,ifss,ilss
            else
c             Add atoms ifsr - ilsr to the anchor list
              natadd=ilsr-ifsr+1
              call indexit(indexn,nanchorr+1,nanchorr+natadd,
     -          nanchorr+1-ifsr)
              nanchorr=nanchorr+natadd
            end if
          end do
          iall=0
        end if
      end do
8000  nanchor=0
      do ja=1,nanchorr
        ia=indexn(ja)
        if (ia .gt. 0) then
          if (indexa(ia) .lt. 0) then
            indexa(ia)=1
            nanchor=nanchor+1
          end if
        end if
      end do
      if (nanchor .eq. 0) then
        print *,'PROBLEM: No anchor atoms were found'
        call askyn('Do you want to repeat the selection',35,
     -    1,+1,iselrep,0)
        if (iselrep .eq. 1) go to 9134
        ifail=1
        return
      end if
      write (iw0,*) 'Salt-bridge anchor atoms:'
      ia=0
      if (nanchor .gt. maxanchorlist) then
        print *,'Anchor list limit (',maxanchorlist,') is reached'
        ifail=1
      end if
      do ib=1,nslt
        if (indexa(ib) .gt. 0) then
          ia=ia+1
          ianchor(ia)=ib
          write (iw0,2146) ia,line(index(ib))(irescol1:irescol2),
     -      iresno(ib),segid4(isegno(ib)),
     -      line(index(ib))(inamcol1:inamcol2),ib
        end if
      end do
      if (ia .ne. nanchor) then
        print *,'PRORAM ERROR: ia=',ia,' nanchor=',nanchor
      end if
      ianchor2=0
      if (iall .eq. 0)
     -  call askyn('Do you want anchor atoms at both ends',37,1,-1,
     -    ianchor2,71)
      iselfanc=0
      if (ianchor2 .eq. 2)
     -  call askyn('Do you want exclude anchor-anchor bonds',39,0,-1,
     -    iselfanc,000)
      call getanchormod(ianchor2,iselfanc,nosamseg,iall)
      return
2142  format(' Number of salt-bridge forming atoms=',i4)
2143  format(' Segment ',a,' atom range [',i6,',',i6,') selected')
2146  format(i5,' Residue=',a,' (',i5,') Chain/seg=',a,' Atom=',a,
     -  ' (',i6,')')
2147  format(' Residue',i6,' is not found in atom range [',i6,' - ',i6,
     -  '] - ignored')
      end
      subroutine getanchormod(ianchor2,iselfanc,nosamseg,iallsel)
      if (iallsel .eq. 0) then
        call askyn(
     -    'Do you want anchor atoms at both ends',37,1,-1,ianchor2,71)
        iselfanc=1
        if (ianchor2 .eq. 0)
     -    call askyn('Do you want exclude anchor-anchor bonds',39,0,-1,
     -      iselfanc,000)
      else
        ianchor2=0
        iselfanc=1
      end if
      call askyn('Do you want exclude intra segment/chain bonds',45,1,
     -  -1,nosamseg,000)
      return
      end
c      subroutine namestolist(index,line,nslt,ifres,ilres,numresslt,
c     -  namelist,nnamelist,list,nlist,maxlist,inamcol1,ierr,iout,label,
c     -  llabel,maxrec)
c      dimension index(nslt),ifres(numresslt),ilres(numresslt),list(nslt)
c      character*(*) label
c      character*132 line(maxrec)
c      character*4 atnam
c      character*4 namelist(nnamelist)
cc     print *,'NAMESTOLIST iout=',iout
c      ierr=0
c      nlist=0
c      do ir=1,numresslt
c        do ia=ifres(ir),ilres(ir)
c          atnam=line(index(ia))(inamcol1:inamcol1+3)
c          call leftadjust4(atnam,atnam)
cc         print *,'ia,atnam=',ia,atnam
c          do it=1,nnamelist
c            if (atnam .eq. namelist(it)) then
cc             Atom found
c              if (nlist .lt. maxlist) then
c                nlist=nlist+1
c                list(nlist)=ia
c                go to 100
c              else
c                write (6,1000) maxlist,label(1:llabel)
c                ierr=1
c                return
c              end if
c            end if
c          end do
c100       continue
c        end do
c      end do
c      print *,'Number of atoms selected=',nlist
c      write (iout,1001) label(1:llabel),(i,list(i),
c     -  line(index(list(i)))(inamcol1:inamcol1+3),i=1,nlist)
c      return
c1000  format('List limit (',i8,') is reached. Name list generation ',
c     -  'failed',/,' Recompile Simulaid with larger MAXBRIDGEATOMS')
c1001  format(' List of ',a,':',/,(i6,i8,a))
c      end
      subroutine extend_nnlist(nneig,ineig,n14neig,nslt,maxng,maxrec)
      dimension nneig(maxrec),n14neig(maxrec),ineig(maxng,maxrec)
      call getint('Minimum number of chemical bond to separate',43,
     -  3,1,4,nbondsep,118)
      do ia=1,nslt
        n14neig(ia)=nneig(ia)
        nnprevlev=0
        if (nbondsep .gt. 2) then
          nerr=0
          do lev=1,nbondsep-2
c           Include (lev+1)th neighbors to the excluded list
            len=n14neig(ia)
            do in=nnprevlev+1,len
              inn=ineig(in,ia)
              do in2=1,nneig(inn)
                inn2=ineig(in2,inn)
c               Check for duplicates
                ifound=0
                do iaa=1,len
                  if (inn2 .eq. ia .or. ineig(iaa,ia) .eq. inn2)
     -              ifound=1
                end do
                if (ifound .eq. 0) then
                  if (n14neig(ia) .lt. maxng) then
                    n14neig(ia)=n14neig(ia)+1
                    ineig(n14neig(ia),ia)=inn2
                  else
                    write (6,1000) ia,maxng
                    nerr=nerr+1
                  end if
                end if
              end do
            end do
            nnprevlev=len
          end do
        end if
      end do
      return
1000  format(' ERROR: number of 1-3 or 1-4 neighbors of atom ',i6,
     -  'exeeds limit (',i3,')',/,
     -  8x,'- recompile with increased MAXNEIG')
      end
      subroutine checktorbond(resnami,atnami,atnamj,fixbond,
     -  ipep,ican,icac,issb)
      character*4 atnami,atnamj
      character*8 resnami,resnam
c     Check for small loops
      fixbond=0
      call leftadjustn(resnami,resnam,8)
      if (resnam(1:3) .eq. 'HIS' .or. resnam(1:3) .eq. 'HSE' .or.
     -    resnam(1:3) .eq. 'HSD' .or. resnam(1:3) .eq. 'HSP' .or.
     -    resnam(1:3) .eq. 'HID') then
        if (atnami(1:3) .eq. 'CD2' .or. atnami(1:3) .eq. 'NE2'
     -  .or. atnami(1:3) .eq. 'CE1' .or. atnami(1:3) .eq. 'ND1')
     -     fixbond=1
        if (atnami(1:3) .eq. 'CG ' .and. atnamj(1:3) .ne. 'CB ')
     -     fixbond=1
      else if (resnam(1:3) .eq. 'PRO') then
        if (atnami(1:3) .eq. 'CD ' .or. atnami(1:3) .eq. 'CB '
     -  .or. atnami(1:3) .eq. 'CG ') fixbond=1
        if ((atnami .eq. 'N   ' .and. atnamj .ne. 'C   ') .or.
     -      (atnami .eq. 'CA  ' .and. atnamj .ne. 'C   '))
     -    fixbond=1
      else if (resnam(1:3) .eq. 'PHE') then
        if (atnami(1:2) .eq. 'CE' .or. atnami(1:2) .eq. 'CD'
     -  .or. atnami(1:2) .eq. 'CZ')  fixbond=1
        if (atnami(1:3) .eq. 'CG ' .and. atnamj(1:3) .ne. 'CB ')
     -     fixbond=1
      else if (resnam(1:3) .eq. 'TYR') then
        if (atnami(1:2) .eq. 'CE' .or. atnami(1:2) .eq. 'CD')
     -    fixbond=1
        if (atnami(1:2) .eq. 'CZ' .and. atnamj(1:2) .ne. 'OH')
     -      fixbond=1
        if (atnami(1:3) .eq. 'CG ' .and. atnamj(1:3) .ne. 'CB ')
     -     fixbond=1
      else if (resnam(1:3) .eq. 'TRP') then
        if (atnami(1:2) .eq. 'CE' .or. atnami(1:2) .eq. 'CD'
     -  .or. atnami(1:2) .eq. 'CZ' .or. atnami(1:2) .eq. 'CH'
     -   .or. atnami(1:2) .eq. 'NE')  fixbond=1
        if (atnami(1:3) .eq. 'CG ' .and. atnamj(1:3) .ne. 'CB ')
     -     fixbond=1
      else if (resnam(1:3) .eq. 'ARG') then
        if (atnami(1:2) .eq. 'NE' .and. atnamj(1:2) .eq. 'CZ' .or.
     -      atnami(1:2) .eq. 'CZ' .and. atnamj(1:2) .eq. 'NH') fixbond=1
      end if
      if (fixbond .eq. 0) then
        ipep=0
        ican=0
        icac=0
        issb=0
        if ((atnami .eq. 'C      ' .and. atnamj .eq. 'N      ') .or.
     -    (atnamj .eq. 'C      ' .and. atnami .eq. 'N      ')) ipep=1
        if ((atnami .eq. 'CA     ' .and. atnamj .eq. 'N      ') .or.
     -    (atnamj .eq. 'CA     ' .and. atnami .eq. 'N      ')) ican=1
        if ((atnami .eq. 'CA     ' .and. atnamj .eq. 'C      ') .or.
     -    (atnamj .eq. 'CA     ' .and. atnami .eq. 'C      ')) icac=1
        if (atnami .eq. 'SG     ' .and. atnamj .eq. 'SG     ')  issb=1
       end if
      return
      end
      subroutine getatnumlist(n,iatnum,ifchrg,ialist,icatlist,ixlist,
     -  nanos)
      dimension iatnum(n),ifchrg(n),ixlist(99),ialist(15),icatlist(15)
c     Get a list of atomic numbers that occured in this system
      call zeroiti(ixlist,0,99)
      call zeroiti(icatlist,0,15)
      nanos=0
      do i=1,n
        ifound=0
        do j=1,nanos
          if (iatnum(i) .eq. ialist(j)) then
            ifound=1
            go to 9031
          end if
        end do
9031    if (ifound .eq. 0) then
          if (nanos .lt. 15) then
            nanos=nanos+1
            ialist(nanos)=iatnum(i)
            ixlist(iatnum(i))=nanos
            icatlist(nanos)=ifchrg(i)
          else
            print *,'ERROR: Number of different elements exceeds',
     -        ' 15 - redimension the program'
            stop
          end if
        end if
      end do
c      write (6,7712) 'ialist',(ialist(i),i=1,nanos)
c      write (6,7712) 'icatlist',(icatlist(i),i=1,nanos)
c7712  format(1x,a,'=',15i3)
      return
      end
      subroutine printbondthres(ialist,nalist,ctfac,bondminfac,
     -  iatnm2,ramax,iout)
      dimension ialist(nalist)
      character*2 iatnm2(99)
      dimension ramax(99)
      write (iout,1003)
      write (iout,1002) (ialist(i),iatnm2(ialist(i)),i=1,nalist)
      do i=1,nalist
        do j=i,nalist
          call decidebondcut(ialist(i),ialist(j),rlim)
          write (iout,1000) iatnm2(ialist(i)),iatnm2(ialist(j)),
     -      sqrt(rlim),iatnm2(ialist(i)),ramax(ialist(i)),
     -      iatnm2(ialist(j)),ramax(ialist(j))
          if (ctfac .gt. 0.0)
     -      write (iout,1001) sqrt(rlim*ctfac),sqrt(rlim*bondminfac)
        end do
      end do
      return
1000  format(1x,a2,' - ',a2,' bondlength threshold=',f5.3,
     - 2(' ramax(',a2,')=',f5.3))
1001  format(9x,'clash threshold=',f5.3,
     -  ' minimum acceptable bondlength=',f5.3)
1002  format(' Atoms used: ',15(i3,1x,a2))
1003  format(' Bond threshold for heavy atoms: max(ramax(i),ramax(j))',
     -  /,' Bond threshold with hydrogen: 0.7*max(ramax(i),ramax(j))')
      end
      subroutine findresnum(iresno,ixres,ir,ifirst,ilast,iafound,
     -  irfound)
      dimension iresno(ilast),ixres(ilast)
c     Find the residue sequence number of residue number ir
c     print *,'if,il=',ifirst,ilast
      ia=ifirst
      do while (iresno(ia) .ne. ir .and. ia .le. ilast)
        ia=ia+1
      end do
      if (ia .gt. ilast) then
        write (6,1000) ir,ifirst,ilast
        ir=0
      end if
      iafound=ia
      irfound=ixres(ia)
      return
1000  format(' ERROR: residue number',i6,' is not found in atom range',
     - i7,' - ',i7)
      end
      subroutine getresrange(nsegm,indexs,isegno,ixres,iresno,ifres,
     -  label,llabel,numres,nslt,ires1save,ires2save,isegdef,iseg1,
     -  iseg2,listres,listlen,nrange,idefall,ionerange,maxrsd,maxrec,
     -  ihelp)
      dimension indexs(maxrec),isegno(maxrec),ixres(maxrec),
     -  iresno(maxrec),ifres(maxrsd),listres(maxrsd)
      character*(*) label
      common /logging/ logfile,ipredict
      character*80 line
c     print *,'GETRESRANGE nslt,numres=',nslt,numres
      listlen=0
      nrange=0
      do while (.true.)
        if (nsegm .eq. 1 .and. ipredict .eq. 0) then
          call reverseindex(indexs,iresno,ifres,1,numres,maxrec)
9156      call getrange(ires1i,iresno(1),ires2i,
     -      iresno(nslt),incr,0,label,llabel,
     -      iresno(nslt),ihelp)
          ires1=indexs(ires1i)
          if (ires1 .eq. 0) write (6,2052) ires1i
          ires2=indexs(ires2i)
          if (ires2 .eq. 0) write (6,2052) ires2i
          if (ires1*ires2 .eq. 0) go to 9156
          iseg1=1
          iseg2=1
        else
          write (6,2039)
          line(1:28)='SEGMENT number of the first '
          lline=28
          line(lline+1:lline+llabel)=label(1:llabel)
          lline=lline+llabel
          if (isegdef .eq. 0) isegdef=1
9152      call getint(line,lline,isegdef,1,nsegm,iseg1,0)
          call findrange(isegno,1,nslt,iseg1,ifss,ilss,'segment',7,
     -      ifail)
          if (ifail .gt. 0) go to 9152
c         print *,'ifss,ilss=',ifss,ilss
c         print *,'iresno(ifss),iresno(ilss)=',iresno(ifss),iresno(ilss)
          write (6,2000) iseg1,iresno(ifss),iresno(ilss)
          line(1:7)='RESIDUE'
          call getint(line,lline,iresno(ifss),1,iresno(ilss),irn1,ihelp)
          line(1:28)='SEGMENT number of the last  '
          iseg2def=iseg1
          if (idefall .eq. 1) iseg2def=nsegm
9153      call getint(line,lline,iseg2def,1,numres,iseg2,ihelp)
          if (iseg2 .lt. iseg1) then
            print *,'ERROR: segment number of the last residue can not',
     -        ' be less than the first'
             go to 9153
          end if
          call findrange(isegno,1,nslt,iseg2,ifss,ilss,'segment',7,
     -      ifail)
          if (ifail .gt. 0) go to 9153
          write (6,2000) iseg2,iresno(ifss),iresno(ilss)
          line(1:7)='RESIDUE'
c         print *,'ifss,ilss=',ifss,ilss
c         print *,'iresno(ifss),iresno(ilss)=',iresno(ifss),iresno(ilss)
          call getint(line,lline,iresno(ilss),1,iresno(ilss),irn2,ihelp)
          call findsegres(isegno,iresno,ixres,1,nslt,iseg1,
     -      irn1,ia1,ires1,ifail1)
          call findsegres(isegno,iresno,ixres,ia1+1,nslt,
     -      iseg2,irn2,ia2,ires2,ifail2)
          if (ifail1+ifail2 .gt. 0) go to 9152
          if (ires2 .lt. ires1) then
            write (6,2001) ires2,ires1
            go to 9152
          end if
        end if
        do ir=ires1,ires2
          listlen=listlen+1
          listres(listlen)=ir
        end do
        nrange=nrange+1
        if (nrange .eq. 1) then
          ires1save=ires1
          ires2save=ires2
        else
          ires1save=min0(ires1,ires1save)
          ires2save=max0(ires2,ires2save)
        end if
        if (ionerange .eq. 1) return
        if (iseg1 .ne. iseg2) isegdef=0
        if (iseg1 .ne. iseg2 .or. irn1 .ne. iresno(ifss) .or.
     -      irn2 .ne. iresno(ilss)) then
          call askyn('Do you want to add an other range',33,1,-1,iadd,0)
        else
          iadd=0
        end if
        if (iadd .eq. 0) return
      end do
      return
2000  format(' Segment',i4,' includes residues ',i6,' to ',i6)
2001  format(' ERROR: residue index of the last residue (',i6,') is ',/,
     -  8x,'less than the first residue (',i6,')')
2039  format(' NOTE: segment numbers and residue ranges are printed ',
     -  'above')
2052  format(' ERROR: residue number',i6,' does not exist')
      end
      subroutine readax(lab,llab,idef,iax,indx)
      character*(*) lab
      dimension indx(3)
1000  call getint(lab,llab,idef,1,3,iax,31)
      if (iax .lt. 1 .or. iax .gt. 3) then
        print *,'ERROR: invalid axis'
        go to 1000
      end if
      indx(1)=iax
      indx(2)=mod(iax,3)+1
      indx(3)=mod(iax+1,3)+1
      return
      end
      subroutine findat(iarep,ira1,ira2,line,index,irescol1,inamcol1,
     -  maxrec)
c*****Find the representative atom of residue ir
      character* 132 line(maxrec)
      dimension index(maxrec)
      character*3 resnam3,repats,repat0
      character*4 atname,an
      character*8 resnam,rn
      common /represent/ repats(2,50),maxrepat
c     Find first atom of residue ir
c     write (77,*)'FINDAT START ir,ira1,ira2=',ir,ira1,ira2
c     Find residue name and corresponding representative atom
      resnam='        '
      resnam=line(index(ira1))(irescol1:irescol1+4)
      call leftadjustn(resnam,rn,8)
      resnam3=rn(1:3)
      infound=0
c     print *,'resnam3=',resnam3,' resnam=',resnam
      do i=1,maxrepat
        if (resnam3 .eq. repats(1,i)) infound=i
      end do
c     Find representative atoms of residue ir
      iarep=0
      repat0='CA '
      do ia=ira1,ira2
        if (infound .gt. 0) repat0=repats(2,infound)
        atname=line(index(ia))(inamcol1:inamcol1+3)
        call leftadjust4(atname,an)
        if (an(1:3) .eq. repat0) iarep=ia
      end do
      if (iarep .eq. 0 .and. infound .gt. 0)
     -  write (6,1000) repats(2,infound),repats(1,infound),ira1,ira2
c     if (iarep .eq. 0 .and. infound .gt. 0) then
c     do ia=ira1,ira2
c       print *,'ia=',ia
c       print *,line(index(ia))(1:78)
c     end do
c     stop
c     end if
      if (iarep .eq. 0) iarep=ira1
      return
1000  format(' Representative atom ',a,' for residue ',a,' not found ',
     - 'in atom range',i6,' - ',i6)
      end
      subroutine findapproach(c,irra1,irra2,inra1,inra2,iatnum,ignoreh,
     -  irarepm,itarepm,rmin2,maxrec)
      dimension c(3,maxrec),iatnum(maxrec)
      rmin2=100000.0
      if (ignoreh .eq. 0) then
c       Use all atoms
        do ira=irra1,irra2
          do ita=inra1,inra2
            r2=dist2(c(1,ira),c(1,ita))
            if (r2 .lt. rmin2) then
              rmin2=r2
              irarepm=ira
              itarepm=ita
            end if
          end do
        end do
      else
c       Use the heavy atoms only
        do ira=irra1,irra2
          if (iatnum(ira) .gt. 1) then
            do ita=inra1,inra2
              if (iatnum(ita) .gt. 1) then
                r2=dist2(c(1,ira),c(1,ita))
                if (r2 .lt. rmin2) then
                  rmin2=r2
                  irarepm=ira
                  itarepm=ita
                end if
              end if
            end do
          end if
        end do
      end if
      return
      end
      subroutine pbcreset(c,n,crep,cell,ncell,ixyzexcld,ixyzincld,img)
      dimension c(3,n),crep(3),cell(3,ncell)
c     Finds the PBC cell of the representative atom and shifts the whole molec
c     back to the central cell
c     print *,'PBCRESET ncell,ixyzexcld,ixyzincld=',
c    -  ncell,ixyzexcld,ixyzincld
      if (n .eq. 0) return
      call genimdist123dim(crep,cell,1,ncell,ixyzexcld,ixyzincld,
     -  img,rmin2)
      do ia=1,n
        call arrdiff(c(1,ia),cell(1,img),c(1,ia),3)
      end do
      return
      end
      subroutine pbcdist(c1,c2,i1,i2,cell,ncell,iw,nframe,img,r,dist)
      dimension c1(3),c2(3),cell(3,ncell),r(3)
      call arrdiff(c2,c1,r,3)
      call genimdist(r,cell,1,ncell,img,d2)
      dist=sqrt(d2)
      if (img .gt. 1) then
        do k=1,3
          r(k)=r(k)-cell(k,img)
        end do
        if (iw .lt. -1) write (-iw,1002) nframe,img
      end if
      if (iw .eq. 0) write (6,1000) i1,i2,dist,r,img
      if (iw .gt. 0) write (iw,1001) nframe,i1,i2,dist,r,img
      return
1000  format(' D(',i5,'-',i5,')=',f9.3,' r=',3f9.4,
     -  ' A, PBC image=',i2)
1001  format(' N=',i6,' D(',i5,'-',i5,')=',f9.3,' r=',3f9.4,
     -  ' A, PBC image=',i2)
1002  format(' PBC reset at frame # ',i6,' PBC image=',i2)
      end
      subroutine findrange(index,n1,n,ifind,ifirst,ilast,label,llabel,
     -  ifail)
c*****Find the atom range in index containig ifind
      dimension index(n)
      character*(*) label
c     print *,'FINDRANGE n1,n,ifind=',n1,n,ifind
      ifail=0
      ifirst=n1
      do while (index(ifirst) .ne. ifind)
        ifirst=ifirst+1
        if (ifirst .gt. n) then
          print *,'ERROR: subroutine findrange failed to find ',
     -      label(1:llabel),' ',ifind
          ifail=1
          return
        end if
      end do
      ilast=ifirst
      do while (index(ilast) .eq. ifind .and. ilast .lt. n)
        ilast=ilast+1
      end do
      if (ilast .lt. n) ilast=ilast-1
c     print *,'FINDRANGE ifirst,ilast=',ifirst,ilast
      return
      end
      subroutine findlim(index,ifst,ilst,max)
      dimension index(max)
      i=max
      do while (i .gt. 0 .and. index(i) .eq. 0)
        i=i-1
      end do
      ilst=i
      if (ilst .eq. 0) return
      i=1
      do while (i .lt. ilst .and. index(i) .eq. 0)
        i=i+1
      end do
      ifst=i
      return
      end
      subroutine findsegres(isegno,iresno,ixres,ifst,ilst,iseg,ires,
     -  iaf,irf,ifail)
c*****Find the residue sequence number of segid=iseg, resid=ires
      dimension isegno(ilst),iresno(ilst),ixres(ilst)
      ifail=0
c     print *,'FINDSEGRES ifst,ilst=',ifst,ilst
      do ia=ifst,ilst
        if (isegno(ia) .eq. iseg) then
          if (iresno(ia) .eq. ires) then
            iaf=ia
            irf=ixres(ia)
c           print *,'FINDSEGRES iseg,ires,ia,irf=',iseg,ires,ia,irf
            return
          end if
        end if
      end do
      write (6,1000) iseg,ires,ifst,ilst
      ifail=1
      return
1000  format(' ERROR: segment number',i3,' residue ',i4,' was not ',
     -  'found',/,' Atom range searched:',i5,' - ',i5)
      end
      subroutine modrepats
c*****Allow for modification/addition of representative atomnames
      character*3 repats,resnam3,atnam3
      common /represent/ repats(2,50),maxrepat
      write (6,2000) ((repats(k,i),k=1,2),i=1,maxrepat)
      write (6,2001)
      call askyn('Do you want to add/modify representative atom list',
     -  50,1,-1,ians,0)
      if (ians .eq. 1) then
100     resnam3='   '
        call getname(resnam3,len,
     -    'Residue name to add/modify (hit ENTER to finish)',38,3,0)
        if (resnam3 .eq. '   ') then
          write (6,2000) ((repats(k,i),k=1,2),i=1,maxrepat)
          return
        end if
        atnam3='   '
        call getname(atnam3,len,
     -    'Representative atom name (3 characters maximum)',47,3,0)
        ifound=0
        do i=1,maxrepat
          if (repats(1,i) .eq. resnam3) ifound=i
        end do
        if (ifound .eq. 0) then
          maxrepat=maxrepat+1
          if (maxrepat .gt. 50) then
            print *,'Maximum number of residue names (50) exceeded'
            stop
          end if
          ifound=maxrepat
          repats(1,ifound)=resnam3
        end if
        repats(2,ifound)=atnam3
        go to 100
      end if
      return
2000  format(' Representative atoms for residues:',/,
     -  (1x,8(a3,'-',a3,2x)))
2001  format(' Representative atoms for unlisted residues: CA; ',
     -  'if not found, the 1st atom')
      end
      subroutine findprotbackbone(line,index,iresno,ia1,inamcol1,
     -  ica,ic,in,icb,icg,icd,nslt,icaonly,maxrec)
      character* 132 line(maxrec)
      dimension index(maxrec),iresno(maxrec)
      character*4 atnami,atnamj
      ica=0
      ic=0
      in=0
      icb=0
      icg=0
      icd=0
      ia=ia1
      irespro=iresno(ia)
c     print *,'FINDPROTBACKBONE irespro,ia1=',irespro,ia1
      do while (iresno(ia) .eq. irespro .and. ia .le. nslt)
        atnami=line(index(ia))(inamcol1:inamcol1+3)
        call leftadjust4(atnami,atnamj)
        if (atnamj(1:2) .eq. 'CA') ica=ia
        if (atnamj(1:2) .eq. 'C ') ic=ia
        if (atnamj(1:2) .eq. 'N ') in=ia
        if (atnamj(1:2) .eq. 'CB') icb=ia
        if (atnamj(1:2) .eq. 'CG') icg=ia
        if (atnamj(1:2) .eq. 'CD') icd=ia
        ia=ia+1
      end do
c     print *,'ica,ic,in,icaonly=',ica,ic,in,icaonly
      if (icaonly .eq. -1) then
c       Full backbone is required
        if (ica*ic*in .eq. 0) then
          print *,'ERROR: residue ',irespro,' has no CA or C or N'
          stop
        end if
      else if (icaonly .eq. 1) then
c       Only CA is required
        if (ica .eq. 0) then
          print *,'ERROR: residue ',irespro,' has no CA'
          stop
        end if
      else
        if (ica .gt. 0 .and. ic*in .eq. 0) then
c         N and/or C is missing, CA is present - ask for CA only option
          print *,'Residue ',irespro,' has no C or N but CA is present'
          call askyn('Do you want to look for just CAs',32,1,+1,icaonly,
     -      0)
          if (icaonly .eq. 0) stop
        end if
      end if
      if (ic .eq. 0) ic=ica
      if (in .eq. 0) in=ica
      ia1=ia
      return
      end
      subroutine findchiral(n,ian,nneig,nhneig,ineig,ichiral,maxneig)
      dimension ian(n),nneig(n),nhneig(n),ineig(maxneig,n),
     -  ichiral(n)
      dimension nnpairs(2,6)
      call zeroiti(ichiral,0,n)
      if (n .gt. 1000) then
        print *,'Chirality search is done for max 1000 atoms'
        return
      end if
      do ia=1,n
        if (nneig(ia) .eq. 4 .and. nhneig(ia) .le. 1) then
          call listsame(ineig(1,ia),ian,4,n,nnpairs,nsamepair)
          if (nsamepair .eq. 0) then
            ichiral(ia)=1
          else
            ipair=nsamepair
            ndiff=0
            do while (ipair .gt. 0)
              call comparetree(nneig,ineig,ian,ia,nnpairs(1,ipair),
     -          nnpairs(2,ipair),idiff,n,maxneig)
              if (idiff .eq. 0) then
                ipair=0
              else
                ipair=ipair-1
                ndiff=ndiff+1
              end if
            end do
            if (ndiff .eq. nsamepair) ichiral(ia)=1
          end if
        end if
      end do
      return
      end
      subroutine listsame(ineig,ian,nn,n,nnpairs,nsamepair)
      dimension ineig(nn),ian(n),nnpairs(2,6)
      nsamepair=0
      do ia=2,4
        do ja=1,ia-1
          if (ian(ineig(ia)) .eq. ian(ineig(ja))) then
            nsamepair=nsamepair+1
            nnpairs(1,nsamepair)=ineig(ia)
            nnpairs(2,nsamepair)=ineig(ja)
          end if
        end do
      end do
      return
      end
      subroutine comparetree(nneig,ineig,ian,ia,in1,in2,idiff,n,maxneig)
      dimension ian(n),nneig(n),ineig(maxneig,n)
      dimension iused1(1000),iused2(1000),nnpar1(1000),nnoffsp1(1000),
     -  nnpar2(1000),nnoffsp2(1000),nian1(100),nian2(100)
      data noffsp1 /0/,noffsp2 /0/
c     print *,'COMPARETREE ia,in1,in2=',ia,in1,in2
      call zeroiti(nian1,0,100)
      call zeroiti(nian2,0,100)
      call zeroiti(iused1,0,n)
      call zeroiti(iused2,0,n)
      iused1(ia)=1
      iused1(in1)=1
      iused2(ia)=1
      iused1(in2)=1
      npar1=1
      nnpar1(1)=in1
      npar2=1
      nnpar2(1)=in2
      lev=0
      idiff=0
      do while ((lev .eq. 0 .or. max0(noffsp1,noffsp2) .gt. 0) .and.
     -          idiff .eq. 0)
        noffsp1=0
        do ip=1,npar1
          do in=1,nneig(nnpar1(ip))
            ja=ineig(in,nnpar1(ip))
            if (iused1(ja) .eq. 0) then
              noffsp1=noffsp1+1
              nnoffsp1(noffsp1)=ja
              nian1(ian(ja))=nian1(ian(ja))+1
              iused1(ja)=1
            end if
          end do
        end do
        noffsp2=0
        do ip=1,npar2
          do in=1,nneig(nnpar2(ip))
            ja=ineig(in,nnpar2(ip))
            if (iused2(ja) .eq. 0) then
              noffsp2=noffsp2+1
              nnoffsp2(noffsp2)=ja
              nian2(ian(ja))=nian2(ian(ja))+1
              iused2(ja)=1
            end if
          end do
        end do
        idiff=0
        do i=1,50
          idiff=idiff+iabs(nian2(i)-nian1(i))
        end do
c        write (6,7677) 'offsp1',(nnoffsp1(i),i=1,noffsp1)
c        write (6,7677) 'offsp2',(nnoffsp2(i),i=1,noffsp2)
c7677    format(1x,a,':',(30i3))
        if (idiff .eq. 0) then
          npar1=noffsp1
          if (npar1 .gt. 0) call trnsfi(nnpar1,nnoffsp1,npar1)
          npar2=noffsp2
          if (npar2 .gt. 0) call trnsfi(nnpar2,nnoffsp2,npar2)
        end if
        lev=lev+1
      end do
      return
      end
      subroutine stat14(c,n,nneig,ineig,index,line,nconfig,pi,iatnm2,
     -  ir1,ir2,ic1,ic2,inpcrdtyp,ioins,iw0,maxrepconf,maxng,maxrec)
      dimension nneig(n),ineig(maxng,n),c(3,n),index(n)
      character*2 iatnm2(99)
      character* 132 line(maxrec)
      rmin=1000.0
      rmax=-rmin
      do ia=1,n
        do j=1,nneig(ia)
          ja=ineig(j,ia)
          if (ia .lt. ja) then
c           Bond ia-ja found
            do ii=1,nneig(ia)
              iaa=ineig(ii,ia)
              do jj=1,nneig(ja)
                jaa=ineig(jj,ja)
                if (jaa .ne. ia .and. iaa .ne. ja
     -              .and. iaa .ne. jaa) then
c                 iaa-ia-ja-jaa is a 1-4  chain
                  r2=sqrt(dist2(c(1,iaa),c(1,jaa)))
                  if (r2 .gt. rmax) then
                    rmax=r2
                    iamax=iaa
                    jamax=jaa
                  else if (r2 .lt. rmin) then
                    rmin=r2
                    iamin=iaa
                    jamin=jaa
                  end if
                  tors=dihangl(c,iaa,ia,ja,jaa,1,maxrec)*(180.0/pi)
                  if (inpcrdtyp .le. ioins) then
                    write (iw0,2042) iaa,line(index(iaa))(ic1:ic2),
     -               line(index(iaa))(ir1:ir2),
     -               ia,line(index(ia))(ic1:ic2),
     -               line(index(ia))(ir1:ir2),
     -               ja,line(index(ja))(ic1:ic2),
     -               line(index(ja))(ir1:ir2),
     -               jaa,line(index(jaa))(ic1:ic2),
     -               line(index(jaa))(ir1:ir2),r2,tors
                  else
                    write (iw0,2039) iaa,iatnm2(iaa),ia,iatnm2(ia),
     -               ja,iatnm2(ja),jaa,iatnm2(jaa),r2,tors
                  end if
                end if
              end do
            end do
          end if
        end do
      end do
      if (nconfig .le. maxrepconf)
     -  write (6,2056) rmin,iamin,jamin,rmax,iamax,jamax
      return
2039  format(3(i5,' (',a2,') - '),i5,' (',a2,'):',/,
     -  ' 1-4 distance=',f8.3,' torsion angle=',f10.3)
2042  format(3(i5,' (',a4,1x,a4,') - '),i5,' (',a4,1x,a4,'):',/,
     -  '1-4 distance=',f5.2,' torsion angle=',f7.1)
2056  format(' Shortest 1-4 distance=',f6.2,' between atoms ',2i6,/,
     -  ' Longest 1-4 distance= ',f6.2,' between atoms ',2i6)
      end
      subroutine ramachandran_init(n,ixres)
      parameter (MAXREC=200000,MAXRSD=70000,MAXNEIG=25,MAXPHI=400)
      parameter (IFILL1=MAXPHI*MAXPHI*MAXPHI-(7+2*MAXNEIG)*MAXREC)
      parameter (IFILL5=(MAXNEIG+6)*MAXREC+IFILL1-44*MAXRSD)
      common /nnwork/ ineig(MAXNEIG,MAXREC),nneig(MAXREC),
     -  nprossacc(6,6,MAXRSD),issprossacc(5,MAXRSD),
     -  ixypross(2,MAXRSD),isspross(MAXRSD),ifill(IFILL5)
      dimension ixres(n)
      nres=ixres(n)
c     print *,'RAMA init n,nres=',n,nres
      call zeroiti(nprossacc,0,36*nres)
      call zeroiti(issprossacc,0,5*nres)
      return
      end
      subroutine ramachandran(c,n,index,line,nconfig,pi,nresfound,
     -  iresno,ixres,ir1,ir2,ic1,iw0,maxng,mxrec)
      dimension c(3,n),index(n),iresno(n),ixres(n)
      character* 132 line(mxrec)
      parameter (MAXFRAMES=50000,MAXCOPY=600)
      common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
     -  increment,increment2,res(2,MAXFRAMES,MAXCOPY),
     -  x0(MAXCOPY),y0(MAXCOPY),nxselres,ixselres(MAXCOPY)
      parameter (MAXREC=200000,MAXRSD=70000,MAXNEIG=25,MAXPHI=400)
      parameter (IFILL1=MAXPHI*MAXPHI*MAXPHI-(7+2*MAXNEIG)*MAXREC)
      parameter (IFILL5=(MAXNEIG+6)*MAXREC+IFILL1-44*MAXRSD)
      common /nnwork/ ineig(MAXNEIG,MAXREC),nneig(MAXREC),
     -  nprossacc(6,6,MAXRSD),issprossacc(5,MAXRSD),
     -  ixypross(2,MAXRSD),isspross(MAXRSD),ifill(IFILL5)
      character*1 prosscode(5)
      character*4 atnam
      data prosscode /'H','E','T','P','C'/
c     C - N - CA - C - N
c     i1  i2  i3   i4  i5
c         <--ires-->
c     print *,'RAMA n,maxng,mxrec=',n,maxng,mxrec
      call trajlimtest(ixres(n),MAXFRAMES)
      nresfound=0
      do ires=1,ixres(n)
        res(1,ires,maxpres)=999.9
        res(2,ires,maxpres)=999.9
      end do
      do ia=1,n
        atnam=line(index(ia))(ic1:ic1+3)
        call leftadjust4(atnam,atnam)
        if (atnam .eq. 'CA  ') then
c         Alpha carbon found
          i3=ia
          call ca_to_bb(i3,iresno,nneig,ineig,index,line,ic1,
     -      i1,i2,i4,i5,ires,iprotein,maxng,mxrec)
          if (iprotein .gt. 0) then
c           Full residue backbone found
c           write (iw0,*)'i1-5=',i1,i2,i3,i4,i5
c           write (iw0,*)'ires i1-5=',iresno(i1),iresno(i2),
c    -        iresno(i3),iresno(i4),iresno(i5)
            phirad=dihangl(c,i1,i2,i3,i4,0,mxrec)
            psirad=dihangl(c,i2,i3,i4,i5,0,mxrec)
            phi=phirad*(180.0/pi)
            psi=psirad*(180.0/pi)
            if (nframe .eq. 0) then
              write (iw0,1000) phi,psi,ires,line(index(i3))(ir1:ir2)
            else
              write (iw0,1000) phi,psi,ires,line(index(i3))(ir1:ir2),
     -          ' ',nframe
              if (nxselres .gt. 0) then
c               Save dial plot info
                do ix=1,nxselres
                  if (ires .eq. ixselres(ix)) then
                    call trajlimtest(nframe,MAXFRAMES)
                    res(1,nframe,2*ix-1)=cos(phirad)
                    res(2,nframe,2*ix-1)=sin(phirad)
                    res(1,nframe,2*ix)=cos(psirad)
                    res(2,nframe,2*ix)=sin(psirad)
                  end if
                end do
              end if
            end if
            nresfound=nresfound+1
            call trajlimtest(nresfound,MAXFRAMES)
            res(1,nresfound,maxpres)=phi
            res(2,nresfound,maxpres)=psi
c            write (iw0,2000) (c(k,i1),k=1,3),(c(k,i2),k=1,3),
c     -       (c(k,i3),k=1,3),(c(k,i4),k=1,3),(c(k,i5),k=1,3)
c2000         format(' c1=',3f8.3,' c2=',f8.3,' c3=',f8.3,' c4=',3f8.3,
c     -         ' c5=',f8.3)
c           Save and accumulate PROSS indices information
            ixypross(1,nresfound)=ixpross(phi)
            ixypross(2,nresfound)=ixpross(psi)
            nprossacc(ixypross(1,nresfound),
     -                ixypross(2,nresfound),nresfound)=
     -        nprossacc(ixypross(1,nresfound),
     -                  ixypross(2,nresfound),nresfound)+1
          end if
        end if
      end do
c     Accumulate PROSS indices information
      call zeroiti(isspross,0,nresfound)
c     Look for Alpha
      ir=1
      do while (ir .le. nresfound)
        ir0=ir
        ixy=ixypross(1,ir)+6*(ixypross(2,ir)-1)
        if (ixy .eq. 8 .or. ixy .eq. 14) then
          irr=ir
          do while (ixy .eq. 8 .or. ixy .eq. 14)
            irr=irr+1
            ixy=0
            if (irr .lt. nresfound)
     -        ixy=ixypross(1,irr)+6*(ixypross(2,irr)-1)
          end do
          if (irr-ir .ge. 4) then
            do i=ir,irr
              isspross(i)=1
            end do
          end if
          ir=irr+1
        end if
        if (ir .eq. ir0) ir=ir+1
      end do
c     Look for Beta
      ir=1
      do while (ir .le. nresfound)
        ir0=ir
        if (isspross(ir) .eq. 0) then
          ixy=ixypross(1,ir)+6*(ixypross(2,ir)-1)
          if (ixy .eq. 13 .or. ixy .eq. 24 .or. ixy .eq. 29 .or.
     -        ixy .eq. 30 .or. ixy .eq. 28 .or. ixy .eq. 36) then
            irr=ir
            do while (ixy .eq. 13 .or. ixy .eq. 24 .or. ixy .eq. 29 .or.
     -        ixy .eq. 30 .or. ixy .eq. 28 .or. ixy .eq. 36)
              irr=irr+1
              ixy=0
              if (irr .lt. nresfound)
     -          ixy=ixypross(1,irr)+6*(ixypross(2,irr)-1)
            end do
            if (irr-ir .ge. 2) then
              do i=ir,irr
                isspross(i)=2
              end do
            end if
            ir=irr+1
          end if
        end if
        if (ir .eq. ir0) ir=ir+1
      end do
c     Look for turn
      ir=1
      do while (ir .le. nresfound-1)
        ir0=ir
        if (isspross(ir) .eq. 0 .and. isspross(ir+1) .eq. 0) then
          ixy1=ixypross(1,ir)+6*(ixypross(2,ir)-1)
          ixy2=ixypross(1,ir+1)+6*(ixypross(2,ir+1)-1)
          if ((ixy1 .eq.  8 .and. (ixy2 .eq. 8 .or. ixy2 .eq. 14 .or.
     -        ixy2 .eq. 13)) .or. (ixy1 .eq.  14 .and. (ixy2 .eq. 8 .or.
     -        ixy2 .eq. 14 .or. ixy2 .eq. 13)) .or. (ixy1 .eq. 13 .and.
     -        (ixy2 .eq.  8 .or. ixy2 .eq. 14 .or. ixy2 .eq.  13)) .or.
     -        (ixy1 .eq. 30 .and. (ixy2 .eq. 20 .or. ixy2 .eq. 16 .or.
     -        ixy2 .eq. 17)) .or. (ixy1 .eq. 24 .and. (ixy2 .eq. 20 .or.
     -        ixy2 .eq. 16 .or. ixy2 .eq. 17)) .or. (ixy1 .eq. 20 .and.
     -        (ixy2 .eq. 20 .or. ixy2 .eq. 16 .or. ixy2 .eq.  17)) .or.
     -        (ixy1 .eq. 16 .and. (ixy2 .eq. 20 .or. ixy2 .eq. 16 .or.
     -        ixy2 .eq. 17)) .or. (ixy1 .eq. 17 .and. (ixy2 .eq. 20 .or.
     -        ixy2 .eq. 16 .or. ixy2 .eq. 17)) .or. (ixy1 .eq. 32 .and.
     -        (ixy2 .eq. 8  .or. ixy2 .eq. 14 .or. ixy2 .eq.  13)) .or.
     -        (ixy1 .eq.  4 .and. (ixy2 .eq. 8 .or. ixy2 .eq. 14 .or.
     -        ixy2 .eq. 13))) then
            isspross(ir)=3
            isspross(ir+1)=3
            ir=ir+2
          end if
        end if
        if (ir .eq. ir0) ir=ir+1
      end do
c     Look for Pi
      ir=1
      do while (ir .le. nresfound)
        if (isspross(ir) .eq. 0) then
          ixy=ixypross(1,ir)+6*(ixypross(2,ir)-1)
          if (ixy .eq. 30 .or. ixy .eq. 24) isspross(ir)=4
        end if
        ir=ir+1
      end do
c     Rest is Coil
      do ir=1,nresfound
        if (isspross(ir) .eq. 0) isspross(ir)=5
      end do
      do ir=1,nresfound
        if (isspross(ir) .lt. 1 .or. isspross(ir) .gt. 5)
     -    print *,'ir=',ir,' isspross=',isspross(ir)
        issprossacc(isspross(ir),ir)=issprossacc(isspross(ir),ir)+1
      end do
      write (iw0,1002) (prosscode(isspross(ir)),ir=1,nresfound)
      if (nresfound .eq. 0) then
        print *,'ERROR: no protein backbone found'
        stop
      else if (nconfig .le. 1) then
        write (6,1001) nresfound
      end if
      return
1000  format(2f10.3,' (phi and psi angles) residue#=',i6,' (',a,')',
     -  a,'Frame=',i5)
1001  format(' Number of protein residues found=',i5)
1002  format(' PROSS SS codes: ',50a1)
c1003  format(' WARNING: dial-plot residue #',i3,', residue',i6,' is ',
c     -  'not a protein',/,10x,'No dials will be plotted for it')
      end
      function ixpross(angle)
c     Obtain the index of PROSS classification for angle
       if (angle .lt. -150.0) then
         ixpross=6
        else
          ixpross=(angle+150.0)/60.0+1.0
        end if
        if (ixpross .lt. 1 .or. ixpross .gt. 6) then
          print *,'Invalid PROSS index (',ixpross,') for angle ',angle
          stop
        end if
      return
      end
      subroutine angledials(c,n,nangsel,ixang123,index,line,pi,
     -  ir1,ir2,ic1,ic2,iw0,mxrec)
      dimension c(3,n),index(n),ixang123(4,nangsel)
      character* 132 line(mxrec)
      parameter (MAXFRAMES=50000,MAXCOPY=600)
      common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
     -  increment,increment2,res(2,MAXFRAMES,MAXCOPY),
     -  x0(MAXCOPY),y0(MAXCOPY),nxselres,ixselres(MAXCOPY)
c     print *,'ANGLEDIALS n,iw0=',n,iw0
      do it=1,nangsel
        phirad=angleijk(c,n,ixang123(1,it),ixang123(2,it),
     -    ixang123(3,it),iw0)
        phi=phirad*(180.0/pi)
        res(1,nframe,it)=cos(phirad)
        res(2,nframe,it)=sin(phirad)
        write (iw0,1000) it,phi,(line(index(ixang123(k,it)))(ic1:ic2),
     -    ixang123(k,it),k=1,3),
     -    line(index(ixang123(2,it)))(ir1:ir2)
      end do
      return
1000  format(' A',i2,'=',f8.3,' (',a4,i6,')',2(' - (',a4,i6,')'),
     -  ' R2:',a)
      end
      subroutine torsiondials(c,n,ntorsel,ixtor1234,index,line,pi,
     -  ir1,ir2,ic1,ic2,iw0,mxrec)
      dimension c(3,n),index(n),ixtor1234(4,ntorsel)
      character* 132 line(mxrec)
      parameter (MAXFRAMES=50000,MAXCOPY=600)
      common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
     -  increment,increment2,res(2,MAXFRAMES,MAXCOPY),
     -  x0(MAXCOPY),y0(MAXCOPY),nxselres,ixselres(MAXCOPY)
c     print *,'TORSIONDIALS n,mxrec=',n,mxrec
      call trajlimtest(nframe,MAXFRAMES)
      do it=1,ntorsel
        phirad=dihangl(c,ixtor1234(1,it),ixtor1234(2,it),
     -    ixtor1234(3,it),ixtor1234(4,it),0,mxrec)
        phi=phirad*(180.0/pi)
        res(1,nframe,it)=cos(phirad)
        res(2,nframe,it)=sin(phirad)
        write (iw0,1000) it,phi,(line(index(ixtor1234(k,it)))(ic1:ic2),
     -    ixtor1234(k,it),k=1,4),
     -    line(index(ixtor1234(3,it)))(ir1:ir2)
      end do
      return
1000  format(' T',i3,'=',f8.3,' (',a4,i6,')',3(' - (',a4,i6,')'),
     -  ' R3:',a)
      end
      subroutine ca_to_bb(icaa,iresno,nneig,ineig,index,line,
     -  ic1,icna,ina,ica,inca,ires,iprotein,maxng,mxrec)
      character* 132 line(mxrec)
      dimension iresno(mxrec),index(mxrec),nneig(mxrec),
     -  ineig(maxng,mxrec)
      character*4 atnam
      iprotein=0
      ires=iresno(icaa)
      ina=0
      ica=0
c     print *,'ic1,maxng,mxrec=',ic1,maxng,mxrec
c     print *,'icaa,ires=',icaa,ires
      do j=1,nneig(icaa)
        ja=ineig(j,icaa)
        if (iresno(ja) .ge. ires) then
          atnam=line(index(ja))(ic1:ic1+3)
          call leftadjust4(atnam,atnam)
          if (atnam .eq. 'N   ') ina=ja
          if (atnam .eq. 'C   ') ica=ja
        end if
      end do
c     print *,' ina,ica=',ina,ica
      if (ina*ica .gt. 0) then
c       N-CA-C found
        icna=0
        inca=0
        do j=1,nneig(ina)
          ja=ineig(j,ina)
          if (iresno(ja) .eq. ires-1) then
            atnam=line(index(ja))(ic1:ic1+3)
            call leftadjust4(atnam,atnam)
            if (atnam .eq. 'C   ') icna=ja
          end if
        end do
c       print *,' icna   =',icna
        do j=1,nneig(ica)
          ja=ineig(j,ica)
          if (iresno(ja) .gt. ires) then
            atnam=line(index(ja))(ic1:ic1+3)
            call leftadjust4(atnam,atnam)
            if (atnam .eq. 'N   ') inca=ja
          end if
        end do
c       print *,' inca   =',inca
        if (icna*inca .gt. 0) iprotein=1
      end if
      return
      end
      subroutine ramachandranplot(nres,ips,xm,iallrama)
      parameter (MAXFRAMES=50000,MAXCOPY=600)
      common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
     -  increment,increment2,res(2,MAXFRAMES,MAXCOPY),
     -  x0(MAXCOPY),y0(MAXCOPY),nxselres,ixselres(MAXCOPY)
c     print *,'RAMACHANDRANPLOT nres,ips,maxpres=',nres,ips,maxpres
      xmm=0.9*xm
      ymm=0.9*xm
      xm0=0.09*xm
      ym0=0.20*xm
      if (nframe .le. 1) then
        write (ips,*) 'np'
        write (ips,1001) xm0,ym0,' m'
        write (ips,1001) xm0,ym0+ymm,' l'
        write (ips,1001) xm0+xmm,ym0+ymm,' l'
        write (ips,1001) xm0+xmm,ym0,'   l'
        write (ips,1001) xm0,ym0,' l'
        write (ips,*) 'sk'
        write (ips,1001) xm0,ym0-0.03*ymm,'m'
        write (ips,*) '(-180) show'
        write (ips,1001) xm0+xmm-0.05*xmm,ym0-0.03*ymm,'m'
        write (ips,*) '(+180) show'
        write (ips,1001) xm0+xmm/2.0-0.06*xmm,ym0-0.03*ymm,'m'
        write (ips,*) '(Phi) show'
        write (ips,1001) xm0-0.07*xmm,ym0+0.01*ymm,'m'
        write (ips,*) '(-180) show'
        write (ips,1001) xm0-0.07*xmm,ym0+ymm-0.02*ymm,'m'
        write (ips,*) '(+180) show'
        write (ips,1001) xm0-0.07*xmm,ym0+ymm/2.0-0.02*ymm,'m'
        write (ips,*) '(Psi) show'
        write (ips,*) 'np'
        write (ips,1001) xm0,ym0+1.01*ymm,' m'
      end if
      if (nframe .gt. 0) call rrgbcolor(ips,nframe,nframetot,0)
      nresplot=nxselres
      if (iallrama .eq. 1) nresplot=nres
      i=1
      do while (i .le. nresplot)
        ii=i
        if (iallrama .eq. 0) ii=ixselres(i)
        if (res(1,i,maxpres) .lt. 999.0) then
          if (nframe .eq. 0) call rrgbcolor(ips,i,nres,0)
          xx=xm0+xmm*(res(1,i,maxpres)+180.0)/360.0
          yy=ym0+ymm*(res(2,i,maxpres)+180.0)/360.0
          write (ips,*) 'np'
          write (ips,1001) xx,yy,' 1 0 360 arc'
          write (ips,*) 'sk'
        end if
        i=i+1
      end do
      if (nframe .eq. 0) then
        ixmm=xmm
        ixm0=xm0
        call rainbowscale(ips,ixm0,ixmm,25,nres,0.0,0.0,0.0,'N(res)',6)
        write (ips,*) 'showpage'
        close (ips)
      end if
      return
1001  format(2f8.1,1x,a)
      end
      subroutine ramachandran_hist(nres,resnames,nrescol,iw,
     -  idistw,isummw)
      character*(*) resnames(nres)
      parameter (MAXREC=200000,MAXRSD=70000,MAXNEIG=25,MAXPHI=400)
      parameter (IFILL1=MAXPHI*MAXPHI*MAXPHI-(7+2*MAXNEIG)*MAXREC)
      parameter (IFILL5=(MAXNEIG+6)*MAXREC+IFILL1-44*MAXRSD)
      common /nnwork/ ineig(MAXNEIG,MAXREC),nneig(MAXREC),
     -  nprossacc(6,6,MAXRSD),issprossacc(5,MAXRSD),
     -  ixypross(2,MAXRSD),isspross(MAXRSD),ifill(IFILL5)
      character*1 prosscode(5)
      character*1 prossixy(36)
      dimension iang(6)
      data prosscode /'H','E','T','P','C'/
      data prossixy /'H','N','T','r','l','B', 'I','O','U','q','k','C',
     -               'J','P','V','p','j','D', 'K','Q','W','o','i','E',
     -               'L','R','X','n','h','F', 'G','M','S','m','g','A'/
c     print *,'RAMA hist nres=',nres
      if (idistw .gt. 0) then
        write (iw,*)
        do i=1,6
          iang(i)=-120+(i-1)*60
        end do
        do i=1,6
          do j=1,6
            ixy=i+6*(j-1)
            write (iw,1001) iang(i),iang(j),prossixy(ixy)
          end do
        end do
        write (iw,*)
        do ir=1,nres
          write (iw,1002) ir,resnames(ir)(1:nrescol),(iang(j),
     -      (nprossacc(i,j,ir),i=1,6),j=6,1,-1)
        end do
      end if
      if (isummw .gt. 0) then
        do ir=1,nres
          write (iw,1000) ir,resnames(ir)(1:nrescol),
     -      (prosscode(i),issprossacc(i,ir),i=1,5)
        end do
      end if
      return
1000  format(' Res',i5,' (',a,') PROSS distr:',5(1x,a1,':',i6))
1001  format(' PROSS SS codes and angles:',(' phi=',i4,' psi=',i4,
     -  ' code=',a1))
1002  format(' PROSS angular grid distribution for residue ',i5,
     -  ' (',a,'):',6(/,' psi=',i4,':',6i9))
      end
      subroutine bondlenstat(c,n,iatnum,nneig,ineig,iatnm2,nconfig,
     -  nanos,ixlist,ialist,iwbls,inpcrdtyp,ioins,ic1,ic2,ir1,ir2,
     -  line,index,radtodeg,maxrepconf,maxng,maxrec)
      dimension c(3,n),iatnum(n),nneig(n),ineig(maxng,n),index(n),
     -  ixlist(99),ialist(15)
      character* 132 line(maxrec)
      character*2 iatnm2(99)
      character*1 sp
      dimension dmin(15,15),dav(15,15),dsd(15,15),ijmin(2,15,15),
     -  nij(15,15),dmax(15,15),ijmax(2,15,15),dd(15),anmin(15,15,15),
     -  anav(15,15,15),ansd(15,15,15),ijkmin(3,15,15,15),nijk(15,15,15),
     -  anmax(15,15,15),ijkmax(3,15,15,15),anan(15,15)
      real*8 cosa
      data ixl /0/,jxl /0/,sp /' '/
c     print *,'BLS ic1,ic2,ir1,ir2=',ic1,ic2,ir1,ir2
c     Bond length statistics first
      do i=1,nanos
        do j=1,i
c         j<=i
          nij(i,j)=0
          dav(i,j)=0.0
          dsd(i,j)=0.0
          dmax(i,j)=0.0
          dmin(i,j)=10000.0
          ijmin(1,i,j)=0
          ijmax(1,i,j)=0
          ijmin(2,i,j)=0
          ijmax(2,i,j)=0
        end do
      end do
      do i=1,n
        ixll=ixlist(iatnum(i))
        do jj=1,nneig(i)
          j=ineig(jj,i)
          jxll=ixlist(iatnum(j))
          dd(jj)=sqrt((c(1,i)-c(1,j))**2+(c(2,i)-c(2,j))**2+
     -       (c(3,i)-c(3,j))**2)
          if (jxll .le. ixll) then
            ixl=ixll
            jxl=jxll
          else
            ixl=jxll
            jxl=ixll
          end if
          dav(ixl,jxl)=dav(ixl,jxl)+dd(jj)
          dsd(ixl,jxl)=dsd(ixl,jxl)+dd(jj)**2
          nij(ixl,jxl)=nij(ixl,jxl)+1
          if (dmax(ixl,jxl) .lt. dd(jj)) then
            dmax(ixl,jxl)=dd(jj)
            ijmax(1,ixl,jxl)=i
            ijmax(2,ixl,jxl)=j
          end if
          if (dmin(ixl,jxl) .gt. dd(jj)) then
            dmin(ixl,jxl)=dd(jj)
            ijmin(1,ixl,jxl)=i
            ijmin(2,ixl,jxl)=j
          end if
        end do
        if (inpcrdtyp .le. ioins) then
          write (iwbls,2046) i,line(index(i))(ic1:ic2),
     -      line(index(i))(ir1:ir2),
     -      (sp,ineig(j,i),line(index(ineig(j,i)))(ic1:ic2),
     -      line(index(ineig(j,i)))(ir1:ir2),dd(j),j=1,nneig(i))
        else
          write (iwbls,2048) i,iatnm2(iatnum(i)),
     -      (sp,ineig(j,i),iatnm2(iatnum(ineig(j,i))),
     -      dd(j),j=1,nneig(i))
        end if
      end do
      if (nconfig .le. maxrepconf) write (6,2057)
      write (iwbls,2057)
      do i=1,nanos
        do j=1,i
          if (nij(i,j) .gt. 0) dav(i,j)=dav(i,j)/nij(i,j)
          dsd(i,j)=sqrt(abs(dsd(i,j)/nij(i,j)-dav(i,j)**2))
          if (dmin(i,j) .eq. 10000.0) dmin(i,j)=0.0
        end do
        do j=1,i
          if (ijmin(1,i,j) .gt. 0) then
            if (nconfig .le. maxrepconf)
     -       write (6,2047) iatnm2(ialist(i)),
     -         iatnm2(ialist(j)),dmin(i,j),ijmin(1,i,j),ijmin(2,i,j),
     -         dav(i,j),dsd(i,j),dmax(i,j),ijmax(1,i,j),ijmax(2,i,j)
            write (iwbls,2047) iatnm2(ialist(i)),
     -       iatnm2(ialist(j)),dmin(i,j),ijmin(1,i,j),ijmin(2,i,j),
     -       dav(i,j),dsd(i,j),dmax(i,j),ijmax(1,i,j),ijmax(2,i,j)
          end if
        end do
      end do
c     Bond angle statistics next
      do i=1,nanos
        do j=1,nanos
          do k=1,j
c           k<=j
            nijk(i,j,k)=0
            anav(i,j,k)=0.0
            ansd(i,j,k)=0.0
            anmax(i,j,k)=0.0
            anmin(i,j,k)=10000.0
            ijkmin(1,i,j,k)=0
            ijkmax(1,i,j,k)=0
            ijkmin(2,i,j,k)=0
            ijkmax(2,i,j,k)=0
            ijkmin(3,i,j,k)=0
            ijkmax(3,i,j,k)=0
          end do
        end do
      end do
      do i=1,n
        ixll=ixlist(iatnum(i))
        do jj=1,nneig(i)
          do kk=1,jj-1
            j=ineig(jj,i)
            k=ineig(kk,i)
            jxll=ixlist(iatnum(j))
            kxll=ixlist(iatnum(k))
            ixl=max0(ixll,jxll,kxll)
            kxl=min0(ixll,jxll,kxll)
            if (ixll .ne. ixl .and. ixll .ne. kxl) jxl=ixll
            if (jxll .ne. ixl .and. jxll .ne. kxl) jxl=jxll
            if (kxll .ne. ixl .and. kxll .ne. kxl) jxl=kxll
            rj=0.0
            rk=0.0
            rjk=0.0
            do l=1,3
              dj=c(l,i)-c(l,j)
              dk=c(l,i)-c(l,k)
              rj=rj+dj*dj
              rk=rk+dk*dk
              rjk=rjk+dj*dk
            end do
            cosa=dble(rjk)/sqrt(rj*rk)
            anan(jj,kk)=radtodeg*dacoscheck(cosa,ccc,1,6,'BONDLENSTAT')
            anav(ixl,jxl,kxl)=anav(ixl,kxl,jxl)+anan(jj,kk)
            ansd(ixl,jxl,kxl)=ansd(ixl,kxl,jxl)+anan(jj,kk)**2
            nijk(ixl,jxl,kxl)=nijk(ixl,kxl,jxl)+1
            if (anmax(ixl,jxl,kxl) .lt. anan(jj,kk)) then
              anmax(ixl,jxl,kxl)=anan(jj,kk)
              ijkmax(1,ixl,jxl,kxl)=i
              ijkmax(2,ixl,jxl,kxl)=j
              ijkmax(3,ixl,jxl,kxl)=k
            end if
            if (anmin(ixl,jxl,kxl) .gt. anan(jj,kk)) then
              anmin(ixl,jxl,kxl)=anan(jj,kk)
              ijkmin(1,ixl,jxl,kxl)=i
              ijkmin(2,ixl,jxl,kxl)=j
              ijkmin(3,ixl,jxl,kxl)=k
            end if
            if (inpcrdtyp .le. ioins) then
              write (iwbls,2050) j,line(index(j))(ic1:ic2),
     -          line(index(j))(ir1:ir2),i,line(index(i))(ic1:ic2),
     -          line(index(i))(ir1:ir2),k,line(index(k))(ic1:ic2),
     -          line(index(k))(ir1:ir2),anan(jj,kk)
            else
              write (iwbls,2051) j,iatnm2(iatnum(j)),
     -          i,iatnm2(iatnum(i)),k,iatnm2(iatnum(k)),anan(jj,kk)
            end if
          end do
        end do
      end do
      if (nconfig .le. maxrepconf) write (6,2058)
      write (iwbls,2058)
      do i=1,nanos
        do j=1,nanos
          do k=1,j
            if (nijk(i,j,k) .gt. 0) then
              anav(i,j,k)=anav(i,j,k)/nijk(i,j,k)
              ansd(i,j,k)=sqrt(abs(ansd(i,j,k)/nijk(i,j,k)-
     -          anav(i,j,k)**2))
            end if
            if (anmin(i,j,k) .eq. 10000.0) anmin(i,j,k)=0.0
            if (ijkmin(1,i,j,k) .gt. 0) then
              if (nconfig .le. maxrepconf)
     -          write (6,2049) iatnm2(ialist(j)),iatnm2(ialist(i)),
     -            iatnm2(ialist(k)),anav(i,j,k),ansd(i,j,k),
     -            ijkmin(2,i,j,k),ijkmin(1,i,j,k),ijkmin(3,i,j,k),
     -            anmin(i,j,k),ijkmax(2,i,j,k),ijkmax(1,i,j,k),
     -            ijkmax(3,i,j,k),anmax(i,j,k)
              write (iwbls,2049) iatnm2(ialist(j)),iatnm2(ialist(i)),
     -          iatnm2(ialist(k)),anav(i,j,k),ansd(i,j,k),
     -          ijkmin(2,i,j,k),ijkmin(1,i,j,k),ijkmin(3,i,j,k),
     -          anmin(i,j,k),ijkmax(2,i,j,k),ijkmax(1,i,j,k),
     -          ijkmax(3,i,j,k),anmax(i,j,k)
            end if
          end do
        end do
      end do
      return
2046  format(i5,' From ',a4,1x,a4,a1,'To ',i5,1x,a4,1x,a4,f6.3,';',a1,
     -                            ' To ',i5,1x,a4,1x,a4,f6.3,';',a1,
     -  /,(20x,2(' To ',i5,1x,a4,1x,a4,f6.3,';',a1)))
2047  format(1x,a2,' - ',a2,f6.3,' (',i5,'-',i5,') < ',f6.3,' (av) +/-',
     -  f4.3,' (SD) < ',f6.3,' (',i5,'-',i5,')')
2048  format(i5,' From ',a2,1x,' To ',i5,1x,a2,1x,f6.3,';',a1,
     -  ' To ',i5,1x,a2,1x,f6.3,';',a1,' To ',i5,1x,a2,1x,f6.3,';',a1,
     -  /,(15x,3(' To ',i5,1x,a2,1x,f6.3,';',a1)))
2049  format(' Angle ',a2,'-',a2,'-',a2,' Average=',f8.2,' SD=',f8.2,
     -  ' deg',/,6x,'Min (',i5,'-',i5,'-',i5,')=',f8.2,
     -  ' Max (',i5,'-',i5,'-',i5,')=',f8.2)
2050  format(' Angle ',i5,' (',a4,1x,a4,') - ',i5,' (',a4,1x,a4,') - ',
     -  i5,' (',a4,1x,a4,')=',f10.5,' deg')
2051  format(' Angle ',i5,' (',a2,') - ',i5,' (',a2,') - ',
     -  i5,' (',a2,')=',f10.5,' deg')
2057  format(' Minimum, average and maximum of bond-type lengths')
2058  format(' Minimum, average and maximum of angle-type values')
      end
      subroutine hblist(c,n,nslt,islvw,naslv,iatnum,ifchrg,isegno,nneig,
     -  nneiga,nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,ixres,
     -  nconfig,hbf0,angm0,molresflag,hblimfac,angmin,iwhbl,ic1,ic2,ir1,
     -  ir2,irn1,irn2,blankline,line,index,indexn,ibnd,indexo,isolvent,
     -  iprint,icallnn,nosamseg,radtodeg,maxrepconf,maxng,maxbox,maxrsd,
     -  maxrec)
      dimension c(3,n),iatnum(n),ifchrg(n),isegno(n),nneig(n),
     -  ineig(maxng,n),nhbneig(n),nneiga(n),nhneig(n),nnneig(n),
     -  ncneig(n),nsneig(n),npneig(n),ixres(n),index(n),indexn(n),
     -  ibnd(maxbox,maxrec),molresflag(maxrsd),indexo(maxrec)
      character* 132 line(maxrec),linep(25),blankline
      character*1 r1,bbsc(4)
      common /connatdat/ ramax(99),ramax2(99),hlimfac,ianfg(99),
     -  namfcg(100),nrmw
      character*8 resnam
      character*8 atname,atname1,atnamea,atname1a
      dimension rhbl(25),nh12(4)
      data bbsc/'B','S','V','?'/
      data pi /3.2141692/
c     print *,'HBLIST n,nslt,ic1,ic2=',n,nslt,ic1,ic2
      innl=0
      nhbats=nslt
      if (isolvent .eq. 1) nhbats=n
c     print *,'NHB=',nhbats
c     print *,'hbf0,angm0=',hbf0,angm0
c     print *,'hblimfac,angmin=',hblimfac,angmin
c     print *,'isegno(1),(n),icallnn=',isegno(1),isegno(n),icallnn
      if (hbf0 .ne. hblimfac .or. angm0 .ne. angmin .or.
     -    isegno(1) .ne. isegno(n) .or. icallnn .eq. 1)
     -  call nnlist(nslt,islvw,naslv,nhbats,iatnum,ifchrg,c,nneig,
     -    nneiga,nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,line,
     -    ir1,ir2,ic1,ic2,index,nconfig,innl,molresflag,hblimfac,angmin,
     -    1,ibnd,indexo,isegno,ixres,maxrepconf,1,radtodeg,maxbox,maxng,
     -    maxrsd,maxrec)
      if (iprint .eq. 0) return
      rDHmin=200.0
      rDHmax=0.0
      nhats=0
      nhbonds=0
c     Determine if backbone,sidechain or other
      atname='        '
      atname1='        '
      resnam='        '
      do i=1,nhbats
        resnam(1:ir2-ir1+1)=line(index(i))(ir1:ir2)
        call changeprot(resnam,r1,2)
        if (i .gt. nslt) then
          indexn(i)=3
        else if (r1 .eq. '*') then
          indexn(i)=4
        else
          indexn(i)=2
          atname(1:ic2-ic1+1)=line(index(i))(ic1:ic1+3)
          call leftadjustn(atname,atnamea,8)
          if (ineig(1,i) .gt. 0) then
            atname1(1:ic2-ic1+1)=line(index(ineig(1,i)))(ic1:ic1+3)
            call leftadjustn(atname1,atname1a,8)
            if (atnamea(1:3) .eq. 'H   ' .or.
     -          atnamea(1:3) .eq. 'HN ') then
              if (atname1a(1:3) .eq. 'N  ') indexn(i)=1
            else if (atnamea(1:3) .eq. 'O  ') then
              if (atname1a(1:3) .eq. 'C  ') indexn(i)=1
            end if
          end if
c          write (77,8871) i,atnamea,atname1a,indexn(i)
c8871      format(i5,' atnamea=',a,' atname1a=',a,' indexn(i)=',i2)
        end if
      end do
      call checkhblist(n,ineig,nhbneig,maxng)
      do ia=1,nhbats
        if (iatnum(ia) .eq. 1) then
c         Atom ia is always the donor H
          ibb=indexn(ia)
c         ibb,jbb: 1,2,3: Backbone/sidechain/solvent/?
          nhats=nhats+1
          nhbia=0
          do ja=1,nhbneig(ia)
            ihb=ineig(maxng+1-ja,ia)
            if (nosamseg .eq. 0 .or. isegno(ia) .ne. isegno(ihb)) then
              nhbia=nhbia+1
              jbb=indexn(ihb)
              if (ihb .gt. n)
     -          print *,'ERROR: illegal ihb (',ihb,') at ia=',ia
              if (nneig(ia) .ne. 1) print *,' WARNING: Hbond donor ',
     -          ia,' has more than one bond'
c             ihb0 is the heavy atom of the donor H
              ihb0=ineig(1,ia)
              call angdistw(c(1,ia),c(1,ihb),c(1,ihb0),rHB,rb,rab,ang)
              ang=ang*(180.0/pi)
              rhbl(ja)=rHB
              call readint(line(index(ia)),irn1,irn2,irna,2)
              call readint(line(index(ihb)),irn1,irn2,irnb,2)
              linep(ja)=blankline
              write (linep(ja),2040) ia,line(index(ia))(ic1:ic2),irna,
     -          line(index(ia))(ir1:ir2),ihb,line(index(ihb))(ic1:ic2),
     -          irnb,line(index(ihb))(ir1:ir2),rHB,ang,rab,
     -          bbsc(ibb),bbsc(jbb)
              if (rDHmin .gt. rHB) then
                rDHmin=rHB
                imn1=ia
                imn2=ineig(maxng+1-ja,ia)
              end if
              if (rDHmax .lt. rHB) then
                rDHmax=rHB
                imx1=ia
                imx2=ineig(maxng+1-ja,ia)
              end if
            end if
          end do
          nhbonds=nhbonds+nhbia
          do ja=1,min0(25,nhbneig(ia))
            call writeline(iwhbl,linep(ja),1,79,0)
          end do
        else if (ifchrg(ia) .gt. 0) then
c         Cation - only H-bonds to water
          nhbng=nhbneig(ia)
          do ja=1,nhbneig(ia)
            ihb=ineig(maxng+1-ja,ia)
            if (ihb .le. nslt) print *,'PROGRAM ERROR: atom ',ia,
     -        ' is a cation but is ','H-bonded to a non-solvent'
            if (iatnum(ihb) .ne. 8) print *,'PROGRAM ERROR: atom ',ia,
     -        ' is H-bonded to a cation but is not an oxygen'
            nnh=0
            do in=1,nneig(ihb)
              jn=ineig(in,ihb)
              if (iatnum(jn) .eq. 1) then
                nnh=nnh+1
                nh12(nnh)=jn
              end if
            end do
            if (nnh .ne. 2) print *,'WARNING: water oxygen ',
     -        ihb,' has',nnh,' hydrogens bonded to it'
c           write (77,*) 'ia,ihb,nh12=',ia,ihb,nh12
            call angdistw(c(1,ihb),c(1,ia),c(1,nh12(1)),rHB,rb,rab,ang)
            ang=ang*radtodeg
            if (ang .lt. angmin) then
              call angdistw(c(1,ihb),c(1,ia),c(1,nh12(2)),rHB,rb,rab,
     -          ang)
              ang=ang*radtodeg
            end if
            call readint(line(index(ia)),irn1,irn2,irna,2)
            call readint(line(index(ihb)),irn1,irn2,irnb,2)
            linep(ja)=blankline
            write (linep(ja),2041) ia,line(index(ia))(ic1:ic2),irna,
     -        line(index(ia))(ir1:ir2),ihb,line(index(ihb))(ic1:ic2),
     -        irnb,line(index(ihb))(ir1:ir2),rHB,ang
          end do
          do ja=1,min0(25,nhbneig(ia))
            call writeline(iwhbl,linep(ja),1,79,0)
          end do
        end if
      end do
      if (nconfig .le. maxrepconf) then
        if (nhbonds .gt. 0) then
          write (6,2049) nconfig,nhbonds
          write (6,2043) 'Shortest',rDHmin,imn1,imn2
          write (6,2043) 'Longest ',rDHmax,imx1,imx2
        else
          if (nhats .eq. 0) then
            print *,'WARNING: structure contains NO hydrogens'
          else
            print *,'No hydrogen bonds found - try with a larger factor'
          end if
        end if
      end if
      return
2040  format(i5,1x,a4,i4,1x,a4,' -',i5,1x,a4,i4,1x,a4,
     -  ' rHA=',f4.2,' a(D-H..A)=',f6.1,' rDA=',f4.2,1x,a1,'-',a1)
2041  format(i5,1x,a4,i4,1x,a4,' -',i5,1x,a4,i4,1x,a4,
     -  ' rO+=',f4.2,' a(+..O-H)=',f6.1)
2043  format(1x,a8,' D-H bond=',f8.3,' between atoms',i5,' and',i5)
2049  format(' Frame ',i6,' Number of hydrogen bonds found=',i5)
      end
      subroutine hph_sltblist(c,n,nhbneig,ineig,iout,ic1,ic2,ir1,ir2,
     -  irn1,irn2,line,index,rlab,lrlab,maxng)
      dimension c(3,n),ineig(maxng,n),nhbneig(n),index(n)
      character* 132 line(n)
      character*(*) rlab
c     print *,'HPHLIST n,maxng=',n,maxng
      do ia=1,n
        do jaa=1,nhbneig(ia)
          ja=ineig(maxng-jaa+1,ia)
          call readint(line(index(ia)),irn1,irn2,irnia,2)
          call readint(line(index(ja)),irn1,irn2,irnja,2)
          write (iout,2040) ia,line(index(ia))(ic1:ic2),irnia,
     -      line(index(ia))(ir1:ir2),ja,line(index(ja))(ic1:ic2),
     -      irnja,line(index(ja))(ir1:ir2),rlab(1:lrlab),
     -      sqrt(dist2(c(1,ia),c(1,ja)))
        end do
      end do
      return
2040  format(i5,1x,a4,i4,1x,a4,' -',i5,1x,a4,i4,1x,a4,' r(',a,')=',f6.1)
      end
      subroutine checknnlist(nfrst,n,ineig,nneig,nerr,maxng)
      dimension nneig(n),ineig(maxng,n)
c     Check for consistency of the neighbpor list
      nerr=0
      do ia=nfrst,n
        do ja=1,nneig(ia)
          ib=ineig(ja,ia)
          if (ib .lt. 1 .or. ib .gt. n) then
            print *,'PROGRAM ERROR: atom',ia,' has an invalid ',
     -        'bonded partner'
            nerr=nerr+1
          else if (nneig(ib) .eq. 0) then
            print *,'PROGRAM ERROR: atom',ib,' is bonded to',ia
            print *,'but it has no bonds listed'
            nerr=nerr+1
          else
            do jja=ja+1,nneig(ia)
              if (ineig(jja,ia) .eq. ib) then
                print *,'PROGRAM ERROR: ',
     -            'Duplicate bond partner of',ia,':',ib
                nerr=nerr+1
              end if
            end do
            do ii=1,nneig(ib)
              if (ineig(ii,ib) .eq. ia) go to 200
            end do
            print *,'PROGRAM ERROR: atom ',ia,' is not bonded to',ib
            nerr=nerr+1
200         continue
          end if
        end do
      end do
      if (nerr .gt. 0)
     -  print *,'NN list check for',n,' atoms done # of errors=',nerr
      return
      end
      subroutine checkhblist(n,ineig,nhbneig,maxng)
      dimension nhbneig(n),ineig(maxng,n)
c     Check for consistency of the H-bond list
c     print *,'CHECKHBLIST n=',n
      do ia=1,n
        do ja=1,nhbneig(ia)
          ihb=ineig(maxng+1-ja,ia)
          if (nhbneig(ihb) .eq. 0) then
            print *,'PROGRAM ERROR: atom',ihb,' is on the HB list',
     -        ' of',ia
            print *,'but it has no HB partner listed'
          else
            do jja=1,ja-1
              if (ineig(maxng+1-jja,ia) .eq. ihb)
     -          print *,'Duplicate H-bond partner of',ia,':',ihb
            end do
            do ii=maxng+1-nhbneig(ihb),maxng
              if (ineig(ii,ihb) .eq. ia) go to 200
            end do
            print *,'PROGRAM ERROR: atom ',ia,' is not on the HB list',
     -        ' of',ihb
200         continue
          end if
        end do
      end do
      return
      end
      subroutine rrdist(c,n,nres,ixresno,iresno,ixres,resnames,ifres,
     -  ilres,increst,incsolvrr,irefres1,irefres2,irefseg1,irefseg2,
     -  irefresinc,resdistlim,inegres1,inegres2,inegseg1,inegseg2,
     -  inegresinc,resapplim,listrefres,nrefres,nrefrange,listnegres,
     -  nnegres,nnegrange,iatnum,ignoreh,nframe,itypavg,iwrrdr,
     -  iwrrdc,iwrrmp,ir1,ir2,ic1,ic2,is1,is2,irescount1,irescount2,
     -  irescount3,line,index,indexn,indexo,itemp1,itemp2,itemp3,
     -  itemp4,temp1,temp2,maxrec,maxrsd)
      dimension c(3,n),iresno(n),ixresno(maxrsd),ixres(n),index(n),
     -  indexn(n),indexo(n),ifres(n),ilres(n),iatnum(n),
     -  listrefres(maxrsd),listnegres(maxrsd),
     -  irescount1(maxrsd),irescount2(maxrsd),irescount3(maxrsd),
     -  itemp1(n),itemp2(n),itemp3(n),itemp4(n),temp1(n),temp2(n)
      character*8 resnames(maxrsd)
      character* 132 line(maxrec)
      parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
      parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
     -  (9*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
      common /nnwork/ sdm(MAX2D,MAX2D),nng(MAX2D),rmsd(MAX2D,MAX2D),
     -  ihbpair(2,MAXBONDS),ihb_pair_res(3,MAXBONDS),ihbtores(MAXBONDS),
     -  iusepair(MAXBONDS),a1(MAXBONDS),a2(MAXBONDS),fill(IFILL2)
      call header_rrdist(iwrrdr,nrefrange,nnegrange,resdistlim,
     -  irefseg1,ixresno(irefres1),irefseg2,ixresno(irefres2),irefres1,
     -  irefres2,inegseg1,ixresno(inegres1),inegseg2,ixresno(inegres2),
     -  inegres1,inegres2,incsolvrr,listrefres,listnegres,nrefres,
     -  nnegres,itemp1,maxrsd)
      call header_rrdist(iwrrdc,nrefrange,nnegrange,resapplim,
     -  irefseg1,ixresno(irefres1),irefseg2,ixresno(irefres2),irefres1,
     -  irefres2,inegseg1,ixresno(inegres1),inegseg2,ixresno(inegres2),
     -  inegres1,inegres2,incsolvrr,listrefres,listnegres,nrefres,
     -  nnegres,itemp1,maxrsd)
      call header_rrdist(iwrrmp,nrefrange,nnegrange,0.0,
     -  irefseg1,ixresno(irefres1),irefseg2,ixresno(irefres2),irefres1,
     -  irefres2,inegseg1,ixresno(inegres1),inegseg2,ixresno(inegres2),
     -  inegres1,inegres2,incsolvrr,listrefres,listnegres,nrefres,
     -  nnegres,itemp1,maxrsd)
      write (iwrrdr,1004) 'reference','neighbour','representative atoms'
      write (iwrrdc,1004) 'reference','neighbour','closest approach'
      if (ignoreh .eq. 1) write (iwrrdc,1002) 'Closest approach'
      if (nframe .eq. 1 .and. itypavg .gt. 0) then
        do irr=irefres1,irefres2
          do inr=inegres1,inegres2
            rmsd(irr-irefres1+1,inr-inegres1+1)=0.0
            sdm(irr-irefres1+1,inr-inegres1+1)=0.0
          end do
        end do
      end if
      resdlim2=resdistlim**2
      resalim2=resapplim**2
      call zeroiti(indexo,0,n)
      call zeroiti(indexn,0,n)
      call zeroiti(itemp1,0,n)
      call zeroiti(itemp2,0,n)
      irramin=0
      ncontact1=0
      distcontactsum1=0.0
      ncontact2=0
      distcontactsum2=0.0
      do irrr=1,nrefres
        irr=listrefres(irrr)
c       First find the representative atom and atom range for residue irr
        call findat(irarep,ifres(irr),ilres(irr),line,index,
     -    ir1,ic1,maxrec)
c       write (iwrrdc,7711) irr,irarep,irra1,irra2,
c    -     line(index(irarep))(ir1:ir1+3),
c    -     line(index(irarep))(ic1:ic2)
c7711  format('irr,irarep=',2i5,' irra1,irra2=',2i5,' r,a=',2a5)
        inramin=0
        do inrr=1,nnegres
          inr=listnegres(inrr)
          if (inr .ne. irr) then
            call findat(inarep,ifres(inr),ilres(inr),line,index,
     -        ir1,ic1,maxrec)
c           Calculate first based on representative atoms
            r2=dist2(c(1,irarep),c(1,inarep))
            if (r2 .lt. resdlim2) then
              indexo(irr)=irarep
              indexo(inr)=inarep
              call writeprox(iwrrdr,irarep,inarep,line,index,r2,
     -          iresno,ir1,ir2,ic1,ic2,is1,is2,maxrec)
              itemp1(irr)=1
              itemp1(inr)=1
              irescount1(irr)=irescount1(irr)+1
              irescount1(inr)=irescount1(inr)+1
              ncontact1=ncontact1+1
              distcontactsum1=distcontactsum1+r2
            end if
            if (itypavg .eq. 1) then
              rmsd(irr-irefres1+1,inr-inegres1+1)=
     -          rmsd(irr-irefres1+1,inr-inegres1+1)+sqrt(r2)
              sdm(irr-irefres1+1,inr-inegres1+1)=
     -          sdm(irr-irefres1+1,inr-inegres1+1)+r2
            end if
c           Now obtain closest approach
            call findapproach(c,ifres(irr),ilres(irr),ifres(inr),
     -        ilres(inr),iatnum,ignoreh,irarepm,inarepm,rmin2,maxrec)
            if (rmin2 .lt. resalim2) then
              indexn(irr)=1
              indexn(inr)=1
              call writeprox(iwrrdc,irarepm,inarepm,line,index,
     -          rmin2,iresno,ir1,ir2,ic1,ic2,is1,is2,maxrec)
              itemp2(irr)=1
              itemp2(inr)=1
              irescount2(irr)=irescount2(irr)+1
              irescount2(inr)=irescount2(inr)+1
              ncontact2=ncontact2+1
              distcontactsum2=distcontactsum2+rmin2
            end if
            if (itypavg .eq. 2) then
              rmsd(irr-irefres1+1,inr-inegres1+1)=
     -          rmsd(irr-irefres1+1,inr-inegres1+1)+sqrt(rmin2)
              sdm(irr-irefres1+1,inr-inegres1+1)=
     -          sdm(irr-irefres1+1,inr-inegres1+1)+rmin2
            end if
          end if
        end do
      end do
      if (ncontact1 .gt. 0)
     -  write (iwrrdr,1001) ncontact1,distcontactsum1/ncontact1
      if (ncontact2 .gt. 0)
     -  write (iwrrdc,1001) ncontact2,distcontactsum2/ncontact2
      call writeuniquelist(itemp1,ixresno,nres,resnames,ir2-ir1+1,
     -  iwrrdr,irefres1,irefres2,irefresinc,itemp3,itemp4,
     -  'reference',9,maxrsd)
      call writeuniquelist(itemp1,ixresno,nres,resnames,ir2-ir1+1,
     -  iwrrdr,inegres1,inegres2,inegresinc,itemp3,itemp4,
     -  'neighbour',9,maxrsd)
      call writeuniquelist(itemp2,ixresno,nres,resnames,ir2-ir1+1,
     -  iwrrdc,irefres1,irefres2,irefresinc,itemp3,itemp4,
     -  'reference',9,maxrsd)
      call writeuniquelist(itemp2,ixresno,nres,resnames,ir2-ir1+1,
     -  iwrrdc,inegres1,inegres2,inegresinc,itemp3,itemp4,
     -  'neighbour',9,maxrsd)
      call zeroiti(itemp1,0,n)
      do i=1,nrefres
        itemp1(listrefres(i))=1
      end do
      do i=1,nnegres
        itemp1(listnegres(i))=1
      end do
      call masktolist(itemp2,itemp1,nres,ncomplneg,0)
c     itemp2 is the list of residues not on the neigbor and reference ist
      if (ncomplneg .gt. 0 .and. increst .gt. 0) then
        write (iwrrdr,1004) 'reference','other','representative atoms'
        write (iwrrdc,1004) 'reference','other','closest approach'
        irramin=0
        do irrr=1,nrefres
          irr=listrefres(irrr)
          if (indexo(irr) .gt. 0 .or. indexn(irr) .eq. 0) then
            call findat(irarep,ifres(irr),ilres(irr),line,index,
     -        ir1,ic1,maxrec)
            inramin=0
            do irrr1=1,ncomplneg
              irr1=itemp2(irrr1)
              if ((irr1 .lt. inegres1 .or. irr1 .gt. inegres2)
     -           .and. irr .ne. irr1) then
                call findat(inarep,ifres(irr1),ilres(irr1),line,
     -            index,ir1,ic1,maxrec)
                if (indexo(irr) .gt. 0 .and. indexo(irr1) .eq. 0) then
                  r2=dist2(c(1,irarep),c(1,inarep))
                  if (r2 .lt. resdlim2)
     -              call writeprox(iwrrdr,irarep,inarep,line,
     -                index,r2,iresno,ir1,ir2,ic1,ic2,is1,is2,maxrec)
                end if
                if (indexn(irr) .gt. 0 .and. indexn(irr1) .eq. 0) then
                  call findapproach(c,ifres(irr),ilres(irr),
     -              ifres(irr1),ilres(irr1),iatnum,ignoreh,irarepm,
     -              inarepm,r2,maxrec)
                  if (r2 .lt. resalim2)
     -              call writeprox(iwrrdc,irarepm,inarepm,line,
     -                index,r2,iresno,ir1,ir2,ic1,ic2,is1,is2,maxrec)
                  end if
                end if
            end do
          end if
        end do
        write (iwrrdr,1004) 'neighbour','other','representative atoms'
        write (iwrrdc,1004) 'neighbour','other','closest approach'
        inramin=0
        do irrr=1,nnegres
          irr=listnegres(irrr)
          if (indexo(irr) .gt. 0 .or. indexn(irr) .eq. 0) then
            call findat(inarep,ifres(irr),ilres(irr),line,index,
     -        ir1,ic1,maxrec)
            irramin=0
            do irrr1=1,ncomplneg
              irr1=itemp2(irrr1)
              if ((irr1 .lt. irefres1 .or. irr1 .gt. irefres2)
     -           .and. irr .ne. irr1) then
                call findat(irarep,ifres(irr1),ilres(irr1),line,
     -            index,ir1,ic1,maxrec)
                if (indexo(irr) .gt. 0 .and. indexo(irr1) .eq. 0) then
                  r2=dist2(c(1,irarep),c(1,inarep))
                  if (r2 .lt. resdlim2)
     -              call writeprox(iwrrdr,inarep,irarep,line,
     -                index,r2,iresno,ir1,ir2,ic1,ic2,is1,is2,maxrec)
                end if
                if (indexn(irr) .gt. 0 .and. indexn(irr1) .eq. 0) then
                  call findapproach(c,ifres(irr),ilres(irr),
     -              ifres(irr1),ilres(irr1),iatnum,ignoreh,irarepm,
     -              inarepm,r2,maxrec)
                  if (r2 .lt. resalim2)
     -              call writeprox(iwrrdc,irarepm,inarepm,line,
     -                index,r2,iresno,ir1,ir2,ic1,ic2,is1,is2,maxrec)
                  end if
                end if
            end do
          end if
        end do
      end if
c     Calculate contact pairs
      write (iwrrmp,1003) 
      if (ignoreh .eq. 1) write (iwrrmp,1002) 'Contact calculation'
c     Put the ref and neg atom lists into itemp3, itemp4. resp
      nrefat=0
      do irr=1,nrefres
        ir=listrefres(irr)
        do ia=ifres(ir),ilres(ir)
          if (ignoreh .eq. 0 .or. iatnum(ia) .gt. 1) then
            nrefat=nrefat+1
            itemp3(nrefat)=ia
          end if
        end do
      end do
      nnegat=0
      do irr=1,nnegres
        ir=listnegres(irr)
        do ia=ifres(ir),ilres(ir)
          if (ignoreh .eq. 0 .or. iatnum(ia) .gt. 1) then
            nnegat=nnegat+1
            itemp4(nnegat)=ia
          end if
        end do
      end do
c     Find the proximal atoms for the ref and neg residues
      do ia=1,n
        temp1(ia)=100000.0
        temp2(ia)=100000.0
      end do
      do iaa=1,nrefat
        ia=itemp3(iaa)
        do jaa=1,nnegat
          ja=itemp4(jaa)
          rijsq=dist2(c(1,ia),c(1,ja))
          if (rijsq .lt. temp1(ia)) then
            itemp1(ia)=ja
            temp1(ia)=rijsq
          end if
          if (rijsq .lt. temp2(ja)) then
            itemp2(ja)=ia
            temp2(ja)=rijsq
          end if
        end do
      end do
      ncontact1=0
      distcontactsum1=0.0
      call zeroiti(indexo,0,n)
      call zeroiti(indexn,0,n)
      do iaa=1,nrefat
        ia=itemp3(iaa)
        if (itemp1(ia) .gt. 0) then
          if (itemp2(itemp1(ia)) .eq. ia) then
c           Mutually proximal atom pair found
            call writeprox(iwrrmp,ia,itemp1(ia),line,index,temp1(ia),
     -        iresno,ir1,ir2,ic1,ic2,is1,is2,maxrec)
            indexo(ixres(ia))=1
            indexn(ixres(itemp1(ia)))=1
            irescount3(ixres(ia))=irescount3(ixres(ia))+1
            irescount3(ixres(itemp1(ia)))=irescount3(ixres(ia))+1
              ncontact1=ncontact1+1
              distcontactsum1=distcontactsum1+temp1(ia)
          end if
        end if
      end do
      if (ncontact1 .gt. 0)
     -  write (iwrrmp,1001) ncontact1,distcontactsum1/ncontact1
      call writeuniquelist(indexo,ixresno,nres,resnames,ir2-ir1+1,
     -  iwrrmp,irefres1,irefres2,irefresinc,itemp1,itemp2,
     -  'reference',9,maxrsd)
      call writeuniquelist(indexn,ixresno,nres,resnames,ir2-ir1+1,
     -  iwrrmp,inegres1,inegres2,inegresinc,itemp1,itemp2,
     -  'neighbour',9,maxrsd)
      return
1001  format(' Number of residue pairs within threshold=',i6,
     -  ' Average distance=',f5.2,' A')
1002  format(1x,a,' is based on heavy atoms only')
1003  format(' Contact atom pairs are the atoms that are mutually ',
     -  'proximal to each other')
1004  format(/,' Residue distances between the ',a,' and ',a,
     -  ' residues, based on the',/,1x,a,':')
      end
      subroutine header_rrdist(iw,nrefrange,nnegrange,resdistlim,
     -  irefseg1,ixrefres1,irefseg2,ixrefres2,irefres1,irefres2,
     -  inegseg1,ixnegres1,inegseg2,ixnegres2,inegres1,inegres2,
     -  incsolvrr,listrefres,listnegres,nrefres,nnegres,itemp,maxrsd)
      dimension listrefres(maxrsd),listnegres(maxrsd),itemp(maxrsd)
      write (iw,*)
      write (iw,2000) 'Reference',irefseg1,ixrefres1,irefseg2,
     -  ixrefres2,irefres1,irefres2
      if (nrefrange .gt. 1) then
        write (iw,2001) 'Reference'
        call zeroiti(itemp,0,maxrsd)
        do i=1,nrefres
          itemp(listrefres(i))=1
        end do
        call condensemask(itemp,1,listrefres(nrefres),iw,maxrsd)
      end if
      write (iw,2000) 'Neighbour',inegseg1,ixnegres1,inegseg2,
     -  ixnegres2,inegres1,inegres2
      if (nnegrange .gt. 1) then
        write (iw,2001) 'Neighbor'
        call zeroiti(itemp,0,maxrsd)
        do i=1,nnegres
          itemp(listnegres(i))=1
        end do
        call condensemask(itemp,1,listnegres(nnegres),iw,maxrsd)
      end if
      write (iw,2003)
      if (resdistlim .gt. 0.0) write (iw,2002) resdistlim
      if (incsolvrr .eq. 1) write (iw,2004) 'included'
      if (incsolvrr .eq. -1) write (iw,2004) 'excluded'
2000  format(1x,a,' residue range:',/,
     -  ' chain',i3,' res ',i5,' - ', 'chain',i3,' res ',i5,
     -  ' (residue serial #s',i5,' - ',i5,')')
2001  format(' NOTE: ',a,' residue range has gaps - actual ',
     -  'ranges:')
2002  format(' Residue pairs will be printed when the calculated ',
     -  'distance is <',f6.2,' A')
2003  format(" Residues not defined as 'reference' or 'neigbour' ",
     -  "residues are called 'other'")
2004  format(' Solvents are ',a,' in the additional neighbor list')
      return
      end
      subroutine mmdist(c,n,atw,iatnum,nmolslt,molsltlim,c2,dist,
     -  ignoreh,iw0,iw1)
      dimension c(3,n),atw(n),iatnum(n),molsltlim(3,n),c2(3,n),dist(n)
      real*8 c0(3),atwsum
c     print *,'MMDIST nmolslt,nmc,iw0,iw1=',nmolslt,nmc,iw0,iw1
      do im=1,nmolslt
        call zeroitd(c0,3)
        atwsum=0.d0
        do ia=molsltlim(1,im),molsltlim(2,im)
          atwsum=atwsum+atw(ia)
          do k=1,3
            c0(k)=c0(k)+atw(ia)*c(k,ia)
          end do
          do k=1,3
            c0(k)=c0(k)+atw(ia)*c(k,ia)
          end do
        end do
        do k=1,3
          c2(k,im)=c0(k)/atwsum
        end do
      end do
      do im=1,nmolslt
        do imm=1,nmolslt
          dist(imm)=sqrt(dist2(c2(1,im),c2(1,imm)))
        end do
        write (iw0,1000) im,(dist(imm),imm=1,nmolslt)
        do imm=1,nmolslt
          rdist2=999999.0
          do iam=molsltlim(1,im),molsltlim(2,im)
            if (ignoreh .eq. 0) then
              do iamm=molsltlim(1,imm),molsltlim(2,imm)
                d2=dist2(c(1,iam),c(1,iamm))
                if (d2 .lt. rdist2) rdist2=d2
              end do
            else
              if (iatnum(iam) .gt. 1) then
                do iamm=molsltlim(1,imm),molsltlim(2,imm)
                  if (iatnum(iamm) .gt. 1) then
                    d2=dist2(c(1,iam),c(1,iamm))
                    if (d2 .lt. rdist2) rdist2=d2
                  end if
                end do
              end if
            end if
          end do
          dist(imm)=sqrt(rdist2)
        end do
        write (iw1,1000) im,(dist(imm),imm=1,nmolslt)
      end do
      return
1000  format(' im=',i4,' D=',5f12.5,/,(11x,5f12.5))
      end
      subroutine writeprox(iout,irarep,inarep,line,index,r2,iresno,
     -  ir1,ir2,ic1,ic2,is1,is2,maxrec)
      dimension index(maxrec),iresno(maxrec)
      character* 132 line(maxrec)
c      write (6,1000) index(irarep),index(inarep)
c1000  format(' index(ir/n)=',2i4)
      r2=sqrt(r2)
      write (iout,2060) line(index(irarep))(is1:is2),
     -  line(index(irarep))(ir1:ir2),iresno(irarep),
     -  line(index(irarep))(ic1:ic2),
     -  irarep,line(index(inarep))(is1:is2),
     -  line(index(inarep))(ir1:ir2),iresno(inarep),
     -  line(index(inarep))(ic1:ic2),inarep,r2
      return
2060  format(1x,a,1x,a,' (',i4,') ',a,' (',i5,') - ',a,1x,a,
     -  ' (',i4,') ',a,' (',i5,')  Dist=',f8.3,' A')
      end
      subroutine writeuniquelist(index,ixresno,n,resnames,nrcol,iout,
     -  ires1,ires2,iresinc,itemp1,itemp2,label,llabel,mxrsd)
      dimension index(mxrsd),ixresno(mxrsd),itemp1(mxrsd),itemp2(mxrsd)
      character*(*) label
      character*8 resnames(mxrsd)
c     print *,'WRITEUNIQUELIST ires1,ires2=',ires1,ires2,
c    -  ' lab=',label(1:llabel)
      nmem=0
      call zeroiti(itemp1,0,n)
      call zeroiti(itemp2,0,n)
      do i=ires1,ires2
        if (index(i) .ne. 0) then
          nmem=nmem+1
          itemp1(nmem)=i
        else
          itemp2(i)=i
        end if
      end do
c     if (nmem .eq. 0) print *,'WRITEUNIQUELIST nmem=',nmem,
c    -  ' ires1,ires2=',ires1,ires2
      if (nmem .eq. 0) then
        write (iout,1003) 'contact',label(1:llabel)
      else
        write (iout,1000) 'contact',label(1:llabel),
     -   (' (',resnames(itemp1(i))(1:nrcol),ixresno(itemp1(i)),i=1,nmem)
        write (iout,1001) 'contact',label(1:llabel)
        call condensemask(index,ires1,ires2,iout,mxrsd)
        if (iresinc .gt. 0) write (iout,1002) iresinc
      end if
      nnonmem=0
      do i=1,n
        if (itemp2(i) .ne. 0) then
          nnonmem=nnonmem+1
          itemp1(nnonmem)=i
        end if
      end do
      if (nnonmem .gt. 0) then
        write (iout,1000) 'non-contact',label(1:llabel),
     -    (' (',resnames(itemp1(i))(1:nrcol),ixresno(itemp1(i)),
     -    i=1,nnonmem)
        write (iout,1001) 'non-contact',label(1:llabel)
        call condensemask(itemp2,ires1,ires2,iout,mxrsd)
        if (iresinc .gt. 0) write (iout,1002) iresinc
      end if
      return
1000  format(' Nonredundant list of ',a,1x,a,' residues:',/,
     -  5(a,a,i5,')'))
1001  format(' Residue SEQUENCE numbers of the ',a,1x,a,' residues:')
1002  format(' Residue numbers are decremented by',i5,' to give the ',
     -  'sequence numbers')
1003  format(' List of ',a,1x,a,' residue numbers is empty')
      end
      subroutine condenselist(index,len,incr,iout)
      dimension index(len)
      character*80 line
c     print *,'CONDENSELIST len=',len
      i=1
      i1=index(1)
      i2=index(1)
      ic=1
      do while (i .lt. len)
        i=i+1
        if (index(i) .eq. index(i-1)+1 .and. i .lt. len) then
          i2=i2+1
        else
c         Range found
          if (i .eq. len) i2=index(i)
          call printrange(line,i1,i2,ic,incr,iout)
          i1=index(i)
          i2=index(i)
        end if
      end do
      if (ic .gt. 1) write (iout,1000) line(1:ic-2)
      return
1000  format(1x,a)
      end
      subroutine condensemask(index,ires1,ires2,iout,mxrsd)
      dimension index(mxrsd)
      character*80 line
c     print *,'CONDENSEMASK ires1,ires2=',ires1,ires2,' iout=',iout
c      write (6,8888) (index(i),i=1,n)
c8888  format(' index:',/,(10i5))
      ic=1
      i=ires1
      do while (i .le. ires2)
c       Find first/next nonzero
        do while (index(i) .eq. 0 .and. i .le. ires2)
          i=i+1
        end do
        if (i .le. ires2) then
c         Find out if singleton or range
          i1=i
          do while (index(i) .gt. 0 .and. i .le. ires2)
            i=i+1
          end do
          i2=i-1
c         print *,'i1=',i1,' i2=',i2,' ic=',ic
          call printrange(line,i1,i2,ic,0,iout)
        end if
      end do
      if (ic .gt. 1) write (iout,1000) line(1:ic-2)
      return
1000  format(1x,a)
      end
      subroutine printrange(line,i1,i2,ic,incr,iout)
      character*(*) line
      if (i1 .eq. i2) then
c       Singleton
        if (ic .gt. 72-incr) then
          write (iout,1000) line(1:ic-1)
          ic=1
        end if
        call writeint(line,ic,i1,lenw)
      else
c       Range
        if (ic .gt. 68-incr) then
          write (iout,1000) line(1:ic-1)
          ic=1
        end if
        call writeint(line,ic,i1,lenw)
        line(ic:ic)='-'
        ic=ic+1
        call writeint(line,ic,i2,lenw)
      end if
      line(ic:ic)=','
      ic=ic+1
      return
1000  format(1x,a)
      end
      subroutine print_rrdist(itypavg,nframe,irefres1,irefres2,inegres1,
     -  inegres2,listrefres,nrefres,listnegres,nnegres,nrescol,iwrrdr,
     -  iwrrdc,ips,ipspage,resnames,inpfile,namleni,itemp,igl,mxrsd)
      dimension itemp(mxrsd),listrefres(mxrsd),listnegres(mxrsd)
      character*8 resnames(mxrsd)
      character*(*) inpfile
      common /colorinfo/ ncolcode,maxcolcode
      parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
      parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
     -  (9*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
      common /nnwork/ sdm(MAX2D,MAX2D),nng(MAX2D),rmsd(MAX2D,MAX2D),
     -  ihbpair(2,MAXBONDS),ihb_pair_res(3,MAXBONDS),ihbtores(MAXBONDS),
     -  iusepair(MAXBONDS),a1(MAXBONDS),a2(MAXBONDS),fill(IFILL2)
      dimension kc(1,1),xyval(1)
      character*4 yclab(1)
      character*14 distlab
      character*80 title2
      real*8 dc(1,1)
      data nyclab /1/,lyclab /1/
      if (ips .eq. 0) return
      if (itypavg .eq. 1) then
        iw=iwrrdr
        distlab='representative'
        ldistlab=14
      else
        iw=iwrrdc
        distlab='closest'
        ldistlab=7
      end if
      title2='Maximum '//distlab(1:ldistlab)//
     -  ' atom based distance to print'
      ltitle2=ldistlab+37
      call getreal(title2,ltitle2,999999.0,rprtmax,1,0)
      title2='Average residue-residue distances based on '//
     -  distlab(1:ldistlab)//' atom distances'
      ltitle2=ldistlab+62
      write (iw,1001) title2(1:ltitle2)
      do irrr=1,nrefres
        irr=listrefres(irrr)
        do inrr=1,nnegres
          inr=listnegres(inrr)
          rmsd(irr-irefres1+1,inr-inegres1+1)=
     -      rmsd(irr-irefres1+1,inr-inegres1+1)/float(nframe)
          sdm(irr-irefres1+1,inr-inegres1+1)=
     -    sqrt(sdm(irr-irefres1+1,inr-inegres1+1)/float(nframe)-
     -    rmsd(irr-irefres1+1,inr-inegres1+1)**2)
          if (rmsd(irr-irefres1+1,inr-inegres1+1) .le. rprtmax)
     -      write (iw,1000) irr,resnames(irr)(1:nrescol),inr,
     -        resnames(inr)(1:nrescol),
     -        rmsd(irr-irefres1+1,inr-inegres1+1),
     -        sdm(irr-irefres1+1,inr-inegres1+1)
        end do
      end do
      call getreal('Upper limit of the distance matrix scale',40,
     -  999999.0,rcmax,1,0)
      rcmin=0.0
      call getint('Number of colors to use',23,5,1,maxcolcode,ncolcode,
     -  0)
      nresx=irefres2-irefres1+1
      nresy=inegres2-inegres1+1
c      do in=1,nresy
c        write (iw,9855) in+inegres1-1,(rmsd(ir,in),ir=1,nresx)
c9855    format(' in=',i4,200f6.2)
c      end do
      scalefac=amin1(1.0,500.0/float(max0(nresx,nresy)))
      ixdel=25
      iydel=115
      incinp=max0(1,500/max0(nresx,nresy))
      call indexit(itemp,1,mxrsd,0)
      call plotmat(ips,kc,rmsd,dc,nresx,nresy,irefres1-1,inegres1-1,
     -  irefres1-1,inegres1-1,1,0,0,iydel,00,iytop,rcmin,rcmax,ncolcode,
     -  maxcolcode,ixdel,iydel,incinp,scalefac,itemp,itemp,itemp,
     -  inpfile,namleni,title2,ltitle2,' ',0,xyval,yclab,nyclab,lyclab,
     -  igl,1,MAX2D,1,mxrsd,mxrsd,ipspage,0)
      ixd=ixdel
      if (ncolcode .le. 5) ixd=ixd+60
c     print *,'RCMIN,RCMAX=',rcmin,rcmax
      call colcodeminmax(ips,ixd,-60,0,ncolcode,maxcolcode,rcmin,rcmax)
      return
1000  format(' Res #',i6,'(',a,') - Res #',i6,'(',a,'): <d>=',f8.4,
     -  ' A sd=',f8.4)
1001  format(/,1x,a,' averages over the trajectory',/)
      end
      subroutine compare_rrdist(resnames,nrescol,itemp,bfac,irefres1,
     -  irefres2,plotfile,lplotfile,igl,mxrsd)
      dimension itemp(mxrsd),bfac(mxrsd)
      character*8 resnames(mxrsd)
      parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
      parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
     -  (9*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
      common /nnwork/ rr1(MAX2D,MAX2D),nng(MAX2D),rr2(MAX2D,MAX2D),
     -  ihbpair(2,MAXBONDS),ihb_pair_res(3,MAXBONDS),ihbtores(MAXBONDS),
     -  iusepair(MAXBONDS),a1(MAXBONDS),a2(MAXBONDS),fill(IFILL2)
      common /colorinfo/ ncolcode,maxcolcode
      character*4 yclab(1)
      character*80 plotfile,title2,inpfile1,inpfile2
      character*80 title1
      dimension kc(1,1),xyval(1)
      real*8 dc(1,1)
      data nyclab /1/,lyclab /1/
c     print *,'COMPARE_RRDIST maxcolcode,mxrsd=',maxcolcode,mxrsd
      ifail=1
      do while (ifail .eq. 1)
        call read_rrdist(rr1,41,'first',5,irefres1,irefres2,inegres1,
     -    inegres2,inpfile1,linpfile1,ifail1,MAX2D)
        call read_rrdist(rr2,41,'second',6,irefres11,irefres22,
     -    inegres11,inegres22,inpfile2,linpfile2,ifail2,MAX2D)
        if (irefres1 .ne. irefres11 .or. irefres2 .ne. irefres22 .or.
     -      inegres1 .ne. inegres11 .or. inegres2 .ne. inegres22) then
          print *,'Residue ranges differ - can not run the comparison'
        else 
          ifail=ifail1+ifail2
        end if
        if (ifail .gt. 0) write (6,1005)
      end do
      lplotfile=0
      call openfile(42,0,'average distance matrix difference',34,'new',
     -  plotfile,lplotfile,notfnd,0,1,1,0,0)
      rdmin=99999.0
      rdmax=-rdmin
      call askyn('Do you want absolute values in the difference plot',
     -  50,1,-1,iabsval,0)
      call getreal('Maximum distance to show',24,10000.0,dmaxshow,1,132)
      call zeroit(bfac,mxrsd)
      ncount_tot=0
      do irr=irefres1,irefres2
        ir=irr-irefres1+1
        ncount=0
        do inr=inegres1,inegres2
          in=inr-inegres1+1
          diffrn=rr1(ir,in)-rr2(ir,in)
          write (42,1000) irr,resnames(irr)(1:nrescol),
     -      inr,resnames(inr)(1:nrescol),rr1(ir,in),rr2(ir,in),diffrn
          if (iabsval .eq. 1) diffrn=abs(diffrn)
          if (diffrn .lt. rdmin) rdmin=diffrn
          if (diffrn .gt. rdmax) rdmax=diffrn
          if (rr1(ir,in) .gt. dmaxshow .and.
     -        rr2(ir,in) .gt. dmaxshow) then
            rr1(ir,in)=0.0
          else
            rr1(ir,in)=diffrn
            bfac(irr)=bfac(irr)+abs(rr1(ir,in))
            ncount=ncount+1
          end if
        end do
        ncount_tot=ncount_tot+ncount
        write (42,1002) ' N',dmaxshow,ncount
        if (ncount .eq. 0) ncount=1
        bfac(irr)=bfac(irr)/float(ncount)
      end do
      write (42,1002) ' Total n',dmaxshow,ncount_tot
      write (42,1003) dmaxshow
      do irr=irefres1,irefres2
        ir=irr-irefres1+1
        do inr=inegres1,inegres2
          in=inr-inegres1+1
          if (rr1(ir,in) .ne. 0.0) write (42,1004) irr,
     -      resnames(irr)(1:nrescol),inr,resnames(inr)(1:nrescol),
     -      rr1(ir,in),rr2(ir,in)
        end do
      end do
      if (iabsval .eq. 1) rdmin=0.0
      close (42)
      ips=43
      plotfile(lplotfile+1:lplotfile+3)='.ps'
      lplotfile=lplotfile+3
      call openfile(ips,0,'average distance matrix difference',34,'new',
     -  plotfile,lplotfile,notfnd,0,1,1,0,0)
      write (6,1001) plotfile(1:lplotfile),rdmin,rdmax
      title2='Average distance matrix difference plot'
      ltitle2=39
      ltitle1=linpfile1+linpfile2+3
      title1(1:ltitle1)=
     -  inpfile1(1:linpfile1)//' - '//inpfile2(1:linpfile2)
      call openps(ips,500.0,500.0,' ',1,' ',1,plotfile,0,
     -  plotfile,0,1,ipspage)
      call getint('Number of colors to use',23,5,1,maxcolcode,ncolcode,
     -  0)
      nresx=irefres2-irefres1+1
      nresy=inegres2-inegres1+1
      scalefac=amin1(1.0,500.0/float(max0(nresx,nresy)))
      ixdel=25
      iydel=115
      incinp=max0(1,500/max0(nresx,nresy))
      call indexit(itemp,1,mxrsd,0)
      call plotmat(ips,kc,rr1,dc,nresx,nresy,irefres1-1,inegres1-1,0,0,
     -  1,0,0,iydel,00,iytop,rdmin,rdmax,ncolcode,maxcolcode,ixdel,
     -  iydel,incinp,scalefac,itemp,itemp,itemp,title1,ltitle1,title2,
     -  ltitle2,' ',0,xyval,yclab,nyclab,lyclab,igl,1,MAX2D,1,mxrsd,
     -  mxrsd,ipspage,0)
      ixd=ixdel
      if (ncolcode .le. 5) inxd=ixd+60
      call colcodeminmax(ips,ixd,-60,0,ncolcode,maxcolcode,rdmin,rdmax)
      return
1000  format(' Res #',i6,'(',a,') - Res #',i6,'(',a,'):<d1>=',f6.2,
     -  ' <d2>=',f6.2,' <d1>-<d2>=',f7.3)
1001  format(' Residue distance difference matrix plots are on file ',a,
     -  /,' Range of differences: [',f10.5,',',f10.5,'] A')
1002  format(a,'umber of pairs within ',f5.1,' A:',i5)
1003  format(' Distance changes for pairs closer than ',f5.2,' A')
1004  format(' Res #',i6,'(',a,') - Res #',i6,'(',a,'):<d1>-<d2>=',f6.2,
     -  ' <d2>=',f6.2)
1005  format(' NOTE: input file should be the .rsd file written by the',
     -  /,'R<E>sidue distance list option of distance analysis')
      end
      subroutine read_rrdist(rr,inpt,lab,llab,irefres1,irefres2,
     -  inegres1,inegres2,inpmat,linpmat,ifail,mxdim)
      dimension rr(mxdim,mxdim)
      character*(*) lab
      character*80 inpmat,prompt,line
      ifail=0
      prompt(1:llab)=lab(1:llab)
      prompt(llab+1:llab+24)=' residue distance matrix'
      lprompt=llab+24
      linpmat=0
      call openfile(inpt,0,prompt,lprompt,'old',inpmat,linpmat,notfnd,
     -  0,1,1,0,0)
      if (inpmat(linpmat-3:linpmat) .ne. '.rsd' .and.
     -    inpmat(linpmat-3:linpmat) .ne. '.rsm') write (6,1002)
      istart=1
      nresfound=0
      do while (.true.)
        read (inpt,1000,end=999) line
        if (line(1:6) .eq. ' Res #') then
          nresfound=nresfound+1
          read (line(07:12),*,end=888,err=888) irefres
          read (line(27:32),*,end=888,err=888) inegres
          if (istart .eq. 1) then
            istart=0
            irefres1=irefres
            inegres1=inegres
          end if
          read (line(45:52),*,end=888,err=888)
     -      rr(irefres-irefres1+1,inegres-inegres1+1)
        end if
      end do
999   close (inpt)
      if (nresfound .gt. 0) then
        irefres2=irefres
        inegres2=inegres
        write (6,1001) irefres1,irefres2,inegres1,inegres2,nresfound
      else
        write (6,*) 'ERROR: No residue distance record was found'
        ifail=1
      end if
      return
888   print *,'ERROR reading record'
      print *,line(1:66)
      close (inpt)
      ifail=1
      return
cRes #     1(ILE ) - Res #     1(ILE ): <d>=  0.0000 A sd=  0.0000
1000  format(a)
1001  format(' Residue ranges found: [',i6,',',i6,'] and [',i6,',',
     -  i6,']',/,' Number of distance records read=',i4)
1002  format(' WARNING: input file extension is not .rsd or .rsm')
      end
      subroutine compare_bondmat(resnames,nrescol,itemp,bfac,nres,
     -  plotfile,lplotfile,igl,mxrsd)
      dimension itemp(mxrsd),bfac(mxrsd)
      character*8 resnames(mxrsd)
      character(*) plotfile
      parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
      parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
     -  (9*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
      common /nnwork/ rnb1(MAX2D,MAX2D),nng(MAX2D),rnb2(MAX2D,MAX2D),
     -  ihbpair(2,MAXBONDS),ihb_pair_res(3,MAXBONDS),ihbtores(MAXBONDS),
     -  iusepair(MAXBONDS),a1(MAXBONDS),a2(MAXBONDS),fill(IFILL2)
      common /colorinfo/ ncolcode,maxcolcode
      character*1 ans
      character*4 yclab(1)
      character*80 title2,inpfile1,inpfile2
      character*200 title1
      dimension kc(1,1),xyval(1)
      real*8 dc(1,1),sum1,sum2
      data nyclab /1/,lyclab /1/
c     print *,'COMPARE_BONDMAT maxcolcode=',maxcolcode,' MAX2D=',MAX2D
      call read_bondmat(rnb1,41,'first',5,nres,inpfile1,linpfile1,
     -  itemp,MAX2D)
c     do iy=1,nres
c       write (77,8811) iy,(rnb1(ix,iy),ix=1,nres)
c     end do
      call read_bondmat(rnb2,41,'second',6,nres,inpfile2,linpfile2,
     -  itemp,MAX2D)
c     do iy=1,nres
c       write (78,8811) iy,(rnb2(ix,iy),ix=1,nres)
c     end do
c8811  format(' iy=',i5,/,(10f7.2))
      lplotfile=0
      call openfile(42,0,'residue bond matrix difference',30,'new',
     -  plotfile,lplotfile,notfnd,0,1,1,0,0)
      call quiz(ans,idifftyp,' ',' ',0,'bond-difference plot type',25,
     -  0,5,6,igl,000)
      rnbmin=99999.9
      rnbmax=-rnbmin
      sum1=0.d0
      sum2=0.d0
      isum1=0
      isum2=0
      call zeroit(bfac,nres)
      do ir=1,nres
        do in=1,nres
          sum1=sum1+rnb1(ir,in)
          sum2=sum2+rnb2(ir,in)
          if (rnb1(ir,in) .gt. 0.0 .and. rnb2(ir,in) .eq. 0.0)
     -      isum1=isum1+1
          if (rnb1(ir,in) .eq. 0.0 .and. rnb2(ir,in) .gt. 0.0)
     -      isum2=isum1+1
          diff=rnb1(ir,in)-rnb2(ir,in)
          write (42,1000) ir,resnames(ir)(1:nrescol),
     -      in,resnames(in)(1:nrescol),diff
          if (diff .lt. rnbmin) rnbmin=diff
          if (diff .gt. rnbmax) rnbmax=diff
          if (idifftyp .eq. 1) then
            rnb1(ir,in)=diff
          else if (idifftyp .eq. 2) then
            rnb1(ir,in)=abs(diff)
          else if (idifftyp .eq. 3) then
            if (rnb1(ir,in) .eq. 0.0 .and. rnb2(ir,in) .gt. 0.0) then
              rnb1(ir,in)=+1.0
            else if (rnb1(ir,in) .gt. 0.0 .and.rnb2(ir,in) .eq. 0.0)then
              rnb1(ir,in)=-1.0
            else
              rnb1(ir,in)=0.0
            end if
          end if
          bfac(ir)=bfac(ir)+rnb1(ir,in)
        end do
c       bfac(ir)=bfac(ir)/float(nres)
      end do
      if (idifftyp .eq. 2) then
        rnbmax=amax1(abs(rnbmin),abs(rnbmax))
        rnbmin=0.0
      else if (idifftyp .eq. 3) then
        rnbmax=1.0
        rnbmin=-1.0
      end if
      write (6,1003) inpfile1(1:linpfile1),sum1,isum1
      write (6,1003) inpfile2(1:linpfile2),sum2,isum2
      write (6,1002) rnbmin,rnbmax
      if (idifftyp .ne. 3) then
        call getreal('Minimum difference to show',26,rnbmin,rnbmin,1,0)
        call getreal('Maximum difference to show',26,rnbmax,rnbmax,1,0)
      end if
      close (42)
      ips=43
      plotfile(lplotfile+1:lplotfile+3)='.ps'
      lplotfile=lplotfile+3
      call openfile(ips,0,'residue bond matrix difference',30,'new',
     -  plotfile,lplotfile,notfnd,0,1,1,0,0)
      write (6,1001) plotfile(1:lplotfile)
      title2='Average distance matrix difference plot'
      ltitle2=39
      if (idifftyp .eq. 2) then
        title2(ltitle2+1:ltitle2+18)=' - absolute values'
        ltitle2=ltitle2+18
      else if (idifftyp .eq. 3) then
        title2(ltitle2+1:ltitle2+27)=' - signs of the differences'
        ltitle2=ltitle2+27
      end if
      ltitle1=linpfile1+linpfile2+3
      title1(1:ltitle1)=
     -  inpfile1(1:linpfile1)//' - '//inpfile2(1:linpfile2)
      call openps(ips,500.0,500.0,' ',1,' ',1,plotfile,0,
     -  plotfile,0,1,ipspage)
      call getint('Number of colors to use',23,5,1,maxcolcode,ncolcode,
     -  0)
      scalefac=amin1(1.0,500.0/float(nres))
      ixdel=25
      iydel=115
      incinp=max0(1,500/nres)
      call indexit(itemp,1,mxrsd,0)
      call plotmat(ips,kc,rnb1,dc,nres,nres,0,0,0,0,1,0,0,iydel,00,
     -  iytop,rnbmin,rnbmax,ncolcode,maxcolcode,ixdel,iydel,incinp,
     -  scalefac,itemp,itemp,itemp,title1,ltitle1,title2,ltitle2,' ',0,
     -  xyval,yclab,nyclab,lyclab,igl,1,MAX2D,1,mxrsd,mxrsd,ipspage,0)
      ixd=ixdel
      if (ncolcode .le. 5) inxd=ixd+60
      call colcodeminmax(ips,ixd,-60,0,ncolcode,maxcolcode,rnbmin,
     -  rnbmax)
      return
1000  format(' Res #',i6,'(',a,') - Res #',i6,'(',a,'): <nb1>-<nb2>=',
     -  f6.3)
1001  format(' Residue bond difference matrix plots are on file ',a)
1002  format(' Range of differences: [',f6.3,',',f6.3,'] A')
1003  format(' Sum of bonds in ',a,'=',f10.3,' sum of (+) changes=',i6)
      end
      subroutine read_bondmat(rnb,inpt,lab,llab,nres,inpmat,linpmat,
     -  itemp,mxdim)
      dimension rnb(mxdim,mxdim),itemp(nres)
      character*(*) lab
      character*80 inpmat,prompt,line
      do ir=1,nres
        do jr=1,nres
          rnb(ir,jr)=0.0
        end do
      end do
      prompt(1:llab)=lab(1:llab)
      prompt(llab+1:llab+28)=' residue-residue bond matrix'
      lprompt=llab+28
      linpmat=0
      call openfile(inpt,0,prompt,lprompt,'old',inpmat,linpmat,notfnd,
     -  0,1,1,0,0)
      call indexit(itemp,1,nres,0)
c     Read pointer if necessary
      do while (line(1:19) .ne. ' Average number of ' .and.
     -  line(1:12) .ne. ' iy(orig):')
        call blankout(line,1,80)
        read (inpt,1000,end=999) line
      end do
      ixf=0
      ixl=1
      if (line(1:12) .eq. ' iy(orig):') then
c       Read indices
        ifr=1
        ilr=10
        call lastchar(line,lc,80)
        if (lc .lt. 73) ilr=ilr-(73-lc)/5
        read (line(24:73),1002,end=888,err=888) (itemp(i),i=ifr,ilr)
        do while (lc .eq. 73)
          ifr=ilr+1
          ilr=ilr+10
          call blankout(line,1,80)
          read (inpt,1000,end=999) line
          call lastchar(line,lc,80)
          if (lc .lt. 73) ilr=ilr-(73-lc)/5
          read (line(24:73),1002,end=888,err=888) (itemp(i),i=ifr,ilr)
        end do
        do while (line(1:19) .ne. ' Average number of ')
          read (inpt,1000,end=999) line
        end do
      end if
      iymin=99999
      iymax=0
      read (inpt,1000,end=999) line
      do while (.true.)
        ixf=1
        ixl=0
        if (line(10:18) .eq. 'iy(orig)=') then
c         Start of one column
          read (line(19:23),*,end=888,err=888) iyorig
          read (line(5:8),*,end=888,err=888) iy
          if (itemp(iy) .ne. iyorig) then
            write (6,1003) iy,iyorig,itemp(iy)
            stop
          end if
          if (iy .lt. iymin) iymin=iy
          if (iy .gt. iymax) iymax=iy
          ixf=1
          ixl=ixf+9
          read (line(25:74),1001,end=888,err=888)
     -      (rnb(itemp(irx),iyorig),irx=ixf,ixl)
c           write (88,7211) iy,iyorig,ixf,ixl,
c    -        (rnb(itemp(irx),iyorig),irx=ixf,ixl)
c7211       format(' iy,iyorig=',2i5,' ixf,ixl=',2i5,' r=',10f7.2)
          read (inpt,1000,end=999) line
          do while(line(10:18) .ne. 'iy(orig)=' .and.
     -             line(1:17) .ne. ' Fraction of time')
            ixf=ixl+1
            ixl=ixf+9
            read (line(25:74),1001,end=888,err=888)
     -        (rnb(itemp(irx),iyorig),irx=ixf,ixl)
c           write (88,7212) ixf,ixl,
c    -        (rnb(itemp(irx),iyorig),irx=ixf,ixl)
c7212       format(' ixf,ixl=',2i5,' r=',10f7.2)
            read (inpt,1000,end=999) line
          end do
          if (line(1:17) .eq. ' Fraction of time') go to 999
        end if
      end do
999   close (inpt)
      write (6,1004) iymin,iymax
      return
888   print *,'ERROR reading record ixf,ixl=',ixf,ixl
      print *,line(1:66)
      close (inpt)
      return
1000  format(a)
1001  format(10f5.2)
1002  format(10i5)
1003  format(' PROGRAM ERROR: iy=',i5,' iyorig=',i5,' iyorig(iy)=',i5)
1004  format(' Bond matrix info read for indices [',i5,',',i5,']')
      end
      subroutine compare_rmsf(resnames,nrescol,siglev,bfac,plotfile,
     -  lplotfile,irmin,irmax,mxrsd)
      dimension bfac(mxrsd)
      character*8 resnames(mxrsd)
      parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
      parameter (MAXRSD=70000)
      parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-4*MAXRSD)
      common /nnwork/ rmsf1(MAXRSD),rmsf2(MAXRSD),sd1(MAXRSD),
     -  sd2(MAXRSD),fill(IFILL2)
      common /colorinfo/ ncolcode,maxcolcode
      character*(*) plotfile
      common /t_test/ t_test_CI_1(5),t_test_CI_2(5),t_test_table(5,30)
      character*80 inpfile1,inpfile2
c     print *,'COMPARE_RRDIST maxcolcode,mxrsd=',maxcolcode,mxrsd
      call read_rmsf(rmsf1,sd1,41,'first',5,irmin,irmax,
     -  inpfile1,linpfile1,MAXRSD)
      call read_rmsf(rmsf2,sd2,42,'second',6,irmin2,irmax2,
     -  inpfile2,linpfile2,MAXRSD)
      if (irmin .ne. irmin2 .or. irmax .ne. irmax2) then
        print *,'Residue ranges differ - can not run the comparison'
        return
      end if
      lplotfile=0
      call openfile(42,0,'RMSF difference',15,'new',
     -  plotfile,lplotfile,notfnd,0,1,1,0,0)
      call zeroit(bfac,irmax)
c     Both SD values are computed over a sample of 10 block averages
      n1=10
      n2=10
      do ir=irmin,irmax
        rmsf_diff=rmsf1(ir)-rmsf2(ir)
        s12=sd1(ir)**2/n1+sd2(ir)**2/n2
        t=abs(rmsf_diff)/sqrt(s12)
        dof=s12**2/((sd1(ir)**2/n1)**2/(n1-1)+(sd2(ir)**2/n2)**2/(n2-1))
        idof=dof
        idof=min0(30,max0(1,idof))
        isig=1
        sig=1.0
        do while (t .gt. t_test_table(isig,idof) .and. isig .lt. 5)
          sig=t_test_CI_2(isig)
          isig=isig+1
        end do
        if (isig .eq. 5) then
          if (t .gt. t_test_table(isig,idof)) then
            sig=t_test_CI_2(isig)
          else
            isig=isig-1
          end if
        end if
        write (42,1001) ir,resnames(ir)(1:nrescol),rmsf1(ir),sd1(ir),
     -    rmsf2(ir),sd2(ir),rmsf_diff,t,dof,t_test_CI_2(isig)
        if (siglev .gt. 0.0 .and. sig .gt. siglev) rmsf_diff=0.0
        bfac(ir)=rmsf_diff
      end do
      return
1001  format(i6,1x,a,' F1=',f5.1,' sd=',f5.1,' F2=',f5.1,
     -  ' sd2=',f5.1,' D=',f5.1,' t=',f5.1,' df=',f4.1,' p<',f5.3)
      end
      subroutine read_rmsf(rmsf,sd,inpt,lab,llab,irmin,irmax,
     -  inpfile,linpfile,mxres)
      dimension rmsf(mxres),sd(mxres)
      character*(*) lab
      character*80 inpfile,prompt,line
      prompt(1:llab)=lab(1:llab)
      prompt(llab+1:llab+5)=' RMSF'
      lprompt=llab+5
      linpfile=0
      call openfile(inpt,0,prompt,lprompt,'old',inpfile,linpfile,notfnd,
     -  0,1,1,0,0)
      istart=1
      irmin=0
      ir=0
      call zeroit(rmsf,mxres)
      call zeroit(sd,mxres)
      do while (.true.)
        read (inpt,1000,end=999) line
        if (line(7:10) .eq. 'RMSF') then
          read (line(1:6),*,end=888,err=888) ir
          read (line(11:16),*,end=888,err=888) rmsf_ir
          read (line(21:26),*,end=888,err=888) sd_ir
          if (irmin .eq. 0) irmin=ir
          if (ir .gt. 0 .and. ir .le. mxres) then
            rmsf(ir)=rmsf_ir
            sd(ir)=sd_ir
          else
            write (6,1002) ir,1,mxres
          end if
        end if
      end do
999   close (inpt)
      irmax=ir
      write (6,1003) irmax
      return
888   print *,'ERROR reading record'
      print *,line(1:66)
      close (inpt)
      write (6,1001)
      return
c    1 RMSF 16.96 SD=  1.99 decide=Uncorrelated
c123456789012345678901234567890
cRes #     1(ILE ) - Res #     1(ILE ): <d>=  0.0000 A sd=  0.0000
1000  format(a)
1001  format(' Residue range found: [',i6,',',i6,']')
1002  format(' ERROR: residue # read (',i6,') is outside the range [',
     -  i6,',',i6,']')
1003  format(' Number of RMSF records found=',i6)
      end
      subroutine rrconn(c,n,numres1,numres2,ifres,ilres,iatnum,
     -  ignoreh,irepuse,iadjtyp,iscalesum,resdistlim,nexpmax,npint,
     -  ipspage,npspages,ilog,iplot,line,index,ir1,ic1,
     -  imarkres,marks,imarks,iarep,iconnsum,itemp,rconnsum,inpfile,
     -  linpfile,markfile,lmarkfile,maxrec)
      dimension c(3,n),index(n),ifres(numres2),ilres(numres2),
     -  iatnum(n),imarks(numres2),iarep(n),iconnsum(n),itemp(n),
     -  rconnsum(n)
      character*1 marks(9)
      character* 132 line(maxrec)
      character*(*) inpfile,markfile
      parameter (MAXPHI=400,MAXCONN=2900,MAXCONN10=10*MAXCONN)
      parameter (IFILL8=MAXPHI*MAXPHI*MAXPHI-3*MAXCONN*MAXCONN
     -  -11*MAXCONN)
      common /nnwork/ rij1(MAXCONN,MAXCONN),rij2(MAXCONN,MAXCONN),
     -  rij3(MAXCONN,MAXCONN),xres(MAXCONN),yres(MAXCONN10),fill(IFILL8)
      dimension ifg(10),imf(10),iml(10),iexpplot(10),lfclab(10)
      character*8 fclab(10)
      character*200 title1,title2
      data connmax /0.0/
c     print *,'RRCONN numres1,numres2,nexpmax,iscalesum=',
c    -  numres1,numres2,nexpmax,iscalesum
c     print *,'RRCONN npspages,ipspage,maxrec=',
c    -  npspages,ipspage,maxrec
      write (6,1003) numres1,numres2
      if (iadjtyp .eq. 1)
     -   write (ilog,1005) '0/1 (integer)','matrix product'
      if (iadjtyp .eq. 2)
     -   write (ilog,1005) '0.0-1.0 (weighted)','matrix product'
      if (iadjtyp .eq. 3)
     -  write (ilog,1005) '0.0-1.0 (weighted)','matrix product-like sum'
      resdistlim2=resdistlim**2
      numres=numres2-numres1+1
      do i1=1,numres
        do i2=1,numres
          rij1(i1,i2)=0.0
          rij2(i1,i2)=0.0
          rij3(i1,i2)=0.0
        end do
      end do
      if (irepuse .gt. 0) then
        write (ilog,1001) 'representative atoms',resdistlim
        title2='Distances based on representative atoms;'
        ltitle2=40
c       Distances based on representative atoms
        do irr=numres1,numres2
c         First find the representative atom and atom range for residue irr
          call findat(iarep(irr),ifres(irr),ilres(irr),line,index,
     -     ir1,ic1,maxrec)
        end do
        do i1=numres1+1,numres2
          ii1=i1-numres1+1
          do i2=numres1,i1-1
            ii2=i2-numres1+1
            rijsq=dist2(c(1,iarep(i1)),c(1,iarep(i2)))
            if (rijsq .lt. resdistlim2) then
              rij1(ii1,ii2)=rijsq
              rij1(ii2,ii1)=rijsq
            end if
          end do
        end do
      else
c       Distances based on closest approach
        write (ilog,1001) 'closest approach',resdistlim
        title2='Distances based on closest approach;'
        ltitle2=36
        if (ignoreh .eq. 1) write (ilog,1002)
        do i1=numres1+1,numres2
          ii1=i1-numres1+1
          do i2=numres1,i1-1
            ii2=i2-numres1+1
            call findapproach(c,ifres(i1),ilres(i1),ifres(i2),
     -        ilres(i2),iatnum,ignoreh,iarep1,iarep2,rijsq,maxrec)
            if (rijsq .lt. resdistlim2) then
              rij1(ii1,ii2)=rijsq
              rij1(ii2,ii1)=rijsq
            end if
          end do
        end do
      end if
c     Convert distances to adjacencies
      do i1=2,numres
        do i2=1,i1-1
          if (rij1(i1,i2) .gt. 0.0) then
            if (iadjtyp .eq. 1) then
              rij=1.0
            else
              if (rij1(i1,i2) .lt. 9.0) then
                rij=1.0
              else
                r=sqrt(rij1(i1,i2))
                rij=(resdistlim-r)/(resdistlim-3.0)
              end if
            end if
            rij1(i1,i2)=rij
            rij1(i2,i1)=rij
            rij2(i1,i2)=rij
            rij2(i2,i1)=rij
            rij3(i1,i2)=rij
            rij3(i2,i1)=rij
          end if
        end do
      end do
      do i=1,numres
        do j=1,numres
          itemp(j)=rij1(i,j)
        end do
        write (ilog,1009) i,(itemp(j),j=1,numres)
      end do
c     Calculate the adjaceny matrix powers
      do i=1,10
        ifg(i)=1
        imf(i)=(i-1)*numres+1
        iml(i)=i*numres
      end do
      do i=1,numres
        xres(i)=i
      end do
      nexpplot=0
      do nexp=1,nexpmax
        if (nexp .gt. 1) then
          do i1=1,numres
            do i2=1,numres
              sum=0.0
              if (iadjtyp .lt. 3) then
                do k=1,numres
                  sum=sum+rij1(i1,k)*rij2(k,i2)
                end do
              else
                do k=1,numres
                  if (rij1(i1,k) .gt. 0.0 .and. rij2(k,i2) .gt. 0.0)
     -              sum=sum+rij1(i1,k)+rij2(k,i2)
                end do
              end if
              rij3(i1,i2)=sum
            end do
          end do
        end if
        do i1=1,numres
          colsum=0.0
          do i2=1,numres
            colsum=colsum+rij3(i1,i2)
            rij2(i1,i2)=rij3(i1,i2)
          end do
          rconnsum(i1)=colsum
        end do
        connmax=0.0
        do i=1,numres
          if (rconnsum(i) .gt. connmax) connmax=rconnsum(i)
        end do
        if (iscalesum .eq. 1) then
          do i=1,numres
            iconnsum(i)=100.0*rconnsum(i)/connmax
          end do
        else
          scalefac=1.0
          nlog=alog10(connmax)
          if (nlog .gt. 3) scalefac=10.0**(2-nlog)
          do i=1,numres
            iconnsum(i)=rconnsum(i)*scalefac
          end do
        end if
        write (ilog,1000) nexp,(iconnsum(i),i=1,numres)
        if ((mod(nexp,npint) .eq. 1 .or. nexp .eq. nexpmax .or.
     -      npint .eq. 1) .and. nexpplot .lt. 10) then
          nexpplot=nexpplot+1
          iexpplot(nexpplot)=nexp
          write (fclab(nexpplot),1004) nexp
          lfclab(nexpplot)=8
          if (iscalesum .eq. 0) then
            do i=1,numres
              yres(imf(nexpplot)-1+i)=iconnsum(i)
            end do
            ny=5
            ydiv=0.0
          else
            do i=1,numres
              yres(imf(nexpplot)-1+i)=(nexpplot-1)+rconnsum(i)/connmax
            end do
            ny=nexpplot
            ydiv=1.0
          end if
        end if
      end do
c     Calculate correlation between marks and high/low col sums
      nmarksum=0
      nmarkup=0
      nmarkdown=0
      nsumup=0
      nsumdown=0
      do i=1,numres
        if (rconnsum(i) .gt. connmax/2.0) then
          nsumup=nsumup+1
        else
          nsumdown=nsumdown+1
        end if
        if (imarks(i) .gt. 0) then
          nmarksum=nmarksum+1
          if (rconnsum(i) .gt. connmax/2.0) then
            nmarkup=nmarkup+1
          else
            nmarkdown=nmarkdown+1
          end if
        end if
      end do
      if (nmarksum .gt. 0) then
        write (ilog,1007) nmarksum,float(nmarkup)/float(nmarksum),
     -    float(nmarkdown)/float(nmarksum),numres,
     -    float(nsumup)/float(numres),float(nsumdown)/float(numres)
      else
        write (ilog,1008) inpfile(1:linpfile)
      end if
      title1='Adjacency matrix analysis for file '
      ltitle1=35
      title1(ltitle1+1:ltitle1+linpfile)=inpfile(1:linpfile)
      ltitle1=ltitle1+linpfile
      write (title2(ltitle2+1:ltitle2+14),1006) resdistlim
      ltitle2=ltitle2+14
      if (iadjtyp .eq. 1) then
        title2(ltitle2+1:ltitle2+27)=' 0/1 matrix, matrix product'
        ltitle2=ltitle2+27
      else
        title2(ltitle2+1:ltitle2+34)=' 0.0-1.0 matrix, product-like sum'
        ltitle2=ltitle2+34
      end if
      if (imarkres .gt. 0) then
        title2(ltitle2+1:ltitle2+13)='; Mark file: '
        ltitle2=ltitle2+13
        title2(ltitle2+1:ltitle2+lmarkfile)=markfile(1:lmarkfile)
        ltitle2=ltitle2+lmarkfile
      end if
      call rounddiv(numres,10,nx,nxdiv)
      xdiv=nxdiv
      call plotnps(xres,yres,MAXCONN,MAXCONN10,nexpplot,imf,iml,ifg,
     -  0.0,1.0,0.0,xdiv,nx,0.0,ydiv,ny,1,ltitle1,title1,ltitle2,title2,
     -  'Residue #',9,fclab,lfclab,imarkres,imarks,marks,iplot,ipspage,
     -  npspages,inperr,ilog)
      return
1000  format(' Bond density (scaled); Adjacency matrix power=',i2,/,
     -  (20i4))
1001  format(' Adjacency is based on ',a,/,
     -  ' Distance threshold =',f5.2,' A')
1002  format(' Closest approach is based on heavy atoms only')
1003  format(' Adjacency matrix analysis for the residue range [',i5,
     -  ',',i5,']')
1004  format('Power=',i2)
1005  format(' Matrix: ',a,' Operation: ',a)
1006  format(' RRmax=',f4.1,' A;')
1007  format(' # of marks=',i4,' x up=',f5.3,' x down=',f5.3,
     -  ' # of res=',i4,' x up=',f5.3,' x down=',f5.3)
1008  format(' No marks were found for file ',a)
1009  format(i4,1x,10i1,1x,10i1,1x,10i1,1x,10i1,1x,10i1,1x,/,
     -  (5x,5(10i1,1x)))
      end
      subroutine rounddiv(max,maxdiv,ndiv,idiv)
      dimension limits (27)
      data limits /1,2,5,24*1/
      do i=1,8
        do k=1,3
          limits(3*i+k)=10*limits(3*(i-1)+k)
        end do
      end do
      do i=1,27
        if (max .le. limits(i)*maxdiv) then
          idiv=limits(i)
          ndiv=(max-1)/idiv +1
          return
        end if
      end do
      idiv=limits(27)
      ndiv=(max-1)/idiv +1
      return
      end
      subroutine pairdistcalc(c,nslt,npairs,listpairdist,pairdistsum,
     -  pairdistsum2,pairdistwsum,npairdist,pairdistminmax,pairgrid,
     -  iout,maxddbin,maxddistr)
      dimension c(3,nslt),listpairdist(2,maxddistr),
     -  npairdist(maxddbin,maxddistr),pairdistsum(maxddistr),
     -  pairdistsum2(maxddistr),pairdistwsum(2,maxddistr),
     -  pairdistminmax(2,maxddistr)
      do ip=1,npairs
        d2=dist2(c(1,listpairdist(1,ip)),c(1,listpairdist(2,ip)))
        d=sqrt(d2)
        if (d .lt. pairdistminmax(1,ip)) pairdistminmax(1,ip)=d
        if (d .gt. pairdistminmax(2,ip)) pairdistminmax(2,ip)=d
        pairdistsum(ip)=pairdistsum(ip)+d
        pairdistsum2(ip)=pairdistsum2(ip)+d2
        pairdistwsum(1,ip)=pairdistwsum(1,ip)+d/d2**3
        pairdistwsum(2,ip)=pairdistwsum(2,ip)+1.0/d2**3
        id=d/pairgrid+1.0
        if (id .gt. maxddbin) id=maxddbin
        npairdist(id,ip)=npairdist(id,ip)+1
        if (iout .gt. 0) write (iout,1000) (listpairdist(k,ip),k=1,2),d
      end do
      return
1000  format(' Atom',i7,' - atom',i7,' distance=',f5.2)
      end
      subroutine clusterdistcalc(c,nslt,npairs,iclustermem,
     -  ifstclst1,ifstclst2,ilstclst2,pairdistsum,pairdistsum2,
     -  pairdistwsum,npairdist,pairdistminmax,pairgrid,iout,
     -  maxddbin,maxpairs,maxclustermem)
      dimension c(3,nslt),iclustermem(maxclustermem),
     -  ifstclst1(maxpairs),ifstclst2(maxpairs),ilstclst2(maxpairs),
     -  npairdist(maxddbin,maxpairs),pairdistsum(maxpairs),
     -  pairdistsum2(maxpairs),pairdistwsum(2,maxpairs),
     -  pairdistminmax(2,maxpairs)
      data d2 /0.0/
      do ip=1,npairs
        d2max=100000.0
        do i1=ifstclst1(ip),ifstclst2(ip)-1
          do i2=ifstclst2(ip),ilstclst2(ip)
            d2=dist2(c(1,iclustermem(i1)),c(1,iclustermem(i2)))
            if (d2 .lt. d2max) d2max=d2
          end do
        end do
        d=sqrt(d2)
        if (d .lt. pairdistminmax(1,ip)) pairdistminmax(1,ip)=d
        if (d .gt. pairdistminmax(2,ip)) pairdistminmax(2,ip)=d
        pairdistsum(ip)=pairdistsum(ip)+d
        pairdistsum2(ip)=pairdistsum2(ip)+d2
        pairdistwsum(1,ip)=pairdistwsum(1,ip)+d/d2**3
        pairdistwsum(2,ip)=pairdistwsum(2,ip)+1.0/d2**3
        id=d/pairgrid+1.0
        if (id .gt. maxddbin) id=maxddbin
        npairdist(id,ip)=npairdist(id,ip)+1
        if (iout .gt. 0) write (iout,1000) ip,d
      end do
      return
1000  format(' Pair ',i3,' distance=',f5.2)
      end
      subroutine pairdistprint(nframe,npairs,listpairdist,iclusterdist,
     -  iclustermem,ifstclst1,ifstclst2,ilstclst2,pairdistsum,
     -  pairdistsum2,pairdistwsum,npairdist,pairdistminmax,pairgrid,
     -  rmaxpair,line,index,inamcol1,inamcol2,irescol1,irescol2,
     -  inpcrdtyp,ioins,iout,nslt,maxddbin,maxddistr,maxcdlist,maxrec)
      dimension listpairdist(2,maxddistr),npairdist(maxddbin,maxddistr),
     -  iclustermem(maxcdlist),ifstclst1(maxddistr),
     -  ifstclst2(maxddistr),ilstclst2(maxddistr),
     -  pairdistsum(maxddistr),pairdistsum2(maxddistr),
     -  pairdistwsum(2,maxddistr),pairdistminmax(2,maxddistr),
     -  index(nslt)
      character*3 star3
      character*8 an1,an2,rn1,rn2
      character* 132 line(maxrec)
      character*80 pline
      dimension dist(100)
      data star3 /' * '/,nnamcol /0/,nrescol /0/
c     For now, only maxddbin=20 works
      if (nframe .gt. 1) write (iout,1003) rmaxpair,pairgrid
      do ip=1,npairs
        write (iout,*)
        davg=pairdistsum(ip)/nframe
        dwavg=pairdistwsum(1,ip)/pairdistwsum(2,ip)
        sd=sqrt(abs(pairdistsum2(ip)/nframe-davg**2))
        if (iclusterdist .eq. 0) then
          i1=listpairdist(1,ip)
          i2=listpairdist(2,ip)
          if (inpcrdtyp .le. ioins) then
            an1=line(index(i1))(inamcol1:inamcol2)
            an2=line(index(i2))(inamcol1:inamcol2)
            rn1=line(index(i1))(irescol1:irescol2)
            rn2=line(index(i2))(irescol1:irescol2)
            write (iout,1000) i1,an1,rn1,i2,an2,rn2,davg,dwavg
          else
            write (iout,1001) i1,i2,davg,dwavg
          end if
        else
          pline(1:10)=' Cluster1:'
          ncol=10
          ip11=ifstclst1(ip)
          ip21=ifstclst2(ip)
          ip12=ip21-1
          ip22=ilstclst2(ip)
          if (inpcrdtyp .le. ioins) then
            nnamcol=inamcol2-inamcol1+1
            nrescol=irescol2-irescol1+1
            ncolinc=nnamcol+nrescol+7
            do i=ip11,ip12
              write (pline(ncol+1:ncol+5),1009) iclustermem(i)
              ncol=ncol+6
              pline(ncol:ncol)=' '
              pline(ncol+1:ncol+nnamcol)=
     -          line(index(iclustermem(i)))(inamcol1:inamcol2)
              ncol=ncol+nnamcol+1
              pline(ncol:ncol)=' '
              pline(ncol+1:ncol+nrescol)=
     -          line(index(iclustermem(i)))(irescol1:irescol2)
              ncol=ncol+nrescol+1
              pline(ncol:ncol)=' '
            end do
          else
            ncolinc=5
            do i=ip11,ip12
              write (pline(ncol+1:ncol+ncolinc),1009)iclustermem(i)
              ncol=ncol+ncolinc
            end do
          end if
          if (ncol+(ip22-ip21+1)*ncolinc+10 .gt. 80) then
            write (iout,1007) pline(1:ncol)
            ncol=0
          end if
          pline(ncol+1:ncol+10)=' Cluster2:'
          ncol=ncol+10
          if (inpcrdtyp .le. ioins) then
            do i=ip21,ip22
              write (pline(ncol+1:ncol+5),1009) iclustermem(i)
              ncol=ncol+6
              pline(ncol:ncol)=' '
              pline(ncol+1:ncol+nnamcol)=
     -          line(index(iclustermem(i)))(inamcol1:inamcol2)
              ncol=ncol+nnamcol+1
              pline(ncol:ncol)=' '
              pline(ncol+1:ncol+nrescol)=
     -          line(index(iclustermem(i)))(irescol1:irescol2)
              ncol=ncol+nrescol+1
              pline(ncol:ncol)=' '
            end do
          else
            do i=ip21,ip22
              write (pline(ncol+1:ncol+ncolinc),1009)iclustermem(i)
              ncol=ncol+ncolinc
            end do
          end if
          if (ncol .gt. 70) then
            write (iout,1007) pline(1:ncol)
            write (iout,1010) davg
          else
            write (pline(ncol+1:ncol+10),1010) davg
            write (iout,1007) pline(1:ncol+10)
          end if
        end if
        if (nframe .gt. 1) then
          write (iout,1004) ip,davg,sd,(pairdistminmax(k,ip),k=1,2),
     -      dwavg
          write (iout,1002) (npairdist(k,ip),k=1,maxddbin)
          write (iout,*)
          pdmax=0.0
          do ic=1,maxddbin
            dist(ic)=float(npairdist(ic,ip))/float(nframe)
            if (dist(ic) .gt. pdmax) pdmax=dist(ic)
          end do
          maxperc=100
          distfact=10.0
          if (pdmax .lt. 0.3) then
            maxperc=30
            distfact=0.3
          else if (pdmax .lt. 0.5) then
            maxperc=50
            distfact=0.5
          else if (pdmax .lt. 0.8) then
            maxperc=80
            distfact=0.8
          end if
          write (iout,1006)
          if (maxddbin .le. 20) then
            lbin=3
          else if (maxddbin .le. 30) then
            lbin=2
          else if (maxddbin .le. 60) then
            lbin=1
          else
            print *,'ERROR: too many bins to plot - distributions ',
     -        'will be only printed'
            lbin=0
          end if
c         if (maxddbin .le. 60) then
          if (maxddbin .eq. 20) then
            lastcol=12+lbin*maxddbin
            pline(lastcol:lastcol)='|'
            do il=10,1,-1
              call blankout(pline,1,lastcol-1)
              pline(11:11)='|'
              if (il .eq. 10) write (pline(5:9),1008) maxperc
              do ic=1,maxddbin
                if (dist(ic) .gt. distfact*float(il-1)/10.0)
     -            pline(12+(ic-1)*lbin:11+ic*lbin)=star3
              end do
              write (iout,1007) pline(1:72)
            end do
            write (iout,1006)
            write (iout,1005) ((rmaxpair/5.0)*i,i=1,5)
          else
            print *,'Sorry, only MAXDDBIN=20 works for now'
          end if
        end if
      end do
      return
1000  format(' Atom',i7,' (',a,1x,a,') - atom',i7,' (',a,1x,a,
     -  ') <d>=',f5.2,' NMR(<d>)=',f5.2,' A')
1001  format(' Atom',i7,' - atom',i7,' <d>=',f5.2,' NMR(<d>)=',f5.2,
     -  ' A')
1002  format(' Distribution :',10i6,/,(15x,10i6))
1003  format(' Distance distributions are limited to the 0 -',f5.1,
     -  ' A range; bin size=',f5.3,' A')
1004  format(' Pair',i4,' <d>=',f5.2,' SD=',f5.2,' Minimum=',f5.2,
     -  ' Maximum=',f5.2,' NMR(<d>)=',f5.2)
1005  format(11x,5f12.2)
1006  format(10x,'|',5(3('-+-'),'-|-'),'|')
1007  format(a)
1008  format(i3,' %')
1009  format(i5)
1010  format(' <d>=',f5.2)
      end
      subroutine checkunphys(c,nslt,n,naslv,islvw,iatnum,ifchrg,isegno,
     -  idelseg,indexo,nneig,nneiga,nhbneig,ineig,nhneig,nnneig,ncneig,
     -  nsneig,npneig,ixres,line,irescol1,irescol2,inamcol1,inamcol2,
     -  index,nconfig,innlist,molresflag,ioppbc,cell,ncell,edge,ixyzhex,
     -  molsltlim,nmolslt,hblimfac,angmin,ctfac,bondminfac,maxdist,iles,
     -  iwchk,isltonly,indices,nbox,rlim,radtodeg,nerr,maxrepconf,maxng,
     -  maxbox,maxrsd,maxrec)
      dimension nneig(n),ineig(maxng,n),iatnum(n),ifchrg(n),c(3,n),
     -  idelseg(1000),indexo(n),nhbneig(n),nneiga(n),nhneig(n),
     -  nnneig(n),ncneig(n),nsneig(n),npneig(n),ixres(n),
     -  molresflag(maxrsd),index(n),indices(maxbox,maxrec),nbox(maxrec),
     -  isegno(n),cell(3,ncell),edge(3),ixyzhex(3),molsltlim(3,nmolslt),
     -  rlim(maxng)
      character* 132 line(maxrec)
      call bondcheck(iwchk,1,nslt,iatnum,nneig,ineig,maxng,c,maxdist,
     -  line,irescol1,irescol2,inamcol1,inamcol2,index,rlim,nbonderr,
     -  maxrec)
      if (isltonly .eq. 0) nlim=n
      if (isltonly .eq. 1) nlim=nslt
      if (iles .eq. 1) then
c       Mark segments to be disregarded
        nmark=0
        call trnsfi(indexo,isegno,nslt)
        do ia=1,nslt
          if (idelseg(isegno(ia)) .eq. 1) nmark=nmark+1
          if (idelseg(isegno(ia)) .eq. 1) isegno(ia)=-1
        end do
      end if
      call nnlist(nslt,islvw,naslv,nlim,iatnum,ifchrg,c,nneig,nneiga,
     -  nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,line,irescol1,
     -  irescol2,inamcol1,inamcol2,index,nconfig,innlist,molresflag,
     -  hblimfac,angmin,0,indices,nbox,isegno,ixres,maxrepconf,1,
     -  radtodeg,maxbox,maxng,maxrsd,maxrec)
      call contactlist(iwchk,nslt,n,iatnum,c,line,irescol1,irescol2,
     -  inamcol1,inamcol2,index,ctfac,bondminfac,isltonly,
     -  naslv,nneig,ineig,isegno,ioppbc,cell,ncell,edge,ixyzhex,
     -  molsltlim,nmolslt,ncontacterr,maxng,maxrec)
        if (iles .eq. 1) call trnsfi(isegno,indexo,nslt)
      nerr=nbonderr+ncontacterr
      return
      end
      subroutine helixaxis(c,nslt,iw0,calph,axisdir,axisini,axisend,
     -  helixcent,perpvec,camod,anglechangeref,circ,rn,axfact,axtol,rot,
     -  rms,helixlen,angles,decidebend,nup,ndown,nrun,nnear,rcirc,
     -  turnperres,anglesn,irot,incrot,nrep,irefang,nreshx,icaahx,ihx,
     -  nhxres,igl,idebughx,radtodeg,pi,maxhlx)
      dimension c(3,nslt),rot(3,3),anglechangeref(maxhlx),icaahx(maxhlx)
      real*8 camod(3,maxhlx),axfact(maxhlx),perpvec(3,maxhlx),
     -  calph(3,maxhlx),axisdir(3),axisini(3),axisend(3),helixcent(3),
     -  circ(3),rn(3)
      real*8 rms
      dimension angles(3),anglesn(3)
      character*9 decidebend
      parameter (MAXFRAMES=50000,MAXCOPY=600)
      common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
     -  increment,increment2,res(2,MAXFRAMES,MAXCOPY),
     -  x0(MAXCOPY),y0(MAXCOPY),nxselres,ixselres(MAXCOPY)
      character*60 message
      real*8 ddistsq
      character*9 decide(6)
      data decide/'Too short','Bent     ','Random   ',
     -  'Alternate','Too long ','         '/
c     print *,'HELIXAXIS maxhlx,nreshx=',maxhlx,nreshx
      iprintkahn=0
      it=0
      do ir=1,nreshx
        do k=1,3
          calph(k,ir)=c(k,icaahx(ir))
        end do
      end do
      if (irot .eq. 1) then
        do ir=1,nreshx
          call dsmatvec(rot,calph(1,ir),calph(1,ir))
        end do
      end if
      message=
     - 'Helix                                                       '
      call kahn(calph,nreshx,.true.,axisdir,axisini,axisend,rms,
     -  iprintkahn, message,maxhlx)
      rmsa=rms
      if (idebughx .gt. 0) then
        write (77,7011) 'axis direction',axisdir
        write (77,7011) 'initial position',axisini
        write (77,7011) 'end position',axisend
        write (77,*) 'Helix quality rms=',rms
        write (77,7012) nreshx,(icaahx(ir),ir=1,nreshx)
      end if
      if (nrep .le. 1 .or. igl .eq. 1) then
        do ir=1,nreshx
          call calcperp(axisini,axisdir,calph(1,ir),camod(1,ir),
     -      perpvec(1,ir),it)
        end do
        call checkbend(calph,axisdir,camod,axfact,perpvec,helixcent,
     -    nreshx,nup,ndown,nrun,nnear,axtol,rcirc,circ,rn,ibtyp,
     -    idebughx)
      end if
      if (nrep .le. 1) then
        do k=1,3
          anglesn(k)=dacoscheck(rn(k),ccc,1,6,'HELIXNORMAL')
        end do
        helixlen=dsqrt(ddistsq(axisini,axisend))
        do k=1,3
          angles(k)=dacoscheck(axisdir(k),ccc,1,6,'HELIXAXIS')
        end do
        call calcturnperres(turnperres,nreshx,incrot,perpvec,axisdir,
     -    anglechangeref,irefang,pi,maxhlx)
        nframes=max0(1,nframe)
        incr=(ihx-1)*nhxres
        call trajlimtest(nframe,MAXFRAMES)
        res(1,nframes,incr+7)=helixlen
        res(2,nframes,incr+7)=rcirc
        do k=1,3
          res(1,nframes,incr+k)=cos(angles(k))
          res(2,nframes,incr+k)=sin(angles(k))
        end do
        res(1,nframes,incr+6)=cos(turnperres)
        res(2,nframes,incr+6)=sin(turnperres)
        res(1,nframes,incr+13)=axisdir(1)
        res(2,nframes,incr+13)=axisdir(2)
        res(1,nframes,incr+14)=axisdir(3)
        res(2,nframes,incr+14)=helixcent(1)
        res(1,nframes,incr+15)=helixcent(2)
        res(2,nframes,incr+15)=helixcent(3)
        decidebend=decide(ibtyp)
        if (iw0 .gt. 0) call printhelix(iw0,axisini,axisend,helixcent,
     -    rms,helixlen,axisdir,angles,decidebend,nup,ndown,nrun,nnear,
     -    rcirc,turnperres,anglesn,ihx,radtodeg)
      end if
      return
7011  format(' Helix ',a,'=',3f10.4)
7012  format(' # of HX res=',i2,(' icaa:',20i5))
      end
      subroutine multihelix(iw0,nhx,nhxres,radtodeg)
      parameter (MAXFRAMES=50000,MAXCOPY=600)
      common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
     -  increment,increment2,res(2,MAXFRAMES,MAXCOPY),
     -  x0(MAXCOPY),y0(MAXCOPY),nxselres,ixselres(MAXCOPY)
      dimension ax1(3),ax2(3),cent1(3),cent2(3)
      real*8 dargin
      ixres=nhx*nhxres+1
c     print *,'MULTIHELIX nhxres=',nhxres
      nframes=max0(1,nframe)
      do ihx=1,nhx
        incr1=(ihx-1)*nhxres
        ax1(1)=res(1,nframes,incr1+13)
        ax1(2)=res(2,nframes,incr1+13)
        ax1(3)=res(1,nframes,incr1+14)
        cent1(1)=res(2,nframes,incr1+14)
        cent1(2)=res(1,nframes,incr1+15)
        cent1(3)=res(2,nframes,incr1+15)
c        write (iw0,7865) incr1,ax1,cent1
c7865    format(' incr=',i3,' ax=',3f10.4,' cent=',3f10.5)
        do jhx=ihx+1,nhx
          incr2=(jhx-1)*nhxres
          ax2(1)=res(1,nframes,incr2+13)
          ax2(2)=res(2,nframes,incr2+13)
          ax2(3)=res(1,nframes,incr2+14)
          cent2(1)=res(2,nframes,incr2+14)
          cent2(2)=res(1,nframes,incr2+15)
          cent2(3)=res(2,nframes,incr2+15)
          sc=0.0
          do k=1,3
            sc=sc+ax1(k)*ax2(k)
          end do
          ang=dacoscheck(dargin,sc,0,6,'MULTIHELIX')*radtodeg
          dist=sqrt(dist2(cent1,cent2))
          write (iw0,1000) ihx,jhx,ang,dist
          res(1,nframes,ixres)=ang
          res(2,nframes,ixres)=dist
          ixres=ixres+1
        end do
      end do
1000  format(' HX#',i3,' - HX#',i3,' ang=',f7.2,' dist=',f5.2)
      end
      subroutine printhelix(iw0,axisini,axisend,cent,rms,helixlen,
     -  axisdir,angles,decidebend,nup,ndown,nrun,nnear,rcirc,turnperres,
     -  anglesn,ihx,radtodeg)
      real*8 axisdir(3),axisini(3),axisend(3),cent(3),rms
      dimension angles(3),anglesn(3)
      character*9 decidebend
      write (iw0,1000) ihx,axisini,axisend,helixlen,axisdir,
     -  (radtodeg*angles(k),k=1,3),rms,decidebend,nup,ndown,nrun-1,
     -  nnear,rcirc,radtodeg*turnperres,cent,(radtodeg*anglesn(k),k=1,3)
      return
1000  format(' HX#',i3,' S=',3f9.4,' E=',3f9.4,' Len=',f5.2,/,
     -  ' D=',3f10.6,' D-X,D-Y,D-Z angles=',3f7.2,/,
     -  ' RMS=',f5.2,' Shape:',a9,' Nup/dn=',2i3,' Ncross=',i2,
     -  ' Nax=',i2,' Rc=',f6.1,' TPR=',f6.2,/,
     -  ' C=',3f10.5,' N-X,N-Y,N-Z angles=',3f7.2)
      end
      subroutine soluteoverlay(isubcrm,ioverlay,nslt,nsegslt,c,cres,cc1,
     -  cc2,crmslt0,crmslt,atw,atw1,molsltlim,itemp,idebughx,iw0,maxrsd,
     -  maxat)
      dimension c(3,maxat),cres(3,maxat),cc1(3,maxat),cc2(3,maxat),
     -  crmslt0(3),crmslt(3),atw(nslt),atw1(nslt),molsltlim(3,maxrsd),
     -  itemp(maxat)
      dimension overlaysds(1000),crmshift(3),com1(3),com2(3),rot(3,3)
c     print *,'SOLUTEOVERLAY nsegslt,nslt,maxat=',nsegslt,nslt,maxat
      if (isubcrm+ioverlay .eq. 0) then
c       No translation or rotation
        call trnsfr(cc2,c,3*nslt)
      else
        call cofms(c,crmslt,nslt,atw)
        call arrdiff(crmslt,crmslt0,crmshift,3)
        if (ioverlay .eq. 0) then
c         Just translation
          do ia=1,nslt
            call arrdiff(c(1,ia),crmshift,cc2(1,ia),3)
          end do
        else if (ioverlay .eq. 1) then
c         Overlay of the whole solute
          call indexit(itemp,1,nslt,0) 
          call bestoverlay(nslt,itemp,itemp,cres,c,atw,0.d0,
     -      cc1,cc2,atw1,rot,com1,com2,idebughx,0.001,iw0,maxat)
          call shiftmol(c,nslt,com2,cc2,-1.0)
          call rotate_c(cc2,nslt,rot,cc2,'HELIX',5)
          call shiftmol(cc2,nslt,com1,cc2,+1.0)
          overlaysd=sdsumix(nslt,cres,cc2,atw,0,itemp,devmax,maxat)
        else
c         Overlay separately each solute molecule
          do is=1,nsegslt
            nats=molsltlim(2,is)-molsltlim(1,is)+1
            ifat=molsltlim(1,is)
            call indexit(itemp,1,nats,molsltlim(1,is)-1)
            call bestoverlay(nats,itemp,itemp,cres,c,atw,0.d0,
     -        cc1,cc2,atw1,rot,com1,com2,idebughx,0.001,iw0,maxat)
            call shiftmol(c(1,ifat),nats,com2,cc2(1,ifat),-1.0)
            call rotate_c(cc2(1,ifat),nats,rot,cc2(1,ifat),'HELIXs',6)
            call shiftmol(cc2(1,ifat),nats,com1,cc2(1,ifat),+1.0)
            overlaysds(is)=sdsumix(nats,cres,cc2,atw,0,itemp,devmax,
     -        maxat)
          end do
        end if
      end if
      if (ioverlay .eq. 2) then
        write (iw0,1003) crmshift,(overlaysds(is),is=1,nsegslt)
      else if (ioverlay .eq. 1) then
        write (iw0,1004) crmshift,' RMSD=',overlaysd
      else if (isubcrm .gt. 0) then
        write (iw0,1004) crmshift
      end if
      return
1003  format(' Solute COM shift=',3f10.3,' Molecular RMSDs=',(2f7.2))
1004  format(' Solute COM shift=',3f10.4,a,f8.4)
      end
      subroutine helixcomp(c,nslt,nres,calph0,dir0,perpvec0,start0,end0,
     -  cent0,crmslt0,rn0,camod,axfact,calph,dir,perpvec,start,end,cent,
     -  anglechange,anglechangeref,crmslt,axtol,iw0,torsion,
C@GL     -  inpfile,namlen,nconfig,
     -  rotation,nrep,igl,indexax,incrot,ireorienthx,idebughx,radtodeg,
     -  pi,cc2,nreshx,icaahx,ihx,nhxres,maxhx,maxat)
      dimension c(3,nslt),crmslt0(3),crmslt(3),anglechange(maxhx),
     -  anglechangeref(maxhx),indexax(3),cc2(3,maxat),icaahx(maxhx)
      real*8 calph0(3,maxhx),dir0(3),start0(3),end0(3),cent0(3),rn0(3),
     -  perpvec0(3,maxhx),camod(3,maxhx),axfact(maxhx),calph(3,maxhx),
     -  dir(3),start(3),end(3),cent(3),perpvec(3,maxhx)
C@GL      character*(*) inpfile
      parameter (MAXFRAMES=50000,MAXCOPY=600)
      common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
     -  increment,increment2,res(2,MAXFRAMES,MAXCOPY),
     -  x0(MAXCOPY),y0(MAXCOPY),nxselres,ixselres(MAXCOPY)
      character*2 iatnm2
      common /atnam/ aw(99),nval(99),nvalmax(99),mmofan(99),
     -  mmatno(64),iatnm2(99)
      real*8 org(3),dev(3),startg(3),endg(3),circ(3),rn(3),xx(3),yy(3),
     -  startw(3),endw(3),dirw(3),dirdotdir0,ddot,rms,devs(3),deve(3)
      dimension rot(3,3),corig(3,3),ccurr(3,3),shift(3),angles(3)
      character*9 decidebend
c     Compute the rotation angle of a helix form the average angle between
c     the corresponding perpendiculars to the helix axis from the Calphas
      incrhx=(ihx-1)*nhxres
      iverbort=1
      if (nframe .gt. 10 .or. nrep .gt. 1) iverbort=0
c     print *,'HELIXC nframe,nrep,iverbort=',nframe,nrep,iverbort
      if (nrep .eq. 1 .and. nframe .eq. 1 .and. idebughx .gt. 0)
     -  write (iw0,1001) 'initial',cent0,
     -  ((calph0(k,ir),k=1,3),ir=1,nres)
      it=0
c     cc2 will be the possibly translated/overlaid frame
      call helixaxis(cc2,nslt,0,calph,dirw,startw,endw,cent,perpvec,
     -  camod,anglechangeref,circ,rn,axfact,axtol,rot,
     -  rms,helixlen,angles,decidebend,nup,ndown,nrun,nnear,rcirc,
     -  turnperres,anglesn,0,incrot,nrep,1,nreshx,icaahx,ihx,nhxres,igl,
     -  idebughx,radtodeg,pi,MAXHX)
      call trnsfrd(start,startw,3)
      call trnsfrd(end,endw,3)
      call trnsfrd(dir,dirw,3)
      if (nrep .eq. 1 .and. idebughx .gt. 0) write (iw0,1001)
     -  'current',cent,((calph(k,ir),k=1,3),ir=1,nres)
c     Shift the helix so that the start is at the origin
      do ir=1,nres
        call dvdif(calph(1,ir),start,calph(1,ir))
      end do
      call dvdif(end,start,end)
      do k=1,3
        shift(k)=start(k)
      end do
      call zeroitd(start,3)
      call trnsfrd(startg,start,3)
      call trnsfrd(endg,end,3)
      if (nrep .eq. 1) then
        dirdotdir0=ddot(dir,dir0)
        rotation=dacoscheck(dirdotdir0,ccc,1,6,'HELIXCOMP')
        res(1,nframe,incrhx+5)=cos(rotation)
        res(2,nframe,incrhx+5)=sin(rotation)
        call dvdif(cent,cent0,dev)
        res(1,nframe,incrhx+8)=dsqrt(ddot(dev,dev))
        res(2,nframe,incrhx+8)=dev(indexax(1))
        res(1,nframe,incrhx+9)=dev(indexax(2))
        res(2,nframe,incrhx+9)=dev(indexax(3))
        call dvdif(startw,start0,devs)
        res(1,nframe,incrhx+10)=devs(indexax(2))
        res(2,nframe,incrhx+10)=devs(indexax(3))
        call dvdif(endw,end0,deve)
        res(1,nframe,incrhx+11)=deve(indexax(2))
        res(2,nframe,incrhx+11)=deve(indexax(3))
        if (idebughx .gt. 0 .and. dirdotdir0 .gt. 0.001)
     -   write (iw0,1001) 'current',cent,((calph(k,ir),k=1,3),ir=1,nres)
        if (ireorienthx .eq. 1) then
c         For better result, rotate dir onto dir0. The rotation axis is the
c         normal to the dir0-dir plane
          call dcross(dir0,dir,org)
          do k=1,3
            corig(k,1)=0.0
            ccurr(k,1)=0.0
            corig(k,2)=dir0(k)
            ccurr(k,2)=dir(k)
            corig(k,3)=org(k)
            ccurr(k,3)=org(k)
          end do
          call ormat(rot,ccurr,corig,3,iverbort)
          do ir=1,nres
            call dsmatvec(rot,calph(1,ir),calph(1,ir))
          end do
          call trnsfrd(dir,dir0,3)
          if (idebughx .gt. 0) write (iw0,1001) 'current reoriented',
     -      cent,((calph(k,ir),k=1,3),ir=1,nres)
        end if
        do ir=1,nres
          call calcperp(start,dir,calph(1,ir),org,perpvec(1,ir),it)
        end do
        nflip=0
100     rotav=0
        rotav2=0
        changemin=100.0
        changemax=0.0
        nflipprev=nflip
c       write (79,*) 'NRES-',nres
        do ir=1,nres
          call angcomp(perpvec0(1,ir),dir0,perpvec(1,ir),angchange)
c          write (79,9671) ir,angchange,(dir0(k),k=1,3),
c     -      (perpvec(k,ir),k=1,3),(perpvec0(k,ir),k=1,3)
c9671      format(' ir=',i3,' dang=',f10.4,' dir0=',3f10.5,/,
c     -      ' perpvec=',3f10.5,' perpvec0=',3f10.5)
          rotav=rotav+angchange
          rotav2=rotav2+angchange**2
          if (angchange .lt. changemin) changemin=angchange
          if (angchange .gt. changemax) changemax=angchange
          anglechange(ir)=angchange
        end do
        torsion=rotav/nres
        sd=sqrt(abs(rotav2/nres-torsion**2))
cd77        write (77,6533) nframe,torsion*180.0/pi,changemin*180.0/pi,
cd77     -    changemax*180.0/pi,(anglechange(ir)*180.0/pi,ir=1,nres)
cd776533    format(' Nframe=',i6,' avg,min,max=',3f10.3,/,(10f8.2))
        if (changemax-changemin .gt. pi/2.0) then
c         Likely to have some sign flips
          do ir=1,nres
            do k=1,3
              xx(k)=-perpvec(k,ir)
            end do
            call angcomp(perpvec0(1,ir),dir0,xx,angchange)
            if (abs(angchange-torsion) .lt.
     -        abs(anglechange(ir)-torsion)) then
              call trnsfrd(perpvec(1,ir),xx,3)
              nflip=nflip+1
            end if
          end do
          if (nflip .le. nres .and. nflip .gt. nflipprev) go to 100
        end if
        if (nflip .gt. 0) then
c         Recalculate TPR
          call calcturnperres(turnperres,nres,incrot,perpvec,dir,
     -      anglechangeref,1,pi,MAXHX)
          res(1,nframe,incrhx+6)=cos(turnperres)
          res(2,nframe,incrhx+6)=sin(turnperres)
        end if
        res(1,nframe,incrhx+4)=cos(torsion)
        res(2,nframe,incrhx+4)=sin(torsion)
        call dcross(dir0,rn0,xx)
        call dcross(rn0,xx,yy)
        do k=1,3
          rot(1,k)=yy(k)
          rot(2,k)=xx(k)
          rot(3,k)=rn0(k)
        end do
c       Keep the normal from oscillating 180 degrees
        if (ddot(rn,rn0) .lt. 0.d0) call dvmul(rn,-1.0d0,rn)
        call dsmatvec(rot,rn,xx)
        res(1,nframe,incrhx+12)=xx(1)
        res(2,nframe,incrhx+12)=xx(2)
        call printhelix(iw0,startw,endw,cent,rms,helixlen,dirw,angles,
     -    decidebend,nup,ndown,nrun,nnear,rcirc,turnperres,anglesn,ihx,
     -    radtodeg)
        write (iw0,1000) radtodeg*torsion,radtodeg*sd,radtodeg*rotation,
     -    radtodeg*dacoscheck(ddot(rn,rn0),ccc,1,6,'HELIXNORMALS'),dev,
     -    dsqrt(ddot(dev,dev))
      end if
      if (nrep .lt. 0) return
C@GL      call drawkink(idkink,idaxes,idseqn,idfname,nconfig,nrep,c,nslt,
C@GL     -  startg,endg,startg,endg,shift,1,inpfile,namlen,1,1,1,1,cent,
C@GL     -  circ,rn)
      return
1000  format(' Rotation=',f9.2,' SD=',f7.2,
     -  ' Local tilt=',f9.2,' N/Nr angle:',f8.3,/,
     -  ' X,Y,Z displacements=',3f9.5,' Absolute displacement=',f9.5)
1001  format(' ',a,' helix cent:',3f12.8,/,' Alpha C:',(3f12.8))
      end
      subroutine angcomp(v0,d0,v,ang)
      real*8 v0(3),d0(3),v(3),v01(3),ddot
c     Calculate the angle between v1 and v2.
c     Obtain the sign by requiring that d0 and d1 correspond to the z axis
      ang=dacoscheck(ddot(v0,v)/dsqrt(ddot(v0,v0)*ddot(v,v)),ccc,1,
     -  6,'ANGCOMP')
      call dcross(v0,v,v01)
      if (ddot(v01,d0) .lt. 0.d0) ang=-ang
      return
      end
      subroutine calcturnperres(turnperres,nres,incrot,perpvec,axisdir,
     -  anglechangeref,irefang,pi,MAXHX)
      real*8 perpvec(3,MAXHX),axisdir(3)
      dimension anglechangeref(MAXHX)
      nresu=nres-2*incrot
      a11=(2*nresu**3+3*nresu**2+nresu)/6
      a21=(nresu*(nresu+1))/2
      a12=a21
      a22=nresu
      b1=0.0
      b2=0.0
      turna=0.0
      nturn=0
      turnchangeav=0.0
      do ir=2+incrot,nres-incrot
        call angcomp(perpvec(1,ir-1),axisdir,perpvec(1,ir),turnchange)
        if (turnchange .lt. 0.0) turnchange=turnchange+2.0*pi
        if (irefang .eq. 1) then
c         Compare with turn angle in the reference conformation
          if (abs(turnchange-anglechangeref(ir)) .gt.
     -        abs((turnchange-2.0*pi)-anglechangeref(ir)))
     -      turnchange=turnchange-2.0*pi
cd77          write (77,*) 'ir,turnchange,ref=',
cd77     -      ir,turnchange*180.0/pi,anglechangeref(ir)*180.0/pi
        end if
        turnchangeav=turnchangeav+turnchange
        turna=turna+turnchange
cd77        write (77,*) 'ir,turna,turnchange=',ir,
cd77     -    turna*180.0/pi,turnchange*180.0/pi
        b1=b1+(ir-incrot)*turna
        b2=b2+turna
      end do
      turnperres=(a22*b1-a12*b2)/(a22*a11-a12*a21)
      turnchangeav=turnchangeav/float(nres-2*incrot-1)
cd77      write (77,*) 'turnchangeav=',turnchangeav,turnchangeav*180.0/pi
      return
      end
      subroutine prokinkcalcla(nrepc,c,nslt,bend,wobble,faceshift,
     -  rmsb,rmsa,
C@GL     -  ncnf,inpfile,namlen,noprol,
     -  iflatproline,ix5,radtodeg,maxhlx)
      dimension c(3,nslt),ix5(5)
C@GL      character*(*) inpfile
      real*8 calph(3,maxhlx),axisdirb(3),axisinib(3),axisendb(3),
     -  axisdira(3),axisinia(3),axisenda(3),rms
      parameter (MAXHX=50)
      common /prokink/ icab(MAXHX),icaa(MAXHX),icb(MAXHX),ica(MAXHX),
     -  inb(MAXHX),ina(MAXHX),icapr,icpr,inpr,nra,nrb,icbpr,icgpr,icdpr,
     -  iprintpk
      character*60 message
c     ProKink variables
      real*8 ddot,dmag,cosa,pro_alphC,orig,origa,orig3,orig4,
     -  perpvec,perpveca,perpvec3,perpvec4,perpvec34,enda,
     -  bmin3C,bmin4C,zax,xx,prolinering,p0,ringnorm,axfact,rr
      dimension pro_alphC(3),orig(3),origa(3),orig3(3),orig4(3),
     -  perpvec(3),perpveca(3),perpvec3(3),perpvec4(3),perpvec34(3),
     -  bmin3C(3),bmin4C(3),enda(3),zax(3),xx(3),prolinering(3,5),
     -  p0(3),ringnorm(3),axfact(5)
c     print *,'PROKINKCALCLA icpr,inpr,nra,nrb=',icpr,inpr,nra,nrb
      iprintkahn=0
      do k=1,3
        calph(k,1)=c(k,icapr)
      end do
      do ir=1,nra
        do k=1,3
          calph(k,ir+1)=c(k,icaa(ir+1))
        end do
      end do
      message=
     - 'Helix after the kink                                        '
      call kahn(calph,nra+1,.true.,axisdira,axisinia,axisenda,
     -  rms,iprintkahn, message,MAXHX)
      rmsa=rms
      if (iprintpk .gt. 1) then
        write (6,7011) 'after','axis',axisdira
        write (6,7011) 'after','init',axisinia
        write (6,7011) 'after','end ',axisenda
        print *,'rms=',rms
      end if
      do ir=1,nrb
        do k=1,3
c         calph(k,ir+1)=c(k,icab(ir+1))
          calph(k,ir)=c(k,icab(ir))
        end do
      end do
      message=
     -  'Helix before the kink                                       '
      call kahn(calph,nrb,.true.,axisdirb,axisinib,axisendb,rms,
     -  iprintkahn, message,MAXHX)
      rmsb=rms
      if (iprintpk .gt. 1) then
        write (6,7011) 'before','axis',axisdirb
        write (6,7011) 'before','init',axisinib
        write (6,7011) 'before','end ',axisendb
        print *,'RMS=',rms
      end if
      iac=icapr
      im3=icab(3)
      im4=icab(4)
      do k=1,3
        pro_alphC(k)=c(k,icapr)
        bmin3C(k)=c(k,im3)
        bmin4C(k)=c(k,im4)
      end do
      if (iflatproline .eq. 1) then
        do i=1,5
          do k=1,3
            prolinering(k,i)=c(k,ix5(i))
          end do
        end do
        call fitpoints(prolinering,5,3,p0,ringnorm,axfact,iprintpk)
        call dvdif(pro_alphC,p0,xx)
        rr=ddot(xx,ringnorm)
        do k=1,3
          pro_alphC(k)=pro_alphC(k)+rr*ringnorm(k)
        end do
      end if
c     New code for proline kink calculation
c     Bend angle: from the scalar product of the two axis vectors
c     Both axis vectors point away from the proline
      cosa=-ddot(axisdira,axisdirb)
      bend=dacoscheck(cosa,ccc,1,6,'PROK-B')*radtodeg
c     Wobble  angle: from the scalar product of the two normals to the
c     before helix axis (from the C-alpha of Proline and the end of the
c     after helix)
      call calcperp(axisendb,axisdirb,pro_alphC,orig,perpvec,iprintpk)
      call dvsum(orig,axisdira,enda)
      call calcperp(axisinib,axisdirb,enda,origa,perpveca,iprintpk)
      call dvdif(origa,enda,xx)
      cc=dmag(xx)
      if (cc .lt. 0.01) print *,'Wobble is suspect'
      cosa=ddot(perpvec,perpveca)
      wobble=dacoscheck(cosa,ccc,1,6,'PROK-W')*radtodeg
c     Establish sign
      call dcross(axisdirb,perpvec,zax)
      if (ddot(zax,perpveca) .gt. 0.d0) wobble=-wobble
      call calcperp(axisinib,axisdirb,bmin3C,orig3,perpvec3,iprintpk)
      call calcperp(axisinib,axisdirb,bmin4C,orig4,perpvec4,iprintpk)
      call dvnorm(perpvec)
      call dvnorm(perpvec3)
      call dvnorm(perpvec4)
      do k=1,3
        perpvec34(k)=(perpvec3(k)+perpvec4(k))/2.d0
      end do
      call dvnorm(perpvec34)
      cosa=ddot(perpvec,perpvec34)
      faceshift=dacoscheck(cosa,ccc,1,6,'PROK-FS')*radtodeg
c     Establish sign
      cosa3=ddot(perpvec,perpvec3)
      cosa4=ddot(perpvec,perpvec4)
      if (cosa3 .gt. cosa4) faceshift=-faceshift
      if (nrepc .lt. 0) return
C@GL      call drawkink(idkink,idaxes,idseqn,idfname,ncnf,nrepc,c,nslt,
C@GL     -  axisinib,axisendb,axisinia,axisenda,c,0,inpfile,namlen,noprol,0,
C@GL     -  0,0,xx,xx,xx)
      return
7011  format(' Helix ',a,': ',a,'=',3f10.4)
      end
      subroutine calcperp(start,dir,from,orig,perpvec,itest)
      real*8 start,dir,from,orig,perpvec
      dimension start(3),dir(3),from(3),orig(3),perpvec(3)
c     For a line from start in the direction dir, calculate the normal to it
c     from the point from. The normal meets the line at orig and its direction
c     is perpvec
      real*8 ddot,dmag,dsx,xx,ddsx,perpvecfac
      dimension dsx(3),xx(3)
      call dvdif(from,start,dsx)
      ddsx=ddot(dir,dsx)
      do k=1,3
        perpvec(k)=dir(k)*ddsx-dsx(k)
      end do
c     call dcross(dsx,dir,xx)
c     call dcross(xx,dir,perpvec)
      call dvnorm(perpvec)
      perpvecfac=ddot(perpvec,dsx)
      do k=1,3
        orig(k)=from(k)-perpvecfac*perpvec(k)
      end do
      if (itest .gt. 0) then
        write (6,1000) 'Start     ',start
        write (6,1000) 'Dir       ',dir,' Magn=',dmag(dir)
        write (6,1000) 'From      ',from
        write (6,1000) 'Orig      ',orig
        write (6,1000) 'Perpvec   ',perpvec,' Magn=',dmag(dir)
        if (itest .gt. 1) then
          cc=ddot(dir,perpvec)
          print *,'Dir . Perpvec (->0)=',cc
          call dvdif(start,orig,xx)
          cc=ddot(dir,xx)/dmag(xx)
          print *,'Dir . (orig-start) (->1)=',cc
        end if
      end if
      return
1000  format(1x,a10,3f12.6,a,f12.6)
      end
      subroutine savekinkdat(nmem,bend,wobble,faceshift,psr,radtodeg)
      parameter (MAXFRAMES=50000,MAXCOPY=600)
      parameter (MAXCOPY6=MAXCOPY-6)
      common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
     -  increment,increment2,bdxy(2,MAXFRAMES),wbxy(2,MAXFRAMES),
     -  fsxy(2,MAXFRAMES),wfsxy(2,MAXFRAMES),psxy(2,MAXFRAMES),
     -  turnpr(2,MAXFRAMES),scalardat(2,MAXFRAMES,MAXCOPY6),
     -  x0(MAXCOPY),y0(MAXCOPY),nxselres,ixselres(MAXCOPY)
      bdxy(2,nframe)=sin(bend/radtodeg)
      bdxy(1,nframe)=cos(bend/radtodeg)
            wbxy(2,nframe)=sin(wobble/radtodeg)
      wbxy(1,nframe)=cos(wobble/radtodeg)
      fsxy(2,nframe)=sin(faceshift/radtodeg)
      fsxy(1,nframe)=cos(faceshift/radtodeg)
      wfs=wobble-faceshift
      wfsxy(2,nframe)=sin(wfs/radtodeg)
      wfsxy(1,nframe)=cos(wfs/radtodeg)
      if (nmem .gt. 0) then
        psxy(2,nframe)=sin(psr/radtodeg)
        psxy(1,nframe)=cos(psr/radtodeg)
      end if
      return
      end
      subroutine princax(c,co,aw,awo,n,indxdel,evecs0,evals0,iprint,
     -  inputref,irefcall,radtodeg,LEVTEST)
      dimension c(3,n),co(3,n),aw(n),awo(n),indxdel(n),evecs0(3,3),
     -  evals0(3)
      parameter (MAXFRAMES=50000,MAXCOPY=600)
      common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
     -  increment,increment2,res(2,MAXFRAMES,MAXCOPY),
     -  x0(MAXCOPY),y0(MAXCOPY),nxselres,ixselres(MAXCOPY)
      common /pcadat/ evecsprev(3,3),angprev(3)
      real*8 ddd
      character*1 signlab(3)
      dimension com(3),index(3),ifa(3),ila(3),itemp(3),temp(3),
     -  overlap(3,3),evecs(3,3),evals(3),ang(3),evecstemp(3,3),
     -  tenssave(3,3)
      real*8 tensinert(3,3),diag(3),offdiag(3)
      data signlab /3*' '/
      if (iprint .eq. 0)  then
        iout=6
      else
        iout=iprint
      end if
c     write (iout,*)'PRINCAX inputref,irefcall=',inputref,irefcall
      write (iout,*)
      nfinal=n
      call trnsfr(co,c,3*n)
      call trnsfr(awo,aw,n)
      call extract(co,indxdel,3,n,nfinal)
      call extract(awo,indxdel,1,n,nfinal)
      call cofms(co,com,nfinal,aw)
      call zeroitd(tensinert,9)
      awsum=0.0
      do ia=1,nfinal
        do i=2,3
          do j=1,i-1
            tensinert(i,j)=tensinert(i,j)+
     -        aw(ia)*(co(i,ia)-com(i))*(co(j,ia)-com(j))
          end do
        end do
        tensinert(1,1)=tensinert(1,1)+aw(ia)*
     -    ((co(2,ia)-com(2))**2+(co(3,ia)-com(3))**2)
        tensinert(2,2)=tensinert(2,2)+aw(ia)*
     -    ((co(1,ia)-com(1))**2+(co(3,ia)-com(3))**2)
        tensinert(3,3)=tensinert(3,3)+aw(ia)*
     -    ((co(1,ia)-com(1))**2+(co(2,ia)-com(2))**2)
      end do
      do i=2,3
        do j=1,i-1
           tensinert(j,i)=tensinert(i,j)
        end do
      end do
      do i=1,3
        do j=1,3
           tenssave(j,i)=tensinert(i,j)
        end do
      end do
c     Find the eigenvectors a and eigenvalues mu of tensinert
      call dtred2(tensinert,3,3,diag,offdiag)
      call dtqli(diag,offdiag,3,3,tensinert,ierr)
      if (ierr .gt. 0) then
        write (6,2004)
        write (iout,2004)
        return
      end if
      do k=1,3
        evals(k)=diag(k)
      end do
      call indexit(index,1,3,0)
      call mrgsrt(6,index,evals,3,ifa,ila,itemp,temp,3)
      do k=1,3
        do l=1,3
          evecs(k,l)=tensinert(l,index(k))
        end do
      end do
      if (LEVTEST .gt. 1) then
c       Test the eigenvectors after sort
        do i=1,3
          do j=1,3
            s=0.0
            do k=1,3
              s=s+tenssave(i,k)*evecs(j,k)
            end do
            evecstemp(i,j)=s/evals(j)
          end do
        end do
c       The columns of evecstemp should be also the eigenvectors
        if (LEVTEST .gt. 2) then
          write (iout,7777) 'evecstest',((evecstemp(i,k),i=1,3),k=1,3)
          write (iout,7777) 'evecs',((evecs(k,i),i=1,3),k=1,3)
        end if
        do i=1,3
          rmin=100.0
          rmax=-100.0
          do j=1,3
            if (evecstemp(j,i) .ne. 0.0) then
              r=evecs(i,j)/evecstemp(j,i)
              if (rmin .gt. r) rmin=r
              if (rmax .lt. r) rmax=r
            end if
          end do
          if (abs(rmax-rmin) .gt. 0.01)
     -      write (iout,*) 'eval failure=',rmax-rmin
        end do
      end if
c     The rows of the matrix evecs are the eigenvectors
c      write (6,1000) diag,evals,tensinert,evecs
c1000  format(' diag=',3f15.5,/,' evals=',3f15.5,/,
c     -  ' tensinert=',/,3(3f10.5,/),' evecs=',/,3(3f10.5,/))
      if (irefcall .eq. 1) then
        call trnsfr(evals0,evals,3)
        call trnsfr(evecs0,evecs,9)
        write (iout,2000) (i,evals(i),(evecs(i,k),k=1,3),' ',i=1,3)
        call trnsfr(evecsprev,evecs0,9)
        return
      end if
      if (nframe .le. 1) then
        if (inputref .eq. 0) then
          call trnsfr(evals0,evals,3)
          call trnsfr(evecs0,evecs,9)
          call zeroit(ang,3)
        end if
      end if
      call indexit(index,1,3,0)
      if (nframe .gt. 1 .or. inputref .eq. 1) then
        if (LEVTEST .gt. 0) then
c         Now check overlap with previous orientation
          call overlapcheck(evecsprev,evecs,overlap,index,nneg)
          write (iout,7777) 'overlap with previous frame',
     -      ((overlap(k,i),i=1,3),k=1,3)
          write (iout,*) 'index=',index
          if (nneg .gt. 0) write (iout,2003) (overlap(index(i),i),i=1,3)
          call overlapcheck(evecs0,evecs,overlap,index,nneg)
          write (iout,7777) 'overlap with reference frame',
     -      ((overlap(k,i),i=1,3),k=1,3)
          write (iout,*) 'index=',index
          if (nneg .gt. 0) write (iout,2003) (overlap(index(i),i),i=1,3)
        end if
        call overlapcheck(evecs0,evecs,overlap,index,nneg)
        do i=1,3
          ang(i)=radtodeg*
     -      dacoscheck(ddd,abs(overlap(index(i),i)),0,6,'PRINCAX')
        end do
      end if
      if (nframe .gt. 0) then
        call trajlimtest(nframe,MAXFRAMES)
        res(1,nframe,1)=evecs(1,1)
        res(2,nframe,1)=evecs(1,2)
        res(1,nframe,2)=evecs(1,3)
        res(2,nframe,2)=evecs(2,1)
        res(1,nframe,3)=evecs(2,2)
        res(2,nframe,3)=evecs(2,3)
        res(1,nframe,4)=evecs(3,1)
        res(2,nframe,4)=evecs(3,2)
        res(1,nframe,5)=evecs(3,3)
        res(1,nframe,6)=ang(1)
        res(2,nframe,6)=ang(2)
        res(1,nframe,7)=ang(3)
      end if
      if (nframe .le. 1 .and. inputref .eq. 0)
     -   call indexit(index,1,3,0)
      write (iout,2000)
     -  (i,evals(index(i)),(evecs(i,k),k=1,3),signlab(i),i=1,3)
      if (nframe .gt. 0) write (iout,2001) ang
      if (irefcall .eq. 0) call trnsfr(evecsprev,evecs,9)
      return
2000  format(' Evalue ',i1,'=',f15.4,' Principal axes=',3f9.5,1x,a)
2001  format(' Angles between initial and current principal axes=',
     -  3f8.2,' deg')
2003  format(' Negative overlap found:',3f6.1)
2004  format(' Calculation aborted due to diagonalization failure')
7777  format(1x,a,':',/,(3f10.5))
      end
      subroutine molrad(c,index,nats,iout,maxats)
      dimension c(3,maxats),index(nats)
      parameter (MAXFRAMES=50000,MAXCOPY=600)
      common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
     -  increment,increment2,res(2,MAXFRAMES,MAXCOPY),
     -  x0(MAXCOPY),y0(MAXCOPY),nxselres,ixselres(MAXCOPY)
      real*8 rg,rh,rav(3),rgten(3,3),diag(3),offdiag(3),diagmin,diagmid,
     -  diagmax
      write (iout,*)
      call zeroitd(rav,3)
      call zeroitd(rgten,9)
      do ia=1,nats
        do k=1,3
          rav(k)=rav(k)+c(k,index(ia))
        end do
      end do
      do k=1,3
        rav(k)=rav(k)/nats
      end do
      rg=0.d0
      do ia=1,nats
        rg=rg+(c(1,index(ia))-rav(1))**2+(c(2,index(ia))-rav(2))**2+
     -    (c(3,index(ia))-rav(3))**2
      end do
      rg=rg/nats
      rg=sqrt(rg)
      rh=0.d0
      do ia=1,nats
        do ja=ia+1,nats
          rij=dist2(c(1,index(ia)),c(1,index(ja)))
          if (rij .lt. 1.e-5) then
            write (6,1000) ia,ja
          else
            rh=rh+1.0/sqrt(rij)
          end if
          do k=1,3
            do l=1,3
              rgten(k,l)=rgten(k,l)+(c(k,index(ia))-c(k,index(ja)))*
     -          (c(l,index(ia))-c(l,index(ja)))
            end do
          end do
        end do
      end do
      rh=2.0*rh/nats**2
c     Find the eigenvectors a and eigenvalues mu of rgten
      do k=1,3
        do l=1,3
          rgten(k,l)=rgten(k,l)/float(nats**2)
        end do
      end do
      call dtred2(rgten,3,3,diag,offdiag)
      call dtqli(diag,offdiag,3,3,rgten,ierr)
      if (ierr .gt. 0) then
        write (6,1004)
        write (iout,1004)
        return
      end if
      diagmin=dmin1(diag(1),diag(2),diag(3))
      diagmax=dmax1(diag(1),diag(2),diag(3))
      diagmid=0.d0
      if (diagmax .eq. diagmin) then
        diagmid=diagmin
      else
        do k=1,3
          if (diag(k) .ne. diagmin .and. diag(k) .ne. diagmax) 
     -      diagmid=diag(k)
        end do
      end if
      rmaxmin=1.0
      if (diagmin .ne. 0.d0) rmaxmin=diagmax/diagmin
      asph=diagmax-0.5*(diagmin+diagmid)
      acyl=diagmid-diagmin
      rsa=1.5*(diag(1)**2+diag(2)**2+diag(3)**2)/
     -  (diag(1)+diag(2)+diag(3))**2-0.5
      if (nframe .gt. 0) then
        call trajlimtest(nframe,MAXFRAMES)
        write (iout,1001) nframe,rg,1/rh
        res(1,nframe,1)=rg
        res(2,nframe,1)=1.0/rh
        res(1,nframe,2)=rh
        res(2,nframe,2)=rmaxmin
      else
        write (iout,1002) rg,1/rh
      end if
      write (iout,1003) diag,rmaxmin,asph,acyl,rsa
      return
1000  format(' Atoms ',i6,' and ',i6,' are too close')
1001  format(' Frame',i6,' R(gyration)=',f9.3,' R(hydrodynamic)=',f9.3)
1002  format(' R(gyration)=',f9.3,' R(hydrodynamic)=',f9.3)
1003  format(' Moments of inertia=',3f10.3,' M(max)/M(min)=',f10.3,/,
     -  ' Asphericity=',f8.3,' Acylindricity=',f8.3,
     -  ' Relative shape anisotropy=',f8.3)
1004  format(' Calculation aborted due to diagonalization failure')
      end
      subroutine overlapcheck(evecsprev,evecs,overlap,index,nneg)
      dimension evecsprev(3,3),evecs(3,3),overlap(3,3),index(3)
      dimension absoverlap(3,3)
      data imax1 /0/,jmax1 /0/,imax2 /0/,jmax2 /0/
      call zeroit(overlap,9)
      do i=1,3
        do j=1,3
          do k=1,3
            overlap(i,j)=overlap(i,j)+evecsprev(i,k)*evecs(j,k)
          end do
          absoverlap(i,j)=abs(overlap(i,j))
        end do
      end do
      call zeroiti(index,0,3)
      omax=0.0
      do i=1,3
        do j=1,3
          if (omax  .lt. absoverlap(i,j)) then
            omax=absoverlap(i,j)
            imax1=i
            jmax1=j
          end if
        end do
      end do
      index(imax1)=jmax1
      omax=0.0
      do i=1,3
        if (i .ne. imax1) then
          do j=1,3
            if (j .ne. jmax1) then
              if (omax  .lt. absoverlap(i,j)) then
                omax=absoverlap(i,j)
                imax2=i
                jmax2=j
              end if
            end if
          end do
        end if
      end do
      index(imax2)=jmax2
      do i=1,3
        if (index(i) .eq. 0) index(i)=6/(jmax1*jmax2)
      end do
      nneg=0
      do i=1,3
        if (overlap(index(i),i) .lt. 0.0) nneg=nneg+1
      end do
      return
      end
      subroutine correl(iout,res1,ic1,name1,lname1,av1,sd1,res2,ic2,
     -  name2,lname2,av2,sd2,corr,n,iavsdcalc,now6)
      dimension res1(2,n),res2(2,n)
      character*(*) name1,name2
      real*8 sum12,sum1,sum2,sum11,sum22
      if (iavsdcalc .gt. 0) then
c       Calculate and print avg & sd
        sum1=0.d0
        sum2=0.d0
        sum11=0.d0
        sum22=0.0d0
        do i=1,n
          sum1=sum1+res1(ic1,i)
          sum11=sum11+res1(ic1,i)**2
          sum2=sum2+res2(ic2,i)
          sum22=sum22+res2(ic2,i)**2
        end do
        av1=sum1/n
        av2=sum2/n
        sd1=dsqrt(dabs(sum11/n-av1**2))
        sd2=dsqrt(dabs(sum22/n-av2**2))
        write (6,1001) name1(1:lname1),av1,sd1
        write (6,1001) name2(1:lname2),av2,sd2
      end if
      sum12=0.d0
      do i=1,n
        sum12=sum12+res1(ic1,i)*res2(ic2,i)
      end do
      sum12=sum12/n
      corr=0.0
      if (sd1*sd2 .gt. 0.0) corr=(sum12-av1*av2)/(sd1*sd2)
      if (now6 .eq. 0)
     -  write (6,1000) name1(1:lname1),name2(1:lname2),corr
      write (iout,1000) name1(1:lname1),name2(1:lname2),corr
      return
1000  format(1x,a25,' - ',a25,' correlation=',f8.5)
1001  format(1x,a25,' Average=',f15.6,' S.D.=',f16.5)
      end
      subroutine trajstat(iout,ndials,maxdials,angname,langname,nrdat,
     -  maxrdat,irescolf,rname,lrname,corr12,incrres,nocorr,now6,
     -  radtodeg)
      character*(*) angname(maxdials),rname(maxrdat)
      dimension langname(maxdials),lrname(maxrdat)
      parameter (MAXFRAMES=50000,MAXCOPY=600)
      common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
     -  increment,increment2,res(2,MAXFRAMES,MAXCOPY),
     -  x0(MAXCOPY),y0(MAXCOPY),nxselres,ixselres(MAXCOPY)
      dimension av_a(MAXCOPY),cv(MAXCOPY),av_r(MAXCOPY),sd_r(MAXCOPY)
      real*8 ddd,sum,sum2,sinsum,cossum,sinsum_ab,sinsum2,cossum2,
     -  sinsum2_a,sinsum2_b,ang_ai,ang_aj,ang_bi,ang_bj,
     -  sin_aij,sin_bij,r12,r13,r23,csd,ssd,csc,crs,crc,corrsum
      write (iout,*) ' '
      if (maxdials .gt. MAXCOPY-1) then
        write (6,2004) maxdials,MAXCOPY
        stop
      end if
      if (nframe .lt. 1) return
      do id=1,ndials
        sinsum=0.d0
        cossum=0.d0
        do i=1,nframe
          cossum=cossum+res(1,i,incrres+id)
          sinsum=sinsum+res(2,i,incrres+id)
        end do
        sum=dsqrt(sinsum**2+cossum**2)
        cv(id)=1.0-sum/nframe
        cossum=cossum/sum
        av_a(id)=dacoscheck(cossum,csum,1,6,'TRAJSTAT')*radtodeg
        if (sinsum .lt. 0.d0) av_a(id)=-av_a(id)
        if (now6 .eq. 0)
     -    write (6,2078) angname(id)(1:langname(id)),av_a(id),cv(id)
        write (iout,2078) angname(id)(1:langname(id)),av_a(id),cv(id)
      end do
      do irdat=1,nrdat
        id=irescolf+(irdat-1)/2
        ic=mod(irdat-1,2)+1
        sum=0.d0
        sum2=0.d0
        do i=1,nframe
          sum=sum+res(ic,i,incrres+id)
          sum2=sum2+res(ic,i,incrres+id)**2
        end do
        av_r(irdat)=sum/nframe
        sd_r(irdat)=dsqrt(dabs(sum2/nframe-av_r(irdat)**2))
        if (now6 .eq. 0) write (6,2077) rname(irdat)(1:lrname(irdat)),
     -    av_r(irdat),sd_r(irdat)
        write (iout,2077)
     -    rname(irdat)(1:lrname(irdat)),av_r(irdat),sd_r(irdat)
      end do
      if (nocorr .eq. 0) then
        if (ndials .gt. 0) then
c         Calculate Fisher & Lee circular correlation coefficient between angles
          if (ndials .le. 10 .and. now6 .eq. 0) write (6,2001)
          write (iout,2001)
          do id=1,ndials
            do jd=id+1,ndials
              sinsum_ab=0.d0
              sinsum2_a=0.d0
              sinsum2_b=0.d0
              corrsum=0.d0
              do i=1,nframe
                ang_ai=dacoscheck(ddd,res(1,i,incrres+id),0,6,
     -            'TRAJSTAT')
                if (res(2,i,incrres+id) .lt. 0.0) ang_ai=-ang_ai
                ang_bi=dacoscheck(ddd,res(1,i,incrres+jd),0,6,
     -            'TRAJSTAT')
                if (res(2,i,incrres+jd) .lt. 0.0) ang_bi=-ang_bi
                corrsum=corrsum+ang_ai*ang_bi
                do j=i+1,nframe
                  ang_aj=dacoscheck(ddd,res(1,j,incrres+id),0,6,
     -              'TRAJSTAT')
                  if (res(2,j,incrres+id) .lt. 0.0) ang_aj=-ang_aj
                  ang_bj=dacoscheck(ddd,res(1,j,incrres+jd),0,6,
     -              'TRAJSTAT')
                  if (res(2,j,incrres+jd) .lt. 0.0) ang_bj=-ang_bj
                  sin_aij=dsin(ang_ai-ang_aj)
                  sin_bij=dsin(ang_bi-ang_bj)
                  sinsum_ab=sinsum_ab+sin_aij*sin_bij
                  sinsum2_a=sinsum2_a+sin_aij**2
                  sinsum2_b=sinsum2_b+sin_bij**2
                end do
              end do
              corrsum=corrsum*radtodeg**2
              ccorr=(sinsum_ab)/dsqrt(sinsum2_a*sinsum2_b)
              if (ndials .le. 10 .and. now6 .eq. 0)
     -          write (6,2000) angname(id)(1:langname(id)),
     -            angname(jd)(1:langname(jd)),ccorr
              write (iout,2000) angname(id)(1:langname(id)),
     -          angname(jd)(1:langname(jd)),ccorr
            end do
          end do
        end if
        if (nrdat .gt. 0) then
c         Calculate standard correlation coefficient between regular data
          if (now6 .eq. 0) write (6,2002) ' '
          write (iout,2002) ' '
          do irdat=1,nrdat
            id=irescolf+(irdat-1)/2
            ic=mod(irdat-1,2)+1
            do jrdat=irdat+1,nrdat
              jd=irescolf+(jrdat-1)/2
              jc=mod(jrdat-1,2)+1
              call correl(iout,res(1,1,incrres+id),ic,
     -          rname(irdat),lrname(irdat),av_r(irdat),sd_r(irdat),
     -          res(1,1,incrres+jd),jc,rname(jrdat),lrname(jrdat),
     -          av_r(jrdat),sd_r(jrdat),corr,nframe,0,now6)
              if (irdat .eq. 1 .and. jrdat .eq. 2) corr12=corr
            end do
          end do
        end if
        if (ndials*nrdat .gt. 0) then
c         Calculate linear-circular correlation coefficient between
c         angles and regular data (Mardia)
          if (ndials .le. 10 .and. now6 .eq. 0) write (6,2003)
          write (iout,2003)
          do id=1,ndials
            do jrdat=1,nrdat
              corrsum=0.d0
              jd=irescolf+(jrdat-1)/2
              jc=mod(jrdat-1,2)+1
              sinsum=0.d0
              sinsum2=0.d0
              cossum=0.d0
              cossum2=0.d0
              crc=0.d0
              crs=0.d0
              csc=0.d0
              do i=1,nframe
                ang_ai=dacoscheck(ddd,res(1,i,incrres+id),0,6,
     -            'TRAJSTAT')
                if (res(2,i,incrres+id) .lt. 0.0) ang_ai=-ang_ai
                c=res(1,i,incrres+id)
                s=res(2,i,incrres+id)
                x=res(jc,i,incrres+jd)
                crc=crc+x*c
                crs=crs+x*s
                csc=csc+s*c
                sinsum=sinsum+s
                cossum=cossum+c
                sinsum2=sinsum2+s**2
                cossum2=cossum2+c**2
                corrsum=corrsum+ang_ai*x
              end do
              corrsum=corrsum*radtodeg
              cav=cossum/nframe
              sav=sinsum/nframe
              csd=(cossum2/nframe-cav**2)
              ssd=(sinsum2/nframe-sav**2)
              if (csd .gt. 0.d0 .and. ssd .gt. 0.d0) then
                csd=dsqrt(csd)
                ssd=dsqrt(ssd)
                r12=(crc/nframe-cav*av_r(jrdat))/(csd*sd_r(jrdat))
                r13=(crs/nframe-sav*av_r(jrdat))/(ssd*sd_r(jrdat))
                r23=(csc/nframe-sav*cav)/(csd*ssd)
                ccorr=(r12**2+r13**2-2.0*r12*r13*r23)/(1-r23**2)
              else
                ccorr=0.0
              end if
              if (ndials .le. 10 .and. now6 .eq. 0)
     -          write (6,2000) angname(id)(1:langname(id)),
     -            rname(jrdat)(1:lrname(jrdat)),ccorr
              write (iout,2000) angname(id)(1:langname(id)),
     -          rname(jrdat)(1:lrname(jrdat)),ccorr
            end do
          end do
        end if
      end if
      return
2000  format(1x,a,' - ',a25,' ccc=',f8.5)
2001  format(' ccc: Circular correlation coefficient (Fisher & Lee)')
2002  format(/,a,'Pearson correlation coefficient')
2003  format(' ccc: Linear-circular correlation coefficient (Mardia)')
2004  format(' PROGRAM ERROR: argument maxdials of subroutine trajstat',
     -  ' exceeds',/,' the parameter MAXCOPY (',i4,' vs ',i4,')')
2077  format(1x,a,' average=',f10.2,' S.D.=',f8.2,a,'CV=',f8.5)
2078  format(1x,a,' average=',f10.2,' CV=',f8.5)
      end
      subroutine volcalc(nrand,c,na,isegno,ian,nsegslt,rcellno,rvdw,
     -  rvdwsolv2,rvdwsolv,rvdwsolv22,vmac,vshell,vint,vmacsd,vshellsd,
     -  vintsd,vfrstsh,vfrstshsd,rsolv,ixcell,index,ifirst,ilast,itemp,
     -  nconfig,iout,levout,maxrec)
c     Perform the Monte Carlo estimate of ligand and interfacial volumes
      dimension c(3,na),isegno(na),ian(na),rvdw(na),rcellno(na),
     -  rvdwsolv2(na),rvdwsolv(na),rvdwsolv22(na),ixcell(na),
     -  index(maxrec),ifirst(maxrec),ilast(maxrec),itemp(maxrec)
      parameter (MAXINTVOL=10)
      dimension corner(3),edge(3),rand(3),r(3),ri(3),rj(3),
     -  ecell(3),rvdwan(99),rijexmn(1000),
     -  rij2mnmx(1000),iamn(1000),ing(MAXINTVOL),
     -  nintij(MAXINTVOL,MAXINTVOL),nxyz(3),ixyz(3)
      character*80 line
      data rvdwan /1.2,4*0.0,2.0,1.5,1.4,1.35,5*0.0,1.9,1.85,1.8,
     -  17*0.0,1.95,64*0.0/
      rsolv2=2.0*rsolv
      rvdwmax=2.0
      padding=rvdwmax+rsolv
      spacing=rvdwmax+2.0*rsolv
      call cellpart(c,ian,rvdwsolv,na,padding,spacing,corner,ecell,
     -  edge,vtot,nxyz,ixyz,rcellno,itemp,index,ifirst,ilast,ntotcell,
     -  levout,iout,maxrec)
c     Get a list of filled cells
      ncell=0
      do ic=1,ntotcell
        if (ifirst(ic) .ne. 0) then
          ncell=ncell+1
          ixcell(ncell)=ic
        end if
      end do
c     Mark neighbors of filled cells
      call zeroiti(itemp,0,ntotcell)
      do ic=1,ncell
        icell=ixcell(ic)-1
        ixyz(1)=mod(icell,nxyz(1))
        icell=(icell-ixyz(1))/nxyz(1)
        ixyz(2)=mod(icell,nxyz(2))
        ixyz(3)=(icell-ixyz(2))/nxyz(2)
        do ix=max0(0,ixyz(1)-1),min0(nxyz(1)-1,ixyz(1)+1)
          do iy=max0(0,ixyz(2)-1),min0(nxyz(2)-1,ixyz(2)+1)
            do iz=max0(0,ixyz(3)-1),min0(nxyz(3)-1,ixyz(3)+1)
              icng=1+ix+nxyz(1)*iy+nxyz(1)*nxyz(2)*iz
              itemp(icng)=1
            end do
          end do
        end do
      end do
      nrancell=0
      do ic=1,ntotcell
        if (itemp(ic) .gt. 0) then
          nrancell=nrancell+1
          itemp(nrancell)=ic
        end if
      end do
      if (nconfig .lt. 2) then
        write (iout,1003) ecell,ntotcell,ncell,nrancell,rsolv2
        write (6,1003) ecell,ntotcell,ncell,nrancell,rsolv2
        if (nsegslt .gt.  MAXINTVOL)  then
          write (iout,1005) nsegslt,MAXINTVOL
          write (6,1005) nsegslt,MAXINTVOL
        end if
      end if
      if (levout .gt. 0) write (iout,7000) nxyz,ntotcell,nrancell,ncell
      do ia=1,na
        rvdw(ia)=rvdwan(ian(ia))
        rvdwsolv(ia)=rvdw(ia)+rsolv
        rvdwsolv2(ia)=(rvdw(ia)+rsolv)**2
        rvdwsolv22(ia)=(rvdw(ia)+2.0*rsolv)**2
        if (levout .gt. 4)
     -    write (iout,7001) ia,ian(ia),rvdw(ia),isegno(ia)
      end do
      nmac=0
      nshell=0
      nfrstsh=0
      nint=0
      nmacprev=0
      nshellprev=0
      nfrstshprev=0
      nintprev=0
      nrandprev=0
      vmacsm=0.0
      vshellsm=0.0
      vfrstshsm=0.0
      vintsm=0.0
      vmacsm2=0.0
      vshellsm2=0.0
      vfrstshsm2=0.0
      vintsm2=0.0
      if (nsegslt .le. MAXINTVOL) call zeroiti(nintij,0,MAXINTVOL**2)
      nrand10=max0(1,nrand/10)
      do ir=1,nrand
        call randpx(3,rand)
        do ic=1,nrancell
          icell=itemp(ic)-1
c         Shift random copy to cell icell and examine just its neighbor cells
c         Deconvolute icell
          ixyz(1)=mod(icell,nxyz(1))
          icell=(icell-ixyz(1))/nxyz(1)
          ixyz(2)=mod(icell,nxyz(2))
          ixyz(3)=(icell-ixyz(2))/nxyz(2)
          if (levout .gt. 3) write (iout,7003) ir,ic,icell,ixyz
          do k=1,3
            r(k)=corner(k)+(ixyz(k)+rand(k))*ecell(k)
          end do
          do im=1,nsegslt
            rijexmn(im)=100000.0
            rij2mnmx(im)=100000.0
          end do
          call zeroiti(iamn,0,nsegslt)
          do ix=max0(0,ixyz(1)-1),min0(nxyz(1)-1,ixyz(1)+1)
            do iy=max0(0,ixyz(2)-1),min0(nxyz(2)-1,ixyz(2)+1)
              do iz=max0(0,ixyz(3)-1),min0(nxyz(3)-1,ixyz(3)+1)
                icn=1+ix+nxyz(1)*iy+nxyz(1)*nxyz(2)*iz
                if (ifirst(icn) .gt. 0) then
c                 Cell is not empty
                  do iaa=ifirst(icn),ilast(icn)
                    ia=index(iaa)
                    rij2=dist2(r,c(1,ia))
                    if (levout .gt. 4)
     -                write (iout,7004) iaa,ia,ix,iy,iz,icn,rij2
                    im=isegno(ia)
                    if (rij2 .lt. rij2mnmx(im)) then
                      rijex=sqrt(rij2)-rvdw(ia)
                      if (rijex .lt. rijexmn(im)) then
                        rijexmn(im)=rijex
                        rij2mnmx(im)=(rvdwmax+rijex)**2
                        iamn(im)=ia
                      end if
                    end if
                  end do
                end if
              end do
            end do
          end do
          nng=0
          rijexmin=10000.0
          do im=1,nsegslt
            if (iamn(im) .gt. 0) then
              if (rijexmn(im) .lt. rijexmin) then
                rijexmin=rijexmn(im)
                iamin=iamn(im)
              end if
              rij2mnmx(im)=(rvdw(iamn(im))+rijexmn(im))**2
            end if
c           Check if potential interface neighbor
            if (iamn(im) .gt. 0) then
              if (rij2mnmx(im) .le. rvdwsolv22(iamn(im))) then
                nng=nng+1
                ing(nng)=im
              end if
            end if
          end do
          if (rijexmin .le. 0.0) then
c           Inside solute's vdW region
            nmac=nmac+1
          else if (rijexmin .le. rsolv) then
c           Within solvent-excluded shell
            nshell=nshell+1
            if (levout .eq. 2) then
              call blankout(line,1,80)
              line(1:4)='ATOM'
              line(22:22)='S'
              line(13:16)='He  '
              line(18:20)='SHL'
              write (line(7:11),2004) nshell
              write (line(23:26),2003) 1
              write (line(31:54),2002) r
              write (line(55:60),2001) 1.0
              write (line(61:66),2001) 0.0
              write (77,2000) line(1:80)
            end if
          else if (rijexmin .le. rsolv2) then
c           Within first solvation shell
            nfrstsh=nfrstsh+1
          end if
          if (nng .gt. 1) then
c           Possible interface
            nrint=0
            do in=1,nng
              ia=iamn(ing(in))
              do jn=1,in-1
                ja=iamn(ing(jn))
                ijint=0
                if (rij2mnmx(in) .lt. rvdwsolv2(ia) .and.
     -              rij2mnmx(jn) .lt. rvdwsolv2(ja)) then
                  ijint=1
                else
                  rij2=dist2(c(1,ia),c(1,ja))
                  if (rij2 .le. (rvdwsolv(ia)+rvdwsolv(ja))**2) then
c                   Calculate the scalar product
                    rijsum=0.0
                    do k=1,3
                      ri(k)=c(k,ia)-r(k)
                      rj(k)=c(k,ja)-r(k)
                      rijsum=rijsum+ri(k)*rj(k)
                    end do
                    ac=rijsum/sqrt(abs(rij2mnmx(in)*rij2mnmx(jn)))
c                   Calculate the scalar threshold value
                    acmax=(rvdwsolv2(ia)+rvdwsolv2(ja)-rij2)/
     -                (2.0*rvdwsolv(ia)*rvdwsolv(ja))
                    if (ac .le. acmax) ijint=1
                  end if
                end if
                if (ijint .eq. 1) then
                  nrint=nrint+1
                  if (nsegslt .le. MAXINTVOL)
     -              nintij(in,jn)=nintij(in,jn)+1
                end if
              end do
            end do
            if (nrint .gt. 0) then
              nint=nint+1
              if (levout .eq. 3) then
                call blankout(line,1,80)
                line(1:4)='ATOM'
                line(22:22)='I'
                line(13:16)='He  '
                line(18:20)='INT'
                write (line(7:11),2004) nint
                write (line(23:26),2003) 1
                write (line(31:54),2002) r
                write (line(55:60),2001) 1.0
                write (line(61:66),2001) 0.0
                write (77,2000) line(1:80)
              end if
            end if
          end if
        end do
        if (mod(ir,nrand10) .eq. 0) then
          if (nconfig .eq. 1 .and. ir+nrand10 .le. nrand) then
            vshell=vtot*float(nshell)/float(ntotcell*ir)
            vfrstsh=vtot*float(nshell+nfrstsh)/float(ntotcell*ir)
            vmac=vtot*float(nmac)/float(ntotcell*ir)
            vint=vtot*float(nint)/float(ntotcell*ir)
            write (iout,1000) ir,vmac,vshell,vfrstsh,vint
          end if
          rndiff=float(ntotcell*(ir-nrandprev))
          vm10=vtot*float(nmac-nmacprev)/rndiff
          vmacsm=vmacsm+vm10
          vmacsm2=vmacsm2+vm10**2
          vs10=vtot*float(nshell-nshellprev)/rndiff
          vshellsm=vshellsm+vs10
          vshellsm2=vshellsm2+vs10**2
          vf10=vtot*float((nshell+nfrstsh)-(nshellprev+nfrstshprev))/
     -      rndiff
          vfrstshsm=vfrstshsm+vf10
          vfrstshsm2=vfrstshsm2+vf10**2
          vi10=vtot*float(nint-nintprev)/rndiff
          vintsm=vintsm+vi10
          vintsm2=vintsm2+vi10**2
          nmacprev=nmac
          nshellprev=nshell
          nfrstshprev=nfrstsh
          nintprev=nint
          nrandprev=ir
        end if
      end do
      vshell=vtot*float(nshell)/float(ntotcell*nrand)
      vfrstsh=vtot*float(nshell+nfrstsh)/float(ntotcell*nrand)
      vmac=vtot*float(nmac)/float(ntotcell*nrand)
      vint=vtot*float(nint)/float(ntotcell*nrand)
      vmacsd=sqrt(abs(vmacsm2/10.0-(vmacsm/10.0)**2)/9.0)
      vshellsd=sqrt(abs(vshellsm2/10.0-(vshellsm/10.0)**2)/9.0)
      vfrstshsd=sqrt(abs(vfrstshsm2/10.0-(vfrstshsm/10.0)**2)/9.0)
      vintsd=sqrt(abs(vintsm2/10.0-(vintsm/10.0)**2)/9.0)
      write (iout,1000) nrand,vmac,vshell,vfrstsh,vint,' ',
     -  vmacsd,vshellsd,vfrstshsd,vintsd
      if (nsegslt .le. MAXINTVOL .and. nsegslt .gt. 2) then
        write (iout,1001) (in,in=1,nsegslt)
        do in=1,nsegslt
          write (iout,1002) in,
     -      (vtot*float(nintij(in,jn))/float(ntotcell*nrand),jn=1,in)
        end do
      end if
      return
1000  format(' Nr=',i7,' Vslt=',f10.1,' Vxsh=',f9.1,' Vfsh=',f9.1,
     -  ' Vint=',f9.1,' A**2',a,/,
     -  11x,'   SD=',f10.1,'   SD=',f9.1,'   SD=',f9.1,'   SD=',f9.1)
1001  format(' Interface volume between solute molecules',/,
     -  3x,10i7)
1002  format(i3,10f7.1)
1003  format(' Copies of random points will be placed in ',
     -  'rectangles of dimension',/,f10.5,2(' * ',f10.5),' A**3',/,
     -  ' There are',i6,' such cells',i5,' of them contains solute',/,
     -  ' Translated copies will be placed into all occupied cells and',
     -  ' its neighbors,',/,' a total of',i6,' cells',
     -  ' Nr: result for Nr random numbers',/
     -  ' Vslt: estimate of solute volume (in A^3)',/,
     -  ' Vxsh: estimate of solvent-excludes shell volume (in A^3)',/,
     -  ' Vfsh: estimate of first solvation shell volume (in A^3)',/,
     -  '       shell thickness=',f5.2,' A',/,
     -  ' Vint: estimate of the interface volume volume (in A^3)',/)
1005  format(' NOTE: The number of solute molecules (',i5,') exceeds',
     -  i4,/,' - pairwise interface volumes will not be calculated')
2000  format(a)
2001  format(f6.3)
2002  format(3f8.3)
2003  format(i4)
2004  format(i5)
7000  format(' nyxz=',3i3,' ntotcell=',i4,' nrancell=',i4,' ncell=',i4)
7001  format(' ia,ian=',2i4,' rvdw(ia)=',f8.2,'isegno=',i4)
7003  format(' ir,ic,icell=',3i5,' ixyz=',3i3)
7004  format(' iaa,ia=',2i5,' ixyz=',3i3,' icn=',i5,' rij2=',e12.5)
      end
      subroutine summarize_amber(inpt,iout,ixr1,ixr2,col1,col2,
     -  ifres,ilres,resnames,lresname,tabcolsum,tabrowsum,ixcol,ixrow,
     -  mxrsd,mxrec)
      dimension ixr1(mxrec),ixr2(mxrec),col1(mxrec),col2(mxrec),
     -  ifres(mxrec),ilres(mxrec),tabcolsum(mxrec),
     -  tabrowsum(mxrec),ixcol(mxrec),ixrow(mxrec)
      character*8 resnames(mxrsd)
      character*1000 line
      character*47 question
      parameter (MAXREC=200000,MAXPHI=400)
      parameter (MAXCOL=36)
      parameter (MAXCOL1000=MAXCOL*1000)
      character*10 title(MAXCOL),label(4),seg
      dimension colsum(MAXCOL)
      character*1 minmaxlab(MAXCOL,1000)
      parameter (IFILL7=MAXPHI*MAXPHI*MAXPHI-2*MAXCOL*MAXREC)
      common /nnwork/ data(MAXCOL,MAXREC),err(MAXCOL,MAXREC),
     -  ifill(IFILL7)
      dimension rmin(MAXCOL),rmax(MAXCOL),irmin(MAXCOL),irmax(MAXCOL),
     -  ltitle(MAXCOL),llabel(4),ixprint(MAXCOL)
      data ires /0/,minmaxlab /MAXCOL1000*' '/
      data label /'COMPLEX','RECEPTOR','LIGAND','DELTA'/
      data llabel /7,8,6,5/,iresrow1p /0/,iresrow2p /0/,irescol1p /0/,
     -  irescol2p /0/
      write (iout,2000)
      read (inpt,*)
c     Gather the data from the statistics file
      call checklabel(line,label(1),llabel(1),inpt)
      read (inpt,*)
      call blankout(line,1,1000)
      read (inpt,1000) line
      ic=1
      ncol=0
      ipairs=0
      ierr=0
      call lastchar(line,lc,1000)
c     write (77,*) 'TITLES (?)',line(1:lc)
      do while (ic .lt. 1000 .and. ncol .lt. MAXCOL)
        call nextchar(line,ic,1000)
        ic1=ic
        call nextblank(line,ic,1000)
        ic2=ic
        if (ic2 .lt. 1000) then
          if (line(ic1:ic2-1) .eq. '->') then
            ipairs=1
          else
            ncol=ncol+1
c           write (77,*) 'ic1,2=',ic1,ic2,' ncol=',ncol
            title(ncol)(1:ic2-ic1)=line(ic1:ic2-1)
            ltitle(ncol)=ic2-ic1
c           write (77,*) ' TITLE:',title(ncol)(1:ic2-ic1)
          end if
        end if
      end do
      if (ipairs .eq. 0) print *,'Residue-molecule data found'
      if (ipairs .eq. 1) print *,'Residue-residue data found'
      call findindex(seg,lseg,
     -  'Data [COMPLEX/RECEPTOR/LIGAND/DELTA (default)] to tabulate',58,
     -  label,llabel,4,nc,10,0)
      if (lseg .lt. 1) nc=4
      do ic=1,nc
        if (ic .gt. 1) then
          call checklabel(line,label(ic),llabel(ic),inpt)
          read (inpt,*)
c         write (77,*) 'Line1:',line(1:20)
          read (inpt,*) line
c         write (77,*) 'Line2:',line(1:50)
        end if
        call read_amb_data(data(1,1),err(1,1),ncol,ixr1,ixr2,nresdat,
     -    ipairs,inpt,MAXCOL,MAXREC)
        print *,label(ic)(1:llabel(ic)),' read'
      end do
      print *,'Number of properties to tabulate:',ncol
      if (ipairs .eq. 0) then
        print *,'Number of residues read=',nresdat
        nres=nresdat
      else
        print *,'Number of residue pairs read=',nresdat
        nrespair=nresdat
        do ir=1,nresdat
          ifres(ir)=0
          ilres(ir)=0
        end do
        iresprev=0
        nres=0
        do ir=1,nresdat
          ires=ixr1(ir)
          if (ires .ne. iresprev) then
            nres=nres+1
            ifres(nres)=ir
            if (nres .gt. 1) ilres(nres-1)=ir-1
            iresprev=ires
          end if
        end do
        ilres(nres)=nrespair
c        write (77,*) 'nresdat,nrespair,nres=',nresdat,nrespair,nres
c        do ir=1,nres
c          write (77,8811) ir,ifres(ir),ilres(ir),ixr1(ifres(ir))
c8811      format(' ir=',i5,' ifres,ilres=',2i7,' ixr1=',i5)
c          if (ilres(ir)-ifres(ir) .ne. ilres(1)-ifres(1)) print *,
c     -      'ERROR: row range changed'
c          do jr=1,nres
c            if (ixr2(ifres(ir)-1+jr) .ne. ixr2(jr))print *,'ix2 ERROR:',
c     -        ' jr=',jr,' ix2(1),ix2(jr)=',
c     -          ixr2(ifres(ir)-1+jr),ixr2(jr)
c          end do
c        end do
      end if
      do while (.true.)
        ncolp=0
        write (6,2005)
        print *,'Hit return to close list'
        do while (.true.)
201       call findindex(seg,lseg,
     -      'Name of the property column to tabulate',39,title,ltitle,
     -      ncol,nd,10,116)
          if (nd .eq. 0) then
            if (ncolp .eq. 0) then
              print *,'WARNING: Nothing selected'
              call  askyn('OK',2,1,-1,iok,0)
              if (iok .eq. 1) return
              go to 201
            end if
            write (6,2001) (title(ixprint(ip))(1:ltitle(ixprint(ip))),
     -        ip=1,ncolp)
            call  askyn('OK',2,1,+1,iok,0)
            if (iok .eq. 0) go to 201
            go to 200
          end if
          ncolp=ncolp+1
          ixprint(ncolp)=nd
        end do
      end do
c     if (ncolp .gt. 1 .or. ipairs .eq. 0) then
200   write (iout,2004)
      call  askyn('Do you want to tabulate the errors too',38,1,-1,
     -  ierr,0)
      call  askyn('Do you want to mark with m and M the extreme values',
     -  51,1,-1,mark,117)
c     end if
      write (iout,2002) label(nc)(1:llabel(nc))
      if (ipairs .eq. 0) then
        if (mark .eq. 1) then
c         Establish min and max
          do ip=1,ncolp
            rmin(ip)=data(ixprint(ip),1)
            rmax(ip)=data(ixprint(ip),1)
            irmin(ip)=1
            irmax(ip)=1
            minmaxlab(ip,1)=' '
          end do
          do ir=2,nres
            do ip=1,ncolp
              r=data(ixprint(ip),ir)
              if (r .gt. rmax(ip)) then
                rmax(ip)=r
                irmax(ip)=ir
              else if (r .lt. rmin(ip)) then
                rmin(ip)=r
                irmin(ip)=ir
              end if
              minmaxlab(ip,ir)=' '
            end do
          end do
          do ip=1,ncolp
            minmaxlab(ip,irmin(ip))='m'
            minmaxlab(ip,irmax(ip))='M'
          end do
        end if
        if (ierr .eq. 0 .or. ncolp .gt. 4)
     -    write (iout,1001)
     -     (title(ixprint(ip))(1:ltitle(ixprint(ip))),ip=1,ncolp)
        if (ierr .eq. 0) then
          do ir=1,nres
            write (iout,1002) ixr1(ir),resnames(ixr1(ir))(1:lresname),
     -        (data(ixprint(ip),ir),minmaxlab(ip,ir),ip=1,ncolp)
            end do
        else
          if (ncolp .gt. 4) then
            do ir=1,nres
              write (iout,1002) ixr1(ir),resnames(ixr1(ir))(1:lresname),
     -          (data(ixprint(ip),ir),minmaxlab(ip,ir),ip=1,ncolp)
              write (iout,1007) ixr1(ir),'sd:',
     -          (err(ixprint(ip),ir),ip=1,ncolp)
            end do
          else
            write (iout,1004)
     -        (title(ixprint(ip))(1:ltitle(ixprint(ip))),ip=1,ncolp)
            do ir=1,nres
              write (iout,1003) ixr1(ir),resnames(ixr1(ir))(1:lresname),
     -          (data(ixprint(ip),ir),minmaxlab(ip,ir),
     -           err(ixprint(ip),ir),ip=1,ncolp)
            end do
          end if
        end if
      else
c       Pairs
        maxresno=ixr1(nresdat)
        if (ncolp .gt. 1) then
          call getrange(ires1,1,ires2,maxresno,incr,0,
     -      'reference residue number',24,maxresno,0)
          write (iout,1113) ires1,ires2
          call zeroit(colsum,ncolp)
          do ir=1,nres
            irp=ifres(ir)
            if (ixr1(irp) .ge. ires1 .and.  ixr1(irp) .le. ires2) then
c             Requested range found
              if (mark .eq. 1) then
c               Obtain the min/max labels for this residue
                do ip=1,ncolp
                  rmin(ip)=data(ixprint(ip),ir)
                  rmax(ip)=data(ixprint(ip),ir)
                  irmin(ip)=1
                  irmax(ip)=1
                  minmaxlab(ip,1)=' '
                end do
                do irr=irp,ilres(ir)
                  do ip=1,ncolp
                    r=data(ixprint(ip),irr)
                    if (r .gt. rmax(ip)) then
                      rmax(ip)=r
                      irmax(ip)=irr-irp+1
                    else if (r .lt. rmin(ip)) then
                      rmin(ip)=r
                      irmin(ip)=irr-irp+1
                    end if
                    minmaxlab(ip,irr-irp+1)=' '
                  end do
                end do
                do ip=1,ncolp
                  minmaxlab(ip,irmin(ip))='m'
                  minmaxlab(ip,irmax(ip))='M'
                end do
              end if
              ir0=irp-1
              call zeroit(colsum,ncolp)
              if (ierr .eq. 1) then
                write (iout,1104)
     -            (title(ixprint(ip))(1:ltitle(ixprint(ip))),ip=1,ncolp)
                do irp=ifres(ir),ilres(ir)
                  write (iout,1107)
     -              ixr1(irp),resnames(ixr1(irp))(1:lresname),
     -              ixr2(irp),resnames(ixr2(irp))(1:lresname),
     -              (data(ixprint(ip),irp),minmaxlab(ip,irp-ir0),
     -              err(ixprint(ip),irp),ip=1,ncolp)
                  do ip=1,ncolp
                    colsum(ip)=colsum(ip)+data(ixprint(ip),irp)
                  end do
                end do
                write (iout,1111) ixr1(ifres(ir)),
     -            (colsum(ip),ip=1,ncolp)
                write (iout,1111)
              else
                write (iout,1101)
     -            (title(ixprint(ip))(1:ltitle(ixprint(ip))),ip=1,ncolp)
                do irp=ifres(ir),ilres(ir)
                  write (iout,1102)
     -              ixr1(irp),resnames(ixr1(irp))(1:lresname),
     -              ixr2(irp),resnames(ixr2(irp))(1:lresname),
     -              (data(ixprint(ip),irp),minmaxlab(ip,irp-ir0),
     -              ip=1,ncolp)
                  do ip=1,ncolp
                    colsum(ip)=colsum(ip)+data(ixprint(ip),irp)
                  end do
                end do
                write (iout,1112) ixr1(ifres(ir)),
     -            (colsum(ip),ip=1,ncolp)
                write (iout,1112)
              end if
            end if
          end do
        else
c         Single property - print residue-residue matrix
          write (iout,1009) title(ixprint(1))(1:ltitle(ixprint(1)))
300       write (6,1011) 'rows'
          call getrange(iresrow1,1,iresrow2,maxresno,incr,0,
     -      'residue number',14,maxresno,0)
          write (6,1011) 'columns'
          call getrange(irescol1,1,irescol2,maxresno,incr,0,
     -      'residue number',14,maxresno,0)
          if ((irescol1 .ge. iresrow1 .and. irescol1 .le. iresrow2) .or.
     -       (irescol2 .ge. iresrow1 .and. irescol2 .le. iresrow2)) then
            print *,'Residue ranges overlap'
            call askyn('Do you want to change the ranges',32,1,1,ichng,
     -        0)
            if (ichng .eq. 1) go to 300
          end if
          do ir=1,nres
            if (ixr2(ir) .eq. iresrow1) iresrow1p=ir
            if (ixr2(ir) .eq. iresrow2) iresrow2p=ir
            if (ixr2(ir) .eq. irescol1) irescol1p=ir
            if (ixr2(ir) .eq. irescol2) irescol2p=ir
          end do
          if (irescol1p*irescol2p*iresrow1p*iresrow2 .eq. 0) then
            if (irescol1p .eq. 0) write (6,1015) irescol1
            if (irescol2p .eq. 0) write (6,1015) irescol2
            if (iresrow1p .eq. 0) write (6,1015) iresrow1
            if (iresrow2p .eq. 0) write (6,1015) iresrow2
            go to 300
          end if
          ntabcol=irescol2p-irescol1p+1
          ntabrow=iresrow2p-iresrow1p+1
c         write (6,*) 'irescol1,irescol2,iresrow1,iresrow2=',
c    -             irescol1,irescol2,iresrow1,iresrow2
c         write (6,*) 'irescol1p,irescol2p,iresrow1p,iresrow2p=',
c    -             irescol1p,irescol2p,iresrow1p,iresrow2p
c         write (6,*) 'nres,ntabcol,ntabrow=',nres,ntabcol,ntabrow
          if (ntabcol .gt. ntabrow) then
           print *,'Number of columns is larger than the number of rows'
            call askyn('Do you want to change the ranges',32,1,1,ichng,
     -        0)
            if (ichng .eq. 1) go to 300
          end if
          do ir=1,ntabcol
            ixcol(ir)=irescol1p-1+ir
          end do
          do ir=1,ntabrow
            ixrow(ir)=iresrow1p-1+ir
          end do
c          write (6,7711) 'ixr1:',(ixr1(ii),ii=1,nres)
c          write (6,7711) 'ixr2:',(ixr2(ii),ii=1,nres)
c          write (6,7711) 'ixrow:',(ixrow(ii),ii=1,ntabrow)
c          write (6,7711) 'ixcol:',(ixcol(ii),ii=1,ntabcol)
c7711      format(1x,a,/(20i4))
302       call zeroit(tabcolsum,ntabcol)
          call zeroit(tabrowsum,ntabrow)
          do irr=1,ntabrow
            if0=ifres(ixrow(irr))-1
            do irc=1,ntabcol
              tabcolsum(irc)=tabcolsum(irc)+
     -          data(ixprint(1),if0+ixcol(irc))
              tabrowsum(irr)=tabrowsum(irr)+
     -          data(ixprint(1),if0+ixcol(irc))
            end do
          end do
          write (iout,1012) (ixr2(irc),resnames(ixr2(irc))(1:lresname),
     -      irc=irescol1p,irescol2p),0,'SUM'
          write (iout,1013) ('-----------',irc=1,ntabcol+1)
          do irr=1,ntabrow
            if0=ifres(ixrow(irr))-1
            write (iout,1014)
     -        ixr2(ixrow(irr)),resnames(ixr2(ixrow(irr)))(1:lresname),
     -        '|',(data(ixprint(1),if0+ixcol(irc)),irc=1,ntabcol),
     -        tabrowsum(irr)
            if (ierr .gt. 0) write (iout,1016)
     -        '|',(err(ixprint(1),if0+ixcol(irc)),irc=1,ntabcol)
          end do
          write (iout,1013) ('-----------',irc=1,ntabcol+1)
          write (iout,1014) 0,'SUM',':',(tabcolsum(i),i=1,ntabcol)
          call askyn('Do you want to tabulate an other property',41,
     -      1,-1,more,0)
          if (more .eq. 1) then
303         call findindex(seg,lseg,
     -        'Name of the property column to tabulate',39,title,ltitle,
     -         ncol,nd,10,116)
            if (nd .eq. 0) go to 303
            ixprint(1)=nd
            write (iout,*)
            write (iout,1009) title(ixprint(1))(1:ltitle(ixprint(1)))
            go to 302
          end if
        end if
      end if
      call  askyn('Do you want to calculate correlations',37,1,-1,
     -  icorr,0)
      ncorrcalc=0
      if (icorr .gt. 0) then
        print *,'NOTE: correlation calculation is NOT limited to the ',
     -    'properties tabulated'
        itypedone=0
        ntypepairs=0
        do while (itypedone .eq. 0)
          if (ntypepairs .gt. 0)
     -     print *,'Hit enter to exit)'
          ntypepairs=ntypepairs+1
          call findindex(seg,lseg,'Name of the first property',26,
     -      title,ltitle,ncol,ic1,10,116)
          if (ic1 .eq. 0) then
            itypedone=1
          else
            call findindex(seg,lseg,
     -        'Data name of the second property',32,title,ltitle,
     -        ncol,ic2,10,116)
            if (ipairs .gt. 0) then
              question='Reference residue number of the first  property'
              call getint(question,47,1,1,nres,ir1,00)
              question(33:38)='second'
              call getint(question,47,nres,1,nres,ir2,00)
            end if
            s12=0.0
            s1=0.0
            s2=0.0
            ss1=0.0
            ss2=0.0
            if (ipairs .eq. 0) then
              do i=1,nres
                s12=s12+data(ic1,i)*data(ic2,i)
                s1=s1+data(ic1,i)
                s2=s2+data(ic2,i)
                ss1=ss1+data(ic1,i)**2
                ss2=ss2+data(ic2,i)**2
              end do
              corr=(s12-s1*s2/nres)/
     -          sqrt((ss1-s1**2/nres)*(ss2-s2**2/nres))
              write (6,1005)
     -          title(ic1)(1:ltitle(ic1)),label(nc)(1:llabel(nc)),
     -          title(ic2)(1:ltitle(ic2)),label(nc)(1:llabel(nc)),
     -          corr
              write (iout,1005)
     -          title(ic1)(1:ltitle(ic1)),label(nc)(1:llabel(nc)),
     -          title(ic2)(1:ltitle(ic2)),label(nc)(1:llabel(nc)),
     -          corr
            else
              do i=ifres(ir1),ilres(ir1)
                col1(i-ifres(ir1)+1)=data(ic1,i)
              end do
              do i=ifres(ir2),ilres(ir2)
                col2(i-ifres(ir2)+1)=data(ic2,i)
              end do
              if (ifres(ir1)-ilres(ir1) .ne.
     -            ifres(ir2)-ilres(ir2)) then
                print *,'Incompatible residue limits:',
     -            ifres(ir1),ilres(ir1),ifres(ir2),ilres(ir2)
                stop
              end if
              nrows=ilres(ir1)-ifres(ir1)+1
              do i=1,nrows
                s12=s12+col1(i)*col2(i)
                s1=s1+col1(i)
                s2=s2+col2(i)
                ss1=ss1+col1(i)**2
                ss2=ss2+col2(i)**2
              end do
              corr=(s12-s1*s2/nrows)/
     -          sqrt((ss1-s1**2/nrows)*(ss2-s2**2/nrows))
              write (6,1010)
     -          title(ic1)(1:ltitle(ic1)),label(nc)(1:llabel(nc)),
     -          ir1,title(ic2)(2:ltitle(ic2)),
     -          label(nc)(1:llabel(nc)),ir2,corr
              write (iout,1010)
     -          title(ic1)(1:ltitle(ic1)),label(nc)(1:llabel(nc)),
     -          ir1,title(ic2)(2:ltitle(ic2)),
     -          label(nc)(1:llabel(nc)),ir2,corr
            end if
          end if
        end do
      end if
      stop
1000  format(a)
1001  format('  Residue',20a10)
1002  format(i5,1x,a3,20(f9.2,a1))
1003  format(i5,1x,a3,4(f9.2,a1,f7.2))
1004  format('  Residue',4(a10,'    +/-'))
1005  format(' Correlation between ',a,'(',a,') and ',a,'(',a,')=',f6.4)
1007  format(i5,1x,a3,f9.2,19f10.2)
1009  format(' Residue-residue contribution table for property ',a,/)
1010  format(' Correlation between ',a,'(',a,', r:',i4,') and ',
     -  a,'(',a,', r:',i4,')=',f6.4)
1011  format(' Specify residue range for the table ',a)
1012  format(13x,1000(1x,i6,1x,a3))
1013  format(13x,1000(a))
1014  format(1x,i6,1x,a3,1x,a1,1000(f11.2))
1015  format(' ERROR: residue ',i6,' is not tabulated')
1016  format(8x,'SD: ',a1,1000(f11.2))
1101  format('  Residue - Residue',a9,19a10)
1102  format(i5,1x,a3,i6,1x,a3,20(f9.2,a1))
1104  format('  Residue - Residue',a9,'    +/-',19(a10,'    +/-'))
1107  format(i5,1x,a3,i6,1x,a3,20(f9.2,a1,f7.2))
1111  format(i5,' ---- SUM:   ',20(f10.2,7x))
1112  format(i5,' ---- SUM:   ',20f10.2)
1113  format(/,' Reference residue range to tabulate: [',i5,',',i5,']')
2000  format(/,' Customized tabulation of Amber residue analysis')
2001  format(' Column(s) to tabulate:',50a10)
2002  format(' Data type tabulated: ',a)
c2003  format(' A PDB file can be also read to provide residue names',/,
c     -  ' Residue numbers should correspond to the residue numbers ',
c     -  'read by mmpbsa.pl',/,
c     -  ' Hitting enter will skip reading/using residue names')
2004  format(' The minimum and maximum ',
     -  'values in each column are marked with m and M, resp.',/)
2005  format(' Single property data are printed as residue X residue',
     -  ' table',/,' Multiple property data are printed as ',
     -  'residue-residue X property table')
      end
      subroutine read_amb_data(data,err,ncol,ix1,ix2,nres,ipairs,inpt,
     -  mxcol,mxrec)
      dimension  data(mxcol,mxrec),err(mxcol,mxrec),ix1(mxrec),
     -  ix2(mxrec)
      character*1000 line
c     Read data from Amber energy analysis tables
      lc=1000
      nres=0
      ifdatcol=3+ipairs
      do while (lc .gt. 1)
        call blankout(line,1,1000)
        read (inpt,1000,end=999) line
        call lastchar(line,lc,1000)
        if (lc .gt. 1) then
          nres=nres+1
c         write (77,*) nres,line
          if (nres .gt. mxrec) then
            write (6,1001) mxrec
            stop
          end if
          ic=1
          call nextchar(line,ic,1000)
          call nextblank(line,ic,1000)
          call getnextint(line,ix1(nres),ic,1000)
          if (ipairs .gt. 0) then
c           Skip '->'
            call nextchar(line,ic,1000)
            call nextblank(line,ic,1000)
            call getnextint(line,ix2(nres),ic,1000)
c           write (77,*)' NR=',nres,' ix1=', ix1(nres),' ix2=',ix2(nres)
c           write (77,*) line
          end if
          do nc=ifdatcol,ncol
            call getnextreal(line,data(nc,nres),ic,1000)
c           print *,'ic=',ic,' data=',data(nc,nres)
            call getnextreal(line,err(nc,nres),ic,1000)
          end do
        end if
      end do
999   return
      stop
1000  format(a)
1001  format(' ERROR: Number of residue-residue records exceeds ',
     -  'the limit (',i9,')',/,8x,'Redimension with larger MAXREC (and',
     -  ' possibly, larger MAXPHI')
      end
      subroutine checklabel(line,label,llabel,inpt)
      character*1000 line
      character*10 label,labelread
      call blankout(line,1,80)
      read (inpt,1000) line
      call lastchar(line,ilc,80)
c     write (77,*) 'CHECKLABEL',line(1:ilc)
      llabelread=ilc-4
      labelread(1:llabelread)=line(5:ilc)
      if (labelread(1:llabelread) .ne. label(1:llabel)) then
        print *,'ERROR: incorrect data label:',labelread(1:llabelread),
     -    ' (instead of ',label(1:llabel),')'
        stop
      end if
      return
1000  format(a)
      end
      subroutine getnextint(line,int,ic,len)
      character*(*) line
      call nextchar(line,ic,len)
      ic1=ic
      call nextblank(line,ic,len)
      ic2=ic
      read (line(ic1:ic2-1),*,err=999) int
      return
999   print *,'Invalid integer:',line(ic1:ic2-1)
      stop
      end
      subroutine getnextreal(line,r,ic,len)
      character*(*) line
      call nextchar(line,ic,len)
      ic1=ic
      call nextblank(line,ic,len)
      ic2=ic
c     print *,'GETNEXTR ic1,ic2=',ic1,ic2
      read (line(ic1:ic2-1),*,err=999) r
      return
999   print *,'Invalid real:',line(ic1:ic2-1)
      stop
      end
      subroutine findindex(lab,llab,q,lq,list,llist,nlist,ix,maxlablen,
     -  ihelp)
      character*(*) q,lab,list(nlist)
      dimension llist(nlist)
      ix=0
110   call getname(lab,llab,q(1:lq),lq,maxlablen,ihelp)
c     print *,'FINDINDEX llab=',llab
      if (llab .le. 1) return
      do i=1,nlist
        if (lab(1:llab) .eq. list(i)(1:llist(i))) ix=i
      end do
      if (ix .eq. 0) then
        print *,'No match found for ',lab(1:llab)
        go to 110
      end if
      return
      end
      subroutine cellpart(c,ian,temp,na,padding,spacing,corner,ecell,
     -  edge,vtot,nxyz,ixyz,rcellno,itemp,index,ifirst,ilast,ntotcell,
     -  levout,iout,maxrec)
      dimension c(3,na),ian(na),temp(na),corner(3),cent(3),
     -  edge(3),ecell(3),nxyz(3),ixyz(3),rcellno(na),itemp(maxrec),
     -  index(maxrec),ifirst(maxrec),ilast(maxrec)
c     Partition the solute atoms into cells for fast distance calculation
      dimension xyzmin(3),xyzmax(3)
      call extension(c,ian,0,1,na,xyzmin,xyzmax,cent,0,0,v)
      do k=1,3
        edge(k)=xyzmax(k)-xyzmin(k)+2.0*padding
        corner(k)=xyzmin(k)-padding
        nxyz(k)=max0(1,int(edge(k)/spacing))
        ecell(k)=edge(k)/nxyz(k)
      end do
      ntotcell=nxyz(1)*nxyz(2)*nxyz(3)
      vtot=edge(1)*edge(2)*edge(3)
c     Establish the cell of each solute atom
      nha=0
      do ia=1,na
        if (ian(ia) .gt. 1) then
          do k=1,3
            ixyz(k)=(c(k,ia)-corner(k))/ecell(k)
          end do
          nha=nha+1
          rcellno(nha)=1+ixyz(1)+nxyz(1)*ixyz(2)+nxyz(1)*nxyz(2)*ixyz(3)
          index(nha)=ia
          if (levout .gt. 3) write (iout,7001) ia,nha,rcellno(nha),ixyz
        end if
      end do
      if (levout .gt. 2) write (iout,*) 'na,nha=',na,nha
      call mrgsrt(6,index,rcellno,nha,ifirst,ilast,itemp,temp,na)
      if (levout .gt. 3)
     -  write (iout,7002) (ia,rcellno(ia),index(ia),ia=1,nha)
      call zeroiti(ifirst,0,ntotcell)
c     Establish the limits of cells
      ia=1
      icell=rcellno(ia)
      ifirst(icell)=ia
      do while (ia .lt. nha)
        ia=ia+1
        if (rcellno(ia) .gt. float(icell)) then
          ilast(icell)=ia-1
          icell=rcellno(ia)
          ifirst(icell)=ia
        end if
      end do
      ilast(icell)=nha
      return
7001  format(i5,' nha=',i4, ' rcellno=',f8.1,' ixyz=',3i6)
7002  format(i5,' rcellno=',f8.1,' index=',i6)
      end
      subroutine dialps(iout,labdial,llabdial,title,ltitle,remark,
     -  lremark,nrdiv,ndials,ndprow,nframesaved,pi,ipspage,npspageinc,
     -  nfravgd,idincr,noopen,noclose)
      character*(*) labdial(ndials)
      character*80 title
      character*(*) remark
      dimension llabdial(ndials)
      parameter (MAXFRAMES=50000,MAXCOPY=600)
      common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
     -  increment,increment2,res(2,MAXFRAMES,MAXCOPY),
     -  x0(MAXCOPY),y0(MAXCOPY),nxselres,ixselres(MAXCOPY)
      character*200 trajnam,trajnam2
      common /trajname/ trajnam,trajnam2,ltrajnam,ltrajnam2
c     print *,'DIALPS idincr=',idincr
      if (ndials .eq. 0) return
      print *,'Drawing dials for ',nframesaved,' frames'
      nlt=min0(80,ltrajnam)
c     xm=500.0
      xm=550.0
      ym=650.0
      nddone=0
      if (ndprow .eq. 0) ndprow=xm/sqrt(xm*ym/float(ndials))+1
      edge=0.95*xm/ndprow
      maxrows=(ym-50.0)/(edge*1.2)
      maxrows=max0(1,maxrows)
      npages=(ndials-1)/(ndprow*maxrows)+1+npspageinc
      if (nfravgd .eq. 0)
     -  call getint('Number of snapshots to average in the dials',43,
     -    1,1,nframe,nfravgd,28)
      if (noopen .eq. 0) then
        call openps(iout,xm,ym,title(1:ltitle),ltitle,remark,lremark,
     -    trajnam,nlt,trajnam,0,npages,ipspage)
      else
        call plothead(iout,xm,ym,title,ltitle,remark,lremark,trajnam,
     -    nlt,trajnam,0)
      end if
      ym=ym-100
      if (nfravgd .gt. 1) then
        write (iout,1000) xm*0.04,ym*0.95,nfravgd
        ymfac=0.85
      else
        ymfac=0.88
      end if
      npage=0
      do while (nddone .lt. ndials)
        nddo=min0(ndials-nddone,ndprow*maxrows)
        call partwindow(xm,ym,ymfac,nddo,edge,x0,y0,nddone,ndprow,nrows)
        ipspage=ipspage+1
        write (iout,1003) ipspage
        ifirst=1
        ilast=0
        do id=nddone+1,nddone+nddo
          if (id .eq. nddone+nddo .or. mod(id,ndprow) .eq. 0) ilast=1
          call drawdial(iout,edge,nframesaved,nfravgd,id,labdial(id),
     -      llabdial(id),nrdiv,ndprow,ifirst,ilast,idincr,pi)
          ifirst=0
        end do
        nddone=nddone+nddo
        write (iout,*) 'showpage'
        if (nddone .lt. ndials) write (iout,*) '25 25 translate'
      end do
      if (noclose .eq. 0) close (iout)
      return
1000  format(2f6.1,' m',/,
     -  '(Plots were averaged over',i4,' frames) show')
1003  format('%%Page: 1 ',i4)
      end
      subroutine partwindow(xm,ym,ymfac,nd,edge,x0,y0,ndincr,ndprow,
     -  nrows)
      dimension x0(nd),y0(nd)
c     The window/page is xm by ym, (0,0) is the bottom left corner
c     The subroutine finds the upper left corners (x0(i),y0(i)) of nd cubes
c     that best fill the window/page
      y00=ym*ymfac
      nleft=nd
c     print *,'PARTWIN nd,ndprow=',nd,ndprow
      ndone=0
      nrows=0
      do while (nleft .gt. 0)
        ndo=min0(nleft,ndprow)
c       x00=(ndprow-ndo)*(xm-ndo*edge)/2.0
        x00=(xm-ndo*edge)/2.0
        do ir=1,ndo
          ndone=ndone+1
          x0(ndincr+ndone)=x00+(ir-1)*edge
          y0(ndincr+ndone)=y00
        end do
        nrows=nrows+1
        nleft=nleft-ndo
        y00=y00-edge*1.2
      end do
c     write (6,1000) xm,ym,edge,(i,x0(i),y0(i),i=1,nd)
      return
c1000  format(' xm=',f10.4,' ym=',f10.4,' edge=',f10.5,/,
c     -  i4,' x0=',f10.4,' y0=',f10.4)
      end
      subroutine drawdial(iout,edge,n,incr,idial,lab,llab,nrdiv,
     -  ndprow,ifirst,ilast,incrid,pi)
      character*(*) lab
      parameter (MAXFRAMES=50000,MAXCOPY=600)
      common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
     -  increment,increment2,res(2,MAXFRAMES,MAXCOPY),
     -  x0(MAXCOPY),y0(MAXCOPY),nxselres,ixselres(MAXCOPY)
      real*8 ddd,cosav,sinav
      data riprev /0.0/,angprev /0.0/
c     Draw a 'dial' into the square of edge edge, with upper left corner at
c     (x0,y0), title lab(1:llab)
c     print *,'DRAWDIAL incrid,llab=',incrid,llab
      ldown=10
      if (ndprow .gt. 4) ldown=8
      cx=x0(idial)+edge*0.50
      cy=y0(idial)-edge*0.50-ldown
      r=0.45*edge
      r0=0.04*edge
      r1=0.41*edge
      write (iout,*) 'np'
c     Print 0,90,180,270 marks
      lfont=10
      if (ndprow .gt. 4) lfont=8
      write (iout,1005) 'Symbol',lfont
      if (ndprow .lt. 4 .or. ilast .eq. 1) then
        write (iout,1000) cx+r+2.0,cy-2.0
        call psshow(iout,'0',1)
      end if
      write (iout,1000) cx-5.0,cy+r+3.0
      call psshow(iout,'p/2',3)
      if (ndprow .lt. 4 .or. ifirst .eq. 1) then
        write (iout,1000) cx-r-7.0,cy-2.0
        call psshow(iout,'p',1)
      end if
      write (iout,1000) cx-8.0,cy-r-10.0
      call psshow(iout,'3p/2',4)
      lfont=12
      if (ndprow .gt. 4) lfont=8
      write (iout,1005) 'Helvetica',lfont
      write (iout,1000) x0(idial)+5.0,y0(idial)
      call psshow(iout,lab,llab)
      write (iout,*) 'sk'
c     Draw the circle
      write (iout,*) 'np'
      write (iout,1000) cx+r,cy
      write (iout,1003) cx,cy,r,0.0,360.0
      if (nrdiv .gt. 1) then
        write (iout,*) 'sk'
        write (iout,*) '[2] 0 setdash'
        do ir=1,nrdiv-1
          write (iout,1003) cx,cy,r0+r1*float(ir)/float(nrdiv),
     -      0.0,360.0
        end do
      end if
      write (iout,*) 'sk'
      write (iout,*) '[] 0 setdash'
      write (iout,*) 'np'
c     Draw ticks
      do ia=1,36
        ang=float(ia*10)*pi/180.0
        rx=sin(ang)*r
        ry=cos(ang)*r
        write (iout,1000) cx+rx,cy+ry
        if (mod(ia,3) .eq. 0) then
          write (iout,1001) cx+0.94*rx,cy+0.94*ry
        else
          write (iout,1001) cx+0.97*rx,cy+0.97*ry
        end if
      end do
c     Draw axes
      write (iout,1000) cx-r,cy
      write (iout,1001) cx+r,cy
      write (iout,*) 'sk'
      write (iout,*) 'np'
      write (iout,1000) cx,cy+r
      write (iout,1001) cx,cy-r
      write (iout,*) 'sk'
c     Draw inner disk and initial postion line
c     write (iout,*) '0.7 0.7 0.7 setrgbcolor'
      write (iout,*) '0.6 0.6 0.6 setrgbcolor'
      write (iout,*) 'np'
      write (iout,1003) cx,cy,r0,0.0,360.0
      write (iout,*) 'fill'
      write (iout,*) 'sk'
      call rgbcolor(iout,-6)
      write (iout,*) 'np'
      write (iout,1000) cx,cy
      anggrid=5.0
      cosav=0.d0
      sinav=0.d0
      nav=0
      incrloop=max0(1,incr)
      do i=1,n,incrloop
        if (incrloop .eq. 1) then
          ang=dacoscheck(ddd,res(1,i,incrid+idial),0,iout,'DRAWDIAL')
          if (res(2,i,incrid+idial) .lt. 0.0) ang=-ang
          cosav=cosav+res(1,i,incrid+idial)
          sinav=sinav+res(2,i,incrid+idial)
        else
c         First average over incrloop steps
          cosavinc=0.0
          sinavinc=0.0
          do j=i,i+incrloop-1
            cosavinc=cosavinc+res(1,j,incrid+idial)
            sinavinc=sinavinc+res(2,j,incrid+idial)
          end do
          cosavinc=cosavinc/incrloop
          sinavinc=sinavinc/incrloop
          sqsum=sqrt(cosavinc**2+sinavinc**2)
          cosavinc=cosavinc/sqsum
          sinavinc=sinavinc/sqsum
          ang=dacoscheck(ddd,cosavinc,0,iout,'DRAWDIAL')
          if (sinavinc .lt. 0.0) ang=-ang
          cosav=cosav+cosavinc
          sinav=sinav+sinavinc
        end if
        nav=nav+1
        ri=r0+r1*float(i)/float(n)
        if (i .eq. 1) then
          write (iout,1001) cx+cos(ang)*r0,cy+sin(ang)*r0
          write (iout,*) 'sk'
          call rgbcolor(iout,-5)
          write (iout,*) 'np'
          write (iout,1000) cx+cos(ang)*r0,cy+sin(ang)*r0
        else
          angdev=(ang-angprev)
          if (angdev .gt. pi) angdev=angdev-2.0*pi
          if (angdev .lt. -pi) angdev=angdev+2.0*pi
          if (abs(angdev)*ri .gt. anggrid) then
            nd=abs(angdev)*ri/anggrid
            if (i .gt. n/2) nd=2*nd
c           if (lab(1:1) .eq. 'P') print *,'i,ri,angdev,nd=',
c    -          i,ri,angdev,nd
            do id=1,nd
              angi=angprev+angdev*float(id)/float(nd)
              rii=riprev+(ri-riprev)*float(id)/float(nd)
              write (iout,1001) cx+cos(angi)*rii,cy+sin(angi)*rii
            end do
          else
            write (iout,1001) cx+cos(ang)*ri,cy+sin(ang)*ri
          end if
        end if
        riprev=ri
        angprev=ang
      end do
      write (iout,*) 'sk'
      lthick=2
      if (ndprow .gt. 6) lthick=1
      if (nav .gt. 0) then
        call rgbcolor(iout,-1)
        write (iout,1004) lthick
        cosav=cosav/nav
        sinav=sinav/nav
        sqsum=sqrt(cosav**2+sinav**2)
        cosav=cosav/sqsum
        sinav=sinav/sqsum
        write (iout,*) 'np'
        write (iout,1000) cx+cosav*r0,cy+sinav*r0
        write (iout,1001) cx+cosav*(r0+r1),cy+sinav*(r0+r1)
        write (iout,*) 'sk'
c       Draw tick outside at the final position
        call rgbcolor(iout,-6)
        write (iout,1004) lthick
        write (iout,*) 'np'
        rx=r*res(1,n,incrid+idial)
        ry=r*res(2,n,incrid+idial)
        write (iout,1000) cx+rx,cy+ry
        write (iout,1001) cx+1.1*rx,cy+1.1*ry
        write (iout,*) 'sk'
      end if
      call rgbcolor(iout,9)
      write (iout,1004) 1
      return
1000  format(2f12.5,' m')
1001  format(2f12.5,' l')
1003  format(5f12.4,' arc')
1004  format(i5,' setlinewidth')
1005  format('/',a,' findfont',/,i2,' scalefont',/,'setfont')
      end
      subroutine psshow(iout,string,len)
      character*(*) string
      character*200 clean
      inc=0
      do ic=1,len
        if (string(ic:ic) .eq. '(') then
          clean(ic+inc:ic+inc)='\\'
          clean(ic+inc+1:ic+inc+1)='('
          inc=inc+1
        else if (string(ic:ic) .eq. ')') then
          clean(ic+inc:ic+inc)='\\'
          clean(ic+inc+1:ic+inc+1)=')'
          inc=inc+1
        else
          clean(ic+inc:ic+inc)=string(ic:ic)
        end if
      end do
      write (iout,1000) clean(1:len+inc)
      return
1000  format('(',a,' ) show')
      end
      subroutine openps(iout,xm,ym,title,ltitle,title1,ltitle1,
     -  filename,lfilename,filename2,lfilename2,npspages,ipspage)
      character*(*) title,title1,filename,filename2
c     print *,'OPENPS'
      ixm=xm+25.0
      iym=ym+25.0
      call psheader(iout,title,ltitle,-10,-10,ixm,iym,npspages,ipspage)
      write (iout,2000)
      call plothead(iout,xm,ym,title,ltitle,title1,ltitle1,
     -  filename,lfilename,filename2,lfilename2)
      return
2000  format('/m { moveto } def',/,'/l { lineto } def',/,
     -  '/np { newpath } def',/, '/sk { stroke } def',/,
     -  '/f { fill } def',/,'/lw { setlinewidth } def',/,
     -  '/Helvetica findfont',/,'12 scalefont',/,'setfont',/,
     -  '25 25 translate')
      end
      subroutine psheader(iout,title,ltitle,ix0,iy0,ixm,iym,npspages,
     -  ipspage)
      character*(*) title
      character*12 today
      common /today_date/ ltoday,today
c     print *,'PSHEADER npspages,ipspage=',npspages,ipspage
      if (npspages .gt. 0) then
        write (iout,1000) title(1:ltitle)
c       if (npspages .lt. 10) then
c         write (iout,1021) npspages
c       else if (npspages .lt. 10) then
c         write (iout,1022) npspages
c       else
c         write (iout,1023) npspages
c       end if
        write (iout,1030) ix0,iy0,ixm,iym
        if (ltoday .gt. 0) write (iout,1001) today(1:ltoday)
        write (iout,1040)
        write (iout,2000)
        ipspage=0
      end if
      return
1000  format('%!PS-Adobe-2.0 ',/,'%%Title: ',a,/,
     -  '%%Creator: SIMULAID')
1001  format('%%CreationDate: ',a)
c1021  format('%%Pages:',i1)
c1022  format('%%Pages:',i2)
c1023  format('%%Pages:',i3)
1030  format('%%BoundingBox:',4i8)
1040  format('%%EndComments')
2000  format('/m { moveto } def',/,'/l { lineto } def',/,
     -  '/np { newpath } def',/, '/sk { stroke } def',/,
     -  '/f { fill } def',/,'/lw { setlinewidth } def',/,
     -  '/r { rlineto } def')
      end
      subroutine plothead(iout,xm,ym,title,ltitle,title1,ltitle1,
     -  filename,lfilename,filename2,lfilename2)
      character*(*) title,title1,filename,filename2
c     print *,'PLOTHEAD ltitle=',ltitle
      yinc=0.0
      if (lfilename2 .gt. 0) then
        write (iout,1000) xm*0.04,ym*0.91+yinc
        write (iout,1003) 'Second file',filename2(1:lfilename2)
        yinc=yinc+ym*0.02
      end if
      if (lfilename .gt. 0) then
        write (iout,1000) xm*0.04,ym*0.91+yinc
        write (iout,1003) 'File',filename(1:lfilename)
        yinc=yinc+ym*0.02
      end if
      if (ltitle1 .gt. 0) then
        write (iout,1000) xm*0.04,ym*0.91+yinc
        call psshow(iout,title1,ltitle1)
        yinc=yinc+ym*0.02
      end if
      write (iout,1000) xm*0.04,ym*0.91+yinc
      itw=0
      if (ltitle .ge. 4) then
        if (title(1:4) .eq. '@#$%') then
          call psshow(iout,'Simulaid-generated plot',23)
          itw=1
        end if
      end if
      if (itw .eq. 0) call psshow(iout,title,ltitle)
      return
1000  format(2f12.5,' m')
1003  format('(',a,' analyzed: ',a,' ) show')
      end
      subroutine hbbridge(nanchor,ianchor,indexa,ianchor2,iqfsel2,lpath,
     -  nbridgetype,ibridgetype,maxbridgemem,n,nhbneig,ineig,list,
     -  nnblist,iparent,ixres,resnames,brslv,nabr,nrescol,nmc,ifail,
     -  listbridge,iout,maxng,maxbridgelen,maxbridgetype,
     -  minbridgelenprint,maxrsd,maxrec)
      character*8 resnames
      dimension ianchor(nanchor),indexa(n),nhbneig(n),ineig(maxng,n),
     -  lpath(maxbridgetype,maxbridgelen,nanchor),
     -  nbridgetype(maxbridgelen,nanchor),
     -  ibridgetype(maxbridgetype,maxbridgelen,nanchor),resnames(maxrsd)
      dimension list(maxrec),nnblist(maxrec),iparent(maxrec),
     -  ixres(maxrec),ip(10),iflist(10),illist(10)
      character*8 brslv
      character*80 line
c     write (iout,*) 'ianchor2,iqfsel2,n,ixres(1),ixres(n)=',
c    -  ianchor2,iqfsel2,n,ixres(1),ixres(n)
c     print *,'HBBRIDGE nanchor=',nanchor,' maxrec=',maxrec
      ifail=0
      do iia=1,nanchor
        do ia=1,ixres(n)
          iparent(ia)=-1
        end do
        iat=ianchor(iia)
c       write (iout,2311) iat,indexa(iat),resnames(ixres(iat)),
c    -    (ineig(maxng+1-ia,iat),ia=1,nhbneig(iat))
c2311    format(' HBBR ianch=',i6,' indexa=',i4,' resn=',a,' ihb=',5i6)
        if (indexa(iat) .eq. 0) then
          print *,'PROGRAM ERROR: ',iia,'th anchorlist=',iat,
     -      ' is not marked as anchor'
          stop
        end if
        list(1)=iat
        ll=1
        ixp=ixres(iat)
c       Grow tree at depth maxbrlen (4)
        ll1=1
        iflist(1)=ll1
        illist(1)=ll
        do it=1,maxbridgemem+1
          nn=0
          do il=ll1,ll
            ia=list(il)
c           ixp is the parent residue (solvent molecule) number
            if (ia .ne. iat) ixp=ixres(ia)
            if (ixp .le. 0) then
              write (iout,1005) iat,ia,it,il,ixp
              write (6,1005) iat,ia,it,il,ixp
              stop
            end if
            do in=1,nhbneig(ia)
              ian=ineig(maxng-in+1,ia)
c             Drop if it is a loop back or already in the current list
              do j=1,illist(min0(2,it))
                if (list(j) .eq. ian) go to 100
              end do
c             list is only sorted at each level
              do itt=3,it
c               print *,'it,itt,iflist(itt),illist(itt)=',
c    -             it,itt,iflist(itt),illist(itt)
                call findixsort(list,iflist(itt),illist(itt),ian,
     -            ixian,itryl)
                if (ixian .gt. 0) go to 100
              end do
c             do j=1,il-1
c               if (nnblist(j) .eq. ian) go to 100
c             end do
              call findixsort(nnblist,1,nn,ian,ixian,itrynnb)
              if (ixian .gt. 0) go to 100
c             If anchor atom then finish bridge and gather statistics
              if (resnames(ixres(ian))(1:nrescol) .ne.
     -            brslv(1:nrescol)) then
                idoit=1
c               See if end is also an anchor
                if (ianchor2 .eq. 1) then
                  if (indexa(ian) .lt. 1) idoit=0
                else
                  if (iqfsel2 .eq. 1 .and. indexa(ian) .eq. 0) idoit=0
                end if
                if (idoit .eq. 1 .and.
     -              (indexa(ian) .lt. 1 .or. ian .gt. iat)) then
                  if (nbridgetype(it,iia) .eq. 0) then
                    nbridgetype(it,iia)=1
                    ibridgetype(1,it,iia)=ian
                    iend=1
                    go to 300
                  end if
                  call findixsort(ibridgetype(1,it,iia),1,
     -               nbridgetype(it,iia),ian,ixian,itry)
                  if (ixian .gt. 0) then
                    iend=ixian
                    go to 300
                  end if
c                 do ial=1,nbridgetype(it,iia)
c                   if (ibridgetype(ial,it,iia) .eq. ian) then
c                     iend=ial
c                     go to 300
c                   end if
c                 end do
                  if (nbridgetype(it,iia) .lt. maxbridgetype) then
c                   Not found, add to list
c                   Shift ibridgetype,lpath to maintain them sorted
                    ixian=itry
                    do ib=nbridgetype(it,iia),ixian,-1
                      ibridgetype(ib+1,it,iia)=ibridgetype(ib,it,iia)
                      lpath(ib+1,it,iia)=lpath(ib,it,iia)
                    end do
                    nbridgetype(it,iia)=nbridgetype(it,iia)+1
                    ibridgetype(ixian,it,iia)=ian
                    iend=ixian
c                   ibridgetype(nbridgetype(it,iia),it,iia)=ian
c                   iend=nbridgetype(it,iia)
                  else
                    write (6,1006) maxbridgetype
                    write (iout,1006) maxbridgetype
                    if (nmc .gt. 0) then
                      write (6,1008) nmc
                      write (iout,1008) nmc
                      ifail=1
                      return
                    else
                      percdone=100.0*float(iia)/float(nanchor)
                      write (6,1009) percdone
                      write (iout,1009) percdone
                      stop
                    end if
                  end if
300               lpath(iend,it,iia)=lpath(iend,it,iia)+1
                  if (listbridge .gt. 0) then
c                   write (iout,1002) ibridgetype(iend,it,iia)
                    ixptb=ixp
                    ip(it)=ixptb
                    iit=it
                    do while (iit .gt. 2)
                      iit=iit-1
c                     write (iout,*) 'TBCK it,iit,ixp,iparent(ixp)=',
c    -                 it,iit,ixptb,iparent(ixptb)
                      ixptb=iparent(ixptb)
                      ip(iit)=ixptb
                      if (ixp .eq. -1) then
                        write (6,1007) iat,it
                        write (iout,1007) iat,it
                        stop
                      end if
                    end do
                    if (nmc .eq. 0) then
                      ic0=0
                    else
                      ic0=10
                      write (line(1:10),1004) nmc
                    end if
                    write (line(ic0+1:ic0+18),1000) iat
                    ic=ic0+18
                    if (it .gt. minbridgelenprint) then
                      do iit=2,it
                        write (line(ic+1:ic+17),1001) ip(iit)
                        ic=ic+17
                        if (iit .eq. 2 .and. iit .lt. it) then
                          write (iout,1003) line(1:ic)
                          ic=ic0+18
                          call blankout(line,1,ic)
                        end if
                      end do
                    end if
                    write (line(ic+1:ic+15),1002)
     -                ibridgetype(iend,it,iia)
                    write (iout,1003) line(1:ic+15)
                  end if
c                  write (77,8877) il,ia,iend,it,iia,lpath(iend,it,iia)
c8877              format(' il,ia,iend,it,iia=',5i4,' lpath=',i3)
                end if
              else
c               New atom, add to list of next level all atoms of this solvent
                isolv=ixres(ian)
                iparent(isolv)=ixp
c               write (iout,*) 'ADD ian,isolv,iparent(isolv)=',
c    -                              ian,isolv,iparent(isolv)
c               Add all atoms of this residue to nnblist
                iaa=ian
                do while (iaa .gt. 1 .and. ixres(iaa) .eq. ixres(ian))
                  iaa=iaa-1
                end do
                if (iaa .eq. 1 .and. ixres(iaa) .eq. ixres(ian))
     -            iaa=iaa-1
                ifr=iaa+1
                iaa=ian
                do while (iaa .lt. n .and. ixres(iaa) .eq. ixres(ian))
                  iaa=iaa+1
                end do
                if (iaa .eq. n .and. ixres(iaa) .eq. ixres(ian))
     -            iaa=iaa+1
                ilr=iaa-1
                if (ilr-ifr+1 .ne. nabr) then
                  write (6,1010) brslv,ixres(ian),ilr-ifr+1,nabr
                  write (iout,1010) brslv,ixres(ian),ilr-ifr+1,nabr
                  stop
                end if
c               write (iout,*) 'Adding itrynnb,ifr,ilr,nn=',
c    -                          itrynnb,ifr,ilr,nn
                if (nn .gt. 0) then
                  do is=nn,itrynnb,-1
                    nnblist(is+nabr)=nnblist(is)
                  end do
                end if
                do isv=1,nabr
                  nnblist(itrynnb-1+isv)=ifr-1+isv
                end do
                nn=nn+nabr
c                 do isv=ifr,ilr
c                   nnblist(nn+isv-ifr+1)=isv
c                 end do
c               nn=nn+ilr-ifr+1
              end if
100           continue
            end do
          end do
c          if (nn .gt. 0) write (iout,6633) (nnblist(kk),kk=1,nn)
c6633      format(' nnblist=',10i6)
          call trnsfi(list(ll+1),nnblist,nn)
          ll1=ll+1
          ll=ll+nn
          iflist(it+1)=ll1
          illist(it+1)=ll
        end do
      end do
      return
1000  format(' Anchor 1:',i5,' - ')
1001  format(' solvent',i6,' - ')
1002  format(' Anchor 2:',i5)
1003  format(a)
1004  format(i10)
1005  format(' PROGRAM ERROR at iat,ia,it,il=',2i5,i3,i2,
     -  ': ixres(ia)=',i4)
1006  format(' ERROR: maximum number of bridge end types (',i4,
     -  ') is exceeded',/,8x,'Reduce the number of bridge members or',/,
     -  8x,'increase MAXBRIDGETYPE')
1007  format(' PROGRAM ERROR in traceback iat=',i4,' it=',i1)
1008  format(8x,'Last frame processed=',i9)
1009  format(8x,'Processed ',f5.1,' % of the anchors')
1010  format(' ERROR: bridge residue ',a,' #',i5,' has',i4,' atoms ',
     -  'instead of',i3,/,' - check the input STRUCTURE file')
      end
      subroutine pairdistconf(c,n,rmsdmin,rmsdmax)
      dimension c(3,n)
      parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
      parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
     -  (9*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
      common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),ing(MAX2D,MAX2D),
     -  ihbpair(2,MAXBONDS),ihb_pair_res(3,MAXBONDS),ihbtores(MAXBONDS),
     -  iusepair(MAXBONDS),a1(MAXBONDS),a2(MAXBONDS),fill(IFILL2)
      rmsd2d(1,1)=0.0
      rmsdmax=0.0
      rmsdmin=99999.0
      do ia=2,n
        do ja=1,ia-1
          d2=sqrt(dist2(c(1,ia),c(1,ja)))
          rmsd2d(ia,ja)=d2
          rmsd2d(ja,ia)=d2
          if (d2 .lt. rmsdmin) rmsdmin=d2
          if (d2 .gt. rmsdmax) rmsdmax=d2
        end do
        rmsd2d(ia,ia)=0.0
      end do
      return
      end
      subroutine printclusterpdb(c,frocc,bfac,ncl,ifclst,ilclst,ixclst,
     -  title,na)
      dimension c(3,na),frocc(na),bfac(na),ifclst(ncl),ilclst(ncl),
     -  ixclst(na)
      character*80 title
      character*200 pdbout
c     Print a PDB file of atoms where each cluster is a separate residue
c     print *,'PRINTCLUSTERPDB ncl=',ncl,' na=',na
      nl=0
      call openfile(50,0,'clustered PDB',13,'new',pdbout,nl,notfnd,
     -  0,1,1,0,0)
      write (50,1001) 'REMARK '//title(1:72)
      write (50,1001) 'REMARK Atoms clustered into different residues'
      na=1
      write (50,1000) na,' O  ','CNT','A',1,0.0,0.0,0.0,1.0,0.0
      do icl=1,ncl
        do ia=ifclst(icl),ilclst(icl)
          na=na+1
          iap=ixclst(ia)
          write (50,1000) na,' H  ','CLS','C',icl,
     -      (c(k,iap),k=1,3),frocc(iap),bfac(iap)
        end do
      end do
      write (50,1001) 'END'
      close (50)
      return
1000  format('ATOM  ',i5,1x,a4,1x,a3,1x,a1,i4,1x,3x,3f8.3,2f6.2)
1001  format(a)
      end
      subroutine printclusterext(c,cent,ncl,ifclst,ilclst,ixclst,
     -  na,iclstyp,outfile,namleno,iout)
      dimension c(3,na),cent(3,ncl),ifclst(ncl),ilclst(ncl),ixclst(na)
      character*(*) outfile
      dimension xyzmin(3),xyzmax(3),xyz(3)
      character*1 xyzl
      character*80 centfile
      common /axislab/ xyzl(3)
      real*8 dxyz(3),r,theta,phi
c     print *,'PRINTCLUSTEREXT ncl=',ncl,' na=',na,
c    -  ' iclstyp,iout=',iclstyp,iout
      do icl=1,ncl
        do k=1,3
          xyzmin(k)=99999.0
          xyzmax(k)=-99999.0
        end do
        rmin=99999.0
        rmax=0.0
        thetamin=10.0
        thetamax=-10.0
        phimin=10.0
        phimax=-10.0
        do ia=ifclst(icl),ilclst(icl)
          do k=1,3
            xyz(k)=c(k,ixclst(ia))
            dxyz(k)=xyz(k)
            if (xyzmin(k) .gt. xyz(k)) xyzmin(k)=xyz(k)
            if (xyzmax(k) .lt. xyz(k)) xyzmax(k)=xyz(k)
          end do
c         Convert xyz to polar coordinates
          call polar(dxyz(1),dxyz(2),dxyz(3),r,phi,theta)
          if (r .lt. rmin) rmin=r
          if (r .gt. rmax) rmax=r
          if (theta .lt. thetamin) thetamin=theta
          if (theta .gt. thetamax) thetamax=theta
          if (phi .lt. phimin) phimin=phi
          if (phi .gt. phimax) phimax=phi
        end do
        write (iout,1000) icl
        if (iclstyp .ne. 2 .and. iclstyp .ne. 4) then
c         Calculate cluster COM
          call zeroit(cent(1,icl),3)
          do ia=ifclst(icl),ilclst(icl)
            do k=1,3
              cent(k,icl)=cent(k,icl)+c(k,ixclst(ia))
            end do
          end do
          do k=1,3
            cent(k,icl)=cent(k,icl)/float(ilclst(icl)-ifclst(icl)+1)
          end do
        end if
        write (iout,1002) (cent(k,icl),k=1,3)
        write (iout,1001) ('    '//xyzl(k),xyzmin(k),xyzmax(k),'A',
     -    k=1,3)
        write (iout,1001) '    R',rmin,rmax,'A'
        write (iout,1001) 'Theta',thetamin,thetamax,'rad'
        write (iout,1001) '  Phi',phimin,phimax,'rad'
      end do
      call askyn('Do you want a cluster-center file',33,
     -  1,-1,icentfile,000)
      if (icentfile .eq. 1) then
        centfile(1:namleno)=outfile(1:namleno)
        centfile(namleno+1:namleno+4)='.cnt'
        print *,'Center coordinates will be written to file ',
     -    centfile(1:namleno+4)
        call openfile(51,0,'cluster center',14,'new',centfile,namleno+4,
     -    notfound,0,1,1,0,0)
        write (51,1003) ncl,((cent(k,icl),k=1,3),icl=1,ncl)
      end if
      return
1000  format(/,' Cluster ',i5,':')
1001  format(1x,a,'-range: [',f6.1,' - ',f6.1,'] ',a)
1002  format(' Cluster center coordinates: ',3f10.5)
1003  format(i3,/,(3f12.5))
      end
      subroutine selectbond(ixres,nanchor,ianchor,indexa,ianchor2,
     -  iselfanc,iqfsel2,nhbneig,ineig,nbfound,nbresfound,nmc,nhbdist,
     -  bondname,lbondname,ianc_anc,itemp,itempres,ifail,iout,maxng,
     -  maxrec,mxbonds)
      dimension ixres(maxrec),ianchor(nanchor),indexa(maxrec),
     -  nhbneig(maxrec),ineig(maxng,maxrec),ianc_anc(mxbonds),
     -  nhbdist(mxbonds),itemp(mxbonds),itempres(mxbonds)
      character*(*) bondname
      parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
      parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
     -  (9*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
      common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),ing(MAX2D,MAX2D),
     -  ihbpair(2,MAXBONDS),ihb_pair_res(3,MAXBONDS),ihbtores(MAXBONDS),
     -  iusepair(MAXBONDS),a1(MAXBONDS),a2(MAXBONDS),fill(IFILL2)
      parameter (MAXFRAMES=50000,MAXCOPY=600,MAXITEMS=2*MAXCOPY-2)
      common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
     -  increment,increment2,ires(MAXITEMS,MAXFRAMES),
     -  scres(2,MAXFRAMES),x0(MAXCOPY),y0(MAXCOPY),nxselres,
     -  ixselres(MAXCOPY)
c     dimension ixx(3000)
c     ianchor: list of anchor atoms
c     indexa(ia): one if ia is an anchor atom;
c                 -1 if it is non-anchor atom but allowed by the charge filter
c     iqfsel2: If > 0, apply the charge filter to both atoms in the H bond
c     ianchor2: If > 0, both atoms forming the H bond have to be anchors
c     iselfanc: If = 0, exclude anchor-anchor hydrogen bonds
      nbitmax=30*MAXITEMS
c     write (6,*) 'SELECTBOND nframe,nbresfound,maxrec,mxbonds=',
c    -  nframe,nbresfound,maxrec,mxbonds
      call trajlimtest(nframe,MAXFRAMES)
      call zeroiti(itemp,0,mxbonds)
      call zeroiti(itempres,0,mxbonds)
      do iia=1,nanchor
        iat=ianchor(iia)
        if (indexa(iat) .eq. 0) print *,'PROGRAM ERROR: ',iia,
     -    'th anchorlist=',iat,' is not marked as anchor'
        do in=1,nhbneig(iat)
          ian=ineig(maxng-in+1,iat)
          idoit=1
c         See if end is also an anchor
          if (ianchor2 .eq. 1) then
            if (indexa(ian) .lt. 1) idoit=0
          else if (iselfanc .eq. 0) then
            if (indexa(ian) .gt. 0) idoit=0
          else
            if (iqfsel2 .eq. 1 .and. indexa(ian) .eq. 0) idoit=0
          end if
          if (idoit .eq. 1 .and.
     -        (indexa(ian) .lt. 1 .or. ian .gt. iat)) then
            if (ian .gt. iat) then
              ib1=iat
              ib2=ian
            else
              ib2=iat
              ib1=ian
            end if
            ihb=1
            do while (ihb .le. nbfound .and.
     -        (ib1 .ne. ihbpair(1,ihb) .or. ib2 .ne. ihbpair(2,ihb)))
              ihb=ihb+1
            end do
            if (ihb .gt. nbfound) then
              nbfound=nbfound+1
              if (ihb .lt. MAXBONDS) then
                ihbpair(1,nbfound)=ib1
                ihbpair(2,nbfound)=ib2
                nhbdist(ihb)=1
                if (indexa(ian) .gt. 0) ianc_anc(ihb)=1
              else
                write (6,1005) bondname(1:lbondname),mxbonds
                write (iout,1005) bondname(1:lbondname),mxbonds
                if (nmc .gt. 0) then
                  write (6,1008) nmc
                  write (iout,1008) nmc
                else
                  percdone=100.0*float(iia)/float(nanchor)
                  write (6,1009) percdone
                  write (iout,1009) percdone
                end if
                call askyn('Do you want to continue without tracking',
     -            40,0,1,istopscan,112)
                ifail=2*istopscan-1
                return
              end if
            else
              nhbdist(ihb)=nhbdist(ihb)+1
            end if
            itemp(ihb)=1
            ir1=ixres(ib1)
            ir2=ixres(ib2)
            ihb=1
            do while (ihb .le. nbresfound .and.
     -        (ir1 .ne. ihb_pair_res(1,ihb) .or.
     -         ir2 .ne. ihb_pair_res(2,ihb)))
              ihb=ihb+1
            end do
            if (ihb .gt. nbresfound) then
              nbresfound=nbresfound+1
              ihb_pair_res(1,nbresfound)=ir1
              ihb_pair_res(2,nbresfound)=ir2
              ihb_pair_res(3,nbresfound)=1
              ihb_pair_res(3,nbresfound+1)=0
              itempres(nbresfound)=1
            else if (itempres(ihb) .eq. 0) then
              ihb_pair_res(3,ihb)=ihb_pair_res(3,ihb)+1
              itempres(ihb)=1
            end if
          end if
        end do
      end do
      if (nbfound .le. nbitmax)
     -  call savebitc(ires(1,nframe),itemp,nbfound,30,MAXITEMS)
      if (nbfound .eq. nbitmax+1) then
        write (6,1005) bondname(1:lbondname),nbitmax
        write (iout,1005) bondname(1:lbondname),nbitmax
      end if
      return
1005  format(' ERROR: maximum number of ',a,' bonds to store (',i5,
     -  ') is exceeded',/,8x,'Reduce the number of anchors or',/,
     -  8x,'increase the size of the array res in the common block ',
     -  '/analres/')
1008  format(8x,'Last frame processed=',i9)
1009  format(8x,'Processed ',f5.1,' % of the anchors')
      end
      subroutine trackstat(nbonds,nhbdist,nhbpers,maxlenon,
     -  maxlenoff,itf,itl,it,itprev)
      dimension nhbdist(nbonds),nhbpers(nbonds),maxlenon(nbonds),
     -  maxlenoff(nbonds),itf(nbonds),itl(nbonds),it(nbonds),
     -  itprev(nbonds)
      parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
      parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
     -  (9*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
      common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),ing(MAX2D,MAX2D),
     -  ihbpair(2,MAXBONDS),ihb_pair_res(3,MAXBONDS),ihbtores(MAXBONDS),
     -  iusepair(MAXBONDS),a1(MAXBONDS),a2(MAXBONDS),fill(IFILL2)
      parameter (MAXFRAMES=50000,MAXCOPY=600,MAXITEMS=2*MAXCOPY-2)
      common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
     -  increment,increment2,ires(MAXITEMS,MAXFRAMES),
     -  scres(2,MAXFRAMES),x0(MAXCOPY),y0(MAXCOPY),nxselres,
     -  ixselres(MAXCOPY)
      dimension isegstart(MAXBONDS)
c     print *,'TRACKSTAT nbonds=',nbonds,' nframe=',nframe
      call zeroiti(nhbdist,0,nbonds)
      call zeroiti(nhbpers,0,nbonds)
      call zeroiti(maxlenon,0,nbonds)
      call zeroiti(maxlenoff,0,nbonds)
      call zeroiti(isegstart,0,nbonds)
      call zeroiti(itf,0,nbonds)
      call zeroiti(itl,0,nbonds)
      do ifr=1,nframe
        call readbitc(ires(1,ifr),it,nbonds,30,MAXITEMS)
        do i=1,nbonds
          if (itf(i) .gt. 0) then
            if (it(i) .ne. itprev(i)) then
              len=ifr-isegstart(i)
               if (itprev(i) .eq. 1) then
                 if (maxlenon(i) .lt. len) maxlenon(i)=len
               else
                 if (maxlenoff(i) .lt. len) maxlenoff(i)=len
               end if
               isegstart(i)=ifr
            end if
          end if
          if (it(i) .eq. 1) then
            nhbdist(i)=nhbdist(i)+1
            if (itf(i) .eq. 0) then
              itf(i)=ifr
              isegstart(i)=ifr
            end if
            itl(i)=ifr
            if (ifr .gt. 1 .and. itprev(i) .eq. 0)
     -        nhbpers(i)=nhbpers(i)+1
          end if
        end do
        call trnsfi(itprev,it,nbonds)
      end do
      return
      end
      subroutine autocorr(itr_ix,itr,nbits,iframeunit,framefac,
     -  iauctypeinp,lastframeinp,nreusemax,percon,loffmin,nseg_scr,
     -  nauc_extra,iout)
      parameter (MAXFRAMES=50000,MAXCOPY=600,MAXITEMS=2*MAXCOPY-2)
      common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
     -  increment,increment2,ires(MAXITEMS,MAXFRAMES),
     -  scres(2,MAXFRAMES),x0(MAXCOPY),y0(MAXCOPY),nxselres,
     -  ixselres(MAXCOPY)
      parameter (MAXFRAMES2=MAXFRAMES/2)
      dimension auc(MAXFRAMES2),nauc(MAXFRAMES2),itrack(MAXFRAMES),
     -  lfrunit(4)
      parameter (MAXFRAMES21=MAXFRAMES2+1)
      common /aucw/ auc_all(MAXFRAMES21,MAXCOPY)
      dimension ran(1),ixran(100)
      character*6 frunit(4)
      data frunit /'frames','ps    ','ns    ','ms    '/,lfrunit/6,2,2,2/
c     Calculate the autocorrelation of bond itr
c     write (6,*) 'AUTOCORR itr_ix,itr,iauctypeinp,lastframeinp=',
c    -  itr_ix,itr,iauctypeinp,lastframeinp
      iauctype=iauctypeinp
      ifrst=0
      nframe2=max0(nframe,lastframeinp)/2
      call zeroiti(itrack,0,max0(nframe,lastframeinp))
      call zeroit(auc,nframe2)
      call zeroiti(nauc,0,nframe2)
c     Read bits
      ii=(itr-1)/nbits+1
      ib=mod(itr-1,nbits)
      lastfr=0
      do ifr=1,nframe
        if (btest(ires(ii,ifr),ib)) itrack(ifr)=1
        if (itrack(ifr) .eq. 1) then
          if (ifrst .eq. 0) ifrst=ifr
          lastfr=ifr
          if (ifrst .eq. 0) ifrst=ifr
        end if
      end do
c      write (0006,9867) itr,nframe,lastfr,loffmin
c9867  format(' ITR=',I6,' NFRAME=',I6,' LASTFR=',I6,' LOFFMIN=',I6)
c     Accumulate auc
      if (nframe-lastfr .gt. loffmin .and. iauctype .gt. 3) then
        iauctype=3
        write (iout,1005) nframe,lastfr,loffmin
      end if
      nframeuse=lastfr-ifrst+1
      lastframeuse=0
      if (iauctype .eq. 1) then
        lastframeuse=lastfr
      else if (iauctype .eq. 2) then
        lastframeuse=nframe
      else
        if (iauctype .eq. 3) then
          nframeuse=lastframeinp-ifrst+1
          call zeroiti(itrack,nframe,lastframeinp)
        else if (iauctype .eq. 4) then
c         Pad with repeating the track
          nframeuse=lastframeinp-ifrst+1
          nadd=lastframeinp-lastfr
c          write (iout,*) 'NADD=',nadd
          incr=lastfr
          lentrackuse=min0(lastfr-ifrst+1,nreusemax)
          do while (nadd .gt. 0)
            ncop=min0(nadd,lentrackuse)
            incr0=max(ifrst-1,lastfr-ncop)
c            write (iout,9682) incr,incr0,nadd,ncop
c9682        format(' INCR=',I6,' INCR0=',I6,' NADD=',I6,' NCOP=',I6)
c           print *,'NCOP,NSEG_SCR=',NCOP,NSEG_SCR
            if (ncop .ge. nseg_scr .and. nseg_scr .gt. 0) then
              lenseg_scr=ncop/nseg_scr
              call scramble(ixran,nseg_scr)
              do is=1,nseg_scr-1
                ishift=(ixran(is)-is)*lenseg_scr
c               print *,'IS,IXRAN(IS),ISHIFT=',is,ixran(is),ishift
                do i=lenseg_scr*(is-1)+1,lenseg_scr*is
                  itrack(incr+i)=itrack(incr0+i+ishift)
                end do
              end do
c             Last (shorter) segment
              do i=lenseg_scr*(nseg_scr-1)+1,ncop
                itrack(incr+i)=itrack(incr0+i)
              end do
            else
              do i=1,ncop
                itrack(incr+i)=itrack(incr0+i)
              end do
            end if
            nadd=nadd-ncop
            incr=incr+ncop
          end do
        else if (iauctype .eq. 5) then
c         Pad with random states, p(on)=percent on
          nframeuse=lastframeinp-ifrst+1
          do i=lastfr+1,lastframeinp
            call randpx(1,ran)
            irand=0
            if (ran(1) .lt. percon) irand=1
            itrack(i)=irand
          end do
        end if
        lastframeuse=lastframeinp
      end if
c     print *,'LASTFRAMEUSE,IFR=',lastframeuse,ifr
      do ifr=ifrst,max0(lastfr,lastframeinp)
        if (itrack(ifr) .eq. 1) then
          ntodo=min0(nframeuse/2,lastframeuse-ifr+1)-1
          do ifrr=1,ntodo
            auc(ifrr)=auc(ifrr)+itrack(ifr+ifrr)
            nauc(ifrr)=nauc(ifrr)+1
c           if (auc(ifrr) .gt. nauc(ifrr)) write (6,7923)
c    -        ifr,ifrr,ntodo,auc(ifrr),nauc(ifrr),itrack(ifr+ifrr)
c7923       format(' ifr,ifrr=',2i6,' ntodo='i6,' auc=',f12.1,
c    -    ' nauc=',i6,' itrack=',i9)
          end do
        end if
      end do
c     Normalize auc
      iauchalf=0
      aucsum=0.0
c      write (0006,9858) nframe2,nframeuse,lastframeuse
c9858  format(' NFRAME2=',i6,' NFRAMEUSE=',i6,' LASTFRAMEUSE=',I6)
      do ifr=1,nframe2
        if (nauc(ifr) .gt. 0) auc(ifr)=auc(ifr)/float(nauc(ifr))
c       if (auc(ifr) .lt. 0.0 .or. auc(ifr) .gt. 1.0) then
c         print *,'IFR=',ifr,' AUC=',auc(ifr),' NAUC=',nauc(ifr),
c    -     ' NFRAME2=',nframe2
c         stop
c       end if
        aucsum=aucsum+auc(ifr)
        if (iauchalf .eq. 0) then
          if (auc(ifr) .lt. 0.5) iauchalf=ifr
        end if
      end do
      rnfr2=framefac*(nframeuse/2)
      if (iframeunit .gt. 2) then
        if (iauchalf .eq. 0) write (iout,1002) itr,aucsum*framefac,'>',
     -    rnfr2,frunit(iframeunit)(1:lfrunit(iframeunit))
        if (iauchalf .gt. 0) write (iout,1002) itr,aucsum*framefac,'=',
     -    iauchalf*framefac,frunit(iframeunit)(1:lfrunit(iframeunit))
      else
        if (iauchalf .eq. 0) write (iout,1001) itr,aucsum*framefac,'>',
     -    rnfr2,frunit(iframeunit)(1:lfrunit(iframeunit))
        if (iauchalf .gt. 0) write (iout,1001) itr,aucsum*framefac,'=',
     -    iauchalf*framefac,frunit(iframeunit)(1:lfrunit(iframeunit))
      end if
      write (iout,1003) (auc(i),i=1,10) 
      incr=max0(1,(nframe-1)/20+1)
      write (iout,1004) (auc(i*incr),i=1,nframeuse/(2*incr)) 
      if (itr_ix .le. MAXCOPY) then
        call trnsfr(auc_all(1,itr_ix),auc,nframe2)
        auc_all(nframe2+1,itr_ix)=aucsum
      else
        nauc_extra=nauc_extra+1
      end if
      return
1001  format(' BO#',i4,' AUC sum=',f7.1,' Half time of the track auc ',
     -  a,f9.1,1x,a)
1002  format(' BO#',i4,' AUC sum=',f11.4,' Half time of the track auc ',
     -  a,f9.4,1x,a)
1003  format(' AUC (1-10):',10f6.3)
1004  format(' AUC (incr):',10f6.3)
1005  format(' Paddig switched to 0s (nframe=',i6,' laston=',i6,
     -  ' loffmin=',i6,')')
      end
      subroutine print_auc(lab,llab,ntracks,nframe,bondname,lbondname)
      character*(*) lab,bondname(ntracks)
      parameter (MAXFRAMES=50000,MAXCOPY=600)
      parameter (MAXFRAMES2=MAXFRAMES/2)
      parameter (MAXFRAMES21=MAXFRAMES2+1)
      common /aucw/ auc_all(MAXFRAMES21,MAXCOPY)
      call openfile(91,0,' ',1,'new',lab,llab,notfnd,0,1,1,0,0)
      ntrackw=min0(ntracks,MAXCOPY)
      write (91,1003) (it,it=1,ntrackw)
      write (91,1004) (it,bondname(it)(1:lbondname),it=1,ntrackw)
      write (91,1001) 0,(1.0,it=1,ntrackw)
      do if=1,nframe/2
        write (91,1001) if,(auc_all(if,it),it=1,ntrackw)
      end do
      write (91,1002) (auc_all(nframe/2+1,it),it=1,ntrackw)
      close (91)
      return
1001  format(i7,400f7.3)
1002  format('#AUCSUM',400f7.1)
1003  format('#      ',400i7)
1004  format('#      ',400(i4,':',a))
      end
      subroutine printrmsd2(iout,n1,n2,lab,llab)
      character*(*) lab
      parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
      parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
     -  (4*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
      common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),ing(MAX2D,MAX2D),
     -  ihbpair(2,MAXBONDS),a1(MAXBONDS),a2(MAXBONDS),fill(IFILL2)
      write (iout,*) lab(1:llab)
      do i=1,n1
        write (iout,1000) i,(rmsd2d(i,j),j=1,n2)
      end do
      return
1000  format(i4,' rmsd2:',10f8.2)
      end
      subroutine hbbridgeprint(nanchor,ianchor,lpath,nbridgetype,
     -  ibridgetype,maxbridgemem,line,index,iresno,inamcol1,inamcol2,
     -  irescol1,irescol2,hblimfac,angmin,filename,namlen,iout,qmin,
     -  iqfsel2,brslv,nrescol,maxbhcount,maxhbtype,minbridgelenprint,
     -  minbridgepercprint,nframe,maxbridgelen,maxbridgetype,maxrec)
      dimension ianchor(nanchor),nbridgetype(maxbridgelen,nanchor),
     -  lpath(maxbridgetype,maxbridgelen,nanchor),iresno(maxrec),
     -  ibridgetype(maxbridgetype,maxbridgelen,nanchor),index(maxrec)
      character* 132 line(maxrec)
      character*200 filename
      character*8 brslv
      dimension lensum(10)
c     print *,'HBBRIDGEPRINT maxbridgelen,maxbridgemem=',
c    -  maxbridgelen,maxbridgemem
      call zeroiti(lensum,0,maxbridgelen)
      if (namlen .gt. 1) write (iout,1008) filename(1:namlen)
      write (iout,1002) brslv(1:nrescol),hblimfac,angmin
      if (qmin .ne. 0.0) write (iout,1003) qmin
      if (iqfsel2 .eq. 1) write (iout,1004)
      if (minbridgelenprint .gt. 1) write (iout,1006) minbridgelenprint
      if (minbridgepercprint .gt. 0)
     -   write (iout,1007) minbridgepercprint,nframe
      write (iout,*)
      maxbrtyp=0
      maxbhcount=0
      maxhbtype=0
      do ia=1,nanchor
        ifrom=ianchor(ia)
        do id=1,maxbridgemem+1
          if (nbridgetype(id,ia) .gt. maxbrtyp)
     -       maxbrtyp=nbridgetype(id,ia)
          do in=1,nbridgetype(id,ia)
            ito=ibridgetype(in,id,ia)
            nbr=lpath(in,id,ia)
            if (id .ge. minbridgelenprint) then
              iperc=float(100*nbr)/float(nframe)
              if (iperc .ge. minbridgepercprint) then
                write (iout,1000) ifrom,iresno(ifrom),
     -            line(index(ifrom))(inamcol1:inamcol2),
     -            line(index(ifrom))(irescol1:irescol2),ito,iresno(ito),
     -            line(index(ito))(inamcol1:inamcol2),
     -            line(index(ito))(irescol1:irescol2),id,nbr
                if (id .lt. 1 .or. id .gt. 10) print *,
     -            'ia,ifrom,ito,nbr,id=',ia,ifrom,ito,nbr,id
                lensum(id)=lensum(id)+nbr
                if (id .eq. 1) then
                  maxhbtype=maxhbtype+1
                  if (nbr .gt. maxbhcount) maxbhcount=nbr
                end if
              end if
            end if
          end do
        end do
      end do
      write (iout,*)
      do id=1,maxbridgelen
        if (lensum(id) .gt. 0) write (iout,1001) id,lensum(id)
      end do
      write (6,1005) maxbrtyp,maxbridgetype
      write (iout,1005) maxbrtyp,maxbridgetype
      return
1000  format(' From (',i6,i6,')(',a,1x,a,') to (',i6,i6,
     -  ')(',a,1x,a,') of length ',i1,' #:',i5)
1001  format(' Number of paths of length',i2,'=',i9)
1002  format(' Bridge residue: ',a,/,
     -  ' Hydrogen-bond are defined with hblimfac=',f5.2,
     -  ' and H-bond angle minimum=',f5.1)
1003  format(' Anchor atoms were filtered by a charge threshold of',
     -  f6.3)
1004  format(' Charge filter was applied to the non-anchor atoms too')
1005  format(/,' Maximum number of bridge types found=',i3,' limit=',i3)
1006  format(' Bridges with length < ',i1,' will not be printed')
1007  format(' Bridges that occur less than ',i3,'% of the',i6,
     -  ' frames will not be printed')
1008  format(' Input file: ',a)
      end
      subroutine bondcorrsum(nbondcorr,nresbondcorr,scpmin,scpmax,
     -  ibframe,itempsum,itemp,ifirstframe,correxp,icorrtyp,
     -  icorrtrans,iaggregate,icorrbothstart,nframeav,imatprint,iout,
     -  igl,mx2d)
      dimension ibframe(mx2d),itempsum(mx2d),
     -  itemp(mx2d),ifirstframe(mx2d)
      parameter (MAXFRAMES=50000,MAXCOPY=600,MAXITEMS=2*MAXCOPY-2)
      common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
     -  increment,increment2,ires(MAXITEMS,MAXFRAMES),
     -  scres(2,MAXFRAMES),x0(MAXCOPY),y0(MAXCOPY),nxselres,
     -  ixselres(MAXCOPY)
      parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
      parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
     -  (9*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
      common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),ing(MAX2D,MAX2D),
     -  ihbpair(2,MAXBONDS),ihb_pair_res(3,MAXBONDS),ihbtores(MAXBONDS),
     -  iusepair(MAXBONDS),ibond(MAXBONDS),a1(MAXBONDS),fill(IFILL2)
      character*1 ans
c     print *,'HBCORRSUM nbondcorr,nframe,nresbondcorr=',
c    -  nbondcorr,nframe,nresbondcorr
      if (nbondcorr .gt. MAX2D) then
        print *,'PROGRAM ERROR: nbondcorr=',nbondcorr,' MAX2D=',MAX2D
        return
      end if
      if (nbondcorr .le. 1) then
        write (6,1004) nbondcorr
        return
      end if
      call trajlimtest(nframe,MAXFRAMES)
      call quiz(ans,icorrtyp,'b',' ',0,'bond correlation type',21,
     -  0,5,6,igl,85)
      if (icorrtyp .eq. 3) then
8010    call getint('Number of frames to average over',32,5,1,nframe,
     -    nframeav,84)
        if (nframeav .ge. nframe) then
          write (6,1008) nframe
          go to 8010
        end if
      end if
      call quiz(ans,icorrtrans,'-',' ',0,
     -  'correlation - measure transformation',36,0,5,6,igl,000)
      write (6,1002)
      call getint('Exponent of correlations',24,1,0,9,icorrexp,3)
      if (nframe .ge. 1000)
     -  print *,'Calculating correlation matrix - wait'
      correxp=icorrexp
      if (icorrexp .lt. 1) correxp=1.0/float(-icorrexp)
      write (iout,1001) 
      call zeroiti(nng,0,MAX2D)
      call zeroiti(ifirstframe,0,MAX2D)
      if (icorrtyp .eq. 3) call zeroiti(itempsum,0,MAX2D)
      call zeroiti(ing,0,MAX2D*MAX2D)
      nframe10=nframe/10+1
      scpmax=0.0
      scpmin=1.0
      ncorr=nbondcorr
      if (iaggregate .gt. 0) ncorr=nresbondcorr
      if (iaggregate .gt. 0) then
        ihbtoresmax=0
        do ib=1,nbondcorr
          if (ihbtores(ib) .gt. ihbtoresmax) ihbtoresmax=ihbtores(ib)
        end do
      end if
c     write (iout,*) 'BONDCORRSUM NCORR=',ncorr,' NBONDCORR=', nbondcorr
      if (ncorr .gt. MAX2D) then
        write (6,1005) MAX2D
        return
      end if
      do ifr=1,nframe
        call readbitc(ires(1,ifr),ibframe,nbondcorr,30,MAXITEMS)
        if (iaggregate .gt. 0) then
c         Aggregate the bonds to res-res interaction
          call zeroiti(itemp,0,ncorr)
          do ib=1,nbondcorr
            ibb=ihbtores(ib)
            if (ibframe(ib)*ibb .gt. 0) itemp(ibb)=1
          end do
          call trnsfi(ibframe,itemp,ncorr)
        end if
        if (icorrtyp .eq. 3) then
          do ib=1,ncorr
            itempsum(ib)=itempsum(ib)+ibframe(ib)
          end do
        end if
        do ib=1,ncorr
          if (ibframe(ib) .eq. 1 .and. ifirstframe(ib) .eq. 0)
     -      ifirstframe(ib)=ifr 
          nng(ib)=nng(ib)+ibframe(ib)
        end do
c       Accumulate scalar product
        do ib1=2,ncorr
          do ib2=1,ib1-1
            if (icorrbothstart .eq. 0) then
               iuseib12=ifirstframe(ib1)+ifirstframe(ib2)
            else
               iuseib12=ifirstframe(ib1)*ifirstframe(ib2)
            end if
            if (iuseib12 .gt. 0) then
              if (icorrtyp .lt. 3) then
                icorr=ibframe(ib1)*ibframe(ib2)
                if (icorrtyp .eq. 1) then
c                 Both on and off states are correlated
                  icorr=icorr+(1-ibframe(ib1))*(1-ibframe(ib2))
                end if
                ing(ib1,ib2)=ing(ib1,ib2)+icorr
                ing(ib2,ib1)=ing(ib2,ib1)+1
              else if (mod(ifr,nframeav) .eq. 0) then
                icorr=itempsum(ib1)*itempsum(ib2)
                ing(ib1,ib2)=ing(ib1,ib2)+icorr
                ing(ib2,ib1)=ing(ib2,ib1)+1
              end if
            end if
          end do
        end do
        if (icorrtyp .eq. 3) then
          if (mod(ifr,nframeav) .eq. 0) call zeroiti(itempsum,0,ncorr)
        end if
        if (nframe .ge. 1000 .and. mod(ifr,nframe10) .eq. 0)
     -    write (6,1000) ifr/nframe10
      end do
c     Prepare the distance measure matrix
      scp=0.0
      do ib1=2,ncorr
        do ib2=1,ib1-1
          if (icorrtyp .eq. 1 .or. icorrtyp .eq. 2) then
            scp=float(ing(ib1,ib2))/float(ing(ib2,ib1))
          else if (icorrtyp .eq. 3) then
c           Average states
            scp=float(ing(ib1,ib2))/float(ing(ib2,ib1)*nframeav**2)
          end if
          if (scp .lt. 0.0 .or. scp .gt. 1.0)
     -      write (iout,1003) ib1,ib2,ing(ib1,ib2),ing(ib2,ib1),scp
          if (icorrtrans .eq. 1) then 
            scp=(1.0-scp)**correxp
          else if (icorrtrans .eq. 2) then
            scp=(amin1(1.0/scp,99.0))**correxp
          else  
            scp=scp**correxp
          end if
c          if (iaggregate .eq. 1)
c     -      write (iout,8781) ib1,ib2,ing(ib1,ib2),ing(ib2,ib1),scp
c8781      format(' IB1,2=',2i6,' ing(ib1,ib2)=',i6,
c     -      ' ing(ib2,ib1)=',i6,' scp=',f10.5)
          rmsd2d(ib1,ib2)=scp
          rmsd2d(ib2,ib1)=scp
          if (scp .lt. scpmin) scpmin=scp
          if (scp .gt. scpmax) scpmax=scp
        end do
      end do
      if (imatprint .eq. 1) then
        if (iaggregate .eq. 0) write (iout,1007) ' '
        if (iaggregate .eq. 1) write (iout,1007) 'residue-aggregated'
        do ib1=1,ncorr
          write (iout,1006) ib1,(rmsd2d(ib1,ib2),ib2=1,ncorr)
        end do
      end if
c      write (iout,8791) (nng(i),i=1,ncorr)
c      write (iout,8792) (ifirstframe(i),i=1,ncorr)
c8791  format(' NNG:',10i6)
c8792  format(' IFF:',10i6)
      return
1000  format(i2,'0 % done')
1001  format(/,' Calculating correlation between bond histories for ',
     -  'clustering the bonds')
1002  format(' Negative number -n for exponent will be changed to ',
     -  '1/n')
1003  format(' PROGRAM ERROR: ib1,2=',2i6,' ing(ib1,ib2)=',i6,
     -  ' ing(ib2,ib1)=',i6,' scp=',f10.5)
1004  format(' Correlation calculations require at least 2 bonds',/,
     -  ' but there is only ',i2,' left')
1005  format(' ERROR: Bond correlation calculation is limited to ',i5,
     -  ' bonds',/,8x,'- recompile Simulaid wit increased MAX2D')
1006    format(' IB1=',i4,' RMSD2D:',15f5.2,/,(15f5.2))
1007  format(' The',a,'bond correlation matrix')
1008  format(' # of frames to average over should be < # of frames (',
     -  i6,')')
      end
      subroutine bondcorrprint(nhbcorr,iout,line,index,iresno,indexbond,
     -  correxp,icorrtyp,icorrtrans,nframeav,nhbdist,nhbpers,itrackf,
     -  itrackl,
     -  maxlenon,maxlenoff,iframeunit,framefac,ifhbclust,ilhbclust,
     -  ixhbclst,rclust,nclust,iclust,inamcol1,inamcol2,irescol1,
     -  irescol2,filename,lfilename,nhneigmin,hblimfac,angmin,
     -  rhph_sltbmax,percmin,percmax,minresdist,maxresdist,numres,
     -  icorrp,nframe,bondname,lbondname,icontract,ixresno,resnames,
     -  iuselaston,maxrec,mxbonds)
      dimension iresno(maxrec),index(maxrec),indexbond(mxbonds),
     -  nhbdist(mxbonds),nhbpers(mxbonds),itrackf(mxbonds),
     -  itrackl(mxbonds),
     -  maxlenon(mxbonds),maxlenoff(mxbonds),ifhbclust(mxbonds),
     -  ilhbclust(mxbonds),ixhbclst(mxbonds),ixresno(maxrec)
      character*(*) filename,bondname
      character*132 line(maxrec)
      character*8 resnames(maxrec)
      parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
      parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
     -  (9*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
      common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),ing(MAX2D,MAX2D),
     -  ihbpair(2,MAXBONDS),ihb_pair_res(3,MAXBONDS),ihbtores(MAXBONDS),
     -  iusepair(MAXBONDS),ibond(MAXBONDS),a1(MAXBONDS),fill(IFILL2)
      dimension i12(2),ihistogram(10)
      character*1 corb
      character*8 aname(2),rname(2)
c     print *,'BONDCORRP nclust,nhbcorr,iclust,bondname=',
c    -  nclust,nhbcorr,iclust,bondname(1:lbondname)
      if (nhbcorr .gt. MAX2D) then
        print *,'PROGRAM ERROR: nhbcorr=',nhbcorr,' MAX2D=',MAX2D
        return
      end if
      lan=inamcol2-inamcol1+1
      lrn=irescol2-irescol1+1
      if (iclust .eq. 0) write (iout,1026) bondname(1:lbondname)
      if (iclust .eq. 1) write (iout,1013) bondname(1:lbondname)
      if (icorrtyp .eq. 1) write (iout,1014)
      if (icorrtyp .eq. 2) write (iout,1015)
      if (icorrtyp .eq. 3) write (iout,1017) nframeav
      if (icorrtrans .eq. 1) write (iout,1018) correxp
      if (icorrtrans .eq. 2) write (iout,1019) correxp
      if (icorrtrans .eq. 3) write (iout,1020) correxp
      write (iout,1004) filename(1:lfilename)
      if (bondname(1:8) .eq. 'hydrogen') then
        write (iout,1010) hblimfac,angmin
      else if (bondname(1:11) .eq. 'hydrophobic') then
        write (iout,1011) bondname(1:11),rhph_sltbmax,' ',nhneigmin
      else if (bondname(1:11) .eq. 'salt-bridge') then
        write (iout,1011) bondname(1:11),rhph_sltbmax
      end if
      nprint=0
      if (percmin .gt. 0.0 .or. percmax .lt. 100.0) then
        write (iout,1006) bondname(1:lbondname),percmin,percmax
        nprint=1
      end if
      if (minresdist .gt. 1 .or. maxresdist .lt. numres-1) then
        write (iout,1007) bondname(1:lbondname),minresdist,maxresdist
        nprint=1
      end if
      if (nprint .eq. 0) write (iout,1005) bondname(1:lbondname)
      if (iclust .gt. 0) then
        if (rclust .gt. 0.0)  write (iout,1003) rclust
        nclp=nclust
      else
        nclp=1
        ifhbclust(1)=1
        ilhbclust(1)=nhbcorr
      end if
      maxhbtype=0
      minhbtype=nframe
      scpmax=0.0
      scpmin=1.0
      if (icorrtrans .ne. 2) then
        scpmaxp=1.0
      else 
        scpmaxp=5.0
        if (correxp .gt. 1.0) scpmaxp=10.0
      end if
      call zeroiti(ihistogram,0,10)
      do ib=1,nhbcorr
        nhbd=nhbdist(indexbond(ib))
        if (nhbd .gt. maxhbtype) maxhbtype=nhbd
        if (nhbd .lt. minhbtype) minhbtype=nhbd
        do ibb=2,ib
          if (icontract .eq. 0) then
            scp=rmsd2d(indexbond(ib),indexbond(ibb))
          else
            scp=rmsd2d(ixhbclst(ib),ibb)
          end if
          if (scpmax .lt. scp) scpmax=scp
          if (scpmin .gt. scp) scpmin=scp
          ix=10*abs(scp-1.e-6)/scpmaxp+1
          if (ix .gt. 10) ix=1
          ihistogram(ix)=ihistogram(ix)+1
        end do
      end do
      write (6,1016) scpmin,scpmax
      write (iout,1016) scpmin,scpmax
      write (6,1008) scpmaxp,
     -   (float(ihistogram(i))/float((nhbcorr*(nhbcorr-1))/2),i=1,10)
      write (iout,1008) scpmaxp,
     -   (float(ihistogram(i))/float((nhbcorr*(nhbcorr-1))/2),i=1,10)
      ihb=0
      corb=':'
      if (icorrp .eq. 0) corb=' '
c      write (iout,9877) (indexbond(i),i=1,nhbcorr)
c9877  format(' INDEXBOND:',/,(20i3))
      if (icontract .eq. 0) call persistence(1,1,1,1,1,1,iframeunit,
     -  framefac,nframe,1,iuselaston,0,iout)
      do ic=1,nclp
        if (iclust .eq. 1) then
          write (iout,1012) ic,ilhbclust(ic)-ifhbclust(ic)+1
          call findbestcorrep(iout,ifhbclust(ic),ilhbclust(ic),
     -      indexbond,mxbonds)
        end if
        if (icontract .eq. 0) write (iout,1022) bondname(1:lbondname)
        if (icontract .eq. 1) write (iout,1023)
        if (icorrp .gt. 0) write (iout,1024)
        do ib=ifhbclust(ic),ilhbclust(ic)
          ihb=ihb+1
          if (icorrp .eq. 1) write (iout,*)
          ib1=indexbond(ib)
          if (icontract .eq. 0) then
            do i=1,2
              i12(i)=ihbpair(i,ib1)
              aname(i)(1:lan)=line(index(i12(i)))(inamcol1:inamcol2)
              rname(i)(1:lrn)=line(index(i12(i)))(irescol1:irescol2)
            end do
            write (iout,1001) ib,ib1,(i12(i),
     -        aname(i)(1:lan),iresno(i12(i)),rname(i)(1:lrn),i=1,2),
     -        float(100*nhbdist(ib1))/float(nframe),corb
            call persistence(nhbdist(ib1),nhbpers(ib1),itrackf(ib1),
     -        itrackl(ib1),maxlenon(ib1),maxlenoff(ib1),iframeunit,
     -        framefac,nframe,0,iuselaston,0,iout)
          else
            ixr1=ihb_pair_res(1,ib1)
            ixr2=ihb_pair_res(2,ib1)
            ir1=ixresno(ixr1)
            ir2=ixresno(ixr2)
            call lastchar(resnames(ixr1),lc1,8)
            call lastchar(resnames(ixr2),lc2,8)
            write (iout,1025) ixhbclst(ib),ib1,resnames(ixr1)(1:lc1),
     -        ir1,resnames(ixr2)(1:lc2),ir2
          end if
          if (icorrp .eq. 1) then
            if (icontract .eq. 0) then
              if (icorrtrans .eq. 2) then
                write (iout,1021)
     -            (rmsd2d(ib1,indexbond(ib2)),ib2=1,nhbcorr)
              else
                write (iout,1009)
     -            (rmsd2d(ib1,indexbond(ib2)),ib2=1,nhbcorr)
              end if
            else
              if (icorrtrans .eq. 2) then
                write (iout,1021)
     -            (rmsd2d(ixhbclst(ib),ib2),ib2=1,nhbcorr)
              else
                write (iout,1009)
     -            (rmsd2d(ixhbclst(ib),ib2),ib2=1,nhbcorr)
              end if
              if (icorrtrans .eq. 1) then
                do ib2=1,nhbcorr
                 if (rmsd2d(ixhbclst(ib),ib2) .lt. 0.0 .or.
     -               rmsd2d(ixhbclst(ib),ib2) .gt. 1.0) write (iout,*)
     -             'ib2=',ib2,' rmsd2d=',rmsd2d(ixhbclst(ib),ib2)
                end do
              end if
            end if
          end if
        end do
        if (nclp .gt. 1) write (iout,1002) ic
      end do
      return
1001  format(' F#',i5,' (',i4,'):',i6,1x,a,i6,1x,a,' -',
     -  i6,1x,a,i6,1x,a,' occ=',f6.2,'% ',a)
1002  format(1x,23('='),' End of cluster ',i4,1x,30('='))
1003  format(' Clustered with Rclust=',f5.3)
1004  format(' Trajectory file (source of correlations): ',a)
1005  format(' All ',a,' bonds are included')
1006  format(' Filtered list: ',a,' bonds are included only when ',/,
     -  5x,'their occurrence is in the range [',f5.1,' - ',f6.1,'] %')
1007  format(' Filtered list: ',a,' bonds are included only when ',/,
     -  5x,'their interresidue number difference is in the range [',i5,
     -  ' - ',i5,'] residues')
1008  format(' Histogram of distance measures (10% bins in the 0 - ',
     -  f4.1,' range):',/,10f6.3,/)
1009  format(15f5.2)
1010  format(' Hydrogen-bonds thresholds: hblimfac=',f5.2,
     -  ' and H-bond angle minimum=',f5.1)
1011  format(' Distance threshold for ',a,'bond=',f5.2,a,/,' Minimum ',
     -  'number of bonded hydrogens for a hydrophobic carbon=',i1)
1012  format(' Cluster ',i4,' number of members:',i5)
1013  format(' Clustering results of ',a,' bonds based on correlation')
1014  format(' Correlation measure: CORR=(HB1.HB2)+(1-HB1).(1-HB2) ',
     -  '(include the off states)')
1015  format(' Correlation measure: CORR=(HB1.HB2) (correlate only the',
     -  '  off states')
1016  format(' Range of the distance measure values:',
     -  ' [',f5.2,' - ',f8.2,']')
1017  format(' Correlations are calculated using a running average ',
     -  'over',i4,' windows')
1018  format(' Distance measure: the correlation complement power ',
     -  '(1-CORR)^(',f5.3,')')
1019  format(' Distance measure: the correlation inverse power ',
     -  '(1/CORR)^(',f5.3,')')
1020  format(' Distance measure: the correlation power CORR^(',f5.3,')')
1021  format(15f5.1)
1022  format(1x,a,' bond# (original #)')
1023  format(' res-res# (original #)')
1024  format(' Correlation measures in each row refer to the ',
     -  'unclustered order')
1025  format(' RR#',i5,' (',i5,') ( ',a,i4,' - ',a,i4,')')
1026  format(' Correlation based distance matrix of ',a,' bonds')
      end
      subroutine plotbondcorr(ips,nbonds,yclab,lyclab,icontract,
     -  indexbond,title,temp,itemp,lablim,ncolcode,maxcolcode,igl,
     -  ipspage,ipsclose)
      parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
      parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
     -  (9*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
      dimension temp(MAX2D),itemp(MAX2D),indexbond(MAX2D)
      character*(*) yclab(nbonds)
      character*80 title
      common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),ing(MAX2D,MAX2D),
     -  ihbpair(2,MAXBONDS),ihb_pair_res(3,MAXBONDS),ihbtores(MAXBONDS),
     -  iusepair(MAXBONDS),ibond(MAXBONDS),a1(MAXBONDS),fill(IFILL2)
      character*200 trajnam,trajnam2
      common /trajname/ trajnam,trajnam2,ltrajnam,ltrajnam2
      dimension kc(1,1)
      real*8 dc(1,1)
      character*200 trajnameplot
      if (nbonds .lt. lablim) then
        nyclab=nbonds
      else
        nyclab=1
        lyclab=1
      end if
      inc=max0(1,500/nbonds)
      ixdel0=25
      iydel0=100
      ixdel=25
      iydel=200
      do i=1,MAX2D
        temp(i)=i
        itemp(i)=i
      end do
      lp=53+ltrajnam
      trajnameplot(1:lp)=
     -  'Bond correlation distance measure matrix Trajectory: '//
     -  trajnam(1:ltrajnam)
      call plotmat(ips,kc,rmsd2d,dc,nbonds,nbonds,0,0,0,0,1,1,
     -  ixdel0,iydel0,0,iytop,0.0,1.0,ncolcode,maxcolcode,ixdel,iydel,
     -  inc,1.0,itemp,indexbond,indexbond,title,80,trajnameplot,lp,' ',
     -  1,temp,yclab,nyclab,lyclab,igl,1,MAX2D,1,MAX2D,MAX2D,ipspage,
     -  ipsclose)
      if (icontract .eq. 1) then
        call pswrite(ips,ixdel0,iytop,'m',1)
        write (ips,*)
     -   '(Bond tracks contracted to residue-residue tracks) show'
        iytop=iytop+20
      end if
      iydel=iydel-50
      ixcent=max0(0,(nbonds*inc-50*ncolcode)/2)
      call colcodeminmax(ips,25+ixcent,-iydel-5,0,ncolcode,
     -  maxcolcode,0.0,1.0)
      write (ips,1000) 'showpage'
      return
1000  format(a)
      end
      subroutine printbonddist(nframe,nbfound,nhbdist,index2d,ianc_anc,
     -  naabond,iout,bondtype,lbondtype,maxbondcount,maxhb)
      dimension nhbdist(maxhb),index2d(maxhb),ianc_anc(maxhb)
      character*(*) bondtype
      dimension nhbhist(10)
      maxbondcount=0
      minbondcount=nframe
      nbondsum=0
      naabond=0
      do ib=1,nbfound
        nhbd=nhbdist(index2d(ib))
        if (nhbd .gt. maxbondcount) maxbondcount=nhbd
        if (nhbd .lt. minbondcount) minbondcount=nhbd
        nbondsum=nbondsum+nhbd
        naabond=naabond+ianc_anc(ib)
      end do
      call zeroiti(nhbhist,0,10)
      do ib=1,nbfound
        ix=(10*nhbdist(index2d(ib))-1)/maxbondcount+1
        nhbhist(ix)=nhbhist(ix)+1
      end do
      write (6,2000) bondtype(1:lbondtype),nbfound,maxbondcount
      write (6,2001) bondtype(1:lbondtype),naabond
      write (iout,2001) bondtype(1:lbondtype),naabond
      write (6,2003) bondtype(1:lbondtype),float(nbondsum)/float(nframe)
      write (iout,2003) bondtype(1:lbondtype),
     -  float(nbondsum)/float(nframe)
      write (6,2002) nframe,minbondcount,maxbondcount,
     -  (nhbhist(i),i=1,10)
      write (iout,2002) nframe,minbondcount,maxbondcount,
     -  (nhbhist(i),i=1,10)
      return
2000  format(' Number of ',a,'-bond types found=',i5,/,
     -  ' Most persistent bond was present in ',i6,' configurations')
2001  format(' Number of anchor-anchor ',a,' bonds found=',i6)
2002  format(' Histogram of the number of frames a bond is present ',
     -  'over',i7,' configurations',/,
     -  ' (10% intervals of [',i5,' - ',i5,'] range:',/,10i7)
2003  format(' Total number of ',a,' bonds / number of frames=',f7.1)
      end
      subroutine finalizebonds(n,nbfound,nbfoundorig,nbresfound,iw0,iw1,
     -  numres,npspages,ipspage,nres2d,ifirstframe,ilastframe,ibondcorr,
     -  iresbondcorr,nhneigmin,hblimfac,angmin,rhph_sltbmax,inamcol1,
     -  inamcol2,irescol1,irescol2,ifhb2d,ilhb2d,nhbdist,iframeunit,
     -  framefac,title,ltitle,trajnam,ltrajnam,xtrajlab,lxtrajlab,xtraj,
     -  value,ifa_s,ila_s,ih,cv,temp,index,iresno,ifres,isegno,atnames,
     -  resnames,ixres,ixresno,ixsegno,indexa,indexs,index2d,ianc_anc,
     -  isc,ixclst,irepav,irepmx,irepeng,irepkm,rmsdlim,engcl,it1,it2,
     -  it3,it4,it5,irrix,itemp1,itemp2,itemp3,nrrbond,line,bondtype,
     -  lbondtype,ibondtype,label2d,iselfanc,ianchor2,iresshift,igl,
     -  ifailbond,ncolcode,maxcolcode,maxbondcount,mxbonds,maxrsd,
     -  maxfrm,maxrec,mx2d)
      dimension index(maxrec),iresno(maxrec),ifres(maxrec),
     -  isegno(maxrec),ixres(maxrec),ixresno(maxrsd),ixsegno(maxrsd),
     -  indexs(maxrec),index2d(mxbonds),ianc_anc(mxbonds),engcl(mx2d),
     -  it1(mxbonds),it2(mxbonds),it3(mxbonds),it4(mxbonds),
     -  it5(mxbonds),irrix(maxrec),itemp1(maxrec),itemp2(maxrec),
     -  itemp3(maxrec),nrrbond(mxbonds),ifhb2d(mxbonds),ilhb2d(mxbonds),
     -  irepav(mx2d),irepmx(mx2d),irepeng(mx2d),irepkm(mx2d),
     -  nhbdist(mxbonds),value(mxbonds),ifa_s(mxbonds),ila_s(mxbonds),
     -  ih(maxrec),cv(maxrec),temp(maxrec),isc(maxrec),ixclst(mxbonds),
     -  rmsdlim(mxbonds),indexa(maxrec),xtraj(maxfrm)
      character*8 atnames(maxrec),resnames(maxrsd)
      character*80 title,label2d(mx2d),label
      character*(*) xtrajlab
      character* 132 line(maxrec)
      character*(*) trajnam,bondtype
      parameter (MAXFRAMES=50000,MAXCOPY=600)
      parameter (MAXCOPY1=MAXCOPY-1)
      common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
     -  increment,increment2,res(2,MAXFRAMES,MAXCOPY1),
     -  scres(2,MAXFRAMES),x0(MAXCOPY),y0(MAXCOPY),nxselres,
     -  ixselres(MAXCOPY)
      parameter (MAXBONDS=10000)
      character*37 yclab(MAXBONDS)
      dimension nhbpers(MAXBONDS),itrackf(MAXBONDS),itrackl(MAXBONDS),
     -  maxlenon(MAXBONDS),maxlenoff(MAXBONDS)
      dimension c(3,1),ct1(3,1),ct2(3,1)
      character*80 plotlab,aucfile
      if (ifailbond .ne. 0) return
      if (nbfound .eq. 0) then
        write (6,2001)
        write (iw0,2001)
        return
      end if
c     Turn on sorting in clique clustering
      nosortindex2d=0
      lablim=50
      icorrtyp=0
      icorrtrans=0
      call zeroiti(nhbpers,0,MAXBONDS)
      call zeroiti(itrackf,0,MAXBONDS)
      call zeroiti(itrackl,0,MAXBONDS)
      plotlab(1:lbondtype)=bondtype(1:lbondtype)
      plotlab(lbondtype+1:lbondtype+7)=' bond #'
      lplotlab=lbondtype+7
c     print *,'FINALIZEBOND nbfound,nframe,ianchor2,nbresfound=',
c    -  nbfound,nframe,ianchor2,nbresfound
c     print *,'Number of ',bondtype(1:lbondtype),' bonds found=',nbfound
      if (nbfound .eq. 0) return
      icorrbothstart=0
      call askyn('Do you want to end the track statistics at '//
     -  'the last on frame',60,1,-1,iuselaston,135)
      if (ibondcorr+iresbondcorr .gt. 0) 
     -  call askyn('Do you want to correlate only after both '//
     -    'tracks started',55,1,-1,icorrbothstart,136)
      call trackstat(nbfound,nhbdist,nhbpers,maxlenon,maxlenoff,
     -  itrackf,itrackl,it1,it2)
8005  call indexit(index2d,1,nbfound,0)
      call printbonddist(nframe,nbfound,nhbdist,index2d,ianc_anc,
     -  naabond,iw0,bondtype,lbondtype,maxbondcount,mxbonds)
      nbfoundorig=nbfound
      call filterbonds(n,nbfound,nhbdist,nhbpers,itrackf,itrackl,
     -  maxlenon,maxlenoff,iframeunit,framefac,nframe,index2d,bondtype,
     -  lbondtype,line,index,inamcol1,inamcol2,irescol1,irescol2,iresno,
     -  isegno,ixres,ixresno,ixsegno,ifres,numres,ianc_anc,isc,bondtype,
     -  lbondtype,percmin,percmax,minresdist,maxresdist,nochange,cv,
     -  iuselaston,iaucw,temp,it1,it2,it3,it4,irrix,itemp2,iw0,igl,
     -  maxrec,maxrsd,mxbonds,MAXFRAMES,MAXCOPY)
c     cv contains the % of frames an atom is forming a bond
      call makebondlab(1,nbfound,0,1,yclab,lyclab,irrix,ixresno,
     -  ixres,index2d,resnames,atnames,nbfound,mxbonds,maxrsd,maxrec)
      if (iaucw .gt. 0) then
        call getname(aucfile,laucfile,'Name of the AUC file',20,80,000)
        call print_auc(aucfile,laucfile,nbfound,nframe,yclab,lyclab)
        write (6,2002) aucfile(1:laucfile)
        write (iw0,2002) aucfile(1:laucfile)
      end if
      rhbcorrclust=0.0
      nhbcorrclust=1
      distmax=rhph_sltbmax
      if (bondtype(1:8) .eq. 'hydrogen') distmax=0.0
c     print *,'FINALIZEB Plotting the ',bondtype(1:lbondtype),' bonds'
      call plotbond(iw1,nbfoundorig,nbfound,nbresfound,nhbcorrclust,
     -  ianc_anc,ifhb2d,ilhb2d,index2d,indexs,it1,it2,rhbcorrclust,0,
     -  xtraj(nframe),10,title,ltitle,xtrajlab,lxtrajlab,ifirstframe-1,
     -  plotlab,lplotlab,0,percmin,percmax,numres,minresdist,maxresdist,
     -  distmax,bondtype,lbondtype,0,nhneigmin,nbondmax,naabondmax,
     -  icorrtyp,icorrtrans,nframeav,correxp,hblimfac,angmin,lablim,
     -  ibondtype,1,0,it3,it4,trajnam,ltrajnam,ixresno,itemp3,ixres,
     -  nrrbond,atnames,resnames,npspages,ipspage,mxbonds,maxrsd,maxrec)
c     Plot the total # of bonds for succesive frames
      call roundlimint(naabondmax+1,iyd2,nyd2)
      call roundlimint(nbondmax+1,iyd,nyd)
      nplot=2
      iyinc=0
      if (iselfanc .eq. 0 .or. ianchor2 .eq. 1
     -   .or. naabond .eq. nbfoundorig) then
        nplot=1
        if (iselfanc .eq. 1) iyinc=1
      end if
      llabel=16+lbondtype
      label(1:llabel)='Number of '//bondtype(1:lbondtype)//' bonds'
      call plot2fun(iw1,nplot,xtraj,scres,scres,nframe,0.0,0.0,0,0.0,
     -  float(iyd),nyd,0.0,float(iyd2),nyd2,title,80,' ',1,xtrajlab,
     -  lxtrajlab,label,llabel,'Number of anchor-anchor bonds',
     -  29,trajnam,ltrajnam,0,6,2,1,0,0,iyinc,0,ipspage,1,1,0)
      if (ibondcorr .gt. 0 .and. nbfoundorig .gt. mx2d) then
        write (6,2000) nbfoundorig,mx2d
        ibondcorr=0
      end if
      if (ibondcorr .gt. 0) then
c       Calculate, plot and print the dot product of bonds
        ireadwrite=1
        ifhb2d(1)=1
        ilhb2d(1)=nbfound
        call bondcorrsum(nbfoundorig,0,scpmin,scpmax,it1,it2,it3,it4,
     -    correxp,icorrtyp,icorrtrans,0,icorrbothstart,nframeav,0,
     -    iw0,igl,mx2d)
        call bondcorrprint(nbfound,iw0,line,index,iresno,index2d,
     -    correxp,icorrtyp,icorrtrans,nframeav,nhbdist,nhbpers,
     -    itrackf,itrackl,maxlenon,maxlenoff,iframeunit,framefac,
     -    ifhb2d,ilhb2d,ixclst,rhbcorrclust,nhbcorrclust,0,inamcol1,
     -    inamcol2,irescol1,irescol2,trajnam,ltrajnam,nhneigmin,
     -    hblimfac,angmin,rhph_sltbmax,percmin,percmax,minresdist,
     -    maxresdist,numres,1,nframe,bondtype,lbondtype,0,ixresno,
     -    resnames,iuselaston,maxrec,mxbonds)
        call plotbondcorr(iw1,nbfound,yclab,lyclab,0,index2d,
     -    title,temp,itemp2,lablim,ncolcode,maxcolcode,igl,ipspage,0)
        rhbcorrclustdef=(scpmax-scpmin)/2.0
        call clusterdistr(nbfound,iw0,rmsdlim,scpmin,scpmax,nhbdist,it1,
     -    it2,it3,it4,ifhb2d,ilhb2d,nhbcorrclust,indexa,index2d,
     -    ixclst,it5,value,ifa_s,ila_s,ih,temp,rhbcorrclustdef,
     -    rhbcorrclust,res(1,1,11),0,'Correlation-based distance',26,0,
     -    0,irepav,irepmx,irepeng,irepkm,engcl,c,ct1,ct2,1,27,
     -    iclstyp,nrrbond,1,label2d,80,0,1,nosortindex2d,1,igl,mxbonds,
     -    maxframe)
c       print *,'Plotting the clustered ',bondtype(1:lbondtype),' bonds'
        call plotbond(iw1,nbfoundorig,nbfound,nbresfound,nhbcorrclust,
     -    ianc_anc,ifhb2d,ilhb2d,index2d,indexs,it1,it2,rhbcorrclust,
     -    iclstyp,xtraj(nframe),10,title,ltitle,xtrajlab,lxtrajlab,
     -    ifirstframe-1,'Bond #',6,1,percmin,percmax,numres,minresdist,
     -    maxresdist,distmax,bondtype,lbondtype,1,nhneigmin,nbondmax,
     -    naabondmax,icorrtyp,icorrtrans,nframeav,correxp,hblimfac,
     -    angmin,lablim,ibondtype,1,0,it3,it4,trajnam,ltrajnam,ixresno,
     -    itemp3,ixres,nrrbond,atnames,resnames,npspages,ipspage,
     -    mxbonds,maxrsd,maxrec)
c       print *,'Printing the clustered ',bondtype(1:lbondtype),' bonds'
        call bondcorrprint(nbfound,iw0,line,index,iresno,index2d,
     -    correxp,icorrtyp,icorrtrans,nframeav,nhbdist,nhbpers,itrackf,
     -    itrackl,maxlenon,maxlenoff,iframeunit,framefac,ifhb2d,ilhb2d,
     -    ixclst,rhbcorrclust,nhbcorrclust,1,inamcol1,inamcol2,irescol1,
     -    irescol2,trajnam,ltrajnam,nhneigmin,hblimfac,angmin,
     -    rhph_sltbmax,percmin,percmax,minresdist,maxresdist,numres,0,
     -    nframe,bondtype,lbondtype,0,ixresno,resnames,iuselaston,
     -    maxrec,mxbonds)
        call askyn(
     -    'Do yo want to repeat clustering with different filters',
     -     54,1,-1,irepscan,0)
        if (irepscan .eq. 1) then
          nbfound=nbfoundorig
          go to 8005
        end if
      end if
      if (nochange .eq. 0) then
        call askyn(
     -    'Do yo want to use all bonds for the residue-residue plot',
     -     56,1,-1,iuseorig,83)
        if (iuseorig .eq. 1) then
          nbfound=nbfoundorig
          call indexit(index2d,1,nbfound,0)
        end if
      end if
      call res_res_bond(nres2d,nbfound,index2d,nhbdist,iresno,
     -  ixres,ifres,isegno,irrix,itemp2,itemp3,it4,temp,it1,value,
     -  ifa_s,ila_s,title,ltitle,bondtype,lbondtype,ifirstframe,
     -  ilastframe,line,index,irescol1,irescol2,iresshift,igl,
     -  iw0,iw1,ipspage,ncolcode,maxcolcode,mxbonds,maxrsd,maxrec)
      call mapbondstorespairs(nbfound,nbfoundorig,nbresfilt,nbresfound,
     -  index2d,ixres,resnames,ixresno,ixsegno,nofilt,irrix,itemp2,
     -  iw0,maxrsd,maxrec)
      call plotbond(iw1,nbfoundorig,nbfound,nbresfilt,nhbcorrclust,
     -  ianc_anc,ifhb2d,ilhb2d,index2d,indexs,it1,it2,rhbcorrclust,0,
     -  xtraj(nframe),10,title,ltitle,xtrajlab,lxtrajlab,ifirstframe-1,
     -  'Residue pair #',14,1,percmin,percmax,numres,minresdist,
     -  maxresdist,distmax,bondtype,lbondtype,0,nhneigmin,nbondmax,
     -  naabondmax,icorrtyp,icorrtrans,nframeav,correxp,hblimfac,angmin,
     -  lablim,ibondtype,2,nofilt,it3,it4,trajnam,ltrajnam,ixresno,
     -  irrix,ixres,nrrbond,atnames,resnames,npspages,ipspage,mxbonds,
     -  maxrsd,maxrec)
      if (iresbondcorr .gt. 0) then
        call bondcorrsum(nbfoundorig,nbresfilt,scpmin,scpmax,it1,it2,
     -    it3,it4,correxp,icorrtyp,icorrtrans,1,icorrbothstart,
     -    nframeav,1,iw0,igl,mx2d)
        call indexit(itemp1,1,nbresfilt,0)
        call makebondlab(1,nbresfilt,0,2,yclab,lyclab,irrix,ixresno,
     -    ixres,itemp1,resnames,atnames,nbresfilt,mxbonds,maxrsd,maxrec)
        call plotbondcorr(iw1,nbresfilt,yclab,lyclab,1,itemp1,title,
     -    temp,itemp2,lablim,ncolcode,maxcolcode,igl,ipspage,0)
        rhbcorrclustdef=(scpmax-scpmin)/2.0
        ifhb2d(1)=1
        ilhb2d(1)=nbresfound
        call clusterdistr(nbresfilt,iw0,rmsdlim,scpmin,scpmax,nhbdist,
     -    it1,it2,it3,it4,ifhb2d,ilhb2d,nhbcorrclust,indexa,irrix,
     -    ixclst,it5,value,ifa_s,ila_s,ih,temp,rhbcorrclustdef,
     -    rhbcorrclust,res(1,1,11),0,'Correlation-based distance',26,0,
     -    0,irepav,irepmx,irepeng,irepkm,engcl,c,ct1,ct2,1,27,
     -    iclstyp,nrrbond,1,label2d,80,0,1,nosortindex2d,0,igl,mxbonds,
     -    maxframe)
        call bondcorrprint(nbresfilt,iw0,line,index,iresno,irrix,
     -    correxp,icorrtyp,icorrtrans,nframeav,nhbdist,nhbpers,itrackf,
     -    itrackl,maxlenon,maxlenoff,iframeunit,framefac,ifhb2d,ilhb2d,
     -    ixclst,rhbcorrclust,nhbcorrclust,1,inamcol1,inamcol2,irescol1,
     -    irescol2,trajnam,ltrajnam,nhneigmin,hblimfac,angmin,
     -    rhph_sltbmax,percmin,percmax,minresdist,maxresdist,numres,1,
     -    nframe,bondtype,lbondtype,1,ixresno,resnames,iuselaston,
     -    maxrec,mxbonds)
        call plotbond(iw1,nbfoundorig,nbfound,nbresfilt,nhbcorrclust,
     -    ianc_anc,ifhb2d,ilhb2d,ixclst,indexs,it1,it2,rhbcorrclust,
     -    iclstyp,xtraj(nframe),10,title,ltitle,xtrajlab,lxtrajlab,
     -    ifirstframe-1,'Residue pair #',14,1,percmin,percmax,numres,
     -    minresdist,maxresdist,distmax,bondtype,lbondtype,0,nhneigmin,
     -    nbondmax,naabondmax,icorrtyp,icorrtrans,nframeav,correxp,
     -    hblimfac,angmin,lablim,ibondtype,2,nofilt,it3,it4,trajnam,
     -    ltrajnam,ixresno,irrix,ixres,nrrbond,atnames,resnames,
     -    npspages,ipspage,mxbonds,maxrsd,maxrec)
        return
      end if
      return
2000  format(' ERROR: the number of bonds found (',i5,') exceeds the',
     -  ' limit (',i5,')',/,' either increase the parameter MAX2D and ',
     -  ' recompile Simulaid',/,' or select fewer atoms to analyze')
2001  format(' NOTE: no bonds were found')
2002  format(' Full autocorrelation functions were written to file',/,
     -  1x,a)
      end
      subroutine mapbondstorespairs(nbfound,nbfoundorig,nbresfound,
     -  nbresorig,index,ixres,resnames,ixresno,ixsegno,iuseallbonds,
     -  irrix,itemp1,iout,maxrsd,maxrec)
      dimension index(maxrec),ixres(maxrec),ixresno(maxrsd),
     -  ixsegno(maxrsd),irrix(maxrsd),itemp1(maxrec)
      character*8 resnames(maxrsd)
      parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
      parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
     -  (9*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
      common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),ing(MAX2D,MAX2D),
     -  ihbpair(2,MAXBONDS),ihb_pair_res(3,MAXBONDS),ihbtores(MAXBONDS),
     -  iusepair(MAXBONDS),ibond(MAXBONDS),a1(MAXBONDS),fill(IFILL2)
c     print *,'MAPBONDSTORESPAIRS NBFOUND,NBRESFOUND,NBRESORIG=',
c    -  nbfound,nbresfound,nbresorig
      write (6,1005)
      call askyn('Do you want to use the full bond list',37,1,-1,
     -  iuseallbonds,00)
      nbuse=nbfound
      if (iuseallbonds .eq. 1) nbuse=nbfoundorig
      call zeroiti(ihbtores,0,nbfoundorig)
      call zeroiti(iusepair,0,nbresorig)
      call indexit(itemp1,1,nbresorig,0)
      do ibb=1,nbuse
        if (iuseallbonds .eq. 1) then
          ib=ibb
        else
          ib=index(ibb)
        end if
        ir1=ixres(ihbpair(1,ib))
        ir2=ixres(ihbpair(2,ib))
        do irr=1,nbresorig
          if (ihb_pair_res(1,irr) .eq. ir1) then
            if (ihb_pair_res(2,irr) .eq. ir2) then
              ihbtores(ib)=irr
              iusepair(irr)=iusepair(irr)+1
              go to 100
            end if
          end if
        end do
        write (6,1000) (ihbpair(k,ib),k=1,2),ir1,ir2
        write (iout,1000) (ihbpair(k,ib),k=1,2),ir1,ir2
100     continue
      end do
c      write (iout,8711) (ihbtores(i),i=1,nbuse)
c8711  format(' IHBTORES:',/,(15i5))
      write (iout,1001) ' filtered out from '
      nrr=0
      do irr=1,nbresorig
        if (iusepair(irr) .eq. 0) then
          ir1=ihb_pair_res(1,irr)
          ir2=ihb_pair_res(2,irr)
          call lastchar(resnames(ir1),lc1,8)
          call lastchar(resnames(ir2),lc2,8)
          write (iout,1002) nrr,irr,ixsegno(ir1),resnames(ir1)(1:lc1),
     -      ixresno(ir1),ixsegno(ir2),resnames(ir2)(1:lc2),ixresno(ir2),
     -      iusepair(irr)
        end if
      end do
      write (iout,1001) ' that belong to '
      ndel=0
      nrr=0
      do irr=1,nbresorig
        if (iusepair(irr) .gt. 0) then
          ir1=ihb_pair_res(1,irr)
          ir2=ihb_pair_res(2,irr)
          call lastchar(resnames(ir1),lc1,8)
          call lastchar(resnames(ir2),lc2,8)
          itemp1(irr)=itemp1(irr)-ndel
          nrr=nrr+1
          irrix(nrr)=irr
          write (iout,1002) nrr,irr,ixsegno(ir1),resnames(ir1)(1:lc1),
     -      ixresno(ir1),ixsegno(ir2),resnames(ir2)(1:lc2),ixresno(ir2),
     -      iusepair(irr)
        else
          if (iuseallbonds .eq. 1) then
            write (6,1003)
          else
            ndel=ndel+1
          end if
        end if
      end do
      if (ndel .gt. 0) then
        write (6,1004) ndel
        write (iout,1004) ndel
        do ib=1,nbfoundorig
          if (ihbtores(ib) .gt. 0) ihbtores(ib)=itemp1(ihbtores(ib))
        end do
      end if
      nbresfound=nbresorig-ndel
c      write (6,8712) (irrix(i),i=1,nbresfound)
c8712  format(' IRRIX:',/,(15i5))
      return
1000  format(' PROGRAM ERROR: bond between atoms',i6,i7,' (residue ',
     -  'indices',i5,i6,')'/,' is not found in the residue pair list')
1001  format(' Residue pairs',a,'the contracted bond history plots')
1002  format(' Pair #',i4,'(',i4,'): C/S',i2,1x,a,i5,' - C/S',i2,1x,a,
     -  i5,' # of bonds:',i2)
1003  format(' PROGRAM ERROR: residue pair #',i4,/,
     -  ': res#',i5,' (',a,') - res#',i5,' (',a,') is not used by any ',
     -  ' bond')
1004  format(' Number of residue-residue pairs filtered out for the ',
     -  'aggregate plot=',i4)
1005  format(/,' Generating residue-contracted bond histories')
      end
      subroutine writetrack(iout_track,iout,nbits,ntracks,nres2d,
     -  trackfile,ltrackfile,trajname,ltrajname,ianc_anc)
      dimension ianc_anc(ntracks)
      character*(*) trackfile,trajname
      parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
      parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
     -  (9*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
      common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),ing(MAX2D,MAX2D),
     -  ihbpair(2,MAXBONDS),ihb_pair_res(3,MAXBONDS),ihbtores(MAXBONDS),
     -  iusepair(MAXBONDS),a1(MAXBONDS),a2(MAXBONDS),fill(IFILL2)
      parameter (MAXFRAMES=50000,MAXCOPY=600,MAXITEMS=2*MAXCOPY-2)
      common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
     -  increment,increment2,ires(MAXITEMS,MAXFRAMES),
     -  scres(2,MAXFRAMES),x0(MAXCOPY),y0(MAXCOPY),nxselres,
     -  ixselres(MAXCOPY)
      dimension itrack(MAXFRAMES)
      write (iout_track,1000) trajname(1:ltrajname)
      write (iout_track,1001)nframe,ntracks,nres2d
      do itr=1,ntracks
        call zeroiti(itrack,0,nframe)
        ii=(itr-1)/nbits+1
        ib=mod(itr-1,nbits)
        do ifr=1,nframe
          if (btest(ires(ii,ifr),ib)) itrack(ifr)=1
        end do
        write (iout_track,1006) itr,(ihbpair(k,itr),k=1,2),
     -    ianc_anc(itr),(itrack(ifr),ifr=1,nframe)
      end do
      write (iout,1002) trackfile(1:ltrackfile),nframe,ntracks
      close (iout_track)
      return
1000  format(a)
1001  format(3i7)
1002  format(' Bond tracks were written to file ',a,/,
     -  ' Number of frames=',i7,/,' Number of tracks=',i5)
1006  format(' TRACK#',i5,' ia1=',i7,' ia2=',i7,' iAA=',i1,/,(100i1))
      end
      subroutine readtrack(iout_track,iout,nbits,nbfound,nbresfound,
     -  nres2d,ixres,trackfile,ltrackfile,trajname,ltrajname,ianc_anc,
     -  ifail,maxrec)
      dimension ixres(maxrec),ianc_anc(nbfound)
      character*(*) trackfile,trajname
      parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
      parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
     -  (9*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
      common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),ing(MAX2D,MAX2D),
     -  ihbpair(2,MAXBONDS),ihb_pair_res(3,MAXBONDS),ihbtores(MAXBONDS),
     -  iusepair(MAXBONDS),itempres(MAXBONDS),a2(MAXBONDS),fill(IFILL2)
      parameter (MAXFRAMES=50000,MAXCOPY=600,MAXITEMS=2*MAXCOPY-2)
      common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
     -  increment,increment2,ires(MAXITEMS,MAXFRAMES),
     -  scres(2,MAXFRAMES),x0(MAXCOPY),y0(MAXCOPY),nxselres,
     -  ixselres(MAXCOPY)
      dimension itrack(MAXFRAMES)
      itr=0
      call blankout(trajname,1,80)
      read (iout_track,1000,end=888,err=888) trajname
      call lastchar(trajname,ltrajname,80)
      read (iout_track,1001,end=888,err=888) nframe,ntracks,nres2d
      nframetot=nframe
      nbfound=ntracks
      do itr=1,ntracks
        call zeroiti(itrack,0,nframe)
        read (iout_track,1004,end=888,err=888) itrr,
     -    (ihbpair(k,itr),k=1,2),ianc_anc(itr),
     -    (itrack(ifr),ifr=1,nframe)
        ii=(itr-1)/nbits+1
        ib=mod(itr-1,nbits)
        do ifr=1,nframe
          if (itrack(ifr) .eq. 1)
     -      ires(ii,ifr)=ibset(ires(ii,ifr),ib)
        end do
        ir1=ixres(ihbpair(1,itr))
        ir2=ixres(ihbpair(2,itr))
        ihb=1
        do while (ihb .le. nbresfound .and.
     -    (ir1 .ne. ihb_pair_res(1,ihb) .or.
     -     ir2 .ne. ihb_pair_res(2,ihb)))
          ihb=ihb+1
        end do
        if (ihb .gt. nbresfound) then
          nbresfound=nbresfound+1
          ihb_pair_res(1,nbresfound)=ir1
          ihb_pair_res(2,nbresfound)=ir2
          ihb_pair_res(3,nbresfound)=1
          ihb_pair_res(3,nbresfound+1)=0
          itempres(nbresfound)=1
        else if (itempres(ihb) .eq. 0) then
          ihb_pair_res(3,ihb)=ihb_pair_res(3,ihb)+1
          itempres(ihb)=1
        end if
      end do
      write (iout,1002) trackfile(1:ltrackfile)
      write (iout,1003) nframe,ntracks,nbresfound,trajname(1:ltrajname)
      write (6,1003) nframe,ntracks,nbresfound,trajname(1:ltrajname)
      close (iout_track)
      ifail=0
      return
888   if (itr .eq. 0) write (6,1005)
      if (itr .gt. 0) write (6,1006) itr
      return
1000  format(a)
1001  format(3i7)
1002  format(' Bond tracks were read from file ',a)
1003  format(' Number of frames=',i7,/,' Number of tracks=',i5,/,
     -  ' Number of residue-residue pairs=',i4,/,
     -  ' Trajectory scanned=',a)
1004  format(' TRACK#',i5,' ia1=',i7,' ia2=',i7,' iAA=',i1,/,(100i1))
1005  format(' ERROR reading the track file header')
1006  format(' ERROR reading track # ',i5)
      end
      subroutine writeconn(ioutpdb,ifres,ilres,line,index,inamcol1,
     -  inamcol2,c,n,iresbondcorr,nrrbond,nframe,iout,mxbonds,maxrsd,
     -  maxrec)
      dimension ifres(maxrsd),ilres(maxrsd),index(maxrec),c(3,maxrec),
     -  nrrbond(mxbonds)
      character* 132 line(maxrec)
      parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
      parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
     -  (9*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
      common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),ing(MAX2D,MAX2D),
     -  ihbpair(2,MAXBONDS),ihb_pair_res(3,MAXBONDS),ihbtores(MAXBONDS),
     -  iusepair(MAXBONDS),ibond(MAXBONDS),a1(MAXBONDS),fill(IFILL2)
      dimension cHe(3)
      lname=inamcol2-inamcol1+1
      if (lname .lt. 1) then
        print *,'PROGRAM ERROR inamcol1,2=',inamcol1,inamcol2
        stop
      end if
      nnoCA=0
      nrr=1
      nrw=0
      corrmax=0.0
      corrmin=1.0
      write (ioutpdb,1000) 'TER'
      do while (ihb_pair_res(1,nrr) .gt. 0 .and. nrr .le. MAXBONDS)
        if (iusepair(nrr) .gt. 0) then
          irr1=ihb_pair_res(1,nrr)
          call findCA(line,index,ifres(irr1),ilres(irr1),inamcol1,
     -      inamcol2,iCA1,nnoCA,maxrec)
          irr2=ihb_pair_res(2,nrr)
          call findCA(line,index,ifres(irr2),ilres(irr2),inamcol1,
     -      inamcol2,iCA2,nnoCA,maxrec)
          do k=1,3
            cHe(k)=(c(k,iCA1)+c(k,iCA2))/2.0
          end do
c          write (6,9782) nrr,irr1,irr2,iCA1,iCA2,iusepair(nrr)
c9782      format(i4,' irr1,2=',2i5,' iCA1,2=',2i6,' iusepair=',i2)
          nrw=nrw+1
          write (ioutpdb,1001) n+nrw,nrw,cHe,
     -      float(nrrbond(nrw))/float(nframe)
        end if
        nrr=nrr+1
      end do
      write (ioutpdb,1000) 'TER'
      if (iresbondcorr .eq. 1) then
        call askyn('Do you want to connect correlated bonds',39,1,-1,
     -    iconncorr,00)
        if (iconncorr .eq. 1) then
          call getreal(
     -      'Maximum correlation distance measure',36,1.0,corrmax,1,0)
          write (iout,2003) ' ','<',corrmax
          write (ioutpdb,2003) 'REMARK ','<',corrmax
        else
          call askyn('Do you want to connect anti-correlated bonds',44,
     -      1,-1,iconnacorr,00)
          if (iconnacorr .eq. 1) then
            call getreal(
     -        'Minimum correlation distance measure',36,1.0,corrmin,1,0)
            write (iout,2003) ' ','>',corrmin
            write (ioutpdb,2003) 'REMARK ','>',corrmin
          end if
        end if
c       Connect bonds where the correlation distance measure is > corrmax
c       or < corrmax
        do ir1=1,nrw
          do ir2=ir1+1,nrw
            if (rmsd2d(ir1,ir2) .gt. corrmin .or.
     -        rmsd2d(ir1,ir2) .lt. corrmax)
     -          write (ioutpdb,2001) n+ir1,n+ir2
          end do
        end do
      end if
      if (nnoCA .gt. 0) write (6,2000) nnoCA
      if (nnoCA .gt. 0) write (iout,2000) nnoCA
      write (iout,2002) nrr
      write (ioutpdb,1000) 'REMARK CA - CA bonds'
      do irr=1,nrr
        if (iusepair(irr) .gt. 0) then
          irr1=ihb_pair_res(1,irr)
          call findCA(line,index,ifres(irr1),ilres(irr1),inamcol1,
     -      inamcol2,iCA1,nnoCA,maxrec)
          irr2=ihb_pair_res(2,irr)
          call findCA(line,index,ifres(irr2),ilres(irr2),inamcol1,
     -      inamcol2,iCA2,nnoCA,maxrec)
          write (ioutpdb,2001) iCA1,iCA2
          write (iout,2004) irr1,irr2,iCA1,iCA2
        end if
      end do
      return
1000  format(a)
1001  format('ATOM',i7,' He   HE  ','X',i4,4x,3f8.2,1x,f5.3,' 0.000',
     -  11x,'He')
2000  format(' NOTE:',i4,' residues had no CA atom - first atom in ',
     -  'the residue is used')
2001  format('CONECT',2i5)
2002  format(' Number of CA-CA bonds created=',i4)
2003  format(a,' Bonds created between CA-CA pairs with correlation ',
     -  'measure ',a,f6.2)
2004  format(' CA - CA bonds between residues',i6,' and',i6,' (atom ',
     -  'numbers',2i7)
      end
      subroutine findCA(line,index,ifr,ilr,inamcol1,inamcol2,iCA,nnoCA,
     -  maxrec)
      dimension index(maxrec)
      character* 132 line(maxrec)
      character*8 aname
      iCA=0
      do ia=ifr,ilr
        aname(1:inamcol2-inamcol1+1)=line(index(ia))(inamcol1:inamcol2)
        if (aname(1:4) .eq. 'CA  ' .or. aname(1:4) .eq. ' CA ') iCA=ia
      end do
      if (iCA .eq. 0) then
        iCA=ifr
        nnoCA=nnoCA+1
      end if
      return
      end
      subroutine rmsdckp(iunit,ireadwrite)
      parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
      parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
     -  (4*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
      common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),ing(MAX2D,MAX2D),
     -  ihbpair(2,MAXBONDS),a1(MAXBONDS),ibond(MAXBONDS),fill(IFILL2)
      if (ireadwrite .eq. 1) then
        write (iunit) rmsd2d
      else
        read (iunit,end=999) rmsd2d
      end if
      return
999   print *,'ERROR: 2D-RMMSD checkpoint file was too short'
      stop
      end
      subroutine readint(line,icol1,icol2,intg,ihextyp)
      character*(*) line
      common /askhex/ iaskhex(4),ishex(4)
      character*1 tab,ctrlM
      common /tab/ tab,ctrlM
      common /logging/ logfile,ipredict
      character*14 inplab(4)
      data inplab /'atom number   ','residue number','residue id    ',
     -  'data          '/
c     ihextyp=1: atom #; ihextyp=2: residue #; inphextyp=4: everything else
      if (icol1 .gt. icol2) then
        write (6,2001) inplab(ihextyp),icol1,icol2,line(1:icol2)
        stop
      end if
      nchars=0
      do ic=icol1,icol2
        if (line(ic:ic) .ne. ' ' .and. line(ic:ic) .ne. tab)
     -    nchars=nchars+1
      end do
      if (nchars .eq. 0) then
c       Field was blank - return zero
        intg=0
      else if (ishex(ihextyp) .eq. 0) then
        read (line(icol1:icol2),*,ERR=100) intg
      else
c       Interpret string as hexadecimal
        intg=iconvhex(line(icol1:icol2),icol2-icol1+1)
      end if
      return
100   if (iaskhex(ihextyp) .eq. 1) then
c       Check if hexadecimal
        ishex(ihextyp)=ishexadecimal(line(icol1:icol2),icol2-icol1+1)
        if (ishex(ihextyp) .eq. 0) then
          write (6,2000) inplab(ihextyp),icol1,icol2,line
          stop
        else
          print *,'Input ',inplab(ihextyp),' appears to be hexadecimal'
          if (ipredict .eq. 0)
     -      call askyn('Is this correct',15,1,1,ishex(ihextyp),00)
          iaskhex(ihextyp)=0
          intg=iconvhex(line(icol1:icol2),icol2-icol1+1)
        end if
      else
        write (6,2000) inplab(ihextyp),icol1,icol2,line
        stop
      end if
      return
2000  format(' ERROR: Invalid integer was read for ',a,/,
     -  8x,'Column range: [',i3,',',i3,':]; the line read:'/,a)
2001  format(' PROGRAM ERROR in readint: icol1 > icol2 (',2i3,')',
     -  ' the line read was:'/,a)
      end
      subroutine delphigrid(iu,iu1,iu2,c,n,nslt,xstart,ystart,zstart,
     -  gx,gy,gz,ngx,ngy,ngz,igincr,rnear,igridfile,iexcl,iquery,
     -  interpol)
      dimension c(3,n)
c     Print the potential at the grid points
      parameter (MAXPHI=400)
      common /nnwork/ phimap(MAXPHI,MAXPHI,MAXPHI)
      character*1 xyz
      common /axislab/ xyz(3)
      dimension xyzmin(3),xyzmax(3)
      if (iquery .eq. 1) then
        x=0.0
        do while (x .ne. 999.0)
          call getreal('X coordinate (999 to quit)',26,999999.0,x,0,0)
          if (x .ne. 999.0) then
            call getreal('Y coordinate',12,999999.0,y,0,0)
            call getreal('Z coordinate',12,999999.0,z,0,0)
            call interpolate(x,y,z,gx,gy,gz,xstart,ystart,zstart,phi)
          write (6,1000) x,y,z,phi
          end if
        end do
      end if
      if (igridfile .eq. 1) then
c       Establish grid range to print
101     call getreal('Grid X coordinate minimum',25,xstart,xgmin,0,0)
        call getreal('Grid X coordinate maximum',25,xstart+ngx*gx,xgmax,
     -    0,0)
        ixgmin=(xgmin-xstart)/gx-1
        if (ixgmin .lt. 1) ixgmin=1
        ixgmax=(xgmax-xstart)/gx+1
        if (ixgmax .gt. ngx) ixgmax=ngx
        if (ixgmin .gt. ixgmax) then
          print *,'Invalid X grid range:',ixgmin,ixgmax
          go to 101
        end if
102     call getreal('Grid Y coordinate minimum',25,ystart,ygmin,0,0)
        call getreal('Grid Y coordinate maximum',25,ystart+ngy*gy,ygmax,
     -    0,0)
        iygmin=(ygmin-ystart)/gy-1
        if (iygmin .lt. 1) iygmin=1
        iygmax=(ygmax-ystart)/gx+1
        if (iygmax .gt. ngy) iygmax=ngy
        if (iygmin .gt. iygmax) then
          print *,'Invalid Y grid range:',iygmin,iygmax
          go to 102
        end if
103     call getreal('Grid Z coordinate minimum',25,zstart,zgmin,0,0)
        call getreal('Grid Z coordinate maximum',25,zstart+ngz*gz,zgmax,
     -    0,0)
        izgmin=(zgmin-zstart)/gz-1
        if (izgmin .lt. 1) izgmin=1
        izgmax=(zgmax-zstart)/gx+1
        if (izgmax .gt. ngz) izgmax=ngz
        if (izgmin .gt. izgmax) then
          print *,'Invalid Z grid range:',izgmin,izgmax
          go to 103
        end if
        rnear2=0.0
        if (iexcl .eq. 1) then
          rnear2=rnear**2
          ncheck=0
          ndrop=0
          do k=1,3
            xyzmin(k)=10000.0
            xyzmax(k)=-xyzmin(k)
          end do
          ii=0
          do ia=1,nslt
            do k=1,3
              if (c(k,ia) .lt. xyzmin(k)) xyzmin(k)=c(k,ia)
              if (c(k,ia) .gt. xyzmax(k)) xyzmax(k)=c(k,ia)
            end do
c           Mark grids to be dropped
            if (c(1,ia)+rnear .gt. xgmin .and.
     -          c(1,ia)-rnear .lt. xgmax .and.
     -          c(2,ia)+rnear .gt. ygmin .and.
     -          c(2,ia)-rnear .lt. ygmax .and.
     -          c(3,ia)+rnear .gt. zgmin .and.
     -          c(3,ia)-rnear .lt. zgmax) then
              ncheck=ncheck+1
              ixmin=(c(1,ia)-rnear-xstart)/gx-1
              if (ixmin .lt. 1) ixmin=1
              ixmax=(c(1,ia)+rnear-xstart)/gx+2
              if (ixmax .gt. ngx) ixmax=ngx
              iymin=(c(2,ia)-rnear-ystart)/gy-1
              if (iymin .lt. 1) iymin=1
              iymax=(c(2,ia)+rnear-ystart)/gy+2
              if (iymax .gt. ngy) iymax=ngy
              izmin=(c(3,ia)-rnear-zstart)/gz-1
              if (izmin .lt. 1) izmin=1
              izmax=(c(3,ia)+rnear-zstart)/gz+2
              if (izmax .gt. ngz) izmax=ngz
              do iz=izmin,izmax
                do iy=iymin,iymax
                  do ix=ixmin,ixmax
                    ii=ii+1
                    x=xstart+(ix-1)*gx
                    y=ystart+(iy-1)*gy
                    z=zstart+(iz-1)*gz
                    dd=(x-c(1,ia))**2+(y-c(2,ia))**2+(z-c(3,ia))**2
                    if (dd. lt. rnear2 .and.
     -                  phimap(ix,iy,iz) .ne. 999999.9) then
                      phimap(ix,iy,iz)=999999.9
                      ndrop=ndrop+1
                    end if
c                  write (77,7878) ia,ix,iy,iz,x,y,z,(c(k,ia),k=1,3),
c     -              dd,rnear2,ndrop
c7878              format(' ia=',i5,2x,3i5,' xyz=',3f10.4,' c=',3f10.4,
c     -              ' dd,rnear2=',2f10.2,' ndrop=',i9)
                  end do
                end do
              end do
            end if
          end do
          write (6,2008) (xyz(k),xyzmin(k),xyzmax(k),k=1,3)
        end if
        ngw=0
        ngd=0
        write (6,1002) ncheck,nslt,ii,ndrop
        do iz=izgmin,izgmax,igincr
          do iy=iygmin,iygmax,igincr
            do ix=ixgmin,ixgmax,igincr
              ngw=ngw+1
              x=xstart+(ix-1)*gx
              y=ystart+(iy-1)*gy
              z=zstart+(iz-1)*gz
              pm=phimap(ix,iy,iz)
              if (pm .eq. 999999.9) then
                pm=0.0
                ngd=ngd+1
              end if
              if (abs(pm) .lt. 99.0) then
                write (iu,1004) iz,x,y,z,pm
              else
                if (pm .lt. -999.0) pm=-999.0
                if (pm .gt. 999.0) pm=999.0
                write (iu,1010) iz,x,y,z,pm
              end if
              if (pm .ne. 0.0 .and. iu1 .gt. 0) then
                if (abs(pm) .lt. 99.0) then
                  write (iu1,1004) iz,x,y,z,pm
                else
                  if (pm .lt. -999.0) pm=-999.0
                  if (pm .gt. 999.0) pm=999.0
                  write (iu1,1010) iz,x,y,z,pm
                end if
              end if
            end do
          end do
        end do
        if (interpol .eq. 1) then
          call fillinterpolate(phimap,ixgmin,ixgmax,iygmin,iygmax,
     -     izgmin,izgmax,igincr,MAXPHI,MAXPHI,MAXPHI,999999.9,ninterpol)
          do iz=izgmin,izgmax,igincr
            do iy=iygmin,iygmax,igincr
              do ix=ixgmin,ixgmax,igincr
                x=xstart+(ix-1)*gx
                y=ystart+(iy-1)*gy
                z=zstart+(iz-1)*gz
                pm=phimap(ix,iy,iz)
                if (abs(pm) .lt. 99.0) then
                  write (iu2,1004) iz,x,y,z,pm
                else
                  if (pm .lt. -999.0) pm=-999.0
                  if (pm .gt. 999.0) pm=999.0
                  write (iu2,1010) iz,x,y,z,pm
                end if
              end do
            end do
          end do
          write (6,1005) 'interpolated',ninterpol
          if (ninterpol .ne. ngd)
     -      print *,'ERROR in number of dropped/interpolated grids'
        end if
      end if
      write (6,1003) ngw
      if (iexcl .gt. 0)
     -   write (6,1005) 'dropped (or written with zero potentials)',ngd
      return
1000  format(' phi(',f10.5,',',f10.5,',',f10.5,')=',f12.5)
1002  format(' Checked ',i5,' atoms out of ',i6,'; Checked',i9,
     -  ' grids',/,' Number of grids found too close to atoms=',i8)
1003  format(' Number of grid points written=',i7)
1004  format('ATOM        He   GRD A ',i3,4x,3f8.3,'  1.00',f6.2)
1005  format(' Number of ',a,' grid points=',i6)
1010  format('ATOM        He   GRD A ',i3,4x,3f8.3,'  1.00',f6.1)
2008  format(' Solute extensions: ',/,3(1x,a,': [',f7.1,' - ',f7.1,']'))
      return
      end
      subroutine fillinterpolate(pmap,nx1,nx,ny1,ny,nz1,nz,igincr,
     -  nxmax,nymax,nzmax,pinf,ninterpol)
      dimension pmap(nxmax,nymax,nzmax)
c     print *,'FI nx1,nx,ny1,ny,nz1,nz=',nx1,nx,ny1,ny,nz1,nz
      ninterpol=0
      ngr=0
      do iz=nz1,nz,igincr
        do iy=ny1,ny,igincr
          do ix=nx1,nx,igincr
            ngr=ngr+1
            if (pmap(ix,iy,iz) .eq. pinf) then
              ninterpol=ninterpol+1
              pint=0.0
              ixlim=ix
              do while (ixlim .le. nx .and. pmap(ixlim,iy,iz) .eq. pinf)
                ixlim=ixlim+1
              end do
              if (ix .eq. nx1) then
                if (ixlim .gt. nx) then
c                 Empty line - stop for now
                  print *,'Empty line iy=',iy,' iz=',iz
                  stop
                end if
                pint=pint+pmap(ixlim,iy,iz)
              else if (ixlim .gt. nx) then
                pint=pint+pmap(ix-igincr,iy,iz)
              else
                pint=pint+(igincr*pmap(ixlim,iy,iz)+
     -            (ixlim-ix)*pmap(ix-igincr,iy,iz))/(ixlim-ix+igincr)
              end if
              iylim=iy
              do while (iylim .le. ny .and. pmap(ix,iylim,iz) .eq. pinf)
                iylim=iylim+1
              end do
              if (iy .eq. ny1) then
                if (iylim .gt. ny) then
c                 Empty line - stop for now
                  print *,'Empty line ix=',ix,' iz=',iz
                  stop
                end if
                pint=pint+pmap(ix,iylim,iz)
              else if (iylim .gt. ny) then
                pint=pint+pmap(ix,iy-igincr,iz)
              else
                pint=pint+(igincr*pmap(ix,iylim,iz)+
     -            (iylim-iy)*pmap(ix,iy-igincr,iz))/(iylim-iy+igincr)
              end if
              izlim=iz
              do while (izlim .le. nz .and. pmap(ix,iy,izlim) .eq. pinf)
                izlim=izlim+1
              end do
              if (iz .eq. nz1) then
                if (izlim .gt. nz) then
c                 Empty line - stop for now
                  print *,'Empty line ix=',ix,' iy=',iy
                  stop
                end if
                pint=pint+pmap(ix,iy,izlim)
              else if (izlim .gt. nz) then
                pint=pint+pmap(ix,iy,iz-igincr)
              else
                pint=pint+(igincr*pmap(ix,iy,izlim)+
     -            (izlim-iz)*pmap(ix,iy,iz-igincr))/(izlim-iz+igincr)
              end if
              pmap(ix,iy,iz)=pint/3.0
            end if
          end do
        end do
      end do
      return
      end
      subroutine delphilabel(c,n,nslt,xstart,ystart,zstart,gx,gy,gz,cv)
      dimension c(3,n),cv(n)
      parameter (MAXPHI=400)
      common /nnwork/ phimap(MAXPHI,MAXPHI,MAXPHI)
      nl=0
      do ia=1,nslt
        call interpolate(c(1,ia),c(2,ia),c(3,ia),gx,gy,gz,
     -    xstart,ystart,zstart,phi)
        cv(ia)=phi
      end do
      return
      end
      subroutine readmap(iu,xstart,ystart,zstart,gx,gy,gz,ngx,ngy,ngz,
     -  nconf,work,lwork)
      dimension work(lwork)
      parameter (MAXPHI=400)
      common /nnwork/ phimap(MAXPHI,MAXPHI,MAXPHI)
      character*60 toplbl !ascii header
      integer*4 ivary ! 0 => x index varys most rapidly
      integer*4 nbyte ! =4, # of bytes in data
      integer*4 inddat ! =0, floating point data
      real*4 xang,yang,zang ! =90,90,90 unit cell angles
      integer*4 intx,inty,intz ! =igrid-1, # of intervals/grid side
      real*4 extentx, extenty, extentz ! maximum extent of grid in x,y,z
      real*4 xstart,xend ! beginning, end of grid sides
      real*4 ystart,yend ! in fractional
      real*4 zstart,zend ! units of extent*
      data imin /0/,jmin /0/,kmin /0/
      rewind iu
      read (iu) toplbl
      print *,'READING MAP ',toplbl
      read (iu) ivary, nbyte, inddat, extentx, extenty, extentz,
     -  xang, yang, zang, xstart, xend, ystart, yend,
     -  zstart, zend, intx, inty, intz
      if (ivary .eq. 0) write (6,*) 'X index varies faster (Fortran)'
      if (ivary .gt. 0) write (6,*) 'Z index varies faster (C)'
c     print *,'ivary, nbyte, intdat=',ivary, nbyte, intdat
      gx=extentx*(xend-xstart)/(intx)
      gy=extenty*(yend-ystart)/(inty)
      gz=extentz*(zend-zstart)/(intz)
      phimin=1000000.0
      ngx=intx+1
      ngy=inty+1
      ngz=intz+1
      write (6,1002) 'X',extentx*xstart,extentx*xend,gx,ngx
      write (6,1002) 'Y',extenty*ystart,extenty*yend,gy,ngy
      write (6,1002) 'Z',extentz*zstart,extentz*zend,gz,ngz
      write (6,1003) extentx*(xstart+xend)/2.0,
     -  extenty*(ystart+yend)/2.0,extentz*(zstart+zend)/2.0
      nskip=0
      if (ngx .gt. MAXPHI) then
        ngxx=ngx
        do while (ngxx .gt. MAXPHI)
          ngxx=ngxx/2
          nskip=nskip+1
        end do
        if (nconf .le. 1) write (6,1000) ngx,MAXPHI,2**nskip
        gx=gx*2**nskip
        gy=gy*2**nskip
        gz=gz*2**nskip
      end if
      nuse=2**nskip
      if (ivary .eq. 0) then
        do k=1,ngz
          do j=1,ngy
            read (iu) (work(i),i=1,ngx)
            do i=1,ngx
              if (work(i) .lt. phimin) then
                phimin=work(i)
                imin=i
                jmin=j
                kmin=k
              end if
            end do
            if (mod(k,nuse) .eq. 0 .and. mod(j,nuse) .eq. 0) then
              do i=1,ngx
                if (mod(i,nuse) .eq. 0)
     -            phimap((i-1)/nuse+1,(j-1)/nuse+1,(k-1)/nuse+1)=work(i)
              end do
            end if
          end do
        end do
      else
        do k=1,ngx
          do j=1,ngy
            read (iu) (work(i),i=1,ngz)
            do i=1,ngz
              if (work(i) .lt. phimin) then
                phimin=work(i)
                imin=i
                jmin=j
                kmin=k
              end if
            end do
            if (mod(k,nuse) .eq. 0 .and. mod(j,nuse) .eq. 0) then
              do i=1,ngz
                if (mod(i,nuse) .eq. 0)
     -            phimap((i-1)/nuse+1,(j-1)/nuse+1,(k-1)/nuse+1)=work(i)
              end do
            end if
          end do
        end do
      end if
      xstart=xstart*extentx
      ystart=ystart*extenty
      zstart=zstart*extentz
      write (6,1001) phimin,xstart+(imin-1)*gx/2**nskip,
     -  ystart+(jmin-1)*gy/2**nskip,zstart+(kmin-1)*gz/2**nskip
      return
1000  format(' The number of gridpoints (',i4,') exceeds ',i4,
     -  ' - only every',i3,'-th will be used',/,
     -  ' (update/replace the nnwork common block to avoid this)')
1001  format(' The lowest potential=',f10.4,' at (',f8.2,',',f8.2,',',
     -  f8.2,')')
1002  format(1x,a,'-direction start=',f10.5,' end=',f10.5,
     -  ' gridsize=',f6.3,' (',i3,' grids)')
1003  format(' The grid is centered at (',f10.5,',',f10.5,',',f10.5,')')
      end
      subroutine interpolate(x,y,z,gx,gy,gz,xstart,ystart,zstart,phi)
      parameter (MAXPHI=400)
      common /nnwork/ phimap(MAXPHI,MAXPHI,MAXPHI)
      ix=(x-xstart)/gx+1
      iy=(y-ystart)/gy+1
      iz=(z-zstart)/gz+1
      xm=xstart+(ix-1)*gx
      ym=ystart+(iy-1)*gy
      zm=zstart+(iz-1)*gz
      wxp=(x-xm)/gx
      wyp=(y-ym)/gy
      wzp=(z-zm)/gz
      wxm=1.0-wxp
      wym=1.0-wyp
      wzm=1.0-wzp
      p0y0=wym*phimap(ix+0,iy+0,iz+0)+wyp*phimap(ix+0,iy+1,iz+0)
      p0y1=wym*phimap(ix+0,iy+0,iz+1)+wyp*phimap(ix+0,iy+1,iz+1)
      p1y0=wym*phimap(ix+1,iy+0,iz+0)+wyp*phimap(ix+1,iy+1,iz+0)
      p1y1=wym*phimap(ix+1,iy+0,iz+1)+wyp*phimap(ix+1,iy+1,iz+1)
      p0yz=wzm*p0y0+wzp*p0y1
      p1yz=wzm*p1y0+wzp*p1y1
      phi=wxm*p0yz+wxp*p1yz
      return
      end
      subroutine readreal(line,icol1,icol2,r)
      character*(*) line
      if (icol2-icol1 .eq. 2) then
        read (line(icol1:icol2),1003,ERR=100) r
      else if (icol2-icol1 .eq. 3) then
        read (line(icol1:icol2),1004,ERR=100) r
      else if (icol2-icol1 .eq. 4) then
        read (line(icol1:icol2),1005,ERR=100) r
      else if (icol2-icol1 .eq. 5) then
        read (line(icol1:icol2),1006,ERR=100) r
      else if (icol2-icol1 .eq. 6) then
        read (line(icol1:icol2),1007,ERR=100) r
      else if (icol2-icol1 .eq. 7) then
        read (line(icol1:icol2),1008,ERR=100) r
      else if (icol2-icol1 .eq. 8) then
        read (line(icol1:icol2),1009,ERR=100) r
      else if (icol2-icol1 .eq. 9) then
        read (line(icol1:icol2),1010,ERR=100) r
      else if (icol2-icol1 .eq. 10) then
        read (line(icol1:icol2),1011,ERR=100) r
      else if (icol2-icol1 .eq. 11) then
        read (line(icol1:icol2),1012,ERR=100) r
      else if (icol2-icol1 .eq. 12) then
        read (line(icol1:icol2),1013,ERR=100) r
      else if (icol2-icol1 .eq. 13) then
        read (line(icol1:icol2),1014,ERR=100) r
      else if (icol2-icol1 .eq. 14) then
        read (line(icol1:icol2),1015,ERR=100) r
      else if (icol2-icol1 .eq. 15) then
        read (line(icol1:icol2),1016,ERR=100) r
      else if (icol2-icol1 .eq. 16) then
        read (line(icol1:icol2),1017,ERR=100) r
      else if (icol2-icol1 .eq. 17) then
        read (line(icol1:icol2),1018,ERR=100) r
      else if (icol2-icol1 .eq. 18) then
        read (line(icol1:icol2),1019,ERR=100) r
      else if (icol2-icol1 .eq. 19) then
        read (line(icol1:icol2),1020,ERR=100) r
      else if (icol2-icol1 .gt. 20) then
        print *,'EXTEND subroutine readreal to larger reals'
        print *,'r=',r,' icol1,2=',icol1,icol2
        stop
      else
        print *,'PROGRAM ERROR: invalid column range in readreal:',
     -  icol1,' - ',icol2
      end if
      return
100   write (6,200) icol1,icol2,line
200   format(' ERROR: Invalid real was read between columns ',
     -  i3,' and ',i3,':',/,a132)
      return
1003  format(f3.0)
1004  format(f4.0)
1005  format(f5.0)
1006  format(f6.0)
1007  format(f7.0)
1008  format(f8.0)
1009  format(f9.0)
1010  format(f10.0)
1011  format(f11.0)
1012  format(f12.0)
1013  format(f13.0)
1014  format(f14.0)
1015  format(f15.0)
1016  format(f16.0)
1017  format(f17.0)
1018  format(f18.0)
1019  format(f19.0)
1020  format(f20.0)
      end
      subroutine readname(q,lqin,blankline,maxlen,defname,ld,name,ihelp)
      character*(*) q,blankline,defname,name
      common /logging/ logfile,ipredict
      character*80 qline,ansline,defn
100   lq=lqin
      defn(1:ld)=defname(1:ld)
      name(1:maxlen)=blankline(1:maxlen)
      qline(1:lq)=q(1:lq)
      ansline=blankline(1:80)
      if (ld .gt. 0) then
        qline(lq+1:lq+2)=' ['
        lq=lq+2
        qline(lq+1:lq+ld)=defn(1:ld)
        lq=lq+ld
        qline(lq+1:lq+1)=']'
        lq=lq+1
      end if
      if (ihelp .gt. 0) then
        if (ld .eq. 0) then
          qline(lq+1:lq+4)=' [?]'
          lq=lq+4
        else
          qline(lq:lq+2)=',?]'
          lq=lq+2
        end if
      end if
      write (6,1000) qline(1:lq)
      read (5,1001) ansline
      if (ansline(1:1) .eq. '?') then
        call explanation(ihelp)
        go to 100
      end if
      ii=1
      call nextchar(ansline,ii,80)
      i1=ii
      call nextblank(ansline,ii,80)
      i2=ii-1
      if (i2-i1+1 .gt. maxlen) then
        write (6,1002) ansline(i1:i2),maxlen
        go to 100
      else if (i1 .gt. i2) then
c       Use default
        if (ld .gt. 0) then
          name(1:ld)=defn(1:ld)
          if (logfile .gt. 0) write (logfile,1001)
        else
          print *,'Please, type in a name'
          go to 100
        end if
      else
        name(1:i2-i1+1)=ansline(i1:i2)
        if (logfile .gt. 0) write (logfile,1001) ansline(i1:i2)
      end if
      return
1000  format(1x,a,'=',$)
1001  format(a)
1002  format(' Name read (',a,') is longer than allowed (',i3,')')
      end
      subroutine blankout(line,n1,n2)
      character*(*) line
      do i=n1,n2
        line(i:i)=' '
      end do
      return
      end
      subroutine writeline(iout,line,icol1,icol2,nocr)
      character* 132 line
      lc=icol2
      if (icol2 .eq. 0) call lastchar(line,lc,132)
      if (nocr .eq. 0) then
        write (iout,2000) line(icol1:lc)
      else
        write (iout,1000) line(icol1:lc)
      end if
      return
1000  format(a,$)
2000  format(a)
      end
      subroutine getint(q,len,idef,noneg,maxval,in,ihelp)
      character*(*) q
      character*132 ansline,pline
      common /logging/ logfile,ipredict
c     print *,'GETINT idef,noneg,maxval=',idef,noneg,maxval
      lenq=len
      pline(1:1)=' '
      pline(2:lenq+1)=q(1:lenq)
c     Allow idef == in
      idefault=idef
      if (idefault .ne. 999999) then
        if (maxval .gt. 0 .and. idefault .gt. maxval) then
          write (6,2002)  idefault,maxval
          lenq=lenq+1
          pline(lenq:lenq)='='
        else
c         Put default on query
          pline(lenq+2:lenq+3)=' ['
          if (idefault .le. 9999) then
            write (pline(lenq+4:lenq+7),1002) idefault
            lenq=lenq+7
          else
            write (pline(lenq+4:lenq+11),1003) idefault
            lenq=lenq+11
          end if
          if (ihelp .eq. 0) then
            pline(lenq+1:lenq+2)=']='
            lenq=lenq+2
          else
            pline(lenq+1:lenq+4)=',?]='
            lenq=lenq+4
          end if
        end if
      else
        if (ihelp .eq. 0) then
          pline(lenq+2:lenq+2)='='
          lenq=lenq+2
        else
          pline(lenq+2:lenq+5)='[?]='
          lenq=lenq+5
        end if
      end if
100   call writeline(6,pline,1,lenq,1)
      call blankout(ansline,1,132)
      read (5,1001,end=99) ansline
      ii=1
      call nextchar(ansline,ii,132)
      if (ansline(ii:ii) .eq. '?') then
        if (ihelp .eq. 0) then
          print *,'Sorry, no help for this'
        else
          call explanation(ihelp)
        end if
        go to 100
      end if
      i1=ii
      call nextblank(ansline,ii,132)
      i2=ii-1
      if (i1 .gt. i2) then
        if (idefault .eq. 999999) go to 100
        in=idefault
        if (logfile .gt. 0) write (logfile,3000)
      else
        ic1=i1
        if (ansline(i1:i1) .eq. '-' .or.  ansline(i1:i1) .eq. '+')
     -    ic1=i1+1
        do i=ic1,i2
          if (idigit(ansline(i:i),1) .ne. 1) go to 999
        end do
        read (ansline(i1:i2),*,err=999) in
        if (logfile .gt. 0) write (logfile,*) in
      end if
      if (noneg .eq. 1 .and. in .lt. 0) then
        write (6,2000) q(1:len)
        go to 100
      end if
      if (maxval .gt. 0 .and. in .gt. maxval) then
        write (6,2001) maxval
        go to 100
      end if
      return
99    print *,'ERROR: run out of data'
      stop
999   print *,'Invalid input for an integer'
      go to 100
1001  format(a132)
1002  format(i4)
1003  format(i8)
2000  format(' ERROR: negative number is invalid for ',a)
2001  format(' ERROR: number read exceeds limit (',i9,')')
2002  format(' PROGRAM ERROR: default value (',i8,') exceeds maximum ',
     -  'value (',i8,')')
3000  format(a)
      end
      subroutine getintline(q,len,noneg,maxval,inputs,n,ihelp)
      dimension inputs(n)
      character*(*) q
      character*132 ansline,pline
      common /logging/ logfile,ipredict
      lenq=len
      pline(1:1)=' '
      pline(2:lenq+1)=q(1:lenq)
      if (ihelp .eq. 0) then
        pline(lenq+2:lenq+2)='='
        lenq=lenq+2
      else
        pline(lenq+2:lenq+5)='[?]='
        lenq=lenq+5
      end if
100   call writeline(6,pline,1,lenq,1)
      call blankout(ansline,1,132)
      read (5,1001) ansline
      ii=1
      call nextchar(ansline,ii,132)
      if (ansline(ii:ii) .eq. '?') then
        if (ihelp .eq. 0) then
          print *,'Sorry, no help for this'
        else
          call explanation(ihelp)
        end if
        go to 100
      end if
      i1=ii
      call lastchar(ansline,ilc,132)
      if (logfile .gt. 0) write (logfile,3000) ansline(1:ilc)
      read (ansline,*,end=888,err=999) (inputs(k),k=1,n)
      do k=1,n
        if (inputs(k) .gt. maxval) then
          write (6,2001) inputs(k),maxval
          go to 100
        else if (noneg .eq. 1 .and. inputs(k) .lt. 0) then
          write (6,2000) inputs(k),q(1:len)
          go to 100
        end if
      end do
      return
888   print *,'Insufficient number of entries'
      go to 100
999   print *,'Invalid input for an integer:',ansline(1:ilc)
      go to 100
1001  format(a132)
2000  format(' ERROR: negative number read (',i9,') is invalid for ',a)
2001  format(' ERROR: number read (',i9,') exceeds limit (',i9,')')
3000  format(a)
      end
      subroutine getreal(q,len,default,r,noneg,ihelp)
      character*(*) q
      character*132 ansline,pline
      common /logging/ logfile,ipredict
      lenq=len
      pline(1:1)=' '
      pline(2:lenq+1)=q(1:lenq)
      if (default .ne. 999999.0) then
c       Put default on query
        pline(lenq+2:lenq+3)=' ['
        if (abs(default) .gt. 1.0) then
          write (pline(lenq+4:lenq+12),1002) default
        else
          write (pline(lenq+4:lenq+12),1003) default
        end if
        if (ihelp .eq. 0) then
          pline(lenq+13:lenq+14)=']='
          lenq=lenq+14
        else
          pline(lenq+13:lenq+16)=',?]='
          lenq=lenq+16
        end if
      else
        if (ihelp .eq. 0) then
          pline(lenq+2:lenq+2)='='
          lenq=lenq+2
        else
          pline(lenq+2:lenq+5)='[?]='
          lenq=lenq+5
        end if
      end if
100   call writeline(6,pline,1,lenq,1)
      call blankout(ansline,1,132)
      read (5,1001,end=99) ansline
      ii=1
      call nextchar(ansline,ii,132)
      if (ansline(ii:ii) .eq. '?') then
        if (ihelp .eq. 0) then
          print *,'Sorry, no help for this'
        else
          call explanation(ihelp)
        end if
        go to 100
      end if
      i1=ii
      call nextblank(ansline,ii,132)
      i2=ii-1
      if (i1 .gt. i2) then
        if (default .eq. 999999.0) go to 100
        r=default
        if (logfile .gt. 0) write (logfile,3000)
      else
        read (ansline(i1:i2),*,err=999) r
        if (noneg .eq. 1 .and. r .lt. 0.0) then
          print *,'ERROR: negative number is invalid'
          go to 100
        end if
        if (logfile .gt. 0) write (logfile,*) r
      end if
      return
99    print *,'ERROR: run out of data'
      stop
999   print *,'Invalid input for a real'
      go to 100
1001  format(a132)
1002  format(f8.2)
1003  format(f8.5)
3000  format(a)
      end
      subroutine getname4(ic,line,name,len,lead_trail)
      character*(*) line
      character*4 name
      name='    '
      call nextchar(line,ic,len)
      icf=ic
      call nextblank(line,ic,len)
      if (ic-icf .le. 4 .or. lead_trail .eq. 1) then
        name(1:ic-icf)=line(icf:ic-1)
      else
c       Use trailing part of the name
        name=line(ic-4:ic-1)
      end if
      return
      end
      subroutine askyn(q,lenq,iyn,idefans,ians,ihelp)
      character*(*) q
      character*132 pline
      character*1 ans
      character*5 defans
      common /graphics/ igl,npixx,npixy,maxpixx,maxpixy,idwmain,idwplot,
     -  wx,wy,wz,wxdr
      common /logging/ logfile,ipredict
c     idefans=-1: default no; idefans=+1: default yes
c     iyn=1: yes -> ians=1, no -> ians=0
c     iyn=0: yes -> ians=0, no -> ians=1
      ians=0
      if (idefans .eq. -1) then
        defans=' [n] '
        lendef=5
      else if (idefans .eq. +1) then
        defans=' [y] '
        lendef=5
      else
        defans=' '
        lendef=1
      end if
      pline(1:1)=' '
      pline(2:lenq+1)=q(1:lenq)
      if (ihelp .eq. 0) then
        lenqq=lenq+7
        pline(lenq+2:lenqq)=' (y/n)'
      else
        lenqq=lenq+9
        pline(lenq+2:lenqq)=' (y/n/?)'
      end if
      pline(lenqq+1:lenqq+lendef)=defans(1:lendef)
100   call writeline(6,pline,1,lenqq+lendef,1)
      ans= ' '
      read (5,1001,end=99,err=99) ans
      if (ans .eq. '?') then
        if (ihelp .eq. 0) then
          print *,'Sorry, no help on this'
          go to 100
        else
          call explanation(ihelp)
          go to 100
        end if
      end if
99    if (ans .ne. 'n' .and. ans .ne. 'N' .and. ans .ne. 'y' .and.
     -  ans .ne. 'Y') then
        call lastchar(ans,ilc,1)
        if (ilc .eq. 1) then
          print *,'Invalid answer - please, answer y or n'
          go to 100
        else if (idefans .ne. 1 .and. idefans .ne. -1) then
          print *,'Pls answer y or n'
          go to 100
        else
          if (idefans .eq. -1) then
            ans='n'
          else if (idefans .eq. 1) then
            ans='y'
          end if
        end if
      end if
      if (logfile .gt. 0) write (logfile,1001) ans
      if (ans .eq. 'y' .or. ans .eq. 'Y') ians=1
      if (iyn .eq. 0) ians=1-ians
      return
1001  format(a1)
      end
      subroutine quiz(char,ians,defchar,prefix,lprefix,question0,lqt0,
     -  nqincr,inpt,iout,igl,ihelp)
      character*(*) prefix,question0
      character*60 ansline
      character*80 line,line1(100),question
      character*1 char,defchar,ans,ch(2,100)
      dimension len(100),lenans(100)
      character*60 q(100),promptlist,prompttype
      common /quizinfo/ nqst(500),lqst(500),iqfst(500),iqlst(500),
     -  maxq,init,nprompttype,promptlist(500),prompttype(500)
      common /logging/ logfile,ipredict
C@GL#include <fgl.h>
C@GL#include <fdevice.h>
c     if lprefix > 0 then the question will be composed of the prefix+question0
c     if lprefix < 0 then the question will be composed of the question0+prefix
c     drop the last nqincr questions
c     print *,'QUIZ lprefix=',lprefix,' lqt0=',lqt0,' init=',init
      idebug=0
      if (init .eq. 0) then
c       Initialize nq,lq,iqfst,iqlst
        init=1
        nprompttype=0
        lqq=0
        do il=1,maxq
          call lastchar(promptlist(il),ilc,60)
          if (promptlist(il)(1:4) .eq. '****') then
            if (nprompttype .gt. 0) then
              iqlst(nprompttype)=il-1
              lqst(nprompttype)=lqq
              if (prompttype(nprompttype)(1:8) .eq. 'run type' .and.
     -            igl .eq. 0) then
c               Drop animation from menu
                promptlist(il-2)=promptlist(il-1)
                iqlst(nprompttype)=iqlst(nprompttype)-1
              end if
            end if
            if (ilc .eq. 4) go to 10
            nprompttype=nprompttype+1
            prompttype(nprompttype)(1:55)=promptlist(il)(6:60)
            if (nprompttype .gt. 1) iqlst(nprompttype-1)=il-1
            iqfst(nprompttype)=il+1
          else
            if (lqq .lt. ilc) lqq=ilc
          end if
        end do
c       Quiz i has label prompptype(i) of length lqst(i)
c       List of menu items in Quiz i: promptlist(iqfst(i))-promptlist(iqlst(i))
10      if (idebug .gt. 0) then
          do i=1,nprompttype
            print *,'i,ifl,ill=',i,iqfst(i),iqlst(i)
            do ip=iqfst(i),iqlst(i)
              print *,'ip,len=',ip,lqst(i)
              print *,promptlist(ip)(1:lqst(i))
            end do
          end do
        end if
      end if
c     Find the quiz label
      iquiz=1
      do while (question0(1:lqt0) .ne. prompttype(iquiz)(1:lqt0) .and.
     -   iquiz .le. nprompttype)
        iquiz=iquiz+1
      end do
      if (iquiz .gt. nprompttype) then
        print *,'PROGRAM ERROR: quiz type ',question0(1:lqt0),
     -    ' is unknown'
        stop
      end if
      if (lprefix .eq. 0) then
        question(1:lqt0)=question0(1:lqt0)
        lqt=lqt0
      else if (lprefix .gt. 0) then
c       Combine prefix and question0
        question(1:lprefix)=prefix(1:lprefix)
        lqt=lprefix+1
        question(lqt:lqt)=' '
        question(lqt+1:lqt+lqt0)=question0(1:lqt0)
        lqt=lqt+lqt0
      else
c       Combine question0 and prefix
        question(1:lqt0)=question0(1:lqt0)
        lqt=lqt0+1
        question(lqt:lqt)=' '
        question(lqt+1:lqt-lprefix)=prefix(1:-lprefix)
        lqt=lqt-lprefix
      end if
      if (idebug .gt. 0) print *,'QUIZ nprompttype,iquiz=',
     -  nprompttype,iquiz,' nq,lq=',nq,lq
      do iq=iqfst(iquiz),iqlst(iquiz)
        q(iq-iqfst(iquiz)+1)=promptlist(iq)
      end do
      nq=iqlst(iquiz)-iqfst(iquiz)+1
      lq=lqst(iquiz)
      if (nq .gt. 40) then
        write (iout,*) '***** Redimension quiz to more than 40 items'
        stop
      end if
      nqq=nq-nqincr
      if (ihelp .gt. 0) nqq=nqq+1
c     igl=0
      ans=' '
100   if (igl .eq. 1) then
c       Initialize pop-up menu
C@GL        idmenu=newpup()
        if (lqt .gt. 0) then
          line(1:lqt)=question(1:lqt)
          call uplow(line(1:1),line(1:1),2,noabc)
          line(lqt+1:lqt+3)=' %t'
C@GL          call addtop(idmenu,line(1:lqt+3),lqt+3,0)
        end if
      else
        if (lqt .gt. 0) write (iout,1002) question(1:lqt)
        idebug=idebug+1
          if (idebug .eq. 4) stop
      end if
      ideffound=0
      do iq=1,nq-nqincr
c       Find signal character position (ich)
        ich=1
        do while (q(iq)(ich:ich) .ne. '<' .and. ich .lt. lq)
          ich=ich+1
        end do
        ich=ich+1
        ichgrt=ich+1
c       Find last non-blank in the menu item line
        il=lq
        do while (q(iq)(il:il) .eq. ' ' .and. il .gt. 1)
          il=il-1
        end do
        len(iq)=il
        lenans(iq)=il-2
        if (ichgrt .eq. il) lenans(iq)=lenans(iq)-1
        ch(1,iq)=q(iq)(ich:ich)
        iconvcase=1
        if (ich .lt. lq-1) then
          call findcase(q(iq)(ich+2:ich+2),icase)
          if (icase .eq. 1) iconvcase=0
        end if
        if (iconvcase .eq. 1 .and. ich .gt. 3) then
          call findcase(q(iq)(ich-2:ich-2),icase)
          if (icase .eq. 1) iconvcase=0
        end if
c       Find lower-case of signal character
        call uplow(ch(1,iq),ch(2,iq),1,noabc)
        if (noabc .eq. 1) ch(2,iq)=ch(1,iq)
c       Generate <>-less menu item
        if (ich .eq. 2) then
          line1(iq)(1:1)=ch(1,iq)
          line1(iq)(2:il-2)=q(iq)(4:il)
        else
          line1(iq)(1:ich-2)=q(iq)(1:ich-2)
          line1(iq)(ich-1:ich-1)=ch(iconvcase+1,iq)
          if (il-ich .gt. 1) line1(iq)(ich:il-2)=q(iq)(ich+2:il)
          call uplow(line1(iq)(1:1),line1(iq)(1:1),2,noabc)
        end if
        if (igl .eq. 0) then
c         Ask from the terminal - complete line with : and signal character
          line(1:len(iq))=q(iq)(1:len(iq))
          do ic=len(iq)+1,lq
            line(ic:ic)=' '
          end do
          do ic=len(iq)+2+mod(len(iq),2),lq-1,2
            line(ic:ic)='-'
          end do
          line(lq+1:lq+2)=': '
          line(lq+3:lq+3)=ch(2,iq)
          line(lq+4:lq+4)=ch(1,iq)
          if (defchar .eq. ch(2,iq)) then
            ideffound=1
            write (iout,1001) line(1:lq+3),' (default)'
          else
            if (iq .lt. nqq) write (iout,1001) line(1:lq+3)
            if (iq .eq. nqq) write (iout,1006) line(1:lq+3)
          end if
        else
c         Generate popup menu item
          line=line1(iq)
C@GL          call addtop(idmenu,line(1:il-2),il-2,0)
        end if
      end do
      if (ihelp .gt. 0) then
c       Add help line
        ch(1,nqq)='?'
        ch(2,nqq)='?'
        call blankout(line,1,lq)
        line(1:4)='Help'
        do ic=6,lq-1,2
          line(ic:ic)='-'
        end do
        line(lq+1:lq+3)=': ?'
        if (igl .eq. 0) then
          write (iout,1006) line(1:lq+3)
        else
C@GL          call addtop(idmenu,line(1:4),4,0)
        end if
      end if
      if (igl .eq. 0) then
c       Read and evaluate answer character
        ans=' '
        read (inpt,1000) ans
        if (defchar .ne. ' ') then
          if (ideffound .eq. 0) then
            print *,'PROGRAM ERROR: invalid default character: ',defchar
          else if (ans .eq. ' ') then
            ans=defchar
          end if
        end if
        do iq=1,nq
          ians=iq
          if (ans .eq. ch(1,iq)) then
            char=ch(2,iq)
            go to 200
          else if (ans .eq. ch(2,iq)) then
            char=ans
            go to 200
          end if
        end do
        if (ihelp .gt. 0 .and. ans .eq. '?') then
          call explanation(ihelp)
        else
          write (iout,*) ans,': Invalid answer, pls repeat'
        end if
        go to 100
      else
c       Output menu, convert answer number to character
C@GL        ians=dopup(idmenu)
        if (ians .gt. nqq .or. ians .lt. 1) go to 100
        char=ch(2,ians)
        go to 200
      end if
200   if (ians .ge. 1 .and. ians .le. nq) then
        lans=lenans(ians)
        write (iout,1003) line1(ians)(1:lans)
        ansline(1:lans)=line1(ians)(1:lans)
        if (logfile .gt. 0) write (logfile,1000) ans
      else if (ians .eq. nqq) then
        call explanation(ihelp)
        go to 100
      else
        lans=1
        ansline(1:lans)='?'
      end if
      return
1000  format(a1)
1001  format(1x,a,a)
1002  format(/,' SELECT ',a,':')
1003  format(' "',a,'" selected')
1006  format(1x,a,'  ',$)
      end
      subroutine menulist
      character*60 promptlist,prompttype
      common /quizinfo/ nqst(500),lqst(500),iqfst(500),iqlst(500),
     -  maxq,init,nprompttype,promptlist(500),prompttype(500)
      character*55 submenu1(20)
      character*35 submenue(20)
      character*35 submenua(20)
      data submenu1 /
     -  '                                                       ',
     -  'optimization type                                      ',
     -  '                                                       ',
     -  'structure file format conversion type                  ',
     -  'trajectory file format conversion type                 ',
     -  'name conversion type                                   ',
     -  'trajectory/configuration stack packing/unpacking       ',
     -  'conformation manipulation                              ',
     -  'structure-derived file creation                        ',
     -  'configuration analysis                                 ',
     -  'clustering source                                      ',
     -  9*'                                                       '/
      data submenua /
     -  'topology/geometry analysis         ',
     -  'bond tracking                      ',
     -  'atomic property calculation        ',
     -  'molecular property calculation     ',
     -  'RMSD calculation                   ',
     -  'distance analysis                  ',
     -  14*'                                   '/
      data submenue /
     -  'selecting option                   ',
     -  'conformation manipulation          ',
     -  'modification type                  ',
     -  17*'                                '/
      call findmenu('run type',8,ix1)
      ix10=ix1
      ix1=ix1+1
      nn=0
      do while (promptlist(ix1)(1:3) .ne. '<Q>')
        write (6,1000) '   ',promptlist(ix1)
        call lastchar(submenu1(ix1-ix10),lc1,55)
        if (lc1 .gt. 1) then
          call findmenu(submenu1(ix1-ix10),lc1,ix2)
          ix20=ix2
          ix2=ix2+1
          do while (promptlist(ix2)(1:4) .ne. '****' .and.
     -              promptlist(ix2)(1:3) .ne. '<Q>')
            write (6,1000) '     ',promptlist(ix2)
            if (submenu1(ix1-ix10)(1:lc1) .eq.
     -          'configuration analysis') then
              call lastchar(submenua(ix2-ix20),lc2,35)
              if (lc2 .gt. 1) then
                call findmenu(submenua(ix2-ix20),lc2,ix3)
                ix3=ix3+1
                do while (promptlist(ix3)(1:4) .ne. '****' .and.
     -                    promptlist(ix3)(1:3) .ne. '<Q>')
                  write (6,1000) '       ',promptlist(ix3)
                  ix3=ix3+1
                end do
              end if
            else if (submenu1(ix1-ix10)(1:lc1) .eq.
     -          'conformation manipulation') then
c             Configuration edit submenus
              call lastchar(submenue(ix2-ix20),lc2,35)
              if (lc2 .gt. 1) then
                call findmenu(submenue(ix2-ix20),lc2,ix3)
                ix3=ix3+1
                do while (promptlist(ix3)(1:4) .ne. '****' .and.
     -                    promptlist(ix3)(1:3) .ne. '<Q>')
                  write (6,1000) '       ',promptlist(ix3)
                  ix3=ix3+1
                end do
              end if
            end if
            ix2=ix2+1
          end do
        end if
        ix1=ix1+1
      end do
      return
1000  format(a,a)
      end
      subroutine findmenu(label,llabel,ix)
      character*(*) label
      character*60 promptlist,prompttype
      common /quizinfo/ nqst(500),lqst(500),iqfst(500),iqlst(500),
     -  maxq,init,nprompttype,promptlist(500),prompttype(500)
      ix=1
      do while (promptlist(ix)(1:5) .ne. '**** ' .or.
     -          promptlist(ix)(6:5+llabel) .ne. label(1:llabel))
        ix=ix+1
        if (ix .eq. 500) then
          print *,'PROGRAM ERROR: menu ',label(1:llabel),' is not found'
          stop
        end if
      end do
      return
      end
      subroutine uplow(charin,charout,iuptolow,noabc)
      character*1 charin,charout
      character*1 abc,idig,digits,hexdigits
      common /charactersets/ ihex(25),abc(26,2),idig(10),digits(14),
     -  hexdigits(25)
c     If iuptolow=1: up -> low; iuptolow=2: low -> up
      do ic=1,26
        if (charin .eq. abc(ic,iuptolow)) then
          charout=abc(ic,3-iuptolow)
          noabc=0
          return
        end if
      end do
      noabc=1
      return
      end
      subroutine findcase(charin,icase)
      character*1 charin
      character*1 abc,idig,digits,hexdigits
      common /charactersets/ ihex(25),abc(26,2),idig(10),digits(14),
     -  hexdigits(25)
c     Returns icase=2: lower; 1: upper; 0: neither
      icase=0
      do ic=1,26
        if (charin .eq. abc(ic,1)) icase=1
        if (charin .eq. abc(ic,2)) icase=2
      end do
      return
      end
C@GL      subroutine drawfilename(idfname,name,namlen)
C@GL      character*(*) name
C@GLc     Write out a the filename in the lower left corner
C@GL      common /graphics/ igl,npixx,npixy,maxpixx,maxpixy,idwmain,idwplot,
C@GL     -  wx,wy,wz,wxdr
C@GL      common /rotmat/ matrot0(4,4),matrot(4,4),nomat0
C@GL#include <fgl.h>
C@GL#include <fdevice.h>
C@GL      call getrotmat(matrot0,nomat0,'DRSQ')
C@GL      call makeob(idfname)
C@GL      call setcolor(7)
C@GL      wxlab=0.9*wxdr
C@GL      wylab=0.9*wxdr
C@GL      call pushma
C@GL      call loadma(matrot0)
C@GL      call cmov(-wxlab,-wylab,0.0)
C@GL      call charst(name,namlen)
C@GL      call popmat
C@GL      call setcolor(1)
C@GL      call closeo
C@GL      call callob(idfname)
C@GLc     print *,'DRAWSEQ num=',num,' wxlab,wylab=',wxlab,wylab
C@GLc     write (6,1060) matrot0
C@GL1060  format(' DRAWSEQ loaded matrix:',/,(4i12))
C@GL      return
C@GL      end
C@GL      subroutine drawseqn(idseqn,num)
C@GLc     Write out a sequence number in the upper left corner
C@GL      common /graphics/ igl,npixx,npixy,maxpixx,maxpixy,idwmain,idwplot,
C@GL     -  wx,wy,wz,wxdr
C@GL      common /rotmat/ matrot0(4,4),matrot(4,4),
C@GL     -  nomat0
C@GL      character*9 number
C@GL#include <fgl.h>
C@GL#include <fdevice.h>
C@GL      write (number,1000) num
C@GL      call getrotmat(matrot0,nomat0,'DRSQ')
C@GL      call makeob(idseqn)
C@GL      call setcolor(7)
C@GL      wxlab=0.9*wxdr
C@GL      wylab=0.9*wxdr
C@GL      call pushma
C@GL      call loadma(matrot0)
C@GL      call cmov(-wxlab,wylab,0.0)
C@GL      call charst(number,9)
C@GL      call popmat
C@GL      call setcolor(1)
C@GL      call closeo
C@GL      call callob(idseqn)
C@GLc     print *,'DRAWSEQ num=',num,' wxlab,wylab=',wxlab,wylab
C@GLc     write (6,1060) matrot0
C@GL1060  format(' DRAWSEQ loaded matrix:',/,(4i12))
C@GL      return
C@GL1000  format(i9)
C@GL      end
C@GL      subroutine drawaxes(idaxes,scalefac,iperm)
C@GLc     Generate a display of axes in the upper left corner
C@GL      dimension cent(3)
C@GL      dimension axis(3),iaxcol(3)
C@GL      common /graphics/ igl,npixx,npixy,maxpixx,maxpixy,idwmain,idwplot,
C@GL     -  wx,wy,wz,wxdr
C@GL      character*1 xyz
C@GL      common /axislab/ xyz(3)
C@GL      data iaxcol /1,2,4/
C@GL#include <fgl.h>
C@GL#include <fdevice.h>
C@GL      call makeob(idaxes)
C@GL      call zeroit(cent,3)
C@GL      axl=scalefac*wy
C@GL      call linewi(3)
C@GL      call bgnlin
C@GL      do k=1,3
C@GL        call setcolor(iaxcol(k))
C@GL        call trnsfr(axis,cent,3)
C@GL        call v3f(axis)
C@GL        axis(k)=axis(k)+axl
C@GL        call v3f(axis)
C@GL      end do
C@GL      call endlin
C@GL      do k=1,3
C@GL        call setcolor(iaxcol(k))
C@GL        call trnsfr(axis,cent,3)
C@GL        axis(k)=axis(k)+axl*1.1
C@GL        call cmov(axis(1),axis(2),axis(3))
C@GL        call charst(xyz(k),1)
C@GL      end do
C@GL      call linewi(1)
C@GL      call closeo
C@GL      call callob(idaxes)
C@GL      return
C@GL      end
C@GL      subroutine drawnear(idimg,c,n,cell,ncell,ia1,ia2)
C@GL      dimension c(3,n),cell(3,27),d1(3),d2(3),cimg1(3),cimg2(3)
C@GL#include <fgl.h>
C@GL#include <fdevice.h>
C@GLc      write (6,7171) ia1,(c(k,ia1),k=1,3),ia2,(c(k,ia2),k=1,3)
C@GLc7171  format(' near ',i4,' c=',3f10.5)
C@GL      do k=1,3
C@GL        d1(k)=c(k,ia2)-c(k,ia1)
C@GL        d2(k)=c(k,ia1)-c(k,ia2)
C@GL      end do
C@GL      call genimdist(d1,cell,2,ncell,icmin1,rmin2)
C@GL      call genimdist(d2,cell,2,ncell,icmin2,rmin2)
C@GL      do k=1,3
C@GL        cimg1(k)=c(k,ia2)-cell(k,icmin1)
C@GL        cimg2(k)=c(k,ia1)-cell(k,icmin2)
C@GL      end do
C@GL      call makeob(idimg)
C@GL      call linewi(3)
C@GL      call connlinf(c(1,ia1),cimg1)
C@GL      call connlinf(c(1,ia2),cimg2)
C@GL      call setcolor(1)
C@GL      call cmov(c(1,ia1),c(2,ia1),c(3,ia1))
C@GL      call charst("*",1)
C@GLc     call circf(c(1,ia1),c(2,ia1),0.2)
C@GL      call cmov(cimg2(1),cimg2(2),cimg2(3))
C@GL      call charst("*",1)
C@GLc     call circf(cimg2(1),cimg2(2),0.2)
C@GL      call setcolor(3)
C@GL      call cmov(c(1,ia2),c(2,ia2),c(3,ia2))
C@GL      call charst("*",1)
C@GLc     call circf(c(1,ia2),c(2,ia2),0.2)
C@GL      call cmov(cimg1(1),cimg1(2),cimg1(3))
C@GL      call charst("*",1)
C@GLc     call circf(cimg1(1),cimg1(2),0.2)
C@GL      call linewi(1)
C@GL      call closeo
C@GL      call callob(idimg)
C@GL      return
C@GL      end
C@GL      subroutine drawmol(idmol,c,ian,isc,n,nslt,nneig,nhneig,ineig,
C@GL     -  isegno,iseghigh,maxng,inpfile,namleni,icolor,i2nd,lw,no5a,
C@GL     -  icentgra,centgra,nhbneig,idrawhb)
C@GL      dimension c(3,n),nneig(n),nhneig(n),ineig(maxng,n),ian(n),isc(n),
C@GL     -  isegno(n),centgra(3),nhbneig(n)
C@GL      common /graphics/ igl,npixx,npixy,maxpixx,maxpixy,idwmain,idwplot,
C@GL     -  wx,wy,wz,wxdr
C@GL      common /rotmat/ matrot0(4,4),matrot(4,4),nomat0
C@GL      common /depthcuedat/ near,ifar,ramp0,idepth,idepthon,idrawh,
C@GL     -  linew,isidec,nbackb,idrawslv
C@GL      character*200 inpfile
C@GL      dimension vp(3,2)
c     print *,'DRAWMOL n,nslt,maxng=',n,nslt,maxng
c      write (6,7177) (i,(c(k,i),k=1,3),i=1,10)
c7177  format(i5,3f10.4)
C@GL      call makeob(idmol)
C@GL      call getrotmat(matrot0,nomat0,'DRWM')
c     print *,'n,nslt=',n,nslt,' nsc=',nsc,' nbb=',nslt-nsc
C@GL      nsc=0
C@GL      do ia=1,nslt
C@GL        if (isc(ia) .ne. 0) nsc=nsc+1
C@GL      end do
C@GL      if (i2nd .eq. 0) then
C@GLc       Draw cell name and scale
C@GL        wylab=0.9*wxdr
C@GL        wxlab=0.9*wxdr
C@GL        call depthcueonoff(0)
C@GL        call pushma
C@GL        call loadma(matrot0)
C@GLc        write (6,1000) matrot0
C@GLc1000  format(' Matrix restored:',/,(4i12))
C@GL        if (no5a .eq. 0) then
C@GL          awl=35.0*2*wxdr/npixx
C@GL          call cmov(wxlab-awl-7.0,wylab,0.0)
C@GL          call setcolor(1)
C@GL          call charst("5 A: ",5)
C@GL          call linewi(3)
C@GL          vp(1,1)=wxlab-6.0
C@GL          vp(2,1)=wylab
C@GL          vp(3,1)=0.0
C@GL          vp(1,2)=wxlab-1.0
C@GL          vp(2,2)=wylab
C@GL          vp(3,2)=0.0
C@GL          call connlinf(vp(1,1),vp(1,2))
C@GL        end if
C@GL        call cmov(-wxlab,-wylab,0.0)
C@GL        if (namleni .gt. 0) call charst(inpfile,namleni)
C@GL        call popmat
C@GL      end if
C@GL      if (icentgra .gt. 0) call shiftmol(c,n,centgra,c,-1.0)
C@GL      call depthcueonoff(1)
C@GL      nadraw=n
C@GL      if (idrawslv .eq. 0) nadraw=nslt
C@GL      if (lw .ne. 0) then
C@GL        lwslt=lw
C@GL      else
C@GL        lwslt=linew
C@GL        if (nadraw .gt. nslt)  lwslt=2
C@GL      end if
C@GL      call linewi(lwslt)
C@GL      if (icolor .eq. 0) call setcolor(1)
C@GL      if (icolor .gt. 0) call setcolor(icolor)
C@GL      isegnoprev=0
C@GL      do i=1,nadraw
C@GL        if (icolor .eq. 0) then
C@GL          if (i .le. nslt) then
C@GL            if (isegno(i) .ne. isegnoprev) then
C@GL              if (isegno(i) .eq. iseghigh) then
C@GL                call linewi(3*lwslt)
C@GL              else
C@GL                call linewi(lwslt)
C@GL              end if
C@GL              call setcolor(mod(isegno(i)-1,6)+1)
C@GL              isegnoprev=isegno(i)
C@GL            end if
C@GL          else if (i .eq. nslt+1) then
C@GL            call setcolor(7)
C@GL          end if
C@GL        end if
C@GL        if ((idrawh .eq. 1 .or. ian(i) .gt. 1) .and.
C@GL     -     (isc(i) .eq. 0 .or. isidec .eq. 1)) then
C@GL          if (nneig(i) .eq. 0) then
C@GL            call cmov(c(1,i),c(2,i),c(3,i))
C@GL            call charst("*",1)
C@GL          else
C@GL            if (idrawh .eq. 1) then
C@GL              do j=1,nneig(i)
C@GL                if (ineig(j,i) .gt. i)
C@GL     -            call connlinf(c(1,i),c(1,ineig(j,i)))
C@GL              end do
C@GL            else
C@GL              if (nneig(i) .eq. nhneig(i)) then
C@GL                call cmov(c(1,i),c(2,i),c(3,i))
C@GL                call charst("*",1)
C@GL              else
C@GL                do j=1,nneig(i)
C@GL                  if (ineig(j,i) .gt. i .and. ian(ineig(j,i)) .gt.1)
C@GL     -              call connlinf(c(1,i),c(1,ineig(j,i)))
C@GL                end do
C@GL              end if
C@GL            end if
C@GL          end if
C@GL          if (i .eq. nslt) then
C@GL            call linewi(1)
C@GL            call setcolor(7)
C@GL          end if
C@GL        end if
C@GL      end do
C@GL      if (idrawhb .gt. 0) then
C@GL        call linewi(1)
C@GL        call setcolor(7)
C@GL        call setlin(3)
C@GL        do i=1,n
C@GL          if (ian(i) .eq. 1) then
C@GL            do j=maxng-nhbneig(i)+1,maxng
C@GL              call connlinf(c(1,i),c(1,ineig(j,i)))
C@GLc             write (77,*) 'HBond:',i,ineig(j,i)
C@GL            end do
C@GL          end if
C@GL        end do
C@GL        call setlin(0)
C@GL      end if
C@GL      call closeo
C@GL      call callob(idmol)
C@GL      call depthcueonoff(0)
C@GL      return
C@GL      end
C@GL      subroutine displaymol(idmol,idaxes,c,co,n,nslt,iatnum,nneig,ineig,
C@GL     -  nhneig,nhbneig,isegno,isc,filen,namlen,icg,centgra,nconfig,maxng)
C@GL      dimension c(3,n),co(3,n),iatnum(n),isegno(n),isc(n),centgra(3),
C@GL     -  nneig(n),nhneig(n),nhbneig(n),ineig(maxng,n)
C@GL      character*200 filen
C@GL      common /rotmat/ matrot0(4,4),matrot(4,4),nomat0
C@GLc     print *,'DISPLAYMOL n,nslt,maxng=',n,nslt,maxng
C@GL      call drawmol(idmol,c,iatnum,isc,n,nslt,nneig,nhneig,ineig,
C@GL     -  isegno,0,maxng,filen,namlen,0,0,0,0,icg,centgra,nhbneig,0)
C@GL      if (icg .gt. 0) call trnsfr(c,co,3*n)
C@GL      call drawaxes(idaxes,0.05,0)
C@GL      call swapbu
C@GL      irot=0
C@GL      if (nconfig .lt. 1)
C@GL     -  call askyn('Do you want to modify the display',33,1,-1,irot,0)
C@GL      nomat=1
C@GL      call getrotmat(matrot,nomat,'ASKR')
C@GL      if (irot .eq. 1) then
C@GL        nstep=0
C@GL        do while (nstep .ge. 0)
C@GL          call askrot(nstep)
C@GL          nomat=1
C@GL          call getrotmat(matrot,nomat,'ASKR')
C@GL          call setcolor(0)
C@GL          call clear()
C@GL          call setcolor(1)
C@GL          call drawmol(idmol,c,iatnum,isc,n,nslt,nneig,nhneig,ineig,
C@GL     -      isegno,0,maxng,filen,namlen,0,0,0,0,icg,centgra,
C@GL     -      nhbneig,0)
C@GL          call drawaxes(idaxes,0.05,0)
C@GL          call swapbu
C@GL          if (icg .gt. 0) call trnsfr(c,co,3*n)
C@GL        end do
C@GL        nomat=1
C@GL      end if
C@GL      return
C@GL      end
C@GL      subroutine drawkink(idkink,idaxes,idseqn,idfname,ncnf,nrep,c,n,
C@GL     -  axisinib,axisendb,axisinia,axisenda,shift,ishift,inpfile,namlen,
C@GL     -  noprol,ionehelix,icirc,inorm,cent,circ,rn)
C@GL      dimension c(3,n),shift(3)
C@GL      real*8 axisinib(3),axisendb(3),axisinia(3),axisenda(3),cent(3),
C@GL     -  circ(3),rn(3)
C@GL      character*(*) inpfile
C@GL      common /graphics/ igl,npixx,npixy,maxpixx,maxpixy,idwmain,idwplot,
C@GL     -  wx,wy,wz,wxdr
C@GL      common /rotmat/ matrot0(4,4),matrot(4,4),nomat0
C@GL      common /depthcuedat/ near,ifar,ramp0,idepth,idepthon,idrawh,
C@GL     -  linew,isidec,nbackb,idrawslv
C@GL      parameter (MAXHX=50)
C@GL      common /prokink/ icab(MAXHX),icaa(MAXHX),icb(MAXHX),ica(MAXHX),
C@GL     -  inb(MAXHX),ina(MAXHX),icapr,icpr,inpr,nra,nrb,icbpr,icgpr,icdpr,
C@GL     -  iprintpk
C@GL      dimension axinib(3),axendb(3),axinia(3),axenda(3),cmin(3),cmax(3)
C@GL      dimension c0(3),w(3),cc(3),cn(3),ca(3),cb(3),cg(3),cd(3),
C@GL     -  center(3),circle(3),rnorm(3)
C@GLc     Arrays of 3*MAXHX length
C@GL      dimension cbef(3,150),caft(3,150)
C@GL      if (nrep .lt. 0) return
C@GLc     iprintpk=ionehelix
C@GL      if (icbpr .eq. 0) icbpr=icapr
C@GL      if (icgpr .eq. 0) icgpr=icapr
C@GL      if (icdpr .eq. 0) icdpr=icapr
C@GL      if (ionehelix .eq. 0) then
C@GL        do k=1,3
C@GL          cmin(k)=dmin1(axisinib(k),axisinia(k),axisendb(k),axisenda(k))
C@GL          cmax(k)=dmax1(axisinib(k),axisinia(k),axisendb(k),axisenda(k))
C@GL        end do
C@GL      else
C@GL        do k=1,3
C@GL          cmin(k)=dmin1(axisinia(k),axisenda(k))
C@GL          cmax(k)=dmax1(axisinia(k),axisenda(k))
C@GL        end do
C@GL      end if
C@GL      do k=1,3
C@GL        c0(k)=(cmax(k)+cmin(k))/2.0
C@GL        w(k)=abs(cmax(k)-cmin(k))/2.0
C@GL        axinia(k)=axisinia(k)-c0(k)
C@GL        axenda(k)=axisenda(k)-c0(k)
C@GL        if (inorm .eq. 1) then
C@GL          center(k)=cent(k)
C@GL          rnorm(k)=4.0d0*rn(k)
C@GL        end if
C@GL        if (icirc .eq. 1) circle(k)=circ(k)
C@GL      end do
C@GL      if (ishift .eq. 1) call shiftmol(c0,1,shift,c0,+1.0)
C@GL      if (ionehelix .eq. 0) then
C@GL        do k=1,3
C@GL          axinib(k)=axisinib(k)-c0(k)
C@GL          axendb(k)=axisendb(k)-c0(k)
C@GL          if (noprol .eq. 0) then
C@GL            cc(k)=c(k,icpr)-c0(k)
C@GL            cn(k)=c(k,inpr)-c0(k)
C@GL            ca(k)=c(k,icapr)-c0(k)
C@GL            cb(k)=c(k,icbpr)-c0(k)
C@GL            cg(k)=c(k,icgpr)-c0(k)
C@GL            cd(k)=c(k,icdpr)-c0(k)
C@GL          end if
C@GL        end do
C@GL        na=1
C@GL        call trnsfr(caft,c(1,ica(1)),3)
C@GL        do ir=2,nra
C@GL          call trnsfr(caft(1,na+1),c(1,ina(ir)),3)
C@GL          call trnsfr(caft(1,na+2),c(1,icaa(ir)),3)
C@GL          call trnsfr(caft(1,na+3),c(1,ica(ir)),3)
C@GL          if (iprintpk .gt. 0) write (6,2000) ir,"after",
C@GL     -      ica(ir),(caft(k,nb+3),k=1,3),
C@GL     -      icaa(ir),(caft(k,nb+2),k=1,3),
C@GL     -      ina(ir),(caft(k,nb+1),k=1,3)
C@GL          na=na+3
C@GL        end do
C@GL        call trnsfr(cbef,c(1,inpr),3)
C@GL        nb=1
C@GL        do ir=1,nrb
C@GL          call trnsfr(cbef(1,nb+1),c(1,icb(ir)),3)
C@GL          call trnsfr(cbef(1,nb+2),c(1,icab(ir)),3)
C@GL          call trnsfr(cbef(1,nb+3),c(1,inb(ir)),3)
C@GL          if (iprintpk .gt. 0) write (6,2000) ir,"before",
C@GL     -      icb(ir),(cbef(k,nb+1),k=1,3),
C@GL     -      icab(ir),(cbef(k,nb+2),k=1,3),
C@GL     -      inb(ir),(cbef(k,nb+3),k=1,3)
C@GL          nb=nb+3
C@GL        end do
C@GL        call shiftmol(cbef,nb,c0,cbef,-1.0)
C@GL      else
C@GL        na=0
C@GL        do ir=1,nra
C@GL          call trnsfr(caft(1,na+3),c(1,ica(ir)),3)
C@GL          call trnsfr(caft(1,na+2),c(1,icaa(ir)),3)
C@GL          call trnsfr(caft(1,na+1),c(1,ina(ir)),3)
C@GL          if (iprintpk .gt. 0) write (6,2000) ir,"after",
C@GL     -      ica(ir),(caft(k,na+3),k=1,3),
C@GL     -      icaa(ir),(caft(k,na+2),k=1,3),
C@GL     -      ina(ir),(caft(k,na+1),k=1,3)
C@GL          na=na+3
C@GL        end do
C@GL      end if
C@GL      call shiftmol(caft,na,c0,caft,-1.0)
C@GL      if (inorm .gt. 0) then
C@GL        call shiftmol(center,1,c0,center,-1.0)
C@GL        call shiftmol(rnorm,1,center,rnorm,+1.0)
C@GL      end if
C@GL      if (icirc .gt. 1) call shiftmol(circle,1,c0,circle,-1.0)
C@GLc      write (77,6511) 'rnorm',rnorm
C@GLc6511  format(1x,a,'=',3f10.5)
C@GL      call setcolor(0)
C@GL      if (ncnf*nrep .eq. 1) then
C@GL        wx=amax1(w(1),w(2),w(3))+10.0
C@GL        wy=wx
C@GL        wz=1.5*wx
C@GL        wxdr=wx
C@GL        call ortho(-wx,wx,-wy,wy,-wz,wz)
C@GL        call getrotmat(matrot0,nomat0,'DRWK')
C@GL      end if
C@GL      call makeob(idkink)
C@GL      call setcolor(0)
C@GL      call pushma
C@GL      call setcolor(0)
C@GL      call clear
C@GL      call swapbu
C@GL      call setcolor(0)
C@GL      call clear
C@GL      nstep=0
C@GL      irot=-1
C@GL      do while (nstep .ge. 0)
C@GL        call depthcueonoff(1)
C@GL        if (noprol .eq. 0) then
C@GL          call setcolor(1)
C@GL          call linewi(6)
C@GL          call bgnlin
C@GL          call v3f(cn)
C@GL          call v3f(ca)
C@GL          call v3f(cb)
C@GL          call v3f(cg)
C@GL          call v3f(cd)
C@GL          call v3f(cn)
C@GL          call endlin
C@GL          call bgnlin
C@GL          call v3f(ca)
C@GL          call v3f(cc)
C@GL          call endlin
C@GL        end if
C@GL        call setcolor(2)
C@GL        call linewi(2)
C@GL        call bgnlin
C@GL        call v3f(caft(1,1))
C@GL        do ia=2,na
C@GL          call v3f(caft(1,ia))
C@GL        end do
C@GL        call endlin
C@GL        call setcolor(3)
C@GL        if (ionehelix .eq. 0) then
C@GL          call bgnlin
C@GL          call v3f(cbef(1,1))
C@GL          do ib=2,nb
C@GL            call v3f(cbef(1,ib))
C@GL          end do
C@GL          call endlin
C@GL        end if
C@GL        if (ionehelix .eq. 0) then
C@GL          call cmov(ca(1),ca(2),ca(3))
C@GL          call charst("*",1)
C@GL          i3=11
C@GL          call cmov(cbef(1,i3),cbef(2,i3),cbef(3,i3))
C@GL          call charst("3",1)
C@GL          i4=14
C@GL          call cmov(cbef(1,i4),cbef(2,i4),cbef(3,i4))
C@GL          call charst("4",1)
C@GL          call linewi(4)
C@GL        end if
C@GL        call setcolor(7)
C@GL        if (ionehelix .eq. 0) then
C@GL          call connlinf(axinib,axendb)
C@GL          call cmov(axendb(1),axendb(2),axendb(3))
C@GL          call charst("x",1)
C@GL        end if
C@GL        call connlinf(axinia,axenda)
C@GL        call cmov(axenda(1),axenda(2),axenda(3))
C@GL        call charst("x",1)
C@GL        if (icirc .eq. 1) then
C@GL          call connlinf(center,circle)
C@GL          call cmov(circle(1),circle(2),circle(3))
C@GL          call charst("o",1)
C@GL        end if
C@GL        if (inorm .eq. 1) then
C@GL          call connlinf(center,rnorm)
C@GL          call cmov(rnorm(1),rnorm(2),rnorm(3))
C@GL          call charst("N",1)
C@GL        end if
C@GL        call closeo
C@GL        call callob(idkink)
C@GL        call depthcueonoff(0)
C@GL        call drawseqn(idseqn,ncnf)
C@GL        call drawaxes(idaxes,0.05,0)
C@GL        call drawfilename(idfname,inpfile,namlen)
C@GL        call swapbu
C@GL        if (ncnf .eq. 1 .and. igl .eq. 1) then
C@GL          if (irot .eq. -1)
C@GL     -      call askyn('Do you want to modify the helix display',39,
C@GL     -        1,-1,irot,0)
C@GL          nomat=1
C@GL          if (irot .eq. 1) then
C@GL            call askrot(nstep)
C@GL            nomat=1
C@GL            call makeob(idkink)
C@GL            call getrotmat(matrot,nomat,'ASKR')
C@GL            call setcolor(0)
C@GL            call clear()
C@GL          else
C@GL            nstep=-1
C@GL          end if
C@GL        else
C@GL          nstep=-1
C@GL        end if
C@GL      end do
C@GL      return
C@GL2000  format(' DRAWKINK ir=',i2,'Helix atoms ',a,' the proline:',/,
C@GL     -  ' ic=',i5,'  cC=',3f10.5,/,' ica=',i5,' cCA=',3f10.5,/,
C@GL     -  ' in=',i5,'  cN=',3f10.5)
C@GL      end
C@GL      subroutine drawplot(cxy,xy,nframe,nframetot,title,ltitle,nrdiv,
C@GL     -  iclear)
C@GL      dimension cxy(2),xy(2,nframe)
C@GL      character*(*) title
C@GL      common /graphics/ igl,npixx,npixy,maxpixx,maxpixy,idwmain,idwplot,
C@GL     -  wx,wy,wz,wxdr
C@GL      dimension rxy(2)
C@GL      if (nframe .eq. 0) return
C@GLc     print *,'DRAWPLOT nframe,nframetot=',nframe,nframetot
C@GL      g2=0.05**2
C@GL      cx=cxy(1)
C@GL      cy=cxy(2)
C@GLc     print *,'DRAWPLOT cx,cy=',cx,cy,' nframe=',nframe
C@GLc     print *,title(1:ltitle)
C@GL      call makeob(idplot)
C@GL      call color(0)
C@GL      if (iclear .eq. 1) call clear
C@GL      call color(7)
C@GL      call linewi(1)
C@GL      call cmov(cx-1.0,cy+1.0,0.0)
C@GL      call charst(title,ltitle)
C@GL      call circ(cx,cy,1.0)
C@GL      if (nrdiv .gt. 1) then
C@GL        call setlin(2)
C@GL        do ir=1,nrdiv-1
C@GL          call circ(cx,cy,float(ir)/float(nrdiv))
C@GL        end do
C@GL        call setlin(0)
C@GL      end if
C@GL      call move(cx-1.0,cy,0.0)
C@GL      call draw(cx+1.0,cy,0.0)
C@GL      call move(cx,cy+1.0,0.0)
C@GL      call draw(cx,cy-1.0,0.0)
C@GL      call bgnlin
C@GL      call v2f(cxy)
C@GL      nft=nframetot
C@GL      if (nframetot .eq. 999999) nft=nframe
C@GL      do i=1,nframe
C@GL        rad=float(i)/float(nft)
C@GL        rxy(1)=cx+rad*xy(1,i)
C@GL        rxy(2)=cy+rad*xy(2,i)
C@GL        call v2f(rxy)
C@GL      end do
C@GL      call endlin
C@GL      call closeo
C@GL      call callob(idplot)
C@GL      return
C@GL      end
      subroutine drawpbc(edgexyz,edge_gen,ioppbc,ixyzhex,cent,i2nd,
C@GL     -  idpbc,icol,lw,
     -  icrot,crot,sizefac,ioutpdb)
      dimension edgexyz(3),edge_gen(3,3),cent(3),ixyzhex(3),crot(3,3),
     -  e2(3),vp(3,48),ixdup(48),hxy(2,6),vphl(3,7),vphu(3,7)
      common /graphics/ igl,npixx,npixy,maxpixx,maxpixy,idwmain,idwplot,
     -  wx,wy,wz,wxdr
      common /rotmat/ matrot0(4,4),matrot(4,4),nomat0
      common /pbcrotmat/ torot_ac(3,3),torot_ca(3,3),tofac_ac,tofac_ca
      common /depthcuedat/ near,ifar,ramp0,idepth,idepthon,idrawh,
     -  linew,isidec,nbackb,idrawslv
C@GL#include <fgl.h>
C@GL#include <fdevice.h>
c     print *,'DRAWPBC ioppbc=',ioppbc,' edge=',edgexyz,
c    -  ' sizefac=',sizefac
c     print *,'DRAWPBC cent=',cent
      if (ioppbc .gt. 9) return
      call indexit(ixdup,1,48,0)
      if (ioutpdb .gt. 0) iconntyp=2
C@GL      iconntyp=1
C@GL      if (ioutpdb .gt. 0) iconntyp=3
      wxold=wx
      wx=0.0
c     Establish world coordinate system
      npixmin=min0(npixx,npixy)
      if (ioppbc .eq. 1) then
        edgemax=edgexyz(1)
        wx=(edgemax/2.0)*sizefac
        edgexyz(2)=edgexyz(1)
        edgexyz(3)=edgexyz(1)
      else if (ioppbc .eq. 2) then
c       Rectangular cell
        edgemax=amax1(edgexyz(1),edgexyz(2),edgexyz(3))
        wx=(edgemax/2.0)*sizefac
      else if (ioppbc .eq. 3) then
        wx=edgexyz(1)*sizefac
      else if (ioppbc .eq. 4) then
        wx=amax1(edgexyz(1)/2,edgexyz(2))*sizefac
      else if (ioppbc .eq. 5) then
        wx=amax1(edgexyz(1)/2,edgexyz(2)/2,edgexyz(3)/2)*sizefac
      else if (ioppbc .eq. 6 .or. ioppbc .eq. 7) then
        wx=edgexyz(1)*sizefac
      else if (ioppbc .eq. 8) then
        wx=(edgexyz(1)/sqrt(3.0))*sizefac
      else if (ioppbc .eq. 9) then
       wx=edge_gen(1,1)*1.3*sizefac
      else if (ioppbc .eq. 10) then
        print *,'Sorry, no cell is to be drawn for inputted images'
      else if (ioppbc .eq. 11) then
        print *,'Sorry, no cell is to be drawn for sphere PBC'
      else
        print *,'ERROR: invalid pbc code=',ioppbc
      end if
      wx=wx+amax1(abs(cent(1)),amax1(abs(cent(2)),abs(cent(3))))
      if (wx .lt. 5.0) wx=5.0
      wy=wx
      wz=wx
      if (wx .gt. wxold .and. i2nd .eq. 0) then
C@GL        call ortho(-wx,+wx,-wy,+wy,-wz,+wz)
C@GL        wxdr=wx
      end if
C@GL      call getrotmat(matrot0,nomat0,'DRPB')
c     Start polyhedron object definition
C@GL      call makeob(idpbc)
      if (i2nd .eq. 0) then
c       Draw cell name
        wylab=0.9*wxdr
        wxlab=0.9*wxdr
c       print *,'wx,wxdr=',wx,wxdr,' wxlab,wylab=',wxlab,wylab
C@GL        call setcolor(icol)
C@GL        call pushma
C@GL        call loadma(matrot0)
C@GL        call cmov(0.5*wxlab,-wylab,0.0)
C@GL        if (ioppbc .eq. 1) call charst("CUBIC",5)
C@GL        if (ioppbc .eq. 2) call charst("RECTANGULAR",11)
C@GL        if (ioppbc .eq. 3) call charst("FACE-CENTERED CUBIC",19)
C@GL        if (ioppbc .eq. 4) call charst("HEXAGONAL PRISM",15)
C@GL        if (ioppbc .eq. 5) call charst("SKEWED HEXAGONAL PRISM",22)
C@GL        if (ioppbc .eq. 6 .or. ioppbc .eq. 7)
C@GL     -    call charst("TRUNCATED OCTAHEDRON",20)
C@GL        if (ioppbc .eq. 8) call charst("HEXAGONAL CLOSE-PACKED",22)
C@GL        call popmat
      end if
C@GL      call depthcueonoff(1)
C@GL      call setcolor(icol)
C@GL      call linewi(lw)
C@GL      call cmov(-wx+0.1*wx,wy-0.1*wy,0.0)
      if (ioppbc .eq. 1 .or. ioppbc .eq. 2) then
c       Rectangular cell
        nv=8
c       e2: half edges in pixel
        do k=1,3
          e2(k)=edgexyz(k)/2.0
        end do
c       vp(k,1-4): y-z face at the -x side
        vp(2,1)=-e2(2)
        vp(3,1)=-e2(3)
        vp(2,2)=+e2(2)
        vp(3,2)=-e2(3)
        vp(2,3)=+e2(2)
        vp(3,3)=+e2(3)
        vp(2,4)=-e2(2)
        vp(3,4)=+e2(3)
c       vp(k,5-8): y-z face at the +x side
        do m=1,4
          vp(1,m)=-e2(1)
          vp(1,m+4)=+e2(1)
          do k=2,3
            vp(k,m+4)=vp(k,m)
          end do
        end do
        call shiftmol(vp,8,cent,vp,1.0)
        call  writevertices(vp,8,ioppbc,ioutpdb,iconntyp,icrot,crot)
        do m=1,4
c         Top polygon edge
          call connlinix(vp,m,mod(m,4)+1,ixdup,iconntyp,ioutpdb,48)
c         Bottom polygon edge
          call connlinix(vp,m+4,mod(m,4)+5,ixdup,iconntyp,ioutpdb,48)
c         Edge parallel to the prizm's axis
          call connlinix(vp,m,m+4,ixdup,iconntyp,ioutpdb,48)
        end do
      else if (ioppbc .eq. 3) then
c       FCC
        nv=14
        edge=edgexyz(1)
        edge2=edgexyz(1)/2.0
        call zeroit(vp,3*6)
        do k=1,3
          vp(k,2*(k-1)+1)=-edge
          vp(k,2*k)=edge
        end do
        do i=1,4
          vp(1,2*(i-1)+7)=(-1)**i*edge2
          vp(1,2*(i-1)+8)=vp(1,2*(i-1)+7)
          vp(2,2*(i-1)+7)=(-1)**((i-1)/2)*edge2
          vp(2,2*(i-1)+8)=vp(2,2*(i-1)+7)
          vp(3,2*(i-1)+7)=-edge2
          vp(3,2*(i-1)+8)=+edge2
        end do
        call shiftmol(vp,14,cent,vp,1.0)
        call finddup(vp,ixdup,14,nunique)
        call  writevertices(vp,nunique,ioppbc,ioutpdb,iconntyp,
     -    icrot,crot)
        call connlinix(vp,1,07,ixdup,iconntyp,ioutpdb,48)
        call connlinix(vp,1,08,ixdup,iconntyp,ioutpdb,48)
        call connlinix(vp,1,11,ixdup,iconntyp,ioutpdb,48)
        call connlinix(vp,1,12,ixdup,iconntyp,ioutpdb,48)
        call connlinix(vp,2,09,ixdup,iconntyp,ioutpdb,48)
        call connlinix(vp,2,10,ixdup,iconntyp,ioutpdb,48)
        call connlinix(vp,2,13,ixdup,iconntyp,ioutpdb,48)
        call connlinix(vp,2,14,ixdup,iconntyp,ioutpdb,48)
        call connlinix(vp,3,11,ixdup,iconntyp,ioutpdb,48)
        call connlinix(vp,3,12,ixdup,iconntyp,ioutpdb,48)
        call connlinix(vp,3,13,ixdup,iconntyp,ioutpdb,48)
        call connlinix(vp,3,14,ixdup,iconntyp,ioutpdb,48)
        call connlinix(vp,4,07,ixdup,iconntyp,ioutpdb,48)
        call connlinix(vp,4,08,ixdup,iconntyp,ioutpdb,48)
        call connlinix(vp,4,09,ixdup,iconntyp,ioutpdb,48)
        call connlinix(vp,4,10,ixdup,iconntyp,ioutpdb,48)
        call connlinix(vp,5,07,ixdup,iconntyp,ioutpdb,48)
        call connlinix(vp,5,09,ixdup,iconntyp,ioutpdb,48)
        call connlinix(vp,5,13,ixdup,iconntyp,ioutpdb,48)
        call connlinix(vp,5,11,ixdup,iconntyp,ioutpdb,48)
        call connlinix(vp,6,08,ixdup,iconntyp,ioutpdb,48)
        call connlinix(vp,6,10,ixdup,iconntyp,ioutpdb,48)
        call connlinix(vp,6,14,ixdup,iconntyp,ioutpdb,48)
        call connlinix(vp,6,12,ixdup,iconntyp,ioutpdb,48)
      else if (ioppbc .eq. 4 .or. ioppbc .eq. 5) then
c       Hexagonal prism
        nv=12
        edgep2=edgexyz(1)/2.0
        if (ioppbc .eq. 4) then
          edgey=edgexyz(2)
          esq3p2=edgey*(sqrt(3.0)/2.0)
          vp(ixyzhex(2),1)=edgey
          vp(ixyzhex(2),2)=edgey/2.0
          vp(ixyzhex(3),2)=esq3p2
        else
          edgex=edgexyz(3)
          edgey=edgexyz(2)
          w=sqrt(edgey**2-edgex**2/4.0)
          h=(w-edgex/(2.0*sqrt(3.0)))/2.0
          vp(ixyzhex(2),1)=w-h
          vp(ixyzhex(3),2)=edgex/2.0
          vp(ixyzhex(2),2)=h
        end if
        vp(ixyzhex(3),1)=0.0
        vp(ixyzhex(3),3)=vp(ixyzhex(3),2)
        vp(ixyzhex(2),3)=-vp(ixyzhex(2),2)
        vp(ixyzhex(2),4)=-vp(ixyzhex(2),1)
        vp(ixyzhex(3),4)=0.0
        vp(ixyzhex(2),5)=-vp(ixyzhex(2),2)
        vp(ixyzhex(3),5)=-vp(ixyzhex(3),2)
        vp(ixyzhex(2),6)=-vp(ixyzhex(2),3)
        vp(ixyzhex(3),6)=-vp(ixyzhex(3),3)
        do m=1,6
          vp(ixyzhex(1),m)=-edgep2
          vp(ixyzhex(1),m+6)=+edgep2
          do k=2,3
            vp(ixyzhex(k),m+6)=vp(ixyzhex(k),m)
          end do
        end do
        call shiftmol(vp,12,cent,vp,1.0)
        call  writevertices(vp,12,ioppbc,ioutpdb,iconntyp,icrot,crot)
        do m=1,6
c         Top polygon edge
          call connlinix(vp,m,mod(m,6)+1,ixdup,iconntyp,ioutpdb,48)
c         Bottom polygon edge
          call connlinix(vp,m+6,mod(m,6)+7,ixdup,iconntyp,ioutpdb,48)
c         Edge parallel to the prizm's axis
          call connlinix(vp,m,m+6,ixdup,iconntyp,ioutpdb,48)
        end do
      else if (ioppbc .eq. 6 .or. ioppbc .eq. 7) then
c       Truncated octahedron cell
        eto2=edgexyz(1)
        eto=edgexyz(1)/2.0
        print *,'eto,sto2=',eto,eto2
        call zeroit(vp,(3*6*8))
c       Hexagon face (+x,+y,+z) quadrant
        vp(1,1)=eto
        vp(3,1)=eto2
        vp(2,2)=eto
        vp(3,2)=eto2
        vp(2,3)=eto2
        vp(3,3)=eto
        vp(1,4)=eto
        vp(2,4)=eto2
        vp(1,5)=eto2
        vp(2,5)=eto
        vp(1,6)=eto2
        vp(3,6)=eto
c       Hexagon face 2 (+x,+y,-z) quadrant
        vp(1,1+6)=eto
        vp(3,1+6)=-eto2
        vp(2,2+6)=eto
        vp(3,2+6)=-eto2
        vp(2,3+6)=eto2
        vp(3,3+6)=-eto
        vp(1,4+6)=eto
        vp(2,4+6)=eto2
        vp(1,5+6)=eto2
        vp(2,5+6)=eto
        vp(1,6+6)=eto2
        vp(3,6+6)=-eto
c       Hexagon face 3 (-x,+y,-z) quadrant
        vp(1,1+12)=-eto
        vp(3,1+12)=-eto2
        vp(2,2+12)=eto
        vp(3,2+12)=-eto2
        vp(2,3+12)=eto2
        vp(3,3+12)=-eto
        vp(1,4+12)=-eto
        vp(2,4+12)=eto2
        vp(1,5+12)=-eto2
        vp(2,5+12)=eto
        vp(1,6+12)=-eto2
        vp(3,6+12)=-eto
c       Hexagon face 4 (-x,+y,+z) quadrant
        vp(1,1+18)=-eto
        vp(3,1+18)=eto2
        vp(2,2+18)=eto
        vp(3,2+18)=eto2
        vp(2,3+18)=eto2
        vp(3,3+18)=eto
        vp(1,4+18)=-eto
        vp(2,4+18)=eto2
        vp(1,5+18)=-eto2
        vp(2,5+18)=eto
        vp(1,6+18)=-eto2
        vp(3,6+18)=eto
c       Hexagon face 5 (+x,-y,+z) quadrant
        vp(1,1+24)=eto
        vp(3,1+24)=eto2
        vp(2,2+24)=-eto
        vp(3,2+24)=eto2
        vp(2,3+24)=-eto2
        vp(3,3+24)=eto
        vp(1,4+24)=eto
        vp(2,4+24)=-eto2
        vp(1,5+24)=eto2
        vp(2,5+24)=-eto
        vp(1,6+24)=eto2
        vp(3,6+24)=eto
c       Hexagon face 6 (+x,-y,-z) quadrant
        vp(1,1+30)=eto
        vp(3,1+30)=-eto2
        vp(2,2+30)=-eto
        vp(3,2+30)=-eto2
        vp(2,3+30)=-eto2
        vp(3,3+30)=-eto
        vp(1,4+30)=eto
        vp(2,4+30)=-eto2
        vp(1,5+30)=eto2
        vp(2,5+30)=-eto
        vp(1,6+30)=eto2
        vp(3,6+30)=-eto
c       Hexagon face 7 (-x,-y,-z) quadrant
        vp(1,1+36)=-eto
        vp(3,1+36)=-eto2
        vp(2,2+36)=-eto
        vp(3,2+36)=-eto2
        vp(2,3+36)=-eto2
        vp(3,3+36)=-eto
        vp(1,4+36)=-eto
        vp(2,4+36)=-eto2
        vp(1,5+36)=-eto2
        vp(2,5+36)=-eto
        vp(1,6+36)=-eto2
        vp(3,6+36)=-eto
c       Hexagon face 8 (-x,-y,+z) quadrant
        vp(1,1+42)=-eto
        vp(3,1+42)=eto2
        vp(2,2+42)=-eto
        vp(3,2+42)=eto2
        vp(2,3+42)=-eto2
        vp(3,3+42)=eto
        vp(1,4+42)=-eto
        vp(2,4+42)=-eto2
        vp(1,5+42)=-eto2
        vp(2,5+42)=-eto
        vp(1,6+42)=-eto2
        vp(3,6+42)=eto
        if (ioppbc .eq. 7)
     -    call rotate_c(vp,48,torot_ca,vp,'VERTICES',8)
        call shiftmol(vp,48,cent,vp,1.0)
        call finddup(vp,ixdup,48,nunique)
        call  writevertices(vp,nunique,ioppbc,ioutpdb,iconntyp,
     -    icrot,crot)
        do ifa=1,8
          do m=1,6
            call connlinix(vp,m+(ifa-1)*6,mod(m,6)+1+(ifa-1)*6,ixdup,
     -        iconntyp,ioutpdb,48)
          end do
        end do
      else if (ioppbc .eq. 8) then
C       Hexagonal close-packed
        d=edgexyz(1)
        t=d*sqrt(3.0)/(2.0*sqrt(2.0))
        hl=d/(2.0*sqrt(6.0))
        hh=(t+hl)/2.0
c       print *,'t,hh,hl=',t,hh,hl
c       x-y coordinates of wrapping hexagon vertices
        hxy(1,1)=d/2.0
        hxy(2,1)=-d/(2.0*sqrt(3.0))
        hxy(1,2)=0.0
        hxy(2,2)=-d/sqrt(3.0)
        hxy(1,3)=-d/2.0
        hxy(2,3)=-d/(2.0*sqrt(3.0))
        hxy(1,4)=-d/2.0
        hxy(2,4)=+d/(2.0*sqrt(3.0))
        hxy(1,5)=0.0
        hxy(2,5)=d/sqrt(3.0)
        hxy(1,6)=d/2.0
        hxy(2,6)=+d/(2.0*sqrt(3.0))
        call zeroit(vp,6)
        vp(3,1)=t
        vp(3,2)=-t
c       Top rhombuses
c       First the chair hexagon
        do i=1,6
          call trnsfr(vphu(1,i),hxy(1,i),2)
          if (mod(i,2) .eq. 1) then
            vphu(3,i)=hl
          else
            vphu(3,i)=hh
          end if
        end do
        call trnsfr(vp(1,3),vphu,18)
c       Bottom rhombuses
        call trnsfr(vphl(1,1),vphu(1,1),21)
        do k=1,7
          vphl(3,k)=-vphl(3,k)
        end do
        call trnsfr(vp(1,9),vphl,18)
        call finddup(vp,ixdup,14,nunique)
        call  writevertices(vp,nunique,ioppbc,ioutpdb,iconntyp,
     -    icrot,crot)
c       Top rhombuses
        do m=1,6
          call connlinix(vp,m+2,mod(m,6)+3,ixdup,iconntyp,ioutpdb,48)
        end do
        do k=2,6,2
          call connlinix(vp,1,k+2,ixdup,iconntyp,ioutpdb,48)
        end do
c       Bottom rhombuses
        do m=1,6
          call connlinix(vp,8+m,mod(m,6)+9,ixdup,iconntyp,ioutpdb,48)
        end do
        do k=2,6,2
          call connlinix(vp,2,k+8,ixdup,iconntyp,ioutpdb,48)
        end do
c       Side connections
        do i=1,6
          call connlinix(vp,i+2,i+8,ixdup,iconntyp,ioutpdb,48)
        end do
      else if (ioppbc .eq. 9) then
c       Octahedral - draw parallelepiped
c       print *,'DRAWPBC ioppbc=9 '
        do k=1,3
          vp(k,1)=(-edge_gen(k,1)-edge_gen(k,2)-edge_gen(k,3))/2.0
        end do
        call arrsum(vp(1,1),edge_gen(1,1),vp(1,2),3)
        call arrsum(vp(1,2),edge_gen(1,2),vp(1,3),3)
        call arrsum(vp(1,1),edge_gen(1,2),vp(1,4),3)
        call arrsum(vp(1,1),edge_gen(1,3),vp(1,5),3)
        call arrsum(vp(1,5),edge_gen(1,1),vp(1,6),3)
        call arrsum(vp(1,6),edge_gen(1,2),vp(1,7),3)
        call arrsum(vp(1,5),edge_gen(1,2),vp(1,8),3)
        call  writevertices(vp,8,ioppbc,ioutpdb,iconntyp,
     -    icrot,crot)
        do m=1,4
          call connlinix(vp,m,mod(m,4)+1,ixdup,iconntyp,ioutpdb,48)
          call connlinix(vp,m+4,mod(m,4)+5,ixdup,iconntyp,ioutpdb,48)
          call connlinix(vp,m,m+4,ixdup,iconntyp,ioutpdb,48)
        end do
      end if
C@GL      call linewi(1)
C@GL      call closeo
C@GL      call callob(idpbc)
c        write (6,7171) (i,(vp(k,i),k=1,3),i=1,nv)
c7171    format(i5,3f10.3)
C@GL      call depthcueonoff(0)
      return
      end
      subroutine writevertices(vp,n,ioppbc,ioutpdb,iconntyp,icrot,crot)
      character*3 pbcres
      dimension vp(3,n),crot(3,3)
      common /pbcresname/ pbcres(10)
      real*8 c8(3)
c     print *,'WRITEVERTICES n=',n,' icrot=',icrot
c     print *,'crot=',crot
      if (iconntyp .eq. 1) return
      if (icrot .eq. 1) call rotate_c(vp,n,crot,vp,'WVERTICES',9)
      do ia=1,n
        do k=1,3
          c8(k)=vp(k,ia)
        end do
        call writepdbd(ioutpdb,c8,ia,1,'VERT',pbcres(ioppbc),'V',1.0,0.)
      end do
      return
      end
C@GL      subroutine connlinf(p1,p2)
C@GL      dimension p1(3),p2(3)
C@GLc     Just draw a line connecting p1 & p2
C@GL      call bgnlin
C@GL      call v3f(p1)
C@GL      call v3f(p2)
C@GL      call endlin
C@GL      return
C@GL      end
      subroutine connlinix(p,i1,i2,ixdup,iconntyp,ioutpdb,max)
      dimension p(3,max)
      dimension ixdup(max)
c     Just draw a line connecting p(i1) & p(i2)
c     iconntyp = 1,2,3: SGI, PDB, both
      if (iconntyp .ne. 2) then
C@GL        call bgnlin
C@GL        call v3f(p(1,ixdup(i1)))
C@GL        call v3f(p(1,ixdup(i2)))
C@GL        call endlin
      end if
      if (iconntyp .ne. 1) then
        if (ixdup(i1) .lt. ixdup(i2)) then
          write (ioutpdb,1000) ixdup(i1),ixdup(i2)
        else
          write (ioutpdb,1000) ixdup(i2),ixdup(i1)
        end if
      end if
      return
1000  format('CONECT',2i5)
      end
      subroutine finddup(p,ixdup,n,nunique)
      dimension p(3,n),ixdup(n),ixshift(48)
      do i=2,n
        do j=1,i-1
          if (ixdup(j) .eq. j) then
            if (dist2(p(1,i),p(1,j)) .le. 0.001) then
              ixdup(i)=j
              go to 100
            end if
          end if
        end do
100     continue
      end do
      ndel=0
      do i=1,n
        if (ixdup(i) .ne. i) then
c         Duplicate - delete
          ndel=ndel+1
        else
          call trnsfr(p(1,i-ndel),p(1,i),3)
          ixshift(i)=i-ndel
        end if
      end do
      do i=1,n
        ixdup(i)=ixshift(ixdup(i))
      end do
      nunique=n-ndel
c      write (6,7777) n,nunique,(ixdup(i),i=1,n)
c7777  format(' FINDDUP n,nunique=',2i6,(' ixdup=',10i3,3x,10i3))
      return
      end
C@GL      subroutine makdptcmap(maxcol,ramp0)
C@GL      integer*2 ir,ig,ib
C@GL      do ic=1,maxcol
C@GL        call getmco(ic,ir,ig,ib)
C@GL        do int=1,100
C@GL          ix=100*ic+int
C@GL          fac=ramp0+(1.0-ramp0)*float(int)/100.0
C@GL          irj=fac*ir
C@GL          igj=fac*ig
C@GL          ibj=fac*ib
C@GL          call mapcol(ix,irj,igj,ibj)
C@GL        end do
C@GL      end do
C@GL      return
C@GL      end
      subroutine setcolor(ic)
      common /depthcuedat/ near,ifar,ramp0,idepth,idepthon,idrawh,
     -  linew,isidec,nbackb,idrawslv
c     print *,'SETCOLOR idepthon,ic,idepth=',idepthon,ic,idepth
      if (idepthon*idepth .eq. 1) then
        if (ic .eq. 0) then
C@GL        call lshade(0,0,near,ifar)
        else
          i1=100*ic+1
          i2=100*(ic+1)
C@GL        call lshade(i1,i2,near,ifar)
        end if
      else
C@GL        call color(ic)
      end if
      return
      end
      subroutine depthcueonoff(ion)
      common /depthcuedat/ near,ifar,ramp0,idepth,idepthon,idrawh,
     -  linew,isidec,nbackb,idrawslv
      if (ion .eq. 1) then
C@GL        if (idepth .eq. 1) call depthc(.true.)
        idepthon=1
      else
C@GL        if (idepth .eq. 1) call depthc(.false.)
        idepthon=0
      end if
      return
      end
c     Subroutines for helix axis calculation Copyright 1996 Jon A.Christopher
c     and Thomas O. Baldwin at Texas A&M University.
      subroutine kahn(co,nats,docircfit,dir,ip,fp,rms,
     -  iprint,message,MAXHX)
      implicit real*8(a-h,o-z)
c     ref. Computers in Chemistry Vol 13, No 3, pg 191, 1989
c     Approach: Construct a vector A from ca atom i to i-1. Construct B
c     from i to i+1.  Find V1, the vector which bisects A and B.  V1 is
c     perpendicuar to the helix axis (for a perfect mathematical helix).
c     Let i = i + 1 and repeat the procedure, finding V2.  As V1 and V2
c     are both perp. to the helical axis, their cross product gives the
c     helix direction.   Average over all possible tetrads of ca atoms,
c     or use a 3-D fitting method to give the direction based on the
c     points calculated to lie on the axis.
c
c     P1 and P2 are the vectors from the origin to CA 1 and CA 2.
c
c     The radius is a calculated as:
c     |dH|**2 - |p2-p1|**2
c     r = --------------------
c     2 * |(p1-p2) dot v2|
c     where d= (p2-p1) dot h
c
c     H1 and H2 are the position vectors
c     H1 = P1 + r*V1
c     H2 = P2 + r*V2
c
 
      real*8 co(3,MAXHX)
      integer nats,iprint
      real*8 ip(3)              !the coordinates of the initial point
      real*8 fp(3)              !the coordinates of the final point
      real*8 dir(3)             !the axis vector
 
      logical docircfit
 
      character*60 Message
      real*8 hsum(3)
c     Arrays of length MAXHX
 
      real*8 p1(3),p2(3),h(3),v1(3),v2(3),a(3),b(3),r,d
      real*8 tmp(3),p1mp2(3),p2mp1(3),dmag,ddot
c     Arrays of length 3,2*MAXHX
      real*8 h1(3,100)
      integer hcount
 
      if (iprint .gt. 3) write (6,7777) ((co(k,i),k=1,3),i=1,nats)
7777  format(' Axis routine input:',/,(3f10.4))
 
      do i=1,3
         hsum(i)=0.0
      end do
      hcount=1
      do i=2,nats-2
c     load p1 and p2
         call dvset(p1,co(1,i))
         call dvset(p2,co(1,i+1))
c     get vector v1
         call dvdif (p1,co(1,i-1),a)
         call dvdif (p1,co(1,i+1),b)
         call dvnorm(a)
         call dvnorm(b)
         call dvsum(a,b,v1)
         call dvnorm(v1)
c     get vector v2
         call dvdif (p2,co(1,i),a)
         call dvdif (p2,co(1,i+2),b)
         call dvnorm(a)
         call dvnorm(b)
         call dvsum(a,b,v2)
         call dvnorm(v2)
 
c     H=direction of axis
         call dcross(v1,v2,h)
         call dvnorm(h)
         call dvsum(h,hsum,hsum)
 
c     calculate radius
         call dvdif (p1,p2,p1mp2)
         call dvdif (p2,p1,p2mp1)
         d=ddot(p2mp1,h)        !rise/residue
         call dvmul(h,d,tmp)
 
c     kahn
         r=(dmag(tmp)**2 - dmag(p2mp1)**2)
     -        /(2.0*abs(ddot(p2mp1,v2)))
 
c     calculate the points on the axis
         call dvmul(V1,r,tmp)
         call dvsum(P1,tmp,H1(1,hcount))
         call dvmul(V2,r,tmp)
         call dvsum(P2,tmp,H1(1,hcount+1))
c     hcount=hcount+1
         hcount=hcount+2
      end do
 
      call dvset(dir,hsum)
      call dvnorm(dir)
 
      call parlsq(h1,hcount-1,docircfit,dir,ip,fp,rms,0)
 
      if (docircfit) then
         call circfit(co,nats,dir,ip)
      else
c     adjust ip to be next to the first alpha carbon, not the second
         call dvdif (co(1,1),ip,tmp)
         call dvproj(dir,tmp,tmp)
         call dvsum(ip,tmp,ip)
      end if
 
      call RMScalc(co,nats,dir,ip,fp,RMS)
      call writeout_h(dir,ip,fp,rms,message,iprint)
      return
      end
 
      subroutine vaset(v,x,y,z)
c     from kahn's package
      real*4 v(3),x,y,z
      V(1) = X
      V(2) = Y
      V(3) = Z
      RETURN
      end
 
      subroutine VNRM(B,A)
c     from kahn's package
      real*4 b(3),a(3)
C
      SUM2 = A(1)*A(1) + A(2)*B(2) + A(3)*A(3)
      IF (SUM2 .LT. 1.0E-8) GO TO 50
      SUM = SQRT(SUM2)
      B(1) = A(1) / SUM
      B(2) = A(2) / SUM
      B(3) = A(3) / SUM
      RETURN
C
 50   B(1) = 0.0
      B(2) = 0.0
      B(3) = 0.0
      RETURN
      end
 
 
      subroutine parlsq(co,n,docircfit,dir,ip,fp,rms,iprint)
c     calculates the axis of a helix from alpha carbon coordinates using
c     linear least squares regressions of atom number versus x,y, and z
c     coordinates.
 
      implicit real*8(a-h,o-z)
      real*8 co(3,n)
      integer n,iprint          !n=number of atoms
      real*8 ip(3)              !the coordinates of the initial point
      real*8 fp(3)              !the coordinates of the final point
      real*8 dir(3)             !the axis vector
      logical docircfit
 
      character*60 message
c     print *,'PARLSQ MAXHX,n=',MAXHX,n
c      write (6,7777) ((co(k,i),k=1,3),i=1,n)
c7777  format(' PARLSQ input:',/,(3f10.4))
c      print *,'docircfit=',docircfit
 
      St=0.
      Srx=0.
      Sry=0.
      Srz=0.
      St_rx=0.
      St_ry=0.
      St_rz=0.
      St2=0.
      do i=1,n
         t= i-1
         St=St + t
         Srx=Srx + co(1,i)
         Sry=Sry + co(2,i)
         Srz=Srz + co(3,i)
         St_rx=St_rx + t * co(1,i)
         St_ry=St_ry + t * co(2,i)
         St_rz=St_rz + t * co(3,i)
         St2=St2 + t**2
      end do
 
      D=St2*n - St*St
      dir(1)=(n*St_rx - St*Srx)/D
      dir(2)=(n*St_ry - St*Sry)/D
      dir(3)=(n*St_rz - St*Srz)/D
 
      if (docircfit) then
c     use circular fit for ip
         call circfit(co,n,dir,ip)
      else
c     use least-squares initial point
         ip(1) =(St2*Srx - St*St_rx)/D
         ip(2) =(St2*Sry - St*St_ry)/D
         ip(3) =(St2*Srz - St*St_rz)/D
      end if
 
      call dvnorm(dir)
      call RMScalc(co,n,dir,ip,fp,RMS)
      message='parlsq'
      call writeout_h(dir,ip,fp,rms,message,iprint)
      end
 
 
C     these are the common subroutines for the helix suite
 
      subroutine RMScalc(co,nats,dir,ip,fp,rms)
      implicit real*8(a-h,o-z)
      real*8 co(3,nats) !the input coordinates
c     Modified from the original to calculate the sd of the atom to axis dist
      integer nats              !number of atoms
      real*8 ip(3)              !the coordinates of the initial point
      real*8 fp(3)              !the coordinates of the final point
      real*8 dir(3)             !the axis vector
 
      real*8 tmp(3)
 
c     calculate rms deviations
      rms=0.0
      sum=0.0
      sum2=0.0
      do i=1,nats
         call dvdif (co(1,i),ip,tmp)
         call dvproj(dir,tmp,tmp)
         call dvsum(ip,tmp,fp)
         dd=ddistsq(co(1,i),fp)
         sum=sum+sqrt(dd)
         sum2=sum2+dd
      end do
      rms=sqrt(sum2/float(nats)-(sum/float(nats))**2)
      end
 
      subroutine writeout_h(dir,ip,fp,rms,message,iprint)
      real*8 dir(3),ip(3),fp(3),rms
      integer iprint,kprint
      character*60 message
 
c     don't waste time
      kprint=mod(iprint,10)
      if (kprint .eq. 0) return
 
 10   format(a6,1x,3(f12.6,1x))
 20   format('     RMS deviation: ',f11.6)
      if (message(1:5) .ne. '     ') write(*,*) '  '//message
      write(*,10) '     D',dir
      write(*,10) '     I',ip
      write(*,10) '     F',fp
      write(*,20) rms
      end
 
      subroutine circfit(x,nats,dir,ip)
      implicit real*8 (a-h,o-z)
      real*8 x(3,nats)
c     Array of 3,2*MAXHX length
      real*8 xp(3,100)
      real*8 ax(6),sum(5),xp0(3)
      real*8 dir(3),ip(3),tmp(3)
      real*8 zero(3)
      integer nats
c     calculates the best-fit circle to a set of data and returns the
c     center in ip
c     x=the coordinates
c     dir(input) the direction vector
c     ip(output) the position vector
c     print *,'CIRCFIT nats,MAXHX=',nats,MAXHX
 
      data zero/0.,0.,0./
c     rotate the coordinates
c
c     read input
      call dvset(ax(1),ip)
      call dvset(ax(4),dir)
 
c      write(*,*) 'got ax:'
c      write(*,'(6(x,f8.3))') ax
c      write(*,*) 'got nats:',nats
c      write(*,*) 'got coords:'
c      do i=1,nats
c         write(*,'(3(x,f8.3))') (x(k,i),k=1,3)
c      end do
 
      call polar(dir(1),dir(2),dir(3),r,thet,fi)
c     write(*,*) 'Theta,phi',thet,fi
      do iat=1,nats
         call dvset(xp(1,iat),x(1,iat))
         call rotabout(xp(1,iat),zero,-thet,'z')
         call rotabout(xp(1,iat),zero,-fi,'y')
      end do
      call dvset(tmp,dir)
      do i=1,5
         sum(i)=0.
      end do
 
      do i=1,nats
         do j=i+1,nats
            sum(1)=sum(1)+(xp(1,i)-xp(1,j))**2
            sum(2)=sum(2)+(xp(2,i)-xp(2,j))**2
            sum(3)=sum(3)+(xp(1,i)-xp(1,j))*(xp(2,i)-xp(2,j))
            scrat=xp(1,i)**2+xp(2,i)**2-xp(1,j)**2-xp(2,j)**2
            sum(4)=sum(4)+scrat*(xp(1,i)-xp(1,j))
            sum(5)=sum(5)+scrat*(xp(2,i)-xp(2,j))
         end do
      end do
c     write(*,'(''sum'',5(x,f8.3))') sum
 
      xp0(1)=(sum(4)*sum(2)-sum(5)*sum(3))/
     -     (2.0*(sum(1)*sum(2)-sum(3)**2))
      xp0(2)=(sum(4)-2.0*xp0(1)*sum(1))/(2.0*sum(3))
      xp0(3)=xp(3,1)            !z coordinate of first atom
      call rotabout(xp0,zero,fi,'y')
      call rotabout(xp0,zero,thet,'z')
      call dvset(ax,xp0)
 
c     save output
      call dvset(ip,ax)
c     write(*,*) 'Output ip, dir'
c     write(*,'(6(x,f8.3))') ax
      end
 
c     ------------------------------------------general vector routines
 
      subroutine polar(x,y,z,r,theta,phi)
c     Return polar coordinates for point (x,y,z)
      real*8 x,y,z,r,theta,phi
      data PI /3.1415926/
      real*8 cosa
c     NOTE: Unlike most conventions, phi is the angle between R and the Z axis
 
      r=(x**2 + y**2 + z**2)**0.5
      if ((x .ne. 0.0) .and. (y .ne. 0.0)) then
         theta=atan(abs(y/x))
         if (y .gt. 0.0) then
            if (x .lt. 0.0) theta=PI-theta ! quadrant 2
         else
            if (x .lt. 0.0) theta=PI+theta ! quadrant 3
            if (x .gt. 0.0) theta=2.0*PI-theta ! quadrant 4
         end if
      else
         if (x .eq. 0.0) then
            if (y .ge. 0.0) then
               theta=PI/2.0
            else
               theta=3*PI/2.0
            end if
         end if
         if (y .eq. 0.0) then
            if (x .ge. 0) then
               theta=0.0
            else
               theta=PI
            end if
         end if
      end if
      if (r .eq. 0.0) then
         phi = 0.0
      else
         cosa=dble(z)/dble(r)
         phi=dacoscheck(cosa,ccc,1,6,'POLAR')
      end if
      end
 
      subroutine rotabout(v,v0,t,axis)
c     rotate vector v about point v0 by t radians along the axis
c     specified.
      real*8 v(3),v0(3),t,temp(3)
      character*1 axis
 
      st=sin(t)
      ct=cos(t)
      if ((axis .eq. 'x') .or. (axis .eq. 'X')) then
         temp(1)=v(1)
         temp(2)=v0(2) + v(2)*ct - v0(2)*ct - v(3)*st + v0(3)*st
         temp(3)=v0(3) + v(3)*ct - v0(3)*ct + v(2)*st - v0(2)*st
      else
         if ((axis .eq. 'y') .or. (axis .eq. 'Y')) then
            temp(1)=v0(1) + v(1)*ct - v0(1)*ct + v(3)*st - v0(3)*st
            temp(2)=v(2)
            temp(3)=v0(3) + v(3)*ct - v0(3)*ct - v(1)*st + v0(1)*st
         else
            if ((axis .eq. 'z') .or. (axis .eq. 'Z')) then
               temp(1)=v0(1) + v(1)*ct - v0(1)*ct - v(2)*st + v0(2)*st
               temp(2)=v0(2) + v(2)*ct - v0(2)*ct + v(1)*st - v0(1)*st
               temp(3)=v(3)
            else
               return           !no rotation if wrong axis specified
            end if
         end if
      end if
      do i=1,3
         v(i)=temp(i)
      end do
      end
 
 
      subroutine transp(rot,N)
c     /*- transpose an NxN matrix rot -*/
      real rot(N,N),tmp
      do i=1,N
         do j=i+1,N
            tmp=rot(j,i)
            rot(j,i)=rot(i,j)
            rot(i,j)=tmp
         end do
      end do
      return
      end
 
      subroutine vdiv(z,x,y)
      real*8 x(3), y, z(3)
c     /*- z =  x / y -*/
      integer i
      if (y .lt. 1e-12) then
         write(*,*) 'vdiv: can''t divide vector by zero!'
      else
         do i=1,3
            z(i)=x(i)/y
         end do
      end if
      end
 
      subroutine dvset(a,b)
      real*8 a(3),b(3)
c     /*- sets vector a=b -*/
      a(1)=b(1)
      a(2)=b(2)
      a(3)=b(3)
      return
      end
 
      real function amag(x)
      real x(3)
c     /*- calc magnitude of vector x -*/
      real dot
      amag=dot(x,x)
      amag=sqrt(amag)
      return
      end
 
      real*8 function dmag(x)
      real*8 x(3)
c     /*- calc magnitude of vector x -*/
      real*8 ddot
      dmag=ddot(x,x)
      dmag=sqrt(dmag)
      return
      end
 
      real function dot(x,y)
      real x(3),y(3)
c     /*- dot product of x and y -*/
      dot=x(1)*y(1)+x(2)*y(2)+x(3)*y(3)
      end
 
      real*8 function ddot(x,y)
c     /*- dot product of x and y -*/
      real*8 x(3),y(3)
      ddot=x(1)*y(1)+x(2)*y(2)+x(3)*y(3)
      end
 
      real*8 function ddistsq(x,x0)
      real*8 x(3),x0(3)
c     /*- returns squared distance -*/
      ddistsq=(x(1)-x0(1))**2 + (x(2)-x0(2))**2 + (x(3)-x0(3))**2
      return
      end
 
      subroutine vnorm(x)
      real x(3)
c     /*- normalize the vector x -*/
      real rmag,amag
      rmag=amag(x)
      if (rmag .lt. 1e-12) then
c        write(*,*) 'vnorm: can''t normalize zero vector'
         continue
      else
         x(1)=x(1)/rmag
         x(2)=x(2)/rmag
         x(3)=x(3)/rmag
      end if
      end
 
      subroutine dvnorm(x)
      real*8 x(3)
c     /*- normalize the vector x -*/
      real*8 rmag,dmag
      rmag=dmag(x)
      if (rmag .lt. 1e-12) then
         write(*,*) 'dvnorm: can''t normalize zero vector'
      else
         x(1)=x(1)/rmag
         x(2)=x(2)/rmag
         x(3)=x(3)/rmag
      end if
      end
c
c     the routines below need to be reformated to have the result as the
c     first parameter
c
c dcross
c dvdif
c dvmul
c dvdiv
c vsum,dvdum
c dvproj
 
      subroutine dcross(x,y,z)
      real*8 x(3), y(3), z(3)
c     /*- compute z = x cross y -*/
      z(1)= x(2)*y(3)-y(2)*x(3)
      z(2)=-x(1)*y(3)+y(1)*x(3)
      z(3)= x(1)*y(2)-y(1)*x(2)
      end
 
      subroutine dvdif(x,y,z)
      real*8 x(3), y(3), z(3)
c     /*- compute z = x - y -*/
      z(1)=x(1)-y(1)
      z(2)=x(2)-y(2)
      z(3)=x(3)-y(3)
      end
 
 
      subroutine dvmul(x,y,z)
      real*8 x(3), y, z(3)
c     /*- z = x * y -*/
      z(1)=x(1)*y
      z(2)=x(2)*y
      z(3)=x(3)*y
      end
 
      subroutine dvdiv(x,y,z)
      real*8 x(3), y, z(3)
c     /*- z =  x / y -*/
      integer i
      if (y .lt. 1e-12) then
         write(*,*) 'dvdiv: can''t divide vector by zero!'
      else
         do i=1,3
            z(i)=x(i)/y
         end do
      end if
      end
 
      subroutine vsum(x,y,z)
      real*4 x(3), y(3), z(3)
c     /*- z = x + y -*/
      z(1)=x(1)+y(1)
      z(2)=x(2)+y(2)
      z(3)=x(3)+y(3)
      end
 
      subroutine dvsum(x,y,z)
      real*8 x(3), y(3), z(3)
c     /*- z = x + y -*/
      z(1)=x(1)+y(1)
      z(2)=x(2)+y(2)
      z(3)=x(3)+y(3)
      end
 
      subroutine dvproj(x,y,z)
      real*8 x(3),y(3),z(3)
c/*-
c     compute z = the projection on x of y
c     projxy requires that x be a unit vector
c     formula: projxy = (y dot x)*x
c-*/
      real*8 tmp(3),ddot
      call dvset(tmp,x)
      call dvnorm(tmp)
      call dvmul(tmp,ddot(tmp,y),z)
      return
      end
      subroutine resautocorr(ires,incrementac,ncf,xyplot)
      dimension xyplot(2,2500)
      parameter (MAXFRAMES=50000,MAXCOPY=600)
      common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
     -  increment,increment2,res(2,MAXFRAMES,MAXCOPY),
     -  x0(MAXCOPY),y0(MAXCOPY),nxselres,ixselres(MAXCOPY)
c     Calculate the relaxation time of the ires-th stored residue
c     print *,'RESAUTOCORR ires,nframe,increment=',ires,nframe,increment
      ncf=nframe/(2*incrementac)
      if (ncf .eq. 0) then
        write (6,1000) nframe,incrementac
        return
      end if
      call zeroit(xyplot,2*ncf)
      do i=1,ncf
        i0=i*incrementac
        do inc=1,ncf-i
          i1=(i+inc)*incrementac
          xyplot(1,inc+1)=xyplot(1,inc+1)+
     -      (res(1,i0,2*ires-1)*res(1,i1,2*ires-1)+
     -      res(2,i0,2*ires-1)*res(2,i1,2*ires-1)+
     -      res(1,i0,2*ires)*res(1,i1,2*ires)+
     -      res(2,i0,2*ires)*res(2,i1,2*ires))/2.0
        end do
      end do
      xyplot(1,1)=1.0
      do i=2,ncf-1
        xyplot(1,i)=xyplot(1,i)/float(ncf-i)
      end do
      xyplot(1,ncf)=xyplot(1,ncf-1)
      return
1000  format(' PROGRAM ERROR in resautocorr: nframe (',i8,
     -  ') < 2* increment (',i8,')')
      end
      subroutine hydropathylist(n,nslt,ixres,resnames,cv,ihydtyp,igl,
     -  maxrsd,maxrec)
      character*8 resnames
      dimension ixres(maxrec),resnames(maxrsd),cv(n)
      character*3 hphres
      character*1 ans
      dimension hph3(4,23),hphres(23)
c     EIS KD WHI
      data hphres /
     -  'ALA','ARG','ASN','ASP','CYS','GLN','GLU','GLY','HIS',
     -  'ILE','LEU','LYS','MET','PHE','PRO','SER','THR','TRP','TYR',
     -  'VAL','ASX','GLX','UNK'/
      data hph3 /
     -  0.62,1.80,-0.50,0.0, -2.53,-4.50,-1.81,0.0,
     -  -0.78,-3.50,-0.85,0.0, -0.90,-3.50,-3.64,0.0,
     -  0.29,2.50,0.02,0.0, -0.85,-3.50,-0.77,0.0,
     -  -0.74,-3.50,-3.63,0.0, 0.48,-0.40,-1.15,0.0,
     -  -0.40,-3.20,-2.33,0.0, 1.38,4.50,1.12,0.0,
     -  1.06,3.80,1.25,0.0, -1.50,-3.90,-2.80,0.0,
     -  0.64,1.90,0.67,0.0, 1.19,2.80,1.71,0.0,
     -  0.12,-1.60,-0.14,0.0, -0.18,-0.80,-0.46,0.0,
     -  -0.05,-0.70,-0.25,0.0, 0.81,-0.90,2.09,0.0,
     -  0.26,-1.30,0.71,0.0, 1.08,4.20,0.46,0.0,
     -  -0.84,-3.50,-2.25,0.0, -0.80,-3.50,-2.20,0.0,
     -  0.00,-0.49,-0.52,0.0/
      if (ihydtyp .eq. 0) then
        call quiz(ans,ihydtyp,' ',' ',0,
     -  'hydropathy/hydrophobicity scale source',38,0,5,6,igl,0)
        if (ihydtyp .eq. 4) then
          do i=1,23
            call getreal('Residue '//hphres(i)//' hydrophobicity',26,
     -        999999.0,hph3(4,i),0,0)
          end do
        end if
        write (6,1002) (hphres(i),(hph3(j,i),j=1,4),i=1,23)
      end if
      do ia=1,nslt
        ir=1
        do while (ir .lt. 23 .and.
     -     resnames(ixres(ia))(1:3) .ne. hphres(ir))
          ir=ir+1
        end do
        cv(ia)=hph3(ihydtyp,ir)
      end do
c     Set solvent atoms to unknown
      do ia=nslt+1,n
        cv(ia)=hph3(ihydtyp,23)
      end do
      return
1002  format(' The residue values stored:',/,
     -   '    Kyte-Dooli Eisenberg     White    Input',/,
     -  (1x,a3,4f10.2))
      end
      subroutine cvlist(c,n,nslt,nsltref_f,nsltref_l,naslv,islvrep,
     -  icvtyp,rcut,rprox,cv,ixtemp,rtemp,dtemp,ifa,ila,it1,ctemp,
     -  isortslv,cvlim)
      dimension c(3,n),cv(n),ixtemp(n),rtemp(n),ifa(n),ila(n),it1(n),
     -  ctemp(3,n),dtemp(n),rprox(n)
      real*8 xnum,ynum,znum,den
      rcut2=rcut*rcut
c     Calculating the circular variance for solute atoms and solvent molecules
c     print *,'CVLIST n,nslt,naslv=',n,nslt,naslv
      call zeroit(rprox,nslt)
      do ia=1,nslt
        xnum=0.d0
        ynum=0.d0
        znum=0.d0
        den=0.d0
        do ja=nsltref_f,nsltref_l
          if (ia .ne. ja) then
            dx=c(1,ia)-c(1,ja)
            dy=c(2,ia)-c(2,ja)
            dz=c(3,ia)-c(3,ja)
            d2=dx*dx+dy*dy+dz*dz
            if (d2 .le. rcut2) then
              d=sqrt(d2)
              if (icvtyp .eq. 1) then
                xnum=xnum+dx/d
                ynum=ynum+dy/d
                znum=znum+dz/d
                den=den+1.d0
              else
                xnum=xnum+dx
                ynum=ynum+dy
                znum=znum+dz
                den=den+d
              end if
            end if
          end if
        end do
        if (den .gt. 0.d0) then
          cv(ia)=1.d0-dsqrt(xnum*xnum+ynum*ynum+znum*znum)/den
        else
          cv(ia)=0.0
        end if
      end do
      if (n .gt. nslt) then
c       CV for solvents
        numslv=(n-nslt)/naslv
        iaa=nslt+islvrep
        do ia=1,numslv
          xnum=0.d0
          ynum=0.d0
          znum=0.d0
          den=0.d0
          d2min=1000000.0
          do ja=nsltref_f,nsltref_l
            dx=c(1,iaa)-c(1,ja)
            dy=c(2,iaa)-c(2,ja)
            dz=c(3,iaa)-c(3,ja)
            d2=dx*dx+dy*dy+dz*dz
            if (d2 .le. rcut2) then
              d=sqrt(d2)
              if (icvtyp .eq. 1) then
                xnum=xnum+dx/d
                ynum=ynum+dy/d
                znum=znum+dz/d
                den=den+1.d0
              else
                xnum=xnum+dx
                ynum=ynum+dy
                znum=znum+dz
                den=den+d
              end if
            end if
            if (d2min .gt. d2) d2min=d2
          end do
          cvi=0.0
          if (den .gt. 0.d0)
     -      cvi=1.d0-dsqrt(xnum*xnum+ynum*ynum+znum*znum)/den
          d2min=sqrt(d2min)
          do i=nslt+(ia-1)*naslv+1,nslt+ia*naslv
            cv(i)=cvi
            rprox(i)=d2min
          end do
          iaa=iaa+naslv
          rtemp(ia)=cvi
          dtemp(ia)=sqrt(d2min)
          ixtemp(ia)=ia
        end do
        if (isortslv .eq. 1) then
          call trnsfr(ctemp(1,nslt+1),c(1,nslt+1),3*(n-nslt))
          call mrgsrt(6,ixtemp,rtemp,numslv,ifa,ila,it1,ctemp,n)
          limfound=0
          if (cvlim .ge. 1.0) limfound=1
          do ia=1,numslv
            ia0=nslt+(ia-1)*naslv
            ix0=nslt+(ixtemp(ia)-1)*naslv
            do i=ia0+1,ia0+naslv
              cv(i)=rtemp(ia)
              rprox(i)=dtemp(ia)
              ix=ix0+(i-ia0)
              call trnsfr(c(1,i),ctemp(1,ix),3)
            end do
            if (limfound .eq. 0) then
              if (rtemp(ia) .gt. cvlim) then
                limfound=1
                write (6,1000) cvlim,ia-1,cvlim,numslv-ia+1,numslv
              end if
            end if
          end do
        end if
      end if
      return
1000  format(' Number of solvents with CV < ',f6.3,'=',i4,/,
     -  ' Number of solvents with CV > ',f6.3,'=',i4,
     -  ' (total: ',i6,')')
      end
      subroutine cvplot(c,n,nslt,imaptyp,line,index,indexr,inamcol1,
     -  inamcol2,iresncol1,iresncol2,repnam,title,ltitle,ncolcode,
     -  maxcolcode,iwr,ips,iclose,maxrec,ipspage)
      dimension c(3,n),index(n),indexr(n)
      character*8 repnam
      character*(*) title
      parameter (MAXPHI=400,MAXCV=2000)
      parameter (IFILL3=MAXPHI*MAXPHI*MAXPHI-(8*MAXCV+5*MAXCV*MAXCV))
      common /nnwork/ mx(MAXCV,MAXCV),rij(3,MAXCV,MAXCV),
     -  dij(MAXCV,MAXCV),cvavfor(MAXCV),cvavback(MAXCV),cvav(MAXCV),
     -  cvrow(MAXCV),cvcol(MAXCV),ca(3,MAXCV),ifill(IFILL3)
      dimension rmx(1,1),ixshuffle(MAXCV)
      real*8 rijsum(3),dijsum,forsum(MAXCV),backsum(MAXCV),dmx(1,1)
      character*4 yclab(1)
      character*47 maptyp(2)
C@GL      character*1 ans
      character*8 atnam
      character* 132 line(maxrec)
      common /graphics/ igl,npixx,npixy,maxpixx,maxpixy,idwmain,idwplot,
     -  wx,wy,wz,wxdr
      data mxr /MAXCV/,iok /0/
      data maptyp /
     -  'Domain map based on standard circular variances',
     -  'Domain map based on weighted circular variances'/
      data nyclab /1/,lyclab /1/
      call indexit(ixshuffle,1,MAXCV,0)
      lnam=inamcol2-inamcol1+1
c     print *,'inamcol1,inamcol2,lnam=',inamcol1,inamcol2,lnam
c     print *,'renam=',repnam(1:lnam),'*'
C@GL      x1=-30
C@GL      x2=mxr
C@GL      y2=mxr
C@GL      y1=-100
C@GL      call ortho(x1,x2,y1,y2,-200.0,200.0)
C@GL      call clear
C@GL      call swapbu
      nres=0
      ireso=0
      icafound=0
      do ia=1,nslt
        atnam(1:lnam)=line(index(ia))(inamcol1:inamcol2)
        call leftadjustn(atnam,atnam,8)
        read (line(index(ia))(iresncol1:iresncol2),*,ERR=999) iresn
c       write (77,*) ia,iresn,' atnam=',atnam(1:lnam),'*'
        if (iresn .ne. ireso) then
c         New residue
          if (ireso .ne. 0) then
            iok=1
            if (icafound .lt. 1) then
              print *,'Residue ',ireso,' had no ',repnam(1:lnam)
              iok=0
            end if
            if (iok .eq. 1) then
              nres=nres+1
            end if
          end if
          ireso=iresn
          icafound=0
        end if
        if (atnam(1:lnam) .eq. repnam(1:lnam)) then
          if (nres .ge. mxr) then
            print *,'ERROR: program is prepared only for ',mxr,
     -        ' residues'
            stop
          end if
          icafound=1
          call trnsfr(ca(1,nres+1),c(1,ia),3)
        end if
      end do
      if (iok .eq. 1) nres=nres+1
      if (nres .eq. 0) then
        print *,'No residues containing ',repnam(1:lnam),' were found'
        stop
      end if
      print *,'Number of ',repnam(1:lnam),'-containig residues=',nres
      do ix=1,nres
        do iy=ix,nres
          d=0.0
          do k=1,3
            rij(k,iy,ix)=ca(k,iy)-ca(k,ix)
            rij(k,ix,iy)=-rij(k,iy,ix)
            d=d+rij(k,iy,ix)**2
          end do
          d=sqrt(d)
          if (imaptyp .eq. 1 .and. iy .ne. ix) then
c           Normalize the rij vectors
            do k=1,3
              rij(k,iy,ix)=rij(k,iy,ix)/d
              rij(k,ix,iy)=-rij(k,iy,ix)
            end do
            d=1.0
          end if
          dij(iy,ix)=d
          dij(ix,iy)=d
        end do
      end do
c     Internally 1-CV is stored/calculated
      cvavfor(1)=0.0
      cvavfor(nres)=0.0
      cvavback(1)=0.0
      cvavback(nres)=0.0
      do ix=1,nres
        mx(ix,ix)=9
        call zeroitd(rijsum,3)
        dijsum=0.d0
        forsum(ix)=0.d0
        do iy=ix+1,nres
          do k=1,3
            rijsum(k)=rijsum(k)+rij(k,ix,iy)
          end do
          dijsum=dijsum+dij(ix,iy)
          cv=dsqrt(rijsum(1)**2+rijsum(2)**2+rijsum(3)**2)/dijsum
          cvrow(iy)=cv
          forsum(ix)=forsum(ix)+cv
          mx(ix,iy)=float(ncolcode)*cv+1
          if (mx(ix,iy) .lt. 1) mx(ix,iy)=1
        end do
        if (nrep .le. 1 .and. iwr .gt. 0) write (iwr,2000)
     -     'For',ix,forsum(ix),(cvrow(iy),iy=ix+1,nres)
      end do
c     Now scan backwards
      do ix=nres,1,-1
        call zeroitd(rijsum,3)
        dijsum=0.d0
        backsum(ix)=0.d0
        do iy=ix-1,1,-1
          do k=1,3
            rijsum(k)=rijsum(k)+rij(k,ix,iy)
          end do
          dijsum=dijsum+dij(ix,iy)
          cv=dsqrt(rijsum(1)**2+rijsum(2)**2+rijsum(3)**2)/dijsum
          cvcol(iy)=cv
          backsum(ix)=backsum(ix)+cv
          mx(ix,iy)=float(ncolcode)*cv+1
          if (mx(ix,iy) .lt. 1) mx(ix,iy)=1
        end do
        if (nrep .le. 1 .and. iwr .gt. 0)
     -    write (iwr,2000) 'Bac',ix,backsum(ix),(cvcol(iy),iy=1,ix-1)
      end do
      do ix=2,nres-1
        cvavfor(ix)=forsum(ix)/(nres-ix)
        cvavback(ix)=backsum(ix)/(ix-1)
        cvav(ix)=(forsum(ix)+backsum(ix))/nres
      end do
      if (nrep .le. 1 .and. iwr .gt. 0)
     -  write (iwr,2001) (cvav(ix),ix=1,nres)
c      do i=1,10
c        write (6,7733) i,(mx(i,j),j=1,10)
c      end do
c7733  format(' MX i=',i3,' mx(i)=',10i3)
c     Plot map
      nrep=0
C@GL200   continue
      nrep=nrep+1
C@GL      call color(7)
C@GL      call clear
C@GL      call makeob(idpfp)
      inc=max0(1,500/nres)
      ixdel=25
      iydel=115
      call plotmat(ips,mx,rmx,dmx,nres,nres,0,0,0,0,1,nrep,ixdel,iydel,
     -  0,iytop,0.0,1.0,ncolcode,maxcolcode,ixdelsh,iydelsh,inc,1.0,
     -  indexr,ixshuffle,ixshuffle,title,ltitle,' ',0,' ',1,ca,yclab,
     -  nyclab,lyclab,igl,mxr,1,1,MAXCV,mxr,ipspage,0)
      iydown=-80
c     Plot row averages for domain map
      if (nres .lt. 750) ixdel=ixdel+45
      scalefac=inc
      call colstrip(cvavfor,nres,ixdel,scalefac,iydown,nrep,' F',
     -  ncolcode,ips)
      call colstrip(cvavback,nres,ixdel,scalefac,iydown+18,nrep,' B',
     -  ncolcode,ips)
      call colstrip(cvav,nres,ixdel,scalefac,iydown+36,nrep,' T',
     -  ncolcode,ips)
      iydown=iydown+54
      call colcode01(ips,ixdel,iydown+5,ncolcode,nrep)
      iydown=iydown+18
c     Plot the type of the plot and close the plot/page
C@GL      call color(0)
C@GL      call cmov(0.0,float(iydown),0.0)
C@GL      call charst(maptyp(imaptyp),47)
C@GL        call closeo
C@GL        call callob(idpfp)
C@GL        call swapbu
      if (nrep .le. 1) then
        call rgbcolor(ips,9)
        write (ips,3001) ixdel,iydown
        call psshow(ips,maptyp(imaptyp),47)
      end if
C@GL      ans=' '
C@GL      do while (ans .ne. 'q' .and. ans .ne. 'r')
C@GL        write (6,1110)
C@GL        read (5,1002) ans
C@GL        if (ans .eq. 'r') then
C@GL          go to 200
C@GL        end if
C@GL      end do
      write (ips,*) 'showpage'
      if (iclose .eq. 1) then
        close (iwr)
        close (ips)
      end if
      return
999   print *,'ERROR: illegal residue number in line',index(ia),':'
      print *,line(index(ia))(1:80)
      stop
C@GL1110  format(' Action (q,r):',/,
C@GL     -  5x,'Quit        : q',/,
C@GL     -  5x,'Refresh plot: r ',$)
C@GL1002  format(a)
2000  format(1x,a,i4,f10.4,(20f5.2))
2001  format(' CV column averages:',/,(8x,20f5.2))
3001  format(i4,i5,' m')
      end
      subroutine plotmat(ips,kc,rc,dc,nresx,nresy,ixinc,iyinc,
     -  ixincshift,iyincshift,navg,nrep,ixdel0,iydel0,idown,iytop,rcmin,
     -  rcmax,ncol,maxcol,ixdel,iydel,incinp,scalefacinp,index,
     -  ixshufflex,ixshuffley,title,ltitle,title2,ltitle2,xylab,lxylab,
     -  xyval,yclab,nyclab,lyclab,igl,mxr,mxrr,mxrd,mx,mxix,ipspage,
     -  ipsclose)
      character*(*) title,title2,xylab,yclab(nyclab)
      real*8 dc
      dimension kc(mxr,mxr),rc(mxrr,mxrr),dc(mxrd,mxrd),index(mxix),
     -  ixshufflex(mx),ixshuffley(mx),xyval(mx)
C@GL      dimension square(3,4)
C@GL      character*3 lab
      data ix0 /0/,iy0 /0/,rcxy /0.0/
c     kc,rc,dc: matrix in integer, real*4 and real*8 formats
c     mxr,mxrr,mxrd: dimensions of kc,rc,dc (only one of them can be > 1)
c     nresx, nresy: matrix dimension
c     ishufflex, ixinc: X axis label of the ith row is ishufflex(i+ixinc)
c     ishuffley, iyinc: Y axis label of the ith row is ishuffley(i+iyinc)
c     ixincshift,iyincshift: deduct from the matrix indices
c     navg: number of residues the matrix entries were averaged over
c     nrep: When >1 then it was a repeat plot
c     ixdel,iydel: increments in the x and y direction
c     scalefac: Overall scaling factor (500*550 matrix fills the page
c     with scalefac=1
c     rcmin,rcmax: min and max of matrix value allowed
c     ncol, maxcol: requested and maximum number of colors
c     inc: increment per matrix row/col
c     print *,'PLOTMAT ips,ncol=',ips,ncol,' nresx,nresy=',nresx,nresy
c     print *,'PLOTMAT mxr,mxrr,mxrd=',mxr,mxrr,mxrd
c     print *,'PLOTMAT mx,mxix=',mx,mxix
c     print *,'PLOTMAT ixdel0,iydel0,navg,iyinc=',
c    -   ixdel0,iydel0,navg,iyinc
c     print *,'PLOTMAT ltitle,ltitle2=',ltitle,ltitle2,
c    -  ' xylab=',xylab(1:lxylab)
c      do i=1,10
c        write (6,7733) i,(kc(i,j),j=1,10)
c      end do
c7733  format(' KC i=',i3,' kc(i)=',10i3)
      scalefac=scalefacinp
      lycinc=lyclab/10
      scalefac=scalefac*(1.0-lycinc*0.04)
      icharsize=12
      ipsdraw=ips
      if (igl .eq. 0) ipsdraw=-ipsdraw
      maxrrgb=maxcol
      maxcol1=maxcol+1
C@GL      do i=1,4
C@GL        call zeroit(square(1,i),3)
C@GL      end do
C@GL      if (igl .eq. 1) call setlin(0)
C@GL      if (igl .eq. 1) call linewi(1)
c      write (6,8422) 'X',(ixshufflex(i),i=1,nresx)
c      write (6,8422) 'Y',(ixshuffley(i),i=1,nresy)
c8422  format(' IXSHUFFLE',a1,':',/,(20i4))
      ipspage=ipspage+1
      write (ips,1020) ipspage
      inc=incinp*navg
      if (scalefac .ne. 1.0) then
        write (ips,3003) scalefac,scalefac
        icharscale=float(icharsize)/scalefac
        write (ips,3011) icharscale
      else
        write (ips,3011) icharsize
      end if
      if (rcmax .eq. rcmin) rcmax=rcmax+0.1
      ixdel=ixdel0
      ixdelmat=ixdel0
      if (nresx*scalefac .lt. 550) ixdelmat=ixdel0+40/scalefac
      iydel=iydel0
      if (scalefac .lt. 1.0) iydel=iydel/scalefac
      write (ips,*) '% TEST1'
      iytop=iydel+nresy*inc
      if (ltitle .gt. 0) then
        iytop=iytop+20
        call pswrite(ips,ixdel,iytop,'m',1)
        write (ips,*) '(System: ) show'
        call psshow(ips,title,ltitle)
      end if
      if (ltitle2 .gt. 0) then
        iytop=iytop+20
        call pswrite(ips,ixdel,iytop,'m',1)
        call psshow(ips,title2,ltitle2)
      end if
c     print *,'PLOTMAT iydel,ixinc,iyinc,inc=',
c    -  iydel,ixinc,iyinc,inc
      do iyy=1,nresy
        iy=ixshuffley(iyy+iyinc)-iyincshift
c       write (77,*) 'iyy,iyinc,iy=',iyy,iyinc,iy
        kcprev=-1
        do ixx=1,nresx
          ix=ixshufflex(ixx+ixinc)-ixincshift
          if (mxr .gt. 1) then
            kccurr=kc(ix,iy)
          else
c           Convert rc(ix,iy) or dc(ix,iy) into color code
            if (mxrr .gt. 1) rcxy=rc(ix,iy)
            if (mxrd .gt. 1) rcxy=dc(ix,iy)
            if (ncol .eq. 0) then
              kccurr=100.0*(rcxy-rcmin)/(rcmax-rcmin)+1.0
            else
              if (rcxy .le. rcmin) then
                kccurr=0
              else if (rcxy .gt. rcmax) then
                kccurr=ncol+1
              else
                rr=amax1(-0.00001,rcxy-rcmin-0.00001)
                kccurr=(rr/(rcmax-rcmin))*ncol+1
              end if
            end if
          end if
c          write (77,7688) ix,iy,rc(ix,iy),kccurr
c7688      format('ix,iy=',2i6,' rc=',f10.5,' kcurr=',i3)
C@GL          if (igl .eq. 1) call color(kccurr)
C@GL          square(1,1)=ixdelmat+(ixx-1)*inc
C@GL          square(2,1)=iydel+(iyy-1)*inc
C@GL          square(1,2)=ixdelmat+(ixx)*inc
C@GL          square(2,2)=iydel+(iyy-1)*inc
C@GL          square(1,3)=ixdelmat+(ixx)*inc
C@GL          square(2,3)=iydel+(iyy)*inc
C@GL          square(1,4)=ixdelmat+(ixx-1)*inc
C@GL          square(2,4)=iydel+(iyy)*inc
C@GL          if (igl .eq. 1) call polf(4,square)
          if (nrep .le. 1) then
            if (kccurr .ne. kcprev) then
              if (kcprev .ne. -1 .and. (kcprev .ne. maxcol1 .or.
     -            ncol .eq. 0)) then
c               Close the rectangle that is open
                call pswrite(ips,ixdelmat+(ixx-1)*inc,iydel+(iyy)*inc,
     -            'l',1)
                call pswrite(ips,ixdelmat+(ixx-1)*inc,iydel+(iyy-1)*inc,
     -            'l',1)
                call pswrite(ips,ix0-inc,iy0-inc,'l',1)
                write (ips,3006)
                ix0=-1
              end if
              if (kccurr .ne. maxcol1 .or. ncol .eq. 0) then
c               Open new rectangle
                if (ncol .eq. 0) then
                  call rrgbcolor(ips,kccurr,100,0)
                else
                  call rgbcolor(ips,kccurr)
                end if
                ix0=ixdelmat+(ixx)*inc
                iy0=iydel+(iyy)*inc
c                write (77,8766) ixx,iyy,ix0,iy0,inc
c8766  format(' ixx,iyy=',2i4,' ix0,iy0=',2i4,' inc=',i2)
                call pswrite(ips,ix0-inc,iy0-inc,'m',1)
                call pswrite(ips,ix0-inc,iy0,'l',1)
              end if
              kcprev=kccurr
            end if
          end if
        end do
        if (ix0 .ne. -1 .and. nrep .le. 1) then
c         Close last opened rectangle
          call pswrite(ips,ixdelmat+(nresx)*inc,iydel+(iyy)*inc,'l',1)
          call pswrite(ips,ixdelmat+(nresx)*inc,iydel+(iyy-1)*inc,'l',1)
          call pswrite(ips,ix0-inc,iy0-inc,'l',1)
          write (ips,3006)
        end if
      end do
c     Write residue/frame number scale
c     print *,'Matrix entries plotted'
c     Plot protein id
      ridown=idown
      idown1=idown+06
      idown2=idown1+9
      rydel=iydel-idown
      rydel1=iydel-idown1
      rydel2=iydel-idown2
C@GL      rir=ixdel
C@GL      if (igl .eq. 1) then
C@GL        call color(0)
C@GL        call cmov(rir,rydel1,0.0)
C@GL        call linewi(2)
C@GL      end if
      if (nrep .le. 1) then
        call rgbcolor(ips,9)
        call pswrite(ips,ixdel,iydel-idown1,'m',1)
      end if
      write (ips,3004) 2
      irxmax=nresx
      irymax=nresy
      if (lxylab .gt. 1) then
        write (ips,3000)
        ix=ixdelmat+(nresx*inc)*0.45
        iydown=30/scalefac
        call pswrite(ips,ix,iydel-idown-iydown,'m',1)
        write (ips,3009) xylab(1:lxylab)
        write (ips,3001)
        xmax=xyval(nresx)
        call roundlim(xmax,xdiv,nxdiv)
        ymax=xyval(nresy)
        if (iyinc .gt. 0) ymax=xyval(nresy+iyinc)-xyval(iyinc)
        call roundlim(ymax,ydiv,nydiv)
        xdiv_i=xdiv*float(nresx)/xmax
        ydiv_i=ydiv*float(nresy)/ymax
        iydiv=ydiv
      else
        call roundlimint(nresx,ixdiv,nxdiv)
        call roundlimint(nresy,iydiv,nydiv)
        xdiv=ixdiv
        ydiv=iydiv
        xdiv_i=ixdiv
        ydiv_i=iydiv
        xmax=xdiv*nresx
        ymax=ydiv*nresy
      end if
c     print *,'DRAWRECT nresy,iydiv,iydel=',nresy,iydiv,iydel
      call drawrect(ipsdraw,9,1,ixdelmat,ixdelmat+nresx*inc,iydel,
     -  iydel+max0(nresy,iydiv)*inc,nrep)
      ixadd=0
      iyadd=0
      if (abs(xmax-nxdiv*xdiv) .lt. xmax*0.01) ixadd=1
      if (abs(ymax-nydiv*ydiv) .lt. ymax*0.01) iyadd=1
      idown1=idown1/scalefac
      idown2=idown2/scalefac
      ixsshift=14/scalefac
      itickstep=10/(xdiv_i*inc)+1
      do itic=1,nxdiv+ixadd,itickstep
        if (lxylab .le. 1) then
          ir=itic*xdiv_i*inc
        else
          ir=(itic-1)*xdiv_i*inc
        end if
        irinc=max0(1,ir/inc)
        if (index(irinc) .le. irxmax) then
C@GL          rir=ixdelmat+ir
C@GL          if (igl .eq. 1) then
C@GL            call move(rir,rydel,0.0)
C@GL            call draw(rir,rydel1,0.0)
C@GL            call cmov(rir-10.0,rydel2,0.0)
C@GL            write (lab,1007) index(irinc)
C@GL            call charst(lab,3)
C@GL          end if
          if (nrep .le. 1) then
c           Upper tick
            write (ips,3000)
            call pswrite(ips,ixdelmat+ir,iydel+nresy*inc+idown,'m',1)
            call pswrite(ips,ixdelmat+ir,iydel+nresy*inc+idown1,'l',1)
            write (ips,3001)
c           Lower tick
            write (ips,3000)
            call pswrite(ips,ixdelmat+ir,iydel-idown,'m',1)
            call pswrite(ips,ixdelmat+ir,iydel-idown1,'l',1)
            write (ips,3001)
c           Scale
            call pswrite(ips,ixdelmat+ir-ixsshift,iydel-idown2,'m',1)
            if (lxylab .le. 1) then
              write (ips,3008) index(irinc)
            else if (xylab(1:1) .eq. ' ' .or.
     -               xdiv .ge. 100.0) then
              ix=navg*(itic-1)*xdiv
              write (ips,3008) ix
            else
              write (ips,3010) navg*(itic-1)*xdiv
            end if
          end if
        end if
      end do
      itickstep=10/(ydiv_i*inc)+1
      do itic=1,nydiv+iyadd,itickstep
        if (lxylab .le. 1) then
          ir=itic*ydiv_i*inc
        else
          ir=(itic-1)*ydiv_i*inc
        end if
        irinc=max0(1,ir/inc)+iyinc
        if (index(irinc) .le. iyinc+irymax .or. itic .eq. 1) then
c         Left tick
          write (ips,3000)
          call pswrite(ips,ixdelmat,iydel+ir,'m',1)
          call pswrite(ips,ixdelmat-(idown1-idown),iydel+ir,'l',1)
          write (ips,3001)
c         Right tick
          write (ips,3000)
          call pswrite(ips,ixdelmat+nresx*inc,iydel+ir,'m',1)
          if (nyclab .le. 1) then
            call pswrite(ips,ixdelmat+nresx*inc+(idown1-idown),iydel+ir,
     -        'l',1)
          else
            call pswrite(ips,ixdelmat+nresx*inc-(idown1-idown),iydel+ir,
     -        'l',1)
          end if
          write (ips,3001)
          if (ixdelmat .gt. ixdel0) then
c           Scale
            call pswrite(ips,ixdel0,iydel+ir-4,'m',1)
            if (lxylab .le. 1) then
              write (ips,3008) index(irinc)
            else if (xylab(1:1) .eq. ' ' .or.
     -               ydiv .ge. 100.0) then
              iy=navg*(itic-1)*ydiv+iyinc
              write (ips,3008) iy
            else
              write (ips,3010) navg*(itic-1)*ydiv
            end if
          end if
        end if
      end do
c     print *,'PLOTMAT NYCLB,LYCLAB=',nyclab,lyclab
      if (nyclab .gt. 1) then
c       Print residue identifiers
        write (ips,3011) icharsize/2+1
        do iy=1,nyclab
          call pswrite(ips,ixdelmat+nresx*inc,iydel+(iy-1)*inc+inc/3,
     -      'm',1)
          write (ips,3009) yclab(iy)(1:lyclab)
        end do
        write (ips,3011) icharsize
      end if
      if (scalefac .ne. 1.0) then
        write (ips,3003) 1.0/scalefac,1.0/scalefac
        write (ips,3011) icharsize
      end if
      if (ipsclose .eq. 1) close (ips)
      return
C@GL1007  format(i3)
1020  format('%%Page: 1 ',i4)
3000  format('np')
3001  format('sk')
3003  format(f10.6,f10.6,' scale')
3004  format(i5,' lw')
3006  format('f')
3008  format('(',i6,') show')
3009  format('(',a,') show')
3010  format('(',f6.2,') show')
3011  format('/Helvetica findfont',/,i4,' scalefont',/,'setfont')
      end
      subroutine contractmat(rij,nxo,nyo,nxn,nyn,navg,ixx,ixy,
     -  itemp1,itemp2,temp,isort,iouttemp,ndim)
      dimension rij(ndim,ndim),ixx(ndim),ixy(ndim),
     -  itemp1(ndim),itemp2(ndim),temp(ndim)
      character*9 filename
      navgdef=max0(1,max0(nxo,nyo)/1000)
c     print *,'CONTRACTMAT nxo,nyo,isort=',nxo,nyo,ndim,isort
      call getint(
     -  'Number of x and y entries to average in the 2D-RMSD plot',56,
     -  navgdef,1,min0(nxo,nyo),navg,122)
c     print *,'NAVG=',navg
      if (navg .eq. 1) then
        write (6,*) 'All matrix elements will be plotted'
        nxn=nxo
        nyn=nyo
        return
      else
        ntry=0
        iopen=1
        filename='rij__.tmp'
        do while (ntry .lt. 10 .and. iopen .gt. 0)
          write (filename(5:5),1000) ntry
          open(unit=iouttemp,status='new',file=filename,iostat=iopen,
     -      form='unformatted')
          ntry=ntry+1
        end do
        if (iopen .gt. 0) then
          print *,'PROGRAM ERROR: could not open rij.tmp'
          stop
        end if
        write (iouttemp) ((rij(i,j),i=1,nxo),j=1,nyo)
        if (isort .gt. 0) then
c         Sort columns first
          do iy=1,nyo
            do i=1,nxo
              temp(i)=rij(ixx(i),iy)
            end do
            call trnsfr(rij(1,iy),temp,nxo)
          end do
          call trnsfi(itemp1,ixy,nyo)
          do i=1,nyo
            itemp2(itemp1(i))=i
          end do
          do iy=1,nyo
            call trnsfr(temp,rij(1,itemp1(iy)),nxo)
            call trnsfr(rij(1,itemp1(iy)),rij(1,iy),nxo)
            call trnsfr(rij(1,iy),temp,nxo)
            itemp1(itemp2(iy))=itemp1(iy)
            itemp2(itemp1(itemp1(iy)))=itemp1(iy)
          end do
        end if
        nxn=(nxo-1)/navg+1
        nyn=(nyo-1)/navg+1
        do ix=1,nxn
          do iy=1,nyn
            sum=0.0
            ixf0=(ix-1)*navg
            iyf0=(iy-1)*navg
            ixl=min0(nxo,ixf0+navg)
            iyl=min0(nyo,iyf0+navg)
            do jx=ixf0+1,ixl
              do jy=iyf0+1,iyl
                sum=sum+rij(jx,jy)
              end do
            end do
            if (ixl .eq. ixf0 .or. iyl .eq. iyf0) then
              write (6,9781) ixl,ixf0,iyl,iyf0
9781          format(' ixl,ixf0=',2i6,' iyl,iyf0=',2i6)
            end if
            rij(ix,iy)=sum/((ixl-ixf0)*(iyl-iyf0))
          end do
        end do
      end if
      return
1000  format(i1)
      end
      subroutine pswrite(iout,i1,i2,lab,llab)
      character*(*) lab
c     Writes a PS command with the minimum number of blanks
      character*80 line
      icol=1
      call writeint(line,icol,i1,lenw)
      line(icol:icol)=' '
      icol=icol+1
      call writeint(line,icol,i2,lenw)
      line(icol:icol)=' '
      line(icol+1:icol+llab)=lab(1:llab)
      write (iout,1000) line(1:icol+llab)
      return
1000  format(a)
      end
      subroutine writeint(line,icol,int,len)
      character*(*) line
c     Writes the integer int into line starting at icol
      ii=int
      if (ii .lt. 0) ii=-ii
      if (ii .eq. 0) then
        len=1
      else
        rii=ii+0.00001
        len=alog10(rii)+1
      end if
      if (int .lt. 0) len=len+1
      if (len .eq. 1) then
        write (line(icol:icol),101) int
      else if (len .eq. 2) then
        write (line(icol:icol+1),102) int
      else if (len .eq. 3) then
        write (line(icol:icol+2),103) int
      else if (len .eq. 4) then
        write (line(icol:icol+3),104) int
      else if (len .eq. 5) then
        write (line(icol:icol+4),105) int
      else if (len .eq. 6) then
        write (line(icol:icol+5),106) int
      else if (len .eq. 7) then
        write (line(icol:icol+6),107) int
      else if (len .eq. 8) then
        write (line(icol:icol+7),108) int
      else if (len .eq. 9) then
        write (line(icol:icol+8),109) int
      end if
      icol=icol+len
      return
101   format(i1)
102   format(i2)
103   format(i3)
104   format(i4)
105   format(i5)
106   format(i6)
107   format(i7)
108   format(i8)
109   format(i9)
      end
      subroutine drawrect(ips0,kc,lw,ix0,ix1,iy0,iy1,nrep)
c     Draw a rectangle
c      write (6,1000) kc,ix0,ix1,iy0,iy1
c1000  format(' DRAWRECT kc=',i1,' ix1,2=',2i5,' iy1,2=',2i5)
      ips=iabs(ips0)
C@GL      if (ips0 .ge. 0) then
C@GL        kcsgi=kc
C@GL        if (kcsgi .eq. 9) kcsgi=7
C@GL        call color(kcsgi)
C@GL        call linewi(lw)
C@GL        call move(float(ix0),float(iy0),0.0)
C@GL        call draw(float(ix0),float(iy1),0.0)
C@GL        call draw(float(ix1),float(iy1),0.0)
C@GL        call draw(float(ix1),float(iy0),0.0)
C@GL        call draw(float(ix0),float(iy0),0.0)
C@GL      end if
      if (nrep .le. 1) then
        write (ips,3004) lw
        write (ips,3000)
        call rgbcolor(ips,kc)
        call pswrite(ips,ix0,iy0,'m',1)
        call pswrite(ips,ix0,iy1,'l',1)
        call pswrite(ips,ix1,iy1,'l',1)
        call pswrite(ips,ix1,iy0,'l',1)
        call pswrite(ips,ix0,iy0,'l',1)
        write(ips,3001)
      end if
      return
3000  format('np')
3001  format('sk')
3004  format(i5,' lw')
      end
      subroutine rainbowscale(iplot,ix0,ixwid,iy0,n,rn,rmin,rmax,
     -  label,llabel)
      character*(*) label
      write (iplot,1019) 15
      ixprev=ix0
      do i=1,100
        call rrgbcolor(iplot,i,100,1)
        ix=ix0+ixwid*float(i)/float(100)
        write (iplot,1002) ixprev,iy0
        write (iplot,1009) ix,iy0
        ixprev=ix
      end do
      write (iplot,1011)
      call rrgbcolor(iplot,i,1,0)
      write (iplot,1002) ix0-30,iy0-25
      if (n .eq. 0 .and. rn .eq. 0.0) then
c       Use rcmin,rcmax
        write (iplot,1014) rmin
        ixlabwid=8.0*alog10(amax1(10.1,rmax))
        write (iplot,1002) ix0+ixwid-30-ixlabwid,iy0-25
        write (iplot,1014) rmax
      else
c       Use 0 - n/rn
        write (iplot,1013) 0
        if (rn .gt. float(n)) then
          ixlabwid=8.0*alog10(amax1(10.1,rn))
          write (iplot,1002) ix0+ixwid-30-ixlabwid,iy0-25
          write (iplot,1014) rn
        else
          ixlabwid=8.0*(alog10(float(n))+2.0)
          write (iplot,1002) ix0+ixwid-ixlabwid,iy0-25
          write (iplot,1013) n
        end if
      end if
      write (iplot,1002) ix0+ixwid/2-50,iy0-25
      call psshow(iplot,label,llabel)
      return
1002  format(i4,i5,' moveto')
1009  format(i4,i5,' lineto')
1011  format('stroke')
1013  format('(',i10,') show')
1014  format('(',f10.4,') show')
1019  format(i5,' setlinewidth')
      end
      subroutine colstrip(cvav,nres,ixdel,scalefac,iydown,nrep,lab,ncol,
     -  ips)
      dimension cvav(nres)
      character*2 lab
      riy=iydown
C@GL      call linewi(12)
C@GL      call move(0.0,-riy,0.0)
      if (nrep .le. 1) then
        write (ips,3004) 12
        write (ips,*) 'np'
        write (ips,3001) ixdel,-iydown
      end if
      kcprev=0
      ixcurr=kcprev
      ix=1
      rrprev=0.0
      ixxprev=ixdel
      do while (ix .lt. nres)
        do while (ixcurr .eq. kcprev .and. ix .lt. nres)
          ix=ix+1
          ixcurr=ncol*cvav(ix)+1
          if (ix .eq. nres) ixcurr=0
        end do
        if (kcprev .gt. ncol) kcprevncol=ncol
        rr=ix-1
C@GL        call color(kcprev)
C@GL        call move(rrprev,-riy ,0.0)
C@GL        call draw(rr,-riy,0.0)
C@GL        rrprev=rr
        if (nrep .le. 1) then
          call rgbcolor(ips,kcprev)
          write (ips,*) 'np'
          ixx=ixdel+scalefac*(ix-1)
          write (ips,3001) ixxprev,-iydown
          write (ips,3002) ixx,-iydown
          write (ips,*) 'sk'
          ixxprev=ixx
        end if
        kcprev=ixcurr
      end do
      rr=nres
C@GL      call color(kcprev)
C@GL      call draw(rr,-riy,0.0)
C@GL      call color(0)
          rx=nres+5
C@GL      call cmov(rx,-riy-5.0,0.0)
C@GL      call charst(lab,2)
      if (nrep .le. 1) then
        call rgbcolor(ips,kcprev)
        write (ips,*) 'np'
        ixnres=ixdel+scalefac*nres
        write (ips,3001) ixnres,-iydown
        call rgbcolor(ips,9)
        write (ips,3001) ixnres+5,-iydown-5
        call psshow(ips,lab,2)
        write (ips,*) 'sk'
      end if
      return
3001  format(i4,i5,' m')
3002  format(i4,i5,' l')
3004  format(i5,' setlinewidth')
      end
      subroutine colcode01(ips,ixright,iydown,ncode,nrep)
C@GL      character*7 lab
c     Plot color code
      iyd0=iydown-2
      iyd1=iydown+3
      iyd2=iydown+8
C@GL      call linewi(12)
C@GL      do icol=1,ncode
C@GL        call color(0)
C@GL        xx=(icol-1)*80+ixright
C@GL        call cmov(xx,float(-iyd2),0.0)
C@GL        write (lab,3011) ncode-icol,ncode
C@GL        call charst(lab,7)
C@GL        call color(icol)
C@GL        call move(xx+60.0,float(-iyd1),0.0)
C@GL        call draw(xx+75.0,float(-iyd1),0.0)
C@GL      end do
C@GL      do icol=1,ncode
C@GL        ix0=(icol-1)*80
C@GL        call drawrect(ips,9,1,ix0+60,ix0+75,-iyd2,-iyd0,nrep+1)
C@GL      end do
      if (nrep .le. 1) then
        write (ips,3004) 12
        do icol=1,ncode
          call rgbcolor(ips,9)
          ix0=ixright+(icol-1)*50
          write (ips,3001) ix0,-iyd2
          write (ips,3012) ncode-icol,ncode
          write (ips,*) 'np'
          call rgbcolor(ips,icol)
          write (ips,3001) ix0+35,-iyd1
          write (ips,3002) ix0+45,-iyd1
          write (ips,*) 'sk'
        end do
      end if
      do icol=1,ncode
        call drawrect(-ips,9,1,ix0+35,ix0+45,-iyd2,-iyd0,nrep)
      end do
      return
3001  format(i4,i5,' m')
3002  format(i4,i5,' l')
3004  format(i5,' setlinewidth')
C@GL3011  format('> ',i1,'/',i1,': ')
3012  format('(>',i1,'/',i1,':) show')
      end
      subroutine colcodeminmax(ips,ixright,iydown,nrep,ncode,maxcode,
     -  rmin,rmax)
C@GL      character*7 lab
      character*6 limline
c     Plot color code
c     print *,'COLCODEMINMAX ips,ncode,iydown=',ips,ncode,iydown
      iyd0=iydown-2
      iyd1=iydown+3
      iyd2=iydown+8
      absmax=amax1(abs(rmin),abs(rmax))
C@GL      call linewi(12)
C@GL      do icol=1,ncode
C@GL        call color(0)
C@GL        xx=(icol-1)*80+ixright
C@GL        call cmov(xx,float(-iyd2),0.0)
C@GL        write (lab,3011) icol-1,ncode-2
C@GL        call charst(lab,7)
C@GL        call color(icol)
C@GL        call move(xx+60.0,float(-iyd1),0.0)
C@GL        call draw(xx+75.0,float(-iyd1),0.0)
C@GL      end do
C@GL      do icol=1,ncode
C@GL        ix0=(icol-1)*80
C@GL        call drawrect(ips,9,1,ix0+60,ix0+75,-iyd2,-iyd0,nrep+1)
C@GL      end do
      if (nrep .le. 1) then
        write (ips,3004) 12
        do icol=0,ncode+1
          call rgbcolor(ips,9)
          ix0=ixright+(icol)*50
          write (ips,3001) ix0,-iyd2
          if (icol .le. ncode) then
            write (ips,3012) '<=',icol,ncode
            icoldrw=icol
          else
            write (ips,3012) '>',ncode,ncode
            icoldrw=maxcode+1
          end if
          write (ips,*) 'np'
          call rgbcolor(ips,icoldrw)
          write (ips,3001) ix0+35,-iyd1
          write (ips,3002) ix0+45,-iyd1
          write (ips,*) 'sk'
        end do
        iyd3=iyd2+15
        call rgbcolor(ips,9)
        do icol=0,ncode+1
          ix0=ixright+(icol)*50
          write (ips,3001) ix0,-iyd3
          rlim=rmin+float(icol)*(rmax-rmin)/float(ncode)
          if (icol .gt. ncode) rlim=rmax
          if (absmax .lt. 1.0) then
            write (limline,3013) rlim
          else if (absmax .lt. 10.0) then
            write (limline,3014) rlim
          else
            write (limline,3015) rlim
          end if
          if (icol .le. ncode) then
            write (ips,3016) '<=',limline
            icoldrw=icol
          else
            write (ips,3016) '>',limline
            icoldrw=maxcode+1
          end if
        end do
      end if
      call rgbcolor(ips,9)
      do icol=0,ncode+1
        ix0=ixright+(icol)*50
        call drawrect(-ips,9,1,ix0+35,ix0+45,-iyd2,-iyd0,nrep)
      end do
      return
3001  format(i4,i5,' m')
3002  format(i4,i5,' l')
3004  format(i5,' setlinewidth')
C@GL3011  format('< ',i1,'/',i1,': ')
3012  format('(',a,i1,'/',i1,':) show')
3013  format(f6.3)
3014  format(f6.2)
3015  format(f6.1)
3016  format('(',a,a,') show')
      end
      subroutine rgbcolor_sgi(iout,icol)
c     Set the PS color to the SGI colors (0-7); reverse 0 & 7
c     0:white; 1:red; 2:green; 3:yellow; 4:blue; 5:pink; 6; cyan; 7:orange
c     8:yellow-green 9:back
      if (icol .eq. 0) then
        write (iout,1000) 1.0,1.0,1.0
      else if (icol .eq. 1) then
        write (iout,1000) 1.0,0.0,0.0
      else if (icol .eq. 2) then
        write (iout,1000) 0.0,1.0,0.0
      else if (icol .eq. 3) then
        write (iout,1000) 1.0,1.0,0.0
      else if (icol .eq. 4) then
        write (iout,1000) 0.0,0.0,1.0
      else if (icol .eq. 5) then
        write (iout,1000) 1.0,0.0,1.0
      else if (icol .eq. 6) then
        write (iout,1000) 0.0,1.0,1.0
      else if (icol .eq. 7) then
        write (iout,1000) 1.0,0.5,0.0
      else if (icol .eq. 8) then
        write (iout,1000) 0.5,1.0,0.0
      else if (icol .eq. 9) then
        write (iout,1000) 0.0,0.0,0.0
      end if
      return
1000  format(3f5.1,' setrgbcolor')
      end
      subroutine rgbcolor(iout,icolinp)
c     Set the PS color to the rainbow colors (0-7);
c     0:white; 1:red; 2: orange; 3: yellow; 4:green;
c     5:cyan; 6:blue; 7:violet; 8:indigo; 9:black 10: magenta
      common /colorinfo/ ncolcode,maxcolcode
      dimension icolconv(9,8)
      data icolconv /
     -  1,9,0,0,0,0,0,0,9,
     -  1,6,9,0,0,0,0,0,9,
     -  1,4,6,9,0,0,0,0,9,
     -  1,3,4,6,9,0,0,0,9,
     -  1,3,4,6,10,9,0,0,9,
     -  1,3,4,5,6,10,9,0,9,
     -  1,2,3,4,5,6,10,9,9,
     -  1,2,3,4,5,6,7,8,9/
      if (icolinp .eq. maxcolcode+1 .or. icolinp .eq. 0) then
        icol=icolinp
      else if (icolinp .lt. 0) then
        icol=-icolinp
      else
        icol=icolconv(icolinp,ncolcode)
      end if
      if (icol .eq. 0) then
        write (iout,1000) 1.0,1.0,1.0
      else if (icol .eq. 1) then
        write (iout,1000) 1.0,0.0,0.0
      else if (icol .eq. 2) then
        write (iout,1000) 1.0,0.5,0.0
      else if (icol .eq. 3) then
        write (iout,1000) 1.0,1.0,0.0
      else if (icol .eq. 4) then
        write (iout,1000) 0.0,1.0,0.0
      else if (icol .eq. 5) then
        write (iout,1000) 0.0,1.0,1.0
      else if (icol .eq. 6) then
        write (iout,1000) 0.0,0.0,1.0
      else if (icol .eq. 7) then
        write (iout,1000) 0.5,0.0,1.0
      else if (icol .eq. 8) then
        write (iout,1000) 1.0,0.0,0.5
      else if (icol .eq. 9) then
        write (iout,1000) 0.0,0.0,0.0
      else if (icol .eq. 10) then
        write (iout,1000) 1.0,0.0,1.0
      end if
      return
1000  format(3f5.1,' setrgbcolor')
      end
      subroutine rrgbcolor(iout,icol,imax,iprt)
c     Set the color on a continous 0-1 scale
      if (iprt .eq. 1) write (iout,*) 'stroke'
      if (imax .eq. 1) then
        write (iout,1000) 0.0,0.0,0.0
      else
        rcol=float(icol-1)/float(imax-1)
        if (rcol .le. 0.25) then
          write (iout,1000) 1.0,4.0*rcol,0.0
        else if (rcol .le. 0.5) then
          write (iout,1000) (2.0-4.0*rcol),1.0,0.0
        else if (rcol .le. 0.75) then
          write (iout,1000) 0.0,1.0,4.0*(rcol-0.5)
        else
          write (iout,1000) 0.0,4.0-4.0*rcol,1.0
        end if
c       rcol=2.0*float(icol-1)/float(imax-1)
c       if (rcol .le. 1.0) then
c         write (iout,1000) (1.0-rcol),rcol,0.0
c       else
c         rcol=rcol-1.0
c         write (iout,1000) 0.0,(1.0-rcol),rcol
c       end if
      end if
      if (iprt .eq. 1) write (iout,*) 'newpath'
      return
1000  format(3f6.2,' setrgbcolor')
      end
      subroutine plotdssp(ips,ifss,ilss,itypss,nss,icx,maxconf,framefac,
     -  nxd,nyd,itit,ntit,xlab,nxlab,ylab,nylab,nframe,ifrdssp,ilrdssp,
     -  ixresno)
c*****Postscript plot of the development of DSSP assignments
      dimension ifss(nss),ilss(nss),itypss(nss),ixresno(ilrdssp)
      character*(*) itit,xlab,ylab
      dimension shiftl(9)
      character*1 typc
      character*21 ssname
      common /dsspnames/ lssname(9),ssname(9),typc(9)
      data shiftl /0.0,0.19,0.41,0.64,0.0,0.3,0.45,0.6,0.75/
c     nxd, nyd: increment between tics in the x, y axes, resp
c     itit: array containing the title; ntit: number of characters in itit
c     xlab, ylab: labels of the x, y axes
c     nxlab, ylab: number of characters in the labels of the x,y axes
c     print *,'PLOT nss,icx,maxconf=',nss,icx,maxconf
c     print *,'PlOT nxd,nyd,nframe=',nxd,nyd,nframe
      xm=675
      ym=495
      xmm=0.9*xm
      ymm=0.9*ym
c     xm0=0.075*xm
c     ym0=0.09*ym
      xm0=0.076*xm
      ym0=0.085*ym
      ixd=maxconf/nxd
      if (mod(maxconf,nxd) .ne. 0) ixd=ixd+1
      maxrsd=ilrdssp-ifrdssp+1
      iyd=maxrsd/nyd
      if (mod(maxrsd,nyd) .ne. 0) iyd=iyd+1
      xmax=nxd*ixd
      ymax=nyd*iyd
c     print *,'ixd,iyd,xmin,xmax=',ixd,iyd,xmin,xmax
      if (nframe .eq. 1) then
        call psheader(ips,itit,ntit,-30,-130,830,830,1,ipspage)
        write (ips,1006)
        write (ips,3000)
        write (ips,*) '-90 rotate'
        write (ips,1001) -xm*1.1,0.1*ym,' translate'
        write (ips,*) 'np'
        write (ips,1001) xm0,ym0,' m'
        write (ips,1001) xm0,ym0+ymm,' l'
        write (ips,1001) xm0+xmm,ym0+ymm,' l'
        write (ips,1001) xm0+xmm,ym0,'   l'
        write (ips,1001) xm0,ym0,' l'
        write (ips,*) 'sk'
        write (ips,*) 'np'
c       write (ips,1001) xm0+0.3*xmm,ym0+1.03*ymm,' m'
        write (ips,1001) xm0,ym0+1.03*ymm,' m'
        call psshow(ips,itit,ntit)
        write (ips,1001) xm0+0.50*xmm,ym0+1.02*ymm,' m'
        write (ips,*) 'sk'
        write (ips,*) 'np'
c       write (ips,1001) xm0+0.45*xmm,ym0-0.10*ymm,' m'
        write (ips,1001) xm0+0.45*xmm,ym0-0.07*ymm,' m'
        call psshow(ips,xlab,nxlab)
        write (ips,*) 'sk'
        write (ips,1001) xm0-0.06*xmm,ym0+0.4*ymm,' translate'
        write (ips,*) '90 rotate'
        write (ips,*) 'np'
        write (ips,1001) 0.0,0.0,' m'
        call psshow(ips,ylab,nylab)
        write (ips,*) 'sk'
        write (ips,*) '-90 rotate'
        write (ips,1001) -(xm0-0.06*xmm),-(ym0+0.4*ymm),' translate'
        write (ips,*) 3,' setlinewidth'
        yinc=0.10*ymm
        do is=1,9
          if (is .eq. 5) yinc=yinc+0.05*ymm
          call rgbcolor(ips,is)
          write (ips,*) 'np'
c         write (ips,1001) xm0+shiftl(is)*xmm,ym0-0.15*ymm,' m'
          write (ips,1001) xm0+shiftl(is)*xmm,ym0-yinc,' m'
          call psshow(ips,ssname(is),lssname(is))
          call psshow(ips,':',1)
          write (ips,1005) 0.01*xmm,0.006*ymm,' rmoveto'
          write (ips,1005) 0.040*xmm,0.0,' rlineto'
          write (ips,1005) 0.01*xmm,-0.006*ymm,' rmoveto'
          write (ips,*) 'sk'
        end do
        write (ips,*) 'np'
        write (ips,*) 1,' setlinewidth'
        call rgbcolor(ips,9)
        ifloatx=0
        if (xlab(1:1) .ne. ' ' .and. framefac*float(ixd) .lt. 100.0)
     -    ifloatx=1
        do ix=1,nxd
          write (ips,*) 'np'
          write (ips,1001) xm0+xmm*float(ix)/float(nxd),ym0,' m'
          write (ips,1001) 0.0,+0.01*ymm,' rlineto'
          write (ips,*) 'sk'
          write (ips,*) 'np'
          write (ips,1001) xm0+0.02*xmm+xmm*float(2*ix-1)/float(2*nxd),
     -      ym0-0.04*ymm,' m'
          if (ifloatx .eq. 0) then
            ixl=framefac*float(ix*ixd)
            write (ips,1002) ixl
          else
            write (ips,1007) framefac*float(ix*ixd)
          end if
        end do
        do iy=1,nyd
          write (ips,*) 'np'
          write (ips,1001) xm0,ym0+float(iy)/float(nyd)*ymm,' m'
          write (ips,1001) +0.01*xmm,0.0,' rlineto'
          write (ips,*) 'sk'
          write (ips,*) 'np'
          write (ips,1001) xm0-0.07*xmm,ym0-0.01*ymm+
     -      float(iy)/float(nyd)*ymm,' m'
          write (ips,1002) ixresno(ifrdssp-1+iy*iyd)
        end do
      end if
      rx=xm0+icx*xmm/xmax
      write (ips,*) 1,' setlinewidth'
      write (ips,*) 'np'
      itprev=0
      ym0=ym0-(ifrdssp-1)*ymm/ymax
      do iss=1,nss
        if (ilss(iss) .gt. ifrdssp .and. ifss(iss) .lt. ilrdssp) then
          if (itypss(iss) .ne. itprev) then
            if (itprev .ne. 0) write (ips,1003)
            call rgbcolor(ips,itypss(iss))
            itprev=itypss(iss)
          end if
          write (ips,1001) rx,ym0+max0(ifrdssp,ifss(iss))*ymm/ymax,'m'
          write (ips,1001) rx,ym0+min0(ilrdssp,ilss(iss))*ymm/ymax,'l'
        end if
      end do
      write (ips,*) 'sk'
      return
1001  format(2f8.1,1x,a)
1002  format('(',i8,') show',/,'sk')
1003  format('sk',/,'np')
1005  format(2f8.1,1x,a)
1006  format('%%Page: 1 1')
1007  format('(',f8.2,') show',/,'sk')
3000  format('/m { moveto } def',/,'/l { lineto } def',/,
     -  '/np { newpath } def',/, '/sk { stroke } def',/,
     -  '/f { fill } def',/,'/lw { setlinewidth } def',/,
     -  '/Helvetica findfont',/,'12 scalefont',/,'setfont')
      end
      subroutine res_res_bond(nres,nbfound,indexbond,nhbdist,
     -  iresno,ixres,ifres,isegno,it1,it2,it3,it4,temp,indexres,value,
     -  ifa,ila,title,ltitle,bondname,lbondname,ifirstframe,ilastframe,
     -  line,index,irescol1,irescol2,iresshift,igl,iout,iplot,ipspage,
     -  ncolcode,maxcolcode,mxbonds,maxrsd,maxat)
      dimension nhbdist(mxbonds),iresno(maxat),ixres(maxat),
     -  indexbond(mxbonds),ifres(maxat),isegno(maxat),index(maxat),
     -  it1(maxat),it2(maxat),it3(maxat),it4(maxat),temp(maxat),
     -  indexres(mxbonds),value(mxbonds),ifa(mxbonds),ila(mxbonds)
      character*(*) title,bondname
      character* 132 line(maxat)
      character*200 trajnam,trajnam2
      common /trajname/ trajnam,trajnam2,ltrajnam,ltrajnam2
      parameter (MAXFRAMES=50000,MAXCOPY=600,MAXITEMS=2*MAXCOPY-2)
      common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
     -  increment,increment2,ires(MAXITEMS,MAXFRAMES),
     -  scres(2,MAXFRAMES),x0(MAXCOPY),y0(MAXCOPY),nxselres,
     -  ixselres(MAXCOPY)
      parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
      parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
     -  (9*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
      common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),ing(MAX2D,MAX2D),
     -  ihbpair(2,MAXBONDS),ihb_pair_res(3,MAXBONDS),ihbtores(MAXBONDS),
     -  iusepair(MAXBONDS),ibond(MAXBONDS),a1(MAXBONDS),fill(IFILL2)
      dimension ixshuffle(MAX2D)
      real*8 dc(1,1)
      character*1 ans
      character*13 yclab(40)
      character*33 runlength
      character*80 question
c     print *,'RES_RES nframe,nbfound,nres,MAXBONDS=',
c    -  nframe,nbfound,nres,MAXBONDS
      call indexit(ixshuffle,1,MAX2D,0)
      call zeroiti(it1,0,nres)
      call zeroiti(it2,0,nres)
      call zeroiti(it3,0,nres)
      do i=1,nbfound
        ihb=indexbond(i)
        it1(ixres(ihbpair(1,ihb)))=1
        it1(ixres(ihbpair(2,ihb)))=1
      end do
c     it1(ir) is one if residue # ir is in a bond listed
c     it2 points from the original list to the short list
c     it3 points from the short residue list to the original list
      nreshb=0
      do ir=1,nres
        if (it1(ir) .gt. 0) then
          nreshb=nreshb+1
          it2(ir)=nreshb
          it3(nreshb)=ir
        end if
      end do
      write (6,1018) bondname(1:lbondname),nreshb,nres
      write (question,2000) bondname(1:lbondname)
      lq=45+lbondname
      call askyn(question,lq,1,+1,ireduceplot,73)
      call quiz(ans,iresres,'c',' ',0,'treatment of contacts',21,
     -  0,5,6,igl,70)
      write (iout,1018) bondname(1:lbondname),nreshb,nres
      write (iout,1000) bondname(1:lbondname),nbfound,nframe
      if (ireduceplot .eq. 0) then
        call indexit(it2,1,nres,0)
        call indexit(it3,1,nres,0)
        nreshb=nres
      end if
      if (ireduceplot .gt. 0 .or. iresshift .gt. 0) then
        write (iout,1001) bondname(1:lbondname),(ir,
     -    iresno(ifres(it3(ir))),isegno(ifres(it3(ir))),
     -    ixres(ifres(it3(ir))),ir=1,nreshb)
        if (iresshift .gt. 0) write (iout,1019)
        write (iout,1014)(it3(ir),ir=1,nreshb)
      end if
      nhbresmax=0
      do ir=1,nreshb
        do jr=1,nreshb
          ing(ir,jr)=0
          rmsd2d(ir,jr)=0.0
        end do
      end do
      do i=1,nbfound
        ihb=indexbond(i)
        ir1=it2(ixres(ihbpair(1,ihb)))
        ir2=it2(ixres(ihbpair(2,ihb)))
        ing(ir1,ir2)=ing(ir1,ir2)+1
        if (nhbresmax .lt. ing(ir1,ir2)) nhbresmax=ing(ir1,ir2)
        rmsd2d(ir1,ir2)=rmsd2d(ir1,ir2)+nhbdist(ihb)
        if (ir1 .ne. ir2) then
          ing(ir2,ir1)=ing(ir1,ir2)
          rmsd2d(ir2,ir1)=rmsd2d(ir1,ir2)
        end if
      end do
      write (6,1017) bondname(1:lbondname),nhbresmax
      write (iout,1017) bondname(1:lbondname),nhbresmax
      write (iout,1010) bondname(1:lbondname)
      do jr=nreshb,1,-1
        write (iout,1003) jr,it3(jr),(ing(ir,jr),ir=1,nreshb)
      end do
      write (iout,1013) bondname(1:lbondname)
      do jr=nreshb,1,-1
        do ir=1,nreshb
          rmsd2d(ir,jr)=rmsd2d(ir,jr)/float(nframe)
          a1(ir)=rmsd2d(ir,jr)
        end do
        call writesmall(iout,a1,nreshb,jr,it3(jr))
      end do
      write (iout,1012) bondname(1:lbondname)
      write (iout,1014)(it3(ir),ir=1,nreshb)
      do jr=nreshb,1,-1
        call zeroit(a1,nreshb)
        do ir=1,nreshb
          if (ing(ir,jr) .gt. 0) a1(ir)=rmsd2d(ir,jr)/float(ing(ir,jr))
        end do
        call writesmall(iout,a1,nreshb,jr,it3(jr))
        if (ans .eq. 'a') call trnsfr(rmsd2d(1,jr),a1,nreshb)
      end do
c     Generate contact statistics ignoring multiple contacts
c     Sort contact list
      call sortbondlist(ixres,nbfound,indexbond,maxrsd,mxbonds)
      irescodeprev=0
      do ifr=1,nframe
        call readbitc(ires(1,ifr),ibond,nbfound,30,MAXITEMS)
        do ib=1,nbfound
          ihb=indexbond(ib)
          if (ibond(ihb) .gt. 0) then
            ir1=it2(ixres(ihbpair(1,ihb)))
            ir2=it2(ixres(ihbpair(2,ihb)))
            irescode=ir1*MAXRSD+ir2
            if (irescode .ne. irescodeprev) then
              irescodeprev=irescode
              ing(ir1,ir2)=ing(ir1,ir2)+1
              ing(ir2,ir1)=ing(ir1,ir2)
            end if
          end if
        end do
      end do
      write (6,1016) bondname(1:lbondname)
      write (iout,1016) bondname(1:lbondname)
      write (iout,1014)(it3(ir),ir=1,nreshb)
      do ir=1,nreshb
        do jr=1,nreshb
          ing(ir,jr)=0
        end do
      end do
      ip=1
      do while (ihb_pair_res(3,ip) .gt. 0)
        ir1=it2(ihb_pair_res(1,ip))
        ir2=it2(ihb_pair_res(2,ip))
        if (ir1*ir2 .gt. 0) ing(ir1,ir2)=ihb_pair_res(3,ip)
        ip=ip+1
      end do
      do jr=nreshb,1,-1
        call zeroit (a1,nreshb)
        do ir=1,nreshb
          a1(ir)=float(ing(ir,jr))/float(nframe)
        end do
        call writesmall(iout,a1,nreshb,jr,it3(jr))
        if (ans .eq. 'i') call trnsfr(rmsd2d(1,jr),a1,nreshb)
      end do
      np=1
      do while (ihb_pair_res(3,np) .gt. 0)
        value(np)=ihb_pair_res(1,np)
        np=np+1
      end do
      np=np-1
      call indexit(indexres,1,np,0)
      call mrgsrt(6,indexres,value,np,ifa,ila,it4,temp,mxbonds)
      write (iout,1020)
      do ipp=1,np
        ip=indexres(ipp)
        ir1=ihb_pair_res(1,ip)
        ir2=ihb_pair_res(2,ip)
        ia1=ifres(ir1)
        ia2=ifres(ir2)
        perc=100.0*float(ihb_pair_res(3,ip))/float(nframe)
        write (iout,1002) iresno(ia1),
     -    line(index(ia1))(irescol1:irescol2),isegno(ia1),iresno(ia2),
     -    line(index(ia2))(irescol1:irescol2),isegno(ia2),perc
      end do
      rhbmax=0.0
      do ir=1,nreshb
        do jr=1,nreshb
          if (rhbmax .lt. rmsd2d(ir,jr)) rhbmax=rmsd2d(ir,jr)
        end do
      end do
      if (nreshb .gt. 0) then
        inc=max0(1,500/nreshb)
        iydel=150
        call indexit(it1,1,nreshb,0)
        write (question,2002) bondname(1:lbondname)
        lq=38+lbondname
        call getreal(question,lq,rhbmax,rhbscalemax,0,74)
        call getint('Last residue to plot on the Y axis',34,
     -    nreshb,1,nreshb,iylst,94)
        call getint('First residue to plot on the Y axis',35,
     -    1,1,nreshb,iyfst,94)
        iyinc=iyfst-1
        nreshby=iylst-iyinc
        write (runlength,1011) ifirstframe,ilastframe
        if (nreshby .le. 40) then
          nyclab=nreshby
          lyclab=1
c         Gather residue names and numbers
          do iy=iyfst,iylst
            ia=ifres(it3(iy))
            write (yclab(iy-iyinc),1008) 
     -        line(index(ia))(irescol1:irescol2),iresno(ia)
            if (irescol2-irescol1+7 .gt. lyclab)
     -        lyclab=irescol2-irescol1+7
c           print *,iy,' YCLAB=',yclab(iy-iyinc)(1:lyclab)
          end do
        else
          nyclab=1
          lyclab=0
        end if
        scalefac=1.0
        call plotmat(iplot,ing,rmsd2d,dc,nreshb,nreshby,0,0,0,iyinc,
     -    1,0,25,iydel,00,iytop,0.0,rhbscalemax,ncolcode,maxcolcode,
     -    ixdelsh,iydelsh,inc,scalefac,ixshuffle,ixshuffle,it1,title,
     -    ltitle,'Trajectory analyzed: '//trajnam,ltrajnam+21,' ',1,a1,
     -    yclab,nyclab,lyclab,igl,1,MAX2D,1,MAX2D,MAX2D,ipspage,0)
c       Draw boundary between solute molecules
        write (iplot,*) '% Drawing separator lines'
        call rgbcolor(iplot,9)
        write (iplot,*) '2 lw'
        if (nreshby .gt. 1) scalefac=scalefac*0.95
        do i=1,nreshb-1
          if (isegno(ifres(it3(i+1))) .ne. isegno(ifres(it3(i)))) then
c           print *,'BOUND at i=',i,' ir=',it3(i),' ia=',ifres(it3(i+1))
            write (iplot,*) 'np'
            ixdell=ixdelsh
            if (nreshb .lt. 550) ixdell=ixdelsh+40
            write (iplot,1005) ixdell+i*inc,iydelsh
            write (iplot,1006) ixdell+i*inc,iydelsh+nreshb*inc
            write (iplot,1005) ixdell,iydelsh+(i-iyfst+1)*inc
            write (iplot,1006) ixdell+nreshb*inc,iydelsh+(i-iyfst+1)*inc
            write (iplot,*) 'sk'
          end if
        end do
        if (nreshb .ge. 5) iydel=iydel-50
        if (nreshb .lt. 5) iydel=iydel-20
        ixcent=max0(0,(nreshb*inc-50*ncolcode)/2)
        call colcodeminmax(iplot,25+ixcent,-iydel-5,0,ncolcode,
     -    maxcolcode,0.0,rhbscalemax)
        iydel=iydel-35
        write (iplot,1005) 75,iydel
        write (iplot,1004) bondname(1:lbondname),0.0,rhbscalemax
        iydel=iydel-15
        write (iplot,1005) 75,iydel
        write (iplot,1007) bondname(1:lbondname)
        iydel=iydel-15
        write (iplot,1005) 75,iydel
        if (ans .eq. 'i') then
          write (iplot,1009) 'Multiple contacts are ignored'
        else if (ans .eq. 'a') then
          write (iplot,1009) 'Multiple contacts are averaged'
        else
          write (iplot,1009) 'Multiple contacts are accumulated'
        end if
        iydel=iydel-15
        write (iplot,1005) 75,iydel
        write (iplot,1009) runlength
      else
        Print *,'No ',bondname(1:lbondname),'-bonding residue was found'
      end if
      write (iplot,*) 'showpage'
      return
1000  format(' Number of different ',a,' bonds found=',i6,/,
     -  ' Number of frames analyzed=',i6,/)
1001  format(' List of the original indices of the ',a,
     -  '-bonding residues',/,(' Residue index(on plot)=',i4,
     -  ' residue #=',i5,' segment #=',i4,' residue index=',i5))
1002  format(' Bonded % of residues',i6,' (',a,') C/S',i2,' and',i6,
     -  ' (',a,') C/S',i2,'=',f5.1)
1003  format(' iy=',i4,' iy(orig)=',i5,10i5,/(23x,10i5))
1004  format('( Range of the ',a,'-bond fraction scale:',f8.3,'  -',
     -  f8.3,') show')
1005  format(2i5,' m')
1006  format(2i5,' l')
1007  format('( Residue-Residue ',a,' bond fractions ) show')
1008  format(1x,a,i5)
1009  format('( ',a,' ) show')
1010  format(/,' Number of different ',a,' bonds between residue pairs')
1011  format(' Frame range: ',i8,' - ',i8)
1012  format(/,' Fraction of time the ',a,' bonds are formed between ',
     -  'residue pairs',/,
     -  ' averaged over all bonds between these residues')
1013  format(/,' Average number of ',a,' bonds between residue pairs')
1014  format(' iy(orig):',13x,10i5,/,(23x,10i5))
c1015  format('( Upper-left triangle: iy is donor; ',
c     -  'Lower-right triangle: ix is donor ) show')
1016  format(/,' Fraction of time any ',a,' bond was formed between ',
     -  'residue pairs')
1017  format(/,' Maximum number of ',a,' bonds between two residues=',
     -  i4)
1018  format(' Number of residues involved in ',a,' bonding=',i5,
     -  ' (out of ',i6,')')
1019  format(' NOTE: residue numbers below refer to the residue ',
     -  'INDICES printed above')
1020  format(/,' List of non-zero entries in the residue-residue ',
     -  'matrix plot:')
2000  format('Do you want only ',a,'-bonded residues in the plot')
2002  format('Limit of the residue-residue ',a,' bond map scale')
      end
      subroutine writesmall(iout,a,n,iy,iyorig)
      dimension a(n)
      character*80 line
c     print *,'WRITESMALL n,iy,iyorig=',n,iy,iyorig
      nw=0
      do while (nw .lt. n)
        call blankout(line,1,80)
        if (nw .eq. 0) write (line(1:24),1001) iy,iyorig
        write (line(25:74),1002) (a(i),i=nw+1,min0(n,nw+10))
        do i=1,min0(10,n-nw)
          if (a(nw+i) .lt. 0.00001) line(24+(i-1)*5+1:24+i*5)=' 0.0 '
        end do
        write (iout,1000) line(1:74)
        nw=nw+10
      end do
      return
1000  format(a)
1001  format(' iy=',i4,' iy(orig)=',i5,':')
1002  format(10f5.2)
      end
      subroutine mrgsortlist(list,it1,it2,it3,it4,t1,t2,n)
      dimension list(n),it1(n),it2(n),it3(n),it4(n),t1(n),t2(n)
c     Sort a list of positive integers 
c     print *,'MRGS n=',n
c     print *,'LIST=',(list(i),i=1,n)
      call indexit(it1,1,n,0)
      do i=1,n
        t1(i)=list(i)
      end do
      call mrgsrt(6,it1,t1,n,it2,it3,it4,t2,n)
c     print *,'T=',(t1(i),i=1,n)
      do i=1,n
        list(i)=t1(i)
      end do
c     print *,'LIST=',(list(i),i=1,n)
      return
      end
      subroutine sortlist(iout,list,listlen,itemp,iorig,lab,itestonly,
     -  maxval)
      dimension list(listlen),itemp(maxval),iorig(listlen)
      character*3 lab
c     Sort a list of distinct positive integers of maximum value maxval
c     Use it for long lists; listlen about the same as maxval
      call zeroiti(itemp,0,maxval)
      nerr=0
      do i=1,listlen
        if (itemp(list(i)) .gt. 0) then
          write (6,1000) lab,list(i),listlen,maxval
          if (iout .gt. 0) write (iout,1000) lab,list(i),listlen,maxval
          nerr=nerr+1
        end if
        itemp(list(i))=i
      end do
      if (nerr .gt. 0) then
        write (6,1001) (list(i),i=1,listlen)
        if (iout .gt. 0) write (iout,1001) (list(i),i=1,listlen)
      end if
      if (itestonly .eq. 0) then
        ll=0
        do i=1,maxval
          if (itemp(i) .gt. 0) then
            ll=ll+1
            list(ll)=i
            iorig(ll)=itemp(i)
          end if
        end do
      end if
      return
1000  format(' PROGRAM ERROR in ',a,' sortlist: duplicate entry ',i6,
     -  /,' List length=',i6,' Maximum value=',i6)
1001  format(' List entries:',/,(10i6))
      end
      subroutine sortbondlist(ixres,listlen,indexbond,maxrsd,mxbonds)
      dimension ixres(maxrsd),indexbond(mxbonds)
      parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
      parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
     -  (9*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
      parameter (IFILL6=MAX2D*MAX2D-6*MAXBONDS)
      common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),ifill(IFILL6),
     -  i1(MAXBONDS),i2(MAXBONDS),i3(MAXBONDS),i4(MAXBONDS),
     -  newpair(2,MAXBONDS),ihbpair(2,MAXBONDS),
     -  ihb_pair_res(3,MAXBONDs),ihbtores(MAXBONDS),
     -  iusepair(MAXBONDS),a1(MAXBONDS),a2(MAXBONDS),fill(IFILL2)
      do i=1,listlen
        ii=indexbond(i)
        a1(i)=ixres(ihbpair(1,ii))*MAXBONDS+ixres(ihbpair(2,ii))
      end do
      call mrgsrt(6,indexbond,a1,listlen,i2,i3,i4,a2,listlen)
c      do i=1,listlen
c        ii=indexbond(i)
c        iii=ixres(ihbpair(1,ii))*MAXBONDS+ixres(ihbpair(2,ii))
c        write (6,5511) i,ii,(ixres(ihbpair(k,ii)),k=1,2),iii
c5511    format(i4,' ixb=',i3,' ir1,2=',2i4,' a=',i9)
c      end do
      return
      end
      subroutine plotbond(ips,nhbtot,nhbplot,nbresplot,nclust,ianc_anc,
     -  ifhbclust,ilhbclust,index,ihb,ihbon,ihbstart,rdclust,iclust,
     -  xtrajmax,nydd,itit,ntit,xlab,nxlab,ixskip,ylab,nylab,nohead,
     -  percmin,percmax,numres,minresdist,maxresdist,distmax,bondname,
     -  lbondname,nobullet,nhneigmin,nbondmax,naabondmax,icorrtyp,
     -  icorrtrans,nframeav,correxp,hblimfac,angmin,lablim,ibondtype,
     -  ibondlab,nofilt,itemp1,itemp2,trajnam,ltrajnam,ixresno,irrix,
     -  ixres,nrrbond,atnames,resnames,npspages,ipspage,mxbonds,maxrsd,
     -  maxrec)
c*****Plot the time-course of hydrogen, hydrophobic bonds & salt bridges
      dimension ianc_anc(mxbonds),ifhbclust(mxbonds),ilhbclust(mxbonds),
     -  index(mxbonds),ihb(mxbonds),ihbon(mxbonds),ihbstart(mxbonds),
     -  itemp1(mxbonds),itemp2(mxbonds),ixresno(maxrsd),irrix(maxrsd),
     -  ixres(maxrec),nrrbond(mxbonds)
      character*(*) itit,xlab,ylab,bondname,trajnam
      character*8 atnames(maxrec),resnames(maxrsd)
      parameter (MAXFRAMES=50000,MAXCOPY=600,MAXITEMS=2*MAXCOPY-2)
      common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
     -  increment,increment2,ires(MAXITEMS,MAXFRAMES),
     -  scres(2,MAXFRAMES),x0(MAXCOPY),y0(MAXCOPY),nxselres,
     -  ixselres(MAXCOPY)
      character*40 clstyp
      common /cluster_typ/ nclstyp,inumclst(9),ireadcutoff(9),
     -  lclstyp(9),clstyp(9)
      parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
      parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
     -  (9*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
      common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),ing(MAX2D,MAX2D),
     -  ihbpair(2,MAXBONDS),ihb_pair_res(3,MAXBONDS),ihbtores(MAXBONDS),
     -  iusepair(MAXBONDS),ibond(MAXBONDS),a1(MAXBONDS),fill(IFILL2)
      dimension icolrb(2),lcorrtyp(3)
      character*1 corrtrans(3)
      character*36 corrtyp(3)
      character*37 bondlab(1)
      data icolrb /1,6/,lcorrtyp /36,28,28/
      data corrtrans /'-','/',' '/,corrtyp /
     -  'Correlate both the on and off states',
     -  'Correlate only the on states        ',
     -  'Correlate averaged on states        '/
c     nxd, nyd: number of tics in the x, y axes, resp
c     itit: array containing the title; ntit: number of characters in itit
c     xlab, ylab: labels of the x, y axes
c     nxlab, ylab: number of characters in the labels of the x,y axes
c     ibondlab=1: bond label; ibondlab=2: res pair label
      nhbtot=min0(nhbtot,30*MAXITEMS)
c     write (06,*) 'PLOTBOND nydd,nhbplot,nhbtot,nbresplot=',
c    -  nydd,nhbplot,nhbtot,nbresplot
c     print *,'PLOTBOND nclust,rdclust,numres,maxresdist=',
c    -                  nclust,rdclust,numres,maxresdist
c      write (40,8711) (ihbtores(i),i=1,nhbtot)
c8711  format(' IHBTORES:',/,(15i5))
      if (iclust .gt. 0 .and. nclust .eq. 0) return
      ntotplot=nhbplot
      if (ibondlab .eq. 2) ntotplot=nbresplot
      if (ntotplot .le. 20) then
        xm=650
        ym=amax1(200.0,350.0*float(ntotplot)/20.0)
        xm0=75
        xm00=-40
        xmm=0.9*xm
      else
        xm=675
        ym=495
        xmm=0.9*xm
        xm0=0.075*xm
        xm00=xm0-0.15*xmm
      end if
      ymm09=0.9*ym
      ymm=amin1(ymm09,float(nhbplot*10))
      if (ibondlab .eq. 1) then
        xm0=xm0+0.05*xmm
        xm00=xm0-0.20*xmm
      end if
      yshiftinc=12
      ym0=2.0*yshiftinc+5.0
      if (xlab(1:1) .eq. ' ') then
        nfrtot=nframetot
        call roundlimint(nfrtot,ixd,nxd)
      else
c       Round up nframetot based on xtrajmax
        frtot=xtrajmax
        call roundlim(frtot,xdiv,nxd)
        nfrtot=float(nframetot)*frtot/xtrajmax+1
        ixd=nfrtot/nxd+1
      end if
      xfac=xmm/float(nxd*ixd)
      nyd=nydd
      if (ibondlab .eq. 2) then
        if (iclust .eq. 0) then
          call trnsfi(itemp1,index,nhbtot)
          call indexit(index,1,nhbtot,0)
        end if
      end if
      call roundlimint(ntotplot,iyd,nyd)
      ymax=nyd*iyd
      yfac=ymm/float(iyd*nyd)
      lw=1
      if (ntotplot .le. 100) lw=2
      if (ntotplot .le. 50) lw=3
      call zeroiti(ihbon,0,nhbtot)
      call zeroiti(ihbstart,0,nhbtot)
      if (iclust .eq. 0) call zeroiti(nrrbond,0,ntotplot)
      nbondmax=0
      naabondmax=0
      do ifr=1,nframetot
        call readbitc(ires(1,ifr),ihb,nhbtot,30,MAXITEMS)
        if (ibondlab .lt. 2) then
          nhbsum=0
          nhbaasum=0
          do ib=1,nhbtot
            ibx=index(ib)
            if (ihb(ibx) .eq. 1) then
              nhbsum=nhbsum+1
              if (ianc_anc(ibx) .eq. 1) nhbaasum=nhbaasum+1
            end if
          end do
          scres(1,ifr)=nhbsum
          scres(2,ifr)=nhbaasum
          if (nbondmax .lt. nhbsum) nbondmax=nhbsum
          if (naabondmax .lt. nhbaasum) naabondmax=nhbaasum
        else
c         res-aggregated tracks
          call trnsfi(itemp2,ihb,nhbtot)
          call zeroiti(ihb,0,ntotplot)
          do ib=1,nhbtot
            ibb=ihbtores(ib)
            if (itemp2(ib)*ibb .gt. 0) ihb(ibb)=1
          end do
          if (iclust .eq. 0) then
            do ib=1,ntotplot
              nrrbond(ib)=nrrbond(ib)+ihb(ib)
            end do
          end if
        end if
        if (ifr .eq. 1) then
          call trnsfi(ihbon,ihb,ntotplot)
          if (nohead .eq. 0) call psheader(ips,itit,ntit,
     -      -30,-130,830,830,npspages,ipspage)
          write (ips,3000) 10
          ipspage=ipspage+1
          write (ips,1019) ipspage
          write (ips,*) '-90 rotate'
          write (ips,1001) -xm*1.1,0.1*ym,' translate'
c         Drawing bounding box
          write (ips,*) 'np'
          write (ips,1001) xm0,ym0,' m'
          write (ips,1001) xm0,ym0+ymm+4,' l'
          write (ips,1001) xm0+xmm,ym0+ymm+4,' l'
          write (ips,1001) xm0+xmm,ym0,'   l'
          write (ips,1001) xm0,ym0,' l'
          write (ips,*) 'sk'
          write (ips,*) 'np'
          yshift=yshiftinc
          if (distmax .gt. 0.0 .or. nhneigmin .gt. 0) then
            write (ips,1001) xm0,ym0+ymm+yshift,' m'
            write (ips,1005) bondname(1:lbondname),distmax
            yshift=yshift+yshiftinc
          end if
          if (ibondtype .eq. 1 .or. ibondtype .eq. 2) then
            write (ips,1001) xm0,ym0+ymm+yshift,' m'
            if (ibondtype .eq. 2) write (ips,1004) nhneigmin
            if (ibondtype .eq. 1) write (ips,1015) hblimfac,angmin
            yshift=yshift+yshiftinc
          end if
          if (percmin .gt. 0.0 .or. percmax .lt. 100.0 .and.
     -        nofilt .eq. 0) then
            write (ips,1001) xm0,ym0+ymm+yshift,' m'
            write (ips,1007) percmin,percmax
            yshift=yshift+yshiftinc
          end if
          if (minresdist .gt. 0 .or. maxresdist .lt. numres-1 .and.
     -        nofilt .eq. 0) then
            write (ips,1001) xm0,ym0+ymm+yshift,' m'
            write (ips,1008) minresdist,maxresdist
            yshift=yshift+yshiftinc
          end if
          if (ibondlab .eq. 2) then
            write (ips,1001) xm0,ym0+ymm+yshift,' m'
            write (ips,1018) bondname(1:lbondname)
            yshift=yshift+yshiftinc
          end if
          write (ips,1001) xm0,ym0+ymm+yshift,' m'
          if (iclust .eq. 0) then
            write (ips,1009) bondname(1:lbondname)
          else
            if (rdclust .gt. 0.0) then 
              write (ips,1010) clstyp(iclust)(1:lclstyp(iclust)),rdclust
            else 
              write (ips,1012) clstyp(iclust)(1:lclstyp(iclust)),nclust
            end if
            yshift=yshift+yshiftinc
            write (ips,1001) xm0,ym0+ymm+yshift,' m'
            write (ips,1013) corrtyp(icorrtyp)(1:lcorrtyp(icorrtyp))
            if (icorrtyp .eq. 3) write (ips,1014) nframeav
            write (ips,1023) corrtrans(icorrtrans),correxp
          end if
          yshift=yshift+yshiftinc
          write (ips,1001) xm0,ym0+ymm+yshift,' m'
          write (ips,1017) trajnam(1:ltrajnam)
          yshift=yshift+yshiftinc
          write (ips,1001) xm0,ym0+ymm+yshift,' m'
          call psshow(ips,'Title: ',7)
          call psshow(ips,itit,ntit)
          write (ips,*) 'sk'
          write (ips,3000) 12
          call rgbcolor(ips,9)
          write (ips,*) 'np'
c         write (ips,1001) xm0+0.45*xmm,ym0-0.09*ymm09,' m'
          write (ips,1001) xm0+0.45*xmm,ym0-2.0*yshiftinc,' m'
          call psshow(ips,xlab,nxlab)
          write (ips,*) 'sk'
          if (ibondlab .eq. 0 .or. ntotplot .gt. lablim) then
c           Don't skip y label to leave room for res-res info
            write (ips,1001) xm0-0.06*xmm,ym0+0.4*ymm,' translate'
            write (ips,*) '90 rotate'
            write (ips,*) 'np'
            write (ips,1001) 0.0,0.0,' m'
            call psshow(ips,ylab,nylab)
            write (ips,*) 'sk'
            write (ips,*) '-90 rotate'
            write (ips,1001) -(xm0-0.06*xmm),-(ym0+0.4*ymm),' translate'
          else if (ntotplot .gt. lablim) then
           if (ibondlab .eq. 2) write (6,1022) lablim,'residue pairs'
           if (ibondlab .eq. 1) write (6,1022) lablim,
     -       bondname(1:lbondname)
          end if
          write (ips,*) 3,' setlinewidth'
          write (ips,*) 'np'
          write (ips,*) 1,' setlinewidth'
          call rgbcolor(ips,9)
          ifloatx=0
          do ix=1,nxd
            write (ips,*) 'np'
            write (ips,1001) xm0+xmm*float(ix)/float(nxd),ym0,' m'
            write (ips,1001) 0.0,+0.01*ymm,' rlineto'
            write (ips,*) 'sk'
            write (ips,*) 'np'
c           write (ips,1001) xm0+0.02*xmm+
            write (ips,1001) xm0-0.02*xmm+
     -        xmm*float(4*ix-1)/float(4*nxd),ym0-yshiftinc,' m'
c    -        xmm*float(4*ix-1)/float(4*nxd),ym0-0.04*ymm09,' m'
            if (xlab(1:1) .eq. ' ') then
              write (ips,1002) (ix*ixd)+ixskip
            else
              if (xdiv .ge. 100.0) then
                ixxdiv=ix*xdiv+ixskip+0.01
                write (ips,1002) ixxdiv
              else
                write (ips,1003) (ix*xdiv)+ixskip
              end if
            end if
          end do
          if (ibondlab .eq. 0 .or. ntotplot .gt. lablim) then
            do iy=1,nyd
              write (ips,*) 'np'
              write (ips,1001) xm0,ym0+float(iy)/float(nyd)*ymm,' m'
              write (ips,1001) +0.01*xmm,0.0,' rlineto'
              write (ips,*) 'sk'
              write (ips,*) 'np'
c             write (ips,1001) xm0-0.07*xmm,ym0-0.01*ymm+
              write (ips,1001) xm0-0.07*xmm,ym0-0.01*ymm+
     -          float(iy)/float(nyd)*ymm,' m'
              write (ips,1002) iy*iyd
            end do
          else
c           Print info
            if (ntotplot .gt. 20) write (ips,1021) 8
            do iy=1,ntotplot
              if (mod(iy,iyd) .eq. 0) then
                write (ips,*) 'np'
                write (ips,1001) xm0,ym0+float(iy)/float(nyd*iyd)*ymm,
     -            ' m'
                write (ips,1001) +0.01*xmm,0.0,' rlineto'
                write (ips,*) 'sk'
              end if
              write (ips,*) 'np'
              write (ips,1001) xm00,
     -          ym0+float(iy)/float(nyd*iyd)*ymm,' m'
              call makebondlab(iy,iy,iy-1,ibondlab,bondlab,lbondlab,
     -          irrix,ixresno,ixres,index,resnames,atnames,1,mxbonds,
     -          maxrsd,maxrec)
              write (ips,1013) bondlab(1)(1:lbondlab)
            end do
            write (ips,1021) 12
          end if
          if (iclust .gt. 0) then
c           Plot cluster marker bars
            write (ips,*) 12,' setlinewidth'
            xclust0=xm0+1.02*xmm
            ncp=0
            do ic=1,nclust
              if (ilhbclust(ic)-ifhbclust(ic) .gt. 0) then
                ncp=ncp+1
                xinc=1.00
c               if (mod(ncp,2) .eq. 0) xinc=1.01
                write (ips,*) 'np'
                write (ips,1001) xinc*xclust0,ym0+yfac*ifhbclust(ic),'m'
                write (ips,1001) xinc*xclust0,ym0+yfac*ilhbclust(ic),'l'
                write (ips,*) 'sk'
              end if
            end do
          end if
c         write (ips,*) 2,' setlinewidth'
          write (ips,*) lw,' setlinewidth'
        end if
c       write (ips,*) lw,' setlinewidth'
        nlwp=0
        do ib=1,ntotplot
          ibx=index(ib)
          if (nobullet .eq. 0) then
            if (ihbstart(ibx) .eq. 0 .and. ihb(ibx) .eq. 1) then
              ihbstart(ibx)=1
              write (ips,*) 'np'
              call rgbcolor(ips,9)
              write (ips,1016) xm0+xfac*float(ifr),ym0+yfac*float(ib),
     -          float(lw),0.0,360.0
              write (ips,*) 'fill'
              write (ips,*) 'sk'
            end if
          end if
          if (ihb(ibx) .eq. 1 .and. ihbon(ibx) .eq. 0) then
            ihbon(ibx)=ifr
          else if ((ihb(ibx) .eq. 0  .or. ifr .eq. nframetot) .and.
     -              ihbon(ibx) .gt. 0) then
c           Draw line between ihbon(ibx) and ifr
            ym=ym0+yfac*float(ib)
            write (ips,*) 'np'
            call rgbcolor(ips,-icolrb(ianc_anc(ibx)+1))
            write (ips,1001) xm0+xfac*float(ihbon(ibx)),ym,' m'
            write (ips,1001) xm0+xfac*float(ifr),ym,' l'
            write (ips,*) 'sk'
            ihbon(ibx)=0
          end if
        end do
      end do
c     Print tick on the right y axis
      call rgbcolor(ips,9)
      write (ips,*) 1,' setlinewidth'
      do iy=1,nyd
        write (ips,*) 'np'
        write (ips,1001) xm0+xmm,ym0+float(iy)/float(nyd)*ymm,' m'
        write (ips,1001) -0.01*xmm,0.0,' rlineto'
        write (ips,*) 'sk'
      end do
c     Print color code
      write (ips,*) lw,' setlinewidth'
      axshift=0.0
      if (nbondmax .gt. naabondmax) then
        write (ips,*) 'np'
        call rgbcolor(ips,-icolrb(1))
        write (ips,1001) xm0+10.0,ym0-0.09*ymm09,' m'
        write (ips,1001) 20.0,0.0,' rlineto'
        write (ips,1001) xm0+30.0,ym0-0.09*ymm09,' m'
        write (ips,1011) ' : anchor -- non-anchor'
        write (ips,*) 'sk'
        axshift=1.0
      end if
      if (naabondmax .gt. 0) then
        write (ips,*) lw,' setlinewidth'
        write (ips,*) 'np'
        call rgbcolor(ips,-icolrb(2))
        write (ips,1001) xm0+10.0+axshift*0.6*xmm,ym0-0.09*ymm09,' m'
        write (ips,1001) 20.0,0.0,' rlineto'
        write (ips,1001) xm0+30.0+axshift*0.6*xmm,ym0-0.09*ymm09,' m'
        write (ips,1011) ' : anchor -- anchor'
        write (ips,*) 'sk'
      end if
      call rgbcolor(ips,9)
      write (ips,*) 1,' setlinewidth'
      write (ips,*) 'showpage'
      if (ibondlab .eq. 2) call trnsfi(index,itemp1,nhbtot)
      return
1001  format(2f8.1,1x,a)
1002  format('(',i8,') show',/,'sk')
1003  format('(',f8.2,') show',/,'sk')
1004  format('( Minimum number of hydrogens on hydrophobic carbons=',
     -  i1,') show')
1005  format('( Length limit of a ',a,' bond=',f5.2,' A) show')
1007  format('(Minimum and maximum % occurrences to show=',
     -  f4.1,f6.1,') show')
1008  format('(Minimum and maximum interresidue distances to show=',
     -  i4,' and ',i5,' residues ) show')
1009  format('(Unclustered plot, original ',a,'-bond order ) show')
1010  format('(Clustering method: ',a,'; distance measure cutoff=',f5.2,
     -  ' ) show')
1011  format('(',a,') show')
1012  format('(Clustering method: ',a,' Number of clusters=',i2,')show')
1013  format('(',a,' ) show')
1014  format('(# of frames averaged=',i4,' ) show')
1015  format('(Hydrogen-bond parameters: hblimfac=',f6.3,
     -  ' angmin=',f8.2,' deg ) show')
1016  format(5f12.4,' arc')
1017  format('(Trajectory analyzed:',a,') show')
1018  format('(Residue aggregated time course of ',a,' bonds) show')
1019  format('%%Page: 1 ',i4)

1021  format('/Helvetica findfont',/,i2,' scalefont',/,'setfont')
1022  format(' NOTE: more than',i3,1x,a,' - no room for the names')
1023  format('(; distance measure=(1',a,'corr)^',f4.2,' ) show')
3000  format('/m { moveto } def',/,'/l { lineto } def',/,
     -  '/np { newpath } def',/, '/sk { stroke } def',/,
     -  '/f { fill } def',/,'/lw { setlinewidth } def',/,
     -  '/Helvetica findfont',/,i2,' scalefont',/,'setfont')
      end
      subroutine makebondlab(ilab1,ilab2,inc,ibondlab,bondlab,lbondlab,
     -  irrix,ixresno,ixres,index,resnames,atnames,maxbondlab,mxbonds,
     -  maxrsd,maxrec)
      dimension ixresno(maxrsd),irrix(maxrsd),ixres(maxrec),
     -  index(mxbonds)
      character*8 atnames(maxrec),resnames(maxrsd)
      character*37 bondlab(maxbondlab)
      parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
      parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
     -  (9*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
      common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),ing(MAX2D,MAX2D),
     -  ihbpair(2,MAXBONDS),ihb_pair_res(3,MAXBONDS),ihbtores(MAXBONDS),
     -  iusepair(MAXBONDS),ibond(MAXBONDS),a1(MAXBONDS),fill(IFILL2)
c     print *,'MAKEBONDLAB ilab1,ilab2,maxbondlab,ilab=',
c    -  ilab1,ilab2,maxbondlab,ilab
      lbondlab=0
      do ilab=ilab1,ilab2
        call blankout(bondlab(ilab-inc),1,37)
        if (ibondlab .eq. 2) then
c         res-aggregated plot
          irr=irrix(ilab)
          ixr1=ihb_pair_res(1,irr)
          ixr2=ihb_pair_res(2,irr)
          ir1=ixresno(ixr1)
          ir2=ixresno(ixr2)
          call lastchar(resnames(ixr1),lc1,8)
          call lastchar(resnames(ixr2),lc2,8)
          lbondlabi=11+lc1+lc2
          write (bondlab(ilab-inc)(1:lbondlabi),1002) 
     -      resnames(ixr1)(1:lc1),ir1,resnames(ixr2)(1:lc2),ir2
        else
c         Single bond plot
          ia1=ihbpair(1,index(ilab))
          ia2=ihbpair(2,index(ilab))
          ixr1=ixres(ia1)
          ixr2=ixres(ia2)
          ir1=ixresno(ixr1)
          ir2=ixresno(ixr2)
          call lastchar(resnames(ixr1),lc1,8)
          call lastchar(resnames(ixr2),lc2,8)
          lbondlabi=21+lc1+lc2
          write (bondlab(ilab-inc)(1:lbondlabi),1001) atnames(ia1)(1:4),
     -      resnames(ixr1)(1:lc1),ir1,atnames(ia2)(1:4),
     -      resnames(ixr2)(1:lc2),ir2
        end if
        if (lbondlab .lt. lbondlabi) lbondlab=lbondlabi
      end do
      return
1001  format(a,1x,a,i4,' - ',a,1x,a,i4)
1002  format(a,i4,' - ',a,i4)
      end
      subroutine plot2fun(iplot,nplot,x,y12,sd12,n,xmn,xdv,nxdv,y1mn,
     -  y1dv,ny1dv,y2mn,y2dv,ny2dv,title,ntit,remark,lremark,xlab,lxlab,
     -  y1lab,ly1lab,y2lab,ly2lab,trajfile,ltrajfile,iprt,iout,nplotdim,
     -  nosd,nsdfreq_in,iconn,iyinc,npspages,ipspage,noclose,landscape,
     -  modhgt)
      dimension x(n),y12(nplotdim,n),sd12(nplotdim,n)
      character*(*) title,remark,trajfile,xlab,y1lab,y2lab
      data ny2 /0/,ly2 /0/,iy2min /0/,y2div /0.0/,
     -  y1fac /0.0/,y2fac /0.0/,icol1 /7/,icol2 /7/
c     iyinc: increment the first index of y12 with iyinc (only for nplot=1)
c     print *,'PLOT2FUN n=',n,' nplot=',nplot,' yl1=',y1lab(1:ly1lab)
c     print *,'y2mn,y2dv,ny2dv=',y2mn,y2dv,ny2dv
c     print *,'REMARK=',remark(1:lremark)
c     print *,'XLAB  =',xlab  (1:lxlab  )
      if (n .lt. 1) return
      write (iplot,8791) '% START plot2fun: ',y1lab(1:ly1lab)
8791  format(a,a)
      if (iyinc .gt. 0 .and. nplot .gt. 1) then
        print *,'PROGRAM ERROR: iyinc > 0 and nplot > 1 in plot3fun'
        print *,'Called for ',title(1:ntit)
        return
      end if
c     do i=1,10
c       print *,'x=',x(i),' y1=',y12(1,i),' sd1=',sd12(1,i)
c     end do
      nsdfreq=nsdfreq_in
      ix0=150
      iy0=100
      ixwid=450
      if (modhgt .eq. 1 .and. ny1dv .gt. 0) then
        iyhgt=min0(420,20*ny1dv)
      else
        iyhgt=420
      end if
      if (nplot .eq. 2) then
        icol1=6
        icol2=1
      else
        icol1=9
      endif
      call psheader(iplot,title,ntit,0,0,612,792,npspages,ipspage)
      ipspage=ipspage+1
      write (iplot,1019) ipspage
      if (landscape .eq. 1) write (iplot,1001)
      write (iplot,1002) ix0+ixwid/2-50,iy0-40
      call psshow(iplot,xlab,lxlab)
      ixcent=80
      if (ntit .gt. 50) ixcent=0
      write (iplot,1002) ix0+ixcent,iy0+iyhgt+10
      call psshow(iplot,title,ntit)
      if (ltrajfile .gt. 1) then
        write (iplot,1002) ix0+ixcent,iy0+iyhgt+25
        write (iplot,1018)
        call psshow(iplot,trajfile,ltrajfile)
      end if
c     write (iplot,1002) ix0+ixwid,iy0+iyhgt+10
      write (iplot,1011)
      write (iplot,1010) ix0,iy0,ixwid,iyhgt,-ixwid
c     Find X range
      if (nxdv .gt. 0) then
        xmin=xmn
        nx=nxdv
        if (xdv .eq. 0.0) then
          xmax=x(n)
          xdiv=(xmax-xmin)/float(nx)
        else
          xdiv=xdv
          xmax=xmin+nx*xdiv
        end if
      else
        xmin=0.0
        xmax=x(n)
        call roundlim(xmax,xdiv,nx)
      end if
c     Find Y1 range
      call arminmax2(y12,n,nplot,y1min,y1max,y2min,y2max,iyinc,nplotdim)
c     print *,'y1min,y1max=',y1min,y1max,' ny1dv=',ny1dv
c     print *,'y2min,y2max=',y2min,y2max,' ny2dv=',ny2dv
      if (iyinc .eq. 1) then
c       Use 2nd column of y12 only
        if (ny2dv .gt. 0) then
          y1min=y2mn
          y1div=y2dv
          ny1=ny2dv
          y1max=y1min+y1div*ny1
        else
          ny1=10
          y1div=(y1max-y1min)/ny1
        end if
      else
        if (ny1dv .gt. 0) then
          y1min=y1mn
          y1div=y1dv
          ny1=ny1dv
          y1max=y1min+y1div*ny1
        else
          ny1=10
          y1div=(y1max-y1min)/ny1
        end if
      end if
      ly1=alog10(amax1(abs(y1min),abs(y1max)))
c     Draw ticks, write axis values
      iy1min=0
      if (nplot .eq. 2) then
        if (ny2dv .gt. 0) then
          y2min=y2mn
          y2div=y2dv
          ny2=ny2dv
          y2max=y2min+y2div*ny2
        else
          ny2=10
          y2div=(y2max-y2min)/ny2
        end if
        ly2=alog10(amax1(abs(y2min),abs(y2max)))
c       Draw ticks, write axis values
        iy1min=0
      end if
c     Draw y1 tics
      do i=iy1min,ny1
        write (iplot,1012)
        write (iplot,1002) ix0,iy0+i*iyhgt/ny1
        write (iplot,1003) 5,0
        write (iplot,1011)
      end do
      call rgbcolor(iplot,-icol1)
      write (iplot,1012)
c     Print y1 axis tick values
      do i=iy1min,ny1
        write (iplot,1002) ix0-50,iy0-5+i*iyhgt/ny1
        if (ly1 .lt. 0) then
          write (iplot,1023) y1min+i*y1div
        else if (ly1 .lt. 2) then
          write (iplot,1022) y1min+i*y1div
        else if (ly1 .lt. 4) then
          write (iplot,1007) y1min+i*y1div
        else if (ly1 .lt. 7) then
          iy1=y1min+i*y1div
          write (iplot,1005) iy1
        else
          write (iplot,1006) y1min+i*y1div
        end if
      end do
      write (iplot,1011)
      call rgbcolor(iplot,9)
      if (nplot .eq. 1) then
        iy2min=iy1min
        ny2=ny1
      end if
      do i=iy2min,ny2
        write (iplot,1012)
        write (iplot,1002) ix0+ixwid,iy0+i*iyhgt/ny2
        write (iplot,1003) -5,0
        write (iplot,1011)
      end do
      if (nplot .eq. 2) then
        call rgbcolor(iplot,-icol2)
        write (iplot,1012)
        do i=iy2min,ny2
          write (iplot,1002) ix0+ixwid+3,iy0-5+i*iyhgt/ny2
          if (ly2 .lt. 0) then
            write (iplot,1023) y2min+i*y2div
          else if (ly2 .lt. 2) then
            write (iplot,1022) y2min+i*y2div
          else if (ly2 .lt. 4) then
            write (iplot,1007) y2min+i*y2div
          else if (ly2 .lt. 7) then
            iy2=y2min+i*y2div
            write (iplot,1005) iy2
          else
            write (iplot,1006) y2min+i*y2div
          end if
        end do
        write (iplot,1011)
        call rgbcolor(iplot,9)
      end if
      if (xmin .ne. 0.0) then
c       Plot initial value too
        ixmin=0
      else
        ixmin=1
      end if
      xrange=nx*xdiv
      do i=ixmin-1,nx
        write (iplot,1012)
        write (iplot,1002) ix0+i*ixwid/nx,iy0
        write (iplot,1003) 0,5
        write (iplot,1002) ix0+i*ixwid/nx,iy0+iyhgt
        write (iplot,1003) 0,-5
        write (iplot,1011)
        write (iplot,1002) ix0-30+i*ixwid/nx,iy0-15
        if (xrange .gt. 10.01) then
          ix=xmin+i*xdiv+0.01
          write (iplot,1013) ix
        else
          xi=xmin+i*xdiv
          write (iplot,1008) xi
        end if
      end do
      write (iplot,1011)
      call rgbcolor(iplot,-icol1)
      write (iplot,1012)
      if (iconn .eq. 1) then
        write (iplot,1002) ix0+10,iy0+iyhgt-15
        write (iplot,1003) 40,0
        write (iplot,1016) 0,-3
      else
        write (iplot,1020) ix0+10,iy0+iyhgt-12,' 2 0 360 arc'
        write (iplot,1016) 0,-3
      end if
      call psshow(iplot,':',1)
      if (iyinc .eq. 0) call psshow(iplot,y1lab,ly1lab)
      if (iyinc .eq. 1) call psshow(iplot,y2lab,ly2lab)
      write (iplot,1011)
      if (lremark .gt. 0) then
c       Print remark (if any)
        write (iplot,1012)
        call rgbcolor(iplot,9)
        write (iplot,1002) ix0+10,iy0+iyhgt-30
        call psshow(iplot,remark,lremark)
        write (iplot,1011)
        call rgbcolor(iplot,-icol1)
      end if
      write (iplot,1012)
c     Plot graphs
      if (y1max .gt. y1min) y1fac=iyhgt/(y1max-y1min)
      if (y1max .eq. y1min) y1fac=0.0
      iprev=0
      if (nsdfreq .eq. 0) nsdfreq=max0(1,n/30)
      mody2=1
      if (nsdfreq .eq. 1) mody2=0
      xmaxgraph=amax1(xmax,nx*xdiv)
      do i=1,n
        if (x(i) .ge. xmin .and. x(i) .le. xmax .and.
     -      y12(iyinc+1,i) .ge. y1min .and.
     -      y12(iyinc+1,i) .le. y1max) then
          ix=ix0+ixwid*(x(i)-xmin)/(xmaxgraph-xmin)
          iy=iy0+y1fac*(y12(iyinc+1,i)-y1min)
          if (iconn .eq. 1) then
            if (iprev .eq. 0) then
              write (iplot,1002) ix,iy
              iprev=1
            else
              write (iplot,1009) ix,iy
            end if
          else
c           Just draw a circle
            write (iplot,1012)
            write (iplot,1020) ix,iy,' 2 0 360 arc'
            write (iplot,1011)
          end if
          if (nosd .eq. 0) then
c           Plot error bars
            if (mod(i,nsdfreq) .eq. 0) then
              iysd=y1fac*sd12(iyinc+1,i)
              write (iplot,1003) 0,iysd
              write (iplot,1003) 3,0
              write (iplot,1003) -6,0
              write (iplot,1003) 3,0
              write (iplot,1003) 0,-2*iysd
              write (iplot,1003) 3,0
              write (iplot,1003) -6,0
              write (iplot,1003) 3,0
              write (iplot,1003) 0,iysd
            end if
          end if
        else
          iprev=0
        end if
      end do
      write (iplot,1011)
      if (nplot .eq. 2) then
        call rgbcolor(iplot,-icol2)
        if (iconn .eq. 1) write (iplot,1015)
        write (iplot,1012)
        if (iconn .eq. 1) then
          write (iplot,1002) ix0+ixwid/2,iy0+iyhgt-15
          write (iplot,1003) 40,0
          write (iplot,1016) 0,-3
        else
          write (iplot,1020) ix0+ixwid/2,iy0+iyhgt-12,' 2 0 360 arc'
          write (iplot,1021)
          write (iplot,1011)
          write (iplot,1012)
          write (iplot,1002) ix0+ixwid/2,iy0+iyhgt-13
        end if
        call psshow(iplot,':',1)
        call psshow(iplot,y2lab,ly2lab)
        write (iplot,1011)
        write (iplot,1012)
        if (y2max .gt. y2min) y2fac=iyhgt/(y2max-y2min)
        if (y2max .eq. y2min) y2fac=0.0
        iprev=0
        do i=1,n
          if (x(i) .ge. xmin .and. x(i) .le. xmax .and.
     -        y12(2,i) .ge. y2min .and. y12(2,i) .le. y2max) then
            ix=ix0+ixwid*(x(i)-xmin)/(xmaxgraph-xmin)
            iy=iy0+y2fac*(y12(2,i)-y2min)
            if (iconn .eq. 1) then
              if (iprev .eq. 0) then
                write (iplot,1002) ix,iy
                iprev=1
              else
                write (iplot,1009) ix,iy
              end if
            else
c             Just draw a circle
              write (iplot,1012)
              write (iplot,1020) ix,iy,' 2 0 360 arc'
              write (iplot,1021)
              write (iplot,1011)
            end if
            if (nosd .eq. 0) then
c             Plot error bars
              if (mod(i,nsdfreq) .eq. mody2) then
                iysd=y2fac*sd12(2,i)
                write (iplot,1003) 0,iysd
                write (iplot,1003) 3,0
                write (iplot,1003) -6,0
                write (iplot,1003) 3,0
                write (iplot,1003) 0,-2*iysd
                write (iplot,1003) 3,0
                write (iplot,1003) -6,0
                write (iplot,1003) 3,0
                write (iplot,1003) 0,iysd
              end if
            end if
          else
            iprev=0
          end if
        end do
        write (iplot,1011)
        call rgbcolor(iplot,9)
      end if
      if (landscape .eq. 1) write (iplot,1097)
      write (iplot,1098)
      if (noclose .eq. 0) close (iplot)
      if (iprt .gt. 0) then
        do i=1,n
          write (iout,2001) i,x(i),(y12(iyinc+k,i),k=1,nplot)
        end do
      end if
      return
1001  format('/Helvetica findfont',/,'11 scalefont',/,'setfont',/,
     -  '612 0 translate',/,'90 rotate')
1002  format(i5,i6,' m')
1003  format(i5,i6,' r')
1005  format('(',i8,') show')
1006  format('(',e10.4,') show')
1007  format('(',f8.2,') show')
1008  format('(',f10.2,') show')
1009  format(i5,i6,' l')
1010  format('% Drawing of graph boundaries',/,'newpath',/,
     -  i3,1x,i3,' moveto',/,i4,' 000 rlineto',/,'000 ',i4,' rlineto',/,
     -  i5,' 000 rlineto',/,'closepath',/,'stroke')
1011  format('sk')
1012  format('np')
1013  format('(',i10,') show')
1015  format('[2] 0 setdash')
1016  format(i5,i6,' rmoveto')
1018  format('(Trajectory analyzed: ) show')
1019  format('%%Page: 1 ',i4)
1020  format(2i5,1x,a)
1021  format('f')
1022  format('(',f8.4,') show')
1023  format('(',f8.6,') show')
1097  format('-90 rotate',/,'-612 0 translate')
1098  format('showpage')
c1099  format('%%Trailer')
2001  format(i11,3e14.6)
      end
      subroutine scatterps(ips,xmin,xmax,xm,ymin,ymax,ym,x,y,ix1,iy1,n,
     -  title,lentit,noclose)
      dimension x(2,n),y(2,n)
      character*(*) title
      write (ips,1005)
      x0=0.1*xm
      y0=0.1*ym
      write (ips,1001) x0,y0
      write (ips,1002) x0,ym
      write (ips,1002) xm,ym
      write (ips,1002) xm,y0
      write (ips,1002) x0,y0
      write (ips,1000)
      write (ips,1005)
      write (ips,1001) x0,0.01*ym
      write (ips,1004) xmin
      write (ips,1001) 0.9*xm,0.01*ym
      write (ips,1004) xmax
      write (ips,1001) 0.0,0.0
      write (ips,1004) ymin
      write (ips,1001) 0.0,ym
      write (ips,1004) ymax
      write (ips,1001) x0,1.01*ym
      call psshow(ips,title,lentit)
      write (ips,1000)
      do i=1,n
        xx=x0+(xm-x0)*(x(ix1,i)-xmin)/(xmax-xmin)
        yy=y0+(ym-y0)*(y(iy1,i)-ymin)/(ymax-ymin)
        write (ips,1005)
        write (ips,1003) xx,yy,3,0,360
        write (ips,1000)
      end do
      write (ips,*) 'showpage'
      if (noclose .eq. 0) close (ips)
      return
1000  format('stroke')
1001  format(2f10.1,' moveto')
1002  format(2f10.1,' lineto')
1003  format(2f10.1,3i5,' arc')
1004  format('(',f10.2,') show')
1005  format('newpath')
      end
      subroutine plotnps(x,y,nxmax,nymax,nf,imf,iml,ifg,r0,cx,
     -  x00,xd,nx,y00,yd,ny,iprt,ntit,tit,ntit2,tit2,xlab,lenx,
     -  fclab,lfclab,imarkx,imarks,marks,iplot,ipspage,npspages,
     -  inperr,iout)
c#    MMC routine 354 lstmod: 04/05/08
c*****Postscript plot of n functions of the same variable
      dimension x(nxmax),y(nymax),imf(nf),iml(nf),ifg(nf),lfclab(nf),
     -  imarks(nxmax)
      character*(*) xlab,fclab(nf),tit,tit2
      character*1 marks(9)
c     character*80 ident
c     common /title/ ident(2)
c     nf: number of functions to be plotted
c     x: the x coordinates of the functions to be plotted
c     ifg(if): First value in x for the if-th function
c     imf(if), iml(if): Y {imf(if) - iml(if)} the value of the if-th function
c     r0,cx: x coordonate labels are transformed as r0+x(i)*cx
c     y00,yd: y scale minimum and unit, yd=0 => program finds them
c     iprt: if .ne. 0, print the function values;
c     tit: string containing the title; ntit: number of chars in tit
c     print *,'ny,iprt,ntit,ntit2=',ny,iprt,ntit,ntit2
c     print *,'nxmax,nymax,nf=',nxmax,nymax,nf
c     print *,'tit=',tit(1:ntit)
c     print *,'tit2=',tit2(1:ntit2)
c     print *,'fclabs=',(fclab(i)(1:lfclab(i)),i=1,nf)
c     print *,'PLOTNPS ipspage,npspages,iout=',ipspage,npspages,iout
      if (iplot .eq. 0) return
      if (iprt .gt. 0) then
        write (iout,5002)
        do if=1,nf
          write (iout,5005) if,x(ifg(if)),x(ifg(if)+iml(if)-imf(if)),
     -      (y(ig),ig=imf(if),iml(if))
          if (iprt .gt. 1) write (iout,5006) (x(ig),ig=imf(if),iml(if))
        end do
      end if
      ix0=100
      iy0=90
      ixwid=600
      iyhgt=480
      call psheader(iplot,tit,ntit,0,0,612,792,npspages,ipspage)
      write (iplot,1001)
      if (nf .gt. 1) call rgbrainbowcolor(iplot,-1.0)
      write (iplot,1002) ix0+300-ntit*3,iy0+iyhgt+10
      write (iplot,1004) tit(1:ntit)
      write (iplot,1002) ix0+300,iy0-40
      iytit=iy0+iyhgt-15
      if (ntit2 .gt. 0) then
        write (iplot,1002) ix0+10,iytit
        write (iplot,1004) tit2(1:ntit2)
        iytit=iytit-15
      end if
c     write (iplot,1002) ix0+10,iytit
c     write (iplot,1004) ident(1)
c     iytit=iytit-15
c     write (iplot,1002) ix0+10,iytit
c     write (iplot,1004) ident(2)
c     write (iplot,1010) ix0,iy0,ixwid,iyhgt,-ixwid
      if (lenx .gt. 0) then
        write (iplot,1002) ix0+300,iy0-30-lenx/5
        write (iplot,1004) xlab(1:lenx)
      end if
      iyhgt=iyhgt-40
      if (xd .eq. 0.0) then
        write (iout,5001)
        inperr=inperr+1
        return
      else
        xmin=x00
        xdiv=xd
        xmax=xmin+nx*xdiv
      end if
      if (yd .eq. 0.0) then
        ymin=y(1)
        ymax=ymin
        do i=1,iml(nf)
          if (y(i) .lt. ymin) ymin=y(i)
          if (y(i) .gt. ymax) ymax=y(i)
        end do
        ny=10
        ydiv=(ymax-y00)/10.0
      else
        ymin=y00
        ydiv=yd
        ymax=ymin+ny*ydiv
      end if
c     Drow graph boundary box
      write (iplot,*) 'np'
      write (iplot,1002) ix0,iy0
      write (iplot,1007) ix0,iy0+iyhgt
      write (iplot,1007) ix0+ixwid,iy0+iyhgt
      write (iplot,1007) ix0+ixwid,iy0
      write (iplot,1007) ix0,iy0
      write (iplot,*) 'sk'
c     Draw ticks, write axis values
      ly=alog10(abs(ydiv))
      do i=1,ny
        write (iplot,1008)
        write (iplot,1002) ix0,iy0+i*iyhgt/ny
        write (iplot,1003) 5,0
        if (ly .lt. 7) then
          write (iplot,1002) ix0-50,iy0-5+i*iyhgt/ny
          write (iplot,1005) ymin+i*ydiv
        else
          write (iplot,1002) ix0-60,iy0-5+i*iyhgt/ny
          write (iplot,1006) ymin+i*ydiv
        end if
        write (iplot,1002) ix0+ixwid,iy0+i*iyhgt/ny
        write (iplot,1003) -5,0
        write (iplot,1011)
        write (iplot,1002) ix0+ixwid+10,iy0-5+i*iyhgt/ny
        if (ly .lt. 7) write (iplot,1005) ymin+i*ydiv
        if (ly .ge. 7) write (iplot,1006) ymin+i*ydiv
      end do
      if (imarkx .gt. 0) then
c       Mark residues
        maxx=0
        do if=1,nf
          nxif=ifg(if)+iml(if)-imf(if)
          if (nxif .gt. maxx) maxx=nxif
        end do
c       write (6,9292) (imarks(i),i=1,120 )
c9292    format(50i1)
        do i=1,maxx
          if (imarks(i) .gt. 0) then
            ix=(x(i)-xmin)*ixwid/(xmax-xmin)
            write (iplot,1002) ix0+ix,iy0+iyhgt
            write (iplot,1004) marks(imarks(i))
          end if
        end do
      end if
      write (iplot,1011)
      do i=1,nx
        write (iplot,1008)
        write (iplot,1002) ix0+i*ixwid/nx,iy0
        write (iplot,1003) 0,5
        write (iplot,1011)
        write (iplot,1008)
        write (iplot,1002) ix0+i*ixwid/nx,iy0+iyhgt
        write (iplot,1003) 0,-5
        write (iplot,1011)
        write (iplot,1002) ix0-30+i*ixwid/nx,iy0-15
        write (iplot,1013) r0+i*cx*xdiv
      end do
      write (iplot,1011)
c     Plot graphs
      if (ymax .gt. ymin) then
        yfac=iyhgt/(ymax-ymin)
      else
        yfac=0.0
      end if
c     iyhgt=480
      iylab=iy0+iyhgt-15
      ixinc=max0(1,nx/15)
      maxfclab=0
      do if=1,nf
        if (maxfclab .lt. lfclab(if)) maxfclab=lfclab(if)
      end do
      do if=1,nf
        istarted=0
        if (nf .gt. 1)
     -    call rgbrainbowcolor(iplot,float(if-1)/float(nf-1))
        write (iplot,1016) 1+2*if
        write (iplot,1008)
        write (iplot,1002) ix0+3*ixwid/4,iylab
        write (iplot,1012) if
        write (iplot,1002) ix0+3*ixwid/4+15,iylab+4
        write (iplot,1003) max0(ixwid/12,ixwid/4-6*maxfclab-30),0
        write (iplot,1002) ix0+3*ixwid/4+15+max0(ixwid/12,
     -    ixwid/4-6*maxfclab-30),iylab
        write (iplot,1015) fclab(if)(1:lfclab(if))
        write (iplot,1011)
        iylab=iylab-15
        write (iplot,1008)
c       print *,'if,imf(if),iml(if)=',if,imf(if),iml(if)
        do ig=imf(if),iml(if)
c         write (77,*) 'if,ig,y(ig)=',if,ig,y(ig)
          if (y(ig) .ne. 0.0) then
            ix=ix0+(x(ifg(if)+ig-imf(if))-xmin)*ixwid/(xmax-xmin)
            iy=iy0+yfac*(y(ig)-ymin)
            if (istarted .eq. 0) then
              write (iplot,1002) ix,iy
              istarted=1
            else
              write (iplot,1007) ix,iy
            end if
          end if
        end do
        write (iplot,1011)
      end do
      if (nf .gt. 1) call rgbrainbowcolor(iplot,-1.0)
      write (iplot,1014)
      write (iplot,1099)
      return
1001  format('/Helvetica findfont',/,'11 scalefont',/,'setfont',/,
     -  '612 0 translate',/,'90 rotate')
1002  format(i4,i4,' moveto')
1003  format(i5,i5,' rlineto')
1004  format('(',a,') show')
1005  format('(',f10.3,') show')
1006  format('(',e10.4,') show')
1007  format(i5,i5,' lineto')
1008  format('newpath')
c1010  format('% Drawing of graph boundaries',/,'newpath',/,
c     -  i3,1x,i3,' moveto',/,i4,' 000 rlineto',/,'000 ',i4,' rlineto',/,
c     -  i5,' 000 rlineto',/,'closepath',/,'stroke')
1011  format('stroke')
1012  format('(',i2,') show')
1013  format('(',f10.2,') show')
1014  format('-90 rotate',/,'-612 0 translate')
1015  format('( : ',a,') show')
1016  format('[',i3,' 3] 0 setdash')
1099  format('showpage')
5001  format(' ***** PROGRAM ERROR: plotnps needs nonzero xdiv')
5002  format(1x,//,(1x,a))
5005  format(' Plot ',i5,' xfirst=',e12.5,' xlast=',e12.5,' y=',/,
     -  (10e13.6))
5006  format(//)
      end
      subroutine rgbrainbowcolor(iout,frac)
c#    MMC routine 355 lstmod: 12/05/03
c*****Set the PS color to frac way on the rainbow scale (0<=frac<=1)
      if (frac .lt. 0.0) then
        red=0.0
        green=0.0
        blue=0.0
      else if (frac .le. 0.5) then
        red=2.0*(0.5-frac)
        green=2.0*frac
        blue=0.0
      else
        red=0.0
        green=2.0*(0.5-(frac-0.5))
        blue=2.0*(frac-0.5)
      end if
      write (iout,1000) red,green,blue
      return
1000  format(3f5.1,' setrgbcolor')
      end
      subroutine plot2d(iplot,xy,n,nfravgt,xmn,xdv,nxdv,ymn,ydv,nydv,
     -  title,ntit,plotdesc,lplotdesc,remark,lremark,xlab,lxlab,
     -  ylab,lylab,timelab,ltimelab,iperiod,iprt,iout,npspages,ipspage,
     -  noclose,maxplot)
      dimension xy(2,maxplot)
      character*(*) title,plotdesc,remark,xlab,ylab,timelab
c     print *,'xmn,xdv,nxdv=',xmn,xdv,nxdv
c     print *,'ymn,ydv,nydv=',ymn,ydv,nydv
c     print *,'START PLOT2D iout,npspages,ipspage=',
c    - iout,npspages,ipspage
      write (iplot,*) '% START plot2d: ',ylab(1:lylab)
      if (nfravgt .eq. 0)
     -  call getint(
     -    'Number of snapshots to average in the 2D trace plots',43,
     -    1,1,nframe,nfravgt,142)
      incr=max0(1,nfravgt)
      ix0=110
      iy0=150
      ixwid=400
      iyhgt=400
      call psheader(iplot,title,ntit,0,0,612,792,npspages,ipspage)
      ipspage=ipspage+1
      write (iplot,1020) ipspage
      write (iplot,1001) ix0+ixwid/2-50,iy0-40
      call psshow(iplot,xlab,lxlab)
      write (iplot,1001) 45,iy0+iyhgt/2-50
      write (iplot,1018) 90
      call psshow(iplot,ylab,lylab)
      write (iplot,1018) -90
      ixcent=80
      if (ntit .gt. 50) ixcent=0
      write (iplot,1002) ix0+ixcent,iy0+iyhgt+10
      write (iplot,1017)
      call psshow(iplot,title,ntit)
c     write (iplot,1002) ix0+ixwid,iy0+iyhgt+10
      write (iplot,1010) ix0,iy0,ixwid,iyhgt,-ixwid
      if (lplotdesc .gt. 0) then
c       Print remark (if any)
        write (iplot,1002) ix0,iy0+iyhgt+25
        call psshow(iplot,plotdesc,lplotdesc)
      end if
      if (lremark .gt. 0) then
c       Print remark (if any)
        write (iplot,1002) ix0,iy0+iyhgt-20
        call psshow(iplot,remark,lremark)
      end if
      write (iplot,1011)
c     Find X,Y range
      call arminmax2(xy,n,2,xmin,xmax,ymin,ymax,0,2)
      if (nxdv .gt. 0) then
        xmin=xmn
        xdiv=xdv
        nx=nxdv
        xmax=xmin+nx*xdiv
      else
        nx=10
        xdiv=(xmax-xmin)/10.0
      end if
      if (nydv .gt. 0) then
        ymin=ymn
        ydiv=ydv
        ny=nydv
        ymax=ymin+ydiv*ny
      else
        ny=10
        ydiv=(ymax-ymin)/ny
      end if
      lx=alog10(amax1(abs(xmin),abs(xmax)))
c     Draw ticks, write axis values
      if (xmin .ne. 0.0) then
c       Plot initial value too
        ixmin=0
      else
        ixmin=1
      end if
c     Draw ticks, write axis values
      if (ymin .ne. 0.0) then
c       Plot initial value too
        iymin=0
      else
        iymin=1
      end if
      ly=alog10(amax1(abs(ymin),abs(ymax)))
      do i=iymin,ny
c       Left tick
        write (iplot,1012)
        write (iplot,1002) ix0,iy0+i*iyhgt/ny
        write (iplot,1003) 5,0
c       write (iplot,1011)
c       Right tick
c       write (iplot,1012)
        write (iplot,1002) ix0+ixwid,iy0+i*iyhgt/ny
        write (iplot,1003) -5,0
        write (iplot,1011)
        write (iplot,1002) ix0-60,iy0-5+i*iyhgt/ny
        if (ny .lt. 8 .or. mod(i,2) .eq. 0) then
          if (ly .lt. 7) write (iplot,1005) ymin+i*ydiv
          if (ly .ge. 7) write (iplot,1006) ymin+i*ydiv
        end if
      end do
      write (iplot,1011)
      if (xmin .ne. 0.0) then
c       Plot initial value too
        ixmin=0
      else
        ixmin=1
      end if
      do i=ixmin,nx
c       Lower tick
        write (iplot,1012)
        write (iplot,1002) ix0+i*ixwid/nx,iy0
        write (iplot,1003) 0,5
c       write (iplot,1011)
c       Upper tick
c       write (iplot,1012)
        write (iplot,1002) ix0+i*ixwid/nx,iyhgt+iy0
        write (iplot,1003) 0,-5
        write (iplot,1011)
        write (iplot,1002) ix0-30+i*ixwid/nx,iy0-15
        if (nx .lt. 8 .or. mod(i,2) .eq. 0) then
          if (lx .lt. 7) write (iplot,1005) xmin+i*xdiv
          if (lx .ge. 7) write (iplot,1006) xmin+i*xdiv
        end if
      end do
c     Plot traces
      if (xmax .gt. xmin) then
        xfac=ixwid/(xmax-xmin)
      else
        xfac=0.0
      end if
      if (ymax .gt. ymin) then
        yfac=iyhgt/(ymax-ymin)
      else
        yfac=0.0
      end if
      ixrange=xdiv*nx*xfac*0.8
      iyrange=ydiv*ny*yfac*0.8
      call rrgbcolor(iplot,1,n,1)
      newpath=1
      iprev=0
      intcol=n/100+1
      nn=max0(1,n/incr)
      xav=0.0
      yav=0.0
      iprev=0
      ixprev=ix0+xfac*(xy(1,1)-xmin)
      iyprev=iy0+yfac*(xy(2,1)-ymin)
      do i=1,n
        xav=xav+xy(1,i)
        yav=yav+xy(2,i)
        if (mod(i,incr) .eq. 0) then
          xav=xav/float(incr)
          yav=yav/float(incr)
          ix=ix0+xfac*(xav-xmin)
          iy=iy0+yfac*(yav-ymin)
          xav=0.0
          yav=0.0
          if (i .gt. 1) then
            idraw=1
            if (iperiod .eq. 1) then
c             Don't draw lines for moves under periodicity
              if (iabs(ix-ixprev) .gt. ixrange .or.
     -            iabs(iy-iyprev) .gt. iyrange ) idraw=0
            end if
            if (idraw .eq. 1) then
              if (newpath .eq. 1) write (iplot,1002) ixprev,iyprev
              if (float(i-iprev)/float(n) .ge. 0.1) then
c               Draw 2-color line
                ixx=(ix+ixprev)/2
                iyy=(iy+iyprev)/2
                write (iplot,1009) ixx,iyy
                call rrgbcolor(iplot,i,n,1)
                write (iplot,1002) ixx,iyy
                write (iplot,1009) ix,iy
              else
                write (iplot,1009) ix,iy
              end if
            end if
            if (nn .lt. 200 .or. mod(i,intcol) .eq. 0 .or.
     -          idraw .eq. 0) then
              call rrgbcolor(iplot,i,n,1)
              newpath=1
            else
              newpath=0
            end if
          end if
          iprev=i
          ixprev=ix
          iyprev=iy
        end if
      end do
      write (iplot,1011)
      call rainbowscale(iplot,ix0,ixwid,iy0-100,n,0.0,0.0,0.0,
     -  timelab,ltimelab)
      write (iplot,1098)
      if (noclose .eq. 0) close (iplot)
      if (iprt .gt. 0) write (iout,2001) (i,(xy(k,i),k=1,2),i=1,n)
      return
1001  format('/Helvetica findfont',/,'11 scalefont',/,'setfont',/,
     -  i4,i5,' moveto')
1002  format(i5,i6,' moveto')
1003  format(i5,i6,' rlineto')
1005  format('(',f10.2,') show')
1006  format('(',e10.4,') show')
1009  format(i5,i6,' lineto')
1010  format('% Drawing of graph boundaries',/,'newpath',/,
     -  i3,1x,i3,' moveto',/,i4,' 000 rlineto',/,'000 ',i4,' rlineto',/,
     -  i5,' 000 rlineto',/,'closepath',/,'stroke')
1011  format('stroke')
1012  format('newpath')
1017  format('(System: ) show')
1018  format(i5,' rotate')
1020  format('%%Page: 1 ',i4)
1098  format('-90 rotate',/,'-612 0 translate',/,'showpage')
c1099  format('%%Trailer')
2001  format(i11,2e14.6)
      end
      subroutine arminmax2(ar,n,nplot,armin1,armax1,armin2,armax2,iyinc,
     -  ndim)
      dimension ar(ndim,n)
c     if iyinc=1, use the 2nd column of ar (valid only for nplot=1)
      armin1=1.e+30
      armax1=-armin1
      do i=1,n
        if (ar(iyinc+1,i) .lt. armin1) armin1=ar(iyinc+1,i)
        if (ar(iyinc+1,i) .gt. armax1) armax1=ar(iyinc+1,i)
      end do
      if (nplot .eq. 2) then
        armin2=1.e+30
        armax2=-armin2
        do i=1,n
          if (ar(2,i) .lt. armin2) armin2=ar(2,i)
          if (ar(2,i) .gt. armax2) armax2=ar(2,i)
        end do
      end if
      return
      end
      subroutine averageres(nframe,res,ix,ires,maxframe,maxres,av,sd)
      dimension res(2,maxframe,maxres)
      real*8 sum,sum2
      sum=0.d0
      sum2=0.d0
      do iframe=1,nframe
        sum=sum+res(ix,iframe,ires)
        sum2=sum2+res(ix,iframe,ires)**2
      end do
      av=sum/nframe
      sd=dsqrt(dabs(sum2/nframe-av**2))
      return
      end
      subroutine roundlim(dmaxinp,div,ndiv)
c     For dmaxinp, find rounded div and ndiv such that div*ndiv ~ dmaxinp
      if (dmaxinp .gt. 1000000.0) then
        fac=10000.0
      else if (dmaxinp .gt. 100000.0) then
        fac=1000.0
      else if (dmaxinp .gt. 10000.0) then
        fac=100.0
      else if (dmaxinp .gt. 1000.0) then
        fac=10.0
      else
        fac=1.0
      end if
      dmax=dmaxinp/fac
      if (dmax .le. 0.05) then
        div=0.005
      else if (dmax .le. 0.1) then
        div=0.01
      else if (dmax .le. 0.2) then
        div=0.02
      else if (dmax .le. 0.5) then
        div=0.05
      else if (dmax .le. 1.0) then
        div=0.1
      else if (dmax .le. 2.0) then
        div=0.2
      else if (dmax .le. 5.0) then
        div=0.5
      else if (dmax .le. 8.0) then
        div=1.0
      else if (dmax .le. 10.0) then
        div=1.0
      else if (dmax .le. 12.0) then
        div=1.0
      else if (dmax .le. 15.0) then
        div=1.5
      else if (dmax .le. 20.0) then
        div=2.0
      else if (dmax .le. 25.0) then
        div=2.5
      else if (dmax .le. 50.0) then
        div=5.0
      else if (dmax .le. 100.0) then
        div=10.0
      else if (dmax .le. 200.0) then
        div=20.0
      else if (dmax .le. 250.0) then
        div=25.0
      else if (dmax .le. 400.0) then
        div=40.0
      else if (dmax .le. 500.0) then
        div=50.0
      else if (dmax .le. 600.0) then
        div=60.0
      else if (dmax .le. 750.0) then
        div=75.0
      else if (dmax .le. 800.0) then
        div=80.0
      else if (dmax .le. 1000.0) then
        div=100.0
      else
        div=200.0
      end if
      ndiv=(dmax+0.0001)/div
      if (dmax-ndiv*div .gt. dmax*0.01) ndiv=ndiv+1
      div=div*fac
      return
      end
      subroutine roundlimint(nmaxinp,idiv,ndiv)
c     For nmaxinp, find rounded idiv and ndiv such that idiv*ndiv ~ nmaxinp
      if (nmaxinp .gt. 1000000) then
        ifac=10000
      else if (nmaxinp .gt. 100000) then
        ifac=1000
      else if (nmaxinp .gt. 10000) then
        ifac=100
      else if (nmaxinp .gt. 1000) then
        ifac=10
      else
        ifac=1
      end if
      nmax=nmaxinp/ifac
      if (nmax .le. 10) then
        idiv=1
      else if (nmax .le. 50) then
        idiv=5
      else if (nmax .le. 100) then
        idiv=10
      else if (nmax .le. 200) then
        idiv=20
      else if (nmax .le. 250) then
        idiv=25
      else if (nmax .le. 300) then
        idiv=30
      else if (nmax .le. 400) then
        idiv=40
      else if (nmax .le. 500) then
        idiv=50
      else if (nmax .le. 600) then
        idiv=60
      else if (nmax .le. 750) then
        idiv=75
      else if (nmax .le. 800) then
        idiv=80
      else if (nmax .le. 1000) then
        idiv=100
      else
        idiv=200
      end if
c     print *,'ROUND idiv,ifac,nmaxinp=',idiv,ifac,nmaxinp
      idiv=idiv*ifac
      ndiv=(nmaxinp-1)/idiv+1
c     print *,'ROUND2 idiv,ndiv=',idiv,ndiv
      return
      end
      subroutine setdivxy(armin,armax,nxydiv,xydiv,xymin)
      if (armin .ne. 0.0) then
c      print *,'armin(inp)=',armin
       arminimp=armin
c       First, round off the minimum
        call roundlim(armin,xymindiv,nxymindiv)
        armin=xymindiv*(nxymindiv-1)
        do while (armin .gt. arminimp)
          armin=armin-xymindiv
        end do
      end if
      range=armax-armin
      call roundlim(range,xydiv,nxydiv)
      nmin=armin/xydiv
      xymin=nmin*xydiv
      return
      end
      subroutine checkbend(c,axisdir,camod,axfact,perpvec,x0,
     -  n,nup,ndown,nrun,nnear,axtol,rcirc,circ,rn,idecide,idebughx)
      real*8 c(3,n),axisdir(3),camod(3,n),perpvec(3,n),axfact(n),x0(3),
     -  circ(3),rn(3)
      real*8 rm(3),x(3),x1(3),x2(3),rr,rmin,ddistsq,ddot
      real*8 cx(3,50)
      dimension nupdown(2)
c     print *,'CHECKBEND n=',n
      call fitpoints(c,n,3,x0,rn,axfact,idebughx)
      if (idebughx .gt. 0) then
        do i=1,n
          call writepdbd(77,c(1,i),i,i,'C   ','CA ','A',1.0,0.0)
        end do
        call writepdbd(77,x0,n+1,n+1,'S   ','X0 ','B',1.0,0.0)
        if (idebughx .gt. 1) then
          idecide=6
          nup=0
          ndown=0
          nrun=0
        else
          call dvsum(x0,rn,x1)
          call writepdbd(77,x1,n+2,n+2,'S   ','RN ','B',1.0,0.0)
        end if
      end if
      if (idebughx .gt. 0)
     -  write (78,1000) (i,(c(k,i),k=1,3),(camod(k,i),k=1,3),axfact(i),
     -    (perpvec(k,i),k=1,3),i=1,n)
c     Find the shortest axis-Calpha distance
      rmin=1000.d0
      do i=1,n
        rr=ddistsq(c(1,i),camod(1,i))
        if (rr .lt. rmin) then
          rmin=rr
          imin=i
        end if
      end do
      rr=dsqrt(rmin)
c     "Pull" uniformly all the Calphas toward the axis as close as possible
      do i=1,n
        do k=1,3
          camod(k,i)=c(k,i)+rr*perpvec(k,i)
        end do
      end do
      if (idebughx .gt. 0) then
        do i=1,n
          call writepdbd(77,camod(1,i),i,i,'C   ','CA ','B',1.0,0.0)
        end do
      end if
c     Calculate the radius of the fitting circle to the pulled points
      call circfit(c,n,axisdir,circ)
      rcirc=dsqrt(ddistsq(circ,x0))
      rr=0
      do i=1,n
        rr=rr+ddistsq(circ,c(1,i))
      end do
      rcirc=dsqrt(rr/dfloat(n))
      if (idebughx .gt. 0) write (77,1002) circ,x0,rcirc
c     Find the projection of the pulled points on the fitting plane
      do i=1,n
        call dvdif(camod(1,i),x0,x1)
        rr=ddot(x1,rn)
        do k=1,3
          camod(k,i)=camod(k,i)-rr*rn(k)
        end do
      end do
      call fitpoints(camod,n,2,x0,rm,axfact,0)
      if (idebughx .gt. 0) then
        do i=1,n
          call writepdbd(77,camod(1,i),i,i,'N   ','CAP','C',1.0,0.0)
        end do
        call writepdbd(77,x0,n+1,n+1,'P   ','X0 ','B',1.0,0.0)
        call dvsum(x0,rm,x1)
        call writepdbd(77,x1,n+2,n+2,'P   ','RM ','B',1.0,0.0)
      end if
      if (idebughx .gt. 0) then
c       Check if projections are indeed in a plane
        call dvdif(camod(1,1),x0,x1)
        call dvdif(camod(1,2),x0,x2)
        call dvprd(x1,x2,x)
        do i=3,n
          call dvdif(camod(1,i),x0,x1)
          rr=ddot(x,x1)
          write (78,1001) i,(camod(k,i),k=1,3),rr
        end do
        call trnsfrd(cx,camod,3*n)
      end if
c     Get the distance vectors between the point and its projection on the line
      do i=1,n
        do k=1,3
          camod(k,i)=(camod(k,i)-x0(k))-axfact(i)*rm(k)
        end do
      end do
      if (idebughx .gt. 0) then
        do i=1,n
          call dvdif(cx(1,i),camod(1,i),x)
          call writepdbd(77,x,i,i,'O   ','CA0','D',1.0,0.0)
        end do
      end if
      nnear=0
      if (axtol .gt. 0.0) then
c       Eliminate (and count) residuea that are within tolerance of the axis
        do i=1,n
          if (sngl(ddot(camod(1,i),camod(1,i))) .le. axtol**2) then
            nnear=nnear+1
          else if (nnear .gt. 0) then
            call trnsfrd(camod(1,i-nnear),camod(1,i),3)
          end if
        end do
      end if
      call zeroiti(nupdown,0,2)
      iupdown=0
      nswitch=0
      do i=2,n-nnear
        if (ddot(camod(1,i-1),camod(1,i)) .lt. 0.d0) then
          nswitch=nswitch+1
          iupdown=1-iupdown
        end if
        nupdown(iupdown+1)=nupdown(iupdown+1)+1
      end do
      nrun=nswitch+1
      nup=nupdown(1)
      ndown=nupdown(2)
      call runtest(nup,ndown,nrun,idecide)
      return
1000  format(i3,' c=',3f8.3,' camod=',3f8.3,' axfac=',f8.3,/,
     -  ' perp=',3f8.4)
1001  format(i3,' camod=',3f8.3,' plane check (->0)=',f10.6)
1002  format(' CHECKBEND circ=',3f10.5,' x0=',3f10.5,' rcirc=',f10.5)
      end
      subroutine runtest(nup,ndown,nrun,idecide)
c*****Computes test for correlation, type of correlation
      dimension nmncrt(20,20),nmxcrt(20,20)
c     Minimum critical values for correlation test:
      data nmncrt/20*0,
     -  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2,
     -  0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3,
     -  0, 0, 0, 0, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4,
     -  0, 0, 0, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5,
     -  0, 0, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 6, 6,
     -  0, 0, 2, 2, 3, 3, 3, 4, 4, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6,
     -  0, 0, 2, 3, 3, 3, 4, 4, 5, 5, 5, 6, 6, 6, 6, 6, 7, 7, 7, 7,
     -  0, 0, 2, 3, 3, 4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8,
     -  0, 0, 2, 3, 3, 4, 5, 5, 5, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 9,
     -  0, 0, 2, 3, 4, 4, 5, 5, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 9,
     -  0, 2, 2, 3, 4, 4, 5, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9,10,10,
     -  0, 2, 2, 3, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 9,10,10,10,10,
     -  0, 2, 2, 3, 4, 5, 5, 6, 7, 7, 8, 8, 9, 9, 9,10,10,10,11,11,
     -  0, 2, 3, 3, 4, 5, 6, 6, 7, 7, 8, 8, 9, 9,10,10,11,11,11,12,
     -  0, 2, 3, 4, 4, 5, 6, 6, 7, 8, 8, 9, 9,10,10,11,11,11,12,12,
     -  0, 2, 3, 4, 4, 5, 6, 7, 7, 8, 9, 9,10,10,11,11,11,12,12,13,
     -  0, 2, 3, 4, 5, 5, 6, 7, 8, 8, 9, 9,10,10,11,11,12,12,13,13,
     -  0, 2, 3, 4, 5, 6, 6, 7, 8, 8, 9,10,10,11,11,12,12,13,13,13,
     -  0, 2, 3, 4, 5, 6, 6, 7, 8, 9, 9,10,10,11,12,12,13,13,13,14/
c     Maximum critical values for correlation test:
      data nmxcrt/60*0,
     -  0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     -  0, 0, 0, 9,10,10,11,11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     -  0, 0, 0, 9,10,11,12,12,13,13,13,13, 0, 0, 0, 0, 0, 0, 0, 0,
     -  0, 0, 0, 0,11,12,12,12,14,14,14,14,15,15,15, 0, 0, 0, 0, 0,
     -  0, 0, 0, 0,11,12,13,13,14,15,15,16,16,16,16,17,17,17,17,17,
     -  0, 0, 0, 0, 0,13,14,14,15,16,16,16,17,17,18,18,18,18,18,18,
     -  0, 0, 0, 0, 0,13,14,15,16,16,17,17,18,18,18,19,19,19,20,20,
     -  0, 0, 0, 0, 0,13,14,15,16,17,17,18,19,19,19,20,20,20,21,21,
     -  0, 0, 0, 0, 0,13,14,16,16,17,18,19,19,20,20,21,21,21,22,22,
     -  0, 0, 0, 0, 0, 0,15,16,17,18,19,19,20,20,21,21,22,22,23,23,
     -  0, 0, 0, 0, 0, 0,15,16,17,18,19,20,20,21,22,23,23,23,23,24,
     -  0, 0, 0, 0, 0, 0,15,16,18,18,19,20,21,22,22,23,23,24,24,25,
     -  0, 0, 0, 0, 0, 0, 0,17,18,19,29,21,21,22,23,23,24,25,25,25,
     -  0, 0, 0, 0, 0, 0, 0,17,18,19,20,21,22,23,23,24,25,25,26,26,
     -  0, 0, 0, 0, 0, 0, 0,17,18,19,20,21,22,23,24,25,25,26,26,27,
     -  0, 0, 0, 0, 0, 0, 0,17,18,29,21,22,23,23,24,25,26,26,27,27,
     -  0, 0, 0, 0, 0, 0, 0,17,18,20,21,22,23,25,25,26,26,27,27,28/
      if (ndown .gt. 20 .or. nup .gt. 20) then
c       High
        idecide=5
      else if (ndown .eq. 0 .or. nup .eq. 0) then
c       Low
        idecide=1
      else if (nmxcrt(ndown,nup) .eq. 0 .or.
     -           nmncrt(ndown,nup) .eq. 0) then
c       Low
        idecide=1
      else if (nrun .lt. nmncrt(ndown,nup)) then
c       Correlated
        idecide=2
      else if (nrun .gt. nmxcrt(ndown,nup)) then
c       Correlated
        idecide=4
      else
c       Uncorrelated
        idecide=3
      end if
      return
      end
      subroutine fitpoints(c,n,ndim,c0,dir,axfact,idebughx)
      real*8 c(3,n),c0(3),dir(3),axfact(n)
      real*8 dd(3),sum,ddot
      real*8 rr(3,3),diag(3),offdiag(3)
      data kcol /0/,kmin /0/,kmax /0/
c     For n points in c, find the mean (c0) and the direction of the normal
c     to the best fitting plane (ndim=3) or the direction of the best fitting
c     line (ndim=2)
c     print *,'FITPOINTS n=',n
      if (ndim .ne. 2 .and. ndim .ne. 3) then
        print *,'PROGRAM ERROR: invalid ndim in fitpoints=',ndim
        stop
      end if
      call zeroitd(c0,3)
      do i=1,n
        do k=1,3
          c0(k)=c0(k)+c(k,i)
        end do
      end do
      do k=1,3
        c0(k)=c0(k)/dfloat(n)
      end do
      if (idebughx .eq. 2) return
      do k=1,3
        do l=k,3
          sum=0.d0
          do i=1,n
            sum=sum+(c(k,i)-c0(k))*(c(l,i)-c0(l))
          end do
          rr(k,l)=sum
          rr(l,k)=sum
        end do
      end do
      if (idebughx .gt. 0) write (77,1000) 'Matrix',rr
c     Find the eigenvectors a and eigenvalues mu of rr
      call dtred2(rr,3,3,diag,offdiag)
      call dtqli(diag,offdiag,3,3,rr,ierr)
      if (ierr .gt. 0) then
        write (6,1004)
        stop
      end if
      if (idebughx .gt. 0) write (77,1000) 'Eigenvectors',rr
      if (idebughx .gt. 0) then
        write (77,1000) 'diag',diag
        write (77,1000) 'offdiag',offdiag
      end if
c     The columns of the matrix rr are the eigenvectors
c     The eigenvalues are in diag
      emax=0.0
      emin=1000.0
      nz=0
      do k=1,3
        if (dabs(diag(k)) .lt. 0.005d0) then
          nz=nz+1
        else
          if (diag(k) .gt. emax) then
            emax=diag(k)
            kmax=k
          end if
          if (diag(k) .lt. emin) then
            emin=diag(k)
            kmin=k
          end if
        end if
      end do
      if (ndim .eq. 2 .and. nz .eq. 0) write (6,1001) diag
      if (ndim .eq. 3 .and. nz .gt. 0) print *,'WARNING: 3D dataset ',
     -  'appears to be in a plane'
      if (ndim .eq. 2) kcol=kmax
      if (ndim .eq. 3) kcol=kmin
      do k=1,3
        dir(k)=rr(k,kcol)
      end do
      do i=1,n
        call dvdif(c(1,i),c0,dd)
        axfact(i)=ddot(dir,dd)
      end do
      return
1000  format(1x,a,'=',/,(3f15.5))
1001  format(' ERROR: no zero eigenvalue found when fitting points ',
     -  'in a plane',/,8x,'diag=',3f10.5)
1004  format(' Calculation aborted due to diagonalization failure')
      end
      subroutine findbestrep(iw0,icl,iclsub,nframe,mask,irdavmn,irdmxmn,
     -  label,llabel,iout_term,mx2d)
      dimension mask(mx2d)
      character*(*) label
      parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
      parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
     -  (4*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
      common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),ing(MAX2D,MAX2D),
     -  ihbpair(2,MAXBONDS),a1(MAXBONDS),a2(MAXBONDS),fill(IFILL2)
      rdsmn=1.0e+20
      rdmn=1.0e+20
      nmem=0
      rmsdmax=0.0
      nframeused=0
      irdmxmn=0
      iravxmn=0
      do ix=1,nframe
        if (mask(ix) .gt. 0) nframeused=nframeused+1
      end do
      nsing=0
      if (icl .gt. 0) then
        if (nframeused .gt. 1) then
          if (iclsub .eq. 0) write (6,1005) icl,nframeused
          if (iclsub .gt. 0) write (6,1002) icl,iclsub,nframeused
        end if
      else
        write (6,*)
      end if
      do ix=1,nframe
        nmem0=nmem
        if (mask(ix) .gt. 0) then
          nmem=nmem+1
          a1(ix)=0.0
          a2(ix)=0.0
          do iy=1,ix-1
            if (mask(iy) .gt. 0) then
              a1(ix)=a1(ix)+rmsd2d(iy,ix)**2
              if (rmsd2d(iy,ix) .gt. a2(ix)) a2(ix)=rmsd2d(iy,ix)
              if (rmsd2d(iy,ix) .ge. rmsdmax) then
                rmsdmax=rmsd2d(iy,ix)
                ix1=ix
                ix2=iy
              end if
            end if
          end do
          do iy=ix+1,nframe
            if (mask(iy) .gt. 0) then
              a1(ix)=a1(ix)+rmsd2d(ix,iy)**2
              if (rmsd2d(ix,iy) .gt. a2(ix)) a2(ix)=rmsd2d(ix,iy)
            end if
          end do
          if (a1(ix) .lt. rdsmn) then
            rdsmn=a1(ix)
            irdavmn=ix
          end if
          if (a2(ix) .lt. rdmn) then
            rdmn=a2(ix)
            irdmxmn=ix
          end if
        end  if
        if (nmem .gt. nmem0) a1(ix)=a1(ix)/float(nmem-nmem0)
      end do
      if (nmem .gt. 1) then
        write (iout_term,1010) irdmxmn,label(1:llabel),rdmn,
     -    label(1:llabel),rmsdmax,ix1,ix2,label(1:llabel),
     -    label(1:llabel),ix1,irdmxmn,rmsd2d(ix1,irdmxmn),
     -    label(1:llabel),ix2,irdmxmn,rmsd2d(ix2,irdmxmn)
        write (iw0,1010) irdmxmn,label(1:llabel),rdmn,
     -    label(1:llabel),rmsdmax,ix1,ix2,label(1:llabel),
     -    label(1:llabel),ix1,irdmxmn,rmsd2d(ix1,irdmxmn),
     -    label(1:llabel),ix2,irdmxmn,rmsd2d(ix2,irdmxmn)
        if (label(1:4) .eq. 'RMSD') then
          write (iout_term,1011) irdavmn,rdsmn/nframeused,ix1,irdavmn,
     -      rmsd2d(ix1,irdavmn),ix2,irdavmn,rmsd2d(ix2,irdavmn)
          write (iw0,1011) irdavmn,rdsmn/nframeused,ix1,irdavmn,
     -      rmsd2d(ix1,irdavmn),ix2,irdavmn,rmsd2d(ix2,irdavmn)
        end if
        if (irdavmn .ne. irdmxmn) then
          write (iout_term,1001) label(1:llabel),irdavmn,irdmxmn,
     -      rmsd2d(irdavmn,irdmxmn)
          write (iw0,1001) label(1:llabel),irdavmn,irdmxmn,
     -      rmsd2d(irdavmn,irdmxmn)
        end if
      end if
      if (label(1:4) .eq. 'RMSD') then
        write (iw0,1003)
        do ix=1,nframe
          if (mask(ix) .gt. 0) then
            write (iw0,1004) ix,sqrt(a1(ix)),a2(ix)
          end if
        end do
      end if
      return
1001  format(1x,a,' between the two center estimates',
     -  ' (',i5,',',i5,')=',f8.2)
1002  format(/,' Cluster #',i4,' Subcluster #',i3,
     -  ' Number of members=',i5)
1003  format(/,' RMSD average and maximum (over other cluster members)',
     -  ' for each frame analyzed')
1004  format(' Frame #',i4,' sqrt(<MSD>)=',f12.3,' Maximum RMSD=',f8.2)
1005  format(/,' Cluster #',i4,' Number of members=',i5)
1011  format(' Cluster center based on the lowest mean MSD:    #',i5,
     -  ' (<MSD>=',f8.2,')',/
     -  ' Cluster radius based on the lowest mean MSD:   ',/,
     -  16x,'RMSD(',i5,',',i5,')=',f8.2,'  RMSD(',i5,',',i5,')=',f8.2)
1010  format(' Cluster center: #',i5,' - based on the lowest maximum ',
     -  a,' (',f8.2,')',/
     -  ' Largest ',a,' (cluster diameter) is ',f8.2,
     -  ' between #',i5,' & #',i5,/,
     -  ' Cluster radius based on the lowest maximum ',a,':',/,
     -  1x,a,'(',i5,',',i5,')=',f8.2,2x,a,'(',i5,',',i5,')=',f8.2)
      end
      subroutine findbestcorrep(iout,ifcl,ilcl,index,mx2d)
      dimension index(mx2d)
      parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
      parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
     -  (4*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
      common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),ing(MAX2D,MAX2D),
     -  ihbpair(2,MAXBONDS),a1(MAXBONDS),a2(MAXBONDS),fill(IFILL2)
      ravmax=100000.0
      ixavmax=0
      rminmax=100000.0
      ixminmax=0
      nmem=ilcl-ifcl+1
      rxymax=0.0
      ixmax=0.
      iymax=0.
      do ixx=ifcl,ilcl
        ix=index(ixx)
        r2av=0.0
        r2max=0.0
        do iyy=ifcl,ilcl
          if (iyy .ne. ixx) then
            iy=index(iyy)
            r2=rmsd2d(ix,iy)
            r2av=r2av+r2
            if (r2 .gt. r2max) r2max=r2
            if (r2 .gt. rxymax) then
              rxymax=r2
              ixmax=ix
              iymax=iy
            end if
          end if
        end do
        if (r2max .lt. rminmax) then
          rminmax=r2max
          ixminmax=ix
        end if
        r2av=r2av/nmem
        if (r2av .lt. ravmax) then
          ravmax=r2av
          ixavmax=ix
        end if
      end do
      write (iout,1001) 'maximum',ixminmax,'maximum',rminmax
      write (iout,1001) 'average',ixavmax,'average',ravmax
      write (iout,1002) rxymax,ixmax,iymax
      write (iout,1003) ixminmax,ixavmax,rmsd2d(ixavmax,ixminmax)
      write (iout,1004) 
      return
1001  format(' Cluster center based on the lowest ',a,' distance: ',i5,
     -  1x,a,' distance=',f8.3)
1002  format(' Cluster diameter=',f8.2,' (distance between ',i6,
     -  ' and ',i6,')')
1003  format(' Distance between the two center estimates',
     -  ' (',i5,',',i5,') =',f8.2)
1004  format(' NOTE: numbers above refer to the unfiltered bond number')
      end
      subroutine plot2drmsd(nrep,iw0,iw1,xtraj,maxn,title,title2,
     -  ltitle2,trajfile,ltrajfile,trajfile2,ltrajfile2,xlab,lxlab,
     -  interval,interval2,ncolcode,maxcolcode,iedit,noopt2d,
     -  limresrange,normsavg,rmsdmin,rmsdmax,absdevmin,absdevmax,
     -  rmsdmn,rmsdmx,indexa,indexr,ixshuffle,ixshuffleref,ilastclx,
     -  nclx,ilastcly,ncly,ym_2d,itemp1,itemp2,temp,matplotonly,isymm,
     -  noplotdist,iskip2dplot,isortmat,noclose,ipspage,ifindbest)
      character*80 title
      character*(*) title2
      character*200 trajfile,trajfile2
      character*(*) xlab
      dimension xtraj(maxn),indexa(maxn),indexr(maxn),ixshuffle(maxn),
     -  ixshuffleref(maxn),ilastcly(maxn),ilastclx(maxn),
     -  itemp1(maxn),itemp2(maxn),temp(maxn)
      parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
      parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
     -  (4*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
      common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),ing(MAX2D,MAX2D),
     -  ihbpair(2,MAXBONDS),a1(MAXBONDS),a2(MAXBONDS),fill(IFILL2)
      parameter (MAXFRAMES=50000,MAXCOPY=600)
      common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
     -  increment,increment2,res(2,MAXFRAMES,MAXCOPY),
     -  x0(MAXCOPY),y0(MAXCOPY),nxselres,ixselres(MAXCOPY)
      dimension kc(1,1)
      real*8 dc(1,1)
      dimension nrmsd(100),xrmsd(100),refrmsd(100)
      character*4 yclab(1)
      character*80 title2add
      data nyclab /1/,lyclab /1/
c     print *,'PLOT2DRMSD isymm,nframe,nframeref=',
c    -                   isymm,nframe,nframeref
c     print *,'PLOT2DRMSD noclose,matplotonly=',noclose,matplotonly
c     print *,'PLOT2DRMSD ioclose,matplotonly=',noclose,matplotonly
      if (ifindbest .gt. 0) then
        call indexit(indexa,1,nframe,0)
        write (6,1015)
        call findbestrep(iw0,0,0,nframe,indexa,irdavmn,irdmxmn,'RMSD',4,
     -    6,MAX2D)
      end if
      rcmax=0.0
      rcmin=100000.0
      do ix=1,nframe
        if (isymm .eq. 1) then
          do iy=ix+1,nframe
            if (rmsd2d(ix,iy) .gt. rcmax) rcmax=rmsd2d(ix,iy)
            if (rmsd2d(ix,iy) .lt. rcmin) rcmin=rmsd2d(ix,iy)
          end do
          rmsd2d(ix,ix)=0.0
        else
          do iy=1,nframeref
            if (rmsd2d(ix,iy) .gt. rcmax) rcmax=rmsd2d(ix,iy)
            if (rmsd2d(ix,iy) .lt. rcmin) rcmin=rmsd2d(ix,iy)
          end do
        end if
      end do
      write (6,1011) 'RMSD',rcmin,rcmax
      write (iw0,1011) 'RMSD',rcmin,rcmax
      if (rcmin .eq. 0.0) then
        write (6,1017) 'minimum','some'
        write (iw0,1017) 'minimum','some'
      end if
      if (rcmax .eq. 0.0) then
        write (6,1017) 'maximum','all'
        write (iw0,1017) 'maximum','all'
        print *,'Exiting plotting'
        return
      end if
      if (absdevmin .lt. 100000.0) then
        write (6,1011) 'absolute deviation',absdevmin,absdevmax
        write (iw0,1011) 'absolute deviation',absdevmin,absdevmax
      end if
      if (isymm .eq. 1) then
        rmsdmn=0.0
      else if (rmsdmin .gt. 0.0) then
        write (6,1010) 'minimum',rmsdmin
        write (iw0,1010) 'minimum',rmsdmin
        rmsdmn=rmsdmin
      else
        rmsdmn=rcmin
      end if
      if (rmsdmax .ne. 0.0) then
        write (6,1010) 'maximum',rmsdmax
        write (iw0,1010) 'maximum',rmsdmax
        rmsdmx=rmsdmax
      else
        rmsdmx=rcmax
      end if
      nframetop=max0(nframe,nframeref)
      if (iskip2dplot .eq. 0) then
        inc=max0(1,500/nframetop)
        scalefac=amin1(1.0,500.0/float(nframetop))
        iyrange=scalefac*(nframeref*inc)+20
        iytop=ym_2d*0.83
        iydel=max0(150,iytop-iyrange)
        iymax=iydel+iyrange
        write (iw1,1005) 25,iymax
        if (ltrajfile2 .eq. 0) then
          write (iw1,1003) 'RMSD map',trajfile(1:ltrajfile),' ',interval
        else
          write (iw1,1003)
     -      'and',trajfile2(1:ltrajfile2),' (Y axis)',interval2
          iymax=iymax+15
          write (iw1,1005) 25,iymax
          write (iw1,1003)
     -      'Cross RMSD map',trajfile(1:ltrajfile),' (X axis)',interval
          nframe2=nframeref
        end if
        iouttemp=91
        call contractmat(rmsd2d,nframe,nframeref,nframeplot,
     -    nframerefplot,navg,ixshuffle,ixshuffleref,itemp1,itemp2,
     -    temp,isortmat,iouttemp,MAX2D)
        iymax=iymax+15
        write (iw1,1005) 25,iymax
        write (title2add,1019) navg
        ladd=30
        if (ltitle2 .gt. 0) then
          title2add(1:ladd+ltitle2)=title2(1:ltitle2)//' '//
     -      title2add(1:ladd)
          ladd=ladd+ltitle2
        end if
        call psshow(iw1,title2add(1:ladd),ladd)
        iymax=iymax+15
        if (limresrange .gt. 0) then
          call psshow(iw1,
     -      'RMSD was calculated on a limited residue set',44)
          iymax=iymax+15
        end if
        if (isortmat .eq. 1 .and. navg .gt. 1) then
          call indexit(ixshuffle,1,nframe,0)
          call indexit(ixshuffleref,1,nframeref,0)
        end if
        call plotmat(iw1,kc,rmsd2d,dc,nframeplot,nframerefplot,0,0,0,0,
     -    navg,nrep,40,iydel,00,iytop,rmsdmn,rmsdmx,ncolcode,maxcolcode,
     -    ixdelsh,iydelsh,inc,scalefac,indexr,ixshuffle,ixshuffleref,
     -    title,0,' ',0,xlab,lxlab,xtraj,yclab,nyclab,lyclab,igl,1,
     -    MAX2D,1,MAX2D,MAX2D,ipspage,0)
        if (navg .gt. 1) then
          rewind iouttemp
          read (iouttemp,end=999)
     -      ((rmsd2d(i,j),i=1,nframe),j=1,nframeref)
          close (iouttemp,status='delete')
        end if
        if (nframe .ge. 50) iydel=iydel-50
        if (nframe .lt. 50) iydel=iydel-40
        ixcent=amax1(0.0,(scalefac*(nframe*inc)-80*ncolcode)/2)
        call colcodeminmax(iw1,20+ixcent,-iydel,nrep,ncolcode,
     -    maxcolcode,rmsdmn,rmsdmx)
        iydel=iydel-40
        write (iw1,1005) 50,iydel
        write (iw1,1002) rmsdmn,rmsdmx
        write (iw1,1005) 50+250,iydel
        if (noopt2d .eq. 0) then
          if (iedit .eq. 0) write (iw1,1009) 'all atoms'
          if (iedit .eq. 1) write (iw1,1009) 'a limited set of atoms'
        else
          write (iw1,1016)
        end if
c       Draw lines in the matrix delineating the clusters
        if (max0(nclx,ncly) .le. 10 .and. min0(nclx,ncly) .gt. 0) then
          write (iw1,1018)
c          print *,'NCLX,NCLY=',nclx,ncly,' NFRAME=',nframe
c          write (6,9876) (ilastclx(i),i=1,nclx)
c9876      format('ILASTCLX:',/,(20i4))
          if (max0(nclx,ncly) .gt. 1 .and. scalefac .ne. 1.0)
     -      write (iw1,1013) scalefac,scalefac
          call rgbcolor(iw1,9)
          write (iw1,1012) 4
          lw=4
          if (max0(nclx,ncly) .gt. 10) lw=2
          write (iw1,*) 'np'
          ixdell=ixdelsh
          if (nframeplot*scalefac .lt. 550)
     -      ixdell=ixdelsh+40/scalefac
          do ic=1,nclx
            if (ilastclx(ic) .ne. nframe) then
              write (iw1,1005) ixdell+ilastclx(ic)*inc,iydelsh
              write (iw1,1006) ixdell+ilastclx(ic)*inc,
     -          iydelsh+nframeref*inc
            end if
          end do
          do ic=1,ncly
            if (ilastcly(ic) .ne. nframe) then
              write (iw1,1005) ixdell,iydelsh+ilastcly(ic)*inc
              write (iw1,1006) ixdell+nframe*inc,
     -          iydelsh+ilastcly(ic)*inc
            end if
          end do
          write (iw1,*) 'sk'
          if (max0(nclx,ncly) .gt. 1 .and. scalefac .ne. 1.0)
     -        write (iw1,1013) 1.0/scalefac,1.0/scalefac
        else
          write (6,1004)
        end if
        write (iw1,*) 'showpage'
        if (matplotonly .eq. 1) then
          if (noclose .eq. 0) close (iw1)
          return
        end if
      end if
      if (normsavg .eq. 0 .or. nframe .lt. 25) then
c       2D RMSD map, dont calculate normalization
        write (iw0,1000)
        do il=1,nframe-1
          rmssum=0.0
          rmssum2=0.0
          rmssum4=0.0
          do i=1,nframe-il
            rmssum=rmssum+rmsd2d(i,i+il)
            rmssum2=rmssum2+rmsd2d(i,i+il)**2
            rmssum4=rmssum4+rmsd2d(i,i+il)**4
          end do
          res(1,il,8)=rmssum/(nframe-il)
          res(2,il,8)=rmssum2/(nframe-il)
          res(1,il,9)=sqrt(abs(rmssum2/(nframe-il)-res(1,il,8)**2))
          res(2,il,9)=sqrt(abs(rmssum4/(nframe-il)-res(2,il,8)**2))
          write (iw0,1001) il,((res(k,il,ii),ii=8,9),k=1,2)
        end do
        if (noplotdist .eq. 0) then
          call arminmax2(res(1,1,8),nframe-1,2,armin1,armax1,armin2,
     -      armax2,0,2)
          call roundlim(armax1,y1div,ny1div)
          call roundlim(armax2,y2div,ny2div)
          call plot2fun(iw1,2,xtraj,res(1,1,8),res(1,1,9),nframe-1,
     -      0.0,0.0,0,0.0,y1div,ny1div,0.0,y2div,ny2div,title,80,' ',1,
     -      xlab,lxlab,'2D-map averaged RMSD',20,
     -      '2D-map averaged MSD',19,trajfile,ltrajfile,0,6,2,0,0,1,0,0,
     -      ipspage,1,1,0)
        end if
      end if
      call zeroiti(nrmsd,0,100)
      if (normsavg .eq. 0 .and. nframe .ge. 25) then
        rcmaxx=rcmax**2
        ircmax=rcmax**2
        rcmax=ircmax+1
        if (nframe .ge. 100) then
          rcdiv=rcmaxx/99.9999
        else if (nframe .ge. 50) then
          rcdiv=rcmaxx/49.9999
        else
          rcdiv=rcmaxx/24.9999
        end if
        do il=1,nframe-1
          do i=1,nframe-il
            ix=rmsd2d(i,i+il)**2/rcdiv+1
            if (ix .gt.100) ix=100
            nrmsd(ix)=nrmsd(ix)+1
          end do
        end do
        pmax1=0.0
        pmax2=0.0
c       dcoef=rcmax/sqrt(float(nframe))
        dcoef=rcmaxx/float(nframe)
        do ix=1,100
          refrmsd(ix)=(nframe-(ix*rcdiv)/dcoef)/
     -      float((nframe*(nframe-1))/2)
        end do
        write (iw0,1007) ' '
        do ix=1,100
          res(1,ix,9)=float(nrmsd(ix))/float((nframe*(nframe-1))/2)
          if (pmax1 .lt. res(1,ix,9)) pmax1=res(1,ix,9)
          xrmsd(ix)=ix*rcdiv
          if (ix .gt. 98) then
            res(2,ix,9)=res(2,98,9)
          else
            res(2,ix,9)=res(1,ix,9)/refrmsd(ix)
          end if
          if (pmax2 .lt. res(2,ix,9)) pmax2=res(2,ix,9)
          write (iw0,1008) ix,xrmsd(ix),res(1,ix,9),' ',res(2,ix,9)
        end do
        if (noplotdist .eq. 0) then
          call roundlim(pmax1,y1div,ny1div)
          call roundlim(pmax2,y2div,ny2div)
          call plot2fun(iw1,2,xrmsd,res(1,1,9),res(1,1,9),100,0.0,
     -      rcmax/10.,10,0.0,y1div,ny1div,0.0,y2div,ny2div,title,80,
     -      ' ',1,'MSD',3,' MSD distribution',17,
     -      ' MSD/Reference ideal distribution',33,trajfile,ltrajfile,
     -      0,6,2,1,0,1,0,0,ipspage,1,1,0)
        end if
      else if (normsavg .eq. 1) then
c       Cross RMSD map
        ircmax=rcmax+1.0
        rcmax=ircmax
        rcdiv=rcmax/99.9999
        do i1=1,nframe
          do i2=1,nframeref
            ix=rmsd2d(i2,i1)/rcdiv+1
            if (ix .gt.100) ix=100
            nrmsd(ix)=nrmsd(ix)+1
          end do
        end do
        pmax1=0.0
        write (iw0,1007) ' R'
        do ix=1,100
          res(1,ix,9)=float(nrmsd(ix))/float(nframe*nframeref)
          if (pmax1 .lt. res(1,ix,9)) pmax1=res(1,ix,9)
          xrmsd(ix)=ix*rcdiv
          write (iw0,1008) ix,xrmsd(ix),res(1,ix,9)
        end do
        call roundlim(pmax1,y1div,ny1div)
        call plot2fun(iw1,1,xrmsd,res(1,1,9),res(1,1,9),100,0.0,
     -    rcmax/10.,10,0.0,y1div,ny1div,0.0,y2div,ny2div,title,80,' ',1,
     -    'RMSD',4,'RMSD distribution',17,' ',1,trajfile,ltrajfile,
     -    0,6,2,1,0,1,0,0,ipspage,1,1,0)
      end if
      if (noclose .eq. 0) close (iw1)
      return
999   write (6,1014)
      stop
      return
1000  format(/,' Average RMSD & MSD as a function of time (frame ',
     -  '# difference) over the 2D map:',/)
1001  format(' RMSD(',i5,')=',f10.5,' SD=',f10.5,
     -  ' MSD=',f10.5,' SD=',f10.5)
1002  format('( Range of the RMSD scale:',f8.3,'  -',f8.3,') show')
1003  format('(',a,' of trajectory file ',a,a,'. Frame interval=',i5,
     -  ') show')
1004  format(' NOTE: There are too many clusters for drawing ',
     -  'cluster-delineating lines')
1005  format(2i5,' m')
1006  format(2i5,' l')
1007  format(/,'Distribution of the',a,'MSD values:',/)
1008  format(i4,' p(RMSD=',f9.2,')=',f8.6,a,'p(refRMSD)=',f10.5)
1009  format('( Overlay is based on ',a,') show')
1010  format(' RMSD ',a,' used for plotting=',f10.2,' A')
1011  format(' Range of ',a,' values: [',f12.5,',',f12.5,'] A')
1012  format(i2,' lw')
1013  format(f10.6,f10.6,' scale')
1014  format(' PROGRAM ERROR: could not restore original matrix from ',
     -  'the temporary file rij.tmp')
1015  format(' Details of the structure ensemble as a single cluster:')
1016  format('( RMSD was calculated without overlay) show')
1017  format(' RMSD ',a,' is zero - ',a,' items are identical')
1018  format('% Draw cluster separator lines')
1019  format('Number of frames averaged=',i2)
      end
      subroutine plot_atomdist_sd(n,line,index,inamcol1,inamcol2,
     -  irescol1,irescol2,iresncol1,iresncol2,ldist,ndist,nframe,indexa,
     -  ixshuffle,xtraj,title,trajfile,ltrajfile,isdtyp,iw0,iw1,igl,
     -  ipspage,maxrec)
      dimension ldist(ndist),index(n),indexa(ndist),
     -  ixshuffle(ndist),xtraj(ndist)
      character*132 line(maxrec)
      character*80 title
      character*(*) trajfile
      parameter (MAXPHI=400,MAXRCORR=3500)
      parameter (IFILL9=MAXPHI*MAXPHI*MAXPHI-
     -  (2*MAXRCORR*MAXRCORR+11*MAXRCORR))
      real*8 trajdist,cav,cavs,rr,dscprod
      common /nnwork/ trajdist(MAXRCORR,MAXRCORR),cav(3,MAXRCORR),
     -  cavsng(3,MAXRCORR),cavs(MAXRCORR),ifill(IFILL9)
      common /colorinfo/ ncolcode,maxcolcode
      dimension kc(1,1),rc(1,1),lnormtyp(4)
      character*4 yclab(1)
      character*17 normtyp(4)
      data normtyp /' ','/RMSD(i)*RMSD(j) ','/r(i,j) ','*r(i,j) '/,
     -  lnormtyp /1,17,8,8/
c     print *,'PLOT ATOMDIST_SD nframe,ndist=',nframe,ndist
      data nyclab /1/,lyclab /1/
      rcmax=0.0
      rcmin=100000.0
      rmsdmax=0.0
      rmsdmin=100000.0
      do ia=1,ndist
        xtraj(ia)=ia
        do k=1,3
          cav(k,ia)=cav(k,ia)/dfloat(nframe)
          cavsng(k,ia)=cav(k,ia)
        end do
        rr=dscprod(cav(1,ia),cav(1,ia))
        cavs(ia)=dsqrt(cavs(ia)/dfloat(nframe)-rr)
        if (rmsdmax .lt. cavs(ia)) rmsdmax=cavs(ia)
        if (rmsdmin .gt. cavs(ia)) rmsdmin=cavs(ia)
        do ja=1,ia-1
          sd=dsqrt(trajdist(ia,ja)/dfloat(nframe)-
     -      (trajdist(ja,ia)/dfloat(nframe))**2)
          if (isdtyp .eq. 2) then
            sd=sd/(cavs(ia)*cavs(ja))
          else if (isdtyp .eq. 3) then
            sd=sd/sqrt(dist2(cavsng(1,ia),cavsng(1,ja)))
          else if (isdtyp .eq. 3) then
            sd=sd*sqrt(dist2(cavsng(1,ia),cavsng(1,ja)))
          end if
          trajdist(ia,ja)=sd
          trajdist(ja,ia)=sd
          if (rcmin .gt. sd) rcmin=sd
          if (rcmax .lt. sd) rcmax=sd
        end do
        trajdist(ia,ia)=0.d0
      end do
      do ia=1,ndist
        write (iw0,1000) ia,ldist(ia),
     -    line(index(ldist(ia)))(inamcol1:inamcol2),
     -    line(index(ldist(ia)))(irescol1:irescol2),
     -    line(index(ldist(ia)))(iresncol1:iresncol2),
     -    (cav(k,ia),k=1,3),cavs(ia),
     -    normtyp(isdtyp)(1:lnormtyp(isdtyp)),
     -    (trajdist(ia,ja),ja=1,ndist)
      end do
      write (6,1011) 'SD(rij)',normtyp(isdtyp)(1:lnormtyp(isdtyp)),
     -  rcmin,rcmax
      write (iw0,1011) 'SD(rij)',normtyp(isdtyp)(1:lnormtyp(isdtyp)),
     -  rcmin,rcmax
      write (6,1011) 'site RMSD',' ',rmsdmin,rmsdmax
      write (iw0,1011) 'site RMSD',' ',rmsdmin,rmsdmax
      if (rmsdmax .gt. 10.0) then
        write (6,1006)
        write (iw0,1006)
      end if
      if (rcmin .eq. 0.0) then
        write (6,1017) 'minimum','some'
        write (iw0,1017) 'minimum','some'
      end if
      if (rcmax .eq. 0.0) then
        write (6,1017) 'maximum','all'
        write (iw0,1017) 'maximum','all'
        print *,'Exiting plotting'
        return
      end if
      navg=1
      nrep=0
      ixdelsh=0
      inc=max0(1,500/ndist)
      scalefac=amin1(1.0,500.0/float(ndist))
      iyrange=scalefac*(ndist*inc)+20
      ym_2d=800.0
      iytop=ym_2d*0.83
      iydel=max0(150,iytop-iyrange)
      iymax=iydel+iyrange
      write (iw1,1005) 25,iymax
      write (iw1,1003) normtyp(isdtyp)(1:lnormtyp(isdtyp)),
     -  trajfile(1:ltrajfile)
      iymax=iymax+15
      write (iw1,1005) 25,iymax
      call plotmat(iw1,kc,rc,trajdist,ndist,ndist,0,0,0,0,navg,
     -  nrep,25,iydel,00,iytop,rcmin,rcmax,ncolcode,maxcolcode,ixdelsh,
     -  iydelsh,inc,scalefac,indexa,ixshuffle,ixshuffle,title,0,
     -  ' ',0,'Atom #',6,xtraj,yclab,nyclab,lyclab,igl,1,1,MAXRCORR,
     -    MAXRCORR,MAXRCORR,ipspage,0)
      if (ndist .ge. 50) iydel=iydel-50
      if (ndist .lt. 50) iydel=iydel-40
      ixcent=amax1(0.0,(scalefac*(ndist*inc)-80*ncolcode)/2)
      call colcodeminmax(iw1,20+ixcent,-iydel,nrep,ncolcode,
     -  maxcolcode,rcmin,rcmax)
      iydel=iydel-40
      write (iw1,1005) 50,iydel
      write (iw1,1002) rcmin,rcmax
      write (iw1,1005) 50+250,iydel
      return
1000  format(i5,' Atom',i7,' (',a,',',a,a,') <c>=',3f8.3,
     -  ' RMSD(c)=',f6.2,/,' SD(Rij)',a,':',/,(10f8.4))
1002  format('( Range of the SD scale:',f8.5,'  -',f8.5,') show')
1003  format('( Atom-atom distance SD',a,'of trajectory file ',a,
     -  ') show')
1005  format(2i5,' m')
1006  format(' NOTE: trajectory scan did not use PBC - trajectory ',
     -  'has to be centered first')
1011  format(' Range of ',a,a,' values: [',f12.5,',',f12.5,'] A')
1017  format(' SD(rij) ',a,' is zero - ',a,' items are identical')
      end
      subroutine read_distmat(iw0,n,rijrmin,rijrmax,ix,label,inpfile,
     -  iuout,igl,mx2d)
      dimension ix(mx2d)
      character*500 label(mx2d)
      character*500 line
      character*(*) inpfile
      parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
      parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
     -  (4*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
      common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),ing(MAX2D,MAX2D),
     -  ihbpair(2,MAXBONDS),a1(MAXBONDS),a2(MAXBONDS),fill(IFILL2)
      dimension n10(10)
      llen=500
      namleni=0
      call openfile(iw0,0,'distance matrix file',20,'old',inpfile,
     -  namleni,notfnd,0,1,1,0,0)
      call askyn('Do you want to limit the label to its last word',47,
     -  1,-1,lastword,0)
      read (iw0,*,err=666) n
      if (n .gt. MAX2D) then
        write (6,1000) n,mx2d
        stop
      else if (n .lt. 1) then
        write (6,1005) n
        stop
      else
        write (6,1003) n
        write (iuout,1003) n,' ',inpfile(1:namleni)
      end if
      do i=1,n
        call blankout(line,1,llen)
        read (iw0,2000,end=999) line
        call lastchar(line,lline,llen)
        if (lline .eq. llen) write (6,1004) llen,i,line
        ic=1
        if (line(1:1) .eq. ' ') call nextchar(line,ic,llen)
        ic1=ic
        call nextblank(line,ic,llen)
c       print *,'ic1,ic=',ic1,ic
c       print *,'line=',line(1:30)
        read (line(ic1:ic-1),*,err=777) ix(i)
        call blankout(label(i),1,llen)
        if (lastword .eq. 0) then
          call nextchar(line,ic,llen)
          label(i)(1:lline-ic+1)=line(ic:lline)
        else
          call laststring(line,icf,icl,lline,llen)
          label(i)(1:icl-icf+1)=line(icf:icl)
        end if
c       print *,'i=',i,' ix=',ix(i),' label=',label(i)(1:lline-ic+1)
        read (iw0,*,end=999,err=888) (rmsd2d(i,j),j=1,n)
      end do
      close (iw0)
c     do i=1,n
c       print *, ix(i),label(i)
c       print *, (rmsd2d(i,j),j=1,n)
c     end do
      rijrmin=1000000.0
      rijrmax=-rijrmin
      nerr=0
      do i=1,n
        do j=1,i-1
          if (rmsd2d(i,j) .lt. rijrmin) rijrmin=rmsd2d(i,j)
          if (rmsd2d(i,j) .gt. rijrmax) rijrmax=rmsd2d(i,j)
          if (rmsd2d(i,j) .ne. rmsd2d(j,i)) then
            nerr=nerr+1
            if (nerr .le. 10)
     -         write (6,1001) i,j,rmsd2d(i,j),j,i,rmsd2d(j,i)
          end if
        end do
      end do
      write (6,1002) rijrmin,rijrmax
      call transform_mat(rmsd2d,n,mx2d,rijrmin,iuout,igl)
      call transform_dist(rijrmin,rijmin)
      call transform_dist(rijrmax,rijmax)
      if (rijmin .gt. rijmax) then
        x=rijmax
        rijmax=rijmin
        rijmin=x
      end if
      write (6,1006) rijmin,rijmax
      call zeroiti(n10,0,10)
      rijrange=rijmax-rijmin
      nz=0
      do i=1,n
        do j=1,i-1
          ixd=10.0*(rmsd2d(i,j)-rijmin)/rijrange
          if (ixd .lt. 10) ixd=ixd+1
          n10(ixd)=n10(ixd)+1
          if (rmsd2d(i,j) .eq. 0.0) nz=nz+1
        end do
      end do
      write (6,1007) n10
      if (nz .gt. 0) then
        write (6,1008) nz 
        call askyn('Do you want a list of identical pairs',37,
     -    1,-1,ilistdup,0)
        if (ilistdup .gt. 0) then
          do i=1,n
            do j=1,i-1
              if (rmsd2d(i,j) .eq. 0.0) then
                call lastchar(label(i),lci,500)
                call lastchar(label(j),lcj,500)
                write (6,1009) i,label(i)(1:lci),j,label(j)(1:lcj)
              end if
            end do
          end do
        end if
      end if
      return
666   print *,' ERROR: invalid matrix dimension:'
      rewind iw0
      read (iw0,2000,end=999) line
      print *,line(1:20)
      stop
777   print *,' ERROR: invalid sequence number for item ',i,':',
     -  line(ic1:ic-1)
      stop
888   print *,' ERROR: invalid number read for item ',i
      stop
999   print *,' ERROR: matrix input ended unexpectedly'
      stop
1000  format(' Matrix dimension (',i6,') exceeds limit (',i6,')',/,
     -  ' Redimension the program')
1001  format(' Symmetry ERROR: R[',i5,',',i5,']=',f10.5,' and ',
     -  'R[',i5,',',i5,']=',f10.5)
1002  format(' Range of matrix values: [',f10.5,',',f10.5,']',/,
     -  ' NOTE: if the input matrix entries represent similarities',/,
     -  '       then you have to use one of the (1-r(i,j)) transform',
     -  ' options')
1003  format(' Distance matrix dimension=',i5,a,/,' Read from file ',a)
1004  format(' WARNING: label is longer than ',i4,' characters in row',
     -  i6,':',/,1x,a)
1005  format(' ERROR: Input matrix dimension is non=positive:',i9)
1006  format(' Transformed distance range: [',f10.5,',',f10.5,']')
1007  format(' Distribution of the distances:',/,10i7)
1008  format(' NOTE: there are ',i6,' identical item pairs')
1009  format(' #',i5,' (',a,') is identical with #',i5,' (',a,')')
2000  format(a)
      end
      subroutine transform_mat(r,n,nmax,rijrmin,iuout,igl)
      dimension r(nmax,nmax)
      character*1 ans
      common /transform_dist_dat/ itranstyp,nexp,rijmin,fracexp
      fracexp=1.0
      rijmin=rijrmin
      call quiz(ans,itranstyp,'u',' ',0,'transformation type',19,
     -   0,5,6,igl,00)
      if (itranstyp .gt. 1) then
        if (itranstyp .ne. 4) then
          call getint('Exponent',8,1,1,6,nexp,0)
          fracexp=1.0/float(nexp)
        end if
        do i=1,n
          do j=1,i-1
            call transform_dist(r(i,j),r(i,j))
            r(j,i)=r(i,j)
          end do
        end do
        write (iuout,1001)
        if (itranstyp .eq. 2) write (iuout,1002) nexp
        if (itranstyp .eq. 3) write (iuout,1003) nexp
        if (itranstyp .eq. 4) write (iuout,1004)
        if (itranstyp .eq. 5) write (iuout,1005) nexp
        if (itranstyp .eq. 6) write (iuout,1006) nexp
        if (itranstyp .eq. 7) write (iuout,1007) nexp
        if (itranstyp .eq. 8) write (iuout,1008) nexp
        if (itranstyp .eq. 9) write (iuout,1009) nexp
      else
        write (iuout,*) 'Input matrix used as is'
      end if
      return
1001  format(' Input data trasnformed as')
1002  format(' r(i,j)=r(i,j)**',i1)
1003  format(' r(i,j)=r(i,j)**(1/',i1,')')
1004  format(' r(i,j)=1.0-r(i,j)')
1005  format(' r(i,j)=(1.0-r(i,j))**',i1)
1006  format(' r(i,j)=(1.0-r(i,j))**(1/',i1,')')
1007  format(' r(i,j)=abs(r(i,j)**',i1)
1008  format(' r(i,j)=(1.0-abs(r(i,j))**',i1)
1009  format(' r(i,j)=(r(i,j)-min(r(i,j))**',i1)
      end
      subroutine transform_dist(r_read,r_trans)
      common /transform_dist_dat/ itranstyp,nexp,rijmin,fracexp
      if (itranstyp .eq. 1) then
        r_trans=r_read
      else if (itranstyp .eq. 2) then
        r_trans=r_read**nexp
      else if (itranstyp .eq. 3) then
        r_trans=r_read**fracexp
      else if (itranstyp .eq. 4) then
        r_trans=1.0-r_read
      else if (itranstyp .eq. 5) then
        r_trans=(1.0-r_read)**nexp
      else if (itranstyp .eq. 6) then
        r_trans=(1.0-r_read)**fracexp
      else if (itranstyp .eq. 7) then
        r_trans=abs(r_read)**nexp
      else if (itranstyp .eq. 8) then
        r_trans=(1.0-abs(r_read))**nexp
      else if (itranstyp .eq. 9) then
        r_trans=(r_read-rijmin)**nexp
      end if
      return
      end
      subroutine read_2drmsd(iw0,system,lsystem,trajname,ltrajname,
     -  trajname2,ltrajname2,isym,rmsdmn,rmsdmx,nframeread,
     -  nframex,nframey,ietotsaved,maxecho,limresrange)
      character*(*) trajname,trajname2,system
      parameter (MAXFRAMES=50000,MAXCOPY=600)
      parameter (MAXCOPY1=MAXCOPY-1)
      common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
     -  increment,increment2,res(2,MAXFRAMES,MAXCOPY1),
     -  xyplot(2,MAXFRAMES),x0(MAXCOPY),y0(MAXCOPY),nxselres,
     -  ixselres(MAXCOPY)
      parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
      parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
     -  (4*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
      common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),ing(MAX2D,MAX2D),
     -  ihbpair(2,MAXBONDS),a1(MAXBONDS),a2(MAXBONDS),fill(IFILL2)
      character*16 errlab
      character*80 line
      limresrange=1
      nline=0
      rmsdmn=1000000.0
      ltrajname2=0
      if (isym .eq. 1) rmsdmn=0.0
      rmsdmx=0.0
      nframex=0
      nframey=0
      call blankout(errlab,1,16)
      do while (.true.)
        call blankout(line,1,80)
        read (iw0,1000,end=999) line
        nline=nline+1
        if (line(1:9) .eq. ' Config #') then
c         RMSD data found
          errlab='structure number'
c         read (line(17:22),*,err=888) ix
c         read (line(74:79),*,err=888) jx
          read (line(11:15),*,err=888) ix
          read (line(52:57),*,err=888) jx
          if (ix .gt. nframex) nframex=ix
          if (jx .gt. nframey) nframey=jx
          read (iw0,1000,end=999) line
          errlab='RMSD'
          read (line(21:28),*,err=888) rmsd2d(ix,jx)
          if (rmsd2d(ix,jx) .gt. rmsdmx) rmsdmx=rmsd2d(ix,jx)
          if (rmsd2d(ix,jx) .lt. rmsdmn) rmsdmn=rmsd2d(ix,jx)
          if (isym .eq. 1) rmsd2d(jx,ix)=rmsd2d(ix,jx)
          if (line(51:53) .eq. 'Ec=') then
            errlab='energy'
            read (line(64:77),*,err=888) res(1,ix,11)
            ietotsaved=1
          end if
          nline=nline+1
          lc=2
          do while (lc .gt. 1)
            call blankout(line,1,80)
            read (iw0,1000,end=999) line
            call lastchar(line,lc,80)
            nline=nline+1
          end do
        else if (line(1:33) .eq. ' Second trajectory file analyzed:')
     -           then
          call lastchar(line,icl,80)
          ltrajname2=icl-33
          trajname2(1:ltrajname2)=line(34:33+ltrajname2)
          nline=nline+1
          print *,'Second trajectory: ',trajname2(1:ltrajname2)
        else if (line(1:26) .eq. ' Trajectory file analyzed:') then
          call lastchar(line,icl,80)
          ltrajname=icl-26
          trajname(1:ltrajname)=line(27:26+ltrajname)
          nline=nline+1
          print *,'Trajectory: ',trajname(1:ltrajname)
        else if (line(1:27) .eq. ' Number of frames analyzed=') then
          call lastchar(line,icl,80)
          errlab='number of frames'
          read (line(28:icl),*,err=888) nframeread
          nline=nline+1
          print *,'Number of structures analyzed=',nframeread
          go to 100
        else if (line(1:8) .eq. ' System:') then
          call blankout(line,1,80)
          read (iw0,1000,end=999) line
          call lastchar(line,lsystem,80)
          system(1:lsystem)=line(1:lsystem)
          nline=nline+2
          print *,'System:',system(1:lsystem)
        else if (line(1:28) .eq. ' All atoms are used for RMSD') then
          limresrange=0
        end if
      end do
100   if (ltrajname2 .gt. 0) then
c       Cross RMSD map
        do i=1,min0(maxecho,nframex)
          write (iw0,2000) i,(rmsd2d(i,j),j=1,nframey)
        end do
      else
        do i=2,min0(maxecho,nframeread)
          write (iw0,2000) i,(rmsd2d(j,i),j=1,i-1)
        end do
        nframex=max0(nframex,nframey)
        nframey=max0(nframex,nframey)
      end if
      write (6,2001) nframex,nframey
      return
888   print *,'ERROR: invalid input for ',errlab,':'
      print *,line
      return
999   print *,'ERROR: 2D RMSD file ended prematurely at line #',nline
      return
1000  format(a)
2000  format(' RMSD(',i4,'):',10f6.1,/,(12x,10f6.1))
2001  format(' Matrix of ',i6,' rows and ',i6,' columns read')
      end
      subroutine matchtraj(rmsdsim,iw0)
      parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
      parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
     -  (4*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
      common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),ing(MAX2D,MAX2D),
     -  ihbpair(2,MAXBONDS),a1(MAXBONDS),a2(MAXBONDS),fill(IFILL2)
      parameter (MAXFRAMES=50000,MAXCOPY=600)
      common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
     -  increment,increment2,res(2,MAXFRAMES,MAXCOPY),
     -  x0(MAXCOPY),y0(MAXCOPY),nxselres,ixselres(MAXCOPY)
      dimension nsame1(MAX2D),nsame2(MAX2D)
      character*6 lab
      nframe1=nframeref
      nframe2=nframe
      call zeroiti(nsame1,0,nframe1)
      call zeroiti(nsame2,0,nframe2)
      rmsdmin=100000.0
c     print *,'MATCHTRAJ iw0,nframe,nframeref=',iw0,nframe,nframeref
      write (iw0,1002)
      do if=1,nframe1
c       Find closest to frame if
        rmsdmini=100000.0
        do jf=1,nframe2
          if (rmsdmini .gt. rmsd2d(if,jf)) then
            rmsdmini=rmsd2d(if,jf)
            jmin=jf
          end if
          if (rmsdsim .gt. rmsd2d(if,jf)) then
            nsame1(if)=nsame1(if)+1
          end if
        end do
        a1(if)=jmin
        if (rmsdmin .gt. rmsdmini) then
          rmsdmin=rmsdmini
          igmin=if
          jgmin=jmin
        end if
      end do
      do jf=1,nframe2
c       Find closest to frame if
        rmsdminj=100000.0
        do if=1,nframe1
          if (rmsdminj .gt. rmsd2d(if,jf)) then
            rmsdminj=rmsd2d(if,jf)
            imin=if
          end if
          if (rmsdsim .gt. rmsd2d(if,jf)) then
            nsame2(if)=nsame2(if)+1
          end if
        end do
        a2(jf)=imin
      end do
      do if=1,nframe1
        jmin=a1(if)
        minrev1=a2(jmin)
        lab='      '
        if (minrev1 .eq. if) lab='mutual'
        if (rmsdsim .eq. 0) then
          write (iw0,1000) 1,if,2,jmin,rmsd2d(if,jmin),lab
        else
          write (iw0,1003) 1,if,rmsdsim,nsame1(if),2,imin,
     -      rmsd2d(if,jmin),lab
        end if
      end do
      do jf=1,nframe2
        imin=a2(jf)
        minrev2=a1(imin)
        lab='      '
        if (minrev2 .eq. jf) lab='mutual'
        if (rmsdsim .eq. 0) then
          write (iw0,1000) 2,jf,1,imin,rmsd2d(imin,jf),lab
        else
          write (iw0,1003) 2,jf,rmsdsim,nsame2(jf),1,imin,
     -      rmsd2d(imin,jf),lab
        end if
      end do
      write (iw0,1001) igmin,jgmin,rmsdmin
      return
1000  format(' Traj',i2,' frame',i5,' closest from traj',i2,' is frame',
     -  i5,' RMSD=',f10.1,1x,a)
1001  format(' Best match is between traj 1, frame',i5,' traj 2, frame',
     -  i5,' RMSD=',f10.1)
1002  format(/,' Best matches between the frames:')
1003  format(' Tr',i2,' #',i5,' # < ',f4.1,':',i5,
     -  ' closest from tr',i2,': #',i5,' RMSD=',f10.1,1x,a)
      end
      subroutine rmsd(co,c,n,nfinalov,nfinalrmsd,atw,atwsum,atw1,c1,
     -  c2,indxov1,indxov2,noopt2d,iedit,isymm,limresrange,itemp1,
     -  indxrmsd1,indxrmsd2,rot,com1,com2,etot,etot2,iout,devmax,
     -  devmaxnoopt,maxat)
      dimension co(3,n),c(3,n),atw(n),atw1(n),c1(3,n),c2(3,n),itemp1(n),
     -  indxov1(n),indxov2(n),indxrmsd1(n),indxrmsd2(n),rot(3,3),
     -  com1(3),com2(3)
      real*8 atwsum
c     Calculate the RMSD of the two structures after obtaining the best fit
c     using Kabsch formula
      character*2 iatnm2
      common /atnam/ aw(99),nval(99),nvalmax(99),mmofan(99),
     -  mmatno(64),iatnm2(99)
      parameter (MAXFRAMES=50000,MAXCOPY=600)
      common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
     -  increment,increment2,res(2,MAXFRAMES,MAXCOPY),
     -  x0(MAXCOPY),y0(MAXCOPY),nxselres,ixselres(MAXCOPY)
      parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
      parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
     -  (4*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
      common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),ing(MAX2D,MAX2D),
     -  ihbpair(2,MAXBONDS),a1(MAXBONDS),a2(MAXBONDS),fill(IFILL2)
c     print *,'Start RMSD nframeref,nframe=',nframeref,nframe
c     Calculate rMSD w/o overlay
c      write (iout,8811) n,nfinalrmsd,nfinalov,iedit,limresrange
c8811  format(' n,nfinalrmsd,nfinalov,iedit,limresrange=',3i8,2i3)
c      write (iout,8812) 'indxov1',(indxov1(i),i=1,nfinalov)
c      write (iout,8812) 'indxrmsd1',(indxov2(i),i=1,nfinalrmsd)
c8812  format(1x,a,':',/,(20i4))
c      write (iout,8813) 'C',((c(k,indxov1(i)),k=1,3),i=1,nfinalov)
c      write (iout,8813) 'CO',((co(k,indxov2(i)),k=1,3),i=1,nfinalov)
c8813  format(1x,a,':',/,(5f10.5))
c      write (iout,8814) (atw(indxov1(i)),i=1,nfinalrmsd)
c8814  format(' ATW:',/,(5f10.5))
      sdnoopt=sqrt(sdsum(nfinalrmsd,co,c,atw,indxrmsd1,indxrmsd2,
     -  devmaxnoopt,maxat))
      if (noopt2d .eq. 0) then
        call bestoverlay(nfinalov,indxov1,indxov2,co,c,atw,atwsum,c1,c2,
     -    atw1,rot,com1,com2,00,0.001,iout,maxat)
        if (iedit .eq. 1 .and. limresrange .eq. 0) then
c         Only limit the overlay calculation - use c1,c2,atw1
          call rotate_c(c2,nfinalov,rot,c2,'RMSD1',5)
          call indexit(itemp1,1,nfinalov,0)
          sd=sqrt(sdsum(nfinalrmsd,c1,c2,atw1,itemp1,itemp1,devmax,
     -      maxat))
        else
c         Shift the full set of coordinate to com1,com2, and rotate by rot
          call shiftmol(co,n,com1,c1,-1.0)
          call shiftmol(c,n,com2,c2,-1.0)
          call rotate_c(c2,n,rot,c2,'RMSD',4)
          sd=sqrt(sdsum(nfinalrmsd,c1,c2,atw,indxrmsd1,indxrmsd2,devmax,
     -      maxat))
        end if
      else
        devmax=devmaxnoopt
      end if
      call trajlimtest(nframe,MAXFRAMES)
      if (etot .eq. 0.0) then
        if (noopt2d .eq. 0)
     -    write (iout,1001) 'Best overlap:',sd,devmax
        write (iout,1001) 'No   overlap:',sdnoopt,devmaxnoopt
      else
        if (noopt2d .eq. 0) then
          write (iout,1001) 'Best overlap:',sd,devmax,' ','c',etot
          write (iout,1001) 'No   overlap:',sdnoopt,devmaxnoopt,' ',
     -      'r',etot2
        else
          write (iout,1001) 'No   overlap:',sdnoopt,devmaxnoopt,' ',
     -      'c',etot
        end if
        res(1,nframe,9)=etot
      end if
      if (nframeref .le. 1) then
        res(1,nframe,7)=sd
        res(2,nframe,7)=devmax
        res(1,nframe,8)=sdnoopt
        res(2,nframe,8)=devmaxnoopt
      end if
      if (nframeref .gt. 0) then
        if (noopt2d .eq. 0) then
          rmsd2d(nframe,nframeref)=sd
          if (isymm .eq. 1) rmsd2d(nframeref,nframe)=sd
        else
          rmsd2d(nframe,nframeref)=sdnoopt
          if (isymm .eq. 1) rmsd2d(nframeref,nframe)=sdnoopt
        end if
      end if
      return
1001  format(1x,a,' RMSD=',f8.3,' Max dev=',f10.3,' A',
     -  a,'E',a1,'=',e14.7)
      end
      subroutine rmsf(cref,c,nslt,ifres,ilres,numresslt,bfacavg)
      dimension cref(3,nslt),c(3,nslt),ifres(numresslt),
     -  ilres(numresslt)
      real*8 bfacavg(numresslt)
      do ir=1,numresslt
        dev2=0
        do ia=ifres(ir),ilres(ir)
          do k=1,3
            dev2=dev2+(c(k,ia)-cref(k,ia))**2
          end do
        end do
        bfacavg(ir)=bfacavg(ir)+sqrt(dev2/float(ilres(ir)-ifres(ir)+1))
      end do
      return
      end
      subroutine celldipole(c,n,nslt,index,nats,q,icharges,aw,iout,
     -  itraj)
      dimension c(3,n),index(n),q(n),aw(n)
c     Calculate the COM of the solute
c     Calculate the solute and the whole cell dipole moment when icharges >0
      parameter (MAXFRAMES=50000,MAXCOPY=600)
      common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
     -  increment,increment2,res(2,MAXFRAMES,MAXCOPY),
     -  x0(MAXCOPY),y0(MAXCOPY),nxselres,ixselres(MAXCOPY)
      real*8 dipole(3),com(3),awsum
      dimension dipslt(3),dipslv(3),diptot(3)
      call trajlimtest(nframe,MAXFRAMES)
      call zeroitd(dipole,3)
      call zeroitd(com,3)
      awsum=0.d0
      do ia=1,nats
        do k=1,3
          if (icharges .gt. 0)
     -      dipole(k)=dipole(k)+c(k,index(ia))*q(index(ia))
            com(k)=com(k)+c(k,index(ia))*aw(index(ia))
        end do
        awsum=awsum+aw(index(ia))
      end do
      do k=1,3
        if (icharges .gt. 0) dipslt(k)=dipole(k)
        com(k)=com(k)/awsum
      end do
      if (iout .gt. 0) write (iout,1003) com
      if (itraj .gt. 0) then
        res(2,nframe,14)=com(1)
        res(1,nframe,15)=com(2)
        res(2,nframe,15)=com(3)
      end if
      if (icharges .eq. 0) return
      dipsltabs=sqrt(dipslt(1)**2+dipslt(2)**2+dipslt(3)**2)
      call zeroitd(dipole,3)
      do ia=nslt+1,n
        do k=1,3
          dipole(k)=dipole(k)+c(k,ia)*q(ia)
        end do
      end do
      do k=1,3
        dipslv(k)=dipole(k)
      end do
      dipslvabs=sqrt(dipslv(1)**2+dipslv(2)**2+dipslv(3)**2)
      do ia=1,nslt 
        do k=1,3
          dipole(k)=dipole(k)+c(k,index(ia))*q(index(ia))
        end do
      end do
      diptotabs=sqrt(diptot(1)**2+diptot(2)**2+diptot(3)**2)
      if (iout .ne. 0) then
        write (iout,1000) dipsltabs
        if (n .gt. nslt) write (iout,1001) dipslvabs,diptotabs
        write (iout,1002) 'solute ',dipslt
        if (n .gt. nslt) then
          write (iout,1002) 'solvent',dipslv
          write (iout,1002) 'cell   ',diptot
        end if
      end if
      if (itraj .gt. 0) then
        res(1,nframe,10)=diptotabs
        res(2,nframe,10)=dipsltabs
        res(1,nframe,11)=diptot(1)
        res(2,nframe,11)=diptot(2)
        res(1,nframe,12)=diptot(3)
        res(1,nframe,13)=dipslt(1)
        res(2,nframe,13)=dipslt(2)
        res(1,nframe,14)=dipslt(3)
      end if
      return
1000  format(' Dipole moment of the solute=',f10.3)
1001  format(' Dipole moment of the solvents=',f10.3,
     -  ' total=',f10.3,' au*A')
1002  format(' Dipole moment vector of ',a,'=',3f10.3,' au*A')
1003  format(' Center-of-mass=',3f10.4,' A')
      end
      subroutine clusterdistr(ndim,iout,rdlim,rdmin,rdmax,nhbdist,
     -  it1,it2,it3,it4,ifclst,ilclst,nrdclust,indexa,index2d,ixclst,
     -  it2d,value,ifa_s,ila_s,ih,cv,rdclustdef,rdclust,etotsaved,
     -  ietotsaved,label,llabel,isorttype,ifindbestrep,irepav,irepmx,
     -  irepeng,irepkm,engcl,c,cent,cent_prev,maxct,ihelp,iclstyp,
     -  iwt,nomemprint,label2d,llabel2d,ilabel2d,idistp,nosortindex2d,
     -  iuseindex2d,igl,mx2d,maxframe)
      dimension rdlim(mx2d),nhbdist(mx2d),it1(mx2d),it2(mx2d),
     -  it3(mx2d),it4(mx2d),ifclst(mx2d),ilclst(mx2d),ixclst(mx2d),
     -  it2d(mx2d),index2d(mx2d),indexa(mx2d),value(mx2d),ifa_s(mx2d),
     -  ila_s(mx2d),ih(mx2d),irepav(mx2d),irepmx(mx2d),iwt(mx2d),
     -  cv(mx2d),etotsaved(2,maxframe),irepeng(mx2d),irepkm(mx2d),
     -  engcl(mx2d),c(3,ndim),cent(3,maxct),cent_prev(3,maxct)
      character*(*) label
      character*(*) label2d(mx2d)
      parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
      dimension cutofflist(5),imemcut(MAX2D,5),ifcl_prev(MAX2D),
     -  ilcl_prev(MAX2D),icent_fin(MAX2D)
      character*18 memlab
      character*80 memdir,memfilename
      character*500 line
      character*1 ans
      character*40 clstyp
      common /cluster_typ/ nclstyp,inumclst(9),ireadcutoff(9),
     -  lclstyp(9),clstyp(9)
      data iu_clst /60/
c     Clustering
c     print *,'CLUSTERD ndim,rdmin,rdmax,ietotsaved=',
c    -  ndim,rdmin,rdmax,ietotsaved
c      write (iout,7934) (index2d(i),i=1,ndim)
c7934  format(' CLUSTERDISTR INDEX2D=',15i4)
      idistprint=idistp
      nrdclust=0
      irepeng(1)=0
      nnmin=0
      idenclstyp=0
      if (rdmax .le. 0.0) then
        print *,'ERROR: largest distance is nonpositive:',rdmax
        return
      end if
      iclstyp=1
8910  call quiz(ans,iclstyp,' ',' ',0,'clustering algorithm',20,
     -  0,5,6,igl,40)
      if (ans .eq. 'q') then
        if (nrdclust .eq. 0) then
          print *,'NOTE: no clustering was done'
          call askyn('No clustering was done - still want to quit',43,
     -      1,1,iquit,130)
          if (iquit .eq. 0) go to 8910
        end if
        return
      end if
      if (maxct .le. 1 .and. iclstyp .eq. 5) then
        write (6,*)
     -   'COM as cluster center only applies to clustering atoms'
        go to 8910
      end if
      write (iout,2060) clstyp(iclstyp),ndim
      if (iclstyp .ne. 4) call zeroiti(irepkm,0,ndim)
      if (inumclst(iclstyp) .eq. 1) then
        call getint('Number of clusters requested',28,999999,1,ndim,
     -    nrdclust,ihelp)
        rdclust=0.0
        write (iout,2061) nrdclust
      else if (ireadcutoff(iclstyp) .eq. 1) then
        write (line,1014) label(1:llabel)
        call getreal(line,22+llabel,rdclustdef,rdclust,1,ihelp)
        nhbcorrclust=1
      end if
      if (iclstyp .eq. 9) then
c       Set density type and neighbor min
        call quiz(ans,idenclstyp,' ',' ',0,'density clustering variant',
     -    26,0,5,6,igl,141)
        if (idenclstyp .lt. 2) call getint(
     -    'Minimum number of common neighbors',34,999999,1,ndim,nnmin,
     -    000)
        if (idenclstyp .eq. 3) call getint(
     -    'Minimum number of individual neighbors',38,999999,1,ndim,
     -    nnmin,000)
      end if
      write (iout,2062)
      if (iclstyp .ne. 3 .and. idistprint .ge. 0)
     -  call askyn('Do you want to print all cluster-cluster distances',
     -    50,1, -1,idistprint,130)
      call zeroit(rdlim,ndim)
      rdlim(1)=rdmax
      rdlim(ndim)=rdmin
      if (rdlim(ndim) .eq. 0.0) rdlim(ndim)=0.000001
      call trnsfi(it2d,index2d,ndim)
      if (iclstyp .eq. 1 .or. iclstyp .eq. 4 .or. iclstyp .eq. 5 .or.
     -    iclstyp .eq. 6 .or. iclstyp .eq. 8 .or. iclstyp .eq. 9) then
c       Just cluster using rdclust as the threshold
        if (ans .ne. 'k')
     -    write (iout,2092) label(1:llabel),rdclust
        call rmsdcluster(rdclust,1,ndim,index2d,iwt,ixclst,ifclst,
     -    ilclst,it1,it2,it3,irepav,irepmx,c,cent,cent_prev,irepkm,
     -    maxct,iclstyp,idenclstyp,nnmin,nrdclust,nosortindex2d,
     -    iuseindex2d,ifail,1,label,llabel,iout,igl)
c      write (iout,7824) (ifclst(i),ilclst(i),i=1,nrdclust)
c7824  format(' After RMSDCLUSTER Cluster limits: ',('[',i5,',',i5,']'))
c      write (iout,6792) 'IXCLST',(ixclst(i),i=1,ndim)
c6792  format(' AFTER RMSDCLUSTER ',a,':',/,(20i5))
        if (ifail .gt. 0) go to 8910
        nclust=nrdclust
c       Members of cluster ic: (index2d(i),i=ifclst(ic),ilclst(ic))
        if (ans .ne. 'k') write (6,2090) label(1:llabel),rdclust,nclust
        call reportclust(ndim,0,1,nclust,ifclst,ilclst,index2d,value,
     -    it1,ifa_s,ila_s,ih,cv,indexa,irepav,irepmx,irepeng,irepkm,
     -    engcl,nhbdist,etotsaved,ietotsaved,ifindbestrep,label,llabel,
     -    isorttype,idistprint,nomemprint,iout,maxframe,mx2d)
      else if (iclstyp .eq. 2 .or. iclstyp .eq. 7) then
c       Vary the threshold until nrdclust clusters result
        write (6,2093) nrdclust,rdmin,rdmax
        write (iout,2093) nrdclust,rdmin,rdmax
        call zeroiti(indexa,0,ndim)
        nclust=1
        rdmn=rdmin
        rdmx=rdmax
        nclmx=nrdclust
        do while (rdlim(nclmx) .eq. 0.0)
          nclmx=nclmx-1
        end do
        rdmx=rdlim(nclmx)
        nclmn=nrdclust
        do while (rdlim(nclmn) .eq. 0.0)
          nclmn=nclmn+1
        end do
        rdmn=rdlim(nclmn)
        ntry=0
        call trnsfi(it4,index2d,ndim)
        do while (nclust .ne. nrdclust .and. ntry .le. ndim)
          call trnsfi(index2d,it4,ndim)
          rdclust=(rdmn+rdmx)/2.0
          call rmsdcluster(rdclust,1,ndim,index2d,iwt,ixclst,ifclst,
     -      ilclst,it1,it2,it3,irepav,irepmx,c,cent,cent_prev,
     -      icent_fin,maxct,iclstyp,idenclstyp,nnmin,nclust,
     -      nosortindex2d,iuseindex2d,ifail,ntry,label,llabel,iout,igl)
          if (ifail .gt. 0) go to 8910
          if (nclust .lt. nrdclust) rdmx=rdclust
          if (nclust .gt. nrdclust) rdmn=rdclust
          write (6,2090) label(1:llabel),rdclust,nclust
          write (iout,2090) label(1:llabel),rdclust,nclust
          if (indexa(nclust) .gt. 25) then
            write (iout,2094) nrdclust,nclust
            write (6,2094) nrdclust,nclust
            nrdclust=nclust
            ntry=ndim
          end if
          indexa(nclust)=indexa(nclust)+1
          rdlim(nclust)=rdclust
          ntry=ntry+1
        end do
        write (iout,2066) label(1:llabel),nclust,rdclust
        write (6,2066) label(1:llabel),nclust,rdclust
        if (nclust .ne. nrdclust) then
          write (iout,2094) nrdclust,nclust
          write (6,2094) nrdclust,nclust
          nrdclust=nclust
        end if
        call reportclust(ndim,0,1,nclust,ifclst,ilclst,index2d,value,
     -    it1,ifa_s,ila_s,ih,cv,indexa,irepav,irepmx,irepeng,irepkm,
     -    engcl,nhbdist,etotsaved,ietotsaved,ifindbestrep,label,llabel,
     -    isorttype,idistprint,nomemprint,iout,maxframe,mx2d)
      else if (iclstyp .eq. 3) then
100     call getint('Number of cutoffs',17,5,1,5,ncutoff,00)
        if (ncutoff .le. 1) go to 100
        call askyn('Do you want uniformly spaced cutoffs',36,1,1,
     -    iunif,0)
        if (iunif .eq. 1) then
          call transform_dist(rdmin,rdtmin)
          call transform_dist(rdmax,rdtmax)
          if (rdtmin .lt. rdtmax) then
            call getreal('Largest cutoff',14,rdtmax,rcutulim,1,00)
            call getreal('Smallest cutoff',14,rdtmin,rcutllim,1,00)
          else
            call getreal('Largest cutoff',14,rdtmin,rcutulim,1,00)
            call getreal('Smallest cutoff',14,rdtmax,rcutllim,1,00)
          end if
          do icut=1,ncutoff
            cutofflist(icut)=
     -        rcutulim-(icut-1)*(rcutulim-rcutllim)/(ncutoff-1)
          end do
        else
          print *,'Specify the cutoffs (in decreasing order)'
          rcutprev=rdmax+1.0
          do icut=1,ncutoff
110         write (line(1:11),1015) icut
            call getreal(line,11,999999.0,cutofflist(icut),1,00)
            if (cutofflist(icut) .ge. rdmax) then
              print *,'Cutoff read exceeds the largest distance'
              go to 110
            else if (cutofflist(icut) .ge. rcutprev) then
              print *,'Cutoffs need to be in decreasing order'
              go to 110
            end if
            rcutprev=cutofflist(icut)
          end do
        end if
        write (6,1016) (cutofflist(icut),icut=1,ncutoff)
        write (iout,*) 'Hierarchical clustering with multiple cutoffs'
        write (iout,1016) (cutofflist(icut),icut=1,ncutoff)
        call getint('Cluster level to calculate average',34,ncutoff,1,
     -    ncutoff,lev_avg,00)
        call askyn('Do you want to write cluster member files',41,1,-1,
     -    memfiles,129)
        if (memfiles .eq. 1) then
111       call getname(memdir,lmemdir,'Name of the directory to write',
     -      30,60,0)
          call checkdir(memdir,lmemdir,iu_clst,iopen)
          if (iopen .gt. 0) then
            write (6,1024) memdir(1:lmemdir)
            go to 111
          end if
          memdir(lmemdir+1:lmemdir+2)='/C'
          lmemdir=lmemdir+2
          memfilename=memdir
        end if
        write (iout,1023) lev_avg
        ifcl_prev(1)=1
        ilcl_prev(1)=ndim
        ncl_prev=1
        call indexit(index2d,1,ndim,0)
        write (iout,1019)
        do icut=1,ncutoff
          ncltot=0
          do icl=1,ncl_prev
c           write (iout,*)
c    -        'cutofflist(icut),ifcl_prev(icl),ilcl_prev(icl)=',
c    -        cutofflist(icut),ifcl_prev(icl),ilcl_prev(icl)
            call rmsdcluster(cutofflist(icut),ifcl_prev(icl),
     -        ilcl_prev(icl),index2d,iwt,ixclst,ifclst(ncltot+1),
     -        ilclst(ncltot+1),it1,it2,it3,irepav,irepmx,c,cent,
     -        cent_prev,icent_fin,maxct,iclstyp,idenclstyp,nnmin,nclust,
     -        nosortindex2d,iuseindex2d,ifail,1,label,llabel,iout,igl)
            if (ifail .gt. 0) go to 8910
            do ic=ncltot+1,ncltot+nclust
              do ia=ifclst(ic),ilclst(ic)
                imemcut(index2d(ia),icut)=ic-ncltot
              end do
            end do
            ncltot=ncltot+nclust
          end do
          call trnsfi(ifcl_prev,ifclst,ncltot)
          call trnsfi(ilcl_prev,ilclst,ncltot)
          ncl_prev=ncltot
        end do
        iranksum=0
        nsum=0
        irank_rep=ndim+1
        ia_rep=0
        ia_start=1
        do ia=1,ndim
          write (line,1017) ia,index2d(ia),
     -      (imemcut(index2d(ia),lev),lev=1,ncutoff)
          len=18+5*ncutoff
          line(len+1:len+1)=' '
          len=len+1
          rankav=0.0
          if (ia .eq. ndim) then
            if (nsum .gt. 0) rankav=float(iranksum)/float(nsum)
            iend=1
          else
c           Find out if cluster ends at level lev_avg
            iend=0
            do lev=1,lev_avg
              if (imemcut(index2d(ia+1),lev) .ne.
     -            imemcut(index2d(ia),lev)) iend=1
            end do
            if (index2d(ia) .lt. irank_rep) then
              irank_rep=index2d(ia)
              ia_rep=ia
            end if
            if (iend .eq. 1) then
              if (nsum .gt. 0)
     -          rankav=float(iranksum+index2d(ia))/float(nsum+1)
              iranksum=0
              nsum=0
              irank_rep=ndim+1
            else
              iranksum=iranksum+index2d(ia)
              nsum=nsum+1
            end if
          end if
          if (ilabel2d .gt. 0) then
            call lastchar(label2d(index2d(ia)),lc,llabel2d)
            line(len+1:len+lc)=label2d(index2d(ia))(1:lc)
            len=len+lc
          end if
          if (memfiles .eq. 1 .and. iend .eq. 1) then
c           Write member list file
            lmemfilename=lmemdir
            do lev=1,lev_avg
              call writeint(memfilename,lmemfilename+1,
     -          imemcut(index2d(ia),lev),ndig)
              lmemfilename=lmemfilename+ndig+1
              memfilename(lmemfilename:lmemfilename)='.'
            end do
            memfilename(lmemfilename+1:lmemfilename+4)='clst'
            lmemfilename=lmemfilename+4
c           call openfile(iu_clst,0,' ',1,'new',memfilename,
c    -        lmemfilename,notfound,0,1,1,1,0)
            open(unit=iu_clst,form='formatted',status='new',
     -        file=memfilename(1:lmemfilename),iostat=iopen)
            if (iopen .eq. 0) then
c             Write list
              do imem=ia_start,ia
                call lastchar(label2d(index2d(imem)),lc,llabel2d)
                write (iu_clst,1000) label2d(index2d(imem))(1:lc),
     -            index2d(imem)
              end do
              close (iu_clst)
            else
              write (6,*) 'ERROR: could not open ',
     -          memfilename(1:lmemfilename)
               write (6,*) 'lmemfilename=',lmemfilename
            end if
            if (iend .eq. 1) ia_start=ia+1
          end if
          if (rankav .gt. 0.0) then
            write (line(len+1:len+18),1010) rankav
            len=len+13
            call laststring(label2d(index2d(ia_rep)),ifc,ilc,lc,500)
            write (line(len+1:len+ilc-ifc+7),1022)
     -        label2d(index2d(ia_rep))(ifc:ilc)
            len=len+ilc-ifc+7
          else if (iend .eq. 1) then
            write (line(len+1:len+10),1025) index2d(ia_rep)
            len=len+10
          end if
          write (iout,1018) line(1:len)
        end do
        return
      end if
      isubcl=0
      if (nclust .lt. ndim .and. iclstyp .eq. 1) then
c       Sub-clustering only works for single-link clustering
        call askyn('Do you want to try sub clustering',33,1,-1,isubcl,
     -    29)
        if (isubcl .gt. 0) then
          call quiz(ans,isubclustertyp,' ',' ',0,
     -      'subclustering algorithm',23,0,5,6,igl,78)
          call getint('Minimum number of members for subclustering',43,
     -      999999,1,ndim,minsubclust,30)
          write (iout,1011) minsubclust
          if (isubclustertyp .eq. 1) then
            write (iout,1012)
          else if (isubclustertyp .eq. 2) then
            call getreal(
     -        'Maximum percent of density for being on the surface',51,
     -        20.0,surfacepercent,1,79)
            surfacefract=surfacepercent/100.0
            call getreal(
     -        'Distance exponent for local density descriptor',46,
     -        2.0,denexp,0,81)
            denexphalf=denexp/2.0
            write (iout,1013) surfacepercent,denexp
          end if
          do ic=nclust,1,-1
            if (ilclst(ic)-ifclst(ic) .gt. minsubclust) then
              call rmsdsubcluster(ic,ifclst(ic),ilclst(ic),index2d,
     -          ixclst,ifa_s,ila_s,rdclust,isubclustertyp,
     -          surfacefract,denexphalf,it1,it2,indexa,ih,it4,value,
     -          cv,iout,nclustic,label,llabel)
              if (nclustic .gt. 1) then
                write (iout,2065) ic,nclustic
                write (6,2065) ic,nclustic
c               Adjust cluster limits
                do icc=nclust,ic+1,-1
                  ifclst(icc)=ifclst(icc-(nclustic-1))
                  ilclst(icc)=ilclst(icc-(nclustic-1))
                end do
                do icc=1,nclustic
                  ifclst(ic+icc-1)=ifa_s(icc)
                  ilclst(ic+icc-1)=ila_s(icc)
                end do
                call sortlist(iout,index2d,ilclst(nclust),it1,it2,'IX2',
     -            1,mx2d)
                call reportclust(ndim,ic,ic,ic+nclustic-1,ifclst,ilclst,
     -            index2d,value,it1,ifa_s,ila_s,ih,cv,indexa,irepav,
     -            irepmx,irepeng,irepkm,engcl,nhbdist,etotsaved,
     -            ietotsaved,ifindbestrep,label,llabel,isorttype,
     -            idistprint,nomemprint,iout,maxframe,mx2d)
                print *,'ic=',ic,' IREPMX=',irepmx(ic)
              else
                write  (iout,*) 'None of the clusters split up'
                write  (6,*) 'None of the clusters split up'
              end if
            end if
          end do
        end if
      end if
      if (ilabel2d .eq. 1 .and. iclstyp .ne. 3) then
        write (iout,1021)
        do ic=1,nrdclust
          do i=ifclst(ic),ilclst(ic)
            lmemlab=0
            if (i .eq. ifclst(ic)) then
              memlab(1:6)=' FIRST'
              lmemlab=6
            end if
            if (ixclst(i) .eq. irepav(ic)) then
              memlab(lmemlab+1:lmemlab+6)=' AVMIN'
              lmemlab=lmemlab+6
            end if
            if (ixclst(i) .eq. irepmx(ic)) then
              memlab(lmemlab+1:lmemlab+6)=' MXMIN'
              lmemlab=lmemlab+6
            end if
            call lastchar(label2d(ixclst(i)),llab,llabel2d)
            write (iout,1020) ic,ixclst(i),label2d(ixclst(i))(1:llab),
     -        memlab(1:lmemlab)
          end do
        end do
      end if
      call askyn('Do you want to run more clustering',34,1,-1,
     -  ians,0)
      if (ians .eq. 1) then
        call trnsfi(index2d,it2d,ndim)
        go to 8910
      end if
      return
1000  format(a,i8)
1010  format(' <R>=',f8.1)
1011  format(' Subclustering clusters containing at least',i4,
     -  ' members')
1012  format(' Subclustering ignores members with the ',
     -  'smallest number of neighbors')
1013  format(' Subclustering ignores members whose local density is ',
     -  'less than ',f5.1,' %',/,' of the maximum local density',/,
     -  ' Local density is the sum of 1/rij^',f3.1)
1014  format(a,' cutoff for clustering')
1015  format('Cutoff # ',i2)
1016  format(' Cutoff list: ',5f10.5)
1017  format(i6,' (',i6,') : ',5(i4,'.'))
1018  format(1x,a,1x,a)
1019  format(/,' In the list below, each line corresponds to one ',
     -  'clustered item',/,' For  ( N ) i1. i2. i3. i4. i5., N is the ',
     -  ' original index of this item,'/,' i1 is the cluster number N ',
     -  ' belongs to, obtained with cutoff #1; ',/,' i2 is the ',
     -  'cluster number of N within cluster i1, obtained with cutoff ',
     -  '#2;',/,' i3 is the cluster number of N within cluster i2, ',
     -  'obtained with cutoff #3; etc.',/
     -  ' <R> is the average rank of the cluster members',/)
1020  format(' Cluster #',i5,' member #',i5,1x,a,a)
1021  format(/,' List of cluster member labels read from the distance ',
     -  'matrix file')
1022  format(' REP: ',a)
1023  format(' Cluster rank averages and representatives are obtained ',
     -  'at cutoff level',i2)
1024  format(' Directory ',a,' is not found',/,
     -  ' Create the directory and try again')
1025  format(' S R=',i5)
2060  format(/,' Clustering method: ',a,/,
     -  ' Number of items to cluster=',i6)
2061  format(' Number of clusters requested=',i5)
2062  format(' Clusters are reported in the order of increasing ',
     -  'average indices (<rank>)')
2065  format(' Cluster ',i4,' partitioned into',i3,' subclusters')
2066  format(1x,a,' threshold resulting in ',i3,' clusters=',f6.2)
2090  format(1x,a,' threshold=',f9.2,' number of clusters=',i4)
2092  format(' Clustering with ',a,' threshold=',f8.3,' A',/)
2093  format(' Clustering into ',i4,' sets. Range of RMSDs: [',
     -  f8.2,',',f8.2,']'/)
2094  format(' Clustering failure: instead of',i4,' clusters',i4,
     -  ' was generated')
      end
      subroutine clusterplot(ips,xtraj,value,ifirst,ilast,ncl,ixclst,
     -  nframe,trajfile,ltrajfile,xtrajlab,lxtrajlab,ipspage,noclose,
     -  mx2d)
      dimension xtraj(mx2d),value(mx2d),ifirst(mx2d),ilast(mx2d),
     -  ixclst(mx2d)
      character*200 trajfile
      character*(*) xtrajlab
c     Plot the history of cluster membership
c     print *,'CLUSTERPLOT ncl=',ncl,' nframe=',nframe,' ips=',ips
      if (nframe .gt. mx2d) then
        write (6,1000) nframe,mx2d
        return
      end if
      do ic=1,ncl
        do ia=ifirst(ic),ilast(ic)
          if (ixclst(ia) .lt. 1 .or. ixclst(ia) .gt. nframe) then
            print *,'CLUSTER ERROR ic,ia,ixclst(ia)=',ic,ia,ixclst(ia)
          else
            value(ixclst(ia))=ic
          end if
        end do
      end do
      iprt=0
      call plot2fun(ips,1,xtraj,value,value,nframe,0.0,0.0,0,0.0,
     -  1.0,ncl+1,0.0,0.0,0,'Cluster membership',18,' ',0,
     -  xtrajlab,lxtrajlab,'Cluster #',9,' ',0,trajfile,ltrajfile,iprt,
     -  6,1,1,0,0,0,0,ipspage,noclose,1,1)
      return
1000  format(' PROGRAM ERROR in CLUSTERPLOT: nframe (',i8,') > ',
     -  'max2d (',i5,')')
      end
      subroutine rmsdcluster(rmsdclust,nfrst,n,index2d,iwt,iclst,
     -  ifirst,ilast,it1,it2,it3,it4,it5,c,cent,cent_prev,icent_fin,
     -  maxct,iclstyp,idenclstyp,nnmin,nofcls,nosortindex2d,iuseindex2d,
     -  ifail,ntry,label,llabel,iout,igl)
      dimension index2d(n),iwt(n),iclst(n),ifirst(n),ilast(n),it1(n),
     -  it2(n),it3(n),it4(n),it5(n),c(3,n),cent(3,maxct),
     -  cent_prev(3,maxct),icent_fin(maxct)
      character*(*) label
      parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
      parameter (IFILL21=MAXPHI*MAXPHI*MAXPHI-
     -  (9*MAXBONDS+2*MAX2D+2*MAX2D*MAX2D))
      common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),ing(MAX2D,MAX2D),
     -  ihbpair(2,MAXBONDS),ihb_pair_res(3,MAXBONDS),ihbtores(MAXBONDS),
     -  iusepair(MAXBONDS),t1(MAXBONDS),w(MAXBONDS),nng2r(MAX2D),
     -  fill(IFILL21)
      dimension icent(MAX2D),icent0(MAX2D),index2dd(MAX2D),
     -  iorder(MAXBONDS),t2(MAXBONDS)
c     Set up neighbor list based on the threshold
c     print *,'RMSDCLUSTER iout,n,iclstyp,MX2D=',iout,n,iclstyp,MAX2D
c     print *,'RMSDCLUSTER iclstyp,idenclstyp,nnmin=',iclstyp,idenclstyp,nnmin
c     write (40,*)'RMSDCLUSTER  nfrst,n,iclstyp=',nfrst,n,iclstyp
c     write (40,*)'RMSDCLUSTER  RMSDCLUST=',rmsdclust
c      write (40,7934) (index2d(i),i=1,n)
c7934  format(' RMSDCLUSTER INDEX2D=',15i4)
      ifail=0
      sdmin=100000.0
      sdmax=0.0
      nofcls_t=0
      if (nfrst .gt. n) then
        print *,'PROGRAM ERROR: nfrst > n - nfrst=',nfrst,' n=',n
        stop
      end if
      if (n .gt. MAXBONDS) then
        write (6,1001) 
        stop
      end if
      if (nfrst .eq. n) then
c        Cluster has one element
         nofcls=1
         iclst(n)=n
         ifirst(1)=n
         ilast(1)=n
         return
      end if
      call zeroiti(nng,0,n)
      if (iclstyp .eq. 9) call zeroiti(nng2r,0,n)
      if (iuseindex2d .eq. 1) then
        call trnsfi(index2dd,index2d,n)
      else
        call indexit(index2dd,1,n,0)
      end if
      rmsdclust4=rmsdclust*4.0
      do ii=nfrst,n
        i=index2dd(ii)
        do jj=ii+1,n
          j=index2dd(jj)
          if (rmsd2d(i,j) .lt. sdmin) sdmin=rmsd2d(i,j)
          if (rmsd2d(i,j) .gt. sdmax) sdmax=rmsd2d(i,j)
          if (iclstyp .ne. 4 .and. iclstyp .ne. 5) then
            if (rmsd2d(i,j) .lt. rmsdclust) then
              nng(ii)=nng(ii)+1
              nng(jj)=nng(jj)+1
              ing(nng(ii),ii)=jj
              ing(nng(jj),jj)=ii
            end if
          end if
          if (iclstyp .eq. 9) then
            if (rmsd2d(i,j) .lt. rmsdclust4) then
              ing(MAX2D-nng2r(ii),ii)=jj
              ing(MAX2D-nng2r(jj),jj)=ii
              nng2r(ii)=nng2r(ii)+1
              nng2r(jj)=nng2r(jj)+1
            end if
          end if
        end do
      end do
      write (6,1002) sdmin,sdmax
      write (iout,1002) sdmin,sdmax
      if (iclstyp .eq. 8 .and. nosortindex2d .eq. 0) then
c       Clique-clustering - sort lists
c       Sort iorder by iwt
        nmem=n-nfrst+1
        call indexit(iorder,1,n,0)
        do ii=nfrst,n
          t2(ii-nfrst+1)=-float(iwt(ii))
        end do
        call mrgsrt(6,iorder(nfrst),t2,nmem,it2,it3,it4,t1,nmem)
c       Sort neighbors by iwt
        do i=nfrst,n
          if (nng(i) .gt. 1) then
            do ii=1,nng(i)
              t2(ii)=-float(iwt(ing(ii,i)))
            end do
            call mrgsrt(6,ing(1,i),t2,nng(i),it2,it3,it4,t1,nng(i))
          end if
        end do
      end if
c      do ii=nfrst,n
c        i=index2dd(ii)
c        write (40,8967) ii,i,(rmsd2d(i,index2dd(j)),j=1,n)
c8967    format(' ii,i=',2i5,' RMSD2D:',15f5.2,/,(15f5.2))
c        write (40,8968) ii,i,(ing(jj,ii),jj=1,nng(ii))
c8968    format(' ii,i=',2i5,' ING:',15i4,/,(14i4))
c      end do
c      do i=1,n
c        write (6,8701) i,nng(i),(ing(j,i),j=1,nng(i))
c8701    format(i4,' nn=',i4,' in=',10i5)
c      end do
      if (sdmin .eq. 0.0) then
        if (ntry .lt. 2)
     -    write (6,1000) label(1:llabel),'minimum','some'
      else if (sdmax .eq. 0.0) then
        write (6,1000) label(1:llabel),'maximum','all'
        print *,'Exiting clustering'
        ifail=1
        return
      end if
      if (iclstyp .le. 3) then
c       Single-link clustering
        call clstrs(ing,nng,it1,nfrst,n,iclst,ifirst,ilast,0,nofcls,
     -    it2,0,it2,0,iout,inperr,0,n,n,MAX2D)
      else if (iclstyp .eq. 4) then
c       K-medoids clustering - no COM
        call clstrs_kmedoids(nfrst,n,index2dd,iclst,ifirst,ilast,nofcls,
     -    rmsd2d,icenttyp,w,t1,icent,icent0,it1,it2,it3,it4,it5,
     -    icent_fin,n,n,MAX2D,iout,igl)
        if (maxct .gt. 1) then
c         Extract coordinates of center nodes
          do ic=1,nofcls
            call trnsfr(cent(1,ic),c(1,icent_fin(ic)),3)
          end do
        end if
      else if (iclstyp .eq. 5) then
c       K-means clustering -  COM-based
        call clstrs_kmeans(nfrst,n,index2dd,iclst,ifirst,ilast,nofcls,
     -    rmsd2d,w,t1,icent,it1,it2,it3,it4,it5,c,cent,cent_prev,ifail,
     -    n,n,MAX2D)
        if (ifail .gt. 0) return
      else if (iclstyp .eq. 6 .or. iclstyp .eq. 7) then
        call clstrs_maxnn(ing,nng,nfrst,n,iclst,ifirst,ilast,0,
     -    nofcls,it2,n,n,MAX2D)
      else if (iclstyp .eq. 8) then
c       Clique-based clustering
        iverb=1
        iout_c=iout
c       iout_c=6
        call clstrs(ing,nng,it1,nfrst,n,iclst,ifirst,ilast,0,nofcls,
     -    iorder,1,it2,1,iout_c,inperr,iverb,n,n,MAX2D)
      else if (iclstyp .eq. 9) then
        call clstrs_density(nfrst,n,iclst,ifirst,ilast,nofcls,nofcls_t,
     -    nng,ing,nng2r,idenclstyp,nnmin,it1,it2,it3,it4,t1,w,MAX2D,
     -    iout)
      end if
c     Sort iclslt within each cluster
c      write (06,9671) 'U',nofcls,(iclst(i),i=1,n)
c9671  format(1x,a,' NCLUST=',i4,' ICLST:',/,(20i4))
      do ic=1,nofcls
        nmem=ilast(ic)-ifirst(ic)
        if (nmem .ge. 1) then
          do ia=1,nmem
            t2(ia)=iclst(ia+ifirst(ic)-1)
          end do
          call indexit(it1,1,nmem,0)
          call mrgsrt(6,it1,t2,nmem,it2,it3,it4,t1,nmem)
          do ia=1,nmem
            iclst(ia+ifirst(ic)-1)=t2(ia)
          end do
        end if
      end do
c     Rearrange the elements of index2d in the order of iclst
      do ii=nfrst,n
        if (iclst(ii) .lt. 1) print *,'ii=',ii,' iclst=',iclst(ii)
        it1(ii)=index2d(iclst(ii))
      end do
      call trnsfi(index2d(nfrst),it1(nfrst),n-nfrst+1)
      if (iclstyp .eq. 9) nofcls=nofcls_t
c     print *,'return RMSDCLUSTER'
      return
1000  format(1x,a,1x,a,' is zero - ',a,' items are identical')
1001  format(' ERROR: number of items exceeds limit',/,
     -  ' Redimension the arrays index2dd and iorder to M A X R E C')
1002  format(' Range of the distance measures: [',f10.5,',',f10.5,']')
      end
      subroutine rmsdsubcluster(numclst,nfrst,n,index2d,iclst,ifirst,
     -  ilast,rmsdclust,isubclustertyp,surfacefract,denexphalf,
     -  i1,i2,i3,i4,i5,value,t1,iout,nofcls,label,llabel)
      dimension index2d(n),iclst(n),ifirst(n),ilast(n),value(n),t1(n),
     -  i1(n),i2(n),i3(n),i4(n),i5(n)
      character*(*) label
      parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
      parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
     -  (4*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
      common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),ing(MAX2D,MAX2D),
     -  ihbpair(2,MAXBONDS),a1(MAXBONDS),a2(MAXBONDS),fill(IFILL2)
      dimension ix1(MAX2D)
      data indxidel /0/
c     Break up a cluster by removing low-neighbor number nodes
      write (6,1002) nfrst,n,rmsdclust
      write (iout,1002) nfrst,n,label(1:llabel),rmsdclust
c     First recreate the nn list for the cluster selected in a way
c     to stay within the cluster
      nofcls=0
      call zeroiti(nng,0,n)
      do ii=nfrst,n
        i=index2d(ii)
        do jj=ii+1,n
          j=index2d(jj)
          if (rmsd2d(i,j) .lt. rmsdclust) then
            nng(ii)=nng(ii)+1
            nng(jj)=nng(jj)+1
            ing(nng(ii),ii)=jj
            ing(nng(jj),jj)=ii
          end if
        end do
      end do
      call clstrs(ing,nng,ix1,nfrst,n,iclst,ifirst,ilast,0,nofcls,i2,0,
     -  i2,0,6,inperr,0,n,n,MAX2D)
      if (nofcls .gt. 1) then
        write (6,1004) nofcls
        return
      end if
      call trnsfi(i3,nng,n)
      do while (.true.)
        istart=0
        if (isubclustertyp .eq. 1) then
c         Subclustering by # of neighbors
          call trnsfi(i4,nng,n)
c         Find NN range (singletons excluded)
          nnmax=-1
          nnmin=n+1
          do i=nfrst,n
            if (nng(i) .gt. 0) then
              if (nng(i) .gt. nnmax) nnmax=nng(i)
              if (nng(i) .lt. nnmin) nnmin=nng(i)
            end if
          end do
          if (nnmin .eq. nnmax) then
            write (6,1001) nnmin
            go to 200
          end if
c         Now eliminate all nodes with nnmin neighbors
          write (6,1007) nnmin
          write (iout,1007) nnmin
          ndel=0
          do i=nfrst,n
            if (nng(i) .eq. nnmin) then
              ndel=ndel+1
              i5(ndel)=i
            end if
          end do
          write (6,1003) numclst,n-nfrst+1,nnmin,nnmax
          write (iout,1003) numclst,n-nfrst+1,nnmin,nnmax
        else
c         Subclustering by 'density'
          tmin=100000.0
          tmax=0.0
          do ii=nfrst,n
            i=index2d(ii)
            t1(ii)=0.0
            do jj=nfrst,n
              j=index2d(jj)
              if (i .ne. j) t1(ii)=t1(ii)+1.0/rmsd2d(i,j)**denexphalf
            end do
            if (tmin .gt. t1(ii)) tmin=t1(ii)
            if (tmax .lt. t1(ii)) tmax=t1(ii)
          end do
          ndel=0
          do i=nfrst,n
            if (t1(i) .lt. surfacefract*tmax) then
              ndel=ndel+1
              i5(ndel)=i
            end if
          end do
          write (6,1009) numclst,n-nfrst+1,tmin,tmax
          write (iout,1009) numclst,n-nfrst+1,tmin,tmax
        end if
c       i5 has the list of nodes to delete
        write (6,1010) (index2d(i5(i)),i=1,ndel)
        write (iout,1010) (index2d(i5(i)),i=1,ndel)
        do i=1,ndel
          id=i5(i)
          do in=1,nng(id)
            idel=ing(in,id)
            do jn=1,nng(idel)
              if (ing(jn,idel) .eq. id) then
                indxidel=jn
                go to 100
              end if
            end do
100         ing(indxidel,idel)=ing(nng(idel),idel)
            nng(idel)=nng(idel)-1
          end do
          nng(id)=0
        end do
        call clstrs(ing,nng,i1,nfrst,n,iclst,ifirst,ilast,0,nofcls,
     -    i2,0,i2,0,6,inperr,0,n,n,MAX2D)
c       Count the number of non-singleton clusters
        nsingl=0
        do ic=1,nofcls
          if (ifirst(ic) .eq. ilast(ic)) then
            nsingl=nsingl+1
          end if
        end do
        nofcls=nofcls-nsingl
        write (6,1005) nofcls
        nc=0
        if (nofcls .gt. 1) then
          do ic=1,nofcls+nsingl
            if (ifirst(ic) .lt. ilast(ic)) then
              nc=nc+1
              i5(nc)=ilast(ic)-ifirst(ic)+1
            end if
          end do
        end if
        if (nc .gt. 0) write (6,1006) (i5(i),i=1,nc)
        call askyn('Do you want to shave more nodes',31,
     -    1,-1,moreshave,0)
        if (moreshave .eq. 0) go to 200
      end do
200   if (nofcls .gt. 1) then
c       Add back to the real clusters the deleted nodes
        call zeroiti(i5,0,n)
        do ic=1,nofcls
          if (ifirst(ic) .lt. ilast(ic)) then
            do ia=ifirst(ic),ilast(ic)
             i5(ia)=ic
            end do
          end if
        end do
c       Now i5 is the cluster number of a remaining node or zero
        do ia=nfrst,n
          if (i5(ia) .eq. 0) then
c           Find a remaining neighbor, assign ia to its cluster
            do ja=1,i3(ia)
              if (i5(ing(ja,i3(ia))) .ne. 0) then
                i5(ia)=i5(ing(ja,i3(ia)))
                go to 300
              end if
            end do
300         continue
          end if
        end do
c       Now, recluster the nodes based on i5
        call indexit(i1,1,n,0)
        nmem=n-nfrst+1
        do ia=1,nmem
          value(ia)=i5(ia+nfrst-1)
        end do
        call mrgsrt(6,i1,value,nmem,i2,i3,i5,t1,nmem)
        ic=1
        ifirst(ic)=nfrst
        icprev=value(1)
        do ia=nfrst,n
          ia0=ia-nfrst+1
          iclst(ia)=i1(ia0)
          if (value(ia0) .ne. icprev) then
            ilast(ic)=ia-1
            ic=ic+1
            ifirst(ic)=ia
          end if
        end do
        ilast(ic)=n
        if (ic .ne. nofcls) write (6,1000) nofcls,ic
c       Finally, rearrange the elements of index2d in the order of iclst
        do ia=nfrst,n
          i1(ia)=index2d(iclst(ia))
        end do
        call trnsfi(index2d(nfrst),i1(nfrst),n-nfrst+1)
      end if
      return
1000  format(' PROGRAM ERROR in rmsdsubcluster nofcls=',i5,' ic=',i5)
1001   format(' All nodes have the same number of neighbors (',i5,
     -  ') - can not subcluster')
1002  format(' Subclustering structures [',i6,' - ',i6,
     -  '] with ',a,' threshold=',f5.2)
1003  format(' Cluster #',i4,' (',i4,' members): minimum and maximum ',
     -  '# of neighbors=',2i5)
1004  format(' PROGRAM ERROR: invalid subclustering - nofcls=',i4)
1005  format(' Number of subclusters found=',i4)
1006  format(' Number of members in the subclusters found=',5i5,/(10i5))
1007  format(' Temporarily deleting members with only',i3,' neighbours')
1009  format(' Cluster #',i4,' (',i4,' members): local density ',
     -  'min/max=',2f10.5)
1010  format(' Temporarily deleting:',10i5)
      end
      subroutine reportclust(ndim,icl0,nfclst,nlclst,ifclst,ilclst,
     -  index2d,value,it1,ifa_s,ila_s,ih,cv,indexa,irepav,irepmx,
     -  irepeng,irepkm,engcl,nhbdist,etotsaved,ietotsaved,ifindbestrep,
     -  label,llabel,isorttype,idistprint,nomemprint,iout,maxframe,mx2d)
      dimension it1(mx2d),ifclst(mx2d),ilclst(mx2d),index2d(mx2d),
     -  indexa(mx2d),value(mx2d),ifa_s(mx2d),ila_s(mx2d),ih(mx2d),
     -  irepav(mx2d),irepmx(mx2d),irepeng(mx2d),irepkm(mx2d),
     -  nhbdist(mx2d),cv(mx2d),engcl(mx2d),etotsaved(2,maxframe)
      character*(*) label
      parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
      parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
     -  (9*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
      common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),ing(MAX2D,MAX2D),
     -  ihbpair(2,MAXBONDS),ihb_pair_res(3,MAXBONDS),ihbtores(MAXBONDS),
     -  iusepair(MAXBONDS),ixrank(MAXBONDS),rankav(MAXBONDS),
     -  fill(IFILL2)
      data emax /0.0/
c     print *,'REPORTCLUST nfclst,nlclst,isorttype,ifindbestrep=',
c    -  nfclst,nlclst,isorttype,ifindbestrep
c      write (77,8822) (index2d(i),i=1,ilclst(nlclst))
c8822  format(' index2d:',25i5)
      nclust=nlclst-nfclst+1
      do ic=nfclst,nlclst
        ixsum=0
        do i=ifclst(ic),ilclst(ic)
          ixsum=ixsum+index2d(i)
        end do
        nmem=ilclst(ic)-ifclst(ic)+1
        rankav(ic)=float(ixsum)/float(nmem)
      end do
      call indexit(ixrank,1,nclust,0)
      call mrgsrt(6,ixrank,rankav(nfclst),nclust,ifa_s,ila_s,ih,cv,
     -  max2d)
      do icc=1,nclust
        ifa_s(icc)=ifclst(ixrank(icc)+nfclst-1)
        ila_s(icc)=ilclst(ixrank(icc)+nfclst-1)
      end do
      do ic=nfclst,nlclst
        ifclst(ic)=ifa_s(ic-nfclst+1)
        ilclst(ic)=ila_s(ic-nfclst+1)
      end do
      iout_term=6
      if (nlclst-nfclst .gt. 9) then
        iout_term=0
        print *,'Cluster characteristics are printed on the .rd2 file ',
     -    'only'
      end if
      do ic=nfclst,nlclst
        nmem=ilclst(ic)-ifclst(ic)+1
        if (nomemprint .eq. 0)
     -    write (iout,2090) ic,nmem,rankav(ic)
        if (isorttype .eq. 1) then
c         Sort by increasing member index
          do i=ifclst(ic),ilclst(ic)
            value(i-ifclst(ic)+1)=index2d(i)
          end do
          call indexit(it1,1,nmem,0)
          call mrgsrt(6,it1,value,nmem,ifa_s,ila_s,ih,cv,max2d)
          do i=ifclst(ic),ilclst(ic)
            index2d(i)=value(i-ifclst(ic)+1)
          end do
          i00=ifclst(ic)-1
          i0=0
          do while (i0 .lt. nmem)
            if (nomemprint .eq. 0) write (iout,2091)ic,(index2d(i00+i),
     -        i=i0+1,min0(i0+10,nmem))
            i0=i0+10
          end do
        else if (isorttype .gt. 1) then
c         Sort by decreasing occurrence
          do i=ifclst(ic),ilclst(ic)
            it1(i-ifclst(ic)+1)=index2d(i)
            value(i-ifclst(ic)+1)=-nhbdist(index2d(i))
          end do
          call mrgsrt(6,it1,value,nmem,ifa_s,ila_s,ih,cv,max2d)
          call trnsfi(index2d(ifclst(ic)),it1,nmem)
          i0=0
          do while (i0 .lt. nmem)
            if (nomemprint .eq. 0) write (iout,2091) ic,(it1(i),
     -        i=i0+1,min0(i0+10,nmem))
            i0=i0+10
          end do
        end if
        if (ifindbestrep .eq. 1) then
          call zeroiti(indexa,0,ndim)
          if (label(1:4) .eq. 'RMSD') then
            do i=ifclst(ic),ilclst(ic)
              indexa(index2d(i))=1
            end do
          else
            call indexit(indexa,ifclst(ic),ilclst(ic),0)
          end if
          if (icl0 .eq. 0) then
            call findbestrep(iout,ic,0,ndim,indexa,irepav(ic),
     -        irepmx(ic),label,llabel,iout_term,max2d)
          else
            call findbestrep(iout,icl0,ic,ndim,indexa,irepav(ic),
     -        irepmx(ic),label,llabel,iout_term,max2d)
          endif
          emax=-1.e+32
          if (ietotsaved .gt. 0) then
            emin=1.e+32
            esum=0.0
            do i=ifclst(ic),ilclst(ic)
              etot=etotsaved(1,index2d(i))
              esum=esum+etot
              if (emin .gt. etot) then
                emin=etot
                irepeng(ic)=index2d(i)
              end if
              if (emax .lt. etot) emax=etot
            end do
            engcl(ic)=esum/(ilclst(ic)-ifclst(ic)+1)
          end if
        end if
      end do
      write (6,2095) (ilclst(ic)-ifclst(ic)+1,ic=1,nclust)
      write (iout,2095) (ilclst(ic)-ifclst(ic)+1,ic=1,nclust)
      if (ifindbestrep .eq. 1) then
        if (label(1:4) .eq. 'RMSD') then
          write (iout,2096) 'average RMSD'
          i0=0
          do while (i0 .lt. nclust)
            write (iout,2098) ' clrepa ',
     -        (index2d(irepav(i)),i=i0+1,min0(i0+10,nclust))
            i0=i0+10
          end do
        end if
        write (iout,2097) 'maximum ',label(1:llabel)
        i0=0
        do while (i0 .lt. nclust)
          write (iout,2098) ' clrepm ',
     -      (index2d(irepmx(i)),i=i0+1,min0(i0+10,nclust))
          i0=i0+10
        end do
        write (iout,2089)
        if (ietotsaved .gt. 0 .and. emax .ne. 0.0) then
          write (iout,2096) 'lowest energy'
          i0=0
          do while (i0 .lt. nclust)
            write (iout,2094) ' clrepe ',
     -        (index2d(irepeng(ic)),etotsaved(1,index2d(irepeng(ic))),
     -        ic=i0+1,min0(i0+3,nclust))
            i0=i0+3
          end do
          write (iout,2100) (engcl(ic),ic=1,nclust)
        end if
        nz=0
        do i=1,nclust
          if (irepkm(i) .eq. 0) nz=nz+1
        end do
        if (nz .eq. 0) then
          write (iout,2096) 'k-means clustering centers'
          i0=0
          do while (i0 .lt. nclust)
            write (iout,2098) ' clrepkm',
     -        (index2d(irepkm(i)),i=i0+1,min0(i0+10,nclust))
            i0=i0+10
          end do
        end if
        i0=0
        do while (i0 .lt. nclust)
          write (iout,2098) ' clfrst ',
     -      (index2d(ifclst(i)),i=i0+1,min0(i0+10,nclust))
          i0=i0+10
        end do
        if (idistprint .eq. 1 .and. nlclst-nfclst .gt. 0) then
          do ic=nfclst,nlclst
            if (label(1:4) .eq. 'RMSD') then
              write (iout,2080) ic,
     -          (rmsd2d(irepav(ic),irepav(jc)),jc=nfclst,nlclst)
            else
              write (iout,2092) ic,label(1:llabel),
     -          (rmsd2d(irepmx(ic),irepmx(jc)),jc=nfclst,nlclst)
            end if
          end do
        end if
      end if
      return
2080  format(' RMSDs between <MSD>-based center of cluster',i4,' and ',
     -  /,' the other cluster centers:',/,(10f8.2))
2089  format(/,' First member of each cluster:')
2090  format(/,' Cluster #',i4,' contains ',i4,' members (<rank>=',
     -  f8.1,'):')
2091  format(' clmem ',i4,':',10i6)
2092  format(' Cluster',i4,1x,a,'-based center-center distances:',/,
     -  (10f8.2))
2094  format(a,3(i8,' (',e12.5,')'))
2095  format(/,' Number of members in each cluster:',/,(10i5))
2096  format(/,' Cluster representatives (centers) based on ',a,':')
2097  format(/,' Cluster representatives (centers) based on ',a,a,':')
2098  format(1x,a,':',10i6)
2100  format(/,' Average energy of the cluster members:',/,(5e13.5))
      end
      subroutine countsim(ifclst,ilclst,index,nclust,rmsdsimdefr,
     -  rmsdsim,nsim,iout,mx2d)
      dimension ifclst(mx2d),ilclst(mx2d),index(mx2d),nsim(mx2d)
      parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
      parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
     -  (4*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
      common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),ing(MAX2D,MAX2D),
     -  ihbpair(2,MAXBONDS),a1(MAXBONDS),a2(MAXBONDS),fill(IFILL2)
c     Count the  number of pairs in each cluster that are within rmsdsim
      rmsdsimdef=rmsdsimdefr
      if (rmsdsimdefr .eq. 0.0) rmsdsimdef=1.0
      call getreal('MAXimum RMSD for intra-cluster similarity',41,
     -  rmsdsimdef,rmsdsim,1,86)
      write (iout,1000) nclust,rmsdsim
      do ic=1,nclust
        nsimic=0
        rmsdmin=99999.9
        rmsdmax=0.0
        do ia=ifclst(ic),ilclst(ic)
          do ja=ia+1,ilclst(ic)
            rmsd=rmsd2d(index(ia),index(ja))
            if (rmsd .le. rmsdsim) nsimic=nsimic+1
            if (rmsd .lt. rmsdmin) rmsdmin=rmsd
            if (rmsd .gt. rmsdmax) rmsdmax=rmsd
          end do
        end do
        nsim(ic)=nsimic
        nmem=ilclst(ic)-ifclst(ic)+1
        write (iout,1001) ic,nmem
        if (nmem .gt. 1)
     -    write (iout,1002) rmsdsim,nsimic,
     -      100.0*float(nsimic)/float((nmem*(nmem-1))/2),rmsdmin,rmsdmax
      end do
      return
1000  format(/,' Counting similar members of',i4,' clusters with ',
     -  'similarity RMSD cutoff=',f5.1,' A')
1001  format(' Cluster',i5,' nmem=',i4)
1002  format(8x,'# of member pairs within',f6.1,' A RMSD=',i8,
     -  ' (',f6.2,' % of all pairs)',/,
     -  8x,'RMSD range of all pairs: [',f7.1,',',f7.1,']')
      end
      subroutine countsimx(ifclst1,ilclst1,index1,nclust1,
     -  ifclst2,ilclst2,index2,nclust2,rmsdsim,iout,mx2d)
      dimension ifclst1(mx2d),ilclst1(mx2d),index1(mx2d),
     -  ifclst2(mx2d),ilclst2(mx2d),index2(mx2d)
      parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
      parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
     -  (4*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
      common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),ing(MAX2D,MAX2D),
     -  ihbpair(2,MAXBONDS),a1(MAXBONDS),a2(MAXBONDS),fill(IFILL2)
c     Count the  number of pairs in each cluster that are within rmsdsim
      write (iout,1000) nclust1,nclust2,rmsdsim
      do ic1=1,nclust1
        do ic2=1,nclust2
          nsimic=0
          rmsddmin=1000000.0
          rmsddmax=0.0
          do i1=ifclst1(ic1),ilclst1(ic1)
            do i2=ifclst2(ic2),ilclst2(ic2)
              rmsd=rmsd2d(index1(i1),index2(i2))
              if (rmsd .le. rmsdsim) nsimic=nsimic+1
              if (rmsd .lt. rmsddmin)rmsddmin=rmsd
              if (rmsd .gt. rmsddmax)rmsddmax=rmsd
            end do
          end do
          nmem1=ilclst1(ic1)-ifclst1(ic1)+1
          nmem2=ilclst2(ic2)-ifclst2(ic2)+1
          write (iout,1001) ic1,nmem1,ic2,nmem2
          if (nmem1*nmem2 .gt. 0 .and. min0(nmem1,nmem2) .gt. 1)
     -      write (iout,1002) rmsdsim,nsimic,
     -        100.0*float(nsimic)/float(nmem1*nmem2),rmsddmin,rmsddmax
        end do
        write (iout,*)
      end do
      return
1000  format(' Counting similar members between',i4,' and ',i4,
     -  ' clusters',/,' Similarity RMSD cutoff=',f5.1,' A')
1001  format(' Traj1, cluster',i4,' (nmem=',i4,') and ',
     -  ' Traj2, cluster',i4,' (nmem=',i4,')')
1002  format(3x,'# of Traj1-Traj2 pairs within',f6.1,' A RMSD=',i8,
     -  ' (',f6.2,' % of all pairs)',/,
     -  3x,'RMSD range of all Traj1-Traj2 pairs: [',f7.1,',',f7.1,']')
      end
      subroutine mapclustx(ixtr2,ifclst1,ilclst1,irepmx1,nclust1,
     -  ifclst2,ilclst2,index2,nclust2,nndist,nndistsum,
     -  rmsdmapmax,nframe2,trajnam1,ltrajnam1,trajnam2,
     -  ltrajnam2,iout,mx2d)
      dimension ifclst1(mx2d),ilclst1(mx2d),irepmx1(mx2d),ifclst2(mx2d),
     -  ilclst2(mx2d),index2(mx2d),nndist(mx2d),nndistsum(mx2d)
      character*(*) trajnam1,trajnam2
      parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
      parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
     -  (4*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
      common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),ing(MAX2D,MAX2D),
     -  ihbpair(2,MAXBONDS),a1(MAXBONDS),a2(MAXBONDS),fill(IFILL2)
      dimension rmsddmin(MAX2D),rmsddmax(MAX2D)
      data iclmin /0/
c     Map traj 2 ont clusters of traj1
c     print *,'MAPCLUSTX nclust1,nclust2,iout=',nclust1,nclust2,iout
      write (iout,1004) rmsdmapmax,trajnam1(1:ltrajnam1),
     -  trajnam2(1:ltrajnam2)
      call zeroiti(nndistsum,0,nclust1)
      do ic2=1,nclust2
        do ic1=1,nclust1
          nndist(ic1)=0
          rmsddmax(ic1)=0.0
          rmsddmin(ic1)=1000000.0
        end do
        do ia=ifclst2(ic2),ilclst2(ic2)
          rmsddmn=100000.0
          if (ixtr2 .eq. 2) then
            do ic1=1,nclust1
              if (rmsd2d(irepmx1(ic1),index2(ia)) .lt. rmsddmn) then
                rmsddmn=rmsd2d(irepmx1(ic1),index2(ia))
                iclmin=ic1
              end if
            end do
          else
            do ic1=1,nclust1
              if (rmsd2d(index2(ia),irepmx1(ic1)) .lt. rmsddmn) then
                rmsddmn=rmsd2d(index2(ia),irepmx1(ic1))
                iclmin=ic1
              end if
            end do
          end if
          if (rmsddmn .le. rmsdmapmax)then
            nndist(iclmin)=nndist(iclmin)+1
            if (rmsddmn .lt. rmsddmin(iclmin)) rmsddmin(iclmin)=rmsddmn
            if (rmsddmn .gt. rmsddmax(iclmin)) rmsddmax(iclmin)=rmsddmn
          end if
        end do
        write (iout,1000) ic2,ilclst2(ic2)-ifclst2(ic2)+1,ixtr2,3-ixtr2
        do ic1=1,nclust1
          if (nndist(ic1) .gt. 0) then
            write (iout,1001) nndist(ic1),
     -        float(100*nndist(ic1))/float(ilclst2(ic2)-ifclst2(ic2)+1),
     -        ic1,ilclst1(ic1)-ifclst1(ic1)+1,
     -        ' ',rmsddmin(ic1),rmsddmax(ic1)
            nndistsum(ic1)=nndistsum(ic1)+nndist(ic1)
          else
            write (iout,1001) nndist(ic1),0.0,ic1,
     -        ilclst1(ic1)-ifclst1(ic1)+1
          end if
          write (iout,1005) ic2,irepmx1(ic2),ic1,irepmx1(ic1),
     -      rmsd2d(irepmx1(ic1),irepmx1(ic2))
        end do
      end do
      write (iout,*)
      nmapped=0
      do ic1=1,nclust1
        write (iout,1002) 3-ixtr2,ic1,ixtr2,nndistsum(ic1),
     -    100.0*float(nndistsum(ic1))/float(nframe2)
        nmapped=nmapped+nndistsum(ic1)
      end do
      write (iout,1003) ixtr2,3-ixtr2,nmapped,
     -  100.0*float(nmapped)/float(nframe2)
      return
1000  format(' Mapping cluster',i3,' (# of members=',i4,') of Traj',i2,
     -  ' to clusters of Traj',i2)
1001  format(i6,' members (',f5.1,'%) mapped on Clst',i4,
     -  ' (',i5,' members)',a,'RMSDs: [',f5.1,',',f5.1,']')
1002  format(' Traj',i2,' Clst',i4,': total # of ',
     -  'structures in Traj',i2,' mapped on it:',i5,' (',f5.1,' %)')
1003  format(' Total number of structures in Traj',i2,' mapped on Traj',
     -  i2,':',i4,' (',f5.1,' %)')
1004  format(' Mapping clusters of two trajectories:',/,
     -  ' counting the number of members of cluster A that are within',
     -  f6.2,' A RMSD',/,' of the representative element of cluster B',
     -  /,' Trajectory 1:',a,/,' Trajectory 2:',a)
1005  format(' RMSD between representative element of cluster',i3,' (',
     -  i6,') and',/,' representative element of cluster',i3,' (',i6,
     -  '):',f5.1,' A')
      end
      subroutine residcorr(c1,c2,n,index,ncorr,nframe)
      dimension c1(3,n),c2(3,n),index(ncorr)
      parameter (MAXPHI=400,MAXRCORR=3500)
      parameter (IFILL4=MAXPHI*MAXPHI*MAXPHI-
     -  (2*MAXRCORR*MAXRCORR+17*MAXRCORR))
      real*8 trajcorr,cav1,cav2,cavs1,cavs2
      common /nnwork/ trajcorr(MAXRCORR,MAXRCORR),cav1(3,MAXRCORR),
     -  cav2(3,MAXRCORR),cavs1(MAXRCORR),cavs2(MAXRCORR),
     -  row(MAXRCORR),ifill(IFILL4)
c     print *,'RESIDCORRR nframe,ncorr=',nframe,ncorr
      if (nframe .eq. 1) then
        call zeroitd(cav1,3*ncorr)
        call zeroitd(cav2,3*ncorr)
        call zeroitd(cavs1,ncorr)
        call zeroitd(cavs2,ncorr)
        do ir=1,ncorr
          call zeroitd(trajcorr(1,ir),ncorr)
        end do
      end if
      do ir=1,ncorr
        do k=1,3
          cav1(k,ir)=cav1(k,ir)+c1(k,index(ir))
          cav2(k,ir)=cav2(k,ir)+c2(k,index(ir))
          cavs1(ir)=cavs1(ir)+scprod(c1(k,index(ir)),c1(k,index(ir)))
          cavs2(ir)=cavs2(ir)+scprod(c2(k,index(ir)),c2(k,index(ir)))
        end do
        do jr=1,ir
          trajcorr(ir,jr)=trajcorr(ir,jr)+
     -      scprod(c1(1,index(ir)),c2(1,index(jr)))
          trajcorr(jr,ir)=trajcorr(ir,jr)
        end do
      end do
      return
      end
      subroutine atomdist_sd(c,n,ldist,ndist,nframe)
      dimension c(3,n),ldist(ndist)
      parameter (MAXPHI=400,MAXRCORR=3500)
      parameter (IFILL9=MAXPHI*MAXPHI*MAXPHI-
     -  (2*MAXRCORR*MAXRCORR+11*MAXRCORR))
      real*8 trajdist,cav,cavs
      common /nnwork/ trajdist(MAXRCORR,MAXRCORR),cav(3,MAXRCORR),
     -  cavsng(3,MAXRCORR),cavs(MAXRCORR),ifill(IFILL9)
      real*8 d2
c     print *,'ATOMDIST_SD nframe,ndist=',nframe,ndist
      if (nframe .eq. 1) then
        call zeroitd(cav,3*ndist)
        call zeroitd(cavs,ndist)
        do ir=1,ndist
          call zeroitd(trajdist(1,ir),ndist)
        end do
      end if
      do ir=1,ndist
        do k=1,3
          cav(k,ir)=cav(k,ir)+c(k,ldist(ir))
          cavs(ir)=cavs(ir)+scprod(c(1,ldist(ir)),c(1,ldist(ir)))
        end do
        do jr=1,ir
          d2=dist2(c(1,ldist(ir)),c(1,ldist(jr)))
          trajdist(ir,jr)=trajdist(ir,jr)+d2
          trajdist(jr,ir)=trajdist(jr,ir)+dsqrt(d2)
        end do
      end do
      return
      end
      subroutine normalmodes(ncorr,inpt,trajnam,ltrajnam,nframe,
     -  inptyp,iout,iannout,ierr,index,value,ifa,ila,itemp,temp,maxt)
c     Calculate the normal modes from the residue correlation matrix
      character*(*) trajnam
      dimension index(maxt),value(maxt),ifa(maxt),
     -  ila(maxt),itemp(maxt),temp(maxt)
      parameter (MAXPHI=400,MAXRCORR=3500)
      parameter (IFILL4=MAXPHI*MAXPHI*MAXPHI-
     -  (2*MAXRCORR*MAXRCORR+17*MAXRCORR))
      real*8 trajcorr,diag,offdiag,diagfill,drow,drowfill,cavs1,cavs2
      common /nnwork/ trajcorr(MAXRCORR,MAXRCORR),
     -  drow(MAXRCORR),drowfill(2,MAXRCORR),
     -  diag(MAXRCORR),offdiag(MAXRCORR),diagfill(MAXRCORR),
     -  cavs1(MAXRCORR),cavs2(MAXRCORR),row(MAXRCORR),ifill(IFILL4)
      character*80 lineinp
c     print *,'NORMALMODES inpt=',inpt,' inptyp=',inptyp
c     Read in the covariance matrix
      ierr=1
      rewind inpt
      if (inptyp .eq. 0) then
c       Read matrix from the temp file written by Simulaid
        do jr=1,ncorr
          read (inpt,end=999) (drow(ir),ir=1,ncorr)
          do ir=1,ncorr
            trajcorr(ir,jr)=drow(ir)
          end do
        end do
      else if (inptyp .eq. 1) then
c       Binary
        read (inpt,end=100,err=100) ncorr
        do i=1,ncorr
          read (inpt,end=101,err=101) (row(j),j=1,ncorr)
          do j=1,ncorr
            trajcorr(i,j)=row(j)
          end do
        end do
      else
c       Ascii
        read (inpt,1005,end=100,err=100) lineinp
        call lastchar(lineinp,lc,80)
        ic=1
        if (lineinp(ic:ic) .eq. '#') ic=2
        read (lineinp(ic:lc),*,end=100,err=100) ncorr
        if (inptyp .eq. 2 .and. ncorr .gt. 3000) then
          print *,'Change format 2006 in subroutine normalmodes'
          stop
        end if
        do i=1,ncorr
          if (inptyp .eq. 3) then
            read (inpt,1004,end=101,err=101) (trajcorr(i,j),j=1,ncorr)
          else
            read (inpt,1006,end=101,err=101) (trajcorr(i,j),j=1,ncorr)
          end if
        end do
      end if
      ierr=0
c     write (77,*) 'ncorr=',ncorr
c     do i=1,ncorr
c       write (77,1004) (trajcorr(i,j),j=1,ncorr)
c     end do
      call dtred2(trajcorr,ncorr,MAXRCORR,diag,offdiag)
      call dtqli(diag,offdiag,ncorr,MAXRCORR,trajcorr,ierr)
      if (ierr .gt. 0) then
        write (6,1007)
        write (iout,1004)
        return
      end if
c     Print normal modes
c     Columns of trajcorr are the eigenvectors
      call askyn('Do you want to sort by eigenvalues',34,1,-1,isortev,0)
      call indexit(index,1,ncorr,0)
      if (isortev .eq. 1) then
        do i=1,ncorr
          value(i)=-diag(i)
        end do
        call mrgsrt(6,index,value,ncorr,ifa,ila,itemp,temp,maxt)
      end if
      if (iannout .eq. 1) then
        if (inptyp .eq. 0) write (iout,1001) trajnam(1:ltrajnam),nframe
        do jjr=1,ncorr
          jr=index(jjr)
          write (iout,1002) jjr,diag(jr),(trajcorr(ir,jr),ir=1,ncorr)
        end do
      else
        do jjr=1,ncorr
          jr=index(jjr)
          write (iout,1003) diag(jr),(trajcorr(ir,jr),ir=1,ncorr)
        end do
      end if
      return
999   write (6,1000) jr
      return
100   print *,'Input covariance matrix is empty'
      return
101   print *,'Input covariance matrix read aborted at row ',i
      return
1000  format(' ERROR: residue correlation matrix of file trajcorr.mat',
     -  ' is incomplete',/,' Reading column ',i5,/,
     -  ' Normal mode calculation is skipped')
1001  format(/,' Eigenvalues and eigenvectors of the covariance ',
     -  'matrix',/,' Trajectory file:',a,/,' Number of frames used=',i8)
1002  format(i6,' Eigenvalue=',e12.5,' eigenvector:',/,(5e13.5))
1003  format(3000e13.6)
1004  format(5e13.6)
1005  format(a)
1006  format(3000e13.6)
1007  format(' Calculation aborted due to diagonalization failure')
      end
      subroutine plotresidcorr(ncorr,nframe,index,indexr,
     -  ncol,maxcol,nrep,iout,iplt,xm,ym,title,ltitle,
     -  filename,lfilename,ipspage,iucorrmat,icovmatplot,temp,maxtemp)
      dimension index(ncorr),indexr(ncorr)
      character*(*) title,filename
      dimension temp(maxtemp)
      parameter (MAXPHI=400,MAXRCORR=3500)
      parameter (IFILL4=MAXPHI*MAXPHI*MAXPHI-
     -  (2*MAXRCORR*MAXRCORR+17*MAXRCORR))
      real*8 trajcorr,cav1,cav2,cavs1,cavs2
      common /nnwork/ trajcorr(MAXRCORR,MAXRCORR),cav1(3,MAXRCORR),
     -  cav2(3,MAXRCORR),cavs1(MAXRCORR),cavs2(MAXRCORR),
     -  row(MAXRCORR),ifill(IFILL4)
      real*8 ddot
      dimension mx(1,1),rx(1,1),ixshuffle(MAXRCORR)
      character*4 yclab(1)
      data nyclab /1/,lyclab /1/
      call indexit(ixshuffle,1,MAXRCORR,0)
      write (iout,1000) ncorr,nframe,(index(ir),ir=1,ncorr)
      write (iout,1005) filename(1:lfilename)
      do ir=1,ncorr
        do k=1,3
          cav1(k,ir)=cav1(k,ir)/nframe
          cav2(k,ir)=cav2(k,ir)/nframe
        end do
        cavs1(ir)=cavs1(ir)/nframe
        cavs2(ir)=cavs2(ir)/nframe
      end do
      rcmax=-100000.0
      rcmin=-rcmax
      do ir=1,ncorr
        do jr=1,ncorr
          trajcorr(ir,jr)=(trajcorr(ir,jr)/nframe-
     -      ddot(cav1(1,ir),cav2(1,jr)))
          if (trajcorr(ir,jr) .lt. rcmin) rcmin=trajcorr(ir,jr)
          if (trajcorr(ir,jr) .gt. rcmax) rcmax=trajcorr(ir,jr)
        end do
      end do
      write (iout,1004) rcmin,rcmax
      do ir=1,ncorr
        if (rcmin .lt. 10000.0 .or. rcmax .gt. 10000.0) then
          write (iout,1003) (trajcorr(ir,jr),jr=1,ncorr)
        else
          write (iout,1002) (trajcorr(ir,jr),jr=1,ncorr)
        end if
      end do
c     Save the covariance matrix for eigenvalue calculation
      if (iucorrmat .gt. 0) then
        call openfile(iucorrmat,0,'log',3,'new','trajcorr.mat',12,
     -      notfnd,0,2,1,0,0)
        do jr=1,ncorr
          write (iucorrmat) (trajcorr(ir,jr),ir=1,ncorr)
        end do
      end if
      inc=max0(1,500/ncorr)
      scalefac=amin1(1.0,500.0/float(ncorr))
      iydel=150
      if (icovmatplot .eq. 1) then
        call plotmat(iplt,mx,rx,trajcorr,ncorr,ncorr,0,0,0,0,1,nrep,25,
     -    iydel,0,iytop,rcmin,rcmax,ncol,maxcol,ixdelsh,iydelsh,inc,
     -    scalefac,indexr,ixshuffle,ixshuffle,title,ltitle,' ',0,' ',1,
     -    temp,yclab,nyclab,lyclab,0,1,1,MAXRCORR,MAXRCORR,MAXRCORR,
     -    ipspage,0)
        iydel=iydel-50
        call rainbowscale(iplt,ixdelsh,450,iydel,0,0.0,rcmin,rcmax,
     -    'Covariance',10)
        call plothead(iplt,xm,ym-15,title,ltitle,
     -    'Residue covariance matrix',25,filename,lfilename,filename,0)
        write (iplt,*) 'showpage'
      end if
      do ir=1,ncorr
        cavs1(ir)=dsqrt(dabs(trajcorr(ir,ir)))
      end do
      do ir=1,ncorr
        do jr=1,ir-1
          trajcorr(ir,jr)=trajcorr(ir,jr)/(cavs1(ir)*cavs1(jr))
          trajcorr(jr,ir)=trajcorr(jr,ir)/(cavs1(ir)*cavs1(jr))
        end do
      end do
      do ir=1,ncorr
        trajcorr(ir,ir)=1.d0
      end do
      write (iout,*) 'The correlation matrix:'
      do ir=1,ncorr
        write (iout,1001) (trajcorr(ir,jr),jr=1,ncorr)
      end do
      iydel=150
      call plotmat(iplt,mx,rx,trajcorr,ncorr,ncorr,0,0,0,0,1,nrep,25,
     -  iydel,0,iytop,-1.0,1.0,ncol,maxcol,ixdelsh,iydelsh,inc,scalefac,
     -  indexr,ixshuffle,ixshuffle,title,ltitle,' ',0,' ',1,temp,
     -  yclab,nyclab,lyclab,0,1,1,MAXRCORR,MAXRCORR,MAXRCORR,ipspage,0)
      iydel=iydel-50
      call rainbowscale(iplt,ixdelsh,450,iydel,0,0.0,-1.0,1.0,
     -  'Correlation',11)
      call plothead(iplt,xm,ym-15,title,ltitle,
     -  'Residue correlation matrix',26,filename,lfilename,filename,0)
      return
1000  format(' Residue covariances and correlations over',i5,
     -  ' residues',/,' Number of structures used=',i6,/,
     -  ' Atomindices used for the calculation:',/,(10i6))
1001  format(10f8.4)
1002  format(10f8.2)
1003  format(5e12.5)
1004  format(' The covariance matrix (min=',e12.5,' max=',e12.5,'):')
1005  format(' Trajectory file: ',a)
      end
      subroutine clstrs(ineig,nneig,nnloop,n0,n,iclst,ifirst,ilast,
     -  nofcls0,nofcls,iorder,iuseorder,iused,iclique,iout,inperr,iverb,
     -  maxat,maxgr,maxneig)
c#    MMC routine 462 lstmod: 07/15/02; clicque option added
c*****Find all clusters in a network and sort atoms in a cluster by groups
      dimension ineig(maxneig,maxat),nneig(maxat),iclst(maxat),
     -  ifirst(maxgr),ilast(maxgr),nnloop(maxat),iorder(maxat),
     -  iused(maxat)
c     Input parameters:
c     n0,n: Use atomnumbers (vertices) from n0 to n (inclusive)
c     maxat,maxneig,maxgr: Array sizes - see dimension statement above
c     nneig(i) : number of neighbours (bonded) of molecule i
c     ineig(j,i) : j-th neighbour of atom i
c     Workspace arrays:
c     iused(i) : 1 - atom i is not accounted for yet
c                0 - atom i is already accounted for
c     nnloop (i) : copy of nneig in loops 1 and 2 (temporary storage)
c                  the number of loop-closing bonds of atom i thereafter
c     Output parameters:
c     nofcls0: Number of disconnected clusters (groups) found previously
c     nofcls: Number of disconnected clusters (groups) found
c     iclst,ifirst,ilast: The elements of the ig-th group are atoms
c     (iclst(ia),ia=ifrst(ig),ilast(ig))
c
c     Description of the algorithm:
c     Starting with an atom, the algorithm successively includes its
c     neighbours and then the neighbours of the atoms already on the list.
c     By excluding atoms that 're-occurred' the algorithm essentially generates
c     a spanning tree.
c     Initialization
c     write (iout,*) 'CLSTRS n0,n,nofcls0,iverb=',n0,n,nofcls0,iverb
      jc=0
      do ii=n0,n
        if (iuseorder .eq. 1) then
          i=iorder(ii)
        else
          i=ii
        end if
        nnloop(i)=nneig(i)
        iused(i)=1
        if (iverb .gt. 0)
     -    write (iout,1010) i,nneig(i),(ineig(j,i),j=1,nneig(i))
        do in=1,nneig(i)
          j=ineig(in,i)
          if (j .lt. n0 .or. j .gt. n) then
            write (iout,1013) i,j,n0,n
            return
          end if
          nfound=0
          do jn=1,nneig(j)
            if (ineig(jn,j) .eq. i) nfound=nfound+1
          end do
          if (nfound .ne. 1) then
            write (iout,1011) j,i,i
            write (iout,1010) j,nneig(j),(ineig(k,j),k=1,nneig(j))
            inperr=inperr+1
          end if
        end do
      end do
      nofcls=nofcls0
      if (n .lt. n0) return
      nfound=n0-1
      ifirst(nofcls0+1)=n0
      do i=n0,n
        if (iused(i) .gt. 0) then
c         Start search
c         ncl is the number of elements in the cluster
c         ic is the index of the atom under consideration
c         kroot is the serial no of the lowest element in the cluster
c         that may still have neighbours not examined yet
          ic=i
          ncl=0
          kroot=1
c         NTOTSKIP=0
          do while (kroot .lt. ncl .or. ncl .eq. 0)
            if (iverb .gt. 1) write (iout,1009)
     -        i,kroot,ncl,ic,nnloop(ic),iused(ic)
            do while (ncl .eq. 0 .or. nnloop(ic) .gt. 0)
              if (iused(ic) .gt. 0) then
                if (iclique .eq. 0 .or. ncl .eq. nfound) then
c                 Include ic into the list
                  ncl=ncl+1
                  iused(ic)=0
                  iclst(nfound+ncl)=ic
                  if (iverb .gt. 1)
     -              write (iout,1008) 'Added1',ic,nnloop(ic),ncl,kroot
                else
c                 Check if ic is connected to all members found so far
                  nmatch=0
                  do icc=nfound+1,nfound+ncl
                    do iin=1,nneig(ic)
                      if (iclst(icc) .eq. ineig(iin,ic)) then
                        nmatch=nmatch+1
                        go to 101
                      end if
                    end do
c                   No match - skip
                    go to 102
101                 continue
                  end do
102               if (nmatch .eq. ncl) then
c                   New clique member found
                    ncl=ncl+1
                    iused(ic)=0
                    iclst(nfound+ncl)=ic
                    if (iverb .gt. 1)
     -                write (iout,1008) 'Added',ic,nnloop(ic),ncl,kroot
                  else
                    if (iverb .gt. 1) write (iout,1008)
     -                'Skipped',ic,nnloop(ic),ncl,kroot
                    iused(ic)=-1
c                   NTOTSKIP=NTOTSKIP+1
                  end if
                end if
c                write (iout,8734) (iclst(ii),ii=nfound+1,nfound+ncl)
c8734            format(' Clique so far:',(20i3))
              end if
              if (nnloop(ic) .gt. 0) then
c               Now search for the first unused neighbor of ic
                jc=ineig(nnloop(ic),ic)
                do while (iused(jc) .le. 0 .and. nnloop(ic) .gt. 0)
                  jc=ineig(nnloop(ic),ic)
                  nnloop(ic)=nnloop(ic)-1
                  if (iverb .gt. 1) write (iout,1006)
     -              ic,jc,nnloop(ic),iused(jc),ncl
                end do
                if (iused(jc) .gt. 0) ic=jc
              end if
c             if (NTOTSKIP .gt. 100) stop
            end do
c           Neighbour chain ended, back to the kroot-th atom in the list
            ic=iclst(nfound+kroot)
            if (nnloop(ic) .eq. 0) kroot=kroot+1
            if (iverb .gt. 1) write (iout,1007)
     -          nfound,kroot,ic,jc,nnloop(ic),ncl
          end do
c         Cluster of ncl elements found
c         stop
          nofcls=nofcls+1
          if (iclique .eq. 1) then
            do ii=n0,n
              nnloop(ii)=nneig(ii)
              if (iused(ii) .eq. -1) iused(ii)=1
            end do
          end if
c         memmax=0
c         memmin=10000000
c         do ia=nfound+1,nfound+ncl
c           if (memmax .lt. iclst(ia)) memmax=iclst(ia)
c           if (memmin .gt. iclst(ia)) memmin=iclst(ia)
c         end do
          nfound=nfound+ncl
          ilast(nofcls)=ifirst(nofcls)+ncl-1
          if (nofcls .lt. maxgr) ifirst(nofcls+1)=ilast(nofcls)+1
          if (iverb .gt. 0) write (iout,1005) nofcls,
     -      ifirst(nofcls),ilast(nofcls),ncl
        end if
      end do
      if (iverb .gt. 0) write (iout,*) 'Number of clusters=',nofcls
c     ilast(nofcls)=n
c     il=ifirst(nofcls)+ncl-1
      if (n .ne. ilast(nofcls)) then
        write (iout,1001) ilast(nofcls),n0,n
        inperr=inperr+1
      end if
      return
1001  format(' ***** PROGRAM ERROR in cluster search:',
     -  ' il=',i6,' n0,n=',2i6)
1005  format(' CLSTRS nofcls=',i8,' if,il=',2i6,' ncl=',i5)
1006  format(' CLSTRS ic,jc=',2i5,' nnloop(ic),iused(jc)=',2i3,
     -  ' ncl=',i5)
1007  format(' CLSTRS nfound,kroot=',2i6,' ic,jc,nnloop(ic)=',2i6,i3,
     -  ' ncl=',i5)
1008  format(' CLSTRS ',a,' ic=',i8,' nnloop(ic)=',i2,' ncl,kroot=',2i5)
1009  format(' CLSTRS i,kroot,ncl,ic,nnloop(ic),iused(ic)=',6i8)
1010  format(' CLSTRS ',i5,' nn=',i4,(' in=',15i6))
1011  format(' ***** PROGRAM ERROR: neigbour',i8,' of',i8,' does not ',
     -  'have',i8,' as neighbor exactly once:')
1013  format(' ERROR: index=',i5,' neigbor=',i5,' is outside the ',
     -  '[',i5,',',i5,'] interval')
      end
      subroutine clstrs_kmedoids(n0,n,index2d,iclst,ifirst,ilast,nofcls,
     -  rmsd2d,icenttyp,w,t1,icent,icent0,it1,it2,it3,it4,indxclst,
     -  icent_fin,maxnode,maxgr,mx2d,iout,igl)
c*****Find all clusters in a network and sort atoms in a cluster by groups
      dimension index2d(maxnode),iclst(maxnode),ifirst(maxgr),
     -  ilast(maxgr),it1(maxnode),it2(maxnode),it3(maxnode),
     -  it4(maxnode),indxclst(maxnode),icent_fin(maxgr),icent(mx2d),
     -  icent0(mx2d),rmsd2d(mx2d,mx2d),t1(mx2d),w(mx2d)
      parameter (MAX2D=5000)
      dimension indxmax(MAX2D),indxav(MAX2D),distmax(MAX2D),
     -  distav(MAX2D)
      character*1 ans
      data icminmax /0/,icminav /0/,jmin /0/
c     Input parameters:
c     n0,n: Use atomnumbers (vertices) from n0 to n (inclusive)
c     maxnode,maxgr: Array sizes - see dimension statement above
c     Workspace arrays: it1,it2,it3
c     Output parameters:
c     nofcls: Number of clusters requested
c     iclst,ifirst,ilast: The elements of the ig-th group are atoms
c     (iclst(ia),ia=ifrst(ig),ilast(ig))
c
c     Description of the algorithm:
c     k-means -> k-medoids
c     Cluster centers have to be one of the nodes.
c     The center node has the smallest max dev from the rest of the cluster
c     print *,'CLSTRS_K start n0,n,nofcls,mx2d=',n0,n,nofcls,mx2d
c     Initialization
c      write (6,9671) (index2d(i),i=n0,n)
c9671  format(' CLSTRS_KMEANS INDEX2D:',/,(20i4))
      iverb=1
      nitersave=min0(20,mx2d/nofcls)
      call zeroiti(icent,0,nitersave*nofcls)
      call init_kmedoids(nofcls,index2d,ifirst,ilast,icent,rmsd2d,n0,n,
     -  nnode,ierr,iverb,mx2d)
      call quiz(ans,icenttyp,'r',' ',0,'k-medoids center choice',23,0,
     -  5,6,igl,139)
      if (icenttyp .eq. 1) write (iout,1004) 'smallest maximum distance'
      if (icenttyp .eq. 2) write (iout,1004) 'smallest average distance'
      call sortlist(0,icent,nofcls,it1,it2,'IK0',0,mx2d)
c     print *,'CENT=',(icent(i),i=1,nofcls)
      call zeroiti(indxclst,n0-1,n)
      do ic=1,nitersave
        icent0(ic)=(ic-1)*nofcls
      end do
      nchange=1
      iter=0
      maxiter=max0(5*nofcls,2*(n-n0))
      looping=0
      do while (nchange .gt. 0 .and.
     -          iter .lt. maxiter .and. looping .eq. 0)
        nchange=0
        ic0prev=icent0(mod(iter,nitersave)+1)
        iter=iter+1
        ic0=icent0(mod(iter,nitersave)+1)
c       Find the nearest center to each node
        do i=n0,n
           ii=index2d(i)
          jmin=0
          do j=1,nofcls
            if (i .eq. icent(ic0prev+j)) then
              jmin=j
            end if
          end do
          if (jmin .eq. 0) then
            rmin=10000.0
            do j=1,nofcls
              if (rmin .gt. rmsd2d(ii,index2d(icent(ic0prev+j)))) then
                rmin=rmsd2d(ii,index2d(icent(ic0prev+j)))
                jmin=j
              end if
            end do
          end if
          if (jmin .ne. indxclst(i)) then
            nchange=nchange+1
            indxclst(i)=jmin
          end if
        end do
c       write (6,7711) 'Bef sort indxclst:',(indxclst(i),i=n0,n)
c7711   format(' KMEANS ',a,(/i3,19i4))
        if (nchange .gt. 0) then
c         Find the new centers
          call indexit(it1,1,nnode,0)
          do i=n0,n
            w(i-n0+1)=indxclst(i)
          end do
          call mrgsrt(6,it1,w,nnode,it2,it3,it4,t1,n)
c         write (6,7711) 'aft sort indxclst:',(it1(i),i=1,n-n0+1)
c         write (6,7711) 'aft sort it1:',(it1(i),i=1,n-n0+1)
          ifirst(1)=n0
          wprev=w(1)
          nc=1
          do i=n0,n
            iclst(i)=it1(i-n0+1)
            if (w(i-n0+1) .gt. wprev) then
              wprev=w(i-n0+1)
              ilast(nc)=i-1
              nc=nc+1
              ifirst(nc)=i
            end if
          end do
          ilast(nc)=n
          nchange=0
          if (nc .ne. nofcls) then
            write (6,1001) nc,nofcls
          else
            do ic=1,nofcls
              rminmax=100000.0
              ravmax=100000.0
              ixa=0
              do ia=ifirst(ic),ilast(ic)
                iaa=index2d(iclst(ia))
                rmax=0.0
                rav=0.0
                do ja=ifirst(ic),ilast(ic)
                  if (rmsd2d(iaa,index2d(iclst(ja))) .gt. rmax)
     -              rmax=rmsd2d(iaa,index2d(iclst(ja)))
                    rav=rav+rmsd2d(iaa,index2d(iclst(ja)))
                end do
                if (rminmax .gt. rmax) then
                  rminmax=rmax
                  icminmax=ia
                end if
                rav=rav/float(ilast(ic)-ifirst(ic)+1)
                if (ravmax .gt. rav) then
                  ravmax=rav
                  icminav=ia
                end if
                ixa=ixa+1
                distmax(ixa)=rmax
                distav(ixa)=rav
                indxav(ixa)=ixa
                indxmax(ixa)=ixa
              end do
              nmem=ixa
              if (icenttyp .eq. 1) then
                icent(ic0+ic)=iclst(icminmax)
              else if (icenttyp .eq. 2) then
                icent(ic0+ic)=iclst(icminav)
              else if (icenttyp .eq. 3) then
                call mrgsrt(6,indxmax,distmax,nmem,it2,it3,it4,t1,nmem)
                call mrgsrt(6,indxav,distav,nmem,it2,it3,it4,t1,nmem)
c                write (77,9873) (indxmax(i),i=1,nmem)
c                write (77,9874) (distmax(i),i=1,nmem)
                do ia=1,nmem
                  it2(indxmax(ia))=ia
                  it3(indxav(ia))=ia
                end do
c                write (77,9875) (it2(i),i=1,nmem)
c                write (77,9876) (it3(i),i=1,nmem)
c9873            format(' INDXMAX:',/,(20i5))
c9874            format(' DISTMAX:',/,(20f5.1))
c9875            format(' IT2:',/,(20i5))
c9876            format(' IT3:',/,(20i5))
                icnext=0
                avminindx=2*MAX2D
                do ia=1,nmem
                  av=float(it2(ia)+it3(ia))/2.0
                  t1(ia)=av
                  if (av .lt. avminindx) then
                    avminindx=av
                    icnext=ia
                  end if
                end do
c                write (77,9877) (t1(i),i=1,nmem)
c9877            format(' RAVINDX:',/,(20f5.1))
c                write (77,*) 'ICNEXT=',icnext
                icent(ic0+ic)=iclst(ifirst(ic)-1+icnext)
              end if
            end do
            call mrgsortlist(icent(ic0+1),it1,it2,it3,it4,w,t1,nofcls)
            do ic=1,nnode
              if (icent(ic0prev+ic) .ne. icent(ic0+ic))nchange=nchange+1
            end do
            if (nchange .gt. 0 .and. iter .gt. nitersave) then
              ip=2
              do while (looping .eq. 0 .and. ip .lt. nitersave)
                idiff=0
                ic0prev=icent0(mod(iter-ip,nitersave)+1)
                ip=ip+1
                do ic=1,nofcls
                  if (icent(ic0prev+ic) .ne. icent(ic0+ic)) idiff=1
                end do
                looping=1-idiff
              end do
            end if
          end if
        else
          ic0=icent0(mod(iter-1,nitersave)+1)
        end if
        if (iverb .gt. 0) write (6,1000) iter,(icent(ic0+k),k=1,nofcls)
        do ic=1,nofcls
          icent_fin(ic)=icent(ic0+ic)
        end do
c       do ic=1,nofcls
c         write (6,7721) ic,(iclst(ia),ia=ifirst(ic),ilast(ic))
c7721      format(' ic=',i3,/,(20i4))
c       end do
      end do
      if (nchange .gt. 0 .and. looping .eq. 0) write (6,1002) iter
      if (nchange .gt. 0 .and. looping .eq. 1) write (6,1003) iter
      return
1000  format(' Iteration ',i4,' Centers chosen=',(10i5))
1001  format(' PROGRAM ERROR: nc=',i5,' Number of clusters requested=',
     -  i5)
1002  format(' NOTE: clustering did not converge in',i6,' iterations ',
     -  '- it may be looping')
1003  format(' NOTE: clustering detected looping on the centers found ',
     -  'after',i6,' iterations')
1004  format(' Criterion for cluster center choice: ',a)
      return
      end
      subroutine clstrs_kmeans(n0,n,index2d,iclst,ifirst,ilast,nofcls,
     -  rmsd2d,w,t1,icent,it1,it2,it3,it4,indxclst,c,cent,cent_prev,
     -  ifail,maxnode,maxgr,mx2d)
c*****Find all clusters in a network and sort atoms in a cluster by groups
      dimension index2d(maxnode),iclst(maxnode),ifirst(maxgr),
     -  ilast(maxgr),it1(maxnode),it2(maxnode),it3(maxnode),
     -  it4(maxnode),indxclst(maxnode),c(3,n),cent(3,maxnode),
     -  cent_prev(3,maxnode)
      dimension icent(mx2d),rmsd2d(mx2d,mx2d),t1(mx2d),w(mx2d)
c     Input parameters:
c     n0,n: Use atomnumbers (vertices) from n0 to n (inclusive)
c     maxnode,maxgr: Array sizes - see dimension statement above
c     Workspace arrays: it1,it2,it3
c     Output parameters:
c     nofcls: Number of clusters requested
c     iclst,ifirst,ilast: The elements of the ig-th group are atoms
c     (iclst(ia),ia=ifrst(ig),ilast(ig))
c
c     Description of the algorithm:
c     k-means++
c     Cluster centers are the COM's of the cluster members
c     print *,'CLSTRS_K_COM start n0,n,nofcls=',n0,n,nofcls
c     Initialization
      iverb=0
      call indexit(index2d,1,MAX2D,0)
      do i=1,n
        do j=i+1,n
          rmsd2d(i,j)=dist2(c(1,j),c(1,i))
          rmsd2d(j,i)=rmsd2d(i,j)
        end do
      end do
      call init_kmedoids(nofcls,index2d,ifirst,ilast,icent,rmsd2d,n0,n,
     -  nnode,ierr,iverb,mx2d)
      ifail=0
      do i=1,nofcls
        call trnsfr(cent(1,i),c(1,icent(i)),3)
      end do
      call zeroiti(indxclst,n0-1,n)
      nchange=1
      iter=0
      maxiter=max0(5*nofcls,2*(n-n0))
      do while (nchange .gt. 0 .and. iter .lt. maxiter)
        nchange=0
        iter=iter+1
c       Find the nearest center to each node
        do i=n0,n
          rmin=10000.0
          jmin=0
          do j=1,nofcls
            d2=dist2(cent(1,j),c(1,i))
            if (d2 .lt. rmin) then
              rmin=d2
              jmin=j
            end if
          end do
          if (jmin .ne. indxclst(i)) then
            nchange=nchange+1
            indxclst(i)=jmin
          end if
        end do
c       write (6,7711) 'Bef sort indxclst:',(indxclst(i),i=n0,n)
c7711   format(' KMEANS ',a,(/i3,19i4))
        if (nchange .gt. 0) then
c         Find the new centers
          call trnsfr(cent_prev,cent,3*nofcls)
          call zeroit(cent,3*nofcls)
          call zeroiti(icent,0,nofcls)
          do i=n0,n
            ic=indxclst(i)
            icent(ic)=icent(ic)+1
            do k=1,3
              cent(k,ic)=cent(k,ic)+c(k,i)
            end do
          end do
          do ic=1,nofcls
            if (icent(ic) .gt. 0) then
              do k=1,3
                cent(k,ic)=cent(k,ic)/float(icent(ic))
              end do
            else
              call trnsfr(cent,cent_prev,3*nofcls)
            end if
          end do
        end if
      end do
      call indexit(it1,1,nnode,0)
      do i=n0,n
        w(i-n0+1)=indxclst(i)
      end do
      call mrgsrt(6,it1,w,nnode,it2,it3,it4,t1,n)
c     write (6,7711) 'aft sort indxclst:',(it1(i),i=1,n-n0+1)
c     write (6,7711) 'aft sort it1:',(it1(i),i=1,n-n0+1)
      ifirst(1)=n0
      wprev=w(1)
      nc=1
      do i=n0,n
        iclst(i)=it1(i-n0+1)
        if (w(i-n0+1) .gt. wprev) then
          wprev=w(i-n0+1)
          ilast(nc)=i-1
          nc=nc+1
          ifirst(nc)=i
        end if
      end do
      ilast(nc)=n
      if (nc .ne. nofcls) then
        write (6,1001) nc,nofcls
        ifail=1
      end if
      if (nchange .gt. 0) write (6,1002) iter
c     write (6,1000) iter,(icent(k),k=1,nofcls)
c      do ic=1,nofcls
c       if (ifirst(ic) .le. ilast(ic)) then
c        write (40,7721) ic,(iclst(ia),ia=ifirst(ic),ilast(ic))
c7721     format(' ic=',i3,/,(20i4))
c        else
c          write (40,*) 'Cluster ',ic,' is empty'
c      end do
      return
c1000  format(' Iteration ',i4,' Number of cluster members=',(10i5))
1001  format(' Clustering failure: nc=',i5,
     -  ' Number of clusters requested=',i5,/,' Clustering algorithm ',
     -  'needs extension',/' Try with different starting structure or ',
     -  'use the option where cluster centers are nodes')
1002  format(' NOTE: clustering did not converge in',i6,' iterations ')
      return
      end
      subroutine init_kmedoids(nofcls,index2d,ifirst,ilast,icent,rmsd2d,
     -  n0,n,nnode,ierr,iverb,mx2d)
      dimension index2d(mx2d),icent(mx2d),ifirst(mx2d),ilast(mx2d),
     -  rmsd2d(mx2d,mx2d)
      integer*4 ixo
      common /rangen/ ixo
      dimension ran(1)
      character*31 qcent
c     print *,'INIT_KMEANS n0,n,mx2d=',n0,n,mx2d
      if (nofcls .le. 0 .or. nofcls .gt. n-n0+1) then
        print *,'PROGRAM ERROR: invalid number of clusters requested:',
     -    nofcls
        nofcls=1
        ifirst(1)=n0
        ilast(1)=n
        ierr=1
        return
      end if
      nnode=n-n0+1
      if (nnode .lt. nofcls) then
        print *,'ERROR: can not generate ',nofcls,' clusters from',nnode
        ierr=1
        return
      end if
      ierr=0
      call askyn('Do you want to specify initial cluster centers',46,
     -  1,-1,ireadct,92)
      if (ireadct .eq. 1) then
        do k=1,nofcls
          write (qcent,1001) k
          call getint(qcent,31,999999,1,n,icent(k),00)
        end do
      else
        if (ixo .ne. 1237) then
          call askyn(
     -      'Do you want to reinitialize the random-number seed',
     -      50,1,1,ireinit,92)
          if (ireinit .eq. 1) call randpx_init(1357)
        end if
        call randpx(1,ran)
        icent(1)=n0+ran(1)*nnode
        ix=0
        do k=2,nofcls
          rminmax=0.0
          do i=n0,n
            ii=index2d(i)
            rmin=10000.0
            do j=1,k-1
              if (i .eq. icent(j)) then
                rmin=0.0
              else
                if (rmin .gt. rmsd2d(ii,index2d(icent(j))))
     -            rmin=rmsd2d(ii,index2d(icent(j)))
              end if
            end do
c           Select cent(k) to have the largest rmin
            if (rmin .gt. rminmax) then
              icent(k)=i
              rminmax=rmin
            end if
          end do
        end do
      end if
      if (iverb .gt. 0) write (6,1000) (icent(k),k=1,nofcls)
      return
1000  format(' Initial centers chosen=',(10i5))
1001  format(' Initial center for cluster #',i3)
      end
      subroutine clstrs_maxnn(ineig,nneig,n0,n,iclst,ifirst,
     -  ilast,nofcls0,nofcls,idrop,maxnode,maxgr,maxneig)
c#    MMC routine 462 lstmod: 07/15/02
c*****Find all clusters in a network and sort atoms in a cluster by groups
      dimension ineig(maxneig,maxnode),nneig(maxnode),iclst(maxnode),
     -  ifirst(maxgr),ilast(maxgr),idrop(maxnode)
      data indxidel /0/
c     Input parameters:
c     n0,n: Use atomnumbers (vertices) from n0 to n (inclusive)
c     maxnode,maxneig,maxgr: Array sizes - see dimension statement above
c     nneig(i) : number of neighbours (bonded) of node i
c     ineig(j,i) : j-th neighbour of atom i
c     Workspace array: idrop
c     Output parameters:
c     nofcls0: Number of disconnected clusters (groups) found previously
c     nofcls: Number of disconnected clusters (groups) found
c     iclst,ifirst,ilast: The elements of the ig-th group are atoms
c     (iclst(ia),ia=ifrst(ig),ilast(ig))
c
c     Description of the algorithm:
c     Pick the node with the largest # of neighbors (and lowest energy)
c     Make it a cluster; remove it ; repeat
c     Initialization
c     print *,'CLSTRS_nn start n0,n,maxgr=',n0,n,maxgr
      nleft=n-n0+1
      nofcls=nofcls0
      lastnode=n0-1
      do while (nleft .gt. 0)
c       Find node(s) with largest nn
        nnmax=0
        do i=n0,n
          if (nneig(i) .ge. nnmax) then
            nnmax=nneig(i)
            imin=i
          end if
        end do
        if (nnmax .lt. 0) write (6,1002) imin,nnmax
        nofcls=nofcls+1
        lastnode=lastnode+1
        ifirst(nofcls)=lastnode
        iclst(lastnode)=imin
        do in=1,nneig(imin)
         iclst(lastnode+in)=ineig(in,imin)
        end do
        lastnode=lastnode+nneig(imin)
        ilast(nofcls)=lastnode
        nleft=nleft-nneig(imin)-1
        if (ilast(nofcls)+nleft .ne. n)
     -    write (6,1001) nofcls,ilast(nofcls),nleft,n
c       write (6,1004) nofcls,ifirst(nofcls),ilast(nofcls),nleft,nnmax,
c    -    imin,nneig(imin)
        if (nleft .lt. 0) write (6,1000) nofcls0,nofcls,imin,nleft
c       Now eliminate imin and its neighbour from ineig
        call trnsfi(idrop,ineig(1,imin),nneig(imin))
        ndrop=nneig(imin)+1
        idrop(ndrop)=imin
        do i=1,ndrop
          id=idrop(i)
          if (nneig(id) .lt. 0) write (6,1003) nofcls,id,nneig(id)
          do in=1,nneig(id)
            idel=ineig(in,id)
            do jn=1,nneig(idel)
              if (ineig(jn,idel) .eq. id) then
                indxidel=jn
                go to 100
              end if
            end do
100         ineig(indxidel,idel)=ineig(nneig(idel),idel)
            nneig(idel)=nneig(idel)-1
          end do
          nneig(id)=-1
        end do
      end do
1000  format(' PROGRAM ERROR: nofcls0,nofcls,imin,nleft=',4i8,' < 0 !')
1001  format(' PROGRAM ERROR: nofcls,ilast(nofcls),nleft,n=',4i6,
     -  ' (il+nl ne n)')
1002  format(' PROGRAM ERROR: imin,nnmax=',2i5,' ( <0 !)')
1003  format(' PROGRAM ERROR: nofcls,id=',2i5,' nneig(id)=',i4,' (<0!)')
c1004  format(' nofcls,ifirst(nofcls),ilast(nofcls),nleft,nnmax=',5i5,/,
c     -  ' imin,nn(imin)=',2i5)
      return
      end
      subroutine clstrs_density(nfrst,n,iclst,ifirst,ilast,nofcls,
     -  nofcls_t,nng,ing,nng2r,idenclstyp,nnmin,it1,it2,it3,it4,
     -  t1,t2,mx2d,iout)
c*****Find all clusters in a network and sort atoms in a cluster by groups
      dimension iclst(mx2d),ifirst(mx2d),ilast(mx2d),nng(mx2d),
     -  ing(mx2d,mx2d),nng2r(mx2d),it1(mx2d),it2(mx2d),it3(mx2d),
     -  it4(mx2d),t1(mx2d),t2(mx2d)
c     Input parameters:
c     n0,n: Use atomnumbers (vertices) from n0 to n (inclusive)
c     idenclst=1: bond if share nnmin neighbors
c     idenclst=2: bond is within cutoff and share at least nnmin neighbors
c     idenclst=3: bond if within cutoff and each has at least nnmin neighbors
c     Workspace arrays: it1,it2,it3,it4,t1,t2
c     Output parameters
c     nofcls: Number of clusters requested
c     iclst,ifirst,ilast: The elements of the ig-th group are atoms
c     (iclst(ia),ia=ifirst(ig),ilast(ig))
c     Initialization
      print *
c     print *,'CLSTRS_DENSITY nnmin=',nnmin
      iverb=1
c     Finf neighbor number range      
      nngmin=mx2d
      nngmax=0
      nz=0
      do i=nfrst,n
        if (nng(i) .lt. nngmin) nngmin=nng(i)
        if (nng(i) .gt. nngmax) nngmax=nng(i)
        if (nng(i) .lt. nnmin) nz=nz+1
      end do
      write (iout,2001) nngmin,nngmax
      write (   6,2001) nngmin,nngmax
      if (nz .gt. 0) write (iout,2000) nnmin,nz
      if (idenclstyp .eq. 3) then
        do i=nfrst,n
          do jj=1,nng(i)
            j=iabs(ing(jj,i))
            if (i .lt. j) then
              if (nng(i) .lt. nnmin .or. nng(j) .lt. nnmin) then
c               Remove i-j bond
                do ii=1,nng(j)
                  if (ing(ii,j) .eq. i) ing(ii,j)=-ing(ii,j)
                end do
                ing(jj,i)=-ing(jj,i)
              end if
            end if
          end do
        end do
c        do i=nfrst,n
c          write (77,7943) i,(ing(j,i),j=1,nng(i))
c7943      format(i5,' NN:',50i5)
c        end do
        call clean_ng(nfrst,n,nng,ing,mx2d)
c        print *,'CLEAN done'
c        do i=nfrst,n
c          write (78,7943) i,(ing(j,i),j=1,nng(i))
c        end do
        call checknnlist(nfrst,n,ing,nng,nerr,mx2d)
        if (nerr .gt. 0) stop
        iverb=0
        call clstrs(ing,nng,it1,nfrst,n,iclst,ifirst,ilast,0,nofcls,
     -    it2,0,it2,0,0006,inperr,iverb,n,n,mx2d)        
c       print *,'CLSTRS done'
      else if (idenclstyp .eq. 2) then
c       Remove bonds if the # of common neighbors is < nnmin
        do i=nfrst,n
          do j=1,nng(i)
            nmatch=0 
            do ii=1,nng(i)
              do jj=1,nng(j)
                iii=iabs(ing(jj,j))
                if (iii .gt. i) then
                  if (iabs(ing(ii,i)) .eq. iii) nmatch=nmatch+1
                end if
              end do
            end do
            if (nmatch .lt. nnmin) then
c             Mark bond for removal by setting it to -ing(ii,i)
              do ii=1,nng(i)
                if (ing(ii,i) .eq. j) ing(ii,i)=-ing(ii,i)
              end do
              do jj=1,nng(j)
                if (ing(jj,j) .eq. i) ing(jj,j)=-ing(jj,j)
              end do
            end if
          end do
        end do
c       Remove the negative and zero ing entries
        call clean_ng(nfrst,n,nng,ing,mx2d)
        call clstrs(ing,nng,it1,nfrst,n,iclst,ifirst,ilast,0,nofcls,
     -    it2,0,it2,0,iout,inperr,0,n,n,mx2d)        
      else if (idenclstyp .eq. 1) then
c       Keep bond when # of common neighbors is >= nnmin; use nng2r list too
        call zeroiti(it3,nfrst-1,n)
c       Move the R-2R neighbors together with the R neighbors
        do i=nfrst,n
          do j=1,nng2r(i)
            ing(nng(i)+j,i)=ing(mx2d-j+1,i)
          end do
        end do
        do i=nfrst,n
          do j=1,nng(i)+nng2r(i)
            jn=ing(j,i)
c           Check for # of common neighbors
            nmatch=0
            do ii=1,nng(i)
              do jj=1,nng(jn)
                if (ing(ii,i) .eq. ing(jj,jn)) nmatch=nmatch+1
              end do
            end do
            if (nmatch .ge. nnmin) then
c             Create bond
              ing(mx2d-it3(i),i)=jn
              ing(mx2d-it3(jn),jn)=i
              it3(i)=it3(i)+1
              it3(jn)=it3(jn)+1
            end if
          end do
        end do
c       Move the it3 bonds to the start in ing
        do i=nfrst,n
          do j=1,it3(i)
            ing(j,i)=ing(mx2d-j+1,i)
          end do
        end do
        call trnsfi(nng(nfrst),it3(nfrst),n-nfrst+1)
        call clstrs(ing,nng,it1,nfrst,n,iclst,ifirst,ilast,0,nofcls,
     -    it2,0,it2,0,iout,inperr,0,n,n,mx2d)        
      end if
c     Sort clusters by the # of members
      do i=1,nofcls
        t2(i)=float(ifirst(i)-ilast(i))
      end do
      call indexit(it1,1,nofcls,0)
      call mrgsrt(iout,it1,t2,nofcls,it2,it3,it4,t1,nofcls)
c     print *,'MRGSRT done'
c      write (6,8943) (it1(i),i=1,nofcls)
c8943  format(' IT1:',/,(20i4))
c      write (6,8944) (-t2(i),i=1,nofcls)
c8944  format(' T2:',/,(20f4.0))
      inc=0
      do i=1,nofcls
        nmem=ilast(it1(i))-ifirst(it1(i))+1
        do j=1,nmem
          it4(inc+j)=iclst(ifirst(it1(i))-1+j)
        end do
        it2(i)=inc+1
        it3(i)=inc+nmem
        inc=inc+nmem
      end do
      call trnsfi(ifirst,it2,nofcls)
      call trnsfi(ilast,it3,nofcls)
      call trnsfi(iclst,it4,n-nfrst+1)
c      do i=1,nofcls
c        write (79,7891) i,ifirst(i),ilast(i),
c     -    (iclst(j),j=ifirst(i),ilast(i))
c7891    format(i5,' if,il=',i4,i5,' iclst:',50i4)
c      end do
      i=1
      do while (ilast(i) .gt. ifirst(i) .and. i .lt. nofcls)
        i=i+1
      end do
      nsing=0
      if (ilast(i) .eq. ifirst(i)) nsing=nofcls-i+1
      write (iout,*) 'Number of single nodes=',nsing
      nofcls_t=nofcls-nsing
      return
2000  format(' Number of nodes with fewer than',i4,' neighbors=',i5)
2001  format(' Range of the number of neighbors: [',i4,',',i4,']')
      end
      subroutine clean_ng(nfrst,n,nng,ing,maxn)
      dimension nng(maxn),ing(maxn,maxn)
c     Remove the eliminated nodes from the nn list of the rest
      do i=nfrst,n
        ndel=0
        do j=1,nng(i)
          if (ing(j,i) .le. 0) then
            ndel=ndel+1
          else
            ing(j-ndel,i)=ing(j,i)
          end if
        end do
        nng(i)=nng(i)-ndel
      end do
      return
      end
      subroutine masktolist(index,mask,n,nfinal,isave)
      dimension index(n),mask(n)
c     Create a list of indices in index where the value of mask is isave
      nfinal=0
      do i=1,n
        if (mask(i) .eq. isave) then
          nfinal=nfinal+1
          index(nfinal)=i
        end if
      end do
      return
      end
      subroutine extract(c,index,ndim,n,nfinal)
      dimension c(ndim,n),index(n)
      nfinal=0
      do ia=1,n
        if (index(ia) .eq. 0) then
          nfinal=nfinal+1
          if (nfinal .lt. ia) call trnsfr(c(1,nfinal),c(1,ia),ndim)
        end if
      end do
      return
      end
      subroutine bestoverlay(nat,index1,index2,c1,c2,atw,atwsuminp,
     -  cc1,cc2,atw1,rot,com1,com2,LEVTEST,TOLERANCE,iout,maxat)
      dimension index1(maxat),index2(maxat),c1(3,maxat),c2(3,maxat),
     -  atw(maxat),cc2(3,maxat),cc1(3,maxat),atw1(maxat),
     -  rot(3,3),com1(3),com2(3)
c     For the atoms in c1(index1(i)), c2(index2(i)) get the best fit
c     using the algorithm of Kabasch, Acta Cryst, A32, p922 (1976).
c     c1 is assumed to be the reference structure.
c     cc1,cc2 are used for temporary storage
      dimension ijk(3,2)
      real*8 atwsuminp,atwsum,sm,r(3,3),dcom1(3),dcom2(3),
     -  rr(3,3),diag(3),offdiag(3),a(3,3),b(3,3),rmu(3)
      data iz /0/,inz /0/,atwsum /0.d0/
c     print *,'BESTOVERLAY LEVTEST,maxat,nat=',LEVTEST,maxat,nat
      ijk(1,1)=2
      ijk(1,2)=3
      ijk(2,1)=1
      ijk(2,2)=3
      ijk(3,1)=1
      ijk(3,2)=2
      devmax=0.0
      if (nat .eq. 1) return
c     Move both sets into COM frame
      do k=1,3
        dcom1(k)=0.d0
        dcom2(k)=0.d0
      end do
      do i=1,nat
        atw1(i)=atw(index1(i))
        do k=1,3
          cc1(k,i)=c1(k,index1(i))
          cc2(k,i)=c2(k,index2(i))
          dcom1(k)=dcom1(k)+atw1(i)*cc1(k,i)
          dcom2(k)=dcom2(k)+atw(index2(i))*cc2(k,i)
        end do
c        write (40,7291) i,(cc1(k,i),k=1,3),(cc2(k,i),k=1,3)
c7291  format(' i=',i5,' cc1=',3f12.7,' cc2=',3f12.7)
      end do
      if (atwsuminp .eq. 0.d0) then
        atwsum=0.d0
        do i=1,nat
          atwsum=atwsum+atw1(i)
        end do
      else
        atwsum=atwsuminp
      end if
      do k=1,3
        com1(k)=dcom1(k)/atwsum
        com2(k)=dcom2(k)/atwsum
      end do
      if (LEVTEST .gt. 0) write (LEVTEST,1001) atwsum,com1,com2
      do i=1,nat
        do k=1,3
          cc1(k,i)=cc1(k,i)-com1(k)
          cc2(k,i)=cc2(k,i)-com2(k)
        end do
      end do
c     Calculate coordinate sums - Numerical recipes starts arrays from 1!!
      do k=1,3
        do l=1,3
          r(k,l)=0.d0
          do i=1,nat
            r(k,l)=r(k,l)+atw1(i)*cc1(k,i)*cc2(l,i)
          end do
          r(k,l)=r(k,l)/atwsum
        end do
      end do
      do k=1,3
        do l=1,3
          sm=0.d0
          do m=1,3
            sm=sm+r(m,k)*r(m,l)
          end do
          rr(k,l)=sm
        end do
      end do
      if (LEVTEST .gt. 0) then
        write (LEVTEST,1000) "r",r
        write (LEVTEST,1000) "rr",rr
      end if
c     Find the eigenvectors a and eigenvalues mu of rr
      call dtred2(rr,3,3,diag,offdiag)
      call dtqli(diag,offdiag,3,3,rr,ierr)
      if (ierr .gt. 0) then
        write (6,1004)
        if (iout .gt. 0) write (iout,1004)
        return
      end if
1004  format(' Calculation aborted due to diagonalization failure')
      do k=1,3
        do l=1,3
          a(k,l)=rr(l,k)
        end do
      end do
c     The rows of the matrix a are the eigenvectors
c     Calculate rotation matrix (U in Kabasch's notation)
      nz=0
      do k=1,3
        if (dabs(diag(k)) .gt. TOLERANCE) then
          rmu(k)=dsqrt(dabs(diag(k)))
        else
          rmu(k)=0.d0
          nz=nz+1
        end if
      end do
      if (LEVTEST .gt. 0) write (LEVTEST,*) "mu=",rmu
      do k=1,3
        if (rmu(k) .lt. TOLERANCE) then
          iz=k
        else
          do l=1,3
            sm=0.d0
            do m=1,3
              sm=sm+r(l,m)*a(k,m)
            end do
            b(k,l)=sm/rmu(k)
          end do
          inz=k
        end if
      end do
      if (LEVTEST .gt. 0) write (LEVTEST,*) "nz=",nz
      if (nz .eq. 1) then
c       Planar molecule: a(iz)=a(inz)xa(jnz), same for b
         a(iz,1)=a(ijk(iz,1),2)*a(ijk(iz,2),3)-
     -     a(ijk(iz,1),3)*a(ijk(iz,2),2)
         a(iz,2)=a(ijk(iz,1),3)*a(ijk(iz,2),1)-
     -     a(ijk(iz,1),1)*a(ijk(iz,2),3)
         a(iz,3)=a(ijk(iz,1),1)*a(ijk(iz,2),2)-
     -     a(ijk(iz,1),2)*a(ijk(iz,2),1)
         b(iz,1)=b(ijk(iz,1),2)*b(ijk(iz,2),3)-
     -     b(ijk(iz,1),3)*b(ijk(iz,2),2)
         b(iz,2)=b(ijk(iz,1),3)*b(ijk(iz,2),1)-
     -     b(ijk(iz,1),1)*b(ijk(iz,2),3)
         b(iz,3)=b(ijk(iz,1),1)*b(ijk(iz,2),2)-
     -     b(ijk(iz,1),2)*b(ijk(iz,2),1)
      else if (nz .eq. 2) then
c       Linear molecules
c       First set the iz-th components to nonparalel to the inz-th
        do k=1,3
          a(iz,k)=0.d0
          b(iz,k)=0.d0
        end do
        if (dabs(a(inz,1)) .lt. TOLERANCE) then
          a(iz,1)=rmu(inz)
        else if (dabs(a(inz,2)) .ge. TOLERANCE) then
          a(iz,1)= -a(inz,1)
        else
          a(iz,2)=rmu(inz)
        end if
        if (dabs(b(inz,1)) .lt. TOLERANCE) then
          b(iz,1)=rmu(inz)
        else if (dabs(b(inz,2)) .ge. TOLERANCE) then
          b(iz,1)= -b(inz,1)
        else
          b(iz,2)=rmu(inz)
        end if
        if (iz .eq. ijk(inz,1)) then
          jz=ijk(inz,2)
        else
          jz=ijk(inz,1)
        end if
c       a(jz)=a(inz)xa(iz)
        a(jz,1)=a(ijk(jz,1),2)*a(ijk(jz,2),3)-
     -    a(ijk(jz,1),3)*a(ijk(jz,2),2)
        a(jz,2)=a(ijk(jz,1),3)*a(ijk(jz,2),1)-
     -    a(ijk(jz,1),1)*a(ijk(jz,2),3)
        a(jz,3)=a(ijk(jz,1),1)*a(ijk(jz,2),2)-
     -    a(ijk(jz,1),2)*a(ijk(jz,2),1)
        b(jz,1)=b(ijk(jz,1),2)*b(ijk(jz,2),3)-
     -    b(ijk(jz,1),3)*b(ijk(jz,2),2)
        b(jz,2)=b(ijk(jz,1),3)*b(ijk(jz,2),1)-
     -    b(ijk(jz,1),1)*b(ijk(jz,2),3)
        b(jz,3)=b(ijk(jz,1),1)*b(ijk(jz,2),2)-
     -    b(ijk(jz,1),2)*b(ijk(jz,2),1)
c       a(iz)=a(inz)xa(jz)
        a(iz,1)=a(ijk(iz,1),2)*a(ijk(iz,2),3)-
     -    a(ijk(iz,1),3)*a(ijk(iz,2),2)
        a(iz,2)=a(ijk(iz,1),3)*a(ijk(iz,2),1)-
     -    a(ijk(iz,1),1)*a(ijk(iz,2),3)
        a(iz,3)=a(ijk(iz,1),1)*a(ijk(iz,2),2)-
     -    a(ijk(iz,1),2)*a(ijk(iz,2),1)
        b(iz,1)=b(ijk(iz,1),2)*b(ijk(iz,2),3)-
     -    b(ijk(iz,1),3)*b(ijk(iz,2),2)
        b(iz,2)=b(ijk(iz,1),3)*b(ijk(iz,2),1)-
     -    b(ijk(iz,1),1)*b(ijk(iz,2),3)
        b(iz,3)=b(ijk(iz,1),1)*b(ijk(iz,2),2)-
     -    b(ijk(iz,1),2)*b(ijk(iz,2),1)
      end if
      if (LEVTEST .gt. 0) then
        write (LEVTEST,*) "diag: ",diag
        write (LEVTEST,*) "mu: ",rmu
      end if
      if (LEVTEST .gt. 0) then
        write (LEVTEST,1000) "a",a
        write (LEVTEST,1000) "b",b
      end if
      do k=1,3
        do l=1,3
          sm=0.0
          do m=1,3
            sm=sm+b(m,k)*a(m,l)
          end do
          rot(k,l)=sm
        end do
      end do
      if (LEVTEST .gt. 0) write (LEVTEST,1000) "rot",rot
      call check_rotmat(rot,'KABSCH',6,ifail)
      if (ifail .gt. 0) write (6,1002) diag,rmu
      return
1000  format(' BESTOV ',a,/,(3f16.7))
1001  format(' BESTOV atwsum=',e15.7,' com1=',3f12.7,' com2=',3f12.7)
1002  format(' BESTOV diag=',3e15.7,' mu=',3e15.7)
      end
      function sdsum(n,c1,c2,atw,index1,index2,devmax,maxat)
      dimension c1(3,maxat),c2(3,maxat),atw(maxat),index1(maxat),
     -  index2(maxat)
c     Calculate the RMS over (selected) atoms , weighted with aw
      sd=0.0
      awsum=0.0
      devmax=0.0
      do ii=1,n
        sd0=0.0
        do k=1,3
          dd=c1(k,index1(ii))-c2(k,index2(ii))
          sd0=sd0+dd*dd
        end do
        sd=sd+sd0*atw(index1(ii))
        awsum=awsum+atw(index1(ii))
        if (devmax .lt. sd0) devmax=sd0
      end do
      devmax=sqrt(devmax)
      sdsum=sd/awsum
      return
      end
      function sdsumix(n,c1,c2,atw,numsel,index,devmax,maxat)
      dimension c1(3,maxat),c2(3,maxat),atw(maxat),index(maxat)
c     Calculate the RMS over the atomlist in index, weighted with aw
      sd=0.0
      awsum=0.0
      devmax=0.0
      if (numsel .eq. 0) then
c       Use all atoms
        do i=1,n
          sd0=(c1(1,i)-c2(1,i))**2+(c1(2,i)-c2(2,i))**2+
     -      (c1(3,i)-c2(3,i))**2
          sd=sd+sd0*atw(i)
          awsum=awsum+atw(i)
          if (devmax .lt. sd0) devmax=sd0
        end do
      else
        do ii=1,numsel
          i=index(ii)
          sd0=(c1(1,i)-c2(1,i))**2+(c1(2,i)-c2(2,i))**2+
     -      (c1(3,i)-c2(3,i))**2
          sd=sd+sd0*atw(i)
          awsum=awsum+atw(i)
          if (devmax .lt. sd0) devmax=sd0
        end do
      end if
      devmax=sqrt(devmax)
      sdsumix=sd/awsum
      return
      end
      subroutine btchmn(npts,nskp,nintvl,xcum,ucum,u,rs,inam,iout,noprt,
     -  sd2i,idecide)
c#    MMC routine 255 lstmod: 05/02/13 (parts moved to subrotine runtest)
c*****Computes error bound with the method of batch means
      real*8 xcum,ucum,denom
      dimension xcum(npts),ucum(npts),u(npts),rs(npts)
      character*8 inam
      if (noprt .eq. 0) write (iout,1001) inam,npts,nskp,nintvl
      sd2i=0.0
      if (npts-nskp .lt. 2) return
      nbl=nintvl
      ntry=1
      do il=1,ntry
        ndfac=2**(il-1)
        if (nskp .eq. 0) then
          u(1)=ucum(ndfac)/xcum(ndfac)
        else
          denom=xcum(ndfac+nskp)-xcum(nskp)
          if (denom .eq. 0.d0) then
            u(1)=0.d0
          else
            u(1)=(ucum(ndfac+nskp)-ucum(nskp))/denom
          end if
        end if
        npts0=(npts-nskp)/ndfac
        do ib=2,npts0
          denom=xcum(ndfac*ib+nskp)-xcum(ndfac*(ib-1)+nskp)
          if (denom .eq. 0.d0) then
            u(ib)=0.d0
          else
            u(ib)=(ucum(ndfac*ib+nskp)-ucum(ndfac*(ib-1)+nskp))/denom
          end if
        end do
c        write (iout,9899) (ib,ucum(ib),u(ib),xcum(ib),ib=1,npts0)
c9899    format(i3,' ucum=',f10.1,' u=',f10.1,' xcum=',f10.1)
        call var(u,npts0,sd2,rs,nup,ndown,nrun)
        if (il .eq. 1) sd2i=sd2
        call runtest(nup,ndown,nrun,idecide)
        if (noprt .eq. 0) write (iout,1002)
     -    inam,amin1(9999.9999,sd2),nbl,nup,ndown,nrun,idecide
c       Double the blocksize
        nbl=nbl*2
        npts0=npts0/2
        if (npts0 .le. 2) return
      end do
      return
1001  format(/,1x,a8,' Number of block averages saved=',i4,
     -  ' Number of block skipped=',i4,' block size=',i9,' MC steps')
1002    format(1x,a8,' 2*sd=',f10.4,' block size=',i9,
     -    ' nup=',i3,' ndown=',i3,' nrun=',i3,i3)
      end
      subroutine var(a,n,sd2,rs,nup,ndown,nrun)
c#    MMC routine 256 lstmod: 01/22/04
c*****Computes the variance for the method of batch means
      dimension a(n),rs(n)
      real*8 av,sd,ai
      sd=0.0d0
      av=0.0d0
      sd2=0
      if (n .eq. 1) return
      do i=1,n
        ai=a(i)
        av=av+ai
        sd=sd+ai**2
      end do
      sd=dsqrt(dabs(sd/dfloat(n)-(av/dfloat(n))**2)/dfloat(n-1))
      sd2=2.0*sd
c     Find the median
      call trnsfr(rs,a,n)
      n2=n/2+1
      do i=1,n2
        r=rs(i)
        jm=i
        do j=i,n
          if (rs(j) .gt. r) then
            r=rs(j)
            jm=j
          end if
        end do
        rs(jm)=rs(i)
        rs(i)=r
      end do
      rmed=rs(n2)
      if (mod(n,2) .eq. 0) rmed=(rs(n2)+rs(n2-1))/2.0
      nup=0
      ndown=0
      nrun=1
      rp=a(1)-rmed
      do i=2,n
        if (rp*(a(i)-rmed) .le. 0.0) nrun=nrun+1
        if (rp .gt. 0.0) nup=nup+1
        if (rp .le. 0.0) ndown=ndown+1
        rp=a(i)-rmed
      end do
      if (mod(n,2) .eq. 1) nrun=nrun-1
      if (rp .gt. 0.0) nup=nup+1
      if (rp .le. 0.0) ndown=ndown+1
      return
      end
      subroutine blockfromcum(bl,cum,xcum,n)
c#    MMC routine 257 lstmod: 03/20/01
c*****Extract block averages from cumulative sum
      real*8 cum,xcum,denom
      dimension bl(n),cum(n),xcum(n)
      if (n .lt. 1) return
      if (xcum(1) .eq. 0.d0) bl(1)=0.d0
      if (xcum(1) .ne. 0.d0) bl(1)=cum(1)/xcum(1)
      do i=2,n
        denom=xcum(i)-xcum(i-1)
        if (denom .eq. 0.d0) bl(i)=bl(i-1)
        if (denom .ne. 0.d0) bl(i)=(cum(i)-cum(i-1))/denom
      end do
      return
      end
      subroutine savebitc(mapbit,ibitx,n,nbits,maxbit)
c*****Save the bits from ibitx into mapbit
      dimension mapbit(maxbit),ibitx(n)
      iw=1
      ib=0
      ibb=0
      mapbi=0
      do i=1,n
        ib=ib+1
        ibb=ibb+1
        if (ibitx(ibb) .eq. 1) mapbi=ibset(mapbi,ib-1)
        if (ib .eq. nbits) then
c       write (77,*)' write iw=',iw,' mapbi=',mapbi,
c    -    ' ibdone,itodo=',ibdone,itodo
          mapbit(iw)=mapbi
          iw=iw+1
          mapbi=0
          ib=0
        end if
      end do
      if (ib .gt. 0) mapbit(iw)=mapbi
c     if (ib .gt. 0) write (77,*)' writ iw=',iw,' mapbi=',mapbi
      return
      end
      subroutine readbitc(mapbit,ibitx,n,nbits,maxbit)
c*****Extract the bits from mapbit into ibitx
      dimension mapbit(maxbit),ibitx(n)
      nloops=(n-1)/nbits+1
      do il=1,nloops
c       Set loop limits so that inside loops can run in parallel
        ibdone=(il-1)*nbits
        itodo=ibdone+min0(nbits,n-ibdone)
        mapbi=mapbit(il)
c       write (77,*)' read il=',il,' mapbi=',mapbi,
c    -    ' ibdone,itodo=',ibdone,itodo
        do ib=ibdone+1,itodo
          ix=mapbi/2
          ibitx(ib)=mapbi-2*ix
          mapbi=ix
        end do
      end do
      return
      end
c     Subroutines from Numerical Recipes
      subroutine dtqli(d,e,n,np,z,ierr)
      real*8 d(np),e(np),z(np,np)
      real*8 dd,r,g,s,c,p,f,b
      ierr=0
      if (n.gt.1) then
        do i=2,n
          e(i-1)=e(i)
        end do
        e(n)=0.d0
        do l=1,n
          iter=0
1         do m=l,n-1
            dd=abs(d(m))+abs(d(m+1))
c           if (abs(e(m))+dd.eq.dd) go to 2
c           MM 10/21/2004
            if (e(m) .eq. 0.0) go to 2
            if (dd .ne. 0.0) then
              if (abs(e(m))/dd .lt. 1.d-15) go to 2
            end if
          end do
          m=n
2         if (m. ne. l) then
c           if (iter .eq. 300) pause 'too many iterations'
            if (iter .eq. 300) then
              print *,'error: too many iterations in tqli'
              ierr=1
              return
            end if
            iter=iter+1
            g=(d(l+1)-d(l))/(2.d0*e(l))
            r=sqrt(g**2+1.d0)
            g=d(m)-d(l)+e(l)/(g+sign(r,g))
            s=1.d0
            c=1.d0
            p=0.d0
            do i=m-1,l,-1
              f=s*e(i)
              b=c*e(i)
              if(abs(f).ge.abs(g))then
                c=g/f
                r=dsqrt(c**2+1.d0)
                e(i+1)=f*r
                s=1.d0/r
                c=c*s
              else
                s=f/g
                r=dsqrt(s**2+1.d0)
                e(i+1)=g*r
                c=1.d0/r
                s=s*c
              endif
              g=d(i+1)-p
              r=(d(i)-g)*s+2.d0*c*b
              p=s*r
              d(i+1)=g+p
              g=c*r-b
              do k=1,n
                f=z(k,i+1)
                z(k,i+1)=s*z(k,i)+c*f
                z(k,i)=c*z(k,i)-s*f
              end do
            end do
            d(l)=d(l)-p
            e(l)=g
            e(m)=0.d0
            go to 1
          endif
        end do
      endif
      return
      end
      subroutine dtred2(a,n,np,d,e)
      real*8 a(np,np),d(np),e(np)
      real*8 scale,h,f,g
      if (n .gt. 1) then
        do i=n,2,-1
          l=i-1
          h=0.d0
          scale=0.d0
          if (l. gt. 1) then
            do k=1,l
              scale=scale+abs(a(i,k))
            end do
            if(scale.eq.0.)then
              e(i)=a(i,l)
            else
              do k=1,l
                a(i,k)=a(i,k)/scale
                h=h+a(i,k)**2
              end do
              f=a(i,l)
              g=-sign(sqrt(h),f)
              e(i)=scale*g
              h=h-f*g
              a(i,l)=f-g
              f=0.
              do j=1,l
                a(j,i)=a(i,j)/h
                g=0.
                do k=1,j
                  g=g+a(j,k)*a(i,k)
                end do
                if (l .gt. j) then
                  do k=j+1,l
                    g=g+a(k,j)*a(i,k)
                  end do
                end if
                e(j)=g/h
                f=f+e(j)*a(i,j)
              end do
              hh=f/(h+h)
              do j=1,l
                f=a(i,j)
                g=e(j)-hh*f
                e(j)=g
                do k=1,j
                  a(j,k)=a(j,k)-f*e(k)-g*a(i,k)
                end do
              end do
            endif
          else
            e(i)=a(i,l)
          end if
          d(i)=h
        end do
      endif
      d(1)=0.d0
      e(1)=0.d0
      do i=1,n
        l=i-1
        if (d(i) .ne. 0.d0) then
          do j=1,l
            g=0.
            do k=1,l
              g=g+a(i,k)*a(k,j)
            end do
            do k=1,l
              a(k,j)=a(k,j)-g*a(k,i)
            end do
          end do
        endif
        d(i)=a(i,i)
        a(i,i)=1.d0
        if (l .ge. 1) then
          do j=1,l
            a(i,j)=0.d0
            a(j,i)=0.d0
          end do
        endif
      end do
      return
      end
      function sqrt1(x)
c*****Avoid overflow for large x - just ignore the +1
      if (abs(x) .lt. 1.e+10) then
        sqrt1=sqrt(x**2+1.0)
      else
        sqrt1=x+0.5
      end if
      return
      end
      subroutine amoeba(p,y,mp,np,ndim,ftol,iter,c,cnew,ih,n,nnh,edge,
     -  ioppbc,cell,ncell,ixyzhex,rot,mintyp)
C*****Numerical Recipes
      parameter (NMAX=20,ALPHA=1.0,BETA=0.5,GAMMA=2.0,ITMAX=200)
      dimension p(MP,NP),y(MP),pr(NMAX),prr(NMAX),pbar(NMAX)
      dimension c(3,n),cnew(3,n),ih(n),edge(3),cell(3,27),
     -  rot(3,3),ixyzhex(3)
c     print *,'--- Simplex optimization started'
      mpts=ndim+1
      iiter=0
110   iter=0
1     ilo=1
      if (y(1) .gt. y(2)) then
        ihi=1
        inhi=2
      else
        ihi=2
        inhi=1
      end if
      do i=1,mpts
        if (y(i) .lt. y(ilo)) ilo=i
        if (y(i) .gt. y(ihi)) then
          inhi=ihi
          ihi=i
        else if (y(i) .gt. y(inhi)) then
          if (i .ne. ihi) inhi=i
        end if
      end do
c     write (6,1711) y,((p(i,k),k=1,3),i=1,4)
c1711  format(' Y=',4f10.5,/,(' P=',3f10.6))
      rtol=2.0*abs(y(ihi)-y(ilo))/(abs(y(ihi))+abs(y(ilo)))
      if (rtol .lt. ftol) then
        call euler(rot,p(ilo,1),p(ilo,2),p(ilo,3))
        return
      end if
      if (iter .eq. itmax) then
        iiter=iiter+1
        if (iiter .gt. 2) then
          print *,'Too many resets'
          call euler(rot,p(ilo,1),p(ilo,2),p(ilo,3))
          return
        end if
        print *,'Reset ',iiter
        ybest=y(ilo)
        do i=1,3
          pr(i)=p(ilo,i)+i*0.05
          p(ihi,i)=pr(i)
        end do
        y(ihi)=touch(c,ih,n,nnh,edge,ioppbc,cell,ncell,ixyzhex,PR,
     -    rot,mintyp,0,cnew)
c       print *,'Reset ',iiter,' ilo=',ilo,' ihi=',ihi
        go to 110
      end if
      iter=iter+1
      ylo=-y(ilo)
      if (mod(iter,10) .eq. 0) write (6,1010) iter,ylo,ftol
1010  format(' --- Iteration',i4,' Objective function=',e15.8,' A',
     -  ' (tolerance=',f9.7,')')
      do j=1,ndim
        pbar(j)=0.0
      end do
      do i=1,mpts
        if (i .ne. ihi) then
          do j=1,ndim
            pbar(j)=pbar(j)+p(i,j)
          end do
        end if
      end do
      do j=1,ndim
        pbar(j)=pbar(j)/ndim
        pr(j)=(1.0+alpha)*pbar(j)-alpha*p(ihi,j)
      end do
c     ypr=funk(pr)
      YPR=touch(c,ih,n,nnh,edge,ioppbc,cell,ncell,ixyzhex,PR,rot,
     -  mintyp,0,cnew)
      if (ypr .le. y(ilo)) then
        do j=1,ndim
          prr(j)=gamma*pr(j)+(1.0-gamma)*pbar(j)
        end do
c       yprr=funk(prr)
        yprr=touch(c,ih,n,nnh,edge,ioppbc,cell,ncell,ixyzhex,PRR,rot,
     -  mintyp,0,cnew)
        if (yprr .lt. y(ilo)) then
          do j=1,ndim
            p(ihi,j)=prr(j)
          end do
          y(ihi)=yprr
        else
          do j=1,ndim
            p(ihi,j)=pr(j)
          end do
          y(ihi)=ypr
        end if
      else if (ypr .ge. y(inhi)) then
        if (ypr .lt. y(ihi)) then
          do j=1,ndim
            p(ihi,j)=pr(j)
          end do
          y(ihi)=ypr
        end if
        do j=1,ndim
          prr(j)=beta*p(ihi,j)+(1.-beta)*pbar(j)
        end do
c       yprr=funk(prr)
        yprr=touch(c,ih,n,nnh,edge,ioppbc,cell,ncell,ixyzhex,PRR,
     -    rot,mintyp,0,cnew)
        if (yprr .lt. y(ihi)) then
          do j=1,ndim
            p(ihi,j)=prr(j)
          end do
          y(ihi)=yprr
        else
          ywrst=y(ihi)
          ncont=0
240       continue
          ncont=ncont+1
c         write (6,1711) y,((p(i,k),k=1,3),i=1,4)
          yw=-10000.0
          do i=1,mpts
            if (i .ne. ilo) then
              do j=1,ndim
                pr(j)=0.5*(p(i,j)+p(ilo,j))
                p(i,j)=pr(j)
              end do
c             y(i)=funk(pr)
              y(i)=touch(c,ih,n,nnh,edge,ioppbc,cell,ncell,ixyzhex,PR,
     -          rot,mintyp,0,cnew)
              if (y(i) .gt. yw) yw=y(i)
            endiF
          end do
c         Continue contracting if the newest worst point is higher than
c         the old worst point
c         print *,'yw=',yw,' ywrst=',ywrst
          if (yw-ywrst .gt. ftol .and. ncont .lt. 5) go to 240
        end if
      else
        do j=1,ndim
          p(ihi,j)=pr(j)
        end do
        y(ihi)=ypr
      end if
      go to 1
      end
      subroutine lubksb(a,n,np,indx,b)
      real a(np,np),b(n)
      integer indx(n)
      ii=0
      do 12 i=1,n
        ll=indx(i)
        sum=b(ll)
        b(ll)=b(i)
        if (ii.ne.0) then
          do 11 j=ii,i-1
            sum=sum-a(i,j)*b(j)
11        continue
        else if (sum.ne.0.) then
          ii=i
        end if
        b(i)=sum
12    continue
      do 14 i=n,1,-1
        sum=b(i)
        if (i.lt.n) then
          do 13 j=i+1,n
            sum=sum-a(i,j)*b(j)
13        continue
        end if
        b(i)=sum/a(i,i)
14    continue
      return
      end
      subroutine ludcmp(a,n,np,indx,d)
      parameter (NMAX=100,TINY=1.0e-20)
      real a(np,np),vv(nmax)
      integer indx(n)
      data imax /0/
      d=1.
      do 12 i=1,n
        aamax=0.
        do 11 j=1,n
          if (abs(a(i,j)).gt.aamax) aamax=abs(a(i,j))
11      continue
        if (aamax.eq.0.) write(*,*) 'Oops, singular matrix!'
        vv(i)=1./aamax
12    continue
      do 19 j=1,n
        if (j.gt.1) then
          do 14 i=1,j-1
            sum=a(i,j)
            if (i.gt.1) then
              do 13 k=1,i-1
                sum=sum-a(i,k)*a(k,j)
13            continue
              a(i,j)=sum
            end if
14        continue
        end if
        aamax=0.
        do 16 i=j,n
          sum=a(i,j)
          if (j.gt.1) then
            do 15 k=1,j-1
              sum=sum-a(i,k)*a(k,j)
15          continue
            a(i,j)=sum
          end if
          dum=vv(i)*abs(sum)
          if (dum.ge.aamax) then
            imax=i
            aamax=dum
          end if
16      continue
        if (j.ne.imax) then
          do 17 k=1,n
            dum=a(imax,k)
            a(imax,k)=a(j,k)
            a(j,k)=dum
17        continue
          d=-d
          vv(imax)=vv(j)
        end if
        indx(j)=imax
        if (j.ne.n) then
          if (a(j,j).eq.0.)a(j,j)=tiny
          dum=1./a(j,j)
          do 18 i=j+1,n
            a(i,j)=a(i,j)*dum
18        continue
        end if
19    continue
      if (a(n,n).eq.0.) a(n,n)=tiny
      return
      end
      subroutine datprt(iout,version,iprtver,mark,lmark,
     -  hostname,lhostname,iheadnode,ihostonly)
c#    MMC routine 252 lstmod: 04/24/05
c*****Prints the date and the time
C@EF      use iflport
      character*8 version
      character*(*) mark
      character*100 hostname
      character*12 today
      common /today_date/ ltoday,today
c     C@ EF : Intel Fortran code
c     C@ AB : Absoft Fortran code
c     C@ G7 : Gnu G77 Fortran code
c     C@ UG : SGI IRIX Fortran code
c     C@ HP : Hewlett-Packard Fortran code
c     C@ AX : IBM AIX code
c     C@ UX : Generic Unix code
C@AB      dimension idayspm(12)
c     INTEL compiler: on Linux  only, requires -Vaxlib compilation option
      integer idtvalue(8),lmonths(12)
C@AB      character*8 date_dat
C@AB      character*10 time_dat
C@AB      character*5 zone_dat
C@EF      character*8 date_dat
C@EF      character*10 time_dat
C@EF      character*5 zone_dat
C@G7      character*3 mon
C@G7      character*24 adate
C@G7      external fdate
C@G7      external etime
C@UG      character*24 fdate
C@UG      external fdate
C@AX      character*24 fdate_
C@AX      external fdate_
C@HP      character*24 fdate
C@HP      external fdate
      character*5 months(12)
      data months/'Jan.','Feb.','March','April','May','June',
     -   'July','Aug.','Sep.','Oct.','Nov.','Dec.'/
      data lmonths /4,4,5,5,3,7*4/
C@AB      data idayspm /31,28,31,30,31,30,31,31,30,31,30,31/
c     Find out host name
      lhostname=0
      iheadnode=0
      call blankout(hostname,1,100)
C@AB      call getenv('HOST',VALUE=hostname)
C@UG      call getenv('HOST',hostname)
C@G7      call getenv('HOST',hostname)
C@EF      istat=hostnam(hostname)
      call lastchar(hostname,lhostname,100)
      if (lhostname .gt. 0) then
        if (hostname(1:lhostname) .eq. 'minerva2' .or.
     -      hostname(1:lhostname) .eq. 'login1') iheadnode=1
      else
        iheadnode=-1
      end if
      if (ihostonly .eq. 1) return
      if (iprtver .eq. 1) write (iout,1000) mark(1:lmark),version
      call zeroiti(idtvalue,0,8)
      ltoday=0
      ief=0
C@EF      ief=1
      iab=0
C@AB      iab=1
c     Print time and date
C@UX      call system('date')
C@UG      write (iout,1008) mark(1:lmark),fdate()
C@AX      write (iout,1008) mark(1:lmark),fdate_()
C@G7      call fdate(adate)
C@G7      read (adate,1012) mon,iday,ihour,imin,isec,iyear
C@G7      write (iout,1018) mark(1:lmark),mon,iday,iyear
C@G7      write (today,1002) mon,iday,iyear
C@G7      ltoday=12
C@G7      write (iout,1011) mark(1:lmark),ihour,imin,isec
      if (ief+iab .gt. 0) then
C@EF        call date_and_time(date_dat,time_dat,zone_dat,idtvalue)
C@AB        call date_and_time(date_dat,time_dat,zone_dat,idtvalue)
        write (iout,1009) mark(1:lmark),
     -    months(idtvalue(2))(1:lmonths(idtvalue(2))),idtvalue(3),
     -    idtvalue(1)
        write (iout,1011) mark(1:lmark),idtvalue(5),idtvalue(6),
     -    idtvalue(7)
        write (today,1001) idtvalue(2),idtvalue(3),idtvalue(1)
        ltoday=10
        do ic=1,ltoday
          if (today(ic:ic).eq. ' ') today(ic:ic)='0'
        end do
      end if
      return
1000  format(a,'SIMULAID Version: ',a)
1001  format(i2,'/',i2,'/',i4)
C@G71002  format(a3,' ',i2,', ',i4)
C@UG1008  format(a,'Date: ',a)
C@AX1008  format(a,'Date: ',a)
1009  format(a,'Date: ',a,i3,', ',i4)
1011  format(a,'Time:',i5,' hours,',i3,' minutes,',i3,' seconds')
C@G71012  format(4x,a3,4(1x,i2),1x,i4)
C@G71018  format(a,'Date: ',a3,1x,i2,', ',i4)
      end
      subroutine testconst(izero,ione,itwo,fzero,fone,ftwo,iout,nfail,
     -  initfail,lab)
c#    MMC routine 105 lstmod: 01/18/07
      character*4 lab
c*****Check the integrity of stored constants
      if (initfail .gt. 0) nfail=0
      if (itwo+itwo .ne. itwo*itwo .or. itwo+itwo .eq. itwo) then
        nfail=nfail+1
        write (iout,1000) lab,'integer two'
      end if
      if (ftwo+ftwo .ne. ftwo*ftwo .or. ftwo+ftwo .eq. ftwo) then
        nfail=nfail+1
        write (iout,1000)lab, 'float two'
      end if
      if (ione+ione .eq. ione .or. ione*ione .ne. ione) then
        nfail=nfail+1
        write (iout,1000) lab,'integer one'
      end if
      if (fone+fone .eq. ione .or. fone*fone .ne. fone) then
        nfail=nfail+1
        write (iout,1000) lab,'float one'
      end if
      if (izero+izero .ne. izero .or. izero*izero .ne. izero) then
        nfail=nfail+1
        write (iout,1000) lab,'integer zero'
      end if
      if (fzero+fzero .ne. fzero .or. fzero*fzero .ne. fzero) then
        nfail=nfail+1
        write (iout,1000) lab,'float zero'
      end if
      return
1000  format(' ***** PROGRAM ERROR at ',a,': Internal constant ',a,
     -  ' is corrupted')
      end
      subroutine explanation(iq)
      character*60 answers
      common /helplist/ init,maxans,answers(1000),
     -  linelen(1000),ifl(1000),ill(1000)
c     The answer to question iq is in lined ifl(iq)-ill(ig);
c     each line is linelen characters long
      idebug=0
      nhelp=0
      if (init .eq. 0) then
c       Initialize linelen, iff, ill
        init=1
        nans=0
        do il=1,maxans
          call lastchar(answers(il),ilc,60)
          linelen(il)=ilc
          if (answers(il)(1:4) .eq. '****') then
            if (nhelp .gt. 0) ill(nhelp)=il-1
            if (ilc .eq. 4) go to 100
            nhelp=nhelp+1
            read (answers(il)(5:ilc),*,err=200) ihelp
            if (ihelp .ne. nhelp) go to 200
            ifl(nhelp)=il+1
          end if
        end do
100     if (idebug .gt. 0) then
          do i=1,nhelp
            print *,'i,ifl,ill=',i,ifl(i),ill(i)
            do ip=ifl(i),ill(i)
              print *,'ip,len=',ip,linelen(ip)
              print *,answers(ip)(1:linelen(ip))
            end do
          end do
        end if
      end if
      write (6,1000) (answers(i)(1:linelen(i)),i=ifl(iq),ill(iq))
      return
200   print *,'Help data error: ',nhelp,'-th item is labeled ',ihelp
      return
1000  format(5x,a)
      end
      block data helpdata
      character*60 answers1,answers2,answers3,answers4,
     -  answers5,answers6,answers7,answers8,answers9,answers10,
     -  answers11,answers12,answers13,answers
      common /helplist/ init,maxans,
     -  answers1(50),answers2(50),answers3(50),answers4(50),
     -  answers5(50),answers6(50),answers7(50),answers8(50),
     -  answers9(50),answers10(50),answers11(50),answers12(50),
     -  answers13(50),answers(350),linelen(1000),ifl(1000),ill(1000)
c     Help information
      data maxans /1000/,init /0/
      data answers1 /
     -  '**** 1                                                      ',
     -  'File names are of the form <name>.<number>.<ext>            ',
     -  'No answer will set <number> the original sequence number    ',
     -  '**** 2                                                      ',
     -  'The number read will be used as the maximum distance        ',
     -  'between the atoms forming a salt bridge.                    ',
     -  '**** 3                                                      ',
     -  'With input IEXP the clustering uses the IEXP-th power for   ',
     -  'IEXP>0 and the |IEXP|-th root when IEXP< 0 of the measure   ',
     -  'selected (corr, 1-corr or 1/corr)                           ',
     -  '**** 4                                                      ',
     -  'Optimization is repeated from different (randomy selected)  ',
     -  'starting configurations and the best result will be used    ',
     -  '**** 5                                                      ',
     -  'Yes answer will calculate the shortest distance between     ',
     -  'any atom in the central PBC cell and any image (after trim) ',
     -  '**** 6                                                      ',
     -  'Yes answer will include into the trace the representative   ',
     -  'atoms of non-peptide residues',
     -  '**** 7                                                      ',
     -  'Bonds that occur in fewer % of the time then the minimum or ',
     -  ' higher % of the time than the maximum will be excluded from',
     -  'the correlation calculation and history plotting            ',
     -  '**** 8                                                      ',
     -  'H bonds between residues whose residue sequence numbers     ',
     -  'differ by less than the minimum or by greater than the      ',
     -  'maximum will be excluded from the correlation calculation   ',
     -  '**** 9                                                      ',
     -  'Brookhave convention assumes that the first two characters  ',
     -  'are the element symnbols: CA21 is Calcium and 1CA2 is an    ',
     -  'alpha carbon - conversion is done by cyclic permutation     ',
     -  '**** 10                                                     ',
     -  'Orientational optimization can be based on heavy atoms only ',
     -  '**** 11                                                     ',
     -  'Atoms with three or four bonds are likely to be inside the  ',
     -  'macromolecule - ignoring them is unlikely to effect the     ',
     -  'result but speeds up the calculation',
     -  '**** 12                                                     ',
     -  'Molecules in a membrane may have limited degrees of freedom ',
     -  '**** 13                                                     ',
     -  'Optimization can be either done with the PBC cell kept      ',
     -  'fixed or with finding the smallest PBC cell with a minimum  ',
     -  'image-image distance',
     -  '**** 14                                                     ',
     -  'MMC can treat groups as different residues                  ',
     -  '**** 15                                                     ',
     -  'No answer will replace MODEL and ENDMDL with REMARK in the  ',
     -  'PDB file output                                             ',
     -  '**** 16                                                     ',
     -  'No answer will drop atoms with HETATM label in the PDB input'/
      data answers2 /
     -  '**** 17                                                     ',
     -  'MMC solute syntax allows the use of the CLON key.           ',
     -  'If CLON was used, Simulaid needs the same information.      ',
     -  '**** 18                                                     ',
     -  'Atoms that are part of the solute (i.e., not solvent) but   ',
     -  'can be treated as solvent molecules and reset into the PBC  ',
     -  'cell independent of the position of the bulk of the solute  ',
     -  'are considered ions in this context                         ',
     -  '**** 19                                                     ',
     -  'Solute residues that represent small molecules that         ',
     -  'can be treated as solvent molecules and reset into the PBC  ',
     -  'cell independent of the position of the bulk of the solute  ',
     -  'are considered molecular residues in this context           ',
     -  '**** 20                                                     ',
     -  'This question is posed in situations where continued running',
     -  'is likely to cause crash of unpredictable results           ',
     -  '**** 21                                                     ',
     -  'PDB atom and residue names have different conventions       ',
     -  'F option converts only names but keeps the file syntax      ',
     -  'D option adds numbers to names when identical name is found ',
     -  '**** 22                                                     ',
     -  'H-bonded bridges connect two solute atoms with a chain of   ',
     -  'H bonds to solvents. This quiz selects the solute atoms that',
     -  'are allowed to be the starting (and, optionally, the end) of',
     -  'the H-bonded chain.                                         ',
     -  '**** 23                                                     ',
     -  'H-bond A...H-D involves a threshold on the A - D distance   ',
     -  'it is calculated as the covalent bond threshold between     ',
     -  'atoms A and H times a tolerance factor                      ',
     -  '**** 24                                                     ',
     -  'H-bond A...H-D involves a minimum value for the angle A-H-D ',
     -  '**** 25                                                     ',
     -  'Intermolecular distances will be calculated using the       ',
     -  'molecular center definiton selected                         ',
     -  '**** 26                                                     ',
     -  'Single-link clustering can be performed either with a set   ',
     -  'minimum distance between clusters or the minimum distance   ',
     -  'can be adjusted until a set number of clusters are obtained.',
     -  '**** 27                                                     ',
     -  'The clustering will use this cutoff on the correlation-based',
     -  'metric for distance between H bonds (using the exponent     ',
     -  'defined above)                                              ',
     -  '**** 28                                                     ',
     -  'Dial plots can be smoothed by plotting the angles averaged  ',
     -  '**** 29                                                     ',
     -  'Each cluster found can be separately clustered by removing  ',
     -  'a layer of low-connectivity elements first and repeating the',
     -  'clustering with the same distance cutoff                    ',
     -  'This implementation finds the minimum number of members     ',
     -  'within cutoff for a cluster and temporarily drops all that  '/
      data answers3 /
     -  'have this minimum number of neighbors. If the minimum is one',
     -  'then it is replaced by two.                                 ',
     -  '**** 30                                                     ',
     -  'Clusters containing too few members may be excluded from    ',
     -  'sub clustering                                              ',
     -  '**** 31                                                     ',
     -  '1, 2, or 3 represent the axes X, Y, or Z, respectively      ',
     -  '**** 32                                                     ',
     -  'Principal axes are calculated separately for each solute    ',
     -  'molecule (chain or segment) - this input selects it         ',
     -  '**** 33                                                     ',
     -  'Volume estimates are based on a so-called crude Monte Carlo ',
     -  'algorithm that generates random points in a box and counts  ',
     -  'the fraction that falls into the region considered.         ',
     -  'More random points result in higher precision.              ',
     -  '**** 34                                                     ',
     -  'Solvents outside the minimal sphere augmented by the shell  ',
     -  '**** 35                                                     ',
     -  'specified here will be trimmed                              ',
     -  'Yes answer will shift the system so the center printed above',
     -  'will be at <0,0,0>                                          ',
     -  '**** 36                                                     ',
     -  'Each time the ENTER key is hit, the display is rotated by a ',
     -  'fixed increment. This input changes this icrement.          ',
     -  '**** 37                                                     ',
     -  'Each cell-center component read will be multiplied by the   ',
     -  'factor read here                                            ',
     -  '**** 38                                                     ',
     -  'Residues with interresidue distance based on representative ',
     -  'atoms will be listed as being vicinal in the .rsd file      ',
     -  '**** 39                                                     ',
     -  'Residues with interresidue distance based on the nearest    ',
     -  'atom pair will be listed as being vicinal in the .rsm file  ',
     -  '**** 40                                                     ',
     -  'Single link clustering: no two elements in different        ',
     -  'clusters are closer than the pre-set threshold.             ',
     -  'Multi cutoff clustering performs a hierarchical clustering  ',
     -  'with several cutoffs (only with single-link clustering      ',
     -  'K-means/medoids clustering: iterative assignment of elements',
     -  'to the cluster whose center is nearest to it; iteration is  ',
     -  'over the center selections. The number of clusters is preset',
     -  '(to K). K-means center is selected as the COM of the whole  ',
     -  'cluster. K-medoid center is a cluster member that is deemed ',
     -  'to be in the middle: whose largest or average distance from ',
     -  'the rest if the cluster is the smallest or whose weight (if ',
     -  'available) is the largest.                                  ',
     -  'Maximum neighborhood method picks the element with the most ',
     -  'neighbours (i.e., within threshold), makes it a cluster,    ',
     -  'removes the cluster and repeats the procedure on the rest.  ',
     -  'Density clustering uses the number of neighbors or common   '/
      data answers4 /
     -  'neighbors besides the distance measure.                     ',
     -  '**** 41                                                     ',
     -  'Conformations after the firts one will be translated to     ',
     -  'overlap the selected atom to its position in at the start   ',
     -  'and will be reoriented around this atom                     ',
     -  '**** 42                                                     ',
     -  'Additional configurations will be subjected to the same     ',
     -  'operation(s) as the first one                               ',
     -  '**** 43                                                     ',
     -  'Additional configurations may be in the same file or in     ',
     -  'different files but Simulaid needs to know which            ',
     -  '**** 44                                                     ',
     -  'Additional configurations generated may omit the header     ',
     -  '**** 45                                                     ',
     -  'Yes answer will allow you the specify the list of atoms to  ',
     -  'match. No answer will match the first atoms.                ',
     -  '**** 46                                                     ',
     -  'If backtracking bonds leads to more than one heavy atoms    ',
     -  'then the user has to specify which one to select            ',
     -  '**** 47                                                     ',
     -  'Setting the increment to greater than one results in using  ',
     -  'only every increment-th element of the range                ',
     -  '**** 48                                                     ',
     -  'When the atom and residue numbers are adjusted the user can ',
     -  'specify the starting atom and residue numbers               ',
     -  '**** 49                                                     ',
     -  'Conversion files contain the information allowing Simulaid  ',
     -  'to deduce the potential type and partial charge of an atom  ',
     -  '**** 50                                                     ',
     -  'Charmm trajectories contain a header specifying the number  ',
     -  'of atoms, atoms fixed, time step, saving frequencies and    ',
     -  'the version of Charmm. Simulaid makes a reasonable guess but',
     -  'the user can override it here.                              ',
     -  '**** 51                                                     ',
     -  'When a number N greater than zero is given, the animation   ',
     -  'will pause at every N-th frame                              ',
     -  '**** 52                                                     ',
     -  'This input controls the speed of animation - the larger the ',
     -  'number, the slower the animation                            ',
     -  '**** 53                                                     ',
     -  'The matrix elements will be color coded with the            ',
     -  'user-specified number of colors, representing uniform       ',
     -  'intervals in a range that can be specified by the user here ',
     -  'or use the actual range of values in the matrix (default).  ',
     -  'Use 0.0001 for zero minimum.                                ',
     -  '**** 54                                                     ',
     -  '                                                            ',
     -  '**** 55                                                     ',
     -  'Simulaid will put several dials on a page (in portrait      ',
     -  'orientation). The more dials are on a line, the smaller each'/
      data answers5 /
     -  'dial will be but the more rows of dials will be on a page.  ',
     -  '**** 56                                                     ',
     -  'H and M regions will be defined as all atoms in spheres of  ',
     -  'user defined radii centered on a user selected atom         ',
     -  '**** 57                                                     ',
     -  'No answer will only check residue pairs where one is in the ',
     -  'reference range and the other is in the neigborhood range.  ',
     -  'Yes answer will separately check residue pairs where only   ',
     -  'one of them is in either the reference or neighborhood      ',
     -  'range but the other is outside both ranges.                 ',
     -  '**** 58                                                     ',
     -  'FCC cell is a rhombic dodecahedron. Its volume is 2*E^3, the',
     -  'radius of the inscribed sphere is E/sqrt(2) where E is the  ',
     -  'parameter read.                                             ',
     -  '**** 59                                                     ',
     -  'This cell has a hexagon base that has two paralles edges    ',
     -  'whose length are different from the other four. Its size is ',
     -  'defined by (a) the distance between the cell center and the ',
     -  'center of the nearest cell in the direction perpendicular to',
     -  'the two parallel edges (o.e., the distance between the two  ',
     -  'parallel edges  and (b) the distance between the cell center',
     -  'and the center of the nearest cell in the direction         ',
     -  'perpendicular to one of the four equal edges.               ',
     -  '**** 60                                                     ',
     -  'Truncated octahedron has faces of squares and hexagons,     ',
     -  'The volume of the cell is 4*E^3 and the radius of the       ',
     -  'inscribed sphere is E*sqrt(3)/2 where E is the distance of  ',
     -  'the square face from the cell center. E=cell(x)/2 for Charmm',
     -  'and E=[cell(x)/2]/[sqrt(3)/2] for Amber where cell(x) is the',
     -  'unit cell parameter along  the X axis.                      ',
     -  '**** 61                                                     ',
     -  'This cell is defined by the hexagonal close packing of      ',
     -  'spheres. The volume of this cell is E^3/sqrt(3) where E is  ',
     -  'the inscribed sphere diameter read                          ',
     -  '**** 62                                                     ',
     -  'Warning will be issued when (a) two non-bonded atoms are    ',
     -  'closer than their bondlength threshold * sqrt(CTFAC)        ',
     -  '(b) a bondlength is shorter than the bondlength threshold * ',
     -  'sqrt(MINFAC) and (c) when a bond is found between non-S     ',
     -  'atoms whose sequence number differ by more than MAXDIST.    ',
     -  'CTFAC, MINFAC and MAXDIST are user-soecified thresholds     ',
     -  '**** 63                                                     ',
     -  'Gridpoints in the close to an atom are likely to have       ',
     -  'near-singular energies. Such gridpoints - defined by a      ',
     -  'distance threshold - can be excluded from the calculation.  ',
     -  '**** 64                                                     ',
     -  'Yes answer will allow the user to ask Simulaid to calculate ',
     -  'the potential at points with user-defined coordinates       ',
     -  '**** 65                                                     ',
     -  'The distribution of the interatomic distance between the    '/
      data answers6 /
     -  'two selected atoms will be calculated using configurations  ',
     -  'where their distance is below the user-defined limit        ',
     -  '**** 66                                                     ',
     -  'The contributions to the circular variance can be limited to',
     -  'points within a threshold distance of the query point       ',
     -  '**** 67                                                     ',
     -  'Solvents whose CV value is above the user-defined limit will',
     -  'be kept as vicinal solvents                                 ',
     -  '**** 68                                                     ',
     -  'Yes answer will allow the specification of residue range(s);',
     -  'the RMSD will be calculation will be (further) restricted to',
     -  'these residues. This choice will not effect the             ',
     -  'superimposition (if requested).                             ',
     -  '**** 69                                                     ',
     -  'Yes answer will allow the selection of atoms for the RMSD   ',
     -  'calculation. Superimposition (if requested) will be done    ',
     -  'based on the selected atoms only.                           ',
     -  '**** 70                                                     ',
     -  'This question settles the treatment of more than one        ',
     -  'hydrogen or hydrophobic bonds between some residue pairs.   ',
     -  'Asking for averaging will calculate the bond fractions as   ',
     -  'the total number of bonds divided by the number of frames   ',
     -  'and by the number of possible bonds between this residue    ',
     -  'pair. Asking for cumulative averaging will result in        ',
     -  'dividing by the number of frames only. Asking for ignoring  ',
     -  'multiple contacts will just average the number of times this',
     -  'residue pair was in contact through any of the possible     ',
     -  'bonds.                                                      ',
     -  '**** 71                                                     ',
     -  'Yes answer will allow only hydrogen or hydrophoboc bonds or ',
     -  'hydrogen-bonded bridges where both ends are on the anchor   ',
     -  'list. No answer will allow all  bonds or bridges involving  ',
     -  'anchor atoms.                                               ',
     -  '**** 72                                                     ',
     -  'Atoms forming a non-covalent bond are called the anchor     ',
     -  'atoms. This quiz selects the solute atoms that are allowed  ',
     -  'to be anchor atoms (i.e., form a non-covalent bond). This   ',
     -  'notation arose because a hydrogen bond is a special case of ',
     -  'H-bonded bridge (an other analysis option).                 ',
     -  '**** 73                                                     ',
     -  'Yes answer will produce an smaller matrix. The actual       ',
     -  'residues corresponding to the matrix rows and colums are    ',
     -  'printed ont the .hbn file. No answer will plot a matrix with',
     -  'all residues.                                               ',
     -  '**** 74                                                     ',
     -  'The default is the maximum of the average number of hydrogen',
     -  'or hydrophobic bonds between a residue pair. It may be worth',
     -  'rounding up to the nearest integer to facilitate comparison.',
     -  '**** 75                                                     ',
     -  'This quiz selects the solute atoms that are allowed to form '/
      data answers7 /
     -  'hydrophobic bond                                            ',
     -  '**** 76                                                     ',
     -  'The number read will be used as the maximum carbon-carbon   ',
     -  'distance in a hydrophobic bond                              ',
     -  '**** 77                                                     ',
     -  'Hydrophobic bonds can be formed between carbons that have   ',
     -  'a (chemical) bond to hydrogens. This input can filter out   ',
     -  'carbons with too few hydrogens (e.g., alpha carbons).       ',
     -  '**** 78                                                     ',
     -  'Subclustering is based on temporarily removing structures   ',
     -  'than can be considered to be on the surface of its cluster. ',
     -  'Indicator of being on the surface can be the number of      ',
     -  'structures within the clustering cutoff (N) or a measure of ',
     -  'local density (D).                                          ',
     -  '**** 79                                                     ',
     -  'Structures whose local density is lower than the maximum    ',
     -  'density observed in the cluster will be deemed to be on the ',
     -  'surface.                                                    ',
     -  '**** 80                                                     ',
     -  'This question arise when there are both regular solute      ',
     -  'molecules and molecular residues in the system. No answer   ',
     -  'will result in PBC centering based on the regular molecules ',
     -  'only while yes answer will center the aggregate of regular  ',
     -  'molecules and molecular residues.                           ',
     -  '**** 81                                                     ',
     -  'The local density descriptor for each member of the set is  ',
     -  'the sum of 1/Rij^denexp over the distances to the other     ',
     -  'cluster members.                                            ',
     -  '**** 82                                                     ',
     -  'New atom order can be defined by either a .sort file created',
     -  'by a previous Simulaid run or the atom numbers of a         ',
     -  'rearranged Charmm CRD or a PDB file or a template file whose',
     -  'atoms will be matched to the input structure on a residue by',
     -  'residue basis                                               ',
     -  '**** 83                                                     ',
     -  'The residue-residue matrix showing the fraction of contacts ',
     -  'may be based on all bonds or on the bonds after filtering   ',
     -  'by % occurrence and interresidue distance                   ',
     -  '**** 84                                                     ',
     -  'The the bond presence toggles will be averaged over the     ',
     -  'number of frames given my this input                        ',
     -  '**** 85                                                     ',
     -  'Correlation measure can only consider either only the states',
     -  'when both bonds are present (on) or consider both the joint ',
     -  'presence and joint absence of bonds for correlation.        ',
     -  'The correlation measure can also be scaled by the mean % of ',
     -  'time the bonds are present, giving higher weight to more    ',
     -  'persistent bond.                                            ',
     -  'Presence of a bond may also be calculated as an average over',
     -  'consecutive frames.                                         '/
      data answers8 /
     -  '**** 86                                                     ',
     -  'When greater than zero is given then for each cluster the   ',
     -  'program will calculate the number of structure pairs that   ',
     -  'are within this threshold. For cross-RMSD calculations, for ',
     -  'each cluster pair the program will calculate the number of  ',
     -  'pairs (one from each cluster) that are within this          ',
     -  'threshold.                                                  ',
     -  '**** 87                                                     ',
     -  'Only structure pairs within this RMSD threshold will be     ',
     -  'mapped to each other                                        ',
     -  '**** 88                                                     ',
     -  'Answering 1, 2 or 3 will exclude the X, Y, or Z  axis from  ',
     -  'the PBC calculation.                                        ',
     -  '**** 89                                                     ',
     -  'Answering <A> will define the new atom X by specifying the  ',
     -  'atoms of a bonded chain X-R1-R2-R3, the X-R1 distance the   ',
     -  'X-R1-R2 angle and the X-R1-R2-R3 torsion                    ',
     -  'Answering <B> will define the new atom X by specifying the  ',
     -  'atom R1 X is bonded to where R1 has exactly two neighbors   ',
     -  '(R2 and R3) and the X-R1 distance. The new atom will be     ',
     -  'placed alomg the negative bisector of the R2-R1-R3 angle.   ',
     -  'Answering <T> will define the new atom X by specifying the  ',
     -  'atom R1 X is bonded to where R1 has exactly three neighbors ',
     -  '(R2, R3 and R4) and the X-R1 distance. The new atom will be ',
     -  'placed away from the plane of the tree atoms R2, R3 and R4. ',
     -  '**** 90                                                     ',
     -  'Answering <y> will allow the repetition of clustering using ',
     -  'the previously calculated 2D RMSD matrix                    ',
     -  '**** 91                                                     ',
     -  'Answering <y> will ask for the previously calculated 2D RMSD',
     -  'matrices of the two trajectories and the cross-RMSD matrix, ',
     -  'repeat the clustering of both trajectories and map          ',
     -  'the calculated clusters of one trajectory to those of the   ',
     -  'other (will do the mapping bith ways)                       ',
     -  '**** 92                                                     ',
     -  'K-means clustering result in general depend on the choice of',
     -  'initial cluster centers. Resetting seed of the rundom-number',
     -  'generator will ensure that the clustring will reproduce     ',
     -  'the result of previous calculations.                        ',
     -  '**** 93                                                     ',
     -  'Answering <Y> will plot the average (R)MSD as a finction of ',
     -  'runlength and the distribution of the RMSD values.          ',
     -  '**** 94                                                     ',
     -  'For contact maps involving molecules A and B where contacts ',
     -  'within one of the interacting molecules, say B, is ignored  ',
     -  'setting the Y axis range to the range of residues in A will ',
     -  'result in a more compact plot.                              ',
     -  '**** 95                                                     ',
     -  'This input sets the number of different colors in the plots ',
     -  '**** 96                                                     '/
      data answers9 /
     -  'Answering <Y> will fit a plane to the atoms of the proline  ',
     -  'ring and use the projections of the ring atoms on that plane',
     -  'to determine the Wobble and Face Shift angles. This will    ',
     -  'reduce the noise due to the ring conformation fluctuations. ',
     -  '**** 97                                                     ',
     -  'Answering <Y> will allow the user to specify a rotation that',
     -  'will be applied to each configuration read from the         ',
     -  'trajectory before analysis. This is useful if some analysis ',
     -  'requires different convention from the one it was run with. ',
     -  '**** 98                                                     ',
     -  'MMC allows the definition of copies of solute atoms with the',
     -  'key CLON. Answering <Y> allows the specification of this    ',
     -  'info.                                                       ',
     -  '**** 99                                                     ',
     -  'Answering <Y> will result in Simulaid reading each number   ',
     -  'from a different line. Answering <N> will result in reading ',
     -  'both numbers of a pair from the same line (separated by , ) ',
     -  '**** 100                                                    ',
     -  'Residues with this name will serve as members of the        ',
     -  'hydrogen-bonded bridge. Usually this is the solvent.        ',
     -  '**** 101                                                    ',
     -  'The selected atomic property will be calculated for the     ',
     -  'atoms of the input structure and, optionally, for atoms in  ',
     -  'all frames of a trajectory. A structure file will be saved  ',
     -  'with the calculated values in the data column if each file. ',
     -  '**** 102                                                    ',
     -  'The selected molecular property will be calculated for a    ',
     -  'user-selected solute molecule of the input structure and,   ',
     -  'optionally, for all frames of a trajectory.                 ',
     -  '**** 103                                                    ',
     -  'Unpacking creates individual structures from a user-selected',
     -  'set of conformations, extracted either from a structure file',
     -  'containing multiple conformations or from a trajectory.     ',
     -  'unpacked files may contain single or multiple conformations.',
     -  'Packing creates a trajectory from a set of structure files  ',
     -  'that contain a single or multiple configurations.           ',
     -  '**** 104                                                    ',
     -  'Trajectory conversion allow not only to switch to a new     ',
     -  'format but also to limit the conversion to selected         ',
     -  'structures. Furthermore, option is provided to change the   ',
     -  'order of the atoms, based on either the comparison of two   ',
     -  'structure files or on a user-provided match list.           ',
     -  '**** 105                                                    ',
     -  'Answering yes will ask the user to input pairs of atom      ',
     -  'clusters (by the atom indices) and calculate the smallest   ',
     -  'distance between the members of the two clusters and        ',
     -  'calculate their average, SD and distribution                ',
     -  '**** 106                                                    ',
     -  'Answering yes will calculate the closest approach between   ',
     -  'residues using only the heavy atoms                         '/
      data answers10 /
     -  '**** 107                                                    ',
     -  'Answering yes will make the interactive quizzes independent ',
     -  'of the data. This will help running Simulaid from a script. ',
     -  '**** 108                                                    ',
     -  'A. Schuyler found that the column sums of the succesive     ',
     -  'powers of the adjacency matrix (defined for a graph with    ',
     -  'residues as the nodes and edges between residues within     ',
     -  'threshold distance) develop peaks at the flexible regions   ',
     -  'of the protein. If the matrix elements instead represent    ',
     -  'the closeness of the contact, then a similar measure is     ',
     -  'obtained if in the matrix product Aik*Bkj is replaced by    ',
     -  'Aik+Bkj.                                                    ',
     -  '**** 109                                                    ',
     -  'A list of single-digit numbers can be read that characterize',
     -  'each residue and the plot of the colum sums can be appended ',
     -  'user-defined marks on the top of the plot.                  ',
     -  '**** 110                                                    ',
     -  'Changing the default 3 to 2 results in 2D PBC calculation.  ',
     -  'The user may have to specify the axis to exclude.      .    ',
     -  'Changing the default 3 to 1 results in 1D PBC calculation.  ',
     -  'The user may have to specify the axis to keep.         .  . ',
     -  '**** 111                                                    ',
     -  'Reference residues are the residues whose neighboring       ',
     -  'residues will be listed. Neighboorhood residues are the ones',
     -  'whose distance from the reference residues will be checked. ',
     -  'Both type of residues have form a contiguous residue list.  ',
     -  '**** 112                                                    ',
     -  'Answering no will abort the scan. Answering no will turn off',
     -  'the storing of the bond information but continue printing   ',
     -  'them.                                                       ',
     -  '**** 113                                                    ',
     -  'For labeling the X axis of the trajectory plots, this value ',
     -  'will be used for the time between the PROCESSED trajectory  ',
     -  'frames (depending on the sampling increment specified below)',
     -  '**** 114                                                    ',
     -  'The number read will be added to the file numbers generated ',
     -  'from the structure number. Thus, when all structures are    ',
     -  'extracted, the first file will be <name>.<increment>.<ext>  ',
     -  '**** 115                                                    ',
     -  'The atoms of the input structure in the range specified will',
     -  'be clustered based on their Cartesian distance              ',
     -  '**** 116                                                    ',
     -  'The property names are the symbols listed at the head of the',
     -  'statistics.out file.                                        ',
     -  '**** 117                                                    ',
     -  'Answering yes will add a mark m and M to the minmum and     ',
     -  'maximum energies, resp., to each residue, in each column    ',
     -  '**** 118                                                    ',
     -  'Carbons that are chemically bonded are automatically        ',
     -  'excluded. To exclude 1-3 or 1-4 carbons answer 3 or 4, resp.'/
      data answers11 /
     -  '**** 119                                                    ',
     -  'Selecting the different structure file option will try to   ',
     -  'match the atom and residue names between the original       ',
     -  'structure and the structure read here while selectig the    ',
     -  'read the new order option will let you use either the atom  ',
     -  'sequence number of a PDB or Charmm CRD file or a .sort file ',
     -  'prepared by Simulaid.                                       ',
     -  '**** 120                                                    ',
     -  'Answering no will let you select atoms over which the RMSD  ',
     -  'will be calculated that were not used in the overlay        ',
     -  '**** 121                                                    ',
     -  'The 2D RMSD matrix plot file can be rather large for large  ',
     -  'number (> 1000) number of structures. Yes answer will omit  ',
     -  'the creation of the plot file.                              ',
     -  '**** 122                                                    ',
     -  'Before plotting the entries in each succesive navg*navg     ',
     -  'submatrices will be averaged. This avoids the generation of ',
     -  'excessive Posscript files whose resolution is likely to     ',
     -  'exceed the resolution of the output devices.                ',
     -  '**** 123                                                    ',
     -  'Some topology files use names like HA2, HA3 instead of HA1, ',
     -  'HA2 for methylene-type hydrogens. Yes answer will convert   ',
     -  'all X2, X3 names to X1, X2.                                 ',
     -  '**** 124                                                    ',
     -  'Some programs fail when reading a PDB file that has no space',
     -  'between the occupancy and B-factor columns. Yes answer will ',
     -  'result in the merging of the two entries, no answer will    ',
     -  'result in truncation of some B-factor entries.              ',
     -  '**** 125                                                    ',
     -  'yes answer will diagonalize the covariance matrix (to give, ',
     -  'e.g., the normal modes)                                     ',
     -  '**** 126                                                    ',
     -  'When the deviation from integer charge sum appears to be    ',
     -  'just round-off error then this option can redistribute the  ',
     -  'charge increments to resultin integral charges. Use only    ',
     -  'when all deviations are just a few hundreds of electron     ',
     -  '**** 127                                                    ',
     -  'Originally Amber wrote box info just after the first frame. ',
     -  'Later versions allowed to write box information after each  ',
     -  'frame. Furthermore, VMD requires either box inf after each  ',
     -  'frame or non at all.                                        ',
     -  '**** 128                                                    ',
     -  'No answer will just print one line per component: eigenvalue',
     -  'and the components of the corresponding eigenvector         ',
     -  '**** 129                                                    ',
     -  'Yes answer will write file for each cluster (at the cutoff  ',
     -  'level specified earlier with a list of its ligand and their ',
     -  'ranks into a user-specified directory                       ',
     -  '**** 130                                                    ',
     -  'Yes answer will print the distances between all pairs of    '/
      data answers12 /
     -  'cluster centers (representative elements)                   ',
     -  '**** 131                                                    ',
     -  'Yes answer will detect the solute molecule boundaries and   ',
     -  'generate different chain/segment ids for them. Option is    ',
     -  'also goven to just blank then out.                          ',
     -  '**** 132                                                    ',
     -  'If both distances compared exceeds this value, then the     ',
     -  'difference  is set to zero                                  ',
     -  '**** 133                                                    ',
     -  'When a torsion moves only hydrogens, includ it only when the',
     -  'number of hydrogens is not larger than the input givn here  ',
     -  '**** 134                                                    ',
     -  'Current format uses 6-character potential labels; the old   ',
     -  'format uses 4-character potential labels                    ',
     -  '**** 135                                                    ',
     -  'Yes answer will consider the track between the first and    ',
     -  'on states for the purpose of calculating average on and off ',
     -  'segments; no answer will use the last frame to and the track',
     -  '**** 136                                                    ',
     -  'Yes answer will start gathering correlation data only after ',
     -  'both tracks started; no answer will start the data gathering',
     -  'when either of the correlated track started                 ',
     -  '**** 137                                                    ',
     -  'Yes answer try to use both Charmm and Amber conventions for ',
     -  'the truncated octahedron PBC cell orientaton                ',
     -  '**** 138                                                    ',
     -  'No answer will put the % of times an atom formed bonds into ',
     -  'the temperature factor (beta) columnn for each atom; yes    ',
     -  'answer will sum up the % values within each residue and put ',
     -  'the sum into the temperature factor column of all atoms in  ',
     -  'that residue                                                ',
     -  '**** 139                                                    ',
     -  'The k-medoids clustering iteration selects new cluster      ',
     -  'centers for each putative cluster. It can be either the node',
     -  'whose maximum or average distance with the rest of the      ',
     -  'members is the lowest or the node whose average rank, based ',
     -  'on the maximum of average distances is the lowest           ',
     -  '**** 140                                                    ',
     -  'Yes answer will add bonds (CONECT records in the PDB file)  ',
     -  'beween the CA (or first) atoms of the residue pairs whose   ',
     -  'bond tracks were plotted  and add a He atom to the middle of',
     -  'each bond whose residue number is the bond number on the    ',
     -  'bond track plots. If residue-residue bond correlations were ',
     -  'requested, the He atoms of correlated or anticorrelated     ',
     -  'residue pairs will also be connected                        ',
     -  '**** 141                                                    ',
     -  'C will connect nodes when the number of common neighbors is ',
     -  'not less than an input minimum; the M option also requires  ',
     -  'that the nodes be within a minimum distance; the U option   ',
     -  'connects nodes within a minimum distance when both have     '/
      data answers13 /
     -  'neighbors not less than the input minimum neighbor number   ',
     -  '**** 142                                                    ',
     -  '2D trace plots can be smoothed by plotting the averaged     ',
     -  'coordinates                                                 ',
     -  '****                                                        ',
     -  45*
     -  '                                                            '/
      data answers /
     -  350*
     -  '                                                            '/
      end
