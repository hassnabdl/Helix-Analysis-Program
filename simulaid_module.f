module simulaid
contains
          subroutine readconf(inpt,inpcrdtyp,iruntyp,iruntypclean,
         -  inpfile,namleni,outfile,namleno,line,title,ititle,trtitle,
         -  ntitlin,ntitltr,nconfig,ncol,n,nlines,nsegm,nosegid,iisegcol,
         -  index,c,iresno,iatnum,isegno,froccin,charge,segid4,altcol,
         -  inscol,iundef,naltnam,nrecdel,ninsres,lineread,nneig,ineig,iha,
         -  itrunc,iendfound,ioktoend,istopatend,iqha,imodelkeep,newsega,
         -  newsegr,neednnlist,ietotread,etotread,bfacavg,molname,
         -  molnamelen,pdbid,iclone,iask77_78,iread77_78,iwarn77_78,
         -  iblank67_76,iask67_76,innlistread,iout,maxrepconf,maxng,maxrec,
         -  maxrsd)
          character*(*) inpfile,outfile
          character* 132 line(maxrec)
          character*80 title,trtitle(32),molname,linewr
          character*4 segid4(maxrsd),pdbid
          character*1 altcol(maxrec),inscol(maxrec)
          dimension c(3,maxrec),index(maxrec),iresno(maxrec),iatnum(maxrec),
         -  isegno(maxrec),froccin(maxrec),charge(maxrec),iisegcol(2,13),
         -  nneig(maxrec),ineig(maxng,maxrec),bfacavg(maxrsd)
          common /clonedat/ nclone,iaclnf(1000),iaclnl(1000),ncopcln(1000)
          character*11 formatname
          common /formats/ iqdconv(20),formatname(19)
          character*5 crdext
          common /iotypes/ iocha,iochaex,iobpdb,iocpdb,ioa3pdb,ioa4pdb,
         -  iommod,iommc,iommc4,iogro,iomol2,iomae,iocif,ioxxx,ioins,
         -  ionxyz,iosxyz,iosxyzrq,iograsp,iofull,lext(19),crdext(19)
          character*2 iatnm2
          common /atnam/ aw(99),nval(99),nvalmax(99),mmofan(99),
         -  mmatno(64),iatnm2(99)
          common /askCA/ iaskca,nocalcium
          common /logging/ logfile,ipredict
          real*8 bfacsum
          character*1 altnam(50),s1,asterisk,ans
          character*2 atsymbol
          character*4 s4,segidprev
          character*8 atomnam
          character*8 segmid
          character*6 rnu
          character*51 question
          character* 132 lineinp,lineprev,linenext
          character*200 altfile
          dimension noblank3(132),in12(2)
          data nnoblank3 /15/, noblank3
         -  /1,5,11,13,19,21,27,29,35,37,43,45,51,119,124,117*0/
          data asterisk/'*'/, question
         -   /'Clone   : original index of the first and last atom'/
          iaskagain=0
          nclone=0
          iendfound=0
          iunrecog=0
          naltnam=0
          itrunc=0
          icinc=0
          nosegid=0
          etotread=0.0
          bfacsum=0.d0
          nbfacsum=0
          nbfacsumtot=0
          ikeepfullalt=-1
          innlistread=0
          naltrec=0
          naltdel=0
          ninsres=0
          call setcol(inpcrdtyp,ncol,idcol,ialtcol,iinscol,
         -  inamcol1,inamcol2,irescol1,irescol2,iccol1,iccol2,
         -  iresncol1,iresncol2,iseqncol1,iseqncol2,isegcol1,isegcol2,
         -  iresidcol1,iresidcol2,iqcol1,iqcol2,ipotcol1,ipotcol2,
         -  iocccol1,iocccol2,ichemcol1,ichemcol2,nrescol,nresncol,
         -  nsegcol,nnamcol,iofull)
          iresnoprev=0
          iresinc=0
          incresno=0
          lineread=0
          linefread=0
          if (iresncol2-iresncol1 .lt. 8)
         -  incresno=10**(iresncol2-iresncol1+1)-1
          nsegmid=isegcol2-isegcol1+1
    100   if (ischarmm(inpcrdtyp) .eq. 1) then
            call blankout(lineinp,1,ncol)
            do i=1,maxrec
              if (linefread .eq. 0) read (inpt,1001,end=9999) lineinp
              lineread=0
              line(i)=lineinp
              if (i .eq. 1) then
                 if (lineinp(1:1) .ne. '*') then
                   write (6,1215) inpfile(1:namleni),'Charmm CRD'
                   namleni=0
                   iunrecog=1
                 end if
                 title=lineinp(3:80)
              end if
              if (lineinp(1:1) .ne. '*') then
                go to 11
              else if (i .gt. 32) then
                write (6,1213) i
                stop
              else
                trtitle(i)=lineinp(3:80)
                call checkforetot(1,lineinp,nconfig,etotread,ietotread,1)
              end if
              ntitlin=i
              ntitltr=i
              if (nconfig .le. maxrepconf) then
                call lastchar(lineinp,ifc,ncol)
                write (6,1010) lineinp(1:ifc)
              end if
            end do
    11      lineread=ntitlin+1
            call lastchar(lineinp,lc,ncol)
            if (lc .le. 1 .and. lineinp(1:1) .eq. ' ') go to 9917
            if (inpcrdtyp .eq. iocha) read (lineinp(1:6),*,err=9915) n
            if (inpcrdtyp .eq. iochaex) read (lineinp(1:10),*,err=9915) n
            line(lineread)=lineinp
            nlines=ntitlin+1+n
            if (n .lt. 1) then
              print *,'ERROR: non-positive number of atoms found:',n
              stop
            end if
            call checkdim(nlines,MAXREC,'MAXREC',6,'number of lines',15,0)
            print *,'Reading',n,' atoms; configuration #:',nconfig
            segmid='        '
            do i=1,n
              read (inpt,1001,end=3000) lineinp
              line(ntitlin+1+i)=lineinp
              index(i)=ntitlin+1+i
              if (i .gt. 1) then
                if (lineinp(isegcol1+icinc:isegcol2+icinc) .ne.
         -          segmid(1:nsegmid)) then
                  nsegm=nsegm+1
                  iresinc=0
                end if
              end if
              isegno(i)=nsegm
              call readint(lineinp,iresncol1+icinc,iresncol2+icinc,
         -      iresno(i),2,0,ierr)
              if (ierr .gt. 0) go to 9919
              if (iresnoprev-iresno(i) .eq. incresno .and. incresno .ne. 0)
         -      iresinc=iresinc+incresno+1
              iresnoprev=iresno(i)
              iresno(i)=iresno(i)+iresinc
              lineread=ntitlin+i+1
              if (inpcrdtyp .eq. iocha) then
                read (lineinp(iccol1+icinc:iccol2+icinc),1101,err=9911)
         -        (c(k,i),k=1,3)
              else
                read (lineinp(iccol1+icinc:iccol2+icinc),1105,err=9911)
         -        (c(k,i),k=1,3)
              end if
              if (iqcol2 .ge. iqcol1)
         -      read (lineinp(iqcol1:iqcol2),*,err=9912,end=8801) charge(n)
              go to 8802
    8801      charge(n)=0.0
    8802      iatnum(i)=
         -      ianum(lineinp(inamcol1+icinc:inamcol2+icinc),1,nnamcol)
              lineprev=lineinp
              if (inpcrdtyp .eq. iocha) then
                segmid(1:nsegmid)=lineinp(isegcol1+icinc:isegcol2+icinc)
              else
                call leftadjustline(lineinp,isegcol1,isegcol2)
                segmid(1:4)=lineinp(isegcol1:isegcol1+3)
              end if
              if (i .eq. 999999) icinc=1
            end do
          else if (ispdb(inpcrdtyp) .gt. 0) then
            iundef=0
            ititfound=0
            ititrfound=0
            ntitltr=0
            ntitlin=0
            linenext_read=0
            namlena=0
            molnamelen=0
            iatseqnumprev=0
            ignoresegnojump=0
            if (inpcrdtyp .ne. iobpdb) then
               iask67_76=0
               iblank67_76=0
            end if
            lineinp(1:1)='X'
            if (nconfig .eq. 0 .and. inpcrdtyp .ne. ioa4pdb) then
              if (ipredict .eq. 1) then
                write (6,2077)
                call askyn(
         -        'Do you want to read chemical symbols from col 77-78',51,
         -        1,1,iread77_78,0,0)
                if (iread77_78 .eq. 1) nocalcium=0
                iask77_78=0
              end if
            else
              iask77_78=0
            end if
            i=0
            do while (lineinp(1:4) .ne. 'ATOM' .and.
         -            lineinp(1:6) .ne. 'HETATM' .and. i .lt. maxrec)
              i=i+1
              call blankout(lineinp,1,ncol)
              read (inpt,1001,end=9999) lineinp
              call lastchar(lineinp,lcinp,ncol)
              lineread=i
              call checkforetot(6,lineinp,nconfig,etotread,ietotread,1)
              line(i)=lineinp
              if (lineinp(1:5) .eq. 'TITLE' .and. ititrfound .eq. 0) then
                title=lineinp(7:80)
                ititle=1
                ititrfound=1
                ititfound=1
              end if
              if (lineinp(1:6) .eq. 'HEADER') pdbid=lineinp(63:66)
              if (ititfound .eq. 0 .and. (lineinp(1:6) .eq. 'HEADER'
         -        .or. lineinp(1:6) .eq. 'REMARK')) then
                title=line(i)(7:80)
                ititfound=1
              end if
              if ((lineinp(1:5) .eq. 'TITLE' .or. lineinp(1:6) .eq. 'HEADER'
         -        .or. lineinp(1:6) .eq. 'REMARK')
         -        .and. ntitltr .lt. 32) then
                ntitltr=ntitltr+1
                trtitle(ntitltr)=lineinp(7:80)
              end if
              if (nconfig .le. maxrepconf) then
                if (lineinp(1:6) .eq. 'HEADER' .or.
         -          lineinp(1:5) .eq. 'TITLE' .or.
         -          lineinp(1:6) .eq. 'REMARK' .and. i .lt. 11) then
                  write (iout,1015) lineinp(1:min0(79,lcinp))
                end if
              end if
              if (lineinp(1:31) .eq. 'REMARK    Name               : ') then
                ic=32
                call nextblank(lineinp,ic,ncol)
                molnamelen=ic-32
                molname(1:molnamelen)=lineinp(32:ic-1)
              end if
              if (lineinp(1:5) .eq. 'MODEL' .or. ipredict. eq. 1) then
                if (imodelkeep .eq. -1) call quiz(ans,imodelkeep,'k',' ',0,
         -        'MODEL record treatment',22,0,5,6,0)
                if (imodelkeep .gt. 1) then
                  line(lineread)(1:6)='REMARK'
                end if
              end if
              ntitlin=ntitlin+1
            end do
            index(1)=ntitlin
            nlines=ntitlin
            ntitlin=ntitlin-1
            n=0
            nhdel=0
            nudel=0
            lineread=ntitlin
            do while (.true.)
              if (lineread .gt. ntitlin) then
                if (linenext_read .eq. 0) then
                  call blankout(lineinp,1,ncol)
                  read (inpt,1001,end=23) lineinp
                else
                  lineinp=linenext
                  linenext_read=0
                end if
                call checkdim(nlines,MAXREC,'MAXREC',6,'number of lines',15,
         -        0)
                line(lineread+1)=lineinp
                nlines=nlines+1
              end if
              lineread=lineread+1
              if (lineinp(1:5) .eq. 'MODEL') then
                if (imodelkeep .gt. 1) line(lineread)(1:6)='REMARK'
              else if (lineinp(1:6) .eq. 'ENDMDL') then
                if (imodelkeep .eq. 2) then
                  line(lineread)(1:6)='REMARK'
                else if (imodelkeep .eq. 3) then
                  line(lineread)(1:6)='END   '
                else if (imodelkeep .eq. 4) then
                  line(lineread)(1:6)='TER   '
                end if
                go to 23
              else if (lineinp(1:3) .eq. 'END' .and. lineinp(4:7).ne. 'ROOT'
         -      .and. lineinp(4:9) .ne. 'BRANCH') then
                if (iruntyp .eq. 12 .and. lineinp(1:3) .eq. 'END') go to 23
                if (istopatend .eq. 1) then
                  go to 23
                else if (istopatend .eq. -1) then
                  call blankout(linenext,1,ncol)
                  read (inpt,1001,end=23) linenext
                  call lastchar(linenext,ilc,ncol)
                  print *,'Data after END was found:'
                  print *,linenext(1:ilc)
                  linenext_read=1
                  call askyn(
         -          'Do you want to replace middle END records with TER',
         -          50,0,-1,istopatend,000,0)
                  if (istopatend .eq. 1) go to 23
                  lineinp(1:3)='TER'
                else
                  lineinp(1:3)='TER'
                end if
              end if
              if (lineinp(1:3) .eq. 'TER' .and. nbfacsum .gt. 0) then
                if (nbfacsum .gt. 0) bfacavg(nsegm)=bfacsum/nbfacsum
                nsegm=nsegm+1
                iresinc=0
                nbfacsumtot=nbfacsumtot+nbfacsum
                bfacsum=0.d0
                nbfacsum=0
              end if
              if (lineinp(1:6) .eq. 'HETATM' .and. iqha .eq. 0
         -        .and. ipredict .eq. 0) then
                call askyn('Do you want to include heteroatoms',34,1,1,iha,
         -        16,0)
                iqha=1
              end if
              if (lineinp(1:4) .eq. 'ATOM' .or.
         -             lineinp(1:6) .eq. 'HETATM') then
                if (lineinp(iccol1:iccol2) .eq.
         -        '************************') then
                  if (iundef .eq. 0) then
                    write (6,2032)
                    call askyn('Do you want to drop the atom',28,1,-1,
         -            idrop,00,0)
                    if (idrop .eq. 1) then
                      iundef=1
                    else
                      iundef=2
                    end if
                  end if
                  if (iundef .eq. 1) then
                    lineinp(idcol:idcol)=asterisk
                    nudel=nudel+1
                    go to 210
                  end if
                end if
    210         n=n+1
                if (n .eq. 1) segidprev='****'
                call checkdim(n,MAXREC,'MAXREC',6,'number of atoms',15,0)
                index(n)=nlines
                icont=0
                if (n .eq. 1 .and. nconfig .eq. 0) then
                  s4=lineinp(iisegcol(1,iocpdb):iisegcol(2,iocpdb))
                  s1=lineinp(iisegcol(1,iobpdb):iisegcol(2,iobpdb))
                  if (s1 .eq. ' ' .and. s4 .eq. '    ') then
                    if (iruntyp .ne. iruntypclean .and.
         -              nconfig .le. maxrepconf) then
                      print *,'WARNING: segment ID is missing - you may ',
         -              'have to run a CLEAN operation'
                      nosegid=1
                    end if
                  else if (inpcrdtyp .eq. iobpdb) then
                    if (s1 .eq. ' ') then
                      write (6,2115) 'Charmm',' ','SSSS','S','    '
                      icont=1
                    end if
                  else
                    if (s4 .eq. '    ') then
                      write (6,2115) 'Brookhaven','S','    ',' ','SSSS'
                      icont=1
                    end if
                  end if
                end if
                if (icont .gt. 0) call askstop(1)
                if (lineinp(1:6) .eq. 'HETATM' .and. iha .eq. 0) then
                  lineinp(idcol:idcol)=asterisk
                  nhdel=nhdel+1
                else
                  if (lineinp(7:11) .eq. '*****') then
                    iatseqnum=iatseqnumprev+1
                    write (lineinp(7:11),1007) mod(iatseqnum,100000)
                  else
                    read (lineinp(7:11),*) iatseqnum
                  end if
                  if (inpcrdtyp .eq. iocpdb .or. inpcrdtyp .eq. ioa3pdb .or.
         -            inpcrdtyp .eq. ioa4pdb)
         -          call leftadjustline(lineinp,irescol1,irescol2)
                  if (n .gt. 1) then
                    if (lineinp(isegcol1:isegcol2) .ne.
         -              segidprev(1:nsegmid)) then
                      bfacavg(nsegm)=0.0
                      nsegm=isegno(n-1)+1
                      if (nbfacsum .gt. 0) bfacavg(nsegm)=bfacsum/nbfacsum
                      nbfacsumtot=nbfacsumtot+nbfacsum
                      bfacsum=0.d0
                      nbfacsum=0
                    else if (iatseqnum .lt. iatseqnumprev .and.
         -                   iatseqnumprev .ne. 99999 .and.
         -                   ignoresegnojump .eq. 0) then
                      write (6,1216) iatseqnum,iatseqnumprev
                      if (ipredict .eq. 0) then
                        call askyn('Do you want to start a new segment',34,
         -                1,1,newsega,000,0)
                        if (newsega .eq. 0) then
                          call askyn(
         -                  'Do you want to ignore all sequence # jumps',42,
         -                  1,1,ignoresegnojump,000,0)
                          print *,'NOte, that the <C>lean option can fix ',
         -                  'such sequence number jumps'
                        end if
                      end if
                      if (nsegm .eq. isegno(n-1) .and. newsega .eq. 1) then
                        nsegm=nsegm+1
                        iresinc=0
                      end if
                    end if
                  end if
                  isegno(n)=nsegm
                  iatseqnumprev=iatseqnum
                end if
                if (lineinp(iccol1:iccol2) .eq.
         -        '************************') then
                  do k=1,3
                    c(k,n)=999.9
                  end do
                  write (lineinp(iccol1:iccol2),1102) (c(k,n),k=1,3)
                else
                  read (lineinp(iccol1:iccol2),1102,err=9911) (c(k,n),k=1,3)
                end if
                nnbl=0
                do ic=67,min0(76,lcinp)
                  if (lineinp(ic:ic) .ne. ' ') nnbl=nnbl+1
                end do
                if (nnbl .gt. 0 .and. iblank67_76 .eq. 1) then
                  if (iask67_76 .eq. 1) then
                    print *,'Columns 67-76 are not blank'
                    call askyn('Do you want to blank out columns 67-76',38,
         -            1,1,iblank67_76,0,0)
                    iask67_76=0
                  end if
                  if (iblank67_76 .eq. 1) call blankout(lineinp,67,76)
                end if
                iatnum(n)=99
                if (lineinp(77:78) .eq. '  ' .and. iread77_78 .eq. 1) then
                  if (iwarn77_78 .eq. 1) then
                    write (6,2031) lineinp(1:min0(79,lcinp))
                    iwarn77_78=0
                  end if
                else
                  if (iread77_78 .eq. 0 .and. iask77_78 .eq. 1) then
                    idef=1
                    if (lineinp(77:78) .eq. '  ') idef=-1
                    call askyn(
         -            'Do you want to read chemical symbols from col 77-78',
         -            51,1,idef,iread77_78,0,0)
                    iask77_78=0
                    if (n .gt. 1 .and. iread77_78 .eq. 1) write (6,2033)
                    if (iread77_78 .eq. 1) nocalcium=0
                  end if
                  if (iread77_78 .eq. 1) then
                    if (lineinp(77:77) .ne. ' ') then
                      call uplow(lineinp(78:78),lineinp(78:78),1,noabc)
                      iatnum(n)=ianum(lineinp(77:78),1,2)
                    else
                      atsymbol(1:1)=lineinp(78:78)
                      atsymbol(2:2)=' '
                      iatnum(n)=ianum(atsymbol,1,2)
                    end if
                    if (iatnum(n) .eq. 99) write (6,2034) n,lineinp(77:78),
         -            lineinp(1:min0(79,lcinp))
                  end if
                end if
                if (iatnum(n) .eq. 99)
         -        iatnum(n)=ianum(lineinp(inamcol1:inamcol2),1,nnamcol)
                call readint(lineinp,iresncol1,iresncol2,iresno(n),2,0,
         -        ierr)
                if (ierr .gt. 0) go to 9919
                if (iresno(n) .lt. iresnoprev .and.
         -        lineinp(isegcol1:isegcol2) .eq. segidprev(1:nsegmid)) then
                  if (newsegr .eq. -1) then
                    write (6,1217) iresno(n),iresnoprev,iatseqnum,n
                    idefans=1
                    if (iresnoprev .eq. 9999) idefans=-1
                    call askyn('Do you want to start a new segment',34,
         -            1,idefans,newsegr,000,0)
                  end if
                  if (newsegr .eq. 1) then
                    isegdec=0
                    if (n .gt. 1) then
                      if (isegno(n) .gt. isegno(n-1)) isegdec=1
                    end if
                    if (isegdec .eq. 0) then
                      nsegm=nsegm+1
                      isegno(n)=nsegm
                    end if
                  end if
                end if
                if (ialtcol .gt. 0) altcol(n)=lineinp(ialtcol:ialtcol)
                if (iinscol .gt. 0) then
                  inscol(n)=lineinp(iinscol:iinscol)
                  if (inscol(n) .ne. ' ') ninsres=ninsres+1
                end if
                if (iresnoprev-iresno(n) .eq. incresno .and. incresno .ne.0)
         -        iresinc=iresinc+incresno+1
                segidprev(1:nsegmid)=lineinp(isegcol1:isegcol2)
                froccin(n)=1.0
                iresnoprev=iresno(n)
                iresno(n)=iresno(n)+iresinc
                if (iocccol2 .ge. iocccol1)
         -        read (lineinp(iocccol1:iocccol2),*,err=9912,end=8805)
         -        froccin(n)
                bfac=0.0
                read (lineinp(61:66),*,end=8805,err=8805) bfac
                bfacsum=bfacsum+bfac
                nbfacsum=nbfacsum+1
    8805        if (iqcol2 .ge. iqcol1)
         -       read (lineinp(iqcol1:iqcol2),*,err=9912,end=8803) charge(n)
                go to 8804
    8803        charge(n)=0.0
              end if
    8804      if (lineinp(1:4) .eq. 'ATOM' .or.
         -        lineinp(1:6) .eq. 'HETATM') then
                call altcolcheck(lineinp,idcol,iruntyp,ialtcol,
         -        ikeepfullalt,altnam,naltnam,naltrec,naltdel,ipredict,
         -        froccin,outfile,altfile,namleno,namlena,ncol,n,asterisk,
         -        maxrec)
                line(lineread)=lineinp
              end if
              lineprev=lineinp
            end do
    23      if (nhdel .gt. 0) print *,nhdel,' heteroatoms will be deleted'
            if (nudel .gt. 0)
         -    print *,nudel,' undetermined atoms will be deleted'
            nrecdel=nhdel+nudel
            call altdelcheck(n,naltnam,naltrec,altnam,ipredict,iruntyp,
         -    altcol,ialtcol,idcol,naltdel,ncol,line,index,idrop,linewr,
         -    altfile,namlena,asterisk,maxrec)
            bfacavg(nsegm)=0.0
            if (nbfacsum .gt. 0) bfacavg(nsegm)=bfacsum/nbfacsum
            nbfacsumtot=nbfacsumtot+nbfacsum
            ndig27=0
            n9999=0
            ictest=27
            do ia=1,n
              if (idigit(line(index(ia))(ictest:ictest),1) .eq. 1) then
                call readint(line(index(ia)),iresncol1,iresncol2+1,
         -        iresno(ia),2,0,ierr)
                if (ierr .gt. 0) go to 9911
                if (iresno(ia) .le. 9999) then
                  line(index(ia))(iresncol1:iresncol2)=
         -          line(index(ia))(iresncol1+1:iresncol2+1)
                  line(index(ia))(iresncol2+1:iresncol2+1)=' '
                else
                  n9999=n9999+1
                end if
                ndig27=ndig27+1
              end if
            end do
            if (ndig27 .gt. 0) write (6,2116) ictest,ndig27,ictest
            if (n9999 .gt. 0) write (6,2117) ictest
            if (naltdel .gt. 0) then
              print *,naltdel,' alternate atoms will be deleted'
              if (ipredict .eq. 1) print *,'Predictable run keeps the ',
         -      'records marked with the 1st altternative character'
            end if
            nrecdel=nrecdel+naltdel
          else if (inpcrdtyp .eq. iommod) then
            lineread=1
            read (inpt,1001,end=9999) lineinp
            line(1)=lineinp
            call lastchar(lineinp,lc,ncol)
            if (lc .le. 1 .and. lineinp(1:1) .eq. ' ') go to 9917
            read (lineinp(2:6),1007,err=9915,end=9999) n
            title=lineinp(8:87)
            trtitle(1)=lineinp(8:87)
            ntitltr=1
            icol=7
            call nextchar(lineinp,icol,132)
            if (icol .gt. 80) line(1)(7:16)='Macromodel'
            if (nconfig .le. maxrepconf) then
              call lastchar(lineinp,ifc,ncol)
              write (6,1010) lineinp(7:ifc)
            end if
            ntitlin=1
            nlines=n+1
            do i=1,n
              read (inpt,1001,end=3000) lineinp
              line(i+1)=lineinp
              do j=1,nnoblank3
                k=noblank3(j)
                if (lineinp(k:k) .ne. ' ') write (6,2051) i,k,lineinp(k:k)
              end do
              index(i)=i+1
              lineread=i+1
              read (lineinp(iccol1:iccol2),1103,err=9911) (c(k,i),k=1,3)
              read(lineinp(iqcol1:iqcol2),*) charge(i)
              call readint(lineinp,ipotcol1,ipotcol2,ityp,4,1,irerr)
              if (ityp .lt. 1 .or. ityp .gt. 64) then
                print *,'ERROR: invalid Macromodel atom type:',ityp
                iatnum(i)=99
              else
                iatnum(i)=mmatno(ityp)
              end if
            end do
            nsegm=0
            do ia=1,n
              isegno(ia)=0
              s1=line(ia+1)(isegcol1:isegcol2)
              do j=1,nsegm
                if (s1 .eq. segid4(j)(1:1)) isegno(ia)=j
              end do
              if (isegno(ia) .eq. 0) then
                nsegm=nsegm+1
                segid4(nsegm)(1:1)=s1
                isegno(ia)=nsegm
              end if
              call readint(line(ia+1),iresncol1,iresncol2,iresno(ia),2,1,
         -      irerr)
            end do
          else if (inpcrdtyp .eq. iommc .or. inpcrdtyp .eq. iommc4) then
            ntitlin=0
            nsegm=1
            n=0
            do irec=1,maxrec
              lstch=0
              do while (lstch .le. 1)
                read (inpt,1001,end=41) lineinp
                call lastchar(lineinp,lstch,80)
              end do
              line(irec)=lineinp
              lineread=irec
              icol=1
              call nextchar(lineinp,icol,132)
              if (lineinp(icol:icol) .eq. '!') then
                if (irec .eq. ntitlin+1) then
                  ntitlin=ntitlin+1
                  if (nconfig .eq. 0 .and. ntitlin .eq. 1)
         -          title=lineinp(1:80)
                  if (nconfig .le. maxrepconf) then
                    call lastchar(lineinp,ifc,ncol)
                    write (6,1010) lineinp(1:ifc)
                  end if
                end if
              else
                n=n+1
                index(n)=irec
                call readint(lineinp,iresncol1,iresncol2,iresno(n),2,1,
         -        irerr)
                if (n .gt. 1) then
                  if (iresno(n) .lt. iresno(n-1)) nsegm=nsegm+1
                end if
                isegno(n)=nsegm
                read (lineinp(iccol1:iccol2),1101,err=9911) (c(k,n),k=1,3)
                iatnum(n)=ianum(lineinp(inamcol1:inamcol2),1,nnamcol)
                read(lineinp(iqcol1:iqcol2),*) charge(n)
              end if
            end do
            itrunc=maxrec
    41      if (iclone .eq. -1) call askyn(
         -    'Do you have cloning information',31,1,-1,iclone,17,0)
            if (iclone .gt. 0) then
              write (6,*) 'NOTE: cloned atoms will have the coordinates ',
         -      'of the atom it was cloned from'
              neednnlist=1
              call getint('Number of clones',16,0,1,1000,nclone,98)
              do ic=1,nclone
    42          write (question(6:8),1003) ic
                call getintline(question,51,1,n,in12,2,00)
                iaclnf(ic)=in12(1)
                iaclnl(ic)=in12(2)
                if (iaclnf(ic) .gt. iaclnl(ic))then
                  print *,'Invalid range'
                  go to 42
                end if
                if (ic .gt. 1) then
                  if (iaclnf(ic) .lt. iaclnl(ic-1)) then
                    print *,'Cloned molecules should be specified in ',
         -            'increasing order'
                    go to 41
                  end if
                end if
                call getint('Number of copies',16,0,1,0,ncopcln(ic),0)
              end do
              do ic=nclone,1,-1
                incr0=iaclnl(ic)-iaclnf(ic)+1
                incr=(ncopcln(ic)-1)*incr0
                incri0=index(iaclnl(ic))-index(iaclnf(ic))+1
                incri=(ncopcln(ic)-1)*incri0
                do irec=index(n),index(iaclnl(ic))+1,-1
                  line(irec+incri)=line(irec)
                end do
                incrres=iresno(iaclnl(ic))-iresno(iaclnf(ic))+1
                incrseg=isegno(iaclnl(ic))-isegno(iaclnf(ic))+1
                if (iaclnf(ic) .gt. 1) then
                  if (isegno(iaclnf(ic)) .eq. isegno(iaclnf(ic)-1)) then
                    do ia=iaclnf(ic),iaclnl(ic)
                      isegno(ia)=isegno(ia)+1
                    end do
                  end if
                end if
                do ia=n,iaclnl(ic)+1,-1
                  index(ia+incr)=index(ia)+incri
                  isegno(ia+incr)=isegno(ia-incr0)+ncopcln(ic)*incrseg
                  iresno(ia+incr)=iresno(ia)+(ncopcln(ic)-1)*incrres
                  write (line(index(ia+incr))(iresncol1:iresncol2),1007)
         -          iresno(ia+incr)
                end do
                do id=1,ncopcln(ic)-1
                  do ir=index(iaclnf(ic)),index(iaclnl(ic))
                    line(ir+id*incri0)=line(ir)
                  end do
                  do ia=iaclnf(ic),iaclnl(ic)
                    isegno(ia+id*incr0)=isegno(ia)+id
                    index(ia+id*incr0)=index(ia)+id*incri0
                    iresno(ia+id*incr0)=iresno(ia)+id*incrres
                    write (line(index(ia+id*incr0))(iresncol1:iresncol2),
         -            1007) iresno(ia+id*incr0)
                  end do
                end do
                n=n+incr
                lineread=lineread+incri
              end do
              do ia=1,n
                irec=index(ia)
                read (line(irec)(iccol1:iccol2),1101,err=9911)
         -        (c(k,ia),k=1,3)
              end do
            end if
            nlines=lineread
            if (nlines .eq. 0) iendfound=1
          else if (inpcrdtyp .eq. iogro) then
            ntitlin=1
            read (inpt,1001,end=9999) lineinp
            line(1)=lineinp
            title=lineinp(1:80)
            trtitle(1)=lineinp(1:80)
            ntitltr=1
            if (nconfig .le. maxrepconf) then
              call lastchar(lineinp,ifc,ncol)
              write (6,1010) lineinp(1:ifc)
            end if
            read (inpt,1001) lineinp
            line(2)=lineinp
            call lastchar(lineinp,lc,ncol)
            if (lc .le. 1 .and. lineinp(1:1) .eq. ' ') go to 9917
            read (lineinp(1:5),1007,err=9915) n
            nlines=2
            call checkdim(n+nlines,MAXREC,'MAXREC',6,'number of lines',15,0)
            do i=1,n
              nlines=nlines+1
              index(i)=nlines
              lineread=nlines
              read (inpt,1001,end=3000) lineinp
              line(nlines)=lineinp
              read (lineinp(iccol1:iccol2),1102,err=9911) (c(k,i),k=1,3)
              call readint(lineinp,iresncol1,iresncol2,iresno(i),2,1,irerr)
              if (iqcol2 .ge. iqcol1)
         -      read(lineinp(iqcol1:iqcol2),*) charge(i)
            end do
          else if (inpcrdtyp .eq. iomol2) then
            if (nconfig .eq. 0)
         -    print *,'NOTE: This format is mostly for input only'
            call read_mol2(inpt,line,nlines,n,iresno,iatnum,title,ititle,
         -    nneig,ineig,iseqncol1,iseqncol2,inamcol1,irescol1,iresncol1,
         -    iresncol2,iccol1,iccol2,ipotcol1,iqcol1,iqcol2,ncol,c,charge,
         -    index,iout,nerr,maxng,MAXREC)
            if (nerr .gt. 0) go to 9919
            innlistread=1
          else if (inpcrdtyp .eq. iomae) then
            if (nconfig .eq. 0)
         -    print *,'NOTE: This format is for input only'
            call read_mae_mol(n,nbonds,iatnum,iresno,isegno,nsegm,c,charge,
         -    nneig,ineig,index,line,inpcrdtyp,iofull,inpt,
         -    iout,ierr,MAXREC,MAXNEIG)
            if (ierr .gt. 0) go to 9919
            nlines=n
            innlistread=1
          else if (inpcrdtyp .eq. iocif) then
            if (nconfig .eq. 0)
         -    print *,'NOTE: This format is for input only'
            call read_cif_mol(n,iatnum,iresno,isegno,nsegm,c,froccin,charge,
         -    altcol,inscol,index,line,linefread,title,ltitle,inpcrdtyp,
         -    iofull,idcol,iruntyp,ialtcol,iinscol,ikeepfullalt,altnam,
         -    naltrec,naltdel,ninsres,ipredict,outfile,altfile,namleno,
         -    namlena,pdbid,ncol,asterisk,inpt,ierr,MAXREC)
            nrecdel=nrecdel+naltdel
            if (ierr .gt. 0) stop
            lineread=n
            innlistread=1
          else if (inpcrdtyp .eq. ioxxx) then
            print *,'Input type not implemented'
            stop
          else if (inpcrdtyp .eq. ioins) then
            ntitlin=4
            read (inpt,1001) lineinp
            line(1)=lineinp
            icarvers=3
            if (lineinp(17:17) .eq. '2') then
              icarvers=2
              idcol=65
              itcol=62
              iqcol1=69
              iqcol2=75
              iresncol1=57
              iresncol2=61
            end if
            print *,'Version',icarvers
            read (inpt,1001) lineinp
            line(2)=lineinp
            call writeline(6,lineinp,1,ncol,0)
            ipbc=0
            if (lineinp(1:6) .eq. 'PBC=ON' .or. lineinp(1:6) .eq. 'PBC=2D')
         -    ipbc=1
            read (inpt,1001) lineinp
            line(3)=lineinp
            title=lineinp(1:80)
            trtitle(1)=lineinp(1:80)
            ntitltr=1
            if (nconfig .le. maxrepconf) then
              call lastchar(lineinp,ifc,ncol)
              write (6,1010) lineinp(1:ifc)
            end if
            read (inpt,1001) lineinp
            line(5)=lineinp
            if (ipbc .eq. 1) then
              ntitlin=ntitlin+1
              read (inpt,1001) lineinp
              line(ntitlin)=lineinp
            end if
            n=0
            lineread=ntitlin
            ntitadd=0
            do i=1,maxrec
              lstch=0
              do while (lstch .le. 1)
                read (inpt,1001,end=51) lineinp
                call lastchar(lineinp,lstch,80)
              end do
              line(lineread+1)=lineinp
              lineread=lineread+1
              call checkdim(lineread,MAXREC,'MAXREC',6,'number of lines',15,
         -      0)
              if (lineinp(1:1) .eq. '!') then
                if (lineread .eq. ntitlin+i) then
                  ntitadd=ntitadd+1
                  call writeline(6,line(lineread),1,ncol,0)
                end if
              else if (lineinp(1:3) .eq. 'end') then
                nsegm=nsegm+1
              else
                n=n+1
                index(n)=lineread
                if (n .gt. 1) then
                  if (lineinp(isegcol1:isegcol2) .ne.
         -            lineprev(isegcol1:isegcol2)) nsegm=nsegm+1
                end if
                isegno(n)=nsegm
                lineread=ntitlin+i
                read (lineinp(iccol1:iccol2),1104,err=9911) (c(k,n),k=1,3)
                atomnam='     '
                atomnam(1:2)=lineinp(ichemcol1:ichemcol2)
                iatnum(n)=ianum(atomnam,1,2)
                icol=iresncol1
                call nextchar(lineinp,icol,132)
                call nextblank(lineinp,icol,132)
                icoll=icol-1
                do while (icoll .gt. iresncol1 .and.
         -                idigit(lineinp(icoll:icoll),1) .eq. 0)
                  icoll=icoll-1
                end do
                call readint(lineinp,iresncol1,icoll,iresno(n),2,1,irerr)
                read(lineinp(iqcol1:iqcol2),*) charge(n)
              end if
              lineprev=lineinp
            end do
    51      ntitlin=ntitlin+ntitadd
            if (icarvers .eq. 3) then
              rnu='      '
              nrescar=0
              do i=1,n
                if (line(index(i))(iresncol1:iresncol2) .ne. rnu) then
                  nrescar=nrescar+1
                  rnu=line(index(i))(iresncol1:iresncol2)
                  write (line(index(i))(iresncol1:iresncol2),1006) nrescar
                else
                  write (line(index(i))(iresncol1:iresncol2),1006) nrescar
                end if
              end do
              write (6,2028) nrescar
            end if
          else if (inpcrdtyp .eq. ionxyz .or. inpcrdtyp .eq. iosxyz .or.
         -         inpcrdtyp .eq. iosxyzrq) then
            call lastchar(lineinp,lc,ncol)
            if (lc .le. 1 .and. lineinp(1:1) .eq. ' ') go to 9917
            read (inpt,*,err=9915) n
            ntitlin=0
            call checkdim(n,MAXREC,'MAXREC',6,'number of atoms',15,0)
            do i=1,n
              read (inpt,1001,end=3000) lineinp
              line(ntitlin+1)=lineinp
              index(i)=ntitlin+i
              lineread=ntitlin+i
              if (inpcrdtyp .eq. ionxyz) then
                read (lineinp,*,err=9913) iatnum(i),(c(k,i),k=1,3)
              else if (inpcrdtyp .eq. iosxyz .or.
         -             inpcrdtyp .eq. iosxyzrq) then
                icol=1
                call nextchar(lineinp,icol,132)
                i1=icol
                call nextblank(lineinp,icol,132)
                atsymbol='  '
                atsymbol(1:icol-i1)=lineinp(i1:icol-1)
                atomnam='     '
                atomnam(1:2)=atsymbol
                iatnum(i)=ianum(atomnam,1,2)
                if (inpcrdtyp .eq. iosxyz) then
                  read (lineinp(icol:ncol-icol+1),*,err=9911) (c(k,i),k=1,3)
                else
                  read (lineinp(icol:ncol-icol+1),*,err=9916)
         -          (c(k,i),k=1,3),iresno(i),charge(i)
                end if
              end if
            end do
          else
            ntitlin=1
            read (inpt,1001) lineinp
            line(ntitlin)=lineinp
            do while (line(ntitlin)(1:1) .eq. '!')
              ntitlin=ntitlin+1
              read (inpt,1001) lineinp
              line(ntitlin)=lineinp
            end do
            ntitlin=ntitlin-1
            n=1
            lineread=ntitlin
            do while (.true.)
              read (inpt,1001,end=3001) lineinp
              line(ntitlin+n)=lineinp
              index(n)=ntitlin+n
              lineread=ntitlin+n
              n=n+1
            end do
    3001    n=n-1
          end if
          go to 9900
    3000  itrunc=i-1
          go to 9919
    9999  iendfound=1
          if (ioktoend .eq. 1) return
          go to 9919
    9911  write (6,9001) lineinp(iccol1:iccol2),iccol1,iccol2,icinc
          print *,'n=',n
          go to 9919
    9912  print *,'Invalid syntax for charge'
          go to 9919
    9913  print *,'Invalid syntax for coordinates or atomno'
          go to 9919
    9915  print *,'Invalid syntax for number of atoms'
          go to 9919
    9916  print *,'Invalid syntax for coordinates or resno or charge'
          go to 9919
    9917  print *,'Number of atoms is missing'
    9919  if (lineread .eq. 0) then
            write (6,1210)
          else
            write (6,1209) lineread,lineinp
          end if
          if (iendfound .eq. 1 .or. n .eq. 0) then
            if (nconfig .eq. 0) then
              print *,'ERROR: Coordinate file ',inpfile(1:namleni),
         -    ' is empty'
              iaskagain=1
            else
              print *,'WARNING: run out of data after ',nconfig,
         -      ' configurations'
              iendfound=1
              if (nconfig .eq. 0) call askstop(0)
            end if
          end if
          if (itrunc .gt. 0) then
            print *,'WARNING: Coordinate file contains only ',itrunc,
         -    ' atoms instead of ',n
            n=itrunc
            if (nconfig .eq. 0) call askstop(0)
            itrunc=0
          end if
          if (iunrecog .eq. 1) then
            print *,'Contents of file ',inpfile(1:namleni),' are not in ',
         -    formatname(inpcrdtyp),' format'
            if (nconfig .eq. 0) then
              iaskagain=1
            else
              stop
            end if
          end if
          if (nconfig .gt. 0 .and. iendfound .eq. 0) then
            print *,'Error occurred at molecule number ',nconfig
            iskipok=0
            if (ispdb(inpcrdtyp) .eq. 1) then
              do while (lineinp(1:3) .ne. 'END')
                call blankout(lineinp,1,ncol)
                read (inpt,1010,end=9900) lineinp
              end do
              iskipok=1
            else if (ischarmm(inpcrdtyp) .eq. 1) then
              do while (lineinp(1:1) .ne. '*')
                call blankout(lineinp,1,ncol)
                read (inpt,1010,end=9900) lineinp
              end do
              linefread=1
              iskipok=1
            else if (inpcrdtyp .eq. iomol2) then
              do while (lineinp(1:17) .ne. '@<TRIPOS>MOLECULE')
                call blankout(lineinp,1,ncol)
                read (inpt,1010,end=9900) lineinp
              end do
              linefread=1
              iskipok=1
            else if (inpcrdtyp .eq. iomae) then
              do while (lineinp(1:6) .ne. 'f_m_ct')
                call blankout(lineinp,1,ncol)
                read (inpt,1010,end=9900) lineinp
              end do
              linefread=1
              iskipok=1
            end if
            if (iskipok .eq. 1) then
              print *,'Skipped input to the next molecule'
              go to 100
            end if
          end if
    9900  if (naltnam .gt. 0) close (40)
          if (nbfacsumtot .eq. 0) call zeroit(bfacavg,nsegm)
          return
    1001  format(a132)
    1003  format(i3)
    1006  format(i4)
    1007  format(i5)
    1010  format(a)
    1101  format(3f10.5)
    1102  format(3f8.3)
    1103  format(3f12.5)
    1104  format(3f15.9)
    1105  format(3f20.10)
    1015  format(1x,a)
    1213  format(' ERROR: number of title lines (',i9,') exceeds 32')
    1215  format(' ERROR: File ',a,' does not',/, 8x,'appear to be in ',a,
         -  ' format')
    1216  format(' Sequence number',i6,' is less than the previous',
         -  ' sequence number (',i6,')')
    1217  format(' Residue id ',i6,' is less than the previous residue id ',
         -  '(',i6,')',/,' Sequence # read:',i7,' n=',i7,')')
    1209  format(' Last line read (',i7,'-th):',/,a)
    1210  format(' No data found in the file')
    2028  format(' Residue sequence names are changed to sequence numbers',
         -  /,' Number of residues found=',i4)
    2031  format(' WARNING: column 77-78 is blank - atomic number will be ',
         -  'deduced from atom name:',/,1x,a)
    2032  format('Lines with undefined coordinates were found',/,
         -  ' The atom may be dropped or the coordinates may be set to ',
         -  '999.9')
    2033  format(' WARNING: Not all ATOM/HETATM records have chemical ',
         -  'symbols')
    2034  format(' ERROR: invalid chemical symbol found in record # ',i6,
         -  ':',a,/,1x,a)
    2051  format(' WARNING: non-blank character in line of atom ',i5,
         -  ' column ',i3,':',a1)
    2077  format(' Note: all heteroatoms will be kept and',/,
         -  7x,'only the first of alternate records will be used')
    2115  format(' WARNING: Input structure has ',a,'-type segment ID, ',
         -  'i.e.,'/,'ATOM  99999 AAAA RRR ',a1,
         -  ' 999       0.0     0.0     0.0    1.00  0.0       ',a4,/,
         -  ' instead of',/,'ATOM  99999 AAAA RRR ',a1,
         -  ' 999       0.0     0.0     0.0    1.00  0.0       ',a4)
    2116  format(' Column ',i2,' is not blank for',i7,' atoms',/,
         -  5x,'- residue numbers will be read including column',i3,/,
         -  5x,'- residue numbers < 10000 will be shifted 1 colum to the ',
         -  'right')
    2117  format(' NOTE: residue numbers > 9999 will be left using ',
         -  'column',i3)
    9001  format(' Invalid syntax for coordinates:',a,
         -  ' (cols ',i3,' - ',i3,'; icinc=',i1,')')
          end
          subroutine altcolcheck(lineinp,idcol,iruntyp,ialtcol,ikeepfullalt,
         -  altnam,naltnam,naltrec,naltdel,ipredict,froccin,outfile,altfile,
         -  namleno,namlena,ncol,n,asterisk,maxrec)
          dimension froccin(maxrec)
          character*1 altnam(maxrec),asterisk
          character*132 lineinp
          character*200 outfile,altfile
          if (lineinp(idcol:idcol) .ne. asterisk .and. iruntyp .ne. 21) then
            if (lineinp(ialtcol:ialtcol) .ne. ' ') then
              if (froccin(n) .eq. 1.0) then
                if (ikeepfullalt .eq. -1) then
                  print *,'Fully occupied alternative record found:'
                  print *,lineinp
                  call askyn(
         -        'Do you want to keep such alternative record mark',
         -        48,1,-1,ikeepfullalt,0,0)
                end if
                if (ikeepfullalt .eq. 0) lineinp(ialtcol:ialtcol)=' '
              end if
            end if
            if (lineinp(ialtcol:ialtcol) .ne. ' ') then
              if (naltnam .eq. 0) then
                naltnam=1
                naltrec=0
                altnam(naltnam)=lineinp(ialtcol:ialtcol)
                if (ipredict .eq. 0) then
                  call changeext(outfile,altfile,namleno,namlena,
         -          'alt',3,1,0)
                  call openfile(40,0,' ',1,'new',altfile,namlena,
         -          notfnd,0,1,1,0,0)
                  write (6,2040) altfile(1:namlena)
                  write (40,2044)
                end if
                iname=1
              else
                do iname=1,naltnam
                  if (altnam(iname) .eq. lineinp(ialtcol:ialtcol))
         -          go to 22
                end do
                naltnam=naltnam+1
                iname=naltnam
                altnam(naltnam)=lineinp(ialtcol:ialtcol)
              end if
    22        if (ipredict .eq. 0) then
                call writeline(40,lineinp,1,ncol,0)
                naltrec=naltrec+1
              else
                if (iname .ne. 1) then
                  naltdel=naltdel+1
                  lineinp(idcol:idcol)=asterisk
                end if
              end if
            end if
          end if
          return
    2040  format(' The input PDB file contains records with non-blank ',
         -  'character in column 17.',/,
         -  6x,'These records, marking alternate positions, will be ',
         -  'written on file',/,6x,a)
    2044  format('REMARK RECORDS WITH ALTERNATE LOCATION MARKER')
          end
          subroutine altdelcheck(n,naltnam,naltrec,altnam,ipredict,iruntyp,
         -  altcol,ialtcol,idcol,naltdel,ncol,line,index,idrop,linewr,
         -  altfile,namlena,asterisk,maxrec)
          dimension index(maxrec)
          character*1 altnam(50),altcol(maxrec),asterisk
          character*80 linewr
          character*132 line(maxrec)
          character*200 altfile
          if (naltnam .eq. 0 .or. iruntyp .eq. 21) return
          write (6,2030) naltrec,(altnam(in),in=1,naltnam)
          naltdel=0
          iblankalt=0
          if (ipredict .eq. 1) then
            write (6,2029) altnam(1)
            iblankalt=1
            altnam(1)=' '
          else
            linewr(1:39)='Do you want to drop records with mark  '
            ndrop=0
            do in=1,naltnam
              linewr(39:39)=altnam(in)
              call askyn(linewr,39,1,0,idrop,0,0)
              if (idrop .eq. 0) altnam(in)=' '
              ndrop=ndrop+idrop
            end do
            if (ndrop .eq. naltnam) then
              print *,'WARNING: ALL alternate records will be dropped'
              call askstop(0)
            else
              if (ndrop .eq. 0) then
                print *,'NOTE: ALL alternate records will be kept'
              else
                print *,'List of deleted records will be ADDED to the',
         -        ' file ',altfile(1:namlena)
              end if
            end if
            call askyn(
         -    'Do you want to blank out the alternative mark',45,1,+1,
         -    iblankalt,00,0)
            write (40,2045)
          end if
          do in=1,naltnam
            naltdel_c=0
            do i=1,n
              if (line(index(i))(ialtcol:ialtcol) .ne. ' ') then
                if (line(index(i))(ialtcol:ialtcol) .eq. altnam(in))then
                  naltdel_c=naltdel_c+1
                  line(index(i))(idcol:idcol)=asterisk
                  if (ipredict .eq. 0)
         -          call writeline(40,line(index(i)),1,ncol,0)
                end if
              end if
            end do
            if (altnam(in) .ne. ' ') then
              write (6,2043) naltdel_c,altnam(in)
              if (naltdel_c .eq. 0) print *,'PROGRAM ERROR: naltdel_c=0'
            end if
            naltdel=naltdel+naltdel_c
          end do
          nab=0
          if (iblankalt .eq. 1) then
            do i=1,n
              if (line(index(i))(ialtcol:ialtcol) .ne. ' ') then
                line(index(i))(ialtcol:ialtcol)=' '
                altcol(i)=' '
                nab=nab+1
              end if
            end do
          end if
          return
    2029  format(' Alternative locations ',a,' will be kept and the others',
         -  ' dropped',/,' Alternative marks will be deleted')
    2030  format(i4,' alternative location records have been found',/,
         -  ' The following characters were found in column 17:',50(1x,a1))
    2043  format(i5,' records containing alternate location marked with ',
         -  a1,' will be deleted')
    2045  format('REMARK RECORDS WITH ALTERNATE LOCATION MARKER TO BE ',
         -  'DELETED')
          end
          subroutine readcharges(nread,nslt,n,charge,iatnum,isv,
         -  icharges,nerr)
          dimension charge(nread),iatnum(nread)
          character*1 ans
          character*8 atomnam
          character*80 line
          character*200 filename
          inpt=51
          call quiz(ans,ians,'n',' ',0,'charge input',12,0,5,6,0)
          if (ans .eq. 'n') return
          nread=nslt
          if (n .gt. nslt) then
            call askyn('Do you have charges for the solvents too',40,1,1,
         -    isv,000,0)
            if (isv .eq. 1) nread=n
          end if
          namlen=0
          if (ans .eq. 'a') then
            call openfile(inpt,0,'Amber prtmtop',13,'old',filename,namlen,
         -    notfound,3,1,1,0,0)
            do while (line(1:12) .ne. '%FLAG CHARGE')
              read (inpt,1000,end=199) line
            end do
            read (inpt,1000,end=199) line
            read (inpt,1001,end=198,err=198) (charge(i),i=1,nread)
            do i=1,nread
              charge(i)=charge(i)/18.2223
            end do
          else if (ans .eq. 'c') then
            call openfile(inpt,0,'Charmm PSF',10,'old',filename,namlen,
         -    notfound,3,1,1,0,0)
            call find_n_psf(inpt,line,nerr,nread,natspsf,'!NATOM',6)
            if (nerr .gt. 0) go to 999
            do ia=1,nread
              call blankout(line,1,80)
              read (inpt,1000,end=999) line
              ic=1
              do irec=1,7
                call nextstring(line,ic,ic1,ic2,80)
                if (irec .eq. 5) then
                  atomnam='        '
                  atomnam(1:ic2-ic1+1)=line(ic1:ic2)
                end if
              end do
              charge(ia)=0.0
              iok=0
              read (line(ic1:ic2),*,err=603) charge(ia)
              iok=1
    603       if (iok .eq. 0) then
                write (6,2000) 'PSF',line(1:79)
                nerr=nerr+1
               end if
            end do
          else if (ans .eq. 'd') then
            call openfile(inpt,0,'Autodock .pdbqt',15,'old',filename,namlen,
         -    notfound,3,1,1,0,0)
            ia=0
            do while (ia .lt. nread)
              read (inpt,1000,end=399) line
              if (line(1:4) .eq. 'ATOM' .or. line(1:6) .eq. 'HETATM') then
                ia=ia+1
                charge(ia)=0.0
                iok=0
                read (line(71:76),*,err=604) charge(ia)
                iok=1
    604         if (iok .eq. 0) then
                  write (6,2000) '.pdbqt',line(1:79)
                  nerr=nerr+1
                end if
              end if
            end do
    399     if (ia .lt. nread) then
              nerr=1
              write (6,2001) ia,nread
            end if
          end if
          nwarn=0
          qsum=0.d0
          nqz=0
          do i=1,nread
            qsum=qsum+charge(i)
            if (charge(i) .eq. 0.0) nqz=nqz+1
            if (charge(i) .lt. -1.0001 .or. charge(i) .gt. 1.0001) then
              nwarn=nwarn+1
              write (6,2004) i,charge(i)
            else if (iatnum (i) .gt. 0) then
              if (iatnum(i) .eq. 1 .and. charge(i) .lt. -0.05 .or.
         -        iatnum(i) .eq. 8 .and. charge(i) .gt. 0.0) then
                write (6,2002) i,iatnum(i),charge(i)
                nwarn=nwarn+1
              end if
            end if
          end do
          if (nqz .eq. nread) then
            print *,'All charges read are zero'
            nerr=nerr+1
          else
            write (6,2003) qsum,nqz
          end if
          if (nerr .gt. 0) then
            print *,'There were errors in reading the charges'
            call askstop(1)
            print *,'No charges will be used'
          end if
          go to 999
    199   print *,'Did not find charge flag in file ',filename(1:namlen)
          nerr=1
          go to 999
    198   print *,'Run out of data'
          nerr=1
    999   close (inpt)
          if (nerr .eq. 0) icharges=2
          return
    1000  format(a)
    1001  format(5e16.8)
    2000  format(' ERROR: invalid charge in ',a,' record:',/,1x,a)
    2001  format(' ERROR: only ',i7,' atoms were found (instead of ',i7,')')
    2002  format(' WARNING: Atom',i6,' atomic #',i2,' has unlikely sign:',
         -  f5.2)
    2003  format(' Total charge =',f8.3,/,' Number of zero charges=',i6)
    2004  format(' WARNING: charge for atom',i6,': ',f8.4)
          end
          subroutine find_n_psf(inpt,line,ierr,n,n_psf,label,llabel)
          character*80 line
          character*(*) label
          ierr=0
          n_psf=0
          do while (n_psf .eq. 0)
            call blankout(line,1,80)
            read (inpt,1010,end=602) line
            ic=1
            call nextstring(line,ic,ic1,ic2,80)
            call nextstring(line,ic,ic21,ic22,80)
            if (ic22 .gt. ic21) then
              if (line(ic21:ic21+llabel-1) .eq. label(1:llabel))
         -      read(line(ic1:ic2),*,err=602) n_psf
            end if
          end do
    602   if (n_psf .eq. 0) then
            print *,'ERROR: no ',label(1:llabel),' line was found'
            ierr=1
          else if (n_psf .lt. n) then
            write (6,2000) n,n_psf
            ierr=1
          else
            print *,'Number of ',label(2:llabel),' found in the PSF file=',
         -    n_psf
          end if
          return
    1010  format(a)
    2000  format(' ERROR: the number of atoms to read (',i8,') exceeds ',
         -  'the number of atoms in the PSF file (',i8,')')
          end
          subroutine writebond(makb,makc,iout_bond,iout_conn,nneig,ineig,
         -  nslt,maxng)
          dimension nneig(nslt),ineig(maxng,nslt)
          character*80 linewr
          if (makb .gt. 0) then
            nb2=0
            do ia=1,nslt
              nb2=nb2+nneig(ia)
            end do
            if (mod(nb2,2) .ne. 0) then
              print *,'PROGRAM ERROR: nneig sum is not even:',nb2
              stop
            end if
            nb=nb2/2
            write (iout_bond,*) 'MAKB ',nb,' ~'
            linewr(73:74)=' ~'
            llw=74
            nw=0
            iw=0
            do ia=1,nslt
              do jaa=1,nneig(ia)
                ja=ineig(jaa,ia)
                if (ja .gt. ia) then
                  nw=nw+1
                  iw=mod(nw-1,4)*18
                  write (linewr(iw+1:iw+18),1109) ia,ja
                  if (nw .eq. nb)call blankout(linewr,iw+19,80)
                  if (mod(nw,4) .eq. 0 .or. nw .eq. nb) then
                    write (iout_bond,1000) linewr(1:llw)
                  end if
                end if 
              end do
            end do
          end if 
          if (makc .gt. 0) then
            do ia=1,nslt
              do jaa=1,nneig(ia)
                ja=ineig(jaa,ia)
                if (ja .gt. ia) write (iout_conn,1110) ia,ja
              end do
            end do
          end if 
          return
    1000  format(a)
    1109  format(2i9)
    1110  format('CONECT',4i5)
          end
          subroutine reverse_opt(c,n,line,maxat)
          character*132 line(maxat)
          dimension c(3,maxat)
          dimension shift(3),rot(3,3)
          nlfound=0
          do il=1,100
            do icc=1,10
              if (line(il)(icc:icc+3) .eq. 'RTTR' .or.
         -        line(il)(icc:icc+3) .eq. 'TRRT') then
                nlfound=nlfound+1
                ic=icc+4
                if (line(il)(ic:ic) .eq. 't') then
                  ic=ic+5
                  read (line(il)(ic+1:ic+45),2000) shift
                else if (line(il)(ic:ic) .eq. 'r') then
                  ic=ic+1
                  read(line(il)(ic:ic),*) i
                  ic=ic+5
                  read (line(il)(ic+1:ic+33),2001) (rot(i,k),k=1,3)
                end if
              end if
            end do
          end do
          if (nlfound .lt. 4) go to 999
          write (6,1000) ((rot(i,k),k=1,3),i=1,3),shift
          call shiftmol(c,n,shift,c,1.0)
          call rotate_c(c,n,rot,c,'REVERSE',7)
          return
    999   print *,'ERROR: no transformation information was found'
          return
    1000  format(' Structure will be shifted by',5x,3f15.6,/,
         -  ' Structure will be rotated by',/,3(5x,3f11.7,/))
    2000  format(3f15.6)
    2001  format(3f11.7)
          end
          subroutine makeunitcell(inpt,inpfile,linpfile,inpcrdtyp,iotyp,
         -  iocif,c,ctemp,atw,n,iatnum,nresslt,nsegslt,segid4,atnames,
         -  resnames,iresno,froccin,charge,ixres,molsltlim,line,index,
         -  iasymbio,iuout,outfile,namleno,itemp, blankline,radtodeg,
         -  maxseg,maxrsd,maxat)
          character*(*) inpfile,outfile
          character*132 line(maxat),blankline
          character*4 segid4(maxseg)
          character*8 atnames(maxat),resnames(maxrsd)
          dimension c(3,maxat),ctemp(3,maxat),index(maxat),atw(maxat),
         -  iatnum(maxat),iresno(maxat),froccin(maxat),charge(maxat),
         -  ixres(maxat),molsltlim(3,maxseg),itemp(maxat)
          character*2 iatnm2
          common /atnam/ aw(99),nval(99),nvalmax(99),mmofan(99),
         -  mmatno(64),iatnm2(99)
          character*1 abc,digits,hexdigits
          common /charactersets/ ihex(25),abc(62),digits(14),hexdigits(25)
          character*1 xyz
          common /axislab/ xyz(3)
          dimension shiftasym(3,20),rotasym(3,3,20),abcabg(6),cmin(3),
         -  cmax(3),c0(3),edge(3),uxyz(3,3),cellxyz(3,3),vertex(3,8),
         -  crm_as(3,20),crmtest(3),ctest(3),shift(3),maskseg(20),
         -  iusedseg(20)
          character*1 segids(62),chainprev,chlist(20),chidused(60),chnew
          character*2 nm2
          character*132 linew
          character*200 cellfile,lineinp
          if (iasymbio .eq. 1) print *,'Generating a full unit cell'
          if (iasymbio .eq. 2) print *,'Generating biological oligomers'
          if (iasymbio .eq. 3)
         -  print *,'Generating all crsytal contacts of the asymetric unit'
          if ((iasymbio .eq. 1 .or. iasymbio .eq. 3) .and.
         -    inpcrdtyp .eq. iocif) then
            print *,
         -    'Sorry, PDBx/mmCIF has no full symmetry tracsformation info'
            return
          end if
          write (6,2000) n,outfile(1:namleno)
          call zeroit(abcabg,6)
          do i=1,62
            segids(i)=abc(i)
          end do
          do is=1,nsegslt
            do i=1,62
              if (segid4(is)(1:1) .eq. segids(i)) segids(i)=' '
            end do
          end do
          if (inpcrdtyp .eq. iocif .and. ispdb(iotyp) .eq. 1) then
            nunknown=0
            do ia=1,n
              if (iatnum(ia) .gt. 0) then
                nm2=iatnm2(iatnum(ia))
                if (nm2(1:1) .eq. ' ') then
                  if (atnames(ia)(1:1) .eq. nm2(1:1)) then
                    do ic=8,2,-1
                      atnames(ia)(ic:ic)=atnames(ia)(ic-1:ic-1)
                    end do
                    atnames(ia)(1:1)=' '
                  end if
                end if
              else
                nunknown=nunknown+1
              end if
            end do
            if (nunknown .gt. 0)
         -    print *,'NOTE: ',nunknown,' atoms had unknown atomic number'
          end if
          call askyn(
         -  'Is the unit cell information in the input STRUCTURE file',56,
         -  1,+1,isamef,000,0)
          if (isamef .eq. 1) then
            inptcell=inpt
            rewind inpt
            cellfile=inpfile
            len=linpfile
            if (ispdb(inpcrdtyp) .ne. 1 .and. inpcrdtyp .ne. iocif)
         -    write (6,2006) cellfile(1:len),'is not'
          else
            inptcell=98
            len=0
            call openfile(inptcell,0,'cell information',16,'old',cellfile,
         -    len,notfnd,0,1,1,0,0)
            if (cellfile(len-2:len) .ne. 'pdb' .and.
         -      cellfile(len-2:len) .ne. 'PDB' .and. ispdb(inpcrdtyp).eq. 1)
         -    write (6,2006) cellfile(1:len),'does not appear to be','PDB'
            if (cellfile(len-2:len) .ne. 'cif' .and. inpcrdtyp .ne. iocif)
         -    write (6,2006) cellfile(1:len),'does not appear to be','mmCIF'
          end if
          icellfound=-5
          do while (icellfound .le. 0)
            read (inptcell,1000,end=555) lineinp
            if (lineinp(1:6) .eq. 'CRYST1') then
              read (lineinp(7:54),*,err=888) abcabg
              icellfound=1
            else if (lineinp(1:6) .eq. '_cell.') then
              if (lineinp(7:14) .eq. 'length_a') then
                ic=15
                call nextstring(lineinp,ic,ic1,ic2,200)
                read (lineinp(ic1:ic2),*,err=888) abcabg(1)
                icellfound=icellfound+1
              else if (lineinp(7:14) .eq. 'length_b') then
                ic=15
                call nextstring(lineinp,ic,ic1,ic2,200)
                read (lineinp(ic1:ic2),*,err=888) abcabg(2)
                icellfound=icellfound+1
              else if (lineinp(7:14) .eq. 'length_c') then
                ic=15
                call nextstring(lineinp,ic,ic1,ic2,200)
                read (lineinp(ic1:ic2),*,err=888) abcabg(3)
                icellfound=icellfound+1
              else if (lineinp(7:17) .eq. 'angle_alpha') then
                ic=18
                call nextstring(lineinp,ic,ic1,ic2,200)
                read (lineinp(ic1:ic2),*,err=888) abcabg(4)
                icellfound=icellfound+1
              else if (lineinp(7:16) .eq. 'angle_beta') then
                ic=17
                call nextstring(lineinp,ic,ic1,ic2,200)
                read (lineinp(ic1:ic2),*,err=888) abcabg(5)
                icellfound=icellfound+1
              else if (lineinp(7:17) .eq. 'angle_gamma') then
                ic=18
                call nextstring(lineinp,ic,ic1,ic2,200)
                read (lineinp(ic1:ic2),*,err=888) abcabg(6)
                icellfound=icellfound+1
              end if
            end if
          end do
    555   irect=0
          call unitmat(uxyz)
          if (icellfound .eq. 1) then
            write (6,2002) abcabg
            call trnsfr(edge,abcabg,3)
          else
            print *,'No unit cell information (CRST1/_cell. records) found'
            call getxyz('Edge length in the ',19,' direction (A)',14,
         -    999999.0,centinp,1,0)
            call getreal('ey-ez angle(in deg)',19,90.0,abcabg(4),1,0)
            call getreal('ex-ez angle(in deg)',19,90.0,abcabg(5),1,0)
            call getreal('ex-ey angle(in deg)',19,90.0,abcabg(6),1,0)
          end if
          if (abcabg(4) .eq. 90.0 .and. abcabg(5) .eq. 90.0 .and.
         -    abcabg(6) .eq. 90.0) irect=1
          if (irect .eq. 0) then
            cosxy=cos(abcabg(6)/radtodeg)
            uxyz(1,2)=cos(abcabg(6)/radtodeg)
            uxyz(2,2)=sin(abcabg(6)/radtodeg)
            uxyz(1,3)=cos(abcabg(5)/radtodeg)
            uxyz(2,3)=
         -    (uxyz(1,2)*uxyz(1,3)-cos(abcabg(4)/radtodeg))/uxyz(2,2)
            uxyz(3,3)=sqrt(1.0-uxyz(1,3)**2+uxyz(2,3)**2)
            write (6,2005) uxyz
          end if
          do i=1,3
            do k=1,3
              cellxyz(k,i)=edge(i)*uxyz(k,i)
            end do
          end do
          rewind inptcell
          nasym=0
          if (iasymbio .eq. 1 .or. iasymbio .eq. 3) then
            do while (.true.)
              read (inptcell,1000,end=999) lineinp
              if (lineinp(1:18) .eq. 'REMARK 290   SMTRY') then
                read (lineinp(19:19),*,err=888) k
                read (lineinp(20:23),*,err=888) nasym
                read (lineinp(24:53),*,err=888) (rotasym(k,i,nasym),i=1,3)
                read (lineinp(54:68),*,err=888) shiftasym(k,nasym)
              end if
            end do
    999     if (nasym .eq. 0) then
              print *,'No transformation info was found in file ',
         -      cellfile(1:len)
              stop
            end if
            if (inptcell .ne. inpt) close (inptcell)
            call checkdim(n*nasym,maxat,'MAXREC',6,
         -    'Number of atoms in the extended system',38,0)
            print *,'Number of transformations found:',nasym
            do isym=2,nasym
              call rotate_c(c,n,rotasym(1,1,isym),c(1,(isym-1)*n+1),
         -      'SYMTRAN',7)
              call shiftmol(c(1,(isym-1)*n+1),n,shiftasym(1,isym),
         -      c(1,(isym-1)*n+1),1.0)
              do is=1,nsegslt
                molsltlim(1,(isym-1)*nsegslt+is)=(isym-1)*n+molsltlim(1,is)
                molsltlim(2,(isym-1)*nsegslt+is)=(isym-1)*n+molsltlim(2,is)
                if (molsltlim(3,is) .gt. 0) then
                 molsltlim(3,(isym-1)*nsegslt+is)=(isym-1)*n+molsltlim(3,is)
                else
                  molsltlim(3,(isym-1)*nsegslt+is)=molsltlim(3,is)
                end if
              end do
            end do
            ntot=n*nasym
            call zeroit(vertex,3*8)
            nv=0
            do ix=1,2
              do iy=1,2
                do iz=1,2
                  nv=nv+1
                  do k=1,3
                    if (ix .eq. 2) vertex(k,nv)=vertex(k,nv)+cellxyz(k,1)
                    if (iy .eq. 2) vertex(k,nv)=vertex(k,nv)+cellxyz(k,2)
                    if (iz .eq. 2) vertex(k,nv)=vertex(k,nv)+cellxyz(k,3)
                  end do
                end do
              end do
            end do
            nattot=nasym*n
            call compact_ucell(c,ctemp,itemp,molsltlim,ntot,nasym*nsegslt,
         -    vertex,cmin,cmax,c0,edge,uxyz,nshift)
            print *,'NSHIFT=',nshift,' NTOT=',ntot
            if (nshift .gt. 0) then
              do i=1,ntot
                write (line(index(i))(31:54),1001) (c(k,i),k=1,3)
              end do
              call extension(c,itemp,0,1,ntot,cmin,cmax,c0,1,0,vol)
            end if
            if (iasymbio .eq. 3) then
              print *,'Wait ... '
              do is=1,nasym
                call cofms(c(1,(is-1)*n+1),crm_as(1,is),n,atw)
              end do
              ncopy=1
              call trnsfr(ctemp,c,n*3)
              do is=2,nasym
                print *,'Testing asymetric unit #',is
                d_org=dist2(crm_as(1,1),crm_as(1,is))
                do ix=-2,2
                  do iy=-2,2
                    do iz=-2,2
                      call zeroit(shift,3)
                      do k=1,3
                        shift(k)=shift(k)+ix*cellxyz(k,1)
                        shift(k)=shift(k)+iy*cellxyz(k,2)
                        shift(k)=shift(k)+iz*cellxyz(k,3)
                      end do
                      call arrsum(crm_as(1,is),shift,crmtest,3)
                        do ia=1,n
                          call arrsum(c(1,(is-1)*n+ia),shift,ctest,3)
                          do ja=1,n
                            if (dist2(ctest,c(1,ja)) .lt. 36.0) then
                              ncopy=ncopy+1
                              call checkdim(n*ncopy,maxat,'MAXREC',6,
         -                      'Number of atoms in the extended system',38,
         -                      0)
                              call trnsfr(ctemp(1,(ncopy-1)*n+1),
         -                      c(1,(is-1)*n+1),n*3)
                              call shiftmol(ctemp(1,(ncopy-1)*n+1),n,shift,
         -                      ctemp(1,(ncopy-1)*n+1),1.0)
                              go to 100
                            end if
                          end do
                        end do
    100               continue
                    end do
                  end do
                end do
              end do
              print *,'Number of contact copies=',ncopy-1
              call trnsfr(c,ctemp,3*n*ncopy)
            else
              ncopy=nasym
            end if
            ifs=1
            do is=nsegslt+1,ncopy*nsegslt
              do while (segids(ifs) .eq. ' ')
                ifs=ifs+1
              end do
              segid4(is)='    '
              segid4(is)(1:1)=segids(ifs)
              segids(ifs)=' '
            end do
            write (6,2001) ((segid4((isym-1)*nsegslt+is)(1:1),is=1,nsegslt),
         -    ' ',isym=1,ncopy)
            iseg=nsegslt
            ix_nslt=index(n)
            do i=1,ix_nslt
              call lastchar(line(i),lc,80)
              write (iuout,1000) line(i)(1:lc)
            end do
            do isym=2,ncopy
              chainprev=' '
              do i=1,n
                linew=line(index(i))(1:80)
                write (linew(31:54),1001) (c(k,(isym-1)*n+i),k=1,3)
                write (linew(07:11),1002) (isym-1)*n+i
                if (linew(22:22) .ne. chainprev) then
                  write (iuout,1000) 'TER'
                  iseg=iseg+1
                  chainprev=linew(22:22)
                end if
                linew(22:22)=segid4(iseg)(1:1)
                call lastchar(linew,lc,80)
                write (iuout,1000) linew(1:lc)
              end do
            end do
            if (iasymbio .eq. 1) then
              icelldup=1
              do while (icelldup .gt. 0)
                call askyn(
         -        'Do you want to create an (other) duplicate cell',47,
         -        1,-1,icelldup,000,0)
                if (icelldup .eq. 1) then
                  call zeroit(shift,3)
                  do k=1,3
                    call getint(
         -            'Shift factor (-1,0,1) in the '//xyz(k)//' direction',
         -            40,0,0,1,ixyzk,0)
                    do l=1,3
                      shift(l)=shift(l)+ixyzk*cellxyz(l,k)
                    end do
                  end do
                  nw=n*ncopy
                  nsw=iseg
                  call shiftmol(c,nw,shift,ctemp,1.0)
                  do isym=1,ncopy
                    write (iuout,1000) 'TER'
                    chainprev=' '
                    do i=1,n
                      linew=line(index(i))(1:80)
                      write (linew(31:54),1001)(ctemp(k,(isym-1)*n+i),k=1,3)
                      write (linew(07:11),1002) nw+(isym-1)*n+i
                      if (linew(22:22) .ne. chainprev) then
                        write (iuout,1000) 'TER'
                        iseg=iseg+1
                        chainprev=linew(22:22)
                      end if
                      linew(22:22)=segid4(iseg-nsw)(1:1)
                      call lastchar(linew,lc,80)
                      write (iuout,1000) linew(1:lc)
                    end do
                  end do
                end if
              end do
              call askyn('Do you want to write the cell vertices/edges too',
         -      48,1,+1,icellw,000,0)
              if (icellw .eq. 1) then
                print *,'Cell vertices will be chain X, all HE atoms'
                write (iuout,1000) 'TER'
                do nv=1,8
                  write (iuout,2003) nasym*n+nv,nasym*nresslt+1,
         -          (vertex(k,nv),k=1,3)
                end do
                do inc=1,2
                  incr=nattot+4*(inc-1)
                  write (iuout,2004) incr+1,incr+2,incr+3
                  write (iuout,2004) incr+2,incr+4
                  write (iuout,2004) incr+3,incr+4
                end do
                do i=1,4
                  write (iuout,2004) nattot+i,nattot+i+4
                end do
              end if
            end if
            write (iuout,1000) 'END'
          else
            nchread=0
            iread=0
            nsegtot=nsegslt
            nslttot=n
            do ic=1,nsegslt
              chidused(ic)=segid4(ic)(1:1)
            end do
            call zeroiti(iusedseg,0,nsegslt)
            if (ispdb(inpcrdtyp) .eq. 1) then
              write (iuout,2011) 'REMARK 350'
              nasym=0
              do while (nasym .eq. 0)
                if (iread .eq. 0) then
                  call blankout(lineinp,1,200)
                  read (inptcell,1000,end=777) lineinp
                else
                  iread=0
                end if
                if (lineinp(1:18) .eq. 'REMARK 350 APPLY T') then
                  call lastchar(lineinp,lc,200)
                  ic=42
                  call nextchar(lineinp,ic,200)
                  nchread=0
                  do while (ic .le. lc)
                    nchread=nchread+1
                    chlist(nchread)=lineinp(ic:ic)
                    ic=ic+3
                  end do
                else if (lineinp(1:18) .eq. 'REMARK 350   BIOMT') then
                  k=0
                  do while (lineinp(1:18) .eq. 'REMARK 350   BIOMT')
                    read (lineinp(19:19),*,end=888,err=888) k
                    read (lineinp(20:23),*,end=888,err=888) nasym
                    read (lineinp(24:53),*,end=888,err=888)
         -           (rotasym(k,i,nasym),i=1,3)
                    read (lineinp(54:68),*,end=888,err=888)
         -            shiftasym(k,nasym)
                    call blankout(lineinp,1,200)
                    read (inptcell,1000,end=777) lineinp
                    iread=1
                  end do
                end if
              end do
            else
              write (iuout,2011) 'pdbx_struct_oper_list.'
              rewind inptcell
              do while (lineinp(1:38) .ne.
         -              '_pdbx_struct_assembly_gen.asym_id_list')
                call blankout(lineinp,1,200)
                read (inptcell,1000,end=777) lineinp
              end do
              call lastchar(lineinp,lc,200)
              ic=39
              call nextchar(lineinp,ic,200)
              nchread=0
              do while (ic .le. lc)
                nchread=nchread+1
                chlist(nchread)=lineinp(ic:ic)
                ic=ic+2
              end do
              rewind inptcell
              do while (lineinp(1:23) .ne. '_pdbx_struct_oper_list.')
                call blankout(lineinp,1,200)
                read (inptcell,1000,end=777) lineinp
              end do
              nitems=0
              ic_isym=0
              ic_m11=0
              ic_m12=0
              ic_m13=0
              ic_m21=0
              ic_m22=0
              ic_m23=0
              ic_m31=0
              ic_m32=0
              ic_m33=0
              ic_v1=0
              ic_v2=0
              ic_v3=0
              call lastchar(lineinp,lc,200)
              do while (lineinp(1:23) .eq. '_pdbx_struct_oper_list.')
                nitems=nitems+1
                if (lineinp(24:25) .eq. 'id') then
                  ic_isym=nitems
                else if (lineinp(24:35) .eq. 'matrix[1][1]') then
                  ic_m11=nitems
                else if (lineinp(24:35) .eq. 'matrix[1][2]') then
                  ic_m12=nitems
                else if (lineinp(24:35) .eq. 'matrix[1][3]') then
                  ic_m13=nitems
                else if (lineinp(24:35) .eq. 'matrix[2][1]') then
                  ic_m21=nitems
                else if (lineinp(24:35) .eq. 'matrix[2][2]') then
                  ic_m22=nitems
                else if (lineinp(24:35) .eq. 'matrix[2][3]') then
                  ic_m23=nitems
                else if (lineinp(24:35) .eq. 'matrix[3][1]') then
                  ic_m31=nitems
                else if (lineinp(24:35) .eq. 'matrix[3][2]') then
                  ic_m32=nitems
                else if (lineinp(24:35) .eq. 'matrix[3][3]') then
                  ic_m33=nitems
                else if (lineinp(24:32) .eq. 'vector[1]') then
                  ic_v1=nitems
                else if (lineinp(24:32) .eq. 'vector[2]') then
                  ic_v2=nitems
                else if (lineinp(24:32) .eq. 'vector[3]') then
                  ic_v3=nitems
                end if
                call blankout(lineinp,1,200)
                read (inptcell,1000,end=777) lineinp
              end do
              nasym=0
              do while (lineinp(1:1) .ne. '#')
                ic=1
                call lastchar(lineinp,lc,200)
                isym=1
                do i=1,nitems
                  call nextstring(lineinp,ic,ic1,ic2,200)
                  if (i .eq. ic_isym) then
                    read (lineinp(ic1:ic2),*,err=666) isym
                  else if (i .eq. ic_m11) then
                    read(lineinp(ic1:ic2),*,err=666) rotasym(1,1,isym)
                  else if (i .eq. ic_m12) then
                    read(lineinp(ic1:ic2),*,err=666) rotasym(1,2,isym)
                  else if (i .eq. ic_m13) then
                    read(lineinp(ic1:ic2),*,err=666) rotasym(1,3,isym)
                  else if (i .eq. ic_m21) then
                    read(lineinp(ic1:ic2),*,err=666) rotasym(2,1,isym)
                  else if (i .eq. ic_m22) then
                    read(lineinp(ic1:ic2),*,err=666) rotasym(2,2,isym)
                  else if (i .eq. ic_m23) then
                    read(lineinp(ic1:ic2),*,err=666) rotasym(2,3,isym)
                  else if (i .eq. ic_m31) then
                    read(lineinp(ic1:ic2),*,err=666) rotasym(3,1,isym)
                  else if (i .eq. ic_m32) then
                    read(lineinp(ic1:ic2),*,err=666) rotasym(3,2,isym)
                  else if (i .eq. ic_m33) then
                    read(lineinp(ic1:ic2),*,err=666) rotasym(3,3,isym)
                  else if (i .eq. ic_v1) then
                    read(lineinp(ic1:ic2),*,err=666) shiftasym(1,isym)
                  else if (i .eq. ic_v2) then
                    read(lineinp(ic1:ic2),*,err=666) shiftasym(2,isym)
                  else if (i .eq. ic_v3) then
                    read(lineinp(ic1:ic2),*,err=666) shiftasym(3,isym)
                  end if
                  if (ic2 .eq. lc .and. i .lt. nitems) then
                    call blankout(lineinp,1,200)
                    read (inptcell,1000,end=777) lineinp
                    call lastchar(lineinp,lc,200)
                    ic=1
                  end if
                end do
                nasym=isym
                call blankout(lineinp,1,200)
                read (inptcell,1000,end=777) lineinp
              end do
              if (nasym .lt. 2) then
                write (6,2012) cellfile(1:len)
                return
              end if
            end if
            nats_transf=molsltlim(2,nsegslt)
            iad=0
            do isym=1,nasym
              write (6,2009) isym,((rotasym(i,j,isym),j=1,3),i=1,3),
         -      (shiftasym(i,isym),i=1,3)
              notransf=1
              do k=1,3
                if (shiftasym(k,isym) .ne. 0.0 .or.
         -          rotasym(k,k,isym) .ne. 1.0) notransf=0
                do kk=1,k-1
                  if (rotasym(k,kk,isym) .ne. 0.0 .or.
         -            rotasym(kk,k,isym) .ne. 0.0) notransf=0
                end do
              end do
              if (nchread .eq. 0) then
                do ic=1,nsegslt
                  maskseg(ic)=1
                end do
              else
                call zeroiti(maskseg,0,nsegslt)
                do ic=1,nchread
                  do icc=1,nsegslt
                    if (chlist(ic) .eq. segid4(icc)(1:1)) maskseg(icc)=1
                  end do
                end do
              end if
              do ic=1,nsegslt
                if (maskseg(ic).eq. 1) then
                  if (iusedseg(ic) .eq. 1 .and. notransf .eq. 1) then
                    print *,'Chain ',segid4(ic)(1:1),' skipped'
                    maskseg(ic)=0
                  else
                    iusedseg(ic)=1
                  end if
                end if
              end do
              do ic=1,nsegslt
                if (maskseg(ic) .eq. 1) then
                  if (notransf .eq. 0) then
                    ich=0
                    new=0
                    do while (ich .lt. 62 .and. new .eq. 0)
                      new=1
                      ich=ich+1
                      do icc=1,nsegtot
                        if (abc(ich) .eq. chidused(icc)) new=0
                      end do
                    end do
                    chnew=abc(ich)
                    chidused(nsegtot+1)=chnew
                  else
                    chnew=segid4(ic)(1:1)
                  end if
                  write (6,2008) segid4(ic)(1:1),chnew
                  is1=molsltlim(1,ic)
                  is1o=is1
                  icn=ic
                  if (isym .gt. 1) then
                    is1=nslttot+1
                    icn=nsegtot+1
                  end if
                  natss=molsltlim(2,ic)-molsltlim(1,ic)+1
                  isn=is1
                  call rotate_c(c(1,is1o),natss,rotasym(1,1,isym),
         -          ctemp(1,isn),'BIOMOL',6)
                  call shiftmol(ctemp(1,isn),natss,shiftasym(1,isym),
         -          ctemp(1,isn),1.0)
                  if (isym .gt. 1) then
                    molsltlim(1,icn)=nslttot+1
                    molsltlim(2,icn)=nslttot+natss
                    if (molsltlim(3,is) .gt. 0) then
                      molsltlim(3,icn)=nslttot+(molsltlim(3,ic)-is1+1)
                    else
                      molsltlim(3,icn)=molsltlim(3,ic)
                    end if
                  end if
                  if (inpcrdtyp .eq. iotyp) then
                    do i=molsltlim(1,icn),molsltlim(2,icn)
                      io=i-molsltlim(1,icn)+molsltlim(1,ic)
                      linew=line(index(io))(1:80)
                      write (linew(31:54),1001)(ctemp(k,i),k=1,3)
                      linew(22:22)=chnew
                      call lastchar(linew,lc,80)
                      write (iuout,1000) linew(1:lc)
                    end do
                  else if (inpcrdtyp .eq. iocif) then
                    do i=molsltlim(1,icn),molsltlim(2,icn)
                      call blankout(linew,1,132)
                      call createrec_fromcif(linew,iocif,iotyp,
         -              ctemp(1,i),iatnum(i-iad),atnames(i-iad),
         -              resnames(ixres(i-iad)),chnew,iresno(i-iad),
         -              froccin(i-iad),charge(i-iad),i,blankline)
                      call lastchar(linew,lc,132)
                      write (iuout,1000) linew(1:lc)
                    end do
                  end if
                  if (ispdb(iotyp) .eq. 1) write (iuout,1000) 'TER'
                  if (notransf .eq. 0) then
                    nslttot=nslttot+natss
                    nsegtot=nsegtot+1
                  end if
                end if
              end do
              iad=iad+nats_transf
            end do
    777     if (nasym .lt. 2) then
              write (6,2012) cellfile(1:len)
             return
            end if
            if (inptcell .ne. inpt) close (inptcell)
          end if
          return
    888   print *,'Error in line:'
          print *,lineinp
          stop
    666   write (6,2010) i,ic2,ic2,lineinp
          stop
    1000  format(a)
    1001  format(3f8.3)
    1002  format(i5)
    2000  format(' Transformations will be applied to ',i6,' atoms - ',
         -  'waters are ignored',/,
         -  ' PDB file generated will be written to ',a)
    2001  format(' Chain IDs of the transformed segments: ',/,1x,(78a1))
    2002  format(' Unit cell dimensions:',3f10.3,' A',/,
         -  ' Cell axis angles:    ',3f10.3,' deg')
    2003  format('ATOM  ',i5,1x,' HE ',1x,'CEL',1x,'X',i4,1x,3x,3f8.3,
         -  '  1.0   0.0')
    2004  format('CONECT',4i5)
    2005  format(' Unit vectors of the non-rectangular unit cell:',/,
         -  ' ex=',3f9.5,/,' ey=',3f9.5,/,' ez=',3f9.5)
    2006  format(' NOTE: cell information is in PDB syntax but the file',/,
         -  a,1x,a,' a ',a,' file')
    
    2008  format(' Chain ',a,' transformed as chain ',a)
    2009  format(' Transformation matrix #',i2,/,3(3f10.5,/),
         -  ' Shift vector:',3f8.3)
    2010  format(' Invalid biological dimer data in line (i=',i2,' ic1,2=',
         -  2i4,'):',/,1x,a)
    2011  format('REMARK Biological oligomers, specified by ',a,' records')
    2012  format(' The ',a,' file did not have oligomer transformation ',
         -  'information',/,' - the input structure should be the right ',
         -  'oligomer')
          end
          subroutine createrec_fromcif(linew,iocif,iotyp,ctemp,iatnum,
         -  atnam,resnam,segnam1,ires,frocc,charge,iat,blankline)
          dimension ctemp(3)
          character*132 linew,blankline
          character*1 segnam1
          character*4 atnam,segnam,chemnam
          character*6 potnam
          character*8 resnam
          character*2 iatnm2
          common /atnam/ aw(99),nval(99),nvalmax(99),mmofan(99),
         -  mmatno(64),iatnm2(99)
          dimension ibnd(1),ineig(1)
          data chemnam /'    '/,potnam /'      '/,segnam /'    '/
          chemnam(1:2)=iatnm2(iatnum)
          segnam(1:1)=segnam1
          ihetat=0
          call createrec(linew,iocif,iotyp,ctemp(1),ctemp(2),ctemp(3),' ',
         -  ' ',atnam,resnam,segnam,iat,ires,ires,chemnam,potnam,frocc,
         -  charge,5,1,'  ',1,ineig,1,ibnd,ihetat,blankline)
          return
          end
          subroutine compact_ucell(c,ctemp,itemp,molsltlim,n,nmolslt,
         -  vertex,cmin,cmax,c0,edge,uxyz,nshift)
          dimension c(3,n),ctemp(3,n),itemp(n),molsltlim(3,nmolslt),
         -  edge(3),uxyz(3,3),vertex(3,8),cmin(3),cmax(3),c0(3)
          print *,'COMPACT_UCELL n,nmolslt=',n,nmolslt,' VOL=',vol
          icompact=1
          nshift=0
          do while (icompact .gt. 0)
            icompact=0
            do im=1,nmolslt
              ifst=molsltlim(1,im)
              ilst=molsltlim(2,im)
              nats=ilst-ifst+1
              call trnsfr(ctemp,c(1,ifst),3*nats)
              call trnsfr(ctemp(1,nats+1),vertex,24)
              call extension(ctemp,itemp,0,1,nats+8,cmin,cmax,c0,1,0,vol)
              call checkonedir(c,ctemp,itemp,ifst,ilst,edge,uxyz,
         -      vertex,cmin,cmax,c0,vol,1,ixshift,n)
              call checkonedir(c,ctemp,itemp,ifst,ilst,edge,uxyz,
         -      vertex,cmin,cmax,c0,vol,2,iyshift,n)
              call checkonedir(c,ctemp,itemp,ifst,ilst,edge,uxyz,
         -      vertex,cmin,cmax,c0,vol,3,izshift,n)
              ishift=ixshift+iyshift+izshift
              print *,'ixshift,iyshift,izshift=',ixshift,iyshift,izshift
              icompact=icompact+ishift
              nshift=nshift+ishift
            end do
          end do
          return
          end
          subroutine checkonedir(c,ctemp,itemp,ifst,ilst,edge,uxyz,
         -  vertex,cmin,cmax,c0,vol,iaxis,ishift,n)
          dimension c(3,n),ctemp(3,n),itemp(n),edge(3),uxyz(3,3),
         -  vertex(3,8),cmin(3),cmax(3),c0(3)
          dimension shift(3)
          print *,'CHECKONEDIR iaxis=',iaxis,' ifst,ilst=',ifst,ilst
          ishift=0
          nats=ilst-ifst+1
          do ix=-1,1,2
            if (ishift .eq. 0) then
              do k=1,3
                shift(k)=edge(k)*uxyz(k,iaxis)
              end do
              call shiftmol(c(1,ifst),nats,shift,ctemp,float(ix))
              call trnsfr(ctemp(1,nats+1),vertex,24)
              call extension(ctemp,itemp,0,1,nats+8,cmin,cmax,c0,1,0,volnew)
              print *,'VOL,VOLNEW=',vol,volnew,' ix,iaxis=',ix,iaxis
              if (volnew/vol .lt. 0.9) then
                vol=volnew
                call trnsfr(c(1,ifst),ctemp,3*nats)
                print *,'MOVED ifst,ilst=',ifst,ilst
                ishift=1
              end if
            end if
          end do
          return
          end
          subroutine try_to_compact(c,ctemp,molsltlim,edge,nslt,nmolslt,
         -  icompact)
          dimension c(3,nslt),ctemp(3,nslt),molsltlim(3,nmolslt),edge(3)
          dimension shift(3)
          do im=1,nmolslt
            ifst=molsltlim(1,im)
            ilst=molsltlim(2,im)
            icomp=1
            do while (icomp .gt. 0)
              icomp=0
              call countout_rect(ifst,ilst,c,edge,nouttot,kmax,nslt)
              if (float(nouttot)/float(ilst-ifst+1) .gt. 0.1) then
                if (kmax .lt. 0) then
                  kmax=-kmax
                  fact_s=1.0
                else
                  fact_s=-1.0
                end if
                call zeroit(shift,3)
                shift(kmax)=edge(kmax)
                call shiftmol(c(1,ifst),ilst-ifst+1,shift,ctemp(1,ifst),
         -        fact_s)
                call countout_rect(ifst,ilst,ctemp,edge,nouttotnew,kmax,
         -        nslt)
                if (nouttotnew .lt. nouttot) then
                  call trnsfr(c(1,ifst),ctemp(1,ifst),3*(ilst-ifst+1))
                  icompact=1
                  icomp=1
                end if
              end if
            end do
          end do
          return
          end
          subroutine countout_rect(ifst,ilst,c,edge,nouttot,kmax,n)
          dimension c(3,n),edge(3)
          dimension nxyzp(3),nxyzm(3)
          call zeroiti(nxyzp,0,3)
          call zeroiti(nxyzm,0,3)
          do ia=ifst,ilst
            do k=1,3
              if (c(k,ia) .lt. 0.0) nxyzm(k)=nxyzm(k)+1
              if (c(k,ia) .gt. edge(k)) nxyzp(k)=nxyzp(k)+1
            end do
          end do
          nouttot=0
          noutmax=0
          kmax=0
          do k=1,3
            nouttot=nouttot+nxyzm(k)+nxyzp(k)
            if (nxyzp(k) .gt. noutmax) then
              noutmax=nxyzp(k)
              kmax=k
            end if
            if (nxyzm(k) .gt. noutmax) then
              noutmax=nxyzm(k)
              kmax=-k
            end if
          end do
          return
          end
          subroutine read_mol2(iomol2,line,nlines,natsmol2,iresno,iatnum,
         -  title,ltitle,nnmol2,inmol2,iseqncol1,iseqncol2,inamcol1,
         -  irescol1,iresncol1,iresncol2,iccol1,iccol2,ipotcol1,iqcol1,
         -  iqcol2,lenrec,cmol2,qmol2,index,iout,nerr,maxng,maxat)
          dimension iresno(maxat),iatnum(maxat),nnmol2(maxat),
         -  inmol2(maxng,maxat),cmol2(3,maxat),qmol2(maxat),index(maxat)
          character*(*) title
          character* 132 line(maxat)
          character*1 xyz
          common /axislab/ xyz(3)
          character*80 lineinp
          nerr=0
          natsmol2=0
          nres=0
          call blankout(lineinp,1,80)
          nlines=0
          naterr=0
          nlines_mol=0
          do while (lineinp(1:17) .ne. '@<TRIPOS>MOLECULE')
            read (iomol2,1000,end=777) lineinp
            nlines=nlines+1
            line(nlines)=lineinp
          end do
          nlines_mol=nlines
          do while (lineinp(1:13) .ne. '@<TRIPOS>ATOM')
            call blankout(lineinp,1,80)
            read (iomol2,1000,end=777) lineinp
            nlines=nlines+1
            line(nlines)(1:80)=lineinp
          end do
    777   if (nlines_mol .eq. 0) then
            print *,'ERROR: no MOLECULE record is found'
            stop
          end if
          call lastchar(line(nlines_mol+1),ltitle,80)
          title(1:ltitle)=line(nlines_mol+1)(1:ltitle)
          read (line(nlines_mol+2),*,err=771) nats,nbonds
    771   do while (lineinp(1:13) .ne. '@<TRIPOS>BOND')
            call blankout(lineinp,1,80)
            read (iomol2,1000,end=888) lineinp
            nlines=nlines+1
            line(nlines)(1:80)=lineinp
            if (lineinp(1:13) .ne. '@<TRIPOS>BOND') then
              natsmol2=natsmol2+1
              index(natsmol2)=nlines
              call blankout(line(nlines),1,80)
              if (natsmol2 .gt. maxat) then
                write (6,2001) maxat
                nerr=1
                return
              end if
              call blankout(line(nlines),1,80)
              ic=1
              call nextchar(lineinp,ic,lenrec)
              ic1=ic
              call nextblank(lineinp,ic,lenrec)
              nsp=iseqncol2-iseqncol1+1-(ic-ic1)
              line(nlines)(iseqncol1+nsp:iseqncol2)=lineinp(ic1:ic-1)
              call nextchar(lineinp,ic,lenrec)
              ic1=ic
              call nextblank(lineinp,ic,lenrec)
              ic2=ic-1
              icc=ic
              call nextchar(lineinp,icc,lenrec)
              if (icc-ic1 .le. 4) then
                ic2=icc
                do ic=ic1,ic2
                  if (lineinp(ic:ic) .eq. ' ') lineinp(ic:ic)='_'
                end do
              end if
              line(nlines)(inamcol1:inamcol1+ic2-ic1)=lineinp(ic1:ic2)
              iatnum(natsmol2)=ianum(lineinp(ic1:ic2),1,ic2-ic1+1)
              lencoord=(iccol2-iccol1+1)/3
              do k=1,3
                call nextchar(lineinp,ic,lenrec)
                if (ic .eq. lenrec) go to 555
                ic1=ic
                call nextblank(lineinp,ic,lenrec)
                if (ic-ic1 .lt. 3) then
                  write (6,2002) xyz(k),lineinp(ic1:ic-1)
                end if
                read (lineinp(ic1:ic-1),*,err=555) cmol2(k,natsmol2)
                write (line(nlines)
         -        (iccol1+(k-1)*lencoord:iccol1+k*lencoord-1),1001)
         -        cmol2(k,natsmol2)
              end do
              call nextchar(lineinp,ic,lenrec)
              if (ic .eq. lenrec) go to 555
              ic1=ic
              call nextblank(lineinp,ic,lenrec)
              line(nlines)(ipotcol1:ipotcol1+ic-ic1-1)=lineinp(ic1:ic-1)
              call nextchar(lineinp,ic,lenrec)
              ic1=ic
              call nextblank(lineinp,ic,lenrec)
              read (lineinp(ic1:ic-1),*,err=555) nres
              call nextchar(lineinp,ic,lenrec)
              if (ic .eq. lenrec) go to 555
              ic1=ic
              call nextblank(lineinp,ic,lenrec)
              line(nlines)(irescol1:irescol1+ic-ic1-1)=lineinp(ic1:ic-1)
              write (line(nlines)(iresncol1:iresncol2),1003) nres
              iresno(natsmol2)=nres
              call nextchar(lineinp,ic,lenrec)
              if (ic .eq. lenrec) go to 555
              ic1=ic
              call nextblank(lineinp,ic,lenrec)
              read (lineinp(ic1:ic-1),*,err=555) qmol2(natsmol2)
              write (line(nlines)(iqcol1:iqcol2),1002) qmol2(natsmol2)
            end if
            go to 556
    555     call lastchar(lineinp,iclast,80)
            write (6,2000) 'atom',natsmol2,lineinp(1:iclast)
            naterr=naterr+1
            if (naterr .eq. 25) then
              call askyn('There were 25 errors so far. Do you want to stop',
         -      48,1,+1,istop,000,0)
              if (istop .eq. 1) stop
            endif
    556     continue
          end do
    888   write (iout,*) 'Read ',natsmol2,' atoms'
          nerr=nerr+naterr
          if (nats .ne. natsmol2) then
            write (6,2003) natsmol2,nats
            call askstop(1)
          end if
          call zeroiti(nnmol2,0,natsmol2)
          nbmol2=0
          do ibn=1,nbonds
            call blankout(lineinp,1,80)
            read (iomol2,1000,end=999,err=666) lineinp
            nlines=nlines+1
            line(nlines)=lineinp
            read (lineinp,*,end=999) ib,ia,ja
            if (nnmol2(ia) .lt. maxng) then
              nnmol2(ia)=nnmol2(ia)+1
              inmol2(nnmol2(ia),ia)=ja
            else
              print *,'ERROR: atom ',ia,' has more than ',maxng,
         -      ' neighbors'
              nerr=nerr+1
            end if
            if (nnmol2(ja) .lt. maxng) then
              nnmol2(ja)=nnmol2(ja)+1
              inmol2(nnmol2(ja),ja)=ia
            else
              print *,'ERROR: atom ',ja,' has more than ',maxng,
         -      ' neighbors'
              nerr=nerr+1
            end if
            nbmol2=nbmol2+1
          end do
    999   write (iout,*) 'Read ',nbmol2,' bonds'
          return
    666   call lastchar(lineinp,iclast,80)
          write (6,2000) 'bond',nbmol2,lineinp(1:iclast)
          nerr=nerr+1
          return
    1000  format(a)
    1001  format(f12.5)
    1002  format(f7.4)
    1003  format(i4)
    2000  format(' ERROR: Invalid .mol2 ',a,' record, natsmol2=',i5,
         -  ' record:',/,1x,a)
    2001  format(' ERROR: maximum number of atoms (',i9,') is exceeded',/,
         -  ' Recompile the program with parameter MAXREC set larger')
    2002  format(' ERROR: ',a1,'-coordinate has too few digits:',a)
    2003  format(' WARNING: # of atoms read (',i6,') differs from the # ',
         -  'specified (',i6,')')
          end
          subroutine read_mae_mol(nats,nbonds,ian,iresn,isegno,nsegm,c,q,
         -  nn,in,index,line,inptyp_mae,iofull,inpt,iout,ierr,
         -  maxat,maxng)
          dimension ian(maxat),iresn(maxat),isegno(maxat),c(3,maxat),
         -  q(maxat),index(maxat)
          dimension nn(maxat),in(maxng,maxat)
          character*132 line(maxat)
          character*400 linein
          parameter (MAXCOL=50)
          character*20 items(MAXCOL)
          character*50 colid(MAXCOL)
          dimension litems(MAXCOL),lcolid(MAXCOL),iancount(99)
          character*2 iatnm2
          common /atnam/ aw(99),nval(99),nvalmax(99),mmofan(99),
         -  mmatno(64),iatnm2(99)
          character*4 segn4,segn4prev
          call setcol(inptyp_mae,ncol,idcol,ialtcol,iinscol,
         -  inamcol1,inamcol2,irescol1,irescol2,iccol1,iccol2,
         -  iresncol1,iresncol2,iseqncol1,iseqncol2,isegcol1,isegcol2,
         -  iresidcol1,iresidcol2,iqcol1,iqcol2,ipotcol1,ipotcol2,
         -  iocccol1,iocccol2,ichemcol1,ichemcol2,nrescol,nresncol,
         -  nsegcol,nnamcol,iofull)
          iccol11=iccol1
          iccol12=iccol1+(iccol2-iccol1+1)/3
          iccol13=iccol12+(iccol2-iccol1+1)/3
          len=400
          ierr=1
          ix_x=0
          ix_y=0
          ix_z=0
          ix_rnum=0
          ix_rnam=0
          ix_anam=0
          ix_occ=0
          ix_tfac=0
          ix_atno=0
          ix_charge1=0
          ix_segn=0
          call read_head_mae('m_atom',6,nats,linein,len,inpt,iout)
          call read_colid_mae(ndcol,colid,lcolid,'atoms',5,linein,
         -  len,iend,inpt,iout,MAXCOL)
          if (iend .eq. 1) return
          do icol=1,ndcol
            lc=lcolid(icol)
            if (colid(icol)(1:lc) .eq. 'r_m_x_coord') then
              ix_x=icol
            else if (colid(icol)(1:lc) .eq. 'r_m_y_coord') then
              ix_y=icol
            else if (colid(icol)(1:lc) .eq. 'r_m_z_coord') then
              ix_z=icol
            else if (colid(icol)(1:lc) .eq. 'i_m_residue_number') then
              ix_rnum=icol
            else if (colid(icol)(1:lc) .eq. 's_m_pdb_residue_name' .or.
         -           colid(icol)(1:lc) .eq. 's_m_residue_name') then
              ix_rnam=icol
            else if (colid(icol)(1:lc) .eq. 's_m_chain_name') then
              ix_segn=icol
            else if (colid(icol)(1:lc) .eq. 's_m_pdb_atom_name' .or.
         -           colid(icol)(1:lc) .eq. 's_m_atom_name') then
              ix_anam=icol
            else if (colid(icol)(1:lc) .eq. 'r_m_pdb_occupancy') then
              ix_occ=icol
            else if (colid(icol)(1:lc) .eq. 'r_m_pdb_tfactor') then
              ix_tfac=icol
            else if (colid(icol)(1:lc) .eq. 'i_m_atomic_number') then
              ix_atno=icol
            else if (colid(icol)(1:lc) .eq. 'r_m_charge1') then
              ix_charge1=icol
            end if
          end do
          if (ix_x*ix_y*ix_z .eq. 0)
         -   write (iout,*) 'WARNING: coordinate records are missing'
          if (ix_anam .eq. 0) write (iout,*)
         -   'WARNING: atom name record is missing - generic atom names',
         -  ' will be generated'
          do ia=1,nats
            do k=1,3
              c(k,ia)=999.9
            end do
            ian(ia)=-1
            iresn(ia)=-1
            occ=0.0
            tfac=0.0
            call blankout(line(ia),inamcol1,inamcol2)
          end do
          segn4prev='@#*&'
          nsegm=0
          nnoname=0
          nUNK=0
          do ia=1,nats
            call blankout(line(ia),1,ncol)
            call blankout(linein,1,len)
            read (inpt,1000,end=991) linein
            index(ia)=ia
            ic=1
            do icol=1,ndcol
              call nextstring(linein,ic,ic1,ic2,len)
              litems(icol)=ic2-ic1+1
              items(icol)(1:litems(icol))=linein(ic1:ic2)
            end do
            icol=1
            read (items(icol)(1:litems(icol)),*,end=992,err=992) ix
            if (ix .ne. ia) then
              write (iout,2002) 'atom',ia,ix
              return
            end if
            icol=ix_x
            if (items(max0(1,icol))(1:2) .ne. '<>' .and. icol .gt. 0) then
              read (items(icol)(1:litems(icol)),*,end=992,err=992) c(1,ia)
              line(ia)(iccol11:iccol11+litems(icol)-1)=
         -      items(icol)(1:litems(icol))
            end if
            icol=ix_y
            if (items(max0(1,icol))(1:2) .ne. '<>' .and. icol .gt. 0) then
              read (items(icol)(1:litems(icol)),*,end=992,err=992) c(2,ia)
              line(ia)(iccol12:iccol12+litems(icol)-1)=
         -      items(icol)(1:litems(icol))
            end if
            icol=ix_z
            if (items(max0(1,icol))(1:2) .ne. '<>' .and. icol .gt. 0) then
              read (items(icol)(1:litems(icol)),*,end=992,err=992) c(3,ia)
              line(ia)(iccol13:iccol13+litems(icol)-1)=
         -      items(icol)(1:litems(icol))
            end if
            icol=ix_rnum
            if (items(max0(1,icol))(1:2) .ne. '<>' .and. icol .gt. 0) then
              read (items(icol)(1:litems(icol)),*,end=992,err=992) iresn(ia)
              line(ia)(iresncol1:iresncol1+litems(icol)-1)=
         -      items(icol)(1:litems(icol))
            end if
            if (ix_rnam .eq. 0) then
              call blankout(line(ia),irescol1,irescol2)
              line(ia)(irescol1:irescol1+2)='LIG'
            else
              icol=ix_rnam
              if (items(max0(1,icol))(1:2) .ne. '<>' .and. icol .gt. 0)
         -      line(ia)(irescol1:irescol1+litems(icol)-1)=
         -        items(icol)(1:litems(icol))
              if (items(max0(1,icol))(1:3) .eq. 'UNK') nUNK=nUNK+1
            end if
            icol=ix_segn
            if (items(max0(1,icol))(1:2) .ne. '<>' .and. icol .gt. 0) then
              segn4='    '
              len4=min0(4,litems(icol))
              segn4(1:len4)=items(icol)(1:len4)
              if (segn4 .ne. segn4prev) then
                nsegm=nsegm+1
                segn4prev=segn4
              end if
              isegno(ia)=nsegm
            end if
            icol=ix_atno
            if (items(max0(1,icol))(1:2) .ne. '<>' .and. icol .gt. 0) then
              read (items(icol)(1:litems(icol)),*,end=992,err=992) ian(ia)
            end if
            icol=ix_anam
            inamefound=0
            if (icol .gt. 0) then
              if (items(icol)(1:2) .ne. '<>')
         -      line(ia)(inamcol1:inamcol1+litems(icol)-1)=
         -        items(icol)(1:litems(icol))
              inamefound=1
            end if
            if (inamefound .eq. 0 .and. ian(ia) .gt. 0) then
              line(ia)(inamcol1:inamcol1+1)=iatnm2(ian(ia))
              inamefound=1
            end if
            if (inamefound .eq. 0) nnoname=nnoname+1
            icol=ix_occ
            if (items(max0(1,icol))(1:2) .ne. '<>' .and. icol .gt. 0) then
              read (items(icol)(1:litems(icol)),*,end=992,err=992) occ
              line(ia)(iocccol1:iocccol1+litems(icol)-1)=
         -      items(icol)(1:litems(icol))
            end if
            write (line(ia)(1:10),1001) ia
            icol=ix_charge1
            if (items(max0(1,icol))(1:2) .ne. '<>' .and. icol .gt. 0) then
              read (items(icol)(1:litems(icol)),*,end=992,err=992) q(ia)
              line(ia)(iqcol1:iqcol1+litems(icol)-1)=
         -      items(icol)(1:litems(icol))
            else
              icol=ix_tfac
              if (items(max0(1,icol))(1:2) .ne. '<>' .and. icol .gt. 0) then
                read (items(icol)(1:litems(icol)),*,end=992,err=992) q(ia)
                line(ia)(iqcol1:iqcol1+litems(icol)-1)=
         -        items(icol)(1:litems(icol))
              end if
            end if
          end do
          if (nnoname .gt. 0) then
            if (nnoname .lt. nats .and. nnoname .ne. nUNK) then
              nha=0
              do ia=1,nats
                if (line(ia)(inamcol1:inamcol2) .eq. '    ') then
                  nha=nha+1
                  line(ia)(inamcol1:inamcol1)='H'
                  ic=inamcol1+1
                  call writeint(line(ia),ic,nha,nhlen)
                end if
              end do
            else
              call zeroiti(iancount,0,99)
              do ia=1,nats
                if (line(ia)(inamcol1:inamcol2) .eq. '    ') then
                  iancount(ian(ia))=iancount(ian(ia))+1
                  line(ia)(inamcol1:inamcol1+1)=iatnm2(ian(ia))
                  if (iancount(ian(ia)) .le. 99) then
                    ic=inamcol1+1
                    call writeint(line(ia),ic,iancount(ian(ia)),nal)
                  else
                    write (iout,*) 'Atom count for ',iatnm2(ian(ia)),
         -            'exceeds 99'
                  end if
                end if
              end do
            end if
          end if
          call read_head_mae('m_bond',6,nbonds,linein,len,inpt,iout)
          if (maxng .gt. 1) then
            call read_colid_mae(ndcol,colid,lcolid,'bonds',5,linein,
         -    len,iend,inpt,iout,MAXCOL)
            if (iend .eq. 1) return
            call zeroiti(nn,0,nats)
            call zeroiti(in,0,maxng*nats)
            do ib=1,nbonds
              call blankout(linein,1,len)
              read (inpt,1000,end=991) linein
              ic=1
              call nextstring(linein,ic,ic1,ic2,len)
              icol=1
              read (linein(ic1:ic2),*,end=992,err=992) ix
              if (ix .ne. ib) then
                write (iout,2002) 'atom',ib,ix
                if (iout .ne. 6) write (6,2002) 'atom',ib,ix
                ierr=1
                return
              end if
              ic=ic2+1
              call nextstring(linein,ic,ic1,ic2,len)
              icol=2
              read (linein(ic1:ic2),*,end=992,err=992) ib1
              ic=ic2+1
              call nextstring(linein,ic,ic1,ic2,len)
              icol=3
              read (linein(ic1:ic2),*,end=992,err=992) ib2
              nn(ib1)=nn(ib1)+1
              in(nn(ib1),ib1)=ib2
              nn(ib2)=nn(ib2)+1
              in(nn(ib2),ib2)=ib1
            end do
          end if
          ierr=0
          return
    991   write (iout,2001) 'atom descriptors'
          if (iout .ne. 6) write (6,2001) 'atom descriptors'
          ierr=1
          return
    992   write (iout,2000) colid(icol)(1:lcolid(icol)),
         -  items(icol)(1:litems(icol)),linein(1:50)
          if (iout .ne. 6) write (6,2000) colid(icol)(1:lcolid(icol)),
         -  items(icol)(1:litems(icol)),linein(1:50)
          ierr=1
          return
    1000  format(a)
    1001  format(i10)
    2000  format(' ERROR: invalid ',a,':',a,' in line',/,1x,a)
    2001  format(' ERROR: run out of data while reading ',a)
    2002  format(' ERROR: index misaligment when reading ',a,
         - ' i=',i6,' i(read)=',i6)
          end
          subroutine read_head_mae(lab,llab,n,line,len,inpt,iout)
          character*(*) lab,line
          n=0
          do while (n .eq. 0)
            call blankout(line,1,len)
            read (inpt,1000,end=991) line
            ic=1
            call nextchar(line,ic,len)
            if (ic .lt. len) then
              if (line(ic:ic+llab-1) .eq. lab(1:llab) .and.
         -        line(ic+llab:ic+llab) .eq. '[') then
                ic1=ic+llab+1
                ic=ic1
                call findnextchar(']',line,ic,len)
                if (ic .eq. len) go to 992
                read (line(ic1:ic-1),*,end=992,err=992) n
              end if
            end if
          end do
          return
    991   write (iout,2001) lab(1:llab)
          return
    992   write (iout,2000) 'Invalid number of items',line(1:50)
          return
    1000  format(a)
    2000  format(' ERROR: ',a,' in line',/,1x,a)
    2001  format(' ERROR: run out of data while reading ',a,' header')
          end
          subroutine read_colid_mae(ndcol,colid,lcolid,lab,llab,line,
         -  len,iend,inpt,iout,maxcol)
          character*(*) lab,line
          character*50 colid(maxcol)
          dimension lcolid(MAXCOL)
          ndcol=1
          colid(1)='index'
          lcolid(1)=5
          ic=1
          iend=0
          do while (line(ic:ic+2) .ne. ':::')
            call blankout(line,1,200)
            read (inpt,1000,end=991,err=991) line
            call lastchar(line,lc,len)
            if (lc .gt. 1) then
              ic=1
              call nextchar(line,ic,len)
              if (line(ic:ic) .ne. '#') then
                ndcol=ndcol+1
                lcolid(ndcol)=min0(lc-ic+1,50)
                colid(ndcol)(1:lcolid(ndcol))=line(ic:lc)
              end if
            end if
          end do
          ndcol=ndcol-1
          return
    991   write (iout,2000) lab(1:llab)
          iend=1
          return
    1000  format(a)
    2000  format(' ERROR: run out of data while reading ',a,
         -  ' column identifiers')
          end
          subroutine read_cif_mol(nats,ian,iresno,isegno,nsegm,c,frocc,
         -  charge,altcol,inscol,index,line,lineread,title,ltitle,
         -  inptyp_cif,iofull,idcol,iruntyp,ialtcol,iinscol,ikeepfullalt,
         -  altnam,naltrec,naltdel,ninsres,ipredict,outfile,altfile,namleno,
         -  namlena,pdbid,ncol,asterisk,inpt,ierr,maxat)
          dimension ian(maxat),iresno(maxat),isegno(maxat),c(3,maxat),
         -  frocc(maxat),charge(maxat),index(maxat)
          character*1 altcol(maxat),inscol(maxat),altnam(50),asterisk
          character*132 line(maxat),linewr
          character*80 title
          character*200 linein,outfile,altfile
          character*4 pdbid
          character*2 iatnm2,an2
          common /atnam/ aw(99),nval(99),nvalmax(99),mmofan(99),
         -  mmatno(64),iatnm2(99)
          dimension limcol(2,30),lencol(30),ic_xyz(3)
          character*4 chain,chain_prev
          character*8 atomname
          character*10 rectyp
          call setcol(inptyp_cif,ncol,idcol,ialtcol,iinscol,
         -  inamcol1,inamcol2,irescol1,irescol2,iccol1,iccol2,
         -  iresncol1,iresncol2,iseqncol1,iseqncol2,isegcol1,isegcol2,
         -  iresidcol1,iresidcol2,iqcol1,iqcol2,ipotcol1,ipotcol2,
         -  iocccol1,iocccol2,ichemcol1,ichemcol2,nrescol,nresncol,
         -  nsegcol,nnamcol,iofull)
          ierr=0
          call get_title_cif(inpt,linein,lineread,title,ltitle,pdbid)
          call askyn('Do you want to use the author (PDB) residue numbers',
         -  51,1,1,iusepdbres,000,0)
          do while (linein(1:11) .ne. '_atom_site.')
            read (inpt,1000,end=999) linein
          end do
          ic_seqno=0
          ic_atsym=0
          ic_atname=0
          ic_alt=0
          ic_ins=0
          ic_resname=0
          ic_segid=0
          call zeroiti(ic_xyz,0,3)
          ic_frocc=0
          ic_beta=0
          ic_qform=0
          ic_resno=0
          ic_resno_auth=0
          icol=1
          do while (linein(1:11) .eq. '_atom_site.')
            ic=1
            call nextblank(linein,ic,200)
            len=ic-1
            if (linein(12:len) .eq. 'id') then
              ic_seqno=icol
            else if (linein(12:len) .eq. 'type_symbol') then
              ic_atsym=icol
            else if (linein(12:len) .eq. 'label_atom_id') then
              ic_atname=icol
            else if (linein(12:len) .eq. 'label_alt_id') then
              ic_alt=icol
            else if (linein(12:len) .eq. 'pdbx_PDB_ins_code') then
              ic_ins=icol
            else if (linein(12:len) .eq. 'label_comp_id') then
              ic_resname=icol
            else if (linein(12:len) .eq. 'label_asym_id') then
              ic_segid=icol
            else if (linein(12:len) .eq. 'Cartn_x') then
              ic_xyz(1)=icol
            else if (linein(12:len) .eq. 'Cartn_y') then
              ic_xyz(2)=icol
            else if (linein(12:len) .eq. 'Cartn_z') then
              ic_xyz(3)=icol
            else if (linein(12:len) .eq. 'occupancy') then
              ic_frocc=icol
            else if (linein(12:len) .eq. 'B_iso_or_equiv') then
              ic_beta=icol
            else if (linein(12:len) .eq. 'pdbx_formal_charge') then
              ic_qform=icol
            else if (linein(12:len) .eq. 'label_seq_id') then
              ic_resno=icol
            else if (linein(12:len) .eq. 'auth_seq_id') then
              ic_resno_auth=icol
            end if
            icol=icol+1
            call blankout(linein,1,200)
            read (inpt,1000,end=999) linein
          end do
          if (ic_xyz(1)*ic_xyz(2)*ic_xyz(3) .eq. 0) then
            print *,'ERROR: missing coordinate record(s) is not found'
            ierr=1
          end if
          if (ic_resno .eq. 0) then
            print *,'ERROR: residue number record is not found'
            ierr=1
          end if
          if (ic_atname .eq. 0)
         -   print *,'WARNING: atom name record is not found'
          if (ic_resname .eq. 0)
         -   print *,'WARNING: residue name record is not found'
          if (ic_atsym .eq. 0)
         -   print *,'WARNING: atom symbol record is not found'
          lenerr=0
          chain_prev='    '
          iresno_prev=0
          iresno_curr=0
          iresno_auth_prev=0
          isg=0
          do while (linein(1:4) .eq. 'ATOM' .or. linein(1:6) .eq. 'HETATM')
            nats=nats+1
            index(nats)=nats
            call blankout(line(nats),1,132)
            do k=1,3
              c(k,nats)=999.9
            end do
            ian(nats)=-1
            iresno(nats)=-1
            occ=0.0
            tfac=0.0
            ic=1
            nc=0
            call lastchar(linein,lc,200)
            line(nats)(1:4)=linein(1:4)
            if (linein(1:6) .eq. 'HETATM') line(nats)(1:6)=linein(1:6)
            do while (ic .lt. lc)
              nc=nc+1
              call nextstring(linein,ic,limcol(1,nc),limcol(2,nc),200)
              lencol(nc)=limcol(2,nc)-limcol(1,nc)+1
            end do
            rectyp='XYZ coords'
            do k=1,3
              icr=ic_xyz(k)
              read(linein(limcol(1,icr):limcol(2,icr)),*,err=888,end=888)
         -      c(k,nats)
              lenccol=(iccol2-iccol1+1)/3
              iccol0=iccol1+(k-1)*lenccol-1
              call save_cif_rec(rectyp,10,'iiccol',6,limcol(1,icr),
         -      line(nats),linein,iccol0+1,iccol0+lenccol,lencol(icr),0,
         -      lenerr)
            end do
            if (ic_resno_auth .gt. 0) then
              rectyp='Res_aut_no'
              icr=ic_resno_auth
              read(linein(limcol(1,icr):limcol(2,icr)),*,err=888,end=888)
         -      iresno_auth
              if (iusepdbres .eq. 1) then
                iresno(nats)=iresno_auth
                call save_cif_rec(rectyp,10,'iiresncol',9,
         -        limcol(1,icr),line(nats),linein,iresncol1,iresncol2,
         -        lencol(icr),0,lenerr)
              end if
            end if
            if (ic_resno .gt. 0 .and. iusepdbres .eq. 0) then
              rectyp='Residue no'
              icr=ic_resno
              if (linein(limcol(1,icr):limcol(2,icr)) .eq. '.') then
                iresno(nats)=-999999
              else
                read(linein(limcol(1,icr):limcol(2,icr)),*,err=888,end=888)
         -        iresno(nats)
                call save_cif_rec(rectyp,10,'iiresncol',9,
         -        limcol(1,icr),line(nats),linein,iresncol1,iresncol2,
         -        lencol(icr),0,lenerr)
                iresno_prev=iresno(nats)
              end if
            end if
            if (ic_atname .gt. 0) then
              icr=ic_atname
              call save_cif_rec('Atom name',9,'iinamcol',8,
         -      limcol(1,icr),line(nats),linein,inamcol1,inamcol2,
         -      lencol(icr),1,lenerr)
              atomname=line(nats)(inamcol1:inamcol2)
            end if
            if (ic_resname .gt. 0) then
              icr=ic_resname
              call save_cif_rec('Residue name',12,'iirescol',8,
         -      limcol(1,icr),line(nats),linein,irescol1,irescol2,
         -      lencol(icr),1,lenerr)
            end if
            if (ic_segid .gt. 0) then
              icr=ic_segid
              call save_cif_rec('Segment id',10,'iisegcol',8,
         -      limcol(1,icr),line(nats),linein,isegcol1,isegcol2,
         -      lencol(icr),1,lenerr)
              chain='    '
              chain(1:limcol(2,icr)-limcol(1,icr)+1)=
         -      linein(limcol(1,icr):limcol(2,icr))
              if (chain .ne. chain_prev) then
                isg=isg+1
                chain_prev=chain
              end if
              isegno(nats)=isg
            end if
            if (ic_atsym .gt. 0) then
              an2='  '
              icr=ic_atsym
              if (lencol(ic_atsym) .eq. 1) then
                an2(2:2)=linein(limcol(1,ic_atsym):limcol(2,ic_atsym))
              else
                an2(1:2)=linein(limcol(1,ic_atsym):limcol(2,ic_atsym))
                call uplow(an2(2:2),an2(2:2),1,noabc)
              end if
              call findname(an2,iatnm2,1,99,ian(nats),2)
              call save_cif_rec('Chemical sym',12,'iichemcol',9,
         -      limcol(1,icr),line(nats),linein,ichemcol1,ichemcol2,
         -      lencol(icr),0,lenerr)
            else if (ic_atname .gt. 0) then
              ian(nats)=ianum(atomname,1,lencol(ic_atname))
            end if
            if (ic_alt .gt. 0) then
              rectyp='Alt at id '
              icr=ic_alt
              if (linein(limcol(1,icr):limcol(2,icr)) .eq. '.' .or.
         -        linein(limcol(1,icr):limcol(2,icr)) .eq. '?')
         -      linein(limcol(1,icr):limcol(2,icr))=' '
              altcol(nats)=linein(limcol(1,icr):limcol(2,icr))
              call save_cif_rec(rectyp,9,'ialtcol',7,limcol(1,icr),
         -      line(nats),linein,ialtcol,ialtcol,lencol(icr),1,lenerr)
            end if
            if (ic_ins .gt. 0) then
              rectyp='Insrt code'
              icr=ic_ins
              if (linein(limcol(1,icr):limcol(2,icr)) .eq. '.' .or.
         -        linein(limcol(1,icr):limcol(2,icr)) .eq. '?')
         -      linein(limcol(1,icr):limcol(2,icr))=' '
              inscol(nats)=linein(limcol(1,icr):limcol(2,icr))
              if (inscol(nats) .ne. ' ') ninsres=ninsres+1
              call save_cif_rec(rectyp,9,'iinscol',7,limcol(1,icr),
         -      line(nats),linein,iinscol,iinscol,lencol(icr),1,lenerr)
            end if
            if (ic_frocc .gt. 0) then
              rectyp='Occupancy '
              icr=ic_frocc
              read(linein(limcol(1,icr):limcol(2,icr)),*,err=888,end=888)
         -      frocc(nats)
              call save_cif_rec(rectyp,9,'iiocccol',8,limcol(1,icr),
         -      line(nats),linein,iocccol1,iocccol2,lencol(icr),0,lenerr)
            end if
            if (ic_beta .gt. 0) then
              rectyp='Beta      '
              icr=ic_beta
              read(linein(limcol(1,icr):limcol(2,icr)),*,err=888,end=888)
         -      charge(nats)
              call save_cif_rec(rectyp,4,'iiqcol',6,limcol(1,icr),
         -      line(nats),linein,iqcol1,iqcol2,lencol(icr),0,lenerr)
            end if
            if (ic_seqno .gt. 0) then
              rectyp='Sequence n'
              icr=ic_seqno
              read(linein(limcol(1,icr):limcol(2,icr)),*,err=888,end=888)
         -      ii
              call save_cif_rec(rectyp,10,'iiseqncol',9,limcol(1,icr),
         -      line(nats),linein,iseqncol1,iseqncol2,lencol(icr),0,lenerr)
            end if
            if (iresno(nats) .eq. -999999) then
              if (iresno_auth .ne. iresno_auth_prev) then
                iresno_auth_prev=iresno_auth
                iresno_curr=iresno_prev+1
                iresno_prev=iresno_curr
              end if
              iresno(nats)=iresno_curr
            end if
            call altcolcheck(line(nats),idcol,iruntyp,ialtcol,
         -    ikeepfullalt,altnam,naltnam,naltrec,naltdel,ipredict,frocc,
         -    outfile,altfile,namleno,namlena,ncol,nats,asterisk,maxrec)
            call blankout(linein,1,200)
            read (inpt,1000,end=999) linein
          end do
    999   if (lenerr .gt. 0) then
            print *,'Record-length errors were found'
            call askstop(0)
          end if
          call altdelcheck(nats,naltnam,naltrec,altnam,ipredict,iruntyp,
         -  altcol,ialtcol,idcol,naltdel,ncol,line,index,idrop,linewr,
         -  altfile,namlena,asterisk,maxrec)
          nsegm=isegno(nats)
          return
    888   write (6,2002) rectyp,nats,linein(limcol(1,icr):limcol(2,icr)),
         -  (limcol(k,icr),k=1,2),icr
          stop
    1000  format(a)
    2002  format(' Invalid ',a,' entry for atom # ',i6,':',a,' lims:',2i4,
         -  ' icr=',i2)
          end
          subroutine get_title_cif(inpt,linein,lineread,title,ltitle,pdbid)
          character*80 title,titles(4)
          character*200 linein
          character*4 pdbid
          dimension len(4)
          pdbid='****'
          call zeroiti(len,0,4)
          len(4)=24
          titles(4)(1:len(4))='Title read interactively'
          ltfound=0
          do while (linein(1:10) .ne. '_atom.site' .and. ltfound .lt. 3)
            if (lineread .eq. 0) then
              call blankout(linein,1,200)
              read (inpt,1000,end=999) linein
            else
              lineread=0
            end if
            if (linein(1:5) .eq. '_data') pdbid=linein(6:9)
            if (linein(1:15) .eq. '_citation.title') then
              call blankout(linein,1,200)
              read (inpt,1000,end=999) linein
              call lastchar(linein,lc,200)
              len(1)=min0(80,lc-1)
              titles(1)(1:len(1))=linein(2:len(1)+1)
              ltfound=ltfound+1
            else if (linein(1:13) .eq. '_struct.title') then
              ic=15
              call nextstring(linein,ic,ic1,ic2,200)
              len(2)=min0(80,ic2-ic1+1)
              titles(2)(1:len(2))=linein(ic1:min0(ic2,ic1+79))
              ltfound=ltfound+1
            else if (linein(1:23) .eq. '_struct.pdbx_descriptor') then
              ic=25
              call nextstring(linein,ic,ic1,ic2,200)
              len(3)=min0(80,ic2-ic1+1)
              titles(3)(1:len(3))=linein(ic1:min0(ic2,ic1+79))
              ltfound=ltfound+1
            end if
          end do
    999   write (6,2000) (i,titles(i)(1:len(i)),i=1,4)
          call getint('Choice (1-4):',12,2,1,4,in,000)
          call blankout(title,1,80)
          if (in .le. 3) then
            if (len(in) .eq. 0) then
              print *,'ERROR: this choice is empty'
              go to 999
            end if
            ltitle=len(in)
            title(1:ltitle)=titles(in)(1:ltitle)
          else
            call getname(title,ltitle,'New title',9,80,'TITLE',5,1,000,00)
          end if
    1000  format(a)
    2000  format(' Select the title to use:',4(/,i2,1x,a))
          end
          subroutine save_cif_rec(label,llabel,clabel,lclabel,limcol,
         -  line,linein,ic1,ic2,len,noadjust,ierr)
          dimension limcol(2)
          character*(*) label,clabel
          character*132 line
          character*200 linein
          if (ic2-ic1+1 .lt. len) then
            write (6,2000) label(1:llabel),len,ic1,ic2,clabel(1:lclabel)
            len=ic2-ic1+1
            ierr=ierr+1
          end if
          line(ic1:ic1+len-1)=linein(limcol(1):limcol(2))
          if (noadjust .eq. 0) call rightadjustline(line,ic1,ic2)
          return
    2000  format(' ERROR: record length for ',a,' (',i2,') exceeds range:',
         -  i3,' - ',i3,/,' Record will be truncated',/,
         -  ' Modify the corresponding ',a,' values in block data')
          end
          subroutine setmolres(ifres,ilres,isegno,molresflag,
         -  molsltlim,nrescol,irescol1,irescol2,resnames,nresslt,nmolslt,
         -  nsegslt,nmolsltnoion,minresflag,index,indexa,indexs,line,
         -  maxrsd,maxrec)
          dimension ifres(maxrec),ilres(maxrec),isegno(maxrec),
         -  molresflag(maxrsd),
         -  molsltlim(3,maxrsd),index(maxrec),indexa(maxrec),indexs(maxrec)
          character* 132 line(maxrec)
          character*8 resnames(maxrsd)
          character*8 ionresnam(100),molresnam(100)
          write (6,2117)
          call askyn('Do you have ions in this system',31,1,-1,ions,18,0)
          if (ions .gt. 0) call getnamelist(ionresnam,nrescol,nions,
         -  'Ion residue name',16,100)
          write (6,2118)
          call askyn('Do you have molecular residues in this system',
         - 45,1,-1,imolres,19,0)
          if (imolres .gt. 0) call getnamelist(molresnam,nrescol,
         -  nmolres,'Molecular residue name',22,100)
          if (ions+imolres .gt. 0) then
            nions_found=0
            nmolres_found=0
            if (ions .gt. 0) call zeroiti(indexa,0,nions)
            if (imolres .gt. 0) call zeroiti(indexs,0,nmolres)
            minresflag=2
            do ir=1,nresslt
              resnames(ir)(1:nrescol)=
         -      line(index(ifres(ir)))(irescol1:irescol2)
              if (ions .gt. 0) then
                do irr=1,nions
                  if (resnames(ir)(1:nrescol) .eq.
         -            ionresnam(irr)(1:nrescol)) then
                    molresflag(ir)=2
                    indexa(irr)=indexa(irr)+1
                    nions_found=nions_found+1
                  end if
                end do
              end if
              if (imolres .gt. 0) then
                do irr=1,nmolres
                  if (molresflag(ir) .eq. 0 .and.
         -            resnames(ir)(1:nrescol) .eq.
         -            molresnam(irr)(1:nrescol))  then
                    molresflag(ir)=1
                    indexs(irr)=indexs(irr)+1
                    nmolres_found=nmolres_found+1
                  end if
                end do
              end if
              if (minresflag .gt. molresflag(ir)) minresflag=molresflag(ir)
            end do
            if (ions .gt. 0) then
              if (nions_found .eq. 0) write (6,2115) 'ions'
              if (nions_found .gt. 0) write (6,2114) 'ions',nions_found
            end if
            if (imolres .gt. 0) then
              if (nmolres_found .eq. 0) write (6,2115) 'molecular residues'
              if (nmolres_found .gt. 0)
         -      write (6,2114) 'molecular residues',nmolres_found
            end if
          else
            minresflag=0
          end if
          nrnoion=nresslt
          nmolion=0
          if (ions .gt. 0) then
            write (6,2121) (ionresnam(irr)(1:nrescol),'ion',
         -    indexa(irr),irr=1,nions)
            ir=nresslt
            do while (ir .gt. 1 .and. molresflag(ir) .eq. 2)
              ir=ir-1
            end do
            if (ir .eq. 1 .and. molresflag(ir) .eq. 2) ir=0
            nrnoion=ir
            numresions=nresslt-nrnoion
            do ir=1,nrnoion
              if (molresflag(ir) .eq. 2) then
                write (6,2116) ir
                molresflag(ir)=1
              end if
            end do
            nsegnoion=isegno(ilres(nrnoion))
            do ir=nrnoion+1,nresslt
              molsltlim(1,nsegnoion+ir-nrnoion)=ifres(ir)
              molsltlim(2,nsegnoion+ir-nrnoion)=ilres(ir)
              molsltlim(3,nsegnoion+ir-nrnoion)=0
            end do
            nmolion=nresslt-nrnoion
            nmolslt=nmolslt+nmolion-(nsegslt-nsegnoion)
          end if
          if (imolres .gt. 0) then
            write (6,2121) (molresnam(irr)(1:nrescol),'molecular residue',
         -    indexs(irr),irr=1,nmolres)
            nmoladd=0
            nresslt=0
            do ir=nrnoion,1,-1
              if (molresflag(ir) .eq. 1) then
                nresslt=nresslt+1
                is=isegno(ilres(ir))
                if (ilres(ir) .eq. molsltlim(2,is) .and.
         -          ifres(ir) .eq. molsltlim(1,is)) then
                else if (ilres(ir) .eq. molsltlim(2,is)) then
                  nmoladd=nmoladd+1
                  do iss=nmolslt+nmoladd,is+2,-1
                    molsltlim(1,iss)=molsltlim(1,iss-1)
                    molsltlim(2,iss)=molsltlim(2,iss-1)
                  end do
                  molsltlim(1,is+1)=ifres(ir)
                  molsltlim(2,is+1)=ilres(ir)
                  molsltlim(2,is)=ifres(ir)-1
                else if (ifres(ir) .eq. molsltlim(1,is)) then
                  nmoladd=nmoladd+1
                  do iss=nmolslt+nmoladd,is+2,-1
                    molsltlim(1,iss)=molsltlim(1,iss-1)
                    molsltlim(2,iss)=molsltlim(2,iss-1)
                  end do
                  molsltlim(1,is+1)=ilres(ir)+1
                  molsltlim(2,is+1)=molsltlim(2,is)
                  molsltlim(1,is)=ifres(ir)
                  molsltlim(2,is)=ilres(ir)
                else
                  nmoladd=nmoladd+2
                  do iss=nmolslt+nmoladd,is+3,-1
                    molsltlim(1,iss)=molsltlim(1,iss-2)
                    molsltlim(2,iss)=molsltlim(2,iss-2)
                  end do
                  molsltlim(2,is)=ifres(ir)-1
                  molsltlim(1,is+2)=ilres(ir)+1
                  molsltlim(2,is+2)=molsltlim(2,is)
                  molsltlim(1,is+1)=ifres(ir)
                  molsltlim(2,is+1)=ilres(ir)
                end if
              end if
            end do
            nmolslt=nmolslt+nmoladd
          end if
          nmolsltnoion=nmolslt-nmolion
          if (ions+imolres .gt. 0) then
            do is=1,nmolslt
              molsltlim(3,is)=0
            end do
          end if
          return
    2114  format(' Number of ',a,' found=',i4)
    2115  format(' ERROR: none of the given ',a,' were found')
    2116  format(' WARNING: residue ',i5,' is an ion residue but is not ',
         -  'at the end of the solute in a contiguous block ',/,
         -  ' - it will be treated as a molecular residue')
    2117  format(' Simulaid treats ions as separate molecules for PBC ',
         -  'calculations',/,' and will not be considered part of the ',
         -  'solute ',/,' for the purpose of centering the system.',/,
         -  ' Ions have to be grouped together at the end of the solute ')
    2118  format(' Simulaid treats segments as whole molecules for PBC ',
         -  'calculations.',/,' However, you may specify residue names ',/,
         -  ' that are to be considered separate molecules')
    2121  format(' Number of ',a,1x,a,'s found=',i3)
          end
          subroutine uniquename(anames,n)
          character*4 anames(n)
          dimension ntyp(200)
          character*4 typnames(200),number
          ntyps=0
          do ia=1,n
            call findname(anames(ia),typnames,1,ntyps,ix,4)
            if (ix .eq. 0) then
              ntyps=ntyps+1
              if (ntyps .gt. 200) then
                print *,'Number of names exceeds 200 - redimension ',
         -        'the subroutine uniquenames'
                stop
              end if
              typnames(ntyps)=anames(ia)
            end if
          end do
          call zeroiti(ntyp,0,200)
          do ia=1,n
            call findname(anames(ia),typnames,1,ntyps,ix,4)
            if (ix .eq. 0) then
              print *,'PROGRAM ERROR in uniquename: ix=0'
            else
              ntyp(ix)=ntyp(ix)+1
              call lastchar(anames(ia),lc,4)
              ic=1
              call writeint(number,ic,ntyp(ix),len)
              if (lc+len .gt. 4) then
                write (6,1000) ntyp(ix),anames(ia)
                if (anames(ia)(1:1) .eq. ' ') write (6,1001)
                stop
              end if
              anames(ia)(lc+1:lc+len)=number(1:len)
            end if
          end do
          return
    1000  format(' There is no room to write ',i4,' after ',a)
    1001  format(' You can make room by first leftadjust the atom names')
          end
          subroutine getseg4(segid4,line,isegcol1,nsegcol)
          character*4 segid4
          character*8 segid8
          character* 132 line
          if (nsegcol .le. 4) then
            segid4(1:nsegcol)=line(isegcol1:isegcol1+nsegcol-1)
          else
            segid8(1:nsegcol)=line(isegcol1:isegcol1+nsegcol-1)
            call leftadjustline(segid8,1,nsegcol)
            segid4(1:4)=segid8(1:4)
          end if
          return
          end
          subroutine molarvol(nslt,n,naslv,line,index,ir1,ir2,irn1,irn2,
         -  naa,nna,nnw,nnf,v,maxrec)
          character* 132 line(maxrec)
          dimension index(maxrec)
          character*8 resname,resnamela
          character*1 aanames1
          character*2 mmodtoamb
          character*3 aanames3
          common /atnamcon/ mmodtoamb(100),aanames1(58),aanames3(58),
         -  naanames,nnanames,nnammnames,nnames,ixwatnam
          common /pmvol/ pmvaana(58)
          lresn=ir2-ir1+1
          vna=0.0
          vpr=0.0
          vw=0.0
          naa=0
          nna=0
          nnw=0
          nnf=0
          iresnumo=0
          do ia=1,nslt
            call readint(line(index(ia)),irn1,irn2,iresnum,2,1,irerr)
            if (iresnum .ne. iresnumo) then
              iresnumo=iresnum
              resname(1:lresn)=line(index(ia))(ir1:ir2)
              call leftadjustn(resname,resnamela,lresn)
              call findname(resnamela,aanames3,1,naanames,ix,3)
              if (ix .gt. 0 .and.
         -        ix .ne. ixwatnam-1 .and. ix .ne. ixwatnam) then
                vpr=vpr+pmvaana(ix)
                naa=naa+1
              else if (resname(1:3) .eq. 'TIP' .or.
         -       resname(1:3) .eq. 'WTR' .or. resname(1:3) .eq. 'HOH') then
                vw=vw+pmvaana(32)
                nnw=nnw+1
              else
                call findname(resnamela,aanames3,
         -        naanames+nnammnames+1,nnames,ix,3)
                if (ix .gt. 0) then
                  vna=vna+pmvaana(ix)
                  nna=nna+1
                else
                  nnf=nnf+1
                end if
              end if
            end if
          end do
          if (n .gt. nslt) then
            resname(1:lresn)=line(index(nslt+1))(ir1:ir2)
            call leftadjustn(resname,resnamela,lresn)
            if (resnamela(1:3) .eq. 'TIP' .or.
         -      resname(1:3) .eq. 'WTR' .or. resname(1:3) .eq. 'HOH') then
              nnw=(n-nslt)/naslv
              vw=nnw*18.07*1.e+24/6.022045e+23
            end if
          end if
          if (nslt .gt. 0) then
            vpr=vpr*1.e+24/6.022045e+23
            vna=vna*1.e+24/6.022045e+23
            v=vpr+vna
            write (6,1000) naa,nna,nnf,v
            if (naa .gt. 0) write (6,1001) 'protein',vpr
            if (nna .gt. 0) then
              write (6,1001) 'nucleic acid',vna
              write (6,1003)
            end if
            if (nnf .gt. 0) write (6,1002)
          end if
          if (n .gt. nslt) then
            if (nnw .gt. 0) then
              print *,'The solvent is assumed to be water'
              write (6,1001) 'water',vw
            end if
          end if
          return
    1000  format(' The solute contains ',i4,' amino acid residues',
         -  i4,' nucleic acid residues',/,
         -  ' and',i6,' unclassified residues',/,
         -  ' The volume of the solute is estimated to be ',f10.2,' A^3')
    1001  format(' Volume of the ',a,' (part) is estimated to be',f12.2,
         -  ' A^3')
    1002  format(' NOTE: unclassified residues did not contribute to the ',
         -  'total solute volume')
    1003  format(' NOTE: Nucleic acid volumes are very sensitive to ',
         -  'cc, salt, etc.')
          end
          subroutine dssp(c,n1,n,nslt,line,index,inamcol1,inamcol2,
         -  iresncol1,iresncol2,nneig,ineig,nbox,indices,ihbneig,ixc,ixo,
         -  ixn,ixa,dssplab,idistdssp,ch,cres,enghb,iparal,iantiparal,nss,
         -  itypss,ifss,ilss,ires0,nconfig,iwdssp,iwrose,iwhead,ifail,
         -  radtodeg,maxrepconf,maxng,nnlistlen,maxbox,listlen,maxss,
         -  maxrsd,maxrec)
          dimension c(3,n),index(n),nneig(n),ineig(maxng,nnlistlen),
         -  indices(maxbox,listlen),nbox(listlen),ihbneig(n),ixc(n),ixo(n),
         -  ixn(n),ixa(n),cres(3,n),iparal(n),iantiparal(n),
         -  idistdssp(9,maxrsd),ch(3,maxrsd),enghb(maxrsd),itypss(maxss),
         -  ifss(maxss),ilss(maxss)
          character*1 dssplab(maxrsd)
          dimension ccprev(3),rx(3),rn(3),rnprev(3),rn1(3),rn1prev(3)
          character*1 charl1(50),charl2(50)
          character*8 atnam
          character* 132 line(maxrec)
          character*1 typc
          character*21 ssname
          common /dsspnames/ lssname(9),ssname(9),typc(9)
          real*8 cosa
          data ing /0/,ils /0/
          lnam=inamcol2-inamcol1+1
          ifail=0
          iok=1
          nres=0
          nresok=0
          iccprevf=0
          icccurrf=0
          icfound=0
          iofound=0
          infound=0
          ihfound=0
          iafound=0
          do ia=n1,nslt
            atnam(1:lnam)=line(index(ia))(inamcol1:inamcol2)
            if (lnam .eq. 4) atnam(5:8)='    '
            if (lnam .gt. 4) call leftadjustn(atnam,atnam,lnam)
            if (atnam(1:4) .eq. 'C   ' .or. atnam(1:4) .eq. ' C   ') then
              icfound=1
              ixc(nres+1)=ia
            else if (atnam(1:4) .eq. 'O   ' .or. atnam(1:4) .eq. ' O   ')
         -           then
              iofound=1
              ixo(nres+1)=ia
            else if (atnam(1:4) .eq. 'N   ' .or. atnam(1:4) .eq. ' N   ')
         -           then
              infound=1
              ixn(nres+1)=ia
            else if (atnam(1:4) .eq. 'CA  ' .or. atnam(1:4) .eq. ' CA  ')
         -           then
              iafound=1
              ixa(nres+1)=ia
            else if (atnam(1:4) .eq. 'H   ' .or. atnam(1:4) .eq. ' H   '
         -    .or. atnam(1:4) .eq. ' D  ' .or. atnam(1:4) .eq. 'D   ' .or.
         -    atnam(1:4) .eq. 'HN  ' .or. atnam(1:4) .eq. ' HN ') then
              ihfound=1
              call trnsfr(ch(1,nres+1),c(1,ia),3)
            end if
            if (ia .eq. nslt) then
              iresn=-1
            else
              read (line(index(ia+1))(iresncol1:iresncol2),*,ERR=999) iresn
              if (ia .eq. n1) ireso=iresn
            end if
            if (iresn .ne. ireso) then
              nres=nres+1
              iok=1
              if (ireso .ne. 0) then
                if (icfound*infound*iofound .lt. 1) then
                  if (nconfig .le. maxrepconf)
         -          print *,'Residue ',ireso,' is missing N, C or O'
                  iok=0
                else if (ihfound .eq. 0) then
                  iok=0
                  call zeroit(ch(1,nres),3)
                  if (iccprevf*iafound .eq. 1) then
                    dnh=0.0
                    dnc=0.0
                    do k=1,3
                      rx(k)=2.0*c(k,ixn(nres))-c(k,ixa(nres))-ccprev(k)
                      dnh=dnh+rx(k)**2
                      dnc=dnc+(c(k,ixn(nres))-ccprev(k))**2
                    end do
                    if (dnc .lt. 4.0) then
                      do k=1,3
                        ch(k,nres)=c(k,ixn(nres))+rx(k)/sqrt(dnh)
                      end do
                      iok=1
                    else
                      if (nconfig .le. maxrepconf)
         -              print *,'Chain break at residue',nres,
         -              ' no H generated'
                    end if
                  else
                    if (nconfig .le. maxrepconf)
         -            print *,'Could not generate H for residue',ireso
                  end if
                end if
                if (icfound .eq. 1) then
                  iccprevf=1
                  if (nres .gt. 1 .and. ixn(nres) .gt. 0) then
                    if (dist2(ccprev,c(1,ixn(nres))) .gt. 4.0) then
                      ihbneig(nres-1)=-1
                      if (nconfig .le. maxrepconf)
         -              print *,'Chain break between residues',nres-1,
         -                ' and',nres
                    end if
                  end if
                  call trnsfr(ccprev,c(1,ixc(nres)),3)
                else
                  iccprevf=0
                  call zeroit(ccprev,3)
                end if
                if (iok .eq. 1) then
                  nresok=nresok+1
                  ihbneig(nres)=0
                else
                  ihbneig(nres)=-1
                end if
              end if
              ireso=iresn
              icfound=0
              iofound=0
              infound=0
              ihfound=0
              iafound=0
            end if
          end do
          if (nresok .eq. 0) then
            print *,'ERROR: No residues containing C, O and N were found'
            ifail=1
            return
          end if
          threshold=-0.5/(0.42*0.20*332.0)
          do ir=1,nres
            enghb(ir)=threshold+1.0e-5
            dssplab(ir)=' '
            if (ixc(ir) .gt. 0) then
              call trnsfr(cres(1,ir),c(1,ixc(ir)),3)
            else
              call zeroit(cres(1,ir),3)
            end if
          end do
          rchb=9.2
          call nnlistsim(1,nres,cres,nneig,ineig,indices,nbox,
         -  rchb,ifail,maxng,nnlistlen,maxbox,listlen,0)
          if (ifail .gt. 0) then
            print *,'Linked-cell routine failed'
            do ir=1,nres
              if (ihbneig(ir) .ge. 0) then
                do jr=ir+3,nres
                  if (ihbneig(jr) .ge. 0) then
                    if (dist2(c(1,ixc(ir)),c(1,ixc(jr))) .lt. rchb**2) then
                      eij=1.0/sqrt(dist2(c(1,ixo(ir)),c(1,ixn(jr))))+
         -              1.0/sqrt(dist2(c(1,ixc(ir)),ch(1,jr)))-
         -              1.0/sqrt(dist2(c(1,ixo(ir)),ch(1,jr)))-
         -              1.0/sqrt(dist2(c(1,ixc(ir)),c(1,ixn(jr))))
                      eji=1.0/sqrt(dist2(c(1,ixo(jr)),c(1,ixn(ir))))+
         -              1.0/sqrt(dist2(c(1,ixc(jr)),ch(1,ir)))-
         -              1.0/sqrt(dist2(c(1,ixo(jr)),ch(1,ir)))-
         -              1.0/sqrt(dist2(c(1,ixc(jr)),c(1,ixn(ir))))
                      if (eij .lt. enghb(ir)) then
                        if (enghb(ir) .eq. 0.0) write (6,1157) ir,jr,
         -                ihbneig(ir),enghb(ir),eij
                        ihbneig(ir)=jr
                        enghb(ir)=eij
                      end if
                      if (eji .lt. enghb(jr)) then
                        if (enghb(jr) .eq. 0.0) write (6,1157) jr,ir,
         -                ihbneig(jr),enghb(ir),eji
                        ihbneig(jr)=ir
                        enghb(jr)=eji
                      end if
                    end if
                  end if
                end do
              end if
            end do
          else
            do ir=1,nres
              if (ihbneig(ir) .ge. 0) then
                do jjr=1,nneig(ir)
                  jr=ineig(jjr,ir)
                  if (ihbneig(jr) .ge. 0 .and. jr .gt. ir+2) then
                    if (dist2(c(1,ixc(ir)),c(1,ixc(jr))) .lt. rchb**2) then
                      eij=1.0/sqrt(dist2(c(1,ixo(ir)),c(1,ixn(jr))))+
         -              1.0/sqrt(dist2(c(1,ixc(ir)),ch(1,jr)))-
         -              1.0/sqrt(dist2(c(1,ixo(ir)),ch(1,jr)))-
         -              1.0/sqrt(dist2(c(1,ixc(ir)),c(1,ixn(jr))))
                      eji=1.0/sqrt(dist2(c(1,ixo(jr)),c(1,ixn(ir))))+
         -              1.0/sqrt(dist2(c(1,ixc(jr)),ch(1,ir)))-
         -              1.0/sqrt(dist2(c(1,ixo(jr)),ch(1,ir)))-
         -              1.0/sqrt(dist2(c(1,ixc(jr)),c(1,ixn(ir))))
                      if (eij .lt. enghb(ir)) then
                        if (enghb(ir) .eq. 0.0) write (6,1157) ir,jr,
         -                ihbneig(ir),enghb(ir),eij
                        ihbneig(ir)=jr
                        enghb(ir)=eij
                      end if
                      if (eji .lt. enghb(jr)) then
                        if (enghb(jr) .eq. 0.0) write (6,1157) jr,ir,
         -                ihbneig(jr),enghb(ir),eji
                        ihbneig(jr)=ir
                        enghb(jr)=eji
                      end if
                    end if
                  end if
                end do
              end if
            end do
          end if
          nss=0
          call zeroiti(iparal,0,nres)
          call zeroiti(iantiparal,0,nres)
          ir=1
          do while (ir .lt. nres)
            do while (ir .lt. nres .and. ihbneig(ir) .le. 0)
              ir=ir+1
            end do
            nhbinc=ihbneig(ir)-ir
            irf=ir
            nss0=nss
            if (nhbinc .gt. 2 .and. nhbinc .le. 5) then
              ihfound=1
              nstep=1
              ir=ir+1
              do while (ihfound .eq. 1)
                nhbinc1=ihbneig(ir)-(ir)
                nhbinc2=ihbneig(ir+1)-(ir+1)
                nhbinc3=ihbneig(ir+2)-(ir+2)
                if (nhbinc1 .ne. nhbinc) then
                  if (nhbinc2 .ne. nhbinc) then
                    if (nhbinc1 .eq. nhbinc2) then
                      ihfound=0
                    else if (nhbinc3 .ne. nhbinc) then
                      ihfound=0
                    end if
                  end if
                end if
                if (ihfound .eq. 1) then
                  nstep=nstep+1
                  irprev=ir
                  ir=ir+1
                end if
              end do
              if (ir-irf .gt. 1) then
                nss=nss+1
                ifss(nss)=irf
                ilss(nss)=ir+nhbinc-1
                itypss(nss)=nhbinc+3
              else
                ir=ir-1
              end if
            else if (nhbinc .eq. -3) then
              ihfound=1
              nstep=1
              ir=ir+1
              do while (ihfound .eq. 1)
                nhbinc1=ihbneig(ir)-(ir)
                if (nhbinc1 .ne. nhbinc) then
                  ihfound=0
                end if
                if (ihfound .eq. 1) then
                  nstep=nstep+1
                  irprev=ir
                  ir=ir+1
                end if
              end do
              if (ir-irf .gt. 1) then
                nss=nss+1
                ifss(nss)=irf
                ilss(nss)=ir+nhbinc-1
                itypss(nss)=9
              end if
            else if (ihbneig(ir) .gt. 0) then
              isfound=1
              isfirst=0
              islast=0
              npar=0
              napar=0
              ineigmax=0
              ineigmin=nres
              ifs=-1
              do while (isfound .eq. 1)
                jr=ihbneig(ir)
                if (jr .gt. 0) then
                  if (ihbneig(jr) .eq. ir) then
                    iantiparal(ir)=1
                    ing=jr
                    ifs=ir-1
                    ils=ir+1
                  end if
                end if
                if (jr .gt. 2) then
                  if (ihbneig(jr-2) .gt. 0) then
                    if (ihbneig(jr-2) .eq. ir) then
                      iparal(ir)=1
                      ing=jr
                      ifs=ir
                      ils=ir+2
                    end if
                  end if
                end if
                if (ir .gt. 1 .and. ir .lt. nres) then
                  jrm=ihbneig(ir-1)
                  if (jrm .gt. 0) then
                    if (ihbneig(jrm) .eq. ir+1) then
                      iparal(ir)=1
                      ing=jrm
                      ifs=ir
                      ils=ir+2
                    end if
                  end if
                else
                  jrm=0
                end if
                if (jrm .gt. 2) then
                  if (ihbneig(jrm-2) .gt. 0) then
                    if (ihbneig(jrm-2) .eq. ir+1) then
                      iantiparal(ir)=1
                      ing=jrm
                      ifs=ir
                      ils=ir+2
                    end if
                  end if
                end if
                if (iparal(ir)+iantiparal(ir) .gt. 0) then
                  if (isfirst .eq. 0) isfirst=ifs
                  if (ineigmin .gt. ing) ineigmin=ing
                  if (ineigmax .lt. ing) ineigmax=ing
                else if (ir .eq. 1) then
                  isfound=0
                else if (ir .gt. 1) then
                  if (iparal(ir-1)+iantiparal(ir-1) .eq. 0) then
                    isfound=0
                    islast=ils
                  end if
                end if
                npar=npar+iparal(ir)
                napar=napar+iantiparal(ir)
                ir=ir+1
              end do
              if (islast-isfirst .gt. 2 .and. isfirst .gt. 0) then
                nss=nss+1
                ifss(nss)=isfirst
                ilss(nss)=islast
                if (npar*napar .gt. 0) then
                  itypss(nss)=3
                else if (npar .gt. 0)  then
                  itypss(nss)=1
                  if (ineigmax-ineigmin .gt. (islast-isfirst)*2)
         -          itypss(nss)=4
                else if (napar .gt. 0)  then
                  itypss(nss)=2
                  if (ineigmax-ineigmin .gt. (islast-isfirst)*2)
         -          itypss(nss)=5
                end if
              end if
            end if
            if (nss .eq. maxss) then
              write (6,1002) maxss
              if (iwdssp .gt. 0) write (iwdssp,1002) maxss
              ir=nres
            else if (nss .eq. nss0) then
                ir=ir+1
            else
              if (nss .gt. 1) then
                if (ilss(nss-1) .ge. ifss(nss)) ifss(nss)=ilss(nss-1)+1
              else
                if (ifss(1) .lt. 1) ifss(1)=1
              end if
              ir=ir+1
            end if
          end do
          do iss=1,nss
            do ir=ifss(iss),ilss(iss)
              dssplab(ir)=typc(itypss(iss))
              idistdssp(itypss(iss),ir)=idistdssp(itypss(iss),ir)+1
            end do
          end do
          if (iwdssp .gt. 0) then
            if (nconfig .le. 1) then
              if (nss .gt. 0) then
                write (iwdssp,2005) (i,ires0+ifss(i),ires0+ilss(i),
         -        ssname(itypss(i))(1:lssname(itypss(i))),i=1,nss)
                write (6,2005) (i,ires0+ifss(i),ires0+ilss(i),
         -        ssname(itypss(i))(1:lssname(itypss(i))),i=1,nss)
              else
                write (iwdssp,2006)
                write (6,2006)
              end if
            end if
            if (iwhead .eq. 1)
         -     write (iwdssp,2004) (typc(i),ssname(i)(1:lssname(i)),i=1,9)
            iresf=1
            do while (iresf .le. nres)
              iresl=min0(nres,iresf+49)
              do ic=1,50
                charl1(ic)=' '
                charl2(ic)=' '
              end do
              do ir=max0(3,iresf),min0(iresl,nres-2)
                if (ixa(ir-2)*ixa(ir)*ixa(ir+2) .ne. 0) then
                  call angles(dist2(c(1,ixa(ir-2)),c(1,ixa(ir))),
         -          dist2(c(1,ixa(ir+2)),c(1,ixa(ir))),
         -          dist2(c(1,ixa(ir-2)),c(1,ixa(ir+2))),ca1,ca2,cbend)
                  cosa=dble(cbend)
                  bend=180.0-dacoscheck(cosa,ccc,1,6,'DSSP')*radtodeg
                  if (bend .gt. 70.0) charl1(ir-iresf+1)='S'
                else
                  charl1(ir-iresf+1)='?'
                end if
              end do
              do ir=max0(2,iresf),min0(iresl,nres-2)
                if (ixa(ir-1)*ixa(ir)*ixa(ir+1)*ixa(ir+2) .ne. 0) then
                  tors=dihangl(c,ixa(ir-1),ixa(ir),ixa(ir+1),ixa(ir+2),0,n)
                  if (tors .ge. 0.0) then
                    charl2(ir-iresf+1)='+'
                  else
                    charl2(ir-iresf+1)='-'
                  end if
                else
                  charl2(ir-iresf+1)='?'
                end if
              end do
              write (iwdssp,2000) iresf,iresl,(mod(i,10),i=iresf,iresl)
              write (iwdssp,2001) (mod(ihbneig(i)/1000,10),i=iresf,iresl)
              write (iwdssp,2001) (mod(ihbneig(i)/100,10),i=iresf,iresl)
              write (iwdssp,2001) (mod(ihbneig(i)/10,10),i=iresf,iresl)
              write (iwdssp,2001) (mod(ihbneig(i),10),i=iresf,iresl)
              write (iwdssp,2002) (charl1(i-iresf+1),i=iresf,iresl)
              write (iwdssp,2002) (charl2(i-iresf+1),i=iresf,iresl)
              write (iwdssp,2002) (dssplab(i),i=iresf,iresl)
              iresf=iresl+1
            end do
          end if
          if (iwrose .gt. 0) then
            write (iwrose,*) 'Data for turn detection with GW Rose method'
            call normplane(c(1,ixa(1)),c(1,ixa(3)),c(1,ixa(5)),rnprev)
            call normplane(c(1,ixa(2)),c(1,ixa(3)),c(1,ixa(4)),rn1prev)
            do ir=4,nres-2
              call radcirc(c(1,ixa(ir-2)),c(1,ixa(ir)),c(1,ixa(ir+2)),r)
              call normplane(c(1,ixa(ir-2)),c(1,ixa(ir)),c(1,ixa(ir+2)),rn)
              rnn=scprod(rn,rnprev)
              call normplane(c(1,ixa(ir-1)),c(1,ixa(ir)),c(1,ixa(ir+1)),rn1)
              rnn1=scprod(rn1,rn1prev)
              call angles(dist2(c(1,ixa(ir-2)),c(1,ixa(ir))),
         -      dist2(c(1,ixa(ir+2)),c(1,ixa(ir))),
         -      dist2(c(1,ixa(ir-2)),c(1,ixa(ir+2))),ca1,ca2,cbend)
              cosa=dble(cbend)
              bend=180.0-dacoscheck(cosa,ccc,1,6,'DSSP')*radtodeg
              charl1(1)=' '
              if (bend .gt. 70.0) charl1(1)='S'
              write (iwrose,2003) ir,charl1(1),dssplab(ir),r,rnn,rnn1
              call trnsfr(rnprev,rn,3)
              call trnsfr(rn1prev,rn1,3)
            end do
          end if
          return
    999   write (6,1000) ia,line
          if (iwdssp .gt. 0) write (iwdssp,1000) ia,line
          return
    1000  format(' ERROR: invalid residue number for atom ',i6,':',/,a)
    1002  format(' ERROR: maximum number of secondary structure elements (',
         -  i3,') has been reached',/,' - redimension the program ')
    1157  format(' eHB update ',i4,' to ',i4,' eold=',f6.2,' old partner=',
         -  i4,' enew=',f6.2)
    2000  format(/,i6,'-',i5,': ',50i1)
    2001  format(14x,50i1)
    2002  format(14x,50a1)
    2003  format(i5,' DSSP labels:',a1,1x,a1,' rc=',f8.3,
         -  ' rn.rnprv(2)=',f8.4,' rn.rnprv(1)=',f8.4)
    2004  format(/' line 1: residue number (mod 10)',/,
         -  ' lines 2-5: the digits of the residue number to which the ',/,
         -  12x,'residue number of line 1 is H-bonded (if any)',/,
         -  ' line 6: S for residues with bend angle ',
         -  '(CA(ir-2)-CA(ir)-CA(ir+2)) > 70 deg',/,
         -  ' line 7: + or -, the sign of the ',
         -  '(CA(ir-1)-CA(ir)-CA(ir+1)-CA(ir+2)) angle',/,
         -  ' line 8: secondary structure element type:',/,
         -  9(9x,a1,': ',a))
    2005  format(/,(' SS#',i3,' Residue index range: [',i5,',',i5,'] Type:',
         -  a))
    2006  format(' No secondary structure element was found')
          end
          subroutine checkforhelix(nhxres,dssplab,indexn,iw,hxoklab,ihxok,
         -  lab,llab,maxrsd,maxrec)
          dimension indexn(maxrec)
          character*1 dssplab(maxrsd)
          character*6 hxoklab(3)
          character*(*) lab
          ihxok=1
          do ir=1,nhxres
            indexn(ir)=1
            if (dssplab(ir) .ne. 'G' .and. dssplab(ir) .ne. 'H'
         -    .and. dssplab(ir) .ne. 'I' .and.
         -     dssplab(ir) .ne. 'L') indexn(ir)=0
            if (dssplab(ir) .eq. ' ') dssplab(ir)='?'
          end do
          if (indexn(1) .eq. 0 .or. indexn(nhxres) .eq. 0) then
            ihxok=3
          else
            do ir=2,nhxres-1
              if (indexn(ir) .eq. 0) ihxok=2
            end do
          end if
          write (iw,2088) lab(1:llab),hxoklab(ihxok),
         -  (dssplab(ir),ir=1,nhxres)
          return
    2088  format(a,' is ',a,': ',(60a1))
          end
          subroutine getlist(list,len,minval,maxval,nlist,maxlen)
          dimension list(nlist,maxlen)
          common /logging/ logfile,ipredict
          character*200 listfile
          character*80 listprompt,line
          namlenl=-1
          listinp=55
          listprev=-999999
          iallpair=0
          irangeinp=0
          if (nlist .eq. 1) then
            write (6,1006) ' ',' in increasing order'
          else
            write (6,1006)
            call askyn(
         -    'Do you want to input just one number per line',
         -    45,1,-1,iallpair,99,0)
             if (iallpair .eq. 0) write (6,1006) ' one pair per line'
             if (iallpair .eq. 1) write (6,1006) ' one per line'
          end if
          write (6,1011)
          call getname(listfile,llistfile,'Name of the list file',21,80,
         -  '',0,1,0,0)
          if (llistfile .gt. 0) then
            call openfile(listinp,1,'list',4,'old',listfile,llistfile,
         -    notfnd,0,1,1,0,0)
          else
            listinp=5
            if (nlist .eq. 1) write (6,1002)
          end if
          maxvalchk=maxval
          if (maxval .eq. 999999) maxvalchk=0
          len=0
          if (nlist .eq. 1 .and. listinp .ne. 5) then
            call readfreelist(list,len,listinp,1,maxlen)
            go to 8
          else if (nlist .eq. 1) then
    100     do while (.true.)
              call blankout(line,1,80)
              call getname(line,lline,'0/r/#:',6,80,'',0,1,0,0)
              if (lline .eq. 0) go to 999
              if (line(1:1) .eq. 'r' .or. line(1:1) .eq. 'R') then
                irangeinp=1
                call getrange(ifst,999999,ilst,999999,increment,1,'number',
         -        6,maxvalchk,0)
                if (ifst .le. listprev) then
                  print *,'Ignoring this range - list has to be in ',
         -          'increasing order'
                  ndrop=1
                else
                  do ics=ifst,ilst,increment
                    len=len+1
                    list(1,len)=ics
                  end do
                  listprev=list(1,len)
                  if (list(1,len) .ne. ilst) then
                    write (6,1005) list(1,len),ilst
                  end if
                end if
              else
                read (line,*,err=99,end=8) ics
                if (ics .eq. 0) then
                  list(1,len+1)=0
                  go to 8
                else
                  len=len+1
                  list(1,len)=ics
                end if
              end if
              ndrop=0
              if (ics .le. listprev) then
                print *,'Ignoring',ics,' - sorry, list has to be in ',
         -        'increasing order'
                print *,'LISTPREV=',listprev
                len=len-1
                ndrop=1
              end if
              if (ndrop .eq. 0) then
                if (len .eq. maxlen) then
                  print *,'List truncated at the',maxlen,'-th element ',
         -         '- redimension Simulaid for longer list'
                  go to 8
                end if
              end if
              listprev=list(1,len)
              irangeinp=0
            end do
    99      print *,'Invalid input - ignored'
            go to 100
          else if (iallpair .eq. 0) then
    200     do while (.true.)
              call blankout(line,1,80)
              if (listinp .eq. 5) then
                write (listprompt,1008) 'pair'
                call getname(line,lline,listprompt,28,80,'',0,1,0,0)
              else
                read (listinp,1004,end=998) line
              end if
              read (line,*,err=88) i1
              if (i1 .eq. 0) go to 8
              len=len+1
              read (line,*,err=88) (list(k,len),k=1,2)
              if (maxvalchk .gt. 0) then
                do k=1,2
                  if (list(k,len) .gt. maxval .or.
         -            list(k,len) .lt. minval) then
                    write (6,1010) list(k,len),minval,maxval
                    len=len-1
                    go to 200
                  end if
                end do
              end if
              if (len .eq. maxlen) then
                print *,'List truncated at the',maxlen,'-th element ',
         -       '- redimension Simulaid for longer list'
                go to 8
              end if
            end do
    88      print *,'Invalid input - ignored'
            go to 200
          else
            lenpair=1
            ix1=1
    300     do while (.true.)
              if (listinp .eq. 5) write (6,1008) 'element'
              call blankout(line,1,80)
              if (listinp .eq. 5) then
                write (listprompt,1008) 'element'
                call getname(line,lline,listprompt,31,80,'',0,1,0,0)
              else
                read (listinp,1004,end=999) line
              end if
              read (line,*,err=77) i1
              if (ix1 .eq. 1 .and. i1 .eq. 0) go to 777
              if (maxvalchk .gt. 0 .and.
         -        (i1 .gt. maxval .or. i1 .lt. minval)) then
                write (6,1010) i1,minval,maxval
                go to 300
              end if
              list(ix1,lenpair)=i1
              ix1=ix1+1
              if (ix1 .eq. 3) then
                ix1=1
                lenpair=lenpair+1
              end if
              if (lenpair .eq. maxlen) then
                print *,'List truncated at the',maxlen,'-th element ',
         -       '- redimension Simulaid for longer list'
                go to 777
              end if
            end do
    77      print *,'Invalid input - ignored'
            go to 300
    777     len=lenpair-1
            go to 8
          end if
    999   write (6,1007) line
    998   list(1,len+1)=0
    8     if (listinp .ne. 5) close(listinp)
          if (len .lt. 100) write (6,1000) ((list(k,i),k=1,nlist),i=1,len)
          write (6,1009) len
          return
    1000  format(' The list read:',/,(10i8))
    1002  format(' Type 0 to finish the list',/,
         -  ' Type a number to be added to the list',/,
         -  ' Type R or r to be able to enter a range')
    1004  format(a)
    1005  format(' WARNING: Last number added to the list=',i6,
         -  ' (instead of ',i6,')')
    1006  format(' List file is a free-formatted list of sequence numbers',
         -  a,/,a)
    1007  format(' Premature end of the list file - last record read=',/,a)
    1008  format(' Next ',a,' (or 0 to finish): ',$)
    1009  format(' Finished reading',i6,' list items')
    1010  format(' ERROR: List element ',i8,' is outside the alllowed ',
         -  'range [',i6,',',i8,']')
    1011  format(' Hit return to input list interactively')
          end
          subroutine readfreelist(list,len,inp,isort,maxlen)
          dimension list(maxlen)
          character*80 line
          len=0
          ic=0
          lc=0
          iprev=0
          nerr=0
          do while (.true.)
            if (ic .ge. lc) then
              call blankout(line,1,80)
              read (inp,1000,end=999) line
              call lastchar(line,lc,80)
              if (lc .eq. 0) return
              ic=1
            end if
            call nextstring(line,ic,ic1,ic2,80)
            ic=ic2+1
            iok=0
            read (line(ic1:ic2),*,err=777) i
            iok=1
            len=len+1
            if (len .gt. maxlen) then
              write (6,1001) maxlen
              return
            end if
            if (isort .eq. 1) then
              if (len .eq. 1 .or. i .gt. iprev) then
                list(len)=i
              else
                write (6,1002) i,iprev
                len=len-1
              end if
              iprev=i
            else
              list(len)=i
            end if
    777     if (iok .eq. 0) then
              print *,'ERROR: Invalid list element:',line(ic1:ic2),
         -      ' ignored'
              nerr=nerr+1
              if (nerr .gt. 2*maxlen) then
                print *,'Too many invalid elements - stopping; iuinp=',inp
                stop
              end if
            end if
          end do
    999   return
    1000  format(a)
    1001  format(' ERROR: list length exceeds',i6,' - redimension Simulaid')
    1002  format(' ERROR: list element (',i6,') is not greater than the ',
         -  'previous value (',i6,')')
          end
          subroutine getclusterpairs(npairs,iclustermem,ifstclst1,ifstclst2,
         -  ilstclst2,nslt,idebug,maxpairs,maxclustermem)
          dimension iclustermem(maxclustermem),ifstclst1(maxpairs),
         -  ifstclst2(maxpairs),ilstclst2(maxpairs)
          character*39 pairprompt
          character*80 line
          character*200 outfiletmp
          listinp=55
          npairread=0
          namlenl=-1
          print *,
         -  '     Hit enter to input the cluster member list interactively'
          call openfile(listinp,1,'cluster member list',19,'old',outfiletmp,
         -  namlenl,notfnd,0,1,1,0,0)
          if (namlenl .eq. 0) then
            listinp=5
            if (npairread .eq. 0) write (6,1002)
          end if
          iread=0
          np1=-1
          do while (np1 .ne. 0)
    100     if (listinp .eq. 5) then
              write (pairprompt,1000) npairread+1,1
              call getint(pairprompt,39,0,1,maxclustermem,np1,0)
            else
              read (listinp,*,err=100,end=999) np1
            end if
            if (np1 .eq. 0) go to 999
    101     if (listinp .eq. 5) then
              call getname(line,lline,'Members (comma-separated):',26,80,
         -      '',0,1,0,0)
              read (line(1:lline),*,err=101,end=101)
         -     (iclustermem(iread+i),i=1,np1)
            else
              read (listinp,*,err=101,end=888)
         -      (iclustermem(iread+i),i=1,np1)
            end if
            ifstclst1(npairread+1)=iread+1
            iread=iread+np1
            ifstclst2(npairread+1)=iread+1
    102     if (listinp .eq. 5) then
              write (pairprompt,1000) npairread+1,2
              call getint(pairprompt,39,1,1,maxclustermem,np2,0)
            else
              read (listinp,*,err=102,end=999) np2
            end if
    103     if (listinp .eq. 5) then
              call getname(line,lline,'Members (comma-separated):',26,80,
         -      '',0,1,0,0)
              read (line(1:lline),*,err=103,end=103)
         -      (iclustermem(iread+i),i=1,np2)
            else
              read (listinp,*,err=103,end=888)
         -      (iclustermem(iread+i),i=1,np2)
            end if
            iread=iread+np2
            ilstclst2(npairread+1)=iread
            npairread=npairread+1
          end do
    999   do ip=1,npairread
            if (idebug .gt. 0) then
              write (6,1003) ip,1,ifstclst2(ip)-ifstclst1(ip),
         -      (iclustermem(i),i=ifstclst1(ip),ifstclst2(ip)-1)
              write (6,1003) ip,2,ifstclst2(ip)-ifstclst2(ip)+1,
         -      (iclustermem(i),i=ifstclst2(ip),ilstclst2(ip))
            end if
            do i=ifstclst1(ip),ifstclst2(ip)-1
              if (iclustermem(i) .lt. 1 .or.  iclustermem(i) .gt. nslt) then
                write (6,1004) ip,1,iclustermem(i),nslt
              end if
            end do
            do i=ifstclst2(ip),ilstclst2(ip)
              if (iclustermem(i) .lt. 1 .or.  iclustermem(i) .gt. nslt) then
                write (6,1004) ip,2,iclustermem(i),nslt
              end if
            end do
          end do
          npairs=npairread
          return
    888   print *,'ERROR: invalid list for cluster',ic12,
         -  ' pair #',npairread+1
          return
    1000  format('Pair ',i3,' number of members in cluster',i2)
    1002  format(' Type 0 to finish the list')
    1003  format(' Pair',i3,' cluster',i2,':',(10i5))
    1004  format(' ERROR: pair',i3,', cluster',i2,' member (',i6,
         -  ') is outside the',' range [1,',i6,']')
          end
          subroutine getnamelist(list,lench,nlist,label,lablen,maxlen)
          character*(*) list(maxlen),label
          character*80 line
          character*200 outfiletmp
          common /logging/ logfile,ipredict
          nlist=0
          line(1:3)='***'
          write (6,1004) lench
          do while (line(1:3) .ne. 'XYZ' .and. line(1:3) .ne. '   ')
            write (6,1000) label(1:lablen),nlist+1
            call blankout(line,1,80)
            read (5,1001) line
            call lastchar(line,iclast,80)
            if (logfile .gt. 0) write (logfile,1001) line(1:iclast)
            if (line(1:4) .eq. 'READ') then
              listinp=55
              namlenl=-1
              call openfile(listinp,1,'name list',9,'old',outfiletmp,
         -      namlenl,notfnd,0,1,1,0,0)
              do while (.true.)
                call blankout(line,1,80)
                read (listinp,1001,end=99) line
                if (line(1:3) .eq. 'XYZ') go to 99
                call lastchar(line,iclast,80)
                if (iclast .gt. lench) write (6,1002) lench
                nlist=nlist+1
                call blankout(list(nlist),1,lench)
                list(nlist)(1:iclast)=line(1:iclast)
              end do
    99        close (listinp)
              line(1:3)='XYZ'
            else
              if (iclast .gt. lench) write (6,1002) lench
            end if
            if (line(1:3) .ne. 'XYZ') then
              if (nlist .eq. maxlen) then
                write (6,1003) maxlen
                call askstop(0)
                return
              else
                nlist=nlist+1
                call blankout(list(nlist),1,lench)
                list(nlist)(1:iclast)=line(1:iclast)
              end if
            end if
          end do
          write (6,5655) (label(1:lablen),i,list(i)(1:lench),i=1,nlist)
    5655  format(1x,a,' #',i4,':',a)
          return
    1000  format(1x,a,' #',i3,' (XYZ or enter to end list)=',$)
    1001  format(a)
    1002  format(' WARNING: Only the first ',i2,' characters will be used')
    1003  format(' WARNING: maximum number of list elements (',i4,') has ',
         -  'been reached - input stops')
    1004  format(' Type READ as the residue name to read a list from a ',
         -  'file',/,' Names are of maximum ',i2,' characters')
          end
          subroutine listformat(ityp)
          character*11 formatname
          common /formats/ iqdconv(20),formatname(19)
          common /columnlim/ incol(19),iidcol(19),iialtcol(19),iiinscol(19),
         -  iinamcol(2,19),iirescol(2,19),iiccol(2,19),iiresncol(2,19),
         -  iiseqncol(2,19),iisegcol(2,19),iiresidcol(2,19),iiqcol(2,19),
         -  iipotcol(2,19),iiocccol(2,19),iichemcol(2,19)
          character*1 ans
          if (ityp .eq. 0) then
            call quiz(ans,ians,'d',' ',0,'file format',11,0,5,6,0)
            it=iqdconv(ians)
          else
            it=ityp
          end if
          write (6,1000) formatname(it)
          write (6,1002) incol(it)
          if (iinamcol(2,it) .ge. iinamcol(1,it))
         -   write (6,1001) 'atom name:           ',(iinamcol(k,it),k=1,2)
          if (iirescol(2,it) .ge. iirescol(1,it))
         -   write (6,1001) 'residue name:        ',(iirescol(k,it),k=1,2)
          if (iiseqncol(2,it) .ge. iiseqncol(1,it))
         -   write (6,1001) 'atom number:         ',(iiseqncol(k,it),k=1,2)
          if (iiresncol(2,it) .ge. iiresncol(1,it))
         -   write (6,1001) 'residue number:      ',(iiresncol(k,it),k=1,2)
          if (iisegcol(2,it) .ge. iisegcol(1,it))
         -   write (6,1001) 'segment (chain) ID:  ',(iisegcol(k,it),k=1,2)
          if (iiresidcol(2,it) .ge. iiresidcol(1,it))
         -   write (6,1001) 'residue ID (Charmm): ',(iiresidcol(k,it),k=1,2)
          if (iiccol(2,it) .ge. iiccol(1,it))
         -   write (6,1001) 'X,Y,Z coordinates:   ',(iiccol(k,it),k=1,2)
          if (iiqcol(2,it) .ge. iiqcol(1,it))
         -   write (6,1001) 'atomic charges:      ',(iiqcol(k,it),k=1,2)
          if (iipotcol(2,it) .ge. iipotcol(1,it))
         -   write (6,1001) 'potential identifier:',(iipotcol(k,it),k=1,2)
          if (iichemcol(2,it) .ge. iichemcol(1,it))
         -   write (6,1001) 'Chemical element:    ',(iichemcol(k,it),k=1,2)
          if (iialtcol(it) .gt. 0) write (6,1003) iialtcol(it)
          if (iiinscol(it) .gt. 0) write (6,1005) iiinscol(it)
          if (iidcol(it) .gt. 0) write (6,1004) iidcol(it)
          return
    1000  format(' Record format specification for ',a,' input')
    1001  format(' Column range for ',a,i3,' - ',i3)
    1002  format(' Number of characters in a record:',11x,i3)
    1003  format(' Alternate marker column:',20x,i3)
    1004  format(' Deletion  marker column:',20x,i3)
    1005  format(' Insertion marker column:',20x,i3)
          end
          subroutine getcrdtyp(inpt,filex,lenfile,ifiltyp,ixcluster,
         -  inoutlab,linoutlab)
          character*(*) filex
          character*5 crdext
          character*(*) inoutlab
          common /iotypes/ iocha,iochaex,iobpdb,iocpdb,ioa3pdb,ioa4pdb,
         -  iommod,iommc,iommc4,iogro,iomol2,iomae,iocif,ioxxx,ioins,
         -  ionxyz,iosxyz,iosxyzrq,iograsp,iofull,lext(19),crdext(19)
          character*11 formatname
          common /formats/ iqdconv(20),formatname(19)
          character*1 ans
          character*5 ext
          character*132 line
          ifiltyp=0
          lenext=lenfile
          if (lenext .ge. 5) then
            ic=lenext
            do while (filex(ic:ic) .ne. '.' .and. ic .gt. max0(1,lenext-6))
              ic=ic-1
            end do
            lenext=lenext-ic
            if (lenext .le. 5) ext(1:lenext)=filex(ic+1:ic+lenext)
          else
            ext(1:lenext)=filex(1:lenext)
          end if
          if (ext(1:3) .ne. 'dat' .and. lenext .le. 5) then
            do it=1,ioins
              if (crdext(it)(1:lenext) .eq. ext(1:lenext) .and.
         -        lext(it) .eq. lenext) ifiltyp=it
            end do
          end if
          if (ext(1:5) .eq. 'pdbqs') then
            ifiltyp=ioa3pdb
          else if (ext(1:5) .eq. 'pdbqt') then
            ifiltyp=ioa4pdb
          else if (lenext .eq. 3 .and. (ext(1:3) .eq. 'pdb' .or.
         -    ext(1:3) .eq. 'PDB' .or. ext(1:3) .eq. 'ent')) then
            write (6,2000) inoutlab(1:linoutlab),'PDB'
            if (inpt .gt. 0) then
              line(1:4)='    '
              do while (line(1:4) .ne. 'ATOM' .and. line(1:6) .ne. 'HETATM')
                read (inpt,1000,end=999) line
              end do
              rewind inpt
              ifiltyp=0
              if (line(22:22) .eq. ' ' .and. line(73:76) .ne. '    ') then
                write (6,2001) 'PDB','Charmm'
                ifiltyp=iocpdb
              else if (line(22:22) .ne. ' ' .and.
         -             line(73:76) .eq. '    ') then
                write (6,2001) 'PDB','Brookhaven'
                ifiltyp=iobpdb
              end if
              ians=0
              if (ifiltyp .gt. 0) call askyn('Is that OK',10,1,1,ians,00,0)
              if (ians .eq. 0) then
                call quiz(ans,ians,'b',' ',0,'PDB file type',13,0,5,6,0)
                if (ans .eq. 'b') ifiltyp=iobpdb
                if (ans .eq. 'c') ifiltyp=iocpdb
              end if
            else
              ifiltyp=iobpdb
              write (6,2003) 'Brookhaven'
            end if
          else if (ext(1:3) .eq. 'CRD') then
            write (6,2000) inoutlab(1:linoutlab),'Charmm CRD'
            if (inoutlab(1:linoutlab) .ne. 'output') then
              line (1:1)='*'
              do while (line(1:1) .eq. '*')
                read (inpt,1000,end=999) line
              end do
              read (inpt,1000) line
              call blankout(line,1,132)
              read (inpt,1000) line
              call lastchar(line,lc,132)
              rewind inpt
              if (lc .gt. 80) then
                write (6,2001) 'Charmm','extended'
                ifiltyp=iocha
              else
                write (6,2001) 'Charmm','standdard'
                ifiltyp=iochaex
              end if
              call askyn('Is that OK',10,1,1,ians,00,0)
            else
              ians=0
            end if
            if (ians .eq. 0) then
              call quiz(ans,ians,'o',' ',0,'Charmm CRD file type',20,0,5,6,
         -      0)
              if (ans .eq. 'o') ifiltyp=iocha
              if (ans .eq. 'e') ifiltyp=iochaex
            end if
          else if (ext(1:3) .eq. 'slt') then
            ifiltyp=iommc
            call askyn('Is the .slt file in the old format',34,1,-1,is4,134,
         -    0)
            if (is4 .eq. 1) ifiltyp=iommc4
          else if (ext(1:3) .eq. 'rep') then
            write (6,2000) inoutlab(1:linoutlab),'Macromodel/Xcluster'
            ifiltyp=iommod
            ixcluster=1
          end if
          if (ifiltyp .ne. 0) then
            write (6,2000) inoutlab(1:linoutlab),formatname(ifiltyp)
          else
    100     call quiz(ans,ians,' ',inoutlab,linoutlab,'file format',11,0,5,
         -    6,0)
            ifiltyp=iqdconv(ians)
            if (ans .eq. 'x') then
              ifiltyp=iommod
              ixcluster=1
            end if
            if (ifiltyp .eq. 0) then
              print *,'PROGRAM ERROR: invalid answer character'
              go to 100
            end if
          end if
          return
    999   write (6,2002) filex(1:max0(1,lenfile))
          stop
    1000  format(a)
    2000  format(' The ',a,' format is established as ',a)
    2001  format(' The ',a,' format is found to be ',a)
    2002  format(' ERROR: input file ',a,' does not have coordinate ',
         -  'records')
    2003  format(' New file - ',a,' PDB selected')
          end
          subroutine strip_cext(analfile,namleni,namleno,lenext)
          character*(*) analfile
          character*4 extinp
          character*6 extinp6
          namleno=namleni
          extinp=analfile(namleno-3:namleno)
          if (extinp .eq. '.pdb' .or. extinp .eq. '.PDB' .or.
         -    extinp .eq. '.crd' .or. extinp .eq. '.CRD' .or.
         -    extinp .eq. '.dat' .or. extinp .eq. '.DAT' .or.
         -    extinp .eq. '.mae' .or. extinp .eq. '.flt' .or.
         -    extinp .eq. '.slt') then
            lenext=4
          else if (extinp .eq. 'mol2') then
            lenext=5
          else
            extinp6=analfile(namleno-5:namleno)
            if (extinp6 .eq. '.pdbqs' .or. extinp6 .eq. '.PDBQS' .or.
         -      extinp6 .eq. '.pdbqt' .or. extinp6 .eq. '.PDBQT')
         -    lenext=6
          end if
          namleno=namleno-lenext
          return
          end
          subroutine asktrajform(inptrajtyp,ioutrajtyp,mmctrajtyp,
         -  resnamslv,inout,iasktrajtyp)
          character*8 resnamslv
          character*5 crdext
          common /iotypes/ iocha,iochaex,iobpdb,iocpdb,ioa3pdb,ioa4pdb,
         -  iommod,iommc,iommc4,iogro,iomol2,iomae,iocif,ioxxx,ioins,
         -  ionxyz,iosxyz,iosxyzrq,iograsp,iofull,lext(19),crdext(19)
          character*8 resnamsv
          common /names/ resnamsv(19)
          character*1 ansfrm
          character*6 inoutlab
          data itrajtyp /0/
          mmctrajtyp=0
          if (iasktrajtyp .eq. 1) then
            inoutlab='output'
            if (inout .eq. -1) inoutlab=' input'
            call quiz(ansfrm,ians,' ',inoutlab,6,'trajectory file format',
         -    22,0,5,6,0)
            if (ansfrm .eq. 'c') then
              itrajtyp=1
            else if (ansfrm .eq. 'a') then
              itrajtyp=2
            else if (ansfrm .eq. 'l') then
              itrajtyp=3
            else if (ansfrm .eq. 'o') then
              itrajtyp=4
            else if (ansfrm .eq. 'x') then
              itrajtyp=5
            else if (ansfrm .eq. 'd') then
              itrajtyp=6
              print *,'Amber CDF trajectory input is not yet implemented'
              print *,'The Linux version of VMD can convert it to old Amber'
              stop
            end if
            if (inout .eq. +1) then
              ioutrajtyp=itrajtyp
            else
              inptrajtyp=itrajtyp
            end if
          end if
          if (itrajtyp .eq. 3 .or. iasktrajtyp .eq. 0) then
            call quiz(ansfrm,ians,' ',' ',0,'MMC trajectory file format',26,
         -    0,5,6,0)
            if (ansfrm .eq. 'b') then
              mmctrajtyp=1
            else if (ansfrm .eq. 'a') then
                mmctrajtyp=2
            else if (ansfrm .eq. 'n') then
              mmctrajtyp=3
            else if (ansfrm .eq. 'p') then
              mmctrajtyp=4
              resnamslv=resnamsv(iobpdb)
            else if (ansfrm .eq. 'c') then
              mmctrajtyp=5
              resnamslv=resnamsv(iocha)
            end if
          end if
          return
          end
          subroutine writeconf(iout,inpcrdtyp,iotyp,inpcrdtyporg,n0,n,nslt,
         -  naslv,islvw,iasv,namesv,qsv,pflsv,icreaterec,iwhead,imodel,
         -  iatnum,ifchrg,nconfig,innlist,c,rprox,cv,ixres,iresno,atnames,
         -  resnames,segnames,charge,isegno,altcol,inscol,ninsres,marker,
         -  ntitlin,ntitlinw,title,ireseq,iresnrestart,iresidrestart,nneig,
         -  nneiga,nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,numres,
         -  numslv,resnamslv,line,blankline,mmtype,ibnd,index,indexn,indexo,
         -  iclean,molresflag,idupl,ihetat,hblimfac,angmin,noleftad,nosort,
         -  noreg,iusecvforq,nobondord,nqdec,iqspaceask,ianaltyp,ifromtraj,
         -  etot,ietot,nclstmem,noend,keeprem,iwriteatsym,radtodeg,
         -  maxrepconf,maxng,maxrsd,maxrec)
          character* 132 line(maxrec),blankline
          character*80 title
          character*1 altcol(maxrec),inscol(maxrec)
          character*4 segnames(maxrsd),pflsv(100)
          character*8 atnames(maxrec),resnames(maxrsd),namesv(100)
          character*6 marker(16)
          dimension nneig(maxrec),ineig(maxng,maxrec),iatnum(maxrec),
         -  ifchrg(maxrec),c(3,maxrec),cv(maxrec),ixres(maxrec),
         -  rprox(maxrec),charge(maxrec),nhbneig(maxrec),nneiga(maxrec),
         -  nhneig(maxrec),nnneig(maxrec),ncneig(maxrec),nsneig(maxrec),
         -  npneig(maxrec),isegno(maxrec),iresno(maxrec),mmtype(maxrec),
         -  ibnd(maxng,maxrec),index(maxrec),indexn(maxrec),indexo(maxrec),
         -  molresflag(maxrsd),idupl(maxrsd),ihetat(maxrec),iasv(100),
         -  qsv(100)
          common /columnlim/ incol(19),iidcol(19),iialtcol(19),iiinscol(19),
         -  iinamcol(2,19),iirescol(2,19),iiccol(2,19),iiresncol(2,19),
         -  iiseqncol(2,19),iisegcol(2,19),iiresidcol(2,19),iiqcol(2,19),
         -  iipotcol(2,19),iiocccol(2,19),iichemcol(2,19)
          character*11 formatname
          common /formats/ iqdconv(20),formatname(19)
          character*5 crdext
          common /iotypes/ iocha,iochaex,iobpdb,iocpdb,ioa3pdb,ioa4pdb,
         -  iommod,iommc,iommc4,iogro,iomol2,iomae,iocif,ioxxx,ioins,
         -  ionxyz,iosxyz,iosxyzrq,iograsp,iofull,lext(19),crdext(19)
          character*2 iatnm2
          common /atnam/ aw(99),nval(99),nvalmax(99),mmofan(99),mmatno(64),
         -  iatnm2(99)
          character*1 abc,digits,hexdigits
          common /charactersets/ ihex(25),abc(62),digits(14),hexdigits(25)
          common /logging/ logfile,ipredict
          character*2 mmcgm
          character*4 segnam,chnam,xseg
          character*6 potnam
          character*8 resnam,resnamslv,atomnam
          character*8 segnamlong
          character*31 question
          dimension iabc(62),cw(3)
          data xseg /'XXXX'/
          mmcgm='  '
          call set_pdbinfo(iotyp,iwriteatsym,iwritecon,iobpdb,iocpdb,0)
          call setcol(inpcrdtyp,ncol,idcol,ialtcol,iinscol,
         -  inamcol1,inamcol2,irescol1,irescol2,iccol1,iccol2,
         -  iresncol1,iresncol2,iseqncol1,iseqncol2,isegcol1,isegcol2,
         -  iresidcol1,iresidcol2,iqcol1,iqcol2,ipotcol1,ipotcol2,
         -  iocccol1,iocccol2,ichemcol1,ichemcol2,nrescol,nresncol,
         -  nsegcol,nnamcol,iofull)
          frocc=1.0
          if (iotyp .eq. iommod .and. nobondord .eq. 0) then
            call nnlist(nslt,islvw,naslv,n,iatnum,ifchrg,c,nneig,nneiga,
         -    nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,line,
         -    irescol1,irescol2,inamcol1,inamcol2,index,nconfig,innlist,
         -    molresflag,hblimfac,angmin,0,ibnd,indexo,isegno,ixres,
         -    maxrepconf,0,0,radtodeg,0,maxng,maxng,maxrsd,maxrec)
            call bondord(iatnum,mmtype,n,nneig,ineig,nhneig,ibnd,maxng,c,
         -    index,ncneig,nsneig,inamcol1,inamcol2,irescol1,irescol2,line,
         -    nconfig,maxrepconf,maxrec)
          end if
          if (inpcrdtyp .le. ioins .and. isegcol2 .ge. isegcol1) then
            nsegm=isegno(n)
            segnames(1)='    '
            call getseg4(segnames(1),line(index(1)),isegcol1,nsegcol)
            nsegcolin=isegcol2-isegcol1+1
            nsegcolout=iisegcol(2,iotyp)-iisegcol(1,iotyp)+1
            isegnoprev=0
            do ia=1,min0(n0,n)
              if (isegno(ia) .ne. isegnoprev) then
                segnam='    '
                call getseg4(segnam,line(index(ia)),isegcol1,nsegcol)
                call leftadjust4(segnam,segnam)
                if (nsegcolout .lt. nsegcolin) then
                  call lastchar(segnam,lc,4)
                  if (lc .gt. 1 .or. nsegcolout .gt. 1) then
                    question='New name of segment #'
                    write (question(22:24),1005) isegno(ia)
                    lq=27+lc
                    question(25:lq)=' ('//segnam(1:lc)//')'
                    lc=min0(lc,nsegcolout)
                    if (lc .eq. 1) segnam(1:1)=abc(isegno(ia))
                    call getname(segnam,len,question,lq,4,segnam(1:lc),lc,0,
         -            0,0)
                  end if
                end if
                segnames(isegno(ia)-isegno(1)+1)=segnam
                isegnoprev=isegno(ia)
              end if
            end do
            if (n .gt. n0) then
              incsg=0
              if (n0 .eq. nslt) then
                segnames(isegno(n0)-isegno(1)+1)=xseg(1:min0(4,nsegcol))
                incsg=1
              end if
              do ia=n0+1,n
                isegno(ia)=isegno(n0)+incsg
              end do
            end if
            if (ischarmm(iotyp) .eq. 1 .or. iotyp .eq. iocpdb) then
              do is=1,nsegm
                segnam=segnames(is)
                if (nconfig .gt. 1) then
    CHX
                  do ic=1,4
                    if (segnam(ic:ic) .eq. ' ') then
                      nslen=ic-1
                      go to 100
                    end if
                  end do
                  go to 101
    100           write (segnamlong,1008) nconfig
                  call leftadjustn(segnamlong,segnamlong,8)
                  call nextchar(segnamlong,ic,8)
                  nnlen=min0(4-nslen,8-ic+1)
                  segnam(nslen+1:nslen+nnlen)=segnamlong(ic:ic+nnlen-1)
    101           continue
                else if (nsegcol .eq. 1) then
                  segnam(2:4)='CHR'
                end if
                segnames(is)=segnam
              end do
            else if (iotyp .eq. iobpdb .and. nsegcol .gt. 1) then
              call zeroiti(iabc,0,62)
              ndupl=0
              do is=1,nsegm
                do iss=1,62
                  if (segnames(is)(1:1) .eq. abc(iss)) then
                    if (iabc(iss) .eq. 0) then
                      iabc(iss)=is
                    else
                      ndupl=ndupl+1
                      idupl(ndupl)=is
                    end if
                    go to 200
                  end if
                end do
                if (segnames(is)(1:1) .eq. ' ') then
                  ndupl=ndupl+1
                  idupl(ndupl)=is
                else
                  print *,'Invalid chain id character:',segnames(is)(1:1)
                  segnames(is)(1:1)=' '
                end if
    200         continue
              end do
              if (ndupl .gt. 0) then
                ifree0=0
                do id=1,ndupl
                  do is=ifree0+1,62
                    if (iabc(is) .eq. 0) then
                      ifree0=is
                      segnames(idupl(id))=abc(is)
                      go to 201
                    end if
                  end do
                end do
                ifree0=62
                print *,'More than 62 different segments exist - all the ',
         -        'remainings will be called Z'
    201         continue
              end if
            end if
          else
            do is=isegno(1),isegno(n)
              segnames(is)(1:1)=abc(min0(62,is))
              segnames(is)(2:4)='   '
            end do
          end if
          segnam='A   '
          resnam='RES     '
          atomnam='        '
          potnam='      '
          chnam='    '
          q=0.0
          icinc=0
          call zeroiti(ihetat,0,n)
          do iat=1,n
            if (line(index(iat))(1:6) .eq. 'HETATM') ihetat(iat)=1
          end do
          do iat=1,n
            if (inpcrdtyp .le. ioins .and. iat .le. n0) then
              if (isegcol2 .ge. isegcol1)
         -      segnam=segnames(isegno(iat)-isegno(1)+1)
              resnam(1:nrescol)=resnames(ixres(iat))(1:nrescol)
              call leftadjustn(resnam,resnam,8)
              ic1=iresncol1
              call nextchar(line(index(iat)),ic1,132)
              ic2=ic1
              call nextblank(line(index(iat)),ic2,132)
              ic2=min0(iresncol2+1,ic2)
              if (ic2 .lt. ic1) then
                write (6,1000) iat
                ires=0
              else
                ires=iresno(iat)
              end if
              atomnam(1:nnamcol)=atnames(iat)(1:nnamcol)
              if (iotyp .eq. iommod) then
                   write (potnam(1:4),1006) mmtype(iat)
              else if (ipotcol2 .ge. ipotcol1) then
                 potnam(1:ipotcol2-ipotcol1+1)=
         -         line(index(iat))(ipotcol1:ipotcol2)
              end if
              if (iqcol2 .ge. iqcol1) q=charge(iat)
              if (iat .eq. 999999 .and. inpcrdtyp .eq. iocha) icinc=1
            else if (inpcrdtyp .le. ioins .and. iat .gt. n0) then
              resnam=resnamslv
              iatslv=mod(iat-n0-1,naslv)+1
              iatnum(iat)=iasv(iatslv)
              charge(iat)=qsv(iatslv)
              q=qsv(iatslv)
              if (inpcrdtyp .eq. ioins .or. inpcrdtyp .eq. iommc)
         -      potnam(1:4)=pflsv(iatslv)
              atomnam=namesv(iatslv)
              ires=iresno(n0)+(iat-n0-1)/naslv+1
              iresno(iat)=ires
            else
              atomnam(1:2)=iatnm2(iatnum(iat))
              if (inpcrdtyp .eq. iosxyzrq) then
                ires=iresno(iat)
                q=charge(iat)
              end if
            end if
            if (iusecvforq .eq. 1) then
              q=cv(iat)
              frocc=rprox(iat)
            end if
            if (inpcrdtyp .eq. iocif) then
              read (line(index(iat))(iocccol1:iocccol2),*) frocc
              read (line(index(iat))(iqcol1:iqcol2),*) q
            end if
            chnam(1:2)=iatnm2(iatnum(iat))
            if (icreaterec .eq. 1) then
              irec=ntitlin+iat
              if (inpcrdtyp .eq. iotyp .and. iotyp .eq. iommc)
         -      mmcgm=line(index(iat))(51:52)
              line(irec)=blankline
              iqspace=1
              if (q .ge. 1000.0) then
                if (iqspaceask .eq. 1) then
                  print *,'B-factor column entry > 1000 found'
                  if (ipredict .eq. 0) then
                    call askyn('Do you want to use all 6 characters',35,0,
         -            -1,iqspace,124,0)
                  else
                    print *,'All 6 characters will be used'
                    iqspace=0
                  end if
                  iqspaceask=0
                end if
              end if
              if (iotyp .le. ioins) then
                call trnsfr(cw,c(1,iat),3)
                if (inpcrdtyp .eq. iogro .and. iotyp .ne. iogro) then
                  do k=1,3
                    cw(k)=c(k,iat)*10.0
                  end do
                else if (iotyp .eq. iogro) then
                  do k=1,3
                    cw(k)=c(k,iat)*0.1
                  end do
                end if
                if (inpcrdtyp .eq. iomae) then
                  segnam(1:1)=abc(min0(62,isegno(iat)))
                  segnam(2:4)='   '
                end if
                call createrec(line(irec),inpcrdtyp,iotyp,cw(1),cw(2),cw(3),
         -        altcol(iat),inscol(iat),atomnam,resnam,segnam,iat,ires,
         -        ires,chnam,potnam,frocc,q,nqdec,iqspace,mmcgm,nneig(iat),
         -        ineig(1,iat),nconfig,ibnd(1,iat),ihetat(iat),blankline)
              else
                call writefree(line(irec),iotyp,chnam,c(1,iat),c(2,iat),
         -        c(3,iat),ires,q)
              end if
              index(iat)=irec
            end if
            if (iotyp .eq. iogro) then
              call leftadjustline(line(index(iat)),iirescol(1,iotyp),
         -      iirescol(2,iotyp))
              call rightadjustline(line(index(iat)),
         -      iinamcol(1,iotyp),iinamcol(2,iotyp))
            else
              call leftadjustline(line(index(iat)),iirescol(1,iotyp),
         -      iirescol(2,iotyp))
              if ((ispdb(iotyp) .eq. 0 .or. inpcrdtyp .eq. iogro) .and.
         -         noleftad .eq. 0)
         -      call leftadjustline(line(index(iat)),
         -        iinamcol(1,iotyp),iinamcol(2,iotyp))
            end if
            if (iotyp .eq. ioins) call leftadjustline(line(index(iat)),
         -    iiresncol(1,iotyp),iiresncol(2,iotyp))
            if (ispdb(iotyp) .gt. 0 .and. noreg .eq. 0) call regularpdb(
         -    line(index(iat))(iinamcol(1,iotyp):iinamcol(2,iotyp)),
         -    line(index(iat))(iinamcol(1,iotyp):iinamcol(2,iotyp)),1)
          end do
          if (iclean .eq. 1) then
            if (iotyp .lt. ioins .and. nosort .eq. 0)
         -    call sortatres(line,n,index,indexn,indexo,nhbneig,nneiga,
         -    ncneig,nsneig,npneig,iiresncol(1,iotyp),iiresncol(2,iotyp),
         -    isegno,'      ',iotyp,nconfig,iout,maxrepconf,maxrec)
            if ((ischarmm(iotyp) .eq. 1 .or. ispdb(iotyp) .gt. 0 .or.
         -       iotyp .eq. iommod .or. iotyp .eq. iommc) .and.
         -       nosort .eq. 0)
         -    call reseq(line,index,n,nslt,nsegm,iatfirst,iresfirst,
         -      iresidfirst,iotyp,iresno,resnames,numres,numslv,naslv,
         -      ninsres,resnamslv,iresnrestart,iresidrestart,nconfig,ireseq,
         -      +1,maxrsd,maxrec)
          end if
          imodelnum=imodel
          if (imodel .gt. 0) imodelnum=nconfig
          call writeout(iout,inpcrdtyporg,iotyp,line,index,isegno,n,marker,
         -  iwhead,imodelnum,ntitlin,ntitlinw,title,blankline,nosort,
         -  ianaltyp,ifromtraj,etot,ietot,nclstmem,noend,keeprem,
         -  iwriteatsym,iatnum,maxrec)
          return
    1000  format(' Atom ',i6,' has no residue number - it is set to zero')
    1005  format(i3)
    1006  format(i4)
    1008  format(i8)
          end
          subroutine writeout(iout,inpcrdtyp,iotyp,line,index,isegno,n,
         -  marker,iwhead,imodelnum,ntitlin,ntitlinw,title,
         -  blankline,nosort,ianaltyp,ifromtraj,etot,ietot,nclstmem,noend,
         -  keeprem,iwriteatsym,iatnum,maxrec)
          dimension index(n),isegno(n),iatnum(n)
          character*6 marker(16)
          character*80 title,linew
          character* 132 line(maxrec),blankline,ansline,pline
          character*5 crdext
          common /iotypes/ iocha,iochaex,iobpdb,iocpdb,ioa3pdb,ioa4pdb,
         -  iommod,iommc,iommc4,iogro,iomol2,iomae,iocif,ioxxx,ioins,
         -  ionxyz,iosxyz,iosxyzrq,iograsp,iofull,lext(19),crdext(19)
          common /logging/ logfile,ipredict
          character*11 formatname
          common /formats/ iqdconv(20),formatname(19)
          common /columnlim/ incol(19),iidcol(19),iialtcol(19),iiinscol(19),
         -  iinamcol(2,19),iirescol(2,19),iiccol(2,19),iiresncol(2,19),
         -  iiseqncol(2,19),iisegcol(2,19),iiresidcol(2,19),iiqcol(2,19),
         -  iipotcol(2,19),iiocccol(2,19),iichemcol(2,19)
          real*8 xtlabc,xtlabc0
          common /boxdat/ xtlabc(6),xtlabc0(6),box(3),box0(3),edge_gen(3,3),
         -  cell0(3,27),cell(3,27),cellalt(3,27),
         -  ncell,ioppbc,noboxinfoar,noboxinfow,noboxrep,
         -  istuner,iboxtypfound,ixcrd(3),ixang(3),ixyzhex(3),
         -  ixyzhextraj(3),isizewarn
          common /analparm/ nsltref_f,nsltref_l,rcut_cv,icvtyp
          nline_add=0
          pline=blankline
          pline(1:6)=marker(iotyp)
          modelfound=0
          if (iwhead .eq. 1) then
            if (marker(iotyp) .ne. '      ') then
              if (ispdb(iotyp) .gt. 0 .or. ischarmm(iotyp) .eq. 1) then
                if (inpcrdtyp .eq. iommod) then
                  icol=60
                  call nextblank(line(1),icol,132)
                  pline(8:icol+1)=line(1)(7:icol)
                  call writeline(iout,pline,1,icol+1,0)
                  pline(icol+2:132)=blankline(icol+2:132)
                  icol=icol-50
                  call nextchar(line(1)(51:130),icol,132)
                  call lastchar(line(1),ifc,130)
                  if (icol .lt. 80) then
                    pline(8:ifc-(icol+50)+8)=line(1)(icol+50:ifc)
                    call writeline(iout,pline,1,ifc-(icol+50)+8,0)
                  end if
                else
                  if (ispdb(inpcrdtyp) .gt. 0) then
                    mncl=7
                    mxcl=79
                  else
                    mncl=2
                    mxcl=74
                  end if
                  ilw=ntitlinw
                  if (ntitlin .eq. 0) then
                    call blankout(linew,1,80)
                    if (ischarmm(iotyp) .eq. 1) then
                      write (linew,1000) marker(iotyp)
                    else
                      write (linew,1000) 'TITLE'
                    end if
                    call lastchar(linew,lc0,80)
                    call lastchar(title,lct,80)
                    ltitle=min0(lct,80-lc0-1)
                    lc=lc0+ltitle+1
                    linew(1:lc)=linew(1:lc0)//' '//title(1:ltitle)
                    write (iout,1000) linew(1:lc)
                    nline_add=1
                  end if
                  do i=1,ntitlin
                    if (line(i)(1:5) .eq. 'MODEL') modelfound=1
                    if (ischarmm(iotyp) .eq. 1 .and. i .le. ntitlin) then
                      if (ianaltyp .eq. 13 .or. ianaltyp .eq. 20 .or.
         -                ianaltyp .eq. 22) then
                        nline_add=1
                      else if (ianaltyp .eq. 14) then
                        nline_add=3
                      else
                        nline_add=0
                      end if
                      if (i .eq. 1 .and. (ietot .eq. 1 .or. nclstmem .gt. 0
         -                .or. ifromtraj .gt. 0)) then
                        nline_add=nline_add+1
                        call blankout(linew,1,80)
                        write (linew,1000) marker(iotyp)
                        call lastchar(linew,lc,80)
                        if (ietot .eq. 1) then
                          write (linew,2034) '*',etot
                          call lastchar(linew,lc,80)
                        end if
                        if (nclstmem .gt. 0) then
                          write (linew(lc+1:lc+16),2036) nclstmem
                          lc=lc+16
                        end if
                        if (ifromtraj .gt. 0) then
                          write (linew(lc+1:lc+16),2037) ifromtraj
                          lc=lc+16
                        end if
                        write (iout,1000) linew(1:lc)
                      end if
                      if (ilw .lt. 30-nline_add) then
                        ietotread=0
                        if (ifromtraj .gt. 0) call checkforetot(1,line(i),
         -                0,etotread,ietotread,0)
                        if (ietotread .eq. 1) nline_add=nline_add-1
                        if (ietotread .eq. 0) then
                          icol=mncl
                          call nextchar(line(i),icol,132)
                          call lastchar(line(i),ifc,mxcl)
                          if (icol .le. mxcl) then
                            ilw=ilw+1
                            pline(8:ifc-icol+8)=line(i)(icol:ifc)
                            call writeline(iout,pline,1,ifc-icol+8,0)
                          end if
                        end if
                      end if
                    else
                      if (i .eq. 1 .and. (ietot .eq. 1 .or. nclstmem .gt. 0
         -                .or. ifromtraj .gt. 0)) then
                        nline_add=nline_add+1
                        call blankout(linew,1,80)
                        write (linew,1000) marker(iotyp)
                        call lastchar(linew,lc,80)
                        if (ietot .eq. 1) then
                          write (linew(lc+1:lc+19),2034) etot
                          lc=lc+19
                        end if
                        if (nclstmem .gt. 0) then
                          write (linew(lc+1:lc+16),2036) nclstmem
                          lc=lc+16
                        end if
                        if (ifromtraj .gt. 0) then
                          write (linew(lc+1:lc+16),2037) ifromtraj
                          lc=lc+16
                        end if
                        write (iout,1000) linew(1:lc)
                      end if
                      call lastchar(line(i),ifc,mxcl)
                      ietotread=0
                      if (ifromtraj .gt. 0)
         -              call checkforetot(6,line(i),0,etotread,ietotread,0)
                      if (ietotread .eq. 0) then
                        if (mncl .eq. 7) then
                          call writeline(iout,line(i),1,ifc,0)
                        else
                          pline(8:ifc-mncl+8)=line(i)(mncl:ifc)
                          call writeline(iout,pline,1,ifc-mncl+8,0)
                        end if
                      end if
                    end if
                    pline(8:132)=blankline(8:132)
                  end do
                  pline=blankline
                  if (ianaltyp .eq. 13) then
                    write (iout,2031) marker(iotyp),'hydropathy label'
                  else if (ianaltyp .eq. 14) then
                    if (icvtyp .eq. 1) then
                      write (iout,2031) marker(iotyp),'Circular variance'
                    else
                      write (iout,2031) marker(iotyp),
         -              'weighted circular variance'
                    end if
                    write (pline,2032) marker(iotyp),rcut_cv
                    call writeline(iout,pline,1,0,0)
                    write (pline,2033) marker(iotyp),nsltref_f,nsltref_l
                    call writeline(iout,pline,1,0,0)
                  else if (ianaltyp .eq. 20) then
                    write (iout,2031) marker(iotyp),
         -            'Delphi potential label'
                  else if (ianaltyp .eq. 22) then
                    write (iout,2031) marker(iotyp),
         -            'residue Root Mean Square Fluctuation (RMSF)'
                  else if (ianaltyp .eq. 37) then
                    write (iout,2031) marker(iotyp),
         -            'residue distance difference average'
                  else if (ianaltyp .eq. 38) then
                    write (iout,2031) marker(iotyp),
         -          'residue Root Mean Square Fluctuation (RMSF) difference'
                  else if (ianaltyp .eq. 91) then
                    write (iout,2035) marker(iotyp),'representative-based'
                  else if (ianaltyp .eq. 92) then
                    write (iout,2035) marker(iotyp),
         -             'closest approach-based'
                  else if (ianaltyp .eq. 93) then
                    write (iout,2035) marker(iotyp),'mutually proximal'
                  else if (ianaltyp .eq. 94) then
                    write (iout,2035) marker(iotyp),'sum of all'
                  end if
                end if
                if (noboxinfoar .eq. 0) then
                  write (iout,2030) marker(iotyp),box
                end if
              else if (iotyp .eq. ioins) then
                write (iout,2062)
                if (inpcrdtyp .le. ioins) then
                  write (iout,1001) title
                else
                  write (iout,2029) ' ',formatname(inpcrdtyp)
                end if
                write (iout,2063)
              end if
            end if
            if (inpcrdtyp .ne. iotyp .and. marker(iotyp) .ne. '      ')
         -    write (iout,2029) marker(iotyp),formatname(inpcrdtyp)
            if (iotyp .eq. iocha) then
              if (n .lt. 100000) then
                write (iout,1291) n
              else
                write (6,3000)
                call askstop(1)
                write (6,3001)
                write (iout,1292) n
              end if
            else if (iotyp .eq. iochaex) then
               write (iout,1293) n
            else if (iotyp .eq. iommod) then
              ansline=blankline
              write (ansline(1:6),1008) n
              if (title(1:4) .ne. '@#$%') then
                ansline(8:87)=title
              else
                ansline(8:28)='Converted by Simulaid'
                if (ntitlin . gt. 0)
         -        ansline(30:109)=title
              end if
              call lastchar(ansline,ifc,incol(inpcrdtyp))
              call writeline(iout,ansline,1,ifc,0)
            else if (iotyp .eq. iogro) then
              write (iout,1001) title
              write (iout,1007) n
            else if (iotyp .eq. ionxyz .or. iotyp .eq. iosxyz .or.
         -           iotyp .eq. iosxyzrq) then
              write (iout,1007) n
            end if
          end if
          if (ischarmm(iotyp) .eq. 1) then
            iresidcol1=iiresidcol(1,iotyp)
            iresidcol2=iiresidcol(2,iotyp)
            do ia=1,n
              call leftadjustline(line(index(ia)),iresidcol1,iresidcol2)
            end do
          end if
          if (imodelnum .gt. 0) write (iout,1002) 'MODEL',imodelnum
          ncol=incol(iotyp)
          call lastchar(line(index(1)),ifc,ncol)
          if (n .gt. 0) then
            if (iwriteatsym .gt. 0)
         -    call addatsym(line(index(1)),iatnum(1),ifc)
            call writeline(iout,line(index(1)),1,ifc,0)
          end if
          if (nosort .eq. 1 .and.
         -    ispdb(inpcrdtyp) .gt. 0 .and. ispdb(iotyp) .gt. 0) then
            nrem=0
            do i=index(1),index(n)
              if (line(i)(1:6) .eq. 'REMARK') nrem=nrem+1
            end do
            if (nrem .gt. 0 .and. keeprem .eq. -1) then
              call askyn(
         -      'Do you want to keep REMARK records among the ATOM records',
         -      57,1,1,keeprem,000,0)
            end if
          end if
          ixprev=index(1)
          do ia=2,n
            if (isegno(ia) .ne. isegno(ia-1)) then
              if (ispdb(iotyp) .gt. 0) write (iout,1000) 'TER'
              if (iotyp .eq. ioins) write (iout,1000) 'end'
            end if
            if (keeprem .eq. 1) then
              if (index(ia)-ixprev .gt. 1) then
                do i=ixprev+1,index(ia)
                  if (line(i)(1:6) .eq. 'REMARK') then
                    call lastchar(line(i),lc,80)
                    call writeline(iout,line(i),1,lc,0)
                  end if
                end do
              end if
              ixprev=index(ia)
            end if
            call lastchar(line(index(ia)),ifc,ncol)
            if (iwriteatsym .gt. 0)
         -    call addatsym(line(index(ia)),iatnum(ia),ifc)
            call writeline(iout,line(index(ia)),1,ifc,0)
          end do
          if (imodelnum+modelfound .gt. 0) then
            write (iout,1000) 'ENDMDL'
          else if (ispdb(iotyp) .gt. 0 .and. noend .eq. 0) then
            write (iout,1000) 'END'
          end if
          if (iotyp .eq. ioins) write (iout,2064)
          return
    1000  format(a)
    1001  format(a80)
    1002  format(a,i6)
    1007  format(i5)
    1008  format(i6)
    1291  format('*',/,i5)
    1292  format('*',/,i6)
    1293  format('*',/,i10,2x,'EXT')
    2029  format(a,' Simulaid generated this file from ',a,' input')
    2030  format(a,' Cell dimensions: ',3f10.5)
    2031  format(a,' Data column shows ',a)
    2032  format(a,' Cutoff used for the CV calculation=',f5.1,' A')
    2033  format(a,' Solute atom range used for the CV calculation [',i4,
         -  ',',i5,']')
    2034  format(' E=',e16.8)
    2035  format(a,' Data column shows ',a,' contact counts')
    2036  format(' Nclstmem=',i6)
    2037  format(' Frame #',i8)
    2062  format('!BIOSYM archive 3',/,'PBC=OFF')
    2063  format('!DATE')
    2064  format('end',/,'end')
    3000  format(' WARNING number of atoms exceeds the format limit',/,
         -  ' You may want to restart the run and ask for the extended ',
         -  ' Charmm format')
    3001  format(' WARNING number of atoms will be printed with i6 format')
          end
          subroutine addatsym(line,ian,ifc)
          character*(*) line
          character*2 iatnm2
          common /atnam/ aw(99),nval(99),nvalmax(99),mmofan(99),
         -  mmatno(64),iatnm2(99)
          character*2 chemsym
          character*4 name
          if (ian .lt. 1) then
            name=line(13:16)
            iatno=ianum(name,1,4)
          else
            iatno=ian
          end if
          chemsym=iatnm2(iatno)
          if (chemsym(2:2) .eq. ' ') then
             chemsym(2:2)=chemsym(1:1)
             chemsym(1:1)=' '
          end if
          if (ifc .gt. 76 .and. line(77:78) .ne. chemsym) then
            write (6,1000) line(77:78),chemsym,line(1:ifc)
          else
            call blankout(line,ifc+1,80)
          end if
          line(77:78)=chemsym
          if (ifc .lt. 77) ifc=78
          return
    1000  format(' WARNING: columns 77-78 is not blank:',a,' - changed to ',
         -  a,' in line',/,a)
          end
          subroutine createrec(line,inpcrdtyp,ioutyp,cx,cy,cz,altcol,inscol,
         -  atnam,resnam,segnam,iseqno,iresnum,iresid,chemnam,potnam,
         -  frocc,q,nqdec,iqspace,mmcgm,nn,in,nconfig,ibnd,ihetat,blankline)
          character* 132 line,blankline
          character*1 altcol,inscol,resnam1
          character*4 atnam,segnam,chemnam
          character*6 potnam
          character*8 resnam
          character*5 crdext
          character*2 mmcgm
          common /iotypes/ iocha,iochaex,iobpdb,iocpdb,ioa3pdb,ioa4pdb,
         -  iommod,iommc,iommc4,iogro,iomol2,iomae,iocif,ioxxx,ioins,
         -  ionxyz,iosxyz,iosxyzrq,iograsp,iofull,lext(19),crdext(19)
          dimension in(nn),ibnd(nn)
          call setcol(inpcrdtyp,ncol,idcol,ialtcol,iinscol,
         -  namcol1,namcol2,irescol1,irescol2,iccol1,iccol2,
         -  iresncol1,iresncol2,iseqncol1,iseqncol2,isegcol1,isegcol2,
         -  iresidcol1,iresidcol2,iqcol1,iqcol2,ipotcol1,ipotcol2,
         -  iocccol1,iocccol2,ichemcol1,ichemcol2,nrescol_i,nresncol,
         -  nsegcol_i,nnamcol_i,iofull)
          call setcol(ioutyp,ncol,idcol,ialtcol,iinscol,
         -  namcol1,namcol2,irescol1,irescol2,iccol1,iccol2,
         -  iresncol1,iresncol2,iseqncol1,iseqncol2,isegcol1,isegcol2,
         -  iresidcol1,iresidcol2,iqcol1,iqcol2,ipotcol1,ipotcol2,
         -  iocccol1,iocccol2,ichemcol1,ichemcol2,nrescol,nresncol,
         -  nsegcol,nnamcol,iofull)
          line=blankline
          if (ioutyp .eq. iocha) then
            icinc=0
            if (icinc .gt. 999999) icinc=1
            write (line(iseqncol1+icinc:iseqncol2+icinc),1000)
         -    mod(iseqno,100000)
            write (line(iresncol1+icinc:iresncol2+icinc),1000)
         -    mod(iresnum,100000)
            if (iseqno .eq. 100000) write (6,1100) 'seqno',99999,'CRD'
            if (iresnum .eq. 100000) write (6,1100) 'resnum',99999,'CRD'
            write (line(iccol1+icinc:iccol2+icinc),1011) cx,cy,cz
            call putreal(line(iqcol1+icinc:iqcol2+icinc),iqcol2-iqcol1+1,
         -    q,nqdec)
            write (line(iresidcol1+icinc:iresidcol2+icinc),1001)
         -    mod(iresid,10000)
            if (iresid .eq. 10000) write (6,1100) 'iresid',9999,'Charmm'
            call leftadjustline(line,iresidcol1+icinc,iresidcol2+icinc)
          else if (ioutyp .eq. iochaex) then
            write (line(iseqncol1:iseqncol2),1005) iseqno
            write (line(iresncol1:iresncol2),1005) iresnum
            write (line(iccol1:iccol2),1015) cx,cy,cz
            call putreal(line(iqcol1:iqcol2),iqcol2-iqcol1+1,q,2*nqdec)
            write (line(iresidcol1:iresidcol2),1004) iresid
            call leftadjustline(line,iresidcol1,iresidcol2)
          else if (ispdb(ioutyp) .gt. 0) then
            if (resnam .eq. '     ' .or. resnam .eq. 'UNK  ') then
              line(1:6)='HETATM'
            else
              line(1:4)='ATOM'
              if (ihetat .eq. 1) line(1:6)='HETATM'
            end if
            write (line(iseqncol1:iseqncol2),1000) mod(iseqno,100000)
            write (line(iresncol1:iresncol2),1001) mod(iresnum,10000)
            write (line(iccol1:iccol2),1012) cx,cy,cz
            line(ialtcol:ialtcol)=altcol
            line(iinscol:iinscol)=inscol
            if (nconfig .le. 10) then
              if (iresnum .eq. 10000) write (6,1100) 'resnum',9999,'PDB'
              if (iseqno .eq. 100000) write (6,1100) 'seqno',99999,'PDB'
            end if
            if (frocc .eq. 1.0) then
              line(55:60)='   1.0'
            else
              call putreal(line(55:60),6,frocc,0)
            end if
            if (iqspace .eq. 1) then
              line(iqcol1:iqcol1)=' '
              call putreal(line(iqcol1+1:iqcol2),iqcol2-iqcol1,q,nqdec)
            else
              call putreal(line(iqcol1:iqcol2),iqcol2-iqcol1+1,q,nqdec)
            end if
            if (ioutyp .eq. iocpdb) then
              if (atnam(1:1) .ne. ' ' .and. atnam (4:4) .eq. ' ') then
                atnam(2:4)=atnam(1:3)
                atnam(1:1)=' '
              end if
              if (ichemcol2 .gt. ichemcol1)
         -      call writeitem(line,ichemcol1,ichemcol2,chemnam,0)
            end if
          else if (ioutyp .eq. iommod) then
            write (line(iresncol1:iresncol2),1000) iresnum
            write (line(iccol1:iccol2),1013) cx,cy,cz
            call writeitem(line,ipotcol1,ipotcol2,potnam,0)
            line(110:118)='  0.00000'
            line(iqcol1:iqcol2)=' '
            call putreal(line(iqcol1+1:iqcol2),iqcol2-iqcol1,q,nqdec)
            do i=1,nn
              write (line(12+(i-1)*8:12+(i-1)*8),1002) ibnd(i)
              write (line(5+(i-1)*8:10+(i-1)*8),1003) in(i)
            end do
            do i=nn+1,6
              line(4+(i-1)*8+1:4+i*8)='     0 0'
            end do
            call changeprot(resnam,resnam1,2)
            line(isegcol1-1:isegcol2-1)=resnam1
          else if (ioutyp .eq. iommc) then
            write (line(iresncol1:iresncol2),1000) iresnum
            write (line(iccol1:iccol2),1011) cx,cy,cz
            call writeitem(line,ipotcol1,ipotcol2,potnam,0)
            call putreal(line(iqcol1:iqcol2),iqcol2-iqcol1+1,q,nqdec)
            line(51:52)=mmcgm
          else if (ioutyp .eq. iogro) then
            write (line(iseqncol1:iseqncol2),1000) iseqno
            write (line(iresncol1:iresncol2),1000) iresnum
            line(irescol1:irescol1)=' '
            line(namcol1:namcol1)=' '
            write (line(iccol1:iccol2),1012) cx/10.0,cy/10.0,cz/10.0
            write (line(iccol1+24:iccol2+24),1012) 0.0,0.0,0.0
          else if (ioutyp .eq. ioins) then
            write (line(iresncol1:iresncol2),1001) iresnum
            call writeitem(line,ichemcol1,ichemcol2,chemnam,0)
            if (inpcrdtyp .eq. ioutyp) then
              call writeitem(line,ipotcol1,ipotcol2,potnam,0)
            else
              call writeitem(line,ipotcol1,ipotcol2,chemnam,0)
            end if
            write (line(iccol1:iccol2),1014) cx,cy,cz
            call putreal(line(iqcol1:iqcol2),iqcol2-iqcol1+1,q,nqdec)
          end if
          call writeitem(line,irescol1,irescol2,resnam,nrescol_i)
          call writeitem(line,isegcol1,isegcol2,segnam,min0(4,nsegcol_i))
          call writeitem(line,namcol1,namcol2,atnam,min0(4,nnamcol_i))
          return
    1000  format(i5)
    1001  format(i4)
    1002  format(i1)
    1003  format(i6)
    1004  format(i8)
    1005  format(i10)
    1011  format(3f10.5)
    1012  format(3f8.3)
    1013  format(3f12.5)
    1014  format(3f15.9)
    1015  format(3f20.10)
    1100  format(' WARNING: leading ',a,' digits over ',i7,
         -  '  are dropped (',a,' format limit)')
          end
          subroutine writeitem(line,icol1,icol2,name,namlen)
          character* 132 line
          character*(*) name
          if (icol1 .gt. icol2) return
          if (namlen .eq. 0) then
            namelen=icol2-icol1+1
          else
            namelen=min0(icol2-icol1+1,namlen)
          end if
          call blankout(line,icol1,icol2)
          line(icol1:icol1+namelen-1)=name(1:namelen)
          return
          end
          subroutine set_pdbinfo(iotyp,iwriteatsym,iwritecon,iobpdb,iocpdb,
         -  iaskcon)
          if (iotyp .eq. iobpdb .or. iotyp .eq. iocpdb) then
            if (iwriteatsym .lt. 0) call askyn(
         -    'Do you want chemical names written in the PDB file',50,
         -    1,-1,iwriteatsym,0,0)
            if (iaskcon .eq. 1) call askyn(
         -    'Do you want CONECT records written in the PDB file',50,1,
         -    -1,iwritecon,0,0)
          end if
          return
          end
          subroutine askstop(idef)
          common /logging/ logfile,ipredict
          if (ipredict .eq. 0) then
            call askyn('Do you want to continue',23,1,idef,icont,20,0)
            if (icont .eq. 0) stop
          else
            print *,'Run continues as predictable input was requested'
          end if
          return
          end
          subroutine putreal(out,len,val,ndec)
          character*(*) out
          character*25 out25
          if (ndec .eq. 0) then
            write (out25,100) val
          else if (ndec .eq. 1) then
            write (out25,101) val
          else if (ndec .eq. 2) then
            write (out25,102) val
          else if (ndec .eq. 3) then
            write (out25,103) val
          else if (ndec .eq. 4) then
            write (out25,104) val
          else if (ndec .eq. 5) then
            write (out25,105) val
          else if (ndec .eq. 6) then
            write (out25,106) val
          else if (ndec .eq. 7) then
            write (out25,107) val
          else if (ndec .eq. 8) then
            write (out25,108) val
          else if (ndec .eq. 9) then
            write (out25,109) val
          else if (ndec .eq. 10) then
            write (out25,110) val
          else
            print *,'Illegal number of decimal digits in putmol:',ndec
            write (out25,110) val
          end if
          ic=1
          call nextchar(out25,ic,25)
          if (ic .le. 25-len) then
            out=out25(ic:ic+len-1)
          else
            out=out25(25-len+1:25)
          end if
          return
    100   format(f25.0)
    101   format(f25.1)
    102   format(f25.2)
    103   format(f25.3)
    104   format(f25.4)
    105   format(f25.5)
    106   format(f25.6)
    107   format(f25.7)
    108   format(f25.8)
    109   format(f25.9)
    110   format(f25.10)
          end
          subroutine writefree(line,ioutyp,chemnam,cx,cy,cz,ires,q)
          character*4 chemnam
          character* 132 line
          character*5 crdext
          common /iotypes/ iocha,iochaex,iobpdb,iocpdb,ioa3pdb,ioa4pdb,
         -  iommod,iommc,iommc4,iogro,iomol2,iomae,iocif,ioxxx,ioins,
         -  ionxyz,iosxyz,iosxyzrq,iograsp,iofull,lext(19),crdext(19)
          if (ioutyp .eq. ionxyz) then
            write (line,1100) ianum(chemnam,0,4),cx,cy,cz
          else if (ioutyp .eq. iosxyz) then
            write (line,1101) chemnam,cx,cy,cz
          else if (ioutyp .eq. iosxyzrq) then
            write (line,1102) chemnam,cx,cy,cz,ires,q
          end if
          return
    1100  format(i5,3f10.5)
    1101  format(a5,3f10.5)
    1102  format(a5,3f10.5,i5,f10.5)
          end
          subroutine writepdbd(iout,c,ia,ir,atnam,resnam,segnam,frocc,bfac)
          real*8 c(3)
          character*4 atnam
          character*3 resnam
          character*1 segnam
          write (iout,1000) ia,atnam,resnam,segnam,ir,c,frocc,bfac
          return
    1000  format('ATOM  ',i5,1x,a4,1x,a3,1x,a1,i4,1x,3x,3f8.3,f6.2,f6.1)
          end
          subroutine writegrasp(iout,nconvdat,analfile,namlena)
          character*200 analfile
          character*4 ires
          character*8 convdat
          character*200 sfilename
          common /savedat/ mxresdat,maxcondat,ifst(1000),ilst(1000),
         -  nres,iresgen,lsfilename,ires(1000),convdat(7,10000),sfilename
          nl=min0(namlena,50)
          write (iout,1000) analfile(1:nl)
          write (iout,1001)
          nxa=0
          nxr=0
          do ia=1,nconvdat
            read (convdat(4,ia),*) ch
            write (iout,2000) convdat(2,ia)(1:4),convdat(1,ia)(1:3),ch
            if (convdat(1,ia)(4:4) .ne. ' ') nxr=nxr+1
            if (convdat(2,ia)(5:5) .ne. ' ') nxa=nxa+1
          end do
          if (nxa .gt. 0) write (6,1002) nxa,'atom',4
          if (nxr .gt. 0) write (6,1002) nxr,'residue',3
          return
    1000  format('!Generated by Simulaid from ',a)
    1001  format('atom__resnumbc_charge_')
    1002  format('WARNING: ',i5,1x,a,' names were longer than ',
         -  i1,' characters')
    2000  format(a4,2x,a3,6x,f6.3)
          end
          subroutine writeUHBD(iout,nconvdat,analfile,namlena,icon)
          character*200 analfile
          character*4 ires
          character*8 convdat
          character*200 sfilename
          common /savedat/ mxresdat,maxcondat,ifst(1000),ilst(1000),
         -  nres,iresgen,lsfilename,ires(1000),convdat(7,10000),sfilename
          character*7 libname(3)
          data libname /'Amber  ','CHARMM ','GROMACS'/
          nl=min0(namlena,50)
          write (iout,1000) libname(icon),analfile(1:nl)
          do ia=1,nconvdat
            iatno=ianum(convdat(2,ia),1,4)
            read (convdat(4,ia),*,err=999) ch
            read (convdat(6,ia),*,err=999) eps
            read (convdat(7,ia),*,err=999) sig
            write (iout,2000) convdat(2,ia)(1:4),convdat(1,ia)(1:4),
         -    ch,eps,sig,(sig/2.0)*2.0**(1.0/6.0)
          end do
          return
    999   write (6,2001) ia,convdat(4,ia),convdat(6,ia),convdat(7,ia)
          return
    1000  format(a,/,'!Generated by Simulaid from ',a,/,
         -  'atom  resi   chrg   epsi   sigm   radi end')
    2000  format(a4,2x,a3,6x,5f8.4)
    2001  format(' PROGRAM ERROR: invalid data in convdat ia=',i4,
         -  ' convdat4,6,7=',3f9.4)
          end
          subroutine setcol(inpcrdtyp,ncol,idcol,ialtcol,iinscol,
         -  inamcol1,inamcol2,irescol1,irescol2,iccol1,iccol2,
         -  iresncol1,iresncol2,iseqncol1,iseqncol2,isegcol1,isegcol2,
         -  iresidcol1,iresidcol2,iqcol1,iqcol2,ipotcol1,ipotcol2,
         -  iocccol1,iocccol2,ichemcol1,ichemcol2,nrescol,nresncol,nsegcol,
         -  nnamcol,iofull)
          common /columnlim/ incol(19),iidcol(19),iialtcol(19),iiinscol(19),
         -  iinamcol(2,19),iirescol(2,19),iiccol(2,19),iiresncol(2,19),
         -  iiseqncol(2,19),iisegcol(2,19),iiresidcol(2,19),iiqcol(2,19),
         -  iipotcol(2,19),iiocccol(2,19),iichemcol(2,19)
          ncol=incol(inpcrdtyp)
          idcol=iidcol(inpcrdtyp)
          ialtcol=iialtcol(inpcrdtyp)
          iinscol=iiinscol(inpcrdtyp)
          inamcol1=iinamcol(1,inpcrdtyp)
          inamcol2=iinamcol(2,inpcrdtyp)
          irescol1=iirescol(1,inpcrdtyp)
          irescol2=iirescol(2,inpcrdtyp)
          iccol1=iiccol(1,inpcrdtyp)
          iccol2=iiccol(2,inpcrdtyp)
          iresncol1=iiresncol(1,inpcrdtyp)
          iresncol2=iiresncol(2,inpcrdtyp)
          iseqncol1=iiseqncol(1,inpcrdtyp)
          iseqncol2=iiseqncol(2,inpcrdtyp)
          isegcol1=iisegcol(1,inpcrdtyp)
          isegcol2=iisegcol(2,inpcrdtyp)
          iresidcol1=iiresidcol(1,inpcrdtyp)
          iresidcol2=iiresidcol(2,inpcrdtyp)
          iqcol1=iiqcol(1,inpcrdtyp)
          iqcol2=iiqcol(2,inpcrdtyp)
          ipotcol1=iipotcol(1,inpcrdtyp)
          ipotcol2=iipotcol(2,inpcrdtyp)
          iocccol1=iiocccol(1,inpcrdtyp)
          iocccol2=iiocccol(2,inpcrdtyp)
          ichemcol1=iichemcol(1,inpcrdtyp)
          ichemcol2=iichemcol(2,inpcrdtyp)
          nrescol=irescol2-irescol1+1
          nresncol=iresncol2-iresncol1+1
          nsegcol=isegcol2-isegcol1+1
          nnamcol=inamcol2-inamcol1+1
          if (inpcrdtyp .gt. iofull) then
            nrescol=4
            iqcol1=0
          end if
          return
          end
          subroutine readxcluster(natoms,c,inpt,nconfig)
          dimension c(3,natoms)
          character*132 inpline
          read (inpt,1001) inpline
          read (inpline(1:6),1008,err=999) nn
          if (-nn .ne. natoms) then
            print *,'ERROR: Number of atoms in the first ',
         -    'structure=',natoms
            print *,'Number of atoms in the X-cluster structure=',-nn
            print *,'Nconfig=',nconfig
            stop
          end if
          do i=1,natoms
            read (inpt,1001) inpline
            read (inpline(6:41),1103) (c(k,i),k=1,3)
          end do
          return
    999   print *,'Invalid number of atoms reading in xcluster'
          stop
    1001  format(a132)
    1008  format(i6)
    1103  format(3f12.5)
          end
          subroutine leftadjustline(line,ic1,ic2)
          character*(*) line
          icol=ic1
          call nextchar(line,icol,132)
          nshift=icol-ic1
          if (nshift .gt. 0) then
            do i=icol,ic2
              line(i-nshift:i-nshift)=line(i:i)
            end do
            do i=1,nshift
              line(ic2-i+1:ic2-i+1)=' '
            end do
          end if
          return
          end
          subroutine rightadjustline(line,ic1,ic2)
          character* 132 line
          nshift=0
          do while (line(ic2-nshift:ic2-nshift) .eq. ' '
         -         .and. nshift .le. ic2-ic1)
            nshift=nshift+1
          end do
          do ic=ic1,ic2-nshift
            icc=ic2-ic+ic1
            line(icc:icc)=line(icc-nshift:icc-nshift)
          end do
          do ic=ic1,ic1+nshift-1
            line(ic:ic)=' '
          end do
          return
          end
          subroutine leftadjust4(in,out)
          character*(*) in
          character*4 out,outt
          outt='    '
          do i=1,4
            if (in(i:i) .ne. ' ') then
              do j=i,4
                outt(j-i+1:j-i+1)=in(j:j)
              end do
              out=outt
              return
            end if
          end do
          out=in(1:4)
          return
          end
          subroutine leftadjustn(in,out,n)
          character*(*) in
          character*(*) out
          nz=0
          i=1
          do while(i .lt. n .and. in(i:i) .eq. ' ')
            i=i+1
          end do
          if (i .eq. n .and. in(n:n) .eq. ' ') then
            call blankout(out,1,n)
            return
          end if
          nz=i-1
          do j=nz+1,n
            out(j-nz:j-nz)=in(j:j)
          end do
          do j=n-nz+1,n
            out(j:j)=' '
          end do
          return
          end
          subroutine askrot(nstep)
          common /rotmat/ matrot0(4,4),matrot(4,4),nomat0
          character*1 ans,ans0,anslc,xyzorig(3)
          common /askrotdat/ angle,ans0
          common /depthcuedat/ near,ifar,ramp0,idepth,idepthon,idrawh,
         -  linew,isidec,nbackb,idrawslv
          character*1 xyz
          common /axislab/ xyz(3)
          character*3 onoff(2)
          data onoff /'OFF','ON '/,xyzorig /'x','y','z'/
          if (nstep .eq. 0) then
            ans0='x'
            angle=10.0
          end if
          if (mod(nstep,20) .eq. 0)
         -  write (6,2104) onoff(2-idepth),onoff(2-idrawh),onoff(2-isidec),
         -  onoff(2-idrawslv),linew
          nstep=nstep+1
          ans=' '
    100   read (5,1010) ans
          if (ans .eq. 's' .or. ans .eq. 'S') then
            nstep=-1
            return
          else if (ans .eq. 'q' .or. ans .eq. 'Q') then
            call getreal('New angle increment',19,angle,angle,0,36)
            go to 100
          else if (ans .eq. 'd' .or. ans .eq. 'D') then
            idepth=1-idepth
            write (6,2001) 'Depth cueing',onoff(idepth+1)
            go to 100
          else if (ans .eq. 'h' .or. ans .eq. 'H') then
            idrawh=1-idrawh
            write (6,2001) 'Hydrogens',onoff(idrawh+1)
            go to 100
          else if (ans .eq. 'c' .or. ans .eq. 'C') then
            if (nbackb .gt. 0) then
              isidec=1-isidec
              write (6,2001) 'Side chains',onoff(isidec+1)
            else
              print *,'There are no backbone atoms - input ignored'
            end if
            go to 100
          else if (ans .eq. 'v' .or. ans .eq. 'V') then
            idrawslv=1-idrawslv
            write (6,2001) 'Solvents',onoff(idrawslv+1)
            go to 100
          else if (idigit(ans,1) .eq. 1) then
            read (ans,*) linew
            write (6,2002) linew
          end if
          if (ans .eq. 'x' .or. ans .eq. 'y' .or. ans .eq. 'z'
         -    .or. ans .eq. 'X' .or. ans .eq. 'Y' .or. ans .eq. 'Z') then
            anslc=ans
            call uplow(ans,anslc,1,noabc)
            do k=1,3
              if (anslc .eq. xyz(k)) ans=xyzorig(k)
            end do
            ans0=ans
          else
            ans=ans0
          end if
          iaxis=10.0*angle
          return
    1010  format(a1)
    2001  format(1x,a,' has been turned ',a)
    2002  format(' Solute linewidth has been changed to',i2)
    2104  format(' Type x/y/z to rotate by 10 degrees around axis x/y/z',/,
         -  ' Type q to change the angle increment',/,
         -  ' Type d to toggle depth-cueing ',a,/,
         -  ' Type h to toggle showing hydrogens  ',a,/,
         -  ' Type c to toggle showing sidechains ',a,/,
         -  ' Type v to toggle showing solvents   ',a,/,
         -  ' Type a number (1 digit) to change the linewidth from',i2,/,
         -  ' Hit <Enter> to continue rotating around the previous axis',/,
         -  ' Type s to stop the rotation and continue the run')
          end
          subroutine cvffconv(cvffname,charmmname,incvff,icvff,outnam,n,
         -  iused,ntypein,iambig,lstambig,nambig,noconv,ioutmsg,maxtyp)
          character*4 incvff,outnam,xxxx
          dimension incvff(n),icvff(n),outnam(n),iused(maxtyp),lstambig(n),
         -  iambig(maxtyp)
          character*2 cvffname(100)
          character*4 charmmname(100)
          data xxxx /'****'/
          call zeroiti(iused,0,maxtyp)
          nambig=0
          noconv=0
          do i=1,n
            icvff(i)=0
            j=0
            do while (j .lt. ntypein .and. icvff(i) .eq. 0)
              j=j+1
              if (incvff(i)(1:2) .eq. cvffname(j)) then
                icvff(i)=j
                outnam(i)=charmmname(j)
                if (outnam(i)(1:1) .eq. '?') then
                  write (6,101) incvff(i)(1:2),i
                  if (ioutmsg .gt. 0) write (ioutmsg,101) incvff(i)(1:2),i
                  noconv=noconv+1
                else
                  iused(j)=iused(j)+1
                end if
                if (iambig(j) .gt. 0) then
                  nambig=nambig+1
                  lstambig(nambig)=i
                end if
              end if
            end do
            if (icvff(i) .eq. 0) then
              write (6,100) incvff(i)(1:2),i
              if (ioutmsg .gt. 0) write (ioutmsg,100) incvff(i)(1:2),i
              outnam(i)=xxxx
            end if
          end do
          return
    100   format(' ERROR: atom type ',a2,' atom number',i4,' is not a',
         -  ' valid cvff type',/,' - check input file')
    101   format(' PROBLEM: no conversion is given for atom type ',a2,
         -  ' atom number ',i4)
          end
          subroutine refineconv(n,cvffnam,iatnam,iatnum,iused,
         -  icvff,nneig,ineig,nhneig,nringnb,iringtyp,maxng,maxtyp,maxat)
          dimension nneig(maxat),ineig(maxng,n),iatnum(maxat),
         -  iatnam(maxat),icvff(maxat),nhneig(maxat),
         -  cvffnam(maxat),nringnb(maxat),iringtyp(maxat),iused(maxtyp)
          character*2 nnam
          character*4 cvffnam,iatnam,obl,ob,ct2,ct3
          data obl /'O   '/,ob /'OB  '/,ct2 /'CT2 '/,ct3 /'CT3 '/
          do i=1,n
            iringtyp(i)=0
            nnam=cvffnam(i)(1:2)
            if (nnam .eq. 'c5' .or. nnam .eq. 'cp' .or. nnam .eq. 'np'
         -      .or. nnam .eq. 'ni') iringtyp(i)=-1
            nringnb(i)=0
            nn=nneig(i)
            do j=1,nn
              nnam=cvffnam(ineig(j,i))(1:2)
              if (nnam .eq. 'c5' .or. nnam .eq. 'cp' .or. nnam .eq. 'np'
         -        .or. nnam .eq. 'ni') nringnb(i)=nringnb(i)+1
            end do
          end do
          do i=1,n
            if (cvffnam(i)(1:2) .eq. 'c5') iringtyp(i)=5
            if (cvffnam(i)(1:2) .eq. 'cp') iringtyp(i)=6
            if (cvffnam(i)(1:2) .eq. 'ni') iringtyp(i)=5
          end do
          do i=1,n
            if (nringnb(i) .gt. 2) iringtyp(i)=4
          end do
          nchange=0
          nrep=0
          do while (nchange .gt. 0 .or. nrep .eq. 0)
            nrep=nrep+1
            do i=1,n
              if (iatnum(i) .eq. 7 .and. iringtyp(i) .eq. -1) then
                nn=nneig(i)
                do in=1,nn
                  if (iringtyp(ineig(in,i)) .eq. 5) then
                    iringtyp(i)=5
                    nchange=nchange+1
                  end if
                  if (iringtyp(ineig(in,i)) .eq. 6) then
                    iringtyp(i)=6
                    nchange=nchange+1
                  end if
                end do
              end if
            end do
          end do
          do i=1,n
            if (iringtyp(i) .eq. 4) then
              nn=nneig(i)
              nn5=0
              nn6=0
              do in=1,nn
                if (iringtyp(ineig(in,i)) .eq. 5) nn5=nn5+1
                if (iringtyp(ineig(in,i)) .eq. 6) nn6=nn6+1
              end do
              if (nn5 .gt. 0 .and. nn6 .gt. 0) iringtyp(i)=1
              if (nn6 .eq. 0 .and. nn5 .eq. 3) iringtyp(i)=2
              if (nn5 .eq. 0 .and. nn6 .eq. 3) iringtyp(i)=3
            end if
          end do
          do i=1,n
            if (iatnam(i) .eq. obl) then
              ic=ineig(1,i)
              if (nneig(i) .gt. 1 .or. iatnum(ic) .ne. 6) then
                write (6,100) nneig(i),iatnam(i),i
              else
                nnc=nneig(ic)
                if (nnc .eq. 2) then
                  ij1=ineig(1,ic)
                  ij2=ineig(2,ic)
                  if (iatnum(ij1) .eq. 6 .and. iatnam(ij2) .eq. 'OH1 '
         -          .or. iatnum(ij2) .eq. 6 .and. iatnam(ij1) .eq. 'OH1 ')
         -          then
                    iatnam(i)=ob
                    iused(83)=iused(83)+1
                    icvff(i)=83
                  end if
                end if
              end if
            else if (cvffnam(i)(1:2) .eq. 'c ') then
              if (nhneig(i) .eq. 2) then
                iatnam(i)=ct2
                iused(84)=iused(84)+1
                icvff(i)=84
              else if (nhneig(i) .eq. 3) then
                iatnam(i)=ct3
                iused(85)=iused(85)+1
                icvff(i)=85
              end if
            else if (cvffnam(i)(1:2) .eq. 'cn' .and. nhneig(i) .eq. 2) then
              iatnam(i)=ct2
              iused(86)=iused(86)+1
              icvff(i)=86
            end if
          end do
          return
    100   format(' ERROR: type O has',i2,' neighbours and the first is '
         -  ,a4,' i=',i4,/,' - check coordinate file')
          end
          subroutine printrtfres(if,il,nneig,ineig,resnam,q,atnam,potnam,
         -  nglist,iqok,ipotok,iout,outfile,namleno,maxng,maxat)
          dimension nneig(maxat),ineig(maxng,maxat),q(maxat),nglist(maxng)
          character*4 resnam,atnam(maxat),potnam(maxat)
          character*(*) outfile
          if (iqok .eq. 0) write (iout,1000) 'Charges were unavailable'
          if (ipotok .eq. 0) write (iout,1000) 'FP labels were unavailable'
          qsum=0.0
          qabssum=0.0
          if (iqok .eq. 1) then
            do ia=if,il
              qsum=qsum+q(ia)
              qabssum=qabssum+abs(q(ia))
            end do
          end if
          if (qabssum .eq. 0.0) write (iout,1000) 'All charges are zero ??'
          write (iout,1003) resnam,qsum
          qsum=0.0
          do ia=if,il
            write (iout,1002) atnam(ia),potnam(ia),q(ia)
            qsum=qsum+q(ia)
            if (isinteger(qsum,4,qoffset) .eq. 1 .and. qabssum .gt. 0.001)
         -     write (iout,1004)
          end do
          do ia=if,il
            nn=nneig(ia)
            if (nn .gt. 0) then
              nnl=0
              do ja=1,nn
                in=ineig(ja,ia)
                if (in .gt. ia) then
                  nnl=nnl+1
                  nglist(nnl)=in
                end if
              end do
              if (nnl .gt. 0) write (iout,1001)
         -      (atnam(ia),atnam(nglist(j)),j=1,nnl)
            end if
          end do
          write (6,2000) resnam,outfile(1:namleno),il-if+1,qsum
          return
    1000  format('! ',a)
    1001  format('BOND  ',12(a4,1x))
    1002  format('ATOM ',a4,1x,a4,f10.5)
    1003  format('RESI ',a4,f10.5)
    1004  format('GROUP')
    2000  format(' RTF file for residue ',a,' was printed a to file ',a,/,
         -  ' Number of atoms=',i4,' Charge sum=',f6.2)
          end
          subroutine sortatres(line,n,index,indexn,indexo,ifa,ila,iresn,
         -  ireso,isegn,iresncol1,iresncol2,isegno,marker,inpcrdtyp,nconfig,
         -  iout,maxrepconf,maxrec)
          character* 132 line(maxrec)
          character*6 marker
          dimension index(n),isegno(n),indexo(n),indexn(n),ifa(n),ila(n),
         -  iresn(n),ireso(n),isegn(n)
          character*5 crdext
          common /iotypes/ iocha,iochaex,iobpdb,iocpdb,ioa3pdb,ioa4pdb,
         -  iommod,iommc,iommc4,iogro,iomol2,iomae,iocif,ioxxx,ioins,
         -  ionxyz,iosxyz,iosxyzrq,iograsp,iofull,lext(19),crdext(19)
          if (n .eq. 1) return
          if (nconfig .le. maxrepconf)
         -  print *,'Sorting by segment (chain) id and residue id'
          if (n .gt. 1000) print *,'..... Wait'
          nresncol=iresncol2-iresncol1+1
          call indexit(indexo,1,n,0)
          nn=n
          call indexit(ifa,1,n,0)
          call indexit(ila,1,n,0)
    11    nnpair=nn/2
          l=1
          do i=1,nnpair
            call mergerec(line,index,indexo,isegno,iresncol1,iresncol2,
         -    ifa(l),ila(l),ifa(l+1),ila(l+1),iresn,ireso,isegn,n,maxrec)
            ifa(i)=ifa(l)
            ila(i)=ila(l+1)
            l=l+2
          end do
          if (2*nnpair .eq. nn) go to 21
          call mergerec(line,index,indexo,isegno,iresncol1,iresncol2,
         -  ifa(nnpair),ila(nnpair),ifa(nn),ila(nn),iresn,ireso,isegn,n,
         -  maxrec)
          ila(nnpair)=ila(nn)
    21    nn=nnpair
          if (nn .gt. 1) go to 11
          do i=1,n
            indexn(indexo(i))=i
          end do
          if (inpcrdtyp .eq. iommod)
         -  call nnupdate(index,indexn,indexo,n,n,line,0,maxrec)
          if (marker .ne. '      ') write (iout,1270) marker
          return
    1270  format(a6,' Atoms sorted by residues by SIMULAID')
          end
          subroutine filenamenum(inpfile,namleni,numfile,namlenn,n,inout)
          character*200 inpfile,numfile
          character*1 separatorchar
          common /filenuminfo/ iaskunderscore,separatorchar
          iunderscore=0
          do ic=namleni,1,-1
            if (inpfile(ic:ic) .eq. '.') then
              nl1=ic
              go to 100
            end if
          end do
          nl1=namleni+1
    100   nl0=nl1-1
          if (nl0 .gt. 1) then
            if (inpfile(nl0-1:nl0+1) .eq. '.1.' .or.
         -      inpfile(nl0-1:nl0+1) .eq. '_1.') nl1=nl1-2
            if (inout .eq. 2 .and. iaskunderscore .eq. 1) then
              print *,'Filenumber separator is . (e.g., x.2.pdb)'
              call askyn('Use _ as the filenumber separator instead',
         -      41,1,-1,iunderscore,0,0)
              iaskunderscore=-1
            end if
            if (separatorchar .eq. '.' .and. iaskunderscore .eq. 1) then
              if (inpfile(nl0-1:nl0-1) .eq. '_') then
                separatorchar='_'
                iunderscore=1
              else if (inpfile(nl0-1:nl0-1) .ne. '.') then
                if (inout .eq. -1) then
                  call askyn(
         -          'Are the file numbers separated by _ (e.g., x_2.pdb)',
         -          51,1,-1,iunderscore,0,0)
                else
                  print *,'Filenumber separator is . (e.g., x_2.pdb)'
                  call askyn('Use _ as the filenumber separator instead',
         -          41,1,-1,iunderscore,0,0)
                  iaskunderscore=-1
                end if
              end if
            end if
          end if
          if (iabs(iaskunderscore) .eq. 1) then
            if (iunderscore .eq. 1) separatorchar='_'
            if (inout .gt. 0)
         -    write (6,2000) separatorchar,inpfile(nl1:namleni)
            iaskunderscore=0
          end if
          numfile(1:nl0)=inpfile(1:nl0)
          numfile(nl1:nl1)=separatorchar
          nl1=nl1+1
          call writeint(numfile,nl1,n,lenw)
          nl1=nl1-1
          if (namleni .gt. nl0) then
            numfile(nl1+1:nl1+namleni-nl0)=inpfile(nl0+1:namleni)
            nl1=nl1+namleni-nl0
          end if
          namlenn=nl1
          return
    2000  format(' Output file names should be of the form x',a1,'*',a)
          end
          subroutine unpackconf(line,nlines,ncol,inpfile,namleni,nconfig,
         -  molname,molnamelen,numsel,iconfsel,numconsec,maxconfsel,
         -  nextconfsel,incr_fileno,ioverallconf,ionefile,
         -  natsfirst,nats,iuunp,maxrec)
          dimension iconfsel(maxconfsel)
          character*(*) molname
          character*132 line(maxrec)
          character*200 inpfile,outfile
          common /logging/ logfile,ipredict
          if (numsel .gt. maxconfsel) then
            print *,'PROGRAM ERROR: illegal numsel (',numsel,');',
         -    ' maxconfsel=',maxconfsel
            stop
          end if
          if (numsel .gt. 0) then
            if (nconfig .eq. iconfsel(nextconfsel)) then
              nextconfsel=nextconfsel+1
            else
              return
            end if
          end if
          if (nconfig .eq. 1) natsfirst=nats
          if (nextconfsel .le. 10) then
            if (nats .ne. natsfirst) write (6,1012) nconfig,nats,natsfirst
          end if
          if (ionefile .eq. 0) then
            if (molnamelen .gt. 0) then
              nl1=molnamelen
              outfile(1:nl1)=molname(1:nl1)
              outfile(nl1+1:nl1+4)='.pdb'
              nl1=nl1+4
            else
              ifnumw=nconfig+incr_fileno
              if (numconsec .gt. 0) ifnumw=nextconfsel-1+incr_fileno
              call filenamenum(inpfile,namleni,outfile,nl1,ifnumw,+2)
            end if
            call openfile(iuunp,0,'output',6,'new',outfile,nl1,notfnd,2,1,1,
         -    0,ioverallconf)
            if (notfnd .eq. 1) write (6,1011) outfile(1:nl1)
            if (notfnd .eq. 1 .or. 
         -      (ipredict .eq. 1 .and. ioverallconf .eq. 0)) then
              call askyn('Do you want to overwrite all existing files',43,
         -      1,-1,ioverallconf,0,0)
              if (ioverallconf .eq. 0) stop
              call openfile(iuunp,0,'output',6,'new',outfile,nl1,notfnd,2,1,
         -      1,0,ioverallconf)
            end if
            write (6,1010) outfile(1:nl1)
          else if (nextconfsel .eq. 2) then
            outfile=inpfile
            ic=namleni
            do while (ic .gt. 1 .and. inpfile(ic:ic) .ne. '.')
              ic=ic-1
            end do
            if (ic .gt. 1) then
              outfile(ic:ic+3)='_sel'
              outfile(ic+4:namleni+4)=inpfile(ic:namleni)
            else
              outfile(namleni+1:namleni+4)='_sel'
            end if
            nl1=namleni+4
            call openfile(iuunp,0,'output',6,'new',outfile,nl1,notfnd,0,1,
         -    1,0,ioverallconf)
            write (6,1010) outfile(1:nl1)
          end if
          lf=1
          if (line(1)(1:3) .eq. 'TER' .or. line(1)(1:3) .eq. 'END') lf=2
          do i=lf,nlines
            call writeline(iuunp,line(i),1,ncol,0)
          end do
          if (ionefile .eq. 0) close (iuunp)
          return
    1010  format(' Writing file: ',a)
    1011  format(' Problem opening file: ',a)
    1012  format(' NOTE: # of atoms in configuration',i7,'=',i6,
         -  'in the first conf:',i6)
          end
          subroutine genrot(rot,pi,iax,angle)
          dimension rot(3,3)
          character*1 ans
          character*6 rq
          print *,'Rotating the structure (if required)'
          call quiz(ans,iax,' ',' ',0,'rotation type',13,0,5,6,0)
          if (ans .eq. 'i') then
            iax=0
          else if (ans .eq. 'q') then
            iax=-1
            return
          end if
          if (iax .gt. 0) then
            call getreal(
         -    'Angle (+: clockwise, -: counterclockwise, viewed from +'
         -    //ans//' axis)',62,999999.0,angle,0,0)
            angler=angle*(pi/180.0)
            iz=iax
            ix=mod(iz,3)+1
            iy=mod(iz+1,3)+1
            call unitmat(rot)
            rot(ix,ix)=cos(angler)
            rot(ix,iy)=sin(angler)
            rot(iy,ix)=-rot(ix,iy)
            rot(iy,iy)=rot(ix,ix)
          else
            do i=1,3
              do j=1,3
                write (rq,1003) i,j
                call getreal(rq,6,999999.0,rot(i,j),0,00)
              end do
            end do
          end if
          return
    1003  format('R(',i1,',',i2,')')
          end
          subroutine modify(inpcrdtyp,c,n,nslt,line,index,iatno,nneig,ineig,
         -  isegno,iresno,charge,icharges,natomadd,lineread,pi,maxneig,
         -  maxrec)
          dimension c(3,maxrec),index(maxrec),iatno(maxrec),nneig(maxrec),
         -  ineig(maxneig,maxrec),isegno(maxrec),iresno(maxrec),
         -  charge(maxrec)
          character*4 atnam,pflab
          character* 132 line(maxrec)
          character*2 iatnm2
          common /atnam/ aw(99),nval(99),nvalmax(99),mmofan(99),
         -  mmatno(64),iatnm2(99)
          character*5 crdext
          common /iotypes/ iocha,iochaex,iobpdb,iocpdb,ioa3pdb,ioa4pdb,
         -  iommod,iommc,iommc4,iogro,iomol2,iomae,iocif,ioxxx,ioins,
         -  ionxyz,iosxyz,iosxyzrq,iograsp,iofull,lext(19),crdext(19)
          character*1 ans,modtyp
          character*2 ATD4typ
          character*80 question
          dimension c12(3),iadef(3)
          data ia4 /0/
          character*21 ngdefnum
          data ngdefnum /'Defining neighbour # '/,ATD4typ /'  '/
          if (inpcrdtyp .eq. iomol2) then
            print *,'Sorry, molecule editing with mol2 format is not ',
         -    'implemented'
             return
          end if
          call setcol(inpcrdtyp,ncol,idcol,ialtcol,iinscol,
         -  inamcol1,inamcol2,irescol1,irescol2,iccol1,iccol2,
         -  iresncol1,iresncol2,iseqncol1,iseqncol2,isegcol1,isegcol2,
         -  iresidcol1,iresidcol2,iqcol1,iqcol2,ipotcol1,ipotcol2,
         -  iocccol1,iocccol2,ichemcol1,ichemcol2,nrescol,nresncol,
         -  nsegcol,nnamcol,iofull)
          chargech=0.0
          iatnoadd=0
          do while (.true.)
            ifail=0
            atnam='    '
            call quiz(modtyp,iansmut,' ',' ',0,'modification type',17,
         -    0,5,6,89)
            if (modtyp .eq. 'm') then
              call getint('Atom number to replace',22,0,1,nslt,ia,0)
              call listatom(line,index,iatno,ia,inpcrdtyp,iofull,
         -      'Atom to mutate',14,n,maxrec)
              question='Name'//' of the new atom'
              lq=20
              call getname(atnam,len,question,lq,4,'',0,0,0,3)
              iatno(ia)=ianum(atnam,1,nnamcol)
              if (nneig(ia) .eq. 1) then
                ia1=ineig(1,ia)
                call listatom(line,index,iatno,ia1,inpcrdtyp,iofull,
         -        'Root atom     ',14,n,maxrec)
                call getint('Valence',7,nval(iatno(ia)),1,8,newn,0)
                call defaultbondl(newn,nneig(ia1),iatno(ia),iatno(ia1),
         -        r12)
                call getreal('New distance',12,r12,rij,1,0)
                call arrdiff(c(1,ia),c(1,ia1),c12,3)
                rnorm=sqrt(scprod(c12,c12))
                do k=1,3
                  c(k,ia)=c(k,ia1)+rij*c12(k)/rnorm
                end do
              else
                write (6,1001) ia
              end if
            else if (modtyp .eq. 'a' .or. modtyp .eq. 'b' .or.
         -           modtyp .eq. 't') then
              call getint(
         -      'Index of the atom that the new atom is bonded to',48,
         -      0,1,nslt,ia1,0)
              call listatom(line,index,iatno,ia1,inpcrdtyp,iofull,
         -      'Atom R1         ',16,n,maxrec)
              question='Name'//' of the new atom'
              lq=20
              call getname(atnam,len,question,lq,4,'',0,0,0,3)
              iatnoadd=ianum(atnam,1,nnamcol)
              if (iatno(ia1) .eq. 1) then
                write (6,1002) ia1
                ifail=1
              end if
              if (modtyp .eq. 'a') then
                write (6,1000) atnam(1:len)
                call findroot('R2',ia1,0,iatno,nneig,ineig,line,index,
         -        inpcrdtyp,iofull,ia2,n,ifail,maxneig,maxrec)
                call findroot('R3',ia2,ia1,iatno,nneig,ineig,line,index,
         -        inpcrdtyp,iofull,ia3,n,ifail,maxneig,maxrec)
                if (ifail .eq. 0) then
                  call getint('Valence',7,nval(iatnoadd),1,8,newn,0)
                  call defaultbondl(nneig(ia1)+1,newn,iatno(ia1),iatnoadd,
         -          r12)
                  call getreal('R1-X distance',13,r12,rij,1,0)
    100           call quiz(ans,ians,' ',' ',0,'R2-R1-X angle',13,0,5,6,0)
                  if (ans .eq. 'i' .or. ans .eq. 'I') then
                    call getreal('R2-R1-X angle',13,999999.0,aijk,1,0)
                  else if (ans .eq. '3') then
                    aijk=180.0-acos(1.0/3.0)*180.0/pi
                  else if (ans .eq. '2') then
                    aijk=120.0
                  else if (ans .eq. '1') then
                    aijk=180.0
                  else
                    print *,'Invalid answer'
                    go to 100
                  end if
    200           call quiz(ans,ians,' ',' ',0,
         -          'R3-R2-R1-X torsion angle',24,0,5,6,0)
                  if (ans .eq. 'i' .or. ans .eq. 'I') then
                    call getreal('R3-R2-R1-X torsion',18,999999.0,tijkl,0,0)
                  else if (ans .eq. 'c' .or. ans .eq. 'C') then
                    tijkl=0.0
                  else if (ans .eq. 't' .or. ans .eq. 'T') then
                    tijkl=180.0
                  else if (ans .eq. '+') then
                    tijkl=60.0
                  else if (ans .eq. '-') then
                    tijkl=-60.0
                  else if (ans .eq. 'p' .or. ans .eq. 'P') then
                    tijkl=120.0
                  else if (ans .eq. 'm' .or. ans .eq. 'M') then
                    tijkl=-120.0
                  else
                    print *,'Invalid answer'
                    go to 200
                  end if
                  ia=n+1
                  call addatom(1,c(1,ia3),c(1,ia3),c(1,ia2),c(1,ia1),
         -          c(1,ia),rij,aijk,tijkl,0.0,ia,pi,1,ifail)
                end if
              else if (modtyp .eq. 'b' .or. modtyp .eq. 't') then
                if (modtyp .eq. 'b') nndef=2
                if (modtyp .eq. 't') nndef=3
                call zeroiti(iadef,0,3)
                if (nneig(ia1) .ne. nndef)
         -        write (6,1007) ia1,nneig(ia1),nndef
                do ind=1,nndef
                  write (ngdefnum(21:21),1003) ind
                  if (ind .le. nneig(ia1)) then
                    iadef(ind)=ineig(ind,ia1)
                    call listatom(line,index,iatno,iadef(ind),inpcrdtyp,
         -            iofull,ngdefnum,21,n,maxrec)
                   else
    C               No bonded neighbor - ask for one
                    write (6,1004) ind
                    call getint('Index of the next definig atom',30,0,1,
         -            nslt,iadef(ind),0)
                    call listatom(line,index,iatno,iadef(ind),inpcrdtyp,
         -            ioins,ngdefnum,21,n,maxrec)
                   end if
                end do
                ia2=iadef(1)
                ia3=iadef(2)
                ia4=iadef(3)
                if (ia4 .eq. 0) ia4=ia3
                call getint('Valence',7,nval(iatnoadd),1,8,newn,0)
                call defaultbondl(nneig(ia1)+1,newn,iatno(ia1),iatnoadd,r12)
                call getreal('R1-X distance',13,r12,rij,1,0)
                bend=0.0
                if (nndef .eq. 2) call getreal(
         -        'Angle between R1-X and the negative bisector',44,0.0,
         -        bend,1,000)
                ia=n+1
                call addatom(nndef,c(1,ia4),c(1,ia3),c(1,ia2),c(1,ia1),
         -        c(1,ia),rij,aijk,tijkl,bend,ia,pi,1,ifail)
              end if
              if (ifail .eq. 0) then
                natomadd=natomadd+1
                if (lineread .gt. index(n)) then
                  do im=lineread+1,index(n)+2,-1
                    line(im)=line(im-1)
                  end do
                  lineread=lineread+1
                end if
                n=n+1
                nslt=nslt+1
                index(n)=index(n-1)+1
                line(index(n))=line(index(ia1))
                nneig(n)=1
                ineig(1,n)=ia1
                nneig(ia1)=nneig(ia1)+1
                ineig(nneig(ia1),ia1)=n
                isegno(n)=isegno(ia1)
                iresno(n)=iresno(ia1)
                call blankout(line(index(n)),iresncol1,iresncol2)
                icolw=iresncol1
                lenw=iresncol2-iresncol1+1
                call writeint(line(index(n)),icolw,iresno(n),lenw)
                call rightadjustline(line(index(n)),iresncol1,iresncol2)
                if (iseqncol2 .gt. iseqncol1) then
                  call blankout(line(index(n)),iseqncol1,iseqncol2)
                  icolw=iseqncol1
                  lenw=iseqncol2-iseqncol1+1
                  read (line(index(n-1))(iseqncol1:iseqncol2),*) lastseq
                  call writeint(line(index(n)),icolw,lastseq+1,lenw)
                  call rightadjustline(line(index(n)),iseqncol1,iseqncol2)
                end if
                if (line(index(n))(77:78) .ne. '  ' .and.
         -          iatnoadd .gt. 0) line(index(n))(77:78)=iatnm2(iatnoadd)
              end if
            else if (modtyp .eq. 'h') then
    
            else if (modtyp .eq. 'c') then
    C         Create new bond
              call getint('Index of the first atom of the new bond',39,
         -      0,1,nslt,ia1,0)
              call listatom(line,index,iatno,ia1,inpcrdtyp,iofull,
         -          ' ',1,n,maxrec)
              call getint('Index of the second atom of the new bond',40,
         -      0,1,nslt,ia2,0)
              call listatom(line,index,iatno,ia2,inpcrdtyp,iofull,
         -          ' ',1,n,maxrec)
              ibonded=0
              do ia=1,nneig(ia1)
                if (ia2 .eq. ineig(ia,ia1)) ibonded=1
              end do
              if (ibonded .eq. 1) then
                print *,'These atoms are already bonded'
              else
                nneig(ia1)=nneig(ia1)+1
                nneig(ia2)=nneig(ia2)+1
                ineig(nneig(ia1),ia1)=ia2
                ineig(nneig(ia2),ia2)=ia1
              end if
            else if (modtyp .eq. 'q') then
              if (natomadd .gt. 0) then
                print *,natomadd,' atoms were added'
              end if
              if (icharges .gt. 0) write (6,1006) chargech
              return
            end if
            if (ifail .eq. 0) then
              line(index(ia))(inamcol1:inamcol2)=atnam(1:nnamcol)
              if (ipotcol1 .le. ipotcol2) then
                question='Potential label'//' of the new atom'
                lq=31
                pflab='    '
                call getname(pflab,len,question,lq,ipotcol2-ipotcol1+1,'',0,
         -        0,0,0)
                line(index(ia))(ipotcol1:ipotcol2)=
         -        pflab(1:ipotcol2-ipotcol1+1)
              end if
              if (icharges .gt. 0) then
                if (modtyp .eq. 'm') then
                  read (line(index(ia))(iqcol1:iqcol2),*) qprev
                  chargech=chargech-qprev
                end if
                call getreal('Charge',6,999999.0,q,0,0)
                if (q .lt. 0.0) q=q-0.000001
                if (q .gt. 0.0) q=q+0.000001
                call putreal(line(index(ia))(iqcol1:iqcol2),iqcol2-iqcol1+1,
         -        q,4)
                chargech=chargech+q
                charge(ia)=q
              end if
              if (inpcrdtyp .eq.  ioa4pdb) then
                call getname(ATD4typ,len,'Autodock-4 atom type',20,2,'',0,0,
         -        0,0)
                line(index(ia))(78:79)=ATD4typ
              end if
              if (inpcrdtyp .eq. iocha) then
                icinc=0
                if (n .ge. 1000000) icinc=1
                write (line(index(ia))(iccol1+icinc:iccol2+icinc),1011)
         -        (c(k,ia),k=1,3)
              else if (inpcrdtyp .eq. iochaex) then
                write (line(index(ia))(iccol1:iccol2),1015) (c(k,ia),k=1,3)
              else if (inpcrdtyp .eq. iommc) then
                write (line(index(ia))(iccol1:iccol2),1011) (c(k,ia),k=1,3)
              else if (ispdb(inpcrdtyp) .gt. 0) then
                write (line(index(ia))(iccol1:iccol2),1012) (c(k,ia),k=1,3)
              else if (inpcrdtyp .eq. iommod) then
                write (line(index(ia))(iccol1:iccol2),1013) (c(k,ia),k=1,3)
              else if (inpcrdtyp .eq. iogro) then
                write (line(index(ia))(iccol1:iccol2),1012)
         -        (c(k,ia)/10.0,k=1,3)
              else if (inpcrdtyp .eq. ioins) then
                write (line(index(ia))(iccol1:iccol2),1014) (c(k,ia),k=1,3)
              end if
            end if
          end do
    1000  format(' The position of the new atom ',a,' will be specified by',
         -  ' specifing ',/,' a sequence of bonded atoms R3-R2-R1-X,',
         -  ' the distance r(R1-X),',/,
         -  ' the angle a(R2-R1-X) and the torsion t(R3-R2-R1-X)')
    1001  format(' Atom',i5,' has more than one bond - position will not ',
         -  'change')
    1002  format(' Atom',i5,' is a hydrogen - can not attach to it')
    1003  format(i1)
    1004  format(' Neighbor #',i1,' is undefined')
    
    1006  format(' Total charge changed by ',f7.4)
    1007  format(' NOTE: atom',i6,' has',i2,' bonded neighbours ',
         -  '(instead of',i2,')')
    1011  format(3f10.5)
    1012  format(3f8.3)
    1013  format(3f12.5)
    1014  format(3f15.9)
    1015  format(3f10.10)
          end
          subroutine retroinverso(c,iat1,iat2,nslt,iatnum,line,index,chain,
         -  nsegm,iaincr,inamcol1,inamcol2,iresncol1,iresncol2,irescol1,
         -  irescol2,pi,ifail,nneig,ineig,mask,iout,maxng,maxrec)
          dimension c(3,nslt),iatnum(nslt),index(nslt),nneig(nslt),
         -  ineig(maxng,nslt),mask(nslt)
          dimension cn(3),ca(3),cb(3),cd(3),cg(3),cm_na(3),cm_bd(3),
         -  e(3),rh(3),cc(3),ch(3),chn(3),ch23(3),con(3),co1(3),cco(3),
         -  oco(3),ccc(3),ch1(3),ch2(3),ch3(3),cnn(3),cnh(3),co(3)
          character*1 chain,ans
          character*3 resnam3
          character*4 atnam4
          character*8 atnam,resnam,resnamn,hnname
          character* 132 line(maxrec)
          call quiz(ans,itertyp,' ',' ',0,'terminus type',13,0,5,6,00)
          lnam=inamcol2-inamcol1+1
          ifail=0
          nres=0
          nresok=0
          icfound=0
          iofound=0
          infound=0
          ihfound=0
          iafound=0
          inf=0
          iaf=0
          ia2=iat2
          frocc=1.0
          bfac=0.0
          rco=1.4
          rcn=1.3
          rcc=1.6
          rnh=0.96
          rch=1.1
          resnam3='   '
          resnamn='        '
          if (chain .eq. ' ') chain='A'
          call indexit(mask,1,nslt,0)
          npro=0
          nwr=0
          ia=1
          icharmm=0
          iamber=0
          iambinc=1
          read (line(index(1))(iresncol1:iresncol2),*,ERR=999) iresninc
          if (itertyp .eq. 3) iresninc=iresninc-1
          iresninc=iresninc-1
          do ia=iat2,iat1,-1
            atnam(1:lnam)=line(index(ia))(inamcol1:inamcol2)
            call leftadjust4(atnam(1:4),atnam4)
            if (lnam .eq. 4) atnam(5:8)='    '
            if (lnam .gt. 4) call leftadjustn(atnam,atnam,lnam)
            if (atnam4 .eq. 'C   ' .or. atnam4 .eq. ' C   ') then
              icfound=ia
              call trnsfr(cc,c(1,ia),3)
            else if (atnam4 .eq. 'O   ' .or. atnam4 .eq. 'O1   ' .or.
         -           atnam4 .eq. 'OT1  ') then
              iofound=ia
              call trnsfr(co,c(1,ia),3)
            else if (atnam4 .eq. 'N   ') then
              infound=ia
              call trnsfr(cn,c(1,ia),3)
            else if (atnam4 .eq. 'CA  ') then
              iafound=ia
              call trnsfr(ca,c(1,ia),3)
            else if (atnam4 .eq. 'H   ' .or. atnam4 .eq. 'HN   ' .or.
         -           atnam4 .eq. 'H1  ') then
              ihfound=ia
              hnname=atnam
              call trnsfr(ch,c(1,ia),3)
            end if
            if (ia .eq. iat1) then
              iresn=-1
            else
              read (line(index(ia-1))(iresncol1:iresncol2),*,ERR=999) iresn
              if (ia .eq. iat2) ireso=iresn
            end if
            if (iresn .ne. ireso) then
              nres=nres+1
              ia1=ia
              resnam(1:irescol2-irescol1+1)=
         -      line(index(ia1))(irescol1:irescol2)
              ndel_extra=0
              if (iresn .eq. -1) then
                nhf=0
                do inn=1,nneig(infound)
                  in=ineig(inn,infound)
                  atnam(1:lnam)=line(index(in))(inamcol1:inamcol2)
                  call leftadjust4(atnam(1:4),atnam4)
                  if (atnam4 .eq. 'H2   ' .or. atnam4 .eq. 'H3  ') then
                    mask(in)=0
                    ndel_extra=ndel_extra+1
                  end if
                end do
              end if
              if (ihfound .eq. 0) then
               if (resnam(1:3) .eq. 'PRO') then
                 if (nneig(infound) .ne. 3) then
                   write (6,1004) infound,nneig(infound),
         -           (ineig(i,infound),i=1,nneig(infound))
                   stop
                 else
                  call addatom(2,cg,c(1,ineig(2,infound)),
         -          c(1,ineig(1,infound)),cn,ch,rnh,0.0,0.0,0.0,1,pi,1,
         -          ifail)
                 end if
               else
                  print *,'NOTE: Residue ',ireso,' is missing the amide H'
                  nht=0
                  do iaa=ia1,ia2
                    atnam(1:lnam)=line(index(iaa))(inamcol1:inamcol2)
                    call leftadjust4(atnam(1:4),atnam4)
                    if (atnam4 .eq. 'H1  ' .or. atnam4 .eq. 'H2  ' .or.
         -              atnam4 .eq. 'H3  ') nht=nht+1
                  end do
                  if (nht .gt. 0) then
                    write (6,1002)
                    ifail=1
                    return
                  end if
                  if (iresn .eq. -1) then
                    do k=1,3
                      ccnk=(cn(k)+ca(k))/2.0
                      co1(k)=2.0*ccnk-cc(k)
                    end do
                  else
                    iaa=ia
                    notfound=1
                    do while (iaa .gt. 1 .and. notfound .eq. 1)
                      atnam(1:lnam)=line(index(iaa))(inamcol1:inamcol2)
                      call leftadjust4(atnam(1:4),atnam4)
                      if (atnam4 .eq. 'C   ') then
                        notfound=0
                        call trnsfr(co1,c(1,iaa),3)
                      end if 
                      iaa=iaa-1
                    end do
                  end if
                  call addatom(2,cg,co1,ca,cn,ch,rnh,0.0,0.0,0.0,1,pi,1,
         -          ifail)
                end if
              else
                mask(ihfound)=0
              end if
              if (nres .eq. 1) then
                do inn=1,nneig(icfound)
                  in=ineig(inn,icfound)
                  atnam(1:lnam)=line(index(in))(inamcol1:inamcol2)
                  call leftadjust4(atnam(1:4),atnam4)
                  if (atnam4 .eq. 'O2  ' .or. atnam4 .eq. 'OT2 ') then
                    mask(in)=0
                    ndel_extra=ndel_extra+1
                  end if
                end do
                do i=ia1,ia2
                  atnam(1:lnam)=line(index(i))(inamcol1:inamcol2)
                  call leftadjust4(atnam(1:4),atnam4)
                  if (atnam4 .eq. '1HH3' .or. atnam4 .eq. '1HH3' .or.
         -            atnam4 .eq. '3HH3' .or. atnam4 .eq. 'CH3 ' .or.
         -            atnam4 .eq. 'HT1 ' .or. atnam4 .eq. 'HT2 ' .or.
         -            atnam4 .eq. 'HT3 ' .or. atnam4 .eq. 'CAT ' .or.
         -            atnam4 .eq. 'NT  ' .or. atnam4 .eq. 'HNT ') then
                    mask(i)=0
                    ndel_extra=ndel_extra+1
                  end if
                  if (atnam4 .eq. 'CAT ') icharmm=1
                  if (atnam4 .eq. 'CH3 ') iamber=1
                end do
                if (iamber  .eq. 1) then
                  iambinc=0
                  do i=ia1,ia2
                    atnam(1:lnam)=line(index(i))(inamcol1:inamcol2)
                    call leftadjust4(atnam(1:4),atnam4)
                    if (atnam4 .eq. 'N   ' .or. atnam4 .eq. 'H   ') then
                      mask(i)=0
                      ndel_extra=ndel_extra+1
                    end if
                  end do
                  if (iafound*icfound*iofound .eq. 0 .and.
         -            iamber .eq. 1) then
                    i=iat2
                    iresr=iresn
                    do while (i .gt. iat1 .and. iresr .gt. iresn-1)
                      atnam(1:lnam)=line(index(i))(inamcol1:inamcol2)
                      call leftadjust4(atnam(1:4),atnam4)
                      if (atnam4 .eq. 'C   ') then
                        icfound=i
                        call trnsfr(cc,c(1,i),3)
                      else if (atnam4 .eq. 'O   ') then
                        iofound=i
                        call trnsfr(co,c(1,i),3)
                      else if (atnam4 .eq. 'CA  ') then
                        iafound=i
                        call trnsfr(ca,c(1,i),3)
                        resnam3=line(index(i))(irescol1:irescol1+2)
                      end if          
                      i=i-1
                      read (line(index(i))(iresncol1:iresncol2),*,
         -              ERR=999) iresr
                    end do
                  end if
                end if
                if (iamber .eq. 0) resnam3=resnam(1:3)
                if (itertyp .eq. 2) then
                  ang=angleijk(c,nslt,iafound,icfound,iofound,6)*180.0/pi
                  dang1=dihangl(c,iofound,icfound,iafound,infound,ihfound,
         -          maxrec)*180.0/pi
                  dang2=dang1+120.0
                  dang3=dang1-120.0
                  call addatom(1,cg,cn,ca,cc,ch23,rnh,ang,dang2,0.0,1,pi,1,
         -          ifail)
                  nwr=nwr+1
                  write (iout,1000) iaincr+nwr,' H2 ',resnam3,chain,
         -          iresninc+nres,ch23,frocc,bfac
                  call addatom(1,cg,cn,ca,cc,ch23,rnh,ang,dang3,0.0,1,pi,1,
         -          ifail)
                  nwr=nwr+1
                  write (iout,1000) iaincr+nwr,' H3 ',resnam3,chain,
         -          iresninc+nres,ch23,frocc,bfac
                  ndel_extra=ndel_extra-2
                  iresninc=iresninc-iamber
                else if (itertyp .eq. 3) then
                  call addatom(2,cg,ca,co,cc,cco,rcn,0.0,0.0,57.0,1,pi,1,
         -          ifail)
                  call addatom(1,cg,ca,cc,cco,oco,rco,120.0,90.0,0.0,1,
         -          pi,1,ifail)
                  call addatom(2,cg,oco,cc,cco,ccc,rcc,0.0,0.0,0.0,1,
         -          pi,1,ifail)
                  call addatom(1,cg,cn,cco,ccc,ch1,rch,104.0,0.0,0.0,1,
         -          pi,1,ifail)
                  call addatom(1,cg,cn,cco,ccc,ch2,rch,104.0,120.0,0.0,1,
         -          pi,1,ifail)
                  call addatom(1,cg,cn,cco,ccc,ch3,rch,104.0,-120.0,0.0,1,
         -          pi,1,ifail)
                  nwr=nwr+1
                  write (iout,1000) iaincr+nwr,'1HH3','ACE',chain,
         -          iresninc+nres-iambinc,ch1,frocc,bfac
                  nwr=nwr+1
                  write (iout,1000) iaincr+nwr,'2HH3','ACE',chain,
         -          iresninc+nres-iambinc,ch2,frocc,bfac
                  nwr=nwr+1
                  write (iout,1000) iaincr+nwr,'3HH3','ACE',chain,
         -          iresninc+nres-iambinc,ch3,frocc,bfac
                  nwr=nwr+1
                  write (iout,1000) iaincr+nwr,' CH3','ACE',chain,
         -          iresninc+nres-iambinc,ccc,frocc,bfac
                  nwr=nwr+1
                  write (iout,1000) iaincr+nwr,' C  ','ACE',chain,
         -          iresninc+nres-iambinc,cco,frocc,bfac
                  nwr=nwr+1
                  write (iout,1000) iaincr+nwr,' O  ','ACE',chain,
         -          iresninc+nres-iambinc,oco,frocc,bfac
                else if (itertyp .eq. 4) then
                  call addatom(2,cg,ca,co,cc,cco,rcn,0.0,0.0,57.0,1,pi,1,
         -          ifail)
                  call addatom(1,cg,ca,cc,cco,oco,rco,120.0,90.0,0.0,1,
         -          pi,1,ifail)
                  call addatom(2,cg,oco,cc,cco,ccc,rcc,0.0,0.0,0.0,1,
         -          pi,1,ifail)
                  call addatom(1,cg,cn,cco,ccc,ch1,rch,104.0,0.0,0.0,1,
         -          pi,1,ifail)
                  call addatom(1,cg,cn,cco,ccc,ch2,rch,104.0,120.0,0.0,1,
         -          pi,1,ifail)
                  call addatom(1,cg,cn,cco,ccc,ch3,rch,104.0,-120.0,0.0,1,
         -          pi,1,ifail)
                  nwr=nwr+1
                  write (iout,1000) iaincr+nwr,' HY1',resnam3,chain,
         -          iresninc+nres,ch1,frocc,bfac
                  nwr=nwr+1
                  write (iout,1000) iaincr+nwr,' HY2',resnam3,chain,
         -          iresninc+nres,ch2,frocc,bfac
                  nwr=nwr+1
                  write (iout,1000) iaincr+nwr,' HY3',resnam3,chain,
         -          iresninc+nres,ch3,frocc,bfac
                  nwr=nwr+1
                  write (iout,1000) iaincr+nwr,' CAY',resnam3,chain,
         -          iresninc+nres,ccc,frocc,bfac
                  nwr=nwr+1
                  write (iout,1000) iaincr+nwr,' CY ',resnam3,chain,
         -          iresninc+nres,cco,frocc,bfac
                  nwr=nwr+1
                  write (iout,1000) iaincr+nwr,' OY ',resnam3,chain,
         -          iresninc+nres,oco,frocc,bfac
                  if (iamber .eq. 1) iresninc=iresninc-1
                end if
              end if
              if (iresn .eq. -1) then
                do i=ia1,ia2
                  atnam(1:lnam)=line(index(i))(inamcol1:inamcol2)
                  call leftadjust4(atnam(1:4),atnam4)
                  if (atnam4 .eq. '1HH3' .or. atnam4 .eq. '1HH3' .or.
         -            atnam4 .eq. '3HH3' .or. atnam4 .eq. 'CH3 ' .or.
         -            atnam4 .eq. 'HY1 ' .or. atnam4 .eq. 'HY2 ' .or.
         -            atnam4 .eq. 'HY3 ' .or. atnam4 .eq. 'CAY ' .or.
         -            atnam4 .eq. 'CY  ' .or. atnam4 .eq. 'OY  ') then
                    mask(i)=0
                    ndel_extra=ndel_extra+1
                  end if
                  if (atnam4 .eq. 'CAY ') icharmm=1
                  if (atnam4 .eq. 'CH3 ') iamber=1
                end do
              end if
              if (iamber .eq. 1) resnamn(1:irescol2-irescol1+1)=
         -      line(index(ia1-1))(irescol1:irescol2)
              if (iamber .eq. 0 .or. (nres .gt. 1 .and. iresn .ne. -1)) then
                if (icfound*infound*iofound*iafound .eq. 0) then
                   print *,'ERROR: Residue ',ireso,
         -         ' is missing N, C, CA or O'
                   ifail=1
                   return
                end if
                hnname=' N      '
                mask(icfound)=0
                mask(infound)=0
                mask(iafound)=0
                mask(iofound)=0
                if (resnam(1:3) .eq. 'PRO') then
                  npro=npro+1
                  ibfound=0
                  idfound=0
                  igfound=0
                  ihfound=0
                  do i=ia1,ia2
                    atnam(1:lnam)=line(index(i))(inamcol1:inamcol2)
                    call leftadjust4(atnam(1:4),atnam4)
                    if (atnam4 .eq. 'CB  ') then
                      ibfound=i
                    else if (atnam4 .eq. 'CD  ') then
                      idfound=i
                    else if (atnam4 .eq. 'CG  ') then
                      igfound=i
                    else if (atnam4 .eq. 'HA  ') then
                      ihfound=i
                      call trnsfr(ch,c(1,ihfound),3)
                    end if
                  end do
                  if (ibfound*idfound*igfound*ihfound .eq. 0) then
                    print *,'Proline residue ',ireso,
         -            ' has no CB, CD, CG or HA'
                    ifail=1
                    return
                  end if
                  nwr=nwr+1
                  write (iout,1000) iaincr+nwr,' N  ','PRO',chain,
         -          iresninc+nres,(c(k,icfound),k=1,3),frocc,bfac
                  call trnsfr(cn,c(1,icfound),3)
                  nwr=nwr+1
                  write (iout,1000) iaincr+nwr,' CA ','PRO',chain,
         -          iresninc+nres,(c(k,iafound),k=1,3),frocc,bfac
                  call trnsfr(ca,c(1,iafound),3)
                  nwr=nwr+1
                  write (iout,1000) iaincr+nwr,' CB ','PRO',chain,
         -          iresninc+nres,(c(k,ibfound),k=1,3),frocc,bfac
                  call trnsfr(cb,c(1,ibfound),3)
                  nwr=nwr+1
                  write (iout,1000) iaincr+nwr,' CD ','PRO',chain,
         -          iresninc+nres,(c(k,iofound),k=1,3),frocc,bfac
                  call trnsfr(cd,c(1,iofound),3)
                  phirad=dihangl(c,iofound,icfound,iafound,ibfound,0,maxrec)
         -          *180.0/pi
                  if (abs(phirad) .gt. 45.0) then
                    print *,'NOTE: Proline ring # ',iresninc+nres,
         -            ' will be wide open'
                    call addatom(1,cd,cn,ca,cb,cg,1.0,105.0,phirad,0.0,0,pi,
         -            1,ifail)
                  else
                    do k=1,3
                      cm_na(k)=(c(k,infound)+ca(k))/2.0
                    end do
                    dcg=sqrt(dist2(c(1,igfound),cm_na))
                    do k=1,3
                      cm_na(k)=(cn(k)+ca(k))/2.0
                      cm_bd(k)=(cb(k)+cd(k))/2.0
                    end do
                    call arrdiff(cm_bd,cm_na,e,3)
                    enorm=sqrt(scprod(e,e))
                    do k=1,3
                      cg(k)=cm_na(k)+dcg*e(k)/enorm
                    end do
                  end if
                  nwr=nwr+1
                  write (iout,1000) iaincr+nwr,' CG ','PRO',chain,
         -          iresninc+nres,cg,frocc,bfac
                  call addatom(2,e,ca,cg,cb,rh,1.0,0.0,0.0,57.,0,pi,1,ifail)
                  nwr=nwr+1
                  write (iout,1000) iaincr+nwr,' HB2','PRO',chain,
         -          iresninc+nres,rh,frocc,bfac
                  call addatom(2,e,ca,cg,cb,rh,1.0,0.0,0.,-57.,0,pi,1,ifail)
                  nwr=nwr+1
                  write (iout,1000) iaincr+nwr,' HB3','PRO',chain,
         -          iresninc+nres,rh,frocc,bfac
                  call addatom(2,e,cb,cd,cg,rh,1.0,0.0,0.0,57.,0,pi,1,ifail)
                  nwr=nwr+1
                  write (iout,1000) iaincr+nwr,' HG2','PRO',chain,
         -          iresninc+nres,rh,frocc,bfac
                  call addatom(2,e,cb,cd,cg,rh,1.0,0.0,0.,-57.,0,pi,1,ifail)
                  nwr=nwr+1
                  write (iout,1000) iaincr+nwr,' HG3','PRO',chain,
         -          iresninc+nres,rh,frocc,bfac
                  call addatom(2,e,cn,cg,cd,rh,1.0,0.0,0.0,57.,0,pi,1,ifail)
                  nwr=nwr+1
                  write (iout,1000) iaincr+nwr,' HD2','PRO',chain,
         -          iresninc+nres,rh,frocc,bfac
                  call addatom(2,e,cn,cg,cd,rh,1.0,0.0,0.,-57.,0,pi,1,ifail)
                  nwr=nwr+1
                  write (iout,1000) iaincr+nwr,' HD3','PRO',chain,
         -          iresninc+nres,rh,frocc,bfac
                  nwr=nwr+1
                  write (iout,1000) iaincr+nwr,' HA ','PRO',chain,
         -          iresninc+nres,(c(k,ihfound),k=1,3),frocc,bfac
                  nwr=nwr+1
                  write (iout,1000) iaincr+nwr,' C  ','PRO',chain,
         -          iresninc+nres,(c(k,infound),k=1,3),frocc,bfac
                  nwr=nwr+1
                  write (iout,1000) iaincr+nwr,' O  ','PRO',chain,
         -          iresninc+nres,(c(k,idfound),k=1,3),frocc,bfac
                else
                  nsc=ia2-ia1-4-ndel_extra
                  rco=sqrt(dist2(c(1,icfound),c(1,iofound)))
                  rnh=sqrt(dist2(c(1,infound),ch))
                  nwr=nwr+1
                  write (iout,1000) iaincr+nwr,' N  ',resnam(1:3),chain,
         -          iresninc+nres,(c(k,icfound),k=1,3),frocc,bfac
                  call rescale_bl(c(1,icfound),c(1,iofound),chn,rco,rnh)
                  nwr=nwr+1
                  if (nres .eq. 1 .and. itertyp .eq. 2) then
                    write (iout,1000) iaincr+nwr,' H1 ',resnam(1:3),chain,
         -            iresninc+nres,chn,frocc,bfac
                  else
                    write (iout,1000) iaincr+nwr,' H  ',resnam(1:3),chain,
         -            iresninc+nres,chn,frocc,bfac
                  end if
                  nwr=nwr+1
                  write (iout,1000) iaincr+nwr,' CA ',resnam(1:3),chain,
         -          iresninc+nres,(c(k,iafound),k=1,3),frocc,bfac
                  do i=ia1,ia2
                    if (mask(i) .gt. 0) then
                      nwr=nwr+1
                      write (iout,1000) iaincr+nwr,
         -              line(index(i))(inamcol1:inamcol2),resnam(1:3),chain,
         -              iresninc+nres,(c(k,i),k=1,3),frocc,bfac
                    end if
                  end do
                  write (iout,1000) iaincr+nwr,' C  ',resnam(1:3),chain,
         -          iresninc+nres,(c(k,infound),k=1,3),frocc,bfac
                  call rescale_bl(c(1,infound),ch,con,rnh,rco)
                  nwr=nwr+1
                  if ((iresn .eq. -1 .or. resnamn(1:3) .eq. 'ACE') .and.
         -             itertyp .eq. 2) then
                    write (iout,1000) iaincr+nwr,' OT1',resnam(1:3),chain,
         -            iresninc+nres,con,frocc,bfac
                  else
                    write (iout,1000) iaincr+nwr,' O  ',resnam(1:3),chain,
         -          iresninc+nres,con,frocc,bfac
                  end if
                end if
                inf=infound
                iaf=iafound
                icfound=0
                iofound=0
                infound=0
                ihfound=0
                iafound=0
                resnam3=resnam(1:3)
              end if
              ireso=iresn
              ia2=ia1-1
            end if
          end do
          if (itertyp .eq. 2) then
            call addatom(2,cg,con,c(1,iaf),c(1,inf),e,rco,0.0,0.0,
         -    0.0,0,pi,1,ifail)
            nwr=nwr+1
            write (iout,1000) iaincr+nwr,' OT2',resnam3,chain,
         -    iresninc+nres-iamber,e,frocc,bfac
          else if (itertyp .eq. 3) then
            call addatom(2,cg,ca,con,cn,cnn,rcn,0.0,0.0,0.0,1,pi,1,ifail)
            call addatom(1,cg,ca,cn,cnn,cnh,rnh,104.0,-120.0,0.0,1,
         -          pi,1,ifail)
            call addatom(2,cg,cn,cnh,cnn,ccc,rcn,0.0,0.0,0.0,1,pi,1,ifail)
            call addatom(1,cg,cn,cnn,ccc,ch1,rch,104.180,0.0,0.0,1,pi,1,
         -    ifail)
            call addatom(1,cg,cn,cnn,ccc,ch2,rch,104.0,120.0,0.0,1,pi,1,
         -    ifail)
            call addatom(1,cg,cn,cnn,ccc,ch3,rch,104.0,-120.0,0.0,1,pi,1,
         -    ifail)
            nwr=nwr+1
            write (iout,1000) iaincr+nwr,' N  ','NME',chain,
         -    iresninc+nres+iambinc,cnn,frocc,bfac
            nwr=nwr+1
            write (iout,1000) iaincr+nwr,' H  ','NME',chain,
         -    iresninc+nres+iambinc,cnh,frocc,bfac
            nwr=nwr+1
            write (iout,1000) iaincr+nwr,' CH3','NME',chain,
         -    iresninc+nres+iambinc,ccc,frocc,bfac
            nwr=nwr+1
            write (iout,1000) iaincr+nwr,'1HH3','NME',chain,
         -    iresninc+nres+iambinc,ch1,frocc,bfac
            nwr=nwr+1
            write (iout,1000) iaincr+nwr,'2HH3','NME',chain,
         -    iresninc+nres+iambinc,ch2,frocc,bfac
            nwr=nwr+1
            write (iout,1000) iaincr+nwr,'3HH3','NME',chain,
         -    iresninc+nres+iambinc,ch3,frocc,bfac
          else if (itertyp .eq. 4) then
            if (iamber .eq. 0) resnam3=resnam
            call addatom(2,cg,ca,con,cn,cnn,rcn,0.0,0.0,0.0,1,pi,1,ifail)
            call addatom(1,cg,ca,cn,cnn,cnh,rnh,104.0,-120.0,0.0,1,
         -          pi,1,ifail)
            call addatom(2,cg,cn,cnh,cnn,ccc,rcn,0.0,0.0,0.0,1,pi,1,ifail)
            call addatom(1,cg,cn,cnn,ccc,ch1,rch,104.0,0.0,0.0,1,pi,1,ifail)
            call addatom(1,cg,cn,cnn,ccc,ch2,rch,104.0,120.0,0.0,1,pi,1,
         -    ifail)
            call addatom(1,cg,cn,cnn,ccc,ch3,rch,104.0,-120.0,0.0,1,pi,1,
         -    ifail)
            nwr=nwr+1
            write (iout,1000) iaincr+nwr,' NT ',resnam3,chain,
         -    iresninc+nres-iamber,cnn,frocc,bfac
            nwr=nwr+1
            write (iout,1000) iaincr+nwr,' HNT',resnam3,chain,
         -    iresninc+nres-iamber,cnh,frocc,bfac
            nwr=nwr+1
            write (iout,1000) iaincr+nwr,' CAT',resnam3,chain,
         -    iresninc+nres-iamber,ccc,frocc,bfac
            nwr=nwr+1
            write (iout,1000) iaincr+nwr,' HT1',resnam3,chain,
         -    iresninc+nres-iamber,ch1,frocc,bfac
            nwr=nwr+1
            write (iout,1000) iaincr+nwr,' HT2',resnam3,chain,
         -    iresninc+nres-iamber,ch2,frocc,bfac
            nwr=nwr+1
            write (iout,1000) iaincr+nwr,' HT3',resnam3,chain,
         -    iresninc+nres-iamber,ch3,frocc,bfac
          end if
          if (npro .gt. 0) write (6,1001) npro
          return
    999   print *,'Illegal record in line'
          print *,line(index(ia))
    1000  format('ATOM  ',i5,1x,a4,1x,a3,1x,a1,i4,1x,3x,3f8.3,2f6.2)
    1001  format(' NOTE:',i3,' prolines were found - run a minimzation to ',
         -  'correct the distorsions')
    1002  format(' It looks like the input is not a single peptide',/,
         -  ' Run each peptide (chain) sperately')
    1003  format(' Use the Modif<Y> option to add amide hydrogens')
    1004  format(' PRO N (ia=',i7,') has no H but the # of bonds is not 3 ',
         -  'but',i3,/,' in:',10i7)
          end
          subroutine rescale_bl(c1,c2,cn,ro,rn)
          dimension c1(3),c2(3),cn(3)
          dimension e(3)
          do k=1,3
            e(k)=(c2(k)-c1(k))/ro
          end do
          do k=1,3
            cn(k)=c1(k)+e(k)*rn
          end do
          return
          end
          subroutine defaultbondl(nni1,nni2,ian1,ian2,r12)
          if (ian1 .lt. ian2) then
            nngi1=nni2
            nngi2=nni1
            iatn1=ian2
            iatn2=ian1
          else
            nngi1=nni1
            nngi2=nni2
            iatn1=ian1
            iatn2=ian2
          end if
          r12=999999.0
          if (iatn2 .eq. 1) r12=1.08
          if (iatn1 .eq. 6) then
              if (iatn2 .eq. 1) r12=1.08
              if (iatn2 .eq. 6) r12=1.53
            else if (nngi1 .eq. 2) then
          else if (iatn1 .eq. 7) then
              if (iatn2 .eq. 1) r12=1.01
              if (iatn2 .eq. 6) r12=1.47
              if (iatn2 .eq. 7) r12=1.25
          else if (iatn1 .eq. 8) then
            if (iatn2 .eq. 1) r12=0.96
            if (nngi1 .eq. 2) then
              if (iatn2 .eq. 6) r12=1.43
            else if (nngi1 .eq. 1) then
              if (iatn2 .eq. 6) r12=1.23
            end if
          else if (iatn1 .eq. 15) then
          else if (iatn1 .eq. 16) then
            if (iatn2 .eq. 1) r12=0.96
            if (iatn2 .eq. 6) r12=1.81
          end if
          return
          end
          subroutine findroot(lev,ia,ianoneig,iatno,nneig,ineig,line,index,
         -  inpcrdtyp,iofull,ia1,n,ifail,maxneig,maxrec)
          dimension index(n),iatno(n),nneig(n),ineig(maxneig,n)
          character*2 lev
          character* 132 line(maxrec)
          character*16 lab1,lab2
          dimension iahv(8)
          data lab1 /'Possible R2 atom'/,lab2 /'Index of atom R2'/,
         -  ia2heavy /0/
          if (ifail .gt. 0) return
          lab1(10:11)=lev
          lab2(15:16)=lev
          nnheavy=0
          if (nneig(ia) .eq. 0) then
            write (6,1001) ia,' '
            ifail=1
            return
          end if
          do ja=1,nneig(ia)
            ia1=ineig(ja,ia)
            if (iatno(ia1) .gt. 1 .and. ia1 .ne. ianoneig) then
              call listatom(line,index,iatno,ia1,inpcrdtyp,iofull,lab1,16,n,
         -      maxrec)
              nnheavy=nnheavy+1
              iahv(nnheavy)=ia1
              ia2heavy=ia1
            end if
          end do
          if (nnheavy .gt. 1) then
    100     call getint(lab2,16,0,1,n,ia1,46)
            nfound=0
            do ja=1,nnheavy
              if (ia1 .eq. iahv(ja)) nfound=1
            end do
            if (nfound .eq. 0) then
              write (6,1000) ia1,(iahv(ja),ja=1,nnheavy)
              go to 100
            end if
          else if (nnheavy .eq. 1) then
            ia1=ia2heavy
            write (6,1002) ia1,lev
          else
            write (6,1001) ia,' heavy atom '
            ifail=1
            return
          end if
          return
    1000  format(' ERROR: index',i6,' is not among indices ',8i6)
    1001  format(' ERROR: atom',i6,' has no',a,'neighbor')
    1002  format(' Atom',i6,' will be used for ',a)
          end
          subroutine listatom(line,index,iatno,ia,inpcrdtyp,iofull,lab,llab,
         -  n,maxrec)
          dimension index(n),iatno(n)
          character* 132 line(maxrec),ll
          character*(*) lab
          character*4 pflab
          character*12 qlab
          call setcol(inpcrdtyp,ncol,idcol,ialtcol,iinscol,
         -  inamcol1,inamcol2,irescol1,irescol2,iccol1,iccol2,
         -  iresncol1,iresncol2,iseqncol1,iseqncol2,isegcol1,isegcol2,
         -  iresidcol1,iresidcol2,iqcol1,iqcol2,ipotcol1,ipotcol2,
         -  iocccol1,iocccol2,ichemcol1,ichemcol2,nrescol,nresncol,
         -  nsegcol,nnamcol,iofull)
          ll=line(index(ia))
          pflab='    '
          qlab='            '
          nqcol=iqcol2-iqcol1+1
          if (nqcol .gt. 0) qlab(1:nqcol)=ll(iqcol1:iqcol2)
          nqcol=max0(1,nqcol)
          if (ipotcol1 .le. ipotcol2) pflab=ll(ipotcol1:ipotcol2)
          write (6,1000) lab(1:llab),ia,ll(inamcol1:inamcol2),
         -  ll(irescol1:irescol2),ll(iresncol1:iresncol2),
         -  iatno(ia),pflab,qlab(1:nqcol)
          return
    1000  format(1x,a,i6,' (',a,1x,a,') resnum=',a,' iatnum=',i2,
         -  ' pf=',a,' q=',a)
          end
          subroutine addatom(ityp,r4,r3,r2,r1,x,rij,aijk,tijkl,bend,ian,pi,
         -  iconv,ifail)
          dimension r4(3),r3(3),r2(3),r1(3),x(3)
          dimension c12(3),c13(3),c14(3),c23(3),x0(3),e2(3),e3(3),bs(3)
          dimension p(3,4)
          character*13 lab
          if (ian .gt. 0) then
            write (lab,1004) ian
            llab=13
          else
            lab=' X'
            llab=2
          end if
          if (iconv .eq. 1) then
            angconv=pi/180.0
            wconv=1.0
          else
            angconv=1.0
            wconv=180.0/pi
          end if
          if (ityp .eq. 1) then
            write (6,1001) lab(1:llab),rij,wconv*aijk,wconv*tijkl
            call arrdiff(r1,r2,c12,3)
            call arrdiff(r3,r2,c23,3)
            rnorm12=sqrt(scprod(c12,c12))
            rnorm23=sqrt(scprod(c23,c23))
            if (aijk .lt. 179.9) then
              if (abs(scprod(c12,c23)/(rnorm12*rnorm23)) .gt. 0.999) then
                print *,'Root atoms are colinear - new atom site is ',
         -        'undefined'
                ifail=ifail+1
              end if
              do k=1,3
                c12(k)=c12(k)/rnorm12
                c23(k)=c23(k)/rnorm23
                x0(k)=r1(k)-rij*c12(k)*cos(angconv*aijk)
              end do
              xproj=rij*sin(angconv*aijk)
              call vprd(c12,c23,e3)
              call vprd(e3,c12,e2)
              do k=1,3
                x(k)=x0(k)+xproj*(cos(angconv*tijkl)*e2(k)+
         -        sin(angconv*tijkl)*e3(k))
              end do
            else
              do k=1,3
                x(k)=r1(k)+rij*c12(k)/rnorm12
              end do
            end if
            call trnsfr(p(1,1),r3,3)
            call trnsfr(p(1,2),r2,3)
            call trnsfr(p(1,3),r1,3)
            call trnsfr(p(1,4),x,3)
          else if (ityp .eq. 2) then
            write (6,1002) lab(1:llab),rij
            call arrdiff(r1,r2,c12,3)
            call arrdiff(r1,r3,c13,3)
            rnorm12=sqrt(scprod(c12,c12))
            rnorm13=sqrt(scprod(c13,c13))
            do k=1,3
              c12(k)=c12(k)/rnorm12
              c13(k)=c13(k)/rnorm13
            end do
            colinear=scprod(c12,c13)
            if (colinear .lt. -0.999) then
              print *,'Atoms R2, R1, and R3 are colinear - can not use ',
         -      'bisector definition'
                ifail=ifail+1
            end if
            call arrsum(c12,c13,bs,3)
            rnormbs=sqrt(scprod(bs,bs))
            if (bend .eq. 0.0) then
              do k=1,3
                bs(k)=bs(k)*rij/rnormbs
                x(k)=r1(k)+bs(k)
              end do
            else
              call arrdiff(r2,r3,c23,3)
              call vprd(c23,bs,e3)
              rnorm3=sqrt(scprod(e3,e3))
              rnormbs=sqrt(scprod(bs,bs))
              bendr=bend*angconv
              do k=1,3
                x(k)=r1(k)+
         -        rij*(bs(k)*cos(bendr)/rnormbs+e3(k)*sin(bendr)/rnorm3)
              end do
            end if
          else if (ityp .eq. 3) then
            write (6,1003) lab(1:llab),rij
            call arrdiff(r1,r2,c12,3)
            call arrdiff(r1,r3,c13,3)
            call arrdiff(r1,r4,c14,3)
            rnorm12=sqrt(scprod(c12,c12))
            rnorm13=sqrt(scprod(c13,c13))
            rnorm14=sqrt(scprod(c14,c14))
            do k=1,3
              c12(k)=c12(k)/rnorm12
              c13(k)=c13(k)/rnorm13
              c14(k)=c14(k)/rnorm14
              bs(k)=c12(k)+c13(k)+c14(k)
            end do
            rnormbs=sqrt(scprod(bs,bs))
            if (rnormbs .lt. 0.01) then
              print *,'Atom R1 is in the plane of R2, R3, and R4 ',
         -      'can not use trisector definition'
                ifail=ifail+1
            end if
            do k=1,3
              bs(k)=bs(k)*rij/rnormbs
              x(k)=r1(k)+bs(k)
            end do
          end if
          return
    1001  format(' Adding',a,': r(X-R1)=',f7.4,' a(R2-R1-X)=',f7.2,
         -  ' t(R3-R2-R1-X)=',f7.2)
    1002  format(' Adding',a,': r(X-R1)=',f7.4,' along the negative ',
         -  'bisector of the R2-R1-R3 angle')
    1003  format(' Adding',a,': r(X-R1)=',f7.4,' along the negative ',
         -  'trisector of the',/,' pyramid with base R2, R3, and R3')
    1004  format(' atom #',i6)
          end
          subroutine select(line,nrecdel,idcol,asterisk,n,nslt,index,ixres,
         -  isegcol1,isegcol2,iseqncol1,iseqncol2,inamcol1,inamcol2,
         -  irescol1,irescol2,iqcol1,iqcol2,charge,iatno,nneig,ineig,
         -  indexdel,iout,maxneig,maxrec)
          dimension index(n),ixres(n),indexdel(n),charge(n),iatno(n),
         -  nneig(n),ineig(maxneig,n)
          character*1 asterisk,ans,lastans
          character*4 chainid,chainidn,atnam,atnamadj,resnam,resnamadj,
         -  namesel(200)
          character* 132 line(maxrec)
          data ans /' '/
          nsegcol=isegcol2-isegcol1+1
          nrescol=irescol2-irescol1+1
          if (iseqncol2 .gt. iseqncol1) then
            call readint(line(index(nslt)),iseqncol1,iseqncol2,iseqno,1,1,
         -    irerr)
          else
            iseqno=nslt
          end if
          maxresno=ixres(n)
          write (6,1000) iseqno,maxresno
          if (iout .gt. 0 .and. iout .ne. 6)
         -  write (iout,1000) iseqno,maxresno
          nkeep=0
          call zeroiti(indexdel,0,n)
          do while (.true.)
            nrecdel0=nrecdel
            lastans=ans
            call quiz(ans,ians,' ',' ',0,'selecting option',16,0,5,6,0)
            if (ans .eq. 'c' .or. ans .eq. 's') then
              if (nsegcol .gt. 0) then
                call blankout(chainid,1,nsegcol)
                if (ans .eq. 'c') then
                  call getname(chainid,len,'Chain ID to keep',16,4,'',0,0,0,
         -          0)
                  if (iout .gt. 0)
         -          write (iout,2002) 'Keep only',chainid(1:nsegcol)
                else if (ans .eq. 's') then
                  call getname(chainid,len,'Chain ID to drop',16,4,'',0,0,0,
         -          0)
                  if (iout .gt. 0)
         -          write (iout,2002) 'Drop',chainid(1:nsegcol)
                end if
              else
                print *,'This input format does not have chain ID'
              end if
            else if (ans .eq. 'k') then
              nkeep=nkeep+1
              if (nkeep .gt. 1) then
                write (6,2003)
                call askstop(1)
              else
                call getrange(ifst,999999,ilst,999999,i,0,'atom to keep',
         -        12,n,0)
              end if
              if (iout .gt. 0) write (iout,2000) 'atoms',' ',ifst,ilst
            else if (ans .eq. 'd') then
              call getrange(ifst,999999,ilst,999999,i,0,'atom to drop',12,
         -      n,0)
              if (iout .gt. 0) write (iout,2001) 'atoms',' ',ifst,ilst
            else if (ans .eq. 'r') then
              nkeep=nkeep+1
              if (nkeep .gt. 1) then
                write (6,2003)
                call askstop(1)
              else
                call getrange(ifst,999999,ilst,999999,i,0,
         -        'residue to keep',15,maxresno,0)
              end if
              if (iout .gt. 0) write (iout,2000) 'residues',' ',ifst,ilst
            else if (ans .eq. 'e') then
              call getrange(ifst,999999,ilst,999999,i,0,
         -      'residue to drop',15,maxresno,0)
              if (iout .gt. 0) write (iout,2001) 'residues',' ',ifst,ilst
            else if (ans .eq. 't') then
              call getnamelist(namesel,4,nnamesel,'Atoms names to use',18,
         -      200)
              write (6,2004) 'Atom',(namesel(i),i=1,nnamesel)
            else if (ans .eq. 'u') then
              call getnamelist(namesel,nrescol,nnamesel,
         -      'Residue names to use',12,200)
              write (6,2004) 'Residue',(namesel(i),i=1,nnamesel)
            else if (ans .eq. 'v') then
              if (n .eq. nslt)
         -      print *,'There are no solvents in the system - check the ',
         -        'solvent residue name'
            else if (ans .eq. 'q') then
              if (nrecdel .eq. n) then
                print *,'NOTE: all atoms were deleted'
                call askstop(-1)
              else if (nrecdel .eq. 0 .and. lastans .ne. 'v') then
                print *,'NOTE: no atom was deleted'
                call askstop(-1)
              end if
              return
            else if (ans .eq. 'a') then
              if (iout .gt. 0) write (iout,2000) 'the alpha carbons'
            else if (ans .eq. 'b') then
              if (iout .gt. 0) write (iout,2000) 'the backbone'
            else if (ans .eq. 'h') then
              if (iout .gt. 0) then
                write (iout,2001) 'the aliphatic hydrogens'
                if (iqcol2 .gt. iqcol1) write (iout,*)
         -        'Hydrogen charges will be added to the carbon charge'
              end if
            else if (ans .eq. 'l') then
              if (iout .gt. 0) then
                write (iout,2001) 'all hydrogens'
                if (iqcol2 .gt. iqcol1) write (iout,*)
         -        'Hydrogen charges will be added to the heavy atom charge'
              end if
            end if
            ncfound=0
            ignoreseqno=0
            iseqask=1
            do ia=1,n
              idrop=0
              if (isegcol2 .ge. isegcol1) then
                chainidn=line(index(ia))(isegcol1:isegcol2)
              else
                chainidn='    '
              end if
              if (iseqncol2 .gt. iseqncol1 .and. ignoreseqno .eq. 0) then
                call readint(line(index(ia)),iseqncol1,iseqncol2,iseqno,1,1,
         -        irerr)
              else
                iseqno=ia
              end if
              if (iseqno .gt. 99990 .and. ignoreseqno .eq. 0) then
                ignoreseqno=1
                write (6,*) 'Sequence number read will be ignored'
              end if
              if (iseqno .ne. ia .and. ignoreseqno .eq. 0 .and.
         -        iseqask .eq. 1) then
                write (6,2005) iseqno,ia
                call askyn('Do you want to ignore the sequence number read',
         -        46,1,1,ignoreseqno,0,0)
                iseqask=0
              end if
              iresno=ixres(ia)
              atnam=line(index(ia))(inamcol1:inamcol2)
              call leftadjust4(atnam,atnamadj)
              if (ans .eq. 'c') then
                if (chainidn(1:nsegcol) .ne. chainid(1:nsegcol)) idrop=1
                if (idrop .eq. 0) ncfound=ncfound+1
              else if (ans .eq. 's') then
                if (chainidn(1:nsegcol) .eq. chainid(1:nsegcol)) idrop=1
                if (idrop .eq. 1) ncfound=ncfound+1
              else if (ans .eq. 'b') then
                 if (isbackbone(atnamadj(1:3),3) .eq. 0)  idrop=1
              else if (ans .eq. 'a') then
                if (atnamadj(1:3) .ne. 'CA ') idrop=1
              else if (ans .eq. 't') then
                idrop=1
                do i=1,nnamesel
                  if (atnamadj(1:4) .eq. namesel(i)) idrop=0
                end do
              else if (ans .eq. 'u') then
                resnam(1:nrescol)=line(index(ia))(irescol1:irescol2)
                call leftadjustn(resnam,resnamadj,nrescol)
                idrop=1
                do i=1,nnamesel
                  if (resnamadj(1:nrescol) .eq. namesel(i)(1:nrescol))
         -          idrop=0
                end do
              else if (ans .eq. 'h' .or. ans .eq. 'l') then
                if (iatno(ia) .eq. 1) then
                  if (nneig(ia) .gt. 0) then
                    iac=ineig(1,ia)
                    if (iatno(ineig(1,ia)) .eq. 6 .or. ans .eq. 'l') then
                      idrop=1
                      if (iqcol2 .gt. iqcol1)
         -              charge(iac)=charge(iac)+charge(ia)
                    end if
                  else
                    print *,'Atom ',ia,' has no neighbour'
                    call askyn('Do you want to keep it',22,1,-1,ikeep,0,0)
                    if (ikeep .eq. 0) idrop=1
                  end if
                end if
              else if (ans .eq. 'k') then
                if (iseqno .lt. ifst .or. iseqno .gt. ilst) idrop=1
              else if (ans .eq. 'd') then
                if (iseqno .ge. ifst .and. iseqno .le. ilst) idrop=1
              else if (ans .eq. 'r') then
                if (iresno .lt. ifst .or. iresno .gt. ilst) idrop=1
              else if (ans .eq. 'e') then
                if (iresno .ge. ifst .and. iresno .le. ilst) idrop=1
              else if (ans .eq. 'v') then
                if (ia .gt. nslt) idrop=1
              end if
              if (idrop .gt. 0 .and. indexdel(ia) .eq. 0) then
                nrecdel=nrecdel+1
                indexdel(ia)=1
                line(index(ia))(idcol:idcol)=asterisk
              end if
            end do
            if (ans .eq. 'c' .or. ans .eq. 's') then
              if (ncfound .gt. 0) print *,'Number of chain ',
         -      chainid(1:nsegcol),' atoms=',ncfound
              if (ncfound .eq. 0) print *,'NOTE: no chain ',
         -      chainid(1:nsegcol),' atoms were found'
            end if
            print *,(nrecdel-nrecdel0),' atoms deleted in this step'
            if (ans .eq. 'h' .and. iqcol2 .gt. iqcol1) then
              do ia=1,n
                call blankout(line(index(ia)),iqcol1,iqcol2)
                if (iqcol2-iqcol1 .gt. 6)  then
                  write (line(index(ia))(iqcol2-8:iqcol2),1003) charge(ia)
                else
                  write (line(index(ia))(iqcol2-5:iqcol2),1002) charge(ia)
                end if
              end do
            end if
          end do
    1000  format(' Selecting atoms from the system',/,' Number of solute ',
         -  'atoms=',i6,' Largest solute residue number=',i6)
    1002  format(f6.3)
    1003  format(f9.5)
    2000  format(' Keep only ',a,a,'in the range [',i6,',',i6,']')
    2001  format(' Delete ',a,a,'in the range [',i6,',',i6,']')
    2002  format(1x,a,' chain/segment ',a)
    2003  format(' Only one range-keeping operation is meaningful.',/,
         -  ' For multiple ranges, use multiple deleting operationa')
    2004  format(1x,a,' names to use:',/,
         -  (10(1x,a4)))
    2005  format(' Atom index read (',i5,') differs from the sequence ',
         -  'number (',i8,')')
          end
          subroutine getrange(ifst,ifstdef,ilst,ilstdef,incr,incrask,
         -  question,lquestion,maxval,ihelp)
          character*(*) question
          character*80 line
          line(7:6+lquestion)=question(1:lquestion)
    100   line(1:6)='First '
          call getint(line,6+lquestion,ifstdef,1,maxval,ifst,ihelp)
          line(1:6)='Last  '
          call getint(line,6+lquestion,ilstdef,1,maxval,ilst,ihelp)
          if (ilst .lt. ifst) then
            print *,'Invalid range'
            go to 100
          end if
          if (incrask .gt. 0) then
    101     call getint('Increment',9,1,1,ilst-ifst+1,incr,47)
            if (incr .lt. 1) then
              print *,'Invalid increment'
              go to 101
            end if
          end if
          return
          end
          subroutine nnupdate(index,indexn,indexo,n,nmax,line,isort,maxrec)
          dimension index(nmax),indexn(nmax),indexo(nmax)
          character* 132 line(maxrec)
          do ia=1,n
            do ib=1,6
              ic1=6+(ib-1)*8
              ic2=ic1+4
              read (line(index(ia))(ic1:ic2),1000) iold
              if (iold .gt. 0) then
                if (isort .eq. 0) then
                  if (iold .gt. 0)
         -          write (line(index(ia))(ic1:ic2),1000) indexn(iold)
                else
                  if (indexo(iold) .gt. 0)
         -          write (line(index(ia))(ic1:ic2),1000) indexo(iold)
                end if
              end if
            end do
          end do
          return
    1000  format(i5)
          end
          subroutine findixsort(list,ifrst,nlist,intg,ix,itry)
          dimension list(nlist)
          imin=ifrst
          imax=nlist
          ix=0
          if (imin .gt. imax) then
            itry=imin
            return
          end if
          do while (imax-imin .gt. 1)
            itry=(imax+imin)/2
            if (list(itry) .eq. intg) then
              ix=itry
              return
            else if (list(itry) .gt. intg) then
              imax=itry
            else
              imin=itry
            end if
          end do
          itry=imax
          if (imax .eq. imin) then
            if (list(itry) .eq. intg) ix=itry
          else
            if (list(imin).eq. intg) then
              ix=imin
            else if (list(imax).eq. intg) then
              ix=imax
            end if
          end if
          return
          end
          subroutine mergerec(line,index,indexo,isegno,iresncol1,iresncol2,
         -  m1,m2,n1,n2,iresn,ireso,isegn,n,maxrec)
          character* 132 line(maxrec)
          dimension index(n),indexo(n),isegno(n),iresn(n),ireso(n),isegn(n)
          i=m1
          j=n1
          k=1
    20    if (i .le. m2 .and. j .le. n2) then
            if (isegno(i) .gt. isegno(j)) then
              idiff=1
            else if (isegno(i) .lt. isegno(j)) then
              idiff=-1
            else
              call readint(line(index(i)),iresncol1,iresncol2,numi,2,1,
         -      irerr)
              call readint(line(index(j)),iresncol1,iresncol2,numj,2,1,
         -      irerr)
              if (numi .gt. numj) then
                idiff=1
              else
                idiff=0
              end if
            end if
            if (idiff .eq. 1) then
              iresn(k)=index(j)
              ireso(k)=indexo(j)
              isegn(k)=isegno(j)
              j=j+1
            else
              iresn(k)=index(i)
              ireso(k)=indexo(i)
              isegn(k)=isegno(i)
              i=i+1
            end if
            k=k+1
            go to 20
          else
            if (i .le. m2) then
              do l=i,m2
                iresn(k)=index(l)
                ireso(k)=indexo(l)
                isegn(k)=isegno(l)
                k=k+1
              end do
            end if
            if (j .le. n2) then
              do l=j,n2
                iresn(k)=index(l)
                ireso(k)=indexo(l)
                isegn(k)=isegno(l)
                k=k+1
              end do
            end if
          end if
          k=0
          do l=m1,n2
            k=k+1
            index(l)=iresn(k)
            indexo(l)=ireso(k)
            isegno(l)=isegn(k)
          end do
          return
          end
          subroutine mrgsrt(iout,indexx,value,n,ifa,ila,itemp,temp,maxt)
          dimension indexx(n),value(n)
          dimension ifa(maxt),ila(maxt),itemp(maxt),temp(maxt)
          call mrglimtst(iout,n,maxt,ireturn)
          if (ireturn .eq. 1) return
          nn=n
          call indexit(ifa,1,n,0)
          call indexit(ila,1,n,0)
    11    nnpair=nn/2
          l=1
          do i=1,nnpair
            call mergelst(indexx,value,ifa(l),ila(l),ifa(l+1),ila(l+1),
         -    itemp,temp,maxt)
            ifa(i)=ifa(l)
            ila(i)=ila(l+1)
            l=l+2
          end do
          if (2*nnpair .ne. nn) then
            call mergelst(indexx,value,ifa(nnpair),ila(nnpair),ifa(nn),
         -    ila(nn),itemp,temp,maxt)
            ila(nnpair)=ila(nn)
          end if
          nn=nnpair
          if (nn .gt. 1) go to 11
          return
          end
          subroutine mergelst(indexx,value,m1,m2,n1,n2,ires,res,maxt)
          dimension indexx(maxt),value(maxt),ires(maxt),res(maxt)
          i=m1
          j=n1
          k=1
    20    if (i .le. m2 .and. j .le. n2) then
            if (value(i) .le. value (j)) then
              res(k)=value(i)
              ires(k)=indexx(i)
              i=i+1
              go to 40
            end if
            res(k)=value(j)
            ires(k)=indexx(j)
            j=j+1
    40      k=k+1
            go to 20
          end if
          if (i .le. m2) then
            do l=i,m2
              res(k)=value(l)
              ires(k)=indexx(l)
              k=k+1
            end do
          end if
          if (j .le. n2) then
            do l=j,n2
              res(k)=value(l)
              ires(k)=indexx(l)
              k=k+1
            end do
          end if
          k=0
          do l=m1,n2
            k=k+1
            indexx(l)=ires(k)
            value(l)=res(k)
          end do
          return
          end
          subroutine mrgsrti(iout,indexx,ivalue,n,ifa,ila,itemp1,itemp2,
         -  maxt)
          dimension indexx(n),ivalue(n)
          dimension ifa(maxt),ila(maxt),itemp1(maxt),itemp2(maxt)
          call mrglimtst(iout,n,maxt,ireturn)
          if (ireturn .eq. 1) return
          nn=n
          call indexit(ifa,1,n,0)
          call indexit(ila,1,n,0)
    11    nnpair=nn/2
          l=1
          do i=1,nnpair
            call mergelsti(indexx,ivalue,ifa(l),ila(l),ifa(l+1),ila(l+1),
         -    itemp1,itemp2,maxt)
            ifa(i)=ifa(l)
            ila(i)=ila(l+1)
            l=l+2
          end do
          if (2*nnpair .ne. nn) then
            call mergelsti(indexx,ivalue,ifa(nnpair),ila(nnpair),ifa(nn),
         -    ila(nn),itemp1,itemp2,maxt)
            ila(nnpair)=ila(nn)
          end if
          nn=nnpair
          if (nn .gt. 1) go to 11
          return
          end
          subroutine mergelsti(indexx,ivalue,m1,m2,n1,n2,ires1,ires2,maxt)
          dimension indexx(maxt),ivalue(maxt),ires1(maxt),ires2(maxt)
          i=m1
          j=n1
          k=1
    20    if (i .le. m2 .and. j .le. n2) then
            if (ivalue(i) .le. ivalue (j)) then
              ires2(k)=ivalue(i)
              ires1(k)=indexx(i)
              i=i+1
              go to 40
            end if
            ires2(k)=ivalue(j)
            ires1(k)=indexx(j)
            j=j+1
    40      k=k+1
            go to 20
          end if
          if (i .le. m2) then
            do l=i,m2
              ires2(k)=ivalue(l)
              ires1(k)=indexx(l)
              k=k+1
            end do
          end if
          if (j .le. n2) then
            do l=j,n2
              ires2(k)=ivalue(l)
              ires1(k)=indexx(l)
              k=k+1
            end do
          end if
          k=0
          do l=m1,n2
            k=k+1
            indexx(l)=ires1(k)
            ivalue(l)=ires2(k)
          end do
          return
          end
          subroutine mrglimtst(iout,n,maxt,ireturn)
          ireturn=0
          if (n .eq. 1) then
            ireturn=1
          else if (n .gt. maxt) then
            write (iout,1000) n,maxt
            return=1
          else if (n .lt. 0) then
            write (iout,1001) n
            ireturn=1
          end if
          return
    1000  format(' ERROR: mrgsrt input array length(',i8,') exceeds the ',
         -  'limit:',i6)
    1001  format(' PROGRAM ERROR: negative number of elements to sort:',i6)
          end
          subroutine setdatapath
          character*100 datapath,datapaths
          common /environment/ npaths,ldatapath,ldatapaths(5),
         -  datapath,datapaths(5)
          ldatapath=0
          do ip=1,npaths
            call trypath(datapaths(ip),ldatapaths(ip),datapath,ldatapath)
            if (ldatapath .gt. 0) then
              write (6,1000) datapath(1:ldatapath)
              return
            end if
          end do
          if (ldatapath .eq. 0) then
            call blankout(datapaths(5),1,100)
            call getenv('PWD',datapaths(5))
            call lastchar(datapaths(5),ldatapathtry,100)
            call trypath(datapaths(5),ldatapathtry,datapath,ldatapath)
            if (ldatapath .gt. 0) then
              write (6,1000) datapath(1:ldatapath)
              return
            end if
          end if
          write (6,1001)
    100   call getname(datapaths(5),ldatapathtry,
         -  'Path to directory of Simulaid-provided conversion files',55,
         -  100,' ',0,1,000,0)
          if (ldatapathtry .gt. 0) then
            call trypath(datapaths(5),ldatapathtry,datapath,ldatapath)
            if (ldatapath .gt. 0) then
              write (6,1000) datapath(1:ldatapath)
              return
            else
              print *,'No conversion files were found in',
         -      datapath(1:ldatapath)
              call askyn('Do you want to try a different path',35,1,1,itry,
         -      0,0)
              if (itry .gt. 0) go to 100
            end if
          end if
          return
    1000  format(' Conversion files found in directory ',a)
    1001  format(' NOTE: no valid datapath is found to Simulaid-provided',
         -  ' conversion files',/,' - the conversion files are assumed to ',
         -  'be in the current directory',/,' You can edit the 4th entry ',
         -  'of the character array datapaths and the ',/,'correponding ',
         -  'array entry of ldatapath or enter it here (or just hit ENTER ',
         -  'if the coversion files are in the current directory or you ',
         -  'will not need them)')
          end
          subroutine trypath(datapathtry,ldatapathtry,datapath,ldatapath)
          character*100 datapathtry,datapath
          character*200 filename
          filename(1:ldatapathtry)=datapathtry(1:ldatapathtry)
          filename(ldatapathtry+1:ldatapathtry+12)='/pdb_nam.dat'
          namlen=ldatapathtry+12
          call openfile(88,0,' ',1,'old',filename,namlen,notfound,2,1,0,1,
         -  0)
          if (notfound .eq. 0) then
            datapath=datapathtry
            ldatapath=ldatapathtry
            close (88)
            return
          else
            ldatapath=0
          end if
          return
          end
          subroutine reseq(line,index,n,nslt,nsegm,iatfirst,
         -  iresfirst,iresidfirst,inptyp,iresno,resnames,numres,numslv,
         -  naslv,ninsres,resnamslv,iresnrestart,iresidrestart,nconfig,
         -  ireseq,ireseqdef,maxrsd,maxrec)
          dimension iresno(maxrec)
          character* 132 line(maxrec)
          character*8 resnam,resnames(maxrsd),resnamslv
          character*4 segnam
          dimension index(n)
          character*5 crdext
          common /iotypes/ iocha,iochaex,iobpdb,iocpdb,ioa3pdb,ioa4pdb,
         -  iommod,iommc,iommc4,iogro,iomol2,iomae,iocif,ioxxx,ioins,
         -  ionxyz,iosxyz,iosxyzrq,iograsp,iofull,lext(19),crdext(19)
          common /solvres/ iaskdiffres,idiffres
          common /logging/ logfile,ipredict
          call setcol(inptyp,ncol,idcol,ialtcol,iinscol,
         -  inamcol1,inamcol2,irescol1,irescol2,iccol1,iccol2,
         -  iresncol1,iresncol2,iseqncol1,iseqncol2,isegcol1,isegcol2,
         -  iresidcol1,iresidcol2,iqcol1,iqcol2,ipotcol1,ipotcol2,
         -  iocccol1,iocccol2,ichemcol1,ichemcol2,nrescol,nresncol,
         -  nsegcol,nnamcol,iofull)
          nrescol=irescol2-irescol1+1
          nresncol=iresncol2-iresncol1+1
          nsegcol=isegcol2-isegcol1+1
          if (ireseq .eq. -1) return
          if (nconfig .eq. 1) then
            if (ninsres .gt. 0) write (6,1101) ninsres
            call askyn('Do you want to adjust atom and residue numbers',
         -    46,1,ireseqdef,ireseq,0,0)
            if (ireseq .eq. 1) then
              call getint('Atom number of the first atom',29,
         -      1,1,0,iatfirst,48)
              call getint('Residue number of the first residue',35,
         -      1,1,0,iresfirst,48)
              if (ischarmm(ioutyp) .eq. 1) then
                call getint('Residue id of the first residue',31,
         -        iresfirst,1,0,iresidfirst,48)
                print *,'First residue id=',iresidfirst
              else
                iresidfirst=0
              end if
              if (nsegm .gt. 1 .or. ipredict .eq. 1) then
                call askyn(
         -       'Do you want to restart residue numbering at each segment',
         -        56,1,-1,iresnrestart,0,0)
                if (ischarmm(inptyp) .eq. 1) then
                call askyn(
         -      'Do you want to restart residue id numbers at each segment',
         -        57,1,+1,iresidrestart,0,0)
                else
                  iresidrestart=0
                end if
                if (iresnrestart+iresidrestart .gt. 0)
         -        print *,'Residue ranges for each segment are listed above'
              end if
            end if
          end if
          if (ireseq .ne. 1) return
          numslv=0
          resnam='        '
          resnam(1:nrescol)=line(index(1))(irescol1:irescol2)
          iresnoprev=iresno(1)
          resnames(1)=resnam
          if (nsegcol .gt. 0)
         -  segnam(1:nsegcol)=line(index(1))(isegcol1:isegcol2)
          numres=iresfirst
          iiresnum=iresfirst
          iiresid=iresidfirst
          ncha=0
          do ia=1,n
            line(index(ia))(iinscol:iinscol)=' '
            if (line(index(ia))(irescol1:irescol2) .ne. resnam(1:nrescol)
         -     .or. iresno(ia) .ne. iresnoprev) then
              numres=numres+1
              iiresnum=iiresnum+1
              iiresid=iiresid+1
              resnam(1:nrescol)=line(index(ia))(irescol1:irescol2)
              iresnoprev=iresno(ia)
              resnames(numres)=resnam
              if (resnamslv(1:nrescol) .eq. resnam(1:nrescol))
         -      numslv=numslv+1
            else if (iaskdiffres .eq. 0 .and. nconfig .eq. 1) then
              if (ia .eq. nslt+naslv+1) then
                call askyn(
         -        'Do you want the solvents to be different residues',49,
         -        1,1,idiffres,0,0)
                iaskdiffres=1
              end if
            end if
            if (ia .gt. nslt+naslv .and. idiffres .eq. 1) then
              if (mod(ia-1-nslt,naslv) .eq. 0) then
                numres=numres+1
                iiresnum=iiresnum+1
                iiresid=iiresid+1
                numslv=numslv+1
              end if
            end if
            if (nsegcol .gt. 0) then
              if (segnam(1:nsegcol) .ne. line(index(ia))(isegcol1:isegcol2))
         -                           then
                segnam(1:nsegcol)=line(index(ia))(isegcol1:isegcol2)
                if (iresnrestart+iresidrestart .gt. 0)
         -        write (6,*) 'Segment ',segnam(1:nsegcol)
                if (iresnrestart .eq. 1) then
                  call getint('Residue number of the first residue',35,
         -          iresfirst,1,0,iresfirst,48)
                  iiresnum=iresfirst
                end if
                if (iresidrestart .eq. 1) then
                  call getint('Residue id of the first residue',31,
         -          iresidfirst,1,0,iresidfirst,48)
                  iiresid=iresidfirst
                end if
              end if
            end if
            if (iseqncol1 .gt. 0) then
              call readint(line(index(ia)),iseqncol1,iseqncol2,iaorg,1,1,
         -      irerr)
              ianew=ia+iatfirst-1
              if (iaorg .ne. ianew) ncha=ncha+1
              if (inptyp .eq. iochaex) then
                write (line(index(ia))(iseqncol1:iseqncol2),1001) ianew
              else
                write (line(index(ia))(iseqncol1:iseqncol2),1000) ianew
              end if
            end if
            if (numres .gt. maxrsd) then
              write (6,2000) maxrsd,numres
              stop
            end if
            call readint(line(index(ia)),iresncol1,iresncol2,iiresorg,2,1,
         -    irerr)
            if (iiresorg .ne. iiresnum) ncha=ncha+1
            if (ischarmm(inptyp) .eq. 1) then
              call readint(line(index(ia)),iresidcol1,iresidcol2,iiresorg,2,
         -      1,irerr)
              if (iiresorg .ne. iiresid) ncha=ncha+1
            end if
            if (inptyp .eq. iocha ) then
              write (line(index(ia))(iresncol1:iresncol2),1000)
         -      mod(iiresnum,100000)
              if (iiresnum .eq. 100000)
         -       write (6,1100) 'residue number',100000
              write (line(index(ia))(iresidcol1:iresidcol2),1006)
         -      mod(iiresid,100000)
              if (iiresid .eq. 100000)
         -       write (6,1100) 'residue id',100000
            else if (inptyp .eq. iochaex) then
              write (line(index(ia))(iresncol1:iresncol2),1001) iiresnum
              write (line(index(ia))(iresidcol1:iresidcol2),1002) iiresid
            else if (inptyp .eq. iommc ) then
              write (line(index(ia))(iresncol1:iresncol2),1000)
         -      mod(iiresnum,100000)
              if (iiresnum .eq. 100000)
         -     write (6,1100) 'residue number',100000
            else
              write (line(index(ia))(iresncol1:iresncol2),1006)
         -      mod(iiresnum,10000)
              if (iiresnum .eq. 10000) write (6,1100) 'residue number',10000
            end if
          end do
          do ir=1,numres
            if (resnames(ir)(1:3) .eq. 'TIP') resnames(ir)(4:4)='3'
          end do
          if (nconfig .eq. 1) then
            if (ncha .gt. 0) then
              print *,'Atom and/or residue sequence numbers were changed'
            else
              print *,'No sequence number was changed'
            end if
          end if
          return
    1000  format(i5)
    1001  format(i10)
    1002  format(i8)
    1006  format(i4)
    1100  format(' WARNING: leading digits for ',a,' over ',i7,
         -  '  are dropped')
    1101  format(' NOTE:',i5,' atoms with duplicate residue numbers were ',
         -  'inserted',/,6x,'You may want to adjust the residue numbers ',
         -  'to avoid duplicates')
    2000  format( 'ERROR: Maximum number of residues (',i5,') is exceeded',
         -  /,' - recompile simulaid with MAXRSD=',i6,' or greater')
          end
          subroutine fixrecform(line,index,n,iconv,inamcol1,inamcol2,
         -  irescol1,irescol2,maxrec)
          character* 132 line(maxrec)
          character*4 atnamo,atnamn
          character*8 resnam
          dimension index(n)
          if (iconv .eq. 2) itofrom=1
          if (iconv .eq. 3) itofrom=0
          n2=0
          do ia=1,n
            resnam='        '
            resnam(1:irescol2-irescol1+1)=
         -    line(index(ia))(irescol1:irescol2)
            atnamo=line(index(ia))(inamcol1:inamcol2)
            call regularpdb(atnamo,atnamn,itofrom)
            line(index(ia))(inamcol1:inamcol2)=atnamn
          end do
          if (n2 .gt. 0) print *,'WARNING: ',n2,
         -    ' atomnames had more than one leading digits'
          return
          end
          subroutine atomdel(line,idcol,asterisk,n,nslt,nrecdel,c,isegno,
         -  index,indexn,indexo,inpcrdtyp,iatnum,charge,altcol,inscol,
         -  iresno,ixres,atnames,ifres,ilres,nconfig,ndel,maxrsd,maxrec)
          character*132 line(maxrec)
          character*1 altcol(maxrec),inscol(maxrec)
          character*8 atnames(maxrec)
          dimension c(3,n),isegno(n),index(n),indexn(n),indexo(n),iatnum(n),
         -  iresno(n),ixres(n),charge(n),ifres(maxrsd),ilres(maxrsd)
          character*1 asterisk
          character*5 crdext
          common /iotypes/ iocha,iochaex,iobpdb,iocpdb,ioa3pdb,ioa4pdb,
         -  iommod,iommc,iommc4,iogro,iomol2,iomae,iocif,ioxxx,ioins,
         -  ionxyz,iosxyz,iosxyzrq,iograsp,iofull,lext(19),crdext(19)
          if (nrecdel .eq. 0) return
          ndel=0
          nsltdel=0
          do i=1,n
            if (line(index(i))(idcol:idcol) .eq. asterisk) then
              ndel=ndel+1
              if (i .le. nslt) nsltdel=nsltdel+1
              indexo(i)=0
            else if (ndel .gt. 0) then
              index(i-ndel)=index(i)
              indexo(i)=i-ndel
              iatnum(i-ndel)=iatnum(i)
              iresno(i-ndel)=iresno(i)
              isegno(i-ndel)=isegno(i)
              charge(i-ndel)=charge(i)
              call trnsfr(c(1,i-ndel),c(1,i),3)
              altcol(i-ndel)=altcol(i)
              inscol(i-ndel)=inscol(i)
              atnames(i-ndel)=atnames(i)
            end if
          end do
          if (nsltdel .gt. 0 .and. nconfig .eq. 0)
         -  print *,'Number of solute atoms deleted=',nsltdel
          if (ndel .ne. nrecdel) then
            write (6,1000) asterisk,ndel,nrecdel
          end if
          if (inpcrdtyp .eq. iommod)
         -  call nnupdate(index,indexn,indexo,n-ndel,n,line,1,maxrec)
          n=n-ndel
          nslt=nslt-nsltdel
          ifres(1)=1
          numres=0
          ixres(1)=1
          do ia=2,n
            if (iresno(ia) .ne. iresno(ia-1) .or.
         -      isegno(ia) .ne. isegno(ia-1)) then
              numres=numres+1
              ilres(numres)=ia-1
              do ja=ifres(numres),ilres(numres)
                ixres(ja)=numres
              end do
              ifres(numres+1)=ia
            end if
          end do
          ilres(numres+1)=n
          nrecdel=0
          return
    1000  format(' PROGRAM ERROR: Number of ',a,'-marked lines found=',
         -  i9,/,5x,'differs from number of records to be deleted=',i9)
          end
          subroutine initnamconv(noconv)
          character*200 filename,line
          character*8 namnam
          character*9 recnam
          common /convspec/ incon,ioutcon,ideoxy,namnam(10)
          character*3 ires0
          character*4 anamcontab,rnamcontab,atnam
          common /convdat/ nanamcon,nrnamcon,nres0,ifst(100),ilst(100),
         -  ncon,nconcol,anamcontab(1000,13),rnamcontab(13,100),ires0(100),
         -  icongro
          ideoxy=-1
          filename='pdb_nam.dat'
          namlen=11
          iuconv=70
          call openfile(iuconv,0,'namcon',6,'old',filename,namlen,
         -  notfnd,1,1,0,0,0)
          write (6,2001) filename(1:namlen)
          maxconcol=13
          read (iuconv,*) ncon,nconcol
          if (nconcol .gt. maxconcol) then
            print *,'ERROR: Conversion data columns exceeds limit (',
         -    maxconcol,')'
            stop
          end if
          read (iuconv,*) (namnam(i),i=1,ncon)
          do ic=1,ncon
            if (namnam(ic)(1:3) .eq. 'Gro') icongro=ic
          end do
          call chosename(namnam,ncon,'input',5,incon)
          call chosename(namnam,ncon,'output',6,ioutcon)
          if (incon .eq. ioutcon) then
            print *,'Names will be matched without conversion'
            noconv=1
            return
          else
            noconv=0
          end if
          if (namnam(ioutcon) .eq. 'Macromod') then
            print *,'Sorry, conversions TO Macromodel are not implemented'
            stop
          end if
          if (incon .eq. icongro .or. ioutcon .eq. icongro) write (6,2006)
          write (6,2004) namnam(incon),namnam(ioutcon)
          recnam='residname'
          do i=1,100
            read (iuconv,1000,end=992) line
            read (line,*,err=9921) (rnamcontab(j,i),j=1,nconcol)
            if (rnamcontab(1,i) .eq. 'DONE') then
              nrnamcon=i
              go to 120
            end if
          end do
          go to 993
    9921  write (6,2005) recnam,filename(1:namlen),i,line
          stop
    120   irec=0
          recnam='atomnname'
          do i=1,100000
            read (iuconv,1000,end=991) line
            read (line,*,err=9921) (anamcontab(irec+1,j),j=1,nconcol)
            if (anamcontab(irec+1,1) .eq. 'DONE') then
              nanamcon=irec
              go to 110
            end if
            atnam=anamcontab(irec+1,2)
            ndiff=0
            do j=3,nconcol
              if (atnam .ne. anamcontab(irec+1,j) .and.
         -        anamcontab(irec+1,j) .ne. '   ') ndiff=ndiff+1
            end do
            if (ndiff .gt. 0) irec=irec+1
            if (irec .eq. 1000) then
              print *,'Atom name table exceeds the maximum (1000)'
              stop
            end if
          end do
    110   nres0=1
          ires0(nres0)=anamcontab(1,1)(1:3)
          ifst(nres0)=1
          do i=2,nanamcon
            if (anamcontab(i,1) .ne. anamcontab(i-1,1)) then
              ilst(nres0)=i-1
              nres0=nres0+1
              ires0(nres0)=anamcontab(i,1)(1:3)
              ifst(nres0)=i
            end if
          end do
          ilst(nres0)=nanamcon
          close (iuconv)
          return
    991   print *,'ERROR: atom name table ended abruptly'
          stop
    992   print *,'ERROR: residue name table ended abruptly'
          stop
    993   print *,'ERROR: too many residues, increase size of ',
         -  'rnamcontab'
          stop
    1000  format(a200)
    2001  format(' Name-conversion file:',a)
    2004  format(' Atom and residue name convention are changed from ',
         -  a,' to ',a)
    2005  format(' ERROR: invalid ',a,' record in file ',a,
         -  ' record no=',i8,' :'/,a)
    2006  format(' NOTE: only 4 characters will be used for conversion',/,
         -  7x,'Only protein conversions are complete for Gromacs')
          end
          subroutine chosename(namelist,nnames,lab,lablen,iname)
          character*(*) namelist(nnames),lab
    100   write (6,1000) lab(1:lablen)
          do i=1,nnames
            if (i .lt. nnames) write (6,1001) namelist(i),i
            if (i .eq. nnames) write (6,1002) namelist(i),i
          end do
          call getint('Convention number',17,999999,1,nnames,iname,00)
          if (iname .lt. 1 .or. iname .gt. nnames) then
            print *,'Invalid choice'
            go to 100
          end if
          return
    1000  format(' Possible ',a,' name conventions:')
    1001  format(5x,a8,':',i3)
    1002  format(5x,a8,':',i3,'  ',$)
          end
          subroutine namconv(nrescol,resnamin,atnamin,resnamout,atnamout,
         -  nrch,nach,line,idcol,nrecdel)
          character* 132 line
          character*1 ans1
          character*4 atnamin,atnamout,an0,an1,resnamin,resnamout,rn0
          character*8 namnam
          common /convspec/ incon,ioutcon,ideoxy,namnam(10)
          character*3 ires0
          character*4 anamcontab,rnamcontab
          common /convdat/ nanamcon,nrnamcon,nres0,ifst(100),ilst(100),
         -  ncon,nconcol,anamcontab(1000,13),rnamcontab(13,100),ires0(100),
         -  icongro
          data inamconv /0/
          incol1=incon+1
          incol2=incon+1
          if (incon .eq. ncon) incol2=nconcol
          an0=atnamin
          rn0=resnamin
          atnamout=atnamin
          call leftadjust4(resnamin,resnamin)
          call leftadjust4(atnamin,an1)
          inrescol=nrescol
          if (incon .eq. ncon) then
            call regularpdb(an1,atnamin,1)
            inrescol=3
          else
            if (idigit(an1(1:1),1) .eq. 1 .and. ioutcon .ne. ncon)
         -    call regularpdb(an1,atnamin,-1)
          end if
          atnamout=atnamin
          an1=atnamin
          resnamout=resnamin
          iresconv=0
          do i=1,nrnamcon
            do j=incol1,incol2
              if (resnamin(1:inrescol) .eq.
         -        rnamcontab(j,i)(1:inrescol)) then
                iresconv=i
                resnamout=rnamcontab(ioutcon+1,i)
                go to 100
              end if
            end do
          end do
          go to 910
    100   iresconv0=0
          do i=1,nres0
            if (ires0(i) .eq. rnamcontab(1,iresconv)(1:3)) then
              iresconv0=i
              go to 110
            end if
          end do
          write (6,2001) rnamcontab(1,iresconv)
    110   if (iresconv0 .gt. 0) then
            do i=ifst(iresconv0),ilst(iresconv0)
              do j=incol1,incol2
                if (atnamin .eq. anamcontab(i,j)) then
                  if (anamcontab(i,ioutcon+1) .eq. '****') then
                    line(idcol:idcol)='*'
                    nrecdel=nrecdel+1
                  else if (anamcontab(i,ioutcon+1) .ne. '    ') then
                    atnamout=anamcontab(i,ioutcon+1)
                  end if
                  inamconv=i
                  go to 900
                end if
              end do
            end do
          end if
          do i=ifst(1),ilst(1)
            do j=incol1,incol2
              if (atnamin .eq. anamcontab(i,j)) then
                if (anamcontab(i,ioutcon+1) .eq. '****') then
                  line(idcol:idcol)='*'
                  nrecdel=nrecdel+1
                else if (anamcontab(i,ioutcon+1) .ne. '    ') then
                  atnamout=anamcontab(i,ioutcon+1)
                end if
                inamconv=i
                go to 900
              end if
            end do
          end do
          inamconv=0
    900   if (nrescol .ge. 4 .and. resnamout(4:4) .ne. ' ') then
            if (resnamout(1:1) .eq. 'D' .or. resnamout(1:1) .eq. 'R') then
              if (ideoxy .eq. -1) then
                if (resnamout(2:4) .eq. 'ADE' .or. resnamout(2:4) .eq.
         -        'GUA' .or. resnamout(2:4) .eq. 'CYT') then
                  call getname(ans1,len,
         -          'Nucleic acid type (D for Deoxy, R Oxy)',38,1,'',0,0,0,
         -          0)
                  ideoxy=1
                  if (ans1 .eq. 'r' .or. ans1 .eq. 'R') ideoxy=0
                else if (resnamout(2:4) .eq. 'THY') then
                  ideoxy=1
                else if (resnamout(2:4) .eq. 'URA') then
                  ideoxy=0
                end if
              else if (ideoxy .eq. 1) then
                resnamout(1:1)='D'
              else if (ideoxy .eq. 0) then
                resnamout(1:1)='R'
              end if
            end if
          end if
          if (ioutcon .eq. icongro) then
            ifound=0
            if (ires0(iresconv0) .eq. 'ASP') then
              call findname('HD2 ',anamcontab(1,ioutcon+1),ifst(iresconv0),
         -      ilst(iresconv0),ifound,3)
            else if (ires0(iresconv0) .eq. 'CYS') then
              call findname('HG  ',anamcontab(1,ioutcon+1),ifst(iresconv0),
         -      ilst(iresconv0),ifound,2)
            else if (ires0(iresconv0) .eq. 'GLU') then
              call findname('HE2 ',anamcontab(1,ioutcon+1),ifst(iresconv0),
         -      ilst(iresconv0),ifound,3)
            else if (ires0(iresconv0) .eq. 'LYS') then
              call findname('HZ3 ',anamcontab(1,ioutcon+1),ifst(iresconv0),
         -      ilst(iresconv0),ifound,3)
            end if
            if (ifound .gt. 0) resnamout(4:4)='H'
          end if
    910   if (inamconv*iresconv .eq. 0) then
            if (incon .eq. ncon) then
              call leftadjust4(an0,an1)
              if (idigit(an1(1:1),1) .eq. 1)
         -      call regularpdb(an1,atnamout,-1)
            else
              atnamout=an1
            end if
          end if
          if (rn0 .ne. resnamout) nrch=nrch+1
          if (an0 .ne. atnamout) nach=nach+1
          return
    2001  format(' ERROR: Generic residue id ',a4,' is not found - ',
         -  'conversion is skipped',/,8x,'Check the conversion table file')
          end
          subroutine regularpdb(inp,reg,itofrom)
          character*4 inp,reg,regg,inpl
          regg='    '
          call leftadjust4(inp,inpl)
          if (itofrom .eq. 1) then
            if (inpl(1:1) .eq. 'C' .or. inpl(1:1) .eq. 'O' .or.
         -    inpl(1:1) .eq. 'N' .or. inpl(1:1) .eq. 'S' .or.
         -    inpl(1:1) .eq. 'P') then
              regg(2:4)=inpl(1:3)
              if (inpl(4:4) .ne. ' ') then
                if (idigit(inpl(4:4),1) .eq. 1) then
                  regg(1:1)= inpl(4:4)
                else if (idigit(inpl(3:3),1) .eq. 1) then
                  regg(1:1)= inpl(3:3)
                  regg(4:4)= inpl(4:4)
                else if (idigit(inpl(2:2),1) .eq. 1) then
                  regg(1:1)= inpl(3:3)
                  regg(3:3)= inpl(3:3)
                  regg(4:4)= inpl(4:4)
                else
                  write (6,1000) ' ',inpl
                end if
              end if
            else if (inpl(1:1) .eq. 'H' .or. inpl(1:1) .eq. 'D') then
              if (inpl .eq. 'H   ') then
                regg=' H  '
              else if (inpl .eq. 'D   ') then
                regg=' D  '
              else if (inpl(3:4) .eq. '  ') then
                regg(2:3)=inpl(1:2)
              else if (inpl(4:4) .eq. ' ') then
                regg(1:1)=' '
                regg(2:4)=inpl(1:3)
              else
                if (idigit(inpl(4:4),1) .eq. 1) then
                  regg(1:1)=inpl(4:4)
                  regg(2:4)=inpl(1:3)
                else if (idigit(inpl(2:2),1) .eq. 1 .and.
         -               idigit(inpl(3:3),1) .eq. 1) then
                  regg(1:1)=inpl(2:2)
                  regg(2:2)=inpl(1:1)
                  regg(3:3)=inpl(4:4)
                  regg(4:4)=inpl(3:3)
                else if (idigit(inpl(2:2),1) .eq. 1) then
                  regg(1:1)=inpl(2:2)
                  regg(2:2)=inpl(1:1)
                  regg(3:4)=inpl(3:4)
                else if (idigit(inpl(3:3),1) .eq. 1) then
                  regg(1:1)=inpl(3:3)
                  regg(2:2)=inpl(1:1)
                  regg(3:3)=inpl(2:2)
                  regg(4:4)=inpl(4:4)
                else
                  write (6,1000) ' H ',inpl
                  regg=inpl
                end if
              end if
            else if (idigit(inpl(1:1),1) .eq. 1 .and.
         -           inpl(4:4) .eq. ' ') then
               regg(2:3)=inpl(2:3)
               if (inpl(3:4) .eq. '  ') then
                 regg(3:3)=inpl(1:1)
               else
                 regg(4:4)=inpl(1:1)
               end if
            else
              regg=inpl
            end if
          else
            if (idigit(inpl(1:1),1) .eq. 1) then
              if (inpl(3:4) .eq. '  ' .or. inpl(3:4) .eq. "''" .or.
         -        inpl(3:4) .eq. '**' .or. inpl(3:4) .eq. "' " .or.
         -        inpl(3:4) .eq. '* ') then
                regg(1:1)=inpl(2:2)
                regg(2:2)=inpl(1:1)
              else if (inpl(4:4) .eq. ' ' .or. inpl(4:4) .eq. '*' .or.
         -             inpl(4:4) .eq. "'") then
                regg(1:2)=inpl(2:3)
                regg(3:3)=inpl(1:1)
              else
                regg(1:3)=inpl(2:4)
                regg(4:4)=inpl(1:1)
              end if
            else
              regg=inpl
            end if
          end if
          reg=regg
          return
    1000  format(' ERROR: can not regularize 4-character',a,
         -  'name withot a digit:',a)
          end
          subroutine check23(line,index,nslt,inamcol1,inamcol2,nnamcol,
         -  maxrec)
          dimension index(nslt)
          character*132 line(maxrec)
          character*1 lcprev1,lcprev2
          character*5 atomnam,prev1,prev2
          lcprev1=' '
          lcprev2=' '
          prev1(1:1)='     '
          prev2(1:1)='     '
          iasked=0
          do ia=1,nslt
            atomnam(1:nnamcol)=line(index(ia))(inamcol1:inamcol2)
            call lastchar(atomnam,lc,nnamcol)
            if (atomnam(lc:lc) .eq. '3' .and.
         -      (atomnam(1:1) .eq. 'H' .or. atomnam(1:2) .eq. ' H')) then
              if ((lcprev2 .ne. '1' .or.
         -        prev2(1:lc-1) .ne. atomnam(1:lc-1)) .and.
         -        prev1(1:lc-1) .eq. atomnam(1:lc-1)) then
                if (iasked .eq. 0) then
                  write (6,1000)
         -          atomnam(1:lc),prev1(1:lc),prev1(1:lc-1)//'1'
                  call askyn('Do you want to shift H*2-H*3 to H*1-H*2',39,
         -          1,1,ishift,123,0)
                  if (ishift .eq. 0) return
                  iasked=1
                end if
                line(index(ia-1))(inamcol1+lc-1:inamcol1+lc-1)='1'
                line(index(ia))(inamcol1+lc-1:inamcol1+lc-1)='2'
              end if
            end if
            prev2=prev1
            prev1=atomnam
            lcprev2=lcprev1
            lcprev1=atomnam(lc:lc)
          end do
          return
    1000  format(' Atom names ',a,' and ',a,' were found without ',a)
          end
          subroutine openfile(iunit,iswitch,prompt,lenprompt,mode,
         -  filename,namlen,notfound,idatapath,ib,nosys,noecho,ioverall)
          character*(*) prompt,filename
          character*3 mode
          character*100 datapath,datapaths
          common /environment/ npaths,ldatapath,ldatapaths(5),
         -  datapath,datapaths(5)
          common /logging/ logfile,ipredict
          character*11 formnam
          character*80 promptq
          dimension lenform(2),formnam(2)
          data formnam /'formatted  ','unformatted'/,lenform /9,11/
          notfound=0
          iover=0
    100   if (namlen .le. 0) then
            write (promptq,1000) prompt(1:lenprompt)
            lprompt=lenprompt+17
            call getname(filename,namlen,promptq,lprompt,200,'',0,0,0,0)
            if (namlen .eq.  0) then
              if (iswitch .eq. 1) then
                print *,'No name was provided - switching to terminal input'
                return
              else
                go to 100
              end if
            end if
          end if
          if (ipredict .eq. 1 .and. mode .eq. 'new' .and.
         -    ioverall .eq. 0) then
            print *,'Opening file ',filename(1:namlen)
            call askyn('If the file exists, do you want to overwrite it',47,
         -    1,-1,iover,0,0)
          end if
          lenfrm=lenform(ib)
    110   if (mode .eq. 'new') then
            open(unit=iunit,status='new',file=filename(1:namlen),
         -    iostat=iopen,form=formnam(ib)(1:lenfrm))
          else
            open(unit=iunit,status='old',file=filename(1:namlen),
         -    iostat=iopen,form=formnam(ib)(1:lenfrm))
          end if
          if (iopen .ne. 0) then
            if ((iover+ioverall) .gt. 0 .and. mode .eq. 'new') then
              open(unit=iunit,status='old',file=filename(1:namlen),
         -      iostat=iopen,form=formnam(ib)(1:lenfrm))
              if (iopen .gt. 0) then
                write (6,1004) 'overwriting',filename(1:namlen)
                stop
              end if
              return
            end if
            if (idatapath .eq. 2) then
              notfound=1
              return
            else if (idatapath .eq. 3 .and. mode .eq. 'old') then
              write (6,1004) 'opening',filename(1:namlen)
              namlen=0
              go to 100
            end if
            if (mode .eq. 'old') then
              if (idatapath .eq. 1 .and. nosys .eq. 0 .and.
         -        ldatapath .gt. 0) then
                filename=datapath(1:ldatapath)//'/'//filename(1:namlen)
                namlen=namlen+ldatapath+1
                open(unit=iunit,status='old',file=filename(1:namlen),
         -        iostat=iopen,form=formnam(ib)(1:lenfrm))
                if (iopen .eq. 0) then
                  filename(1:namlen)=filename(ldatapath+2:ldatapath+namlen)
                  go to 200
                end if
              end if
              write (6,1004) 'opening',filename(1:namlen)
              namlen=-1
              go to 100
            else
              if (ipredict .eq. 0) then
                write (6,1004) 'opening',filename(1:namlen)
                call askyn(
         -        'Do you want to overwrite it if it already exists',48,
         -        1,-1,iover,0,0)
              end if
              if (iover .eq. 1) then
                print *,'Overwriting file ',filename(1:namlen)
                open(unit=iunit,status='old',file=filename(1:namlen),
         -        iostat=iopen,form=formnam(ib)(1:lenfrm))
                if (iopen .eq. 0) then
                  close (iunit,status='delete')
                  go to 110
                end if
                write (6,1002) filename(1:namlen)
              end if
              namlen=-1
              go to 100
            end if
          end if
    200   if (namlen .eq. 0) namlen=lenchar(filename,1,200)
          if (noecho .eq. 0) write (6,1001) filename(1:namlen),
         -  formnam(ib)(1:lenfrm),iunit
          return
    1000  format('Name of the ',a,' file')
    1001  format(' File ',a,' (',a,') opened on unit ',i3)
    1002  format(' There is still a problem opening file ',a)
    1004  format(' Problem ',a,' file ',a)
          end
          subroutine checkdir(dirname,ldirname,iunit,iopen)
          character*(*) dirname
          character*200 filename
          filename(1:ldirname)=dirname(1:ldirname)
          filename(ldirname+1:ldirname+7)='/xyzXYZ'
          open(unit=iunit,status='new',file=filename(1:ldirname+7),
         -  iostat=iopen,form='formatted')
          if (iopen .eq. 0) close(iunit,status='delete')
          return
          end
          subroutine changeext(oldname,newname,leno,lenn,newext,lenext,
         -  insert,iask)
          character*(*) oldname,newname,newext
          character*80 question,oldext
          character*200 tempname
          tempname=oldname
          lenn=leno
          do while (lenn .gt. 0 .and. tempname(lenn:lenn) .ne. '.')
            lenn=lenn-1
          end do
          if (lenn .eq. 0) then
            lenn=leno+1
            tempname(lenn:lenn)='.'
          end if
          if (insert .eq. 0) then
            tempname(lenn+1:lenn+lenext+1)=newext
            lenn=lenn+lenext+1
            if (iask .eq. 0) then
              newname=tempname
            else
              question='Output file name: '//tempname(1:lenn)//' - is it OK'
              lq=29+lenn
              call askyn(question,lq,1,1,ians,00,0)
              if (ians .eq. 1) then
                newname=tempname
              else
                lenn=0
              end if
            end if
          else
            oldext=tempname(lenn:leno)
            newname=tempname(1:lenn-1)//'_'//newext//oldext
            lenn=leno+lenext+1
          end if
          return
          end
          subroutine isdcd(filename,namlen,idcdtyp)
          character*200 filename
          character*4 header
          call openfile(97,0,' ',1,'old',filename,namlen,notfound,0,2,1,1,0)
          rewind 97
          idcdtyp=0
          read (97,end=99,err=99) header
          if (header .eq. 'CORD') idcdtyp=1
          if (header .eq. 'VELD') idcdtyp=2
    99    close (97)
          return
          end
          subroutine isambertraj(filename,namlen,itrajtyp)
          character*200 filename
          character* 132 line
          call openfile(97,0,' ',1,'old',filename,namlen,notfound,0,1,1,1,0)
          rewind 97
          itrajtyp=0
          read (97,1000,end=99,err=99) line
          call blankout(line,1,132)
          read (97,1000,end=99,err=99) line
          call lastchar(line,ifc,132)
          if (ifc .le. 72 .or. ifc .gt. 80) go to 99
          ndec=0
          do ic=1,ifc
           if (idigit(line(ic:ic),2) .eq. 0) go to 99
           if (line(ic:ic) .eq. '.') ndec=ndec+1
          end do
          if (ndec .ne. 10) go to 99
          itrajtyp=1
    99    close (97)
          return
    1000  format(a)
          end
          subroutine convertseq(resnames,resnames1,segnames,inpfile,outfile,
         -  maxrsd)
          character*8 resnames(maxrsd)
          character*1 resnames1(maxrsd)
          character*200 inpfile,outfile
          character*4 segnames(maxrsd) 
          character*1 ans,ch
          character*4 s4
          character*132 l132(1)
          character*200 line
          character*1 abc,digits,hexdigits
          common /charactersets/ ihex(25),abc(62),digits(14),hexdigits(25)
          linpfile=0
          loutfile=0
          call openfile(30,0,'input sequence',14,'old',inpfile,linpfile,
         -  notfndi,0,1,1,0,0)
          call quiz(ans,inpstyp,' ',' ',0,
         -  'Input format for sequence list',30,0,5,6,00)
          call openfile(31,0,'output sequence',15,'new',outfile,loutfile,
         -  notfndo,0,1,1,0,1)
          call quiz(ans,iostyp,' ',' ',0,
         -  'Output format for sequence list',31,0,5,6,00)
          if (notfndi+notfndo .gt. 0) stop
          nres=0
          nresp=nres
          nseg=0
          if (inpstyp .eq. 1) then
            print *,'It is assumed that no other Charmm input items are ',
         -    'in the file'
            do while (.true.)
              call blankout(line,1,80)
              read (30,1000,end=100) line
              call lastchar(line,lc,80)
              if (line(1:1) .eq. '*' .and. lc .eq. 1) then
                read (30,*,end=888,err=888) numres
                nr=0
                do while (nr .lt. numres)
                  call blankout(line,1,80)
                  read (30,1000,end=100) line
                  call lastchar(line,lc,80)
                  if (mod(lc,5) .ne. 0) then
                    print *,'List of residues seem to be corrupted:' 
                    print *,line(1:lc)
                    stop
                  end if
                  nc=lc/5
                  do i=1,nc
                    nres=nres+1
                    resnames(nres)(1:3)=line((i-1)*5+3:i*5)
                    call changeprot(resnames(nres)(1:3),resnames1(nres),2)
                  end do
                  nr=nr+nc
                end do
                call blankout(line,1,80)
                read (30,1000,end=100) line
                nseg=nseg+1
                s4='    '
                if (line(1:8) .ne. 'GENERATE') then
                  s4(1:1)=abc(nseg)
                else
                  ic=10
                  call nextblank(line,ic,80)
                  len=min0(4,ic-10)
                  s4(1:len)=line(10:9+len)
                end if
                do i=1,numres
                  segnames(nresp+i)=s4
                end do
                nresp=nres
              end if
            end do
          else if (inpstyp .eq. 2) then
            ch=' '
            print *,'SEQRES input start'
            do while (.true.)
              call blankout(line,1,80)
              read (30,1000,end=100) line
              if (line(1:6) .eq. 'SEQRES') then
                call lastchar(line,lc,80)
                if (line(12:12) .ne. ch) nseg=nseg+1
                ch=line(12:12)
                ic0=20
                do while (ic0 .lt. lc)
                  nres=nres+1
                  segnames(nres)(1:1)=ch
                  segnames(nres)(2:4)='   '
                  resnames(nres)(1:3)=line(ic0:ic0+2)
                  call changeprot(resnames(nres)(1:3),resnames1(nres),2)
                  ic0=ic0+4
                end do
              end if
            end do
          else if (inpstyp .eq. 3 .or. inpstyp .eq. 4) then
            nseg=1
            call blankout(line,1,80)
            do while (line(1:1) .ne. '>')
              call blankout(line,1,80)
              read (30,1000,end=100) line
            end do
            do while (.true.)
              if (line(1:6) .ne. 'SEQNAM') then
                call lastchar(line,lc,80)
                do ic=1,lc
                  nres=nres+1
                  resnames1(nres)=line(ic:ic)
                  call changeprot(resnames(nres)(1:3),resnames1(nres),1)
                  segnames(nres)='A   '
                end do
              end if
            end do
          else if (inpstyp .eq. 5) then
            do while (.true.)
              call blankout(line,1,200)
              read (30,1000,end=100) line
              call lastchar(line,lc,200)
              ic=1
              call findnextchar('p',line,ic,200)
              if (lc-11 .gt. ic) then
                if (line(ic:ic+10) .eq. 'polypeptide') then
                  ch=abc(nseg+1)
                  if (line(lc:lc) .eq. '?') then
                    do k=1,3
                      call nextblank(line,ic,200)
                      ic=ic+1
                    end do
                    call nextchar(line,ic,200)
                    do while (line(ic:ic) .ne. ' ')
                      nres=nres+1
                      resnames1(nres)=line(ic:ic)
                      segnames(nres)=ch//'   '
                      call changeprot(resnames(nres)(1:3),resnames1(nres),1)
                      ic=ic+1
                    end do
                  else
                    nl=0
                    do while (nl .eq. 0 .or. line(1:1) .ne. ';')
                      call blankout(line,1,200)
                      read (30,1000,end=100) line
                      if (nl .eq. 0 .or. line(1:1) .ne. ';') then
                        call lastchar(line,lc,200)
                        incr=0
                        if (nl .eq. 0) incr=1
                        do ic=1+incr,lc
                          resnames1(nres-incr+ic)=line(ic:ic)
                          segnames(nres-incr+ic)=ch//'   '
                          call changeprot(resnames(nres-incr+ic)(1:3),
         -                  resnames1(nres-incr+ic),1)
                        end do
                        nres=nres+lc-incr
                        nl=nl+1
                        line(1:1)=' '
                      end if
                    end do
                  end if
                  nseg=nseg+1
                end if
              end if
            end do
          else if (inpstyp .eq. 6) then
            s4='    '
            do while (.true.)
              call blankout(line,1,200)
              read (30,1000,end=100) line
              call lastchar(line,lc,200)
              if (line(1:5) .eq. 'LOCUS') then
                ic=6
                call nextchar(line,ic,200)
                call nextblank(line,ic,200)
                call nextchar(line,ic,200)
                ic1=ic
                call nextblank(line,ic,200)
                read (line(ic1:ic-1),*,err=888) numres
                do i=1,4
                  read(30,1000,end=100) 
                end do
                nr=0
                do while (nr .lt. numres)
                  ir1=nr+1
                  ir2=min0(nr+50,numres)
                  read (30,1000,end=100) line
                  read(line,2001) (resnames1(nresp+i),i=ir1,ir2)
                  nr=nr+50
                end do
                nseg=nseg+1
                s4(1:1)=abc(nseg)
                do i=nresp+1,nresp+numres
                  segnames(i)=s4
                  call changeprot(resnames(i)(1:3),resnames1(i),1)
                end do
                nresp=nresp+numres
                nres=nresp
              end if
            end do
          end if
    100   print *,'Read ',nres,' residues in ',nseg,' segments'
          nresp=0
          segnames(nres+1)='    '
          do iseg=1,nseg
            s4=segnames(nresp+1)
            nrespc=nresp
            do while (segnames(nrespc+1) .eq. s4 .and. nrespc .lt. nres)
              nrespc=nrespc+1
            end do 
            if (iostyp .eq. 1) then
              write (31,2024) s4,nrespc-nresp,
         -      (resnames(i)(1:3),i=nresp+1,nrespc)
              write (31,2021) s4
            else if (iostyp .eq. 2) then
              ir1=nresp+1
              nl=0
              do while (ir1 .le. nrespc)
                nl=nl+1
                ir2=min0(nrespc,ir1+12)
                write (31,2100) nl,s4(1:1),nrespc-nresp,
         -        (resnames(ir)(1:3),ir=ir1,ir2)
                ir1=ir2+1
              end do
            else if (iostyp .eq. 3) then
              if (iseg .eq. 1) write (31,1000) '>SIMULAID conversion'
              write (31,2000) (resnames1(i),i=nresp+1,nrespc)
            else if (iostyp .eq. 4) then
              if (iseg .eq. 1) write (31,1000) '>SIMULAID conversion'
              write (31,2000) (resnames1(i),i=nresp+1,nrespc)
            else if (iostyp .eq. 5) then
              if (inpstyp .eq. 2) write (6,2029)
              call gcgwrite(0,l132,0,outfile,loutfile,31,
         -      resnames1(nresp+1),nrespc-nresp,.false.,1)
            end if
            nresp=nrespc
          end do
          close(30)
          close(31)
          return
    888   write (6,*) 'Invalid number of residues ic=',ic,' in ',line(1:40)
          stop
    1000  format(a)
    2000  format(75a1)
    2001  format(9x,10a1,1x,10a1,1x,10a1,1x,10a1,1x,10a1,1x)
    2021  format('GENERATE ',a4,' SETUP',/)
    2024  format('* Sequence list from SIMULAID Segid=',a4,/,
         -  '* ',/,i5,/,(12a5))
    2029  format(' NOTE: If the input is a full PDB file than the ',
         -  '<E>xtract sequence',/,' option can also obtain the additional',
         -  ' information asked below')
    2100  format('SEQRES',i4,1x,a1,i5,1x,13(1x,a3))
          end
          subroutine writeseq(outfile,namleno,numres,resnames,resnames1,
         -  numslv,line,index,inpcrdtyp,title,nslt,n,ionly,maxrsd,
         -  maxrec)
          dimension index(maxrec)
          character*200 outfile,seqfile
          character* 132 line(maxrec)
          character*80 title
          character*1 ans,resnames1(maxrsd)
          character*4 segid
          character*8 resnames(maxrsd)
          character*1 aanames1
          character*2 mmodtoamb
          character*3 aanames3
          character*80 seqid
          common /atnamcon/ mmodtoamb(100),aanames1(58),aanames3(58),
         -  naanames,nnanames,nnammnames,nnames,ixwatnam
          common /columnlim/ incol(19),iidcol(19),iialtcol(19),iiinscol(19),
         -  iinamcol(2,19),iirescol(2,19),iiccol(2,19),iiresncol(2,19),
         -  iiseqncol(2,19),iisegcol(2,19),iiresidcol(2,19),iiqcol(2,19),
         -  iipotcol(2,19),iiocccol(2,19),iichemcol(2,19)
          character*1 abc,digits,hexdigits
          common /charactersets/ ihex(25),abc(62),digits(14),hexdigits(25)
          character*5 crdext
          common /iotypes/ iocha,iochaex,iobpdb,iocpdb,ioa3pdb,ioa4pdb,
         -  iommod,iommc,iommc4,iogro,iomol2,iomae,iocif,ioxxx,ioins,
         -  ionxyz,iosxyz,iosxyzrq,iograsp,iofull,lext(19),crdext(19)
          character*6 typnam(5)
          character*30 question
          data typnam /'Charmm','PDB   ','1-char','PIR   ','GCG   '/
          if (inpcrdtyp .gt. ioins) then
            print *,'This input format does not have sequence information'
            stop
          end if
          if (ionly .eq. 0) then
            call askyn('Do you want a sequence list',27,1,-1,iseqls,0,0)
            if (iseqls .eq. 0) return
            iostyp=inpcrdtyp
            if (iostyp .gt. 2) iostyp=2
            write (6,2002) typnam(iostyp)
          else
            call quiz(ans,iostyp,' ',' ',0,
         -    'Output format for sequence list',31,0,5,6,00)
          end if
          call changeext(outfile,seqfile,namleno,namlens,'seq',3,0,0)
          call openfile(30,0,' ',1,'new',seqfile,namlens,notfnd,0,1,1,0,0)
          isegidc1=iisegcol(1,inpcrdtyp)
          isegidc2=iisegcol(2,inpcrdtyp)
          iresnc1=iiresncol(1,inpcrdtyp)
          iresnc2=iiresncol(2,inpcrdtyp)
          iresc1=iirescol(1,inpcrdtyp)
          iresc2=iirescol(2,inpcrdtyp)
          nrescol=iresc2-iresc1+1
          if (nslt .eq. n) then
            index(n+1)=index(n)+1
            line(index(n+1))(isegidc1:isegidc1)='*'
            line(index(n+1))(iresnc1:iresnc1)='*'
          end if
          lenseq=1
          lenseqo=1
          ia=1
          nseg=0
          nfail=0
          do while (ia .le. nslt)
            nseg=nseg+1
            segid=line(index(ia))(isegidc1:isegidc2)
            do while (segid .eq.
         -    line(index(ia))(isegidc1:isegidc2) .and. ia .le. nslt)
                ia=ia+1
                if (line(index(ia))(iresnc1:iresnc2) .ne.
         -          line(index(ia-1))(iresnc1:iresnc2)) then
                  resnames(lenseq)(1:nrescol)=
         -          line(index(ia-1))(iresc1:iresc2)
                  lenseq=lenseq+1
                end if
            end do
            if (iostyp .eq. 1) then
              write (30,2022)
              ifc=1
              call nextchar(title,ifc,80)
              if (ifc .lt. 78) write (30,2020) '* ', title(1:78)
              write (30,2024) segid,lenseq-lenseqo,
         -      (resnames(i)(1:nrescol),i=lenseqo,lenseq-1)
              write (30,2021) segid
              if (numslv .gt. 0) then
                write (30,2023)
         -        line(index(nslt+1))(isegidc1:isegidc2),numslv
                if (line(index(nslt+1))(isegidc1:isegidc2) .eq.
         -          line(index(nslt))(isegidc1:isegidc2))
         -      write (6,2026) line(index(nslt))(isegidc1:isegidc2)
              end if
            else if (iostyp .eq. 2) then
              ir1=lenseqo
              nl=0
              do while (ir1 .le. lenseq-1)
                nl=nl+1
                ir2=min0(lenseq-1,ir1+12)
                write (30,2100) nl,segid(1:1),lenseq-lenseqo,
         -        (resnames(ir)(1:3),ir=ir1,ir2)
                ir1=ir2+1
              end do
            else if (iostyp .ge. 3) then
              do ir=lenseqo,lenseq-1
                call changeprot(resnames(ir),resnames1(ir),2)
                if (resnames1(ir) .eq. '*') nfail=nfail+1
              end do
              if (iostyp .eq. 3) then
                if (nseg .eq. 1) write (30,2028) title
                write (30,2001) (resnames1(i),i=lenseqo,lenseq-1)
              else if (iostyp .eq. 4) then
                question='Sequence id of segment   '
                write (question(23:25),1002) nseg
                call getname(seqid,namlen,question,25,80,abc(nseg),1,0,0,0)
                call lastchar(title,lentit,80)
                lentit=min0(80,lentit+4+namlen)
                write (30,2027) seqid(1:namlen),title(1:lentit),
         -        seqid(1:namlen)
                resnames1(lenseq)='*'
                write (30,2001) (resnames1(i),i=lenseqo,lenseq)
              else
                call gcgwrite(inpcrdtyp,line,index(1),seqfile,namlens,30,
         -        resnames1(lenseqo),lenseq-lenseqo,.false.,maxrec)
              end if
            end if
            lenseqo=lenseq
          end do
          close (30)
          write (6,2025) typnam(iostyp),numres-numslv,seqfile(1:namlens)
          if (numslv .gt. 0) print *,'Number of solvent residues=',numslv
          if (nfail .gt. 0) print *,'WARNING',nfail,' residues had no ',
         -  '1-character version'
          return
    1002  format(i3)
    2001  format(80a1)
    2002  format(' Sequence is saved in ',a,' format',/,' Use the ',
         -  '<E>xtract sequence option to get it in other formats')
    2020  format(a,a)
    2021  format('GENERATE ',a4,' SETUP',/)
    2022  format('READ SEQUENCE CARD')
    2023  format('!Solvent segment',/,'READ SEQU',a4,1x,i6,/)
    2024  format('* Sequence list from SIMULAID Segid=',a4,/,
         -  '* ',/,i5,/,(12a5))
    2025  format(1x,a,' sequence (input) list of ',i6,' residues were',
         -  ' written to file ',/,5x,a)
    2026  format(' WARNING: Solvent segmentid (',a4,') is the same as',
         -  ' the last solute segment id')
    2027  format('>P1;',a,1x,a,/,'sequence:',a,':::::::0.0: 0.0')
    2028  format('>',a,a)
    2100  format('SEQRES',i4,1x,a1,i5,1x,13(1x,a3))
          end
          subroutine gcgwrite(inpcrdtyp,line,nhead,inpfile,leninpfile,ifile,
         -  seq,lenseq,skipnuc,maxrec)
          character*1 seq(lenseq),type
          character*4 pdbid
          character* 132 line(maxrec)
          character*200 inpfile
          character*40 keywords
          character*62 textinp
          character*5 crdext
          common /iotypes/ iocha,iochaex,iobpdb,iocpdb,ioa3pdb,ioa4pdb,
         -  iommod,iommc,iommc4,iogro,iomol2,iomae,iocif,ioxxx,ioins,
         -  ionxyz,iosxyz,iosxyzrq,iograsp,iofull,lext(19),crdext(19)
          logical skipnuc
          type='N'
          do i=1,lenseq
            if (seq(i) .ne. 'A' .and. seq(i) .ne. 'C' .and.
         -      seq(i) .ne. 'G' .and. seq(i) .ne. 'T' .and.
         -      seq(i) .ne. 'U') then
              type='P'
              go to 31
            end if
          end do
    31    if (skipnuc .and. type .eq. 'N') return
          pdbid='    '
          if (inpcrdtyp .gt. 0) then
            if (ispdb(inpcrdtyp) .gt. 0) then
              nhline=0
              do i=1,nhead
                if (line(i)(1:6) .eq. 'HEADER') then
                  nhline=nhline+1
                  if (nhline .eq. 1) then
                    pdbid=line(i)(63:66)
                    keywords=line(i)(11:50)
                  end if
                end if
              end do
            end if
          end if
          if (pdbid .eq. '    ') then
            call getname(keywords,len,'Keywords (max 40 chars)',23,40,'',0,
         -    0,0,0)
            call getname(pdbid,len,
         -    '4-character identifier (for LOCUS key)',38,4,'',0,0,0,0)
          end if
          write (ifile,1001) pdbid,lenseq
          icheck=0
          icount=0
          do l=1,lenseq
            icount=icount+1
            lchar=ichar(seq(l))  !convert to ascii decimal form
            if (lchar.ge.97 .and. lchar.le.122)
         -    lchar=lchar-32     !change lower case to upper case
            icheck=icheck + icount*lchar
            if (icount.eq.57) icount=0
          end do
          lsum=icheck/10000                  !integer division
          icheck=icheck - lsum*10000        !remainder which is the checksum
          ncline=0
          if (inpcrdtyp .gt. 0) then
            if (ispdb(inpcrdtyp) .gt. 0) then
              do i=1,nhead
                if (line(i)(1:6) .eq. 'COMPND') then
                  ncline=ncline+1
                  if (ncline .eq. 1) then
                    write (ifile,1003) line(i)(11:72)
                  else
                    write (ifile,1004) line(i)(11:72)
                  end if
                end if
              end do
            end if
          end if
          if (ncline .eq. 0) then
            call getname(textinp,len,'Compound name (for DEFINITION key)',
         -    34,62,'',0,0,0,3)
            write (ifile,1003) textinp
          end if
          write (ifile,1002) inpfile(1:leninpfile)
          write (ifile,1006) keywords
          write (ifile,1005) pdbid,lenseq,type,icheck
          nline=(lenseq-1)/50+1
          if=1
          linelim=50
          do iline=1,nline
            linc=(iline-1)*50
            if (iline .eq. nline) linelim=lenseq-linc
            nfirst=(iline-1)*50+1
            write (ifile,1000) nfirst,(seq(linc+l),l=if,linelim)
          end do
          return
    1000  format(i8,1x,5(10a1,1x))
    1001  format('LOCUS       ',a4,'------',i7,' AA    PROT',
         -  12x,'PRE-ENTRY 00/00/0')
    1002  format('ORIGIN      ',a)
    1003  format('DEFINITION  ',a62)
    1004  format(12x,a62)
    1005  format(1x,a4,' Length:',i5,' April 2, 1992      Type: ',a1,
         -  '  Check:',i6,' ..')
    1006  format('KEYWORDS    ',a62)
          end
          subroutine pbctype(ioppbc,npbc,ixyzhex,nonone)
          dimension ixyzhex(3)
          common /pbcrotmat/ torot_ac(3,3),torot_ca(3,3),tofac_ac,tofac_ca
          common /rotmat/ matrot0(4,4),matrot(4,4),nomat0
          character*1 xyz
          common /axislab/ xyz(3)
          character*1 ans,ansedge,ansvertex
    100   call quiz(ans,ians,'r',' ',0,'PBC cell type',13,0,5,6,0)
          if (ans .eq. 'n') then
            if (nonone .eq. 0) then
              ioppbc=-1
              npbc=1
            else
              print *,'No PBC choice is invalid in this context'
              go to 100
            end if
          else if (ans .eq. 'c') then
            ioppbc=1
            npbc=1
          else if (ans .eq. 'r') then
            ioppbc=2
            npbc=3
          else if (ans .eq. 'f') then
            ioppbc=3
            npbc=1
          else if (ans .eq. 'h' .or. ans .eq. 'w') then
    200     call quiz(ansedge,ixyzhex(1),' ',
         -    'parallel to the prism length',-28,'axis',4,0,5,6,0)
            call quiz(ansvertex,ixyzhex(2),' ',
         -    'going through the hexagon vertex',-32,'axis',4,0,5,6,0)
            if (ansedge .eq. ansvertex) then
              print *,'ERROR: can not use the same axes twice'
              go to 200
            end if
            ixyzhex(3)=1
            do while (ixyzhex(3) .eq. ixyzhex(1) .or.
         -    ixyzhex(3) .eq. ixyzhex(2))
              ixyzhex(3)=ixyzhex(3)+1
            end do
            write (6,2000) xyz(ixyzhex(1)),xyz(ixyzhex(2))
            if (ans .eq. 'h') then
              ioppbc=4
              npbc=2
            else
              ioppbc=5
              npbc=3
            end if
          else if (ans .eq. 't' .or. ans .eq. 'o') then
            npbc=1
            torot_ac(1,1)=1.0/sqrt(3.0)
            torot_ac(2,1)=1.0/sqrt(3.0)
            torot_ac(3,1)=1.0/sqrt(3.0)
            torot_ac(1,2)=-1.0/sqrt(6.0)
            torot_ac(2,2)=-1.0/sqrt(6.0)
            torot_ac(3,2)=2.0/sqrt(6.0)
            torot_ac(1,3)=1.0/sqrt(2.0)
            torot_ac(2,3)=-1.0/sqrt(2.0)
            torot_ac(3,3)=0.0
            tofac_ac=2.0/sqrt(3.0)
            torot_ca(1,1)=1.0/sqrt(3.0)
            torot_ca(1,2)=1.0/sqrt(3.0)
            torot_ca(1,3)=1.0/sqrt(3.0)
            torot_ca(2,1)=-1.0/sqrt(6.0)
            torot_ca(2,2)=-1.0/sqrt(6.0)
            torot_ca(2,3)=2.0/sqrt(6.0)
            torot_ca(3,1)=1.0/sqrt(2.0)
            torot_ca(3,2)=-1.0/sqrt(2.0)
            torot_ca(3,3)=0.0
            tofac_ca=sqrt(3.0)/2.0
            if (ans .eq. 't') then
              ioppbc=6
              write (6,2011)
            else if (ans .eq. 'o') then
              ioppbc=7
              npbc=1
              write (6,2012)
            end if
          else if (ans .eq. 'x') then
            ioppbc=8
            npbc=1
          else if (ans .eq. 'd') then
            ioppbc=9
            npbc=1
            write (6,2013)
          else if (ans .eq. 'i') then
            ioppbc=10
          else if (ans .eq. 's') then
            ioppbc=11
            npbc=1
          else
            print *,'PROGRAM ERROR'
          end if
          return
    2000  format(' Hexagonal prism edge: along the ',a,' axis',/,
         -  ' Axis going through the hexagon: ',a)
    2011  format(' Charmm convention - X axis is normal to a square')
    2012  format(' Amber/NAMD convention - X axis is normal to a hexagon')
    2013  format(' NOTE: For now, this PBC can not be used for optimizing',
         -  ' orientation')
          end
          subroutine pbcsize(ioppbc,edge,npbc)
          dimension edge(3)
          character*1 xyz
          common /axislab/ xyz(3)
          common /numbers/ sq3,sq3inv,sq3p2,sq2p3
          if (ioppbc .eq. 0) then
          else if (ioppbc .eq. 1) then
            call getreal('Edge length (A)',15,999999.0,edge(1),1,0)
          else if (ioppbc .eq. 2) then
            do k=1,3
              call getreal('Edge length in the '//xyz(k)//' direction (A)',
         -      34,999999.0,edge(k),1,0)
            end do
          else if (ioppbc .eq. 3) then
            call getreal('Edge parameter of the FCC cell (A)',34,999999.0,
         -    edge(1),1,58)
          else if (ioppbc .eq. 4) then
            call getreal('Length of the prism (A)',23,999999.0,edge(1),1,0)
            call getreal('Edge of the hexagon (A)',23,999999.0,edge(2),1,0)
          else if (ioppbc .eq. 5) then
            call getreal('Length of the prism (A)',23,999999.0,edge(1),1,0)
            call getreal('Cell length (a) along Cartesian axis (A)',40,
         -    999999.0,edge(3),1,59)
            call getreal(
         -    'Cell length (b) at ca 120 deg of Cartesian axis (A)',51,
         -    999999.0,edge(2),1,59)
          else if (ioppbc .eq. 6) then
            call getreal('Charmm periodic cell X coordinate (A)',37,
         -    999999.0,cellx,1,60)
            edge(1)=cellx/2.0
          else if (ioppbc .eq. 7) then
            call getreal('Amber/NAMD periodic cell X coordinate (A)',41,
         -    999999.0,cellx,1,60)
            edge(1)=(cellx/2.0)/sq3p2
          else if (ioppbc .eq. 8) then
            call getreal('Inscribed sphere diameter (A)',29,999999.0,
         -    edge(1),1,61)
          else if (ioppbc .eq. 9) then
            call getreal('Edge of the rhomboid (A)',24,999999.0,
         -    edge(1),1,00)
          else if (ioppbc .eq. 10) then
            call getreal('Radius of the sphere',20,999999.0,edge(1),1,0)
          end if
          do k=npbc+1,3
            edge(k)=edge(npbc)
          end do
          return
          end
          subroutine readimg(cell,ncell)
          dimension cell(3,27)
          character*1 xyz
          common /axislab/ xyz(3)
          character*1 abc,digits,hexdigits
          common /charactersets/ ihex(25),abc(62),digits(14),hexdigits(25)
          character*1 ans
          character*80 line
          character*200 imgfile
          dimension scale(3)
          call quiz(ans,ians,' ','image',5,'PBC cell type',13,0,5,6,0)
          lenfilename=0
          call openfile(30,0,'image',5,'old',imgfile,lenfilename,notfnd,
         -  1,1,1,0,0)
          if (ans .eq. 'c') then
            do k=1,3
              call getreal(
         -    'Charmm '//xyz(k)//' axis image parameter (@'//abc(58+k)//')',
         -      34,999999.0,scale(k),1,0)
            end do
            ncell=1
            call zeroit(cell,3)
            rewind 30
            line(1:3)='   '
            do while (line(1:3) .ne. 'END' .and. line(1:3) .ne. 'end')
              read (30,888,end=999) line
              if (line(1:3) .eq. 'END') then
                print *,'Read ',ncell-1,' images - (0,0,0) was added'
              else
                if (line(1:5) .eq. 'TRANS') then
                  ncell=ncell+1
                  read (line(7:36),900,err=998) (cell(k,ncell),k=1,3)
                  do k=1,3
                    cell(k,ncell)=-scale(k)*cell(k,ncell)
                  end do
                end if
              end if
            end do
          else
            do k=1,3
              call getreal('Multiplying factor for the '//xyz(k)//' axis',
         -      33,1.0,scale(k),1,37)
            end do
            ncell=0
            do while (.true.)
              read (30,1001,err=998,end=100) (cell(k,ncell+1),k=1,3)
              ncell=ncell+1
              do k=1,3
                cell(k,ncell)=cell(k,ncell)*scale(k)
              end do
            end do
    100     print *,'Read ',ncell,' cell centers - (0,0,0) is assumed ',
         -    'to be listed'
          end if
          return
    998   write (6,1000) ncell,line(7:36)
          stop
    999   print *,'ERROR: Image file is not terminated properly'
          stop
    900   format(3f10.0)
    888   format(a80)
    1000  format(' ERROR: invalid cell coordinate input for cell ',i3,
         -  ':',/,8x,a)
    1001  format(3f10.5)
          end
          subroutine setpbccell(quest,lquest,edge,edge_gen,cell,ncell,
         -  cellalt,ixyzhex,npbc,ioppbc,iusepbc,vol,nw,rinscr,
         -  rcirc,nonone)
          dimension edge(3),edge_gen(3,3),cell(3,27),cellalt(3,27),
         -  ixyzhex(3)
          character*(*) quest
          iusepbc=1
          if (lquest .gt. 0) call askyn(quest,lquest,1,-1,iusepbc,0,0)
          if (iusepbc .eq. 1) then
            call pbctype(ioppbc,npbc,ixyzhex,nonone)
            call pbcsize(ioppbc,edge,npbc)
            if (ioppbc .eq. 0) then
              call readimg(cell,ncell)
            else
              call crorgn(edge,edge_gen,ioppbc,3,ncell,cell,cellalt,
         -      ixyzhex,rinscr,rcirc)
            end if
            call prtcell(ioppbc,edge,edge_gen,0.0,vol,nw,1)
          end if
          if (ioppbc .eq. -1) iusepbc=0
          return
          end
          subroutine compact(co,cn,iatnum,ih,n,nnh,c0,rmin,rorgext,rorgcom,
         -  list,np,nlist,nocom,r,maxrec)
          dimension co(3,n),cn(3,n),iatnum(n),ih(n),c0(3),list(n),r(n)
          character*2 iatnm2
          common /atnam/ aw(99),nval(99),nvalmax(99),mmofan(99),
         -  mmatno(64),iatnm2(99)
          dimension cmin(3),cmax(3),del(3),c1(3),c2(3),c3(3),c4(3),ca(3),
         -  rd(4),czero(3),cai(2),com(3),iopp(3)
          data iopp/0,0,0/,idiagplane /0/,nopp /0/
          call zeroit(czero,3)
          call extension(co,ih,nnh,1,n,cmin,cmax,c0,0,0,v)
          r0=0.0
          do k=1,3
            if (cmax(k) -c0(k) .gt. r0) r0=cmax(k)-c0(k)
          end do
          if (nocom .eq. 0) then
            do i=1,n
              r(i)=0.0
              if (iatnum(i) .gt. 0) r(i)=aw(iatnum(i))
            end do
            call cofms(co,com,n,r)
          end if
          r02=r0**2
          extfac=0.36
    31    nlist=0
          rmaxext=0
          do ii=1,nnh
            i=ih(ii)
            ri2=dist2(co(1,i),c0)
            if (ri2 .ge. r02*extfac) then
              nlist=nlist+1
              list(nlist)=i
              r(nlist)=ri2
              if (ri2 .gt. rmaxext) then
                rmaxext=ri2
                lmax=nlist
              end if
            end if
          end do
          if (nlist .lt. 2) then
            print *,'Too few atoms remained:',nlist
            call askyn('Do you want to keep all atoms instead',37,
         -    1,1,ikeep,0,0)
            if (ikeep .eq. 0) stop
            extfac=0.0
            go to 31
          end if
          nlstorg=nlist
          rorgext=sqrt(rmaxext)
          if (rorgext .lt. 0.01) then
            print *,'ERROR: The original radius of the solute is < 0.01'
            stop
          end if
          if (nocom .eq. 0) then
            rmaxcom=0.0
            do ii=1,nnh
              i=ih(ii)
              ri2=dist2(co(1,i),com)
              if (ri2 .gt. rmaxcom) then
                rmaxcom=ri2
              end if
            end do
            rorgcom=sqrt(rmaxcom)
          end if
          nstep=1
          np=1
          call swapl(list,r,nlist,lmax,-1,maxrec)
          call lpshiftc(co,list,nlist,del,c0,np,maxrec)
          call findshift(co,r,list,c0,del,nlist+1,nlist,rlambda,lmax,nzero,
         -  maxrec)
          call transc(c0,del,rlambda)
          call newdist(r,co,list,c0,nlstorg,maxrec)
          np=2
          nlistdel=0
          call swapl(list,r,nlist,lmax,-1,maxrec)
    30    nstep=nstep+1
          call lpshiftc(co,list,nlist,del,c0,np,maxrec)
          call findshift(co,r,list,c0,del,nlist+1,nlist-nlistdel,
         -  rlambda,lmax,nzero,maxrec)
          nlistdel=0
          do k=1,3
            c1(k)=co(k,list(nlist+1))-c0(k)
          end do
          rlammax=scprod(c1,del)
          if ((rlambda .ge. rlammax .or. rlambda .eq. 0.0) .and.
         -  nzero .le. 1) then
            write (6,1001) list(nlist+1),list(nlist+2)
            rlambda=rlammax
            go to 90
          end if
    33    call angles(r(lmax),r(nlist+1),r(nlist+2),cal,ca(1),ca(2))
          do ic=1,2
            if (ca(ic) .lt. 0.0) then
              call swapl(list,r,nlist+ic,lmax,0,maxrec)
              call swapl(list,r,nlist-nlistdel,lmax,0,maxrec)
              nlistdel=nlistdel+1
              call transc(c0,del,rlambda)
              call newdist(r,co,list,c0,nlstorg,maxrec)
              write (6,1002) list(nlist),list(nlist+1),list(nlist+2)
              go to 30
            end if
          end do
          call transc(c0,del,rlambda)
          call newdist(r,co,list,c0,nlstorg,maxrec)
          np=3
          if (nlistdel .eq. 0) then
            call swapl(list,r,nlist,lmax,-1,maxrec)
          else
            call swapl(list,r,nlist,nlist-nlistdel,0,maxrec)
            call swapl(list,r,nlist,lmax,-1,maxrec)
          end if
    40    nstep=nstep+1
          do k=1,3
            c1(k)=co(k,list(nlist+2))-co(k,list(nlist+1))
            c2(k)=co(k,list(nlist+3))-co(k,list(nlist+1))
          end do
          call vprd(c1,c2,del)
          do k=1,3
            c1(k)=co(k,list(nlist+1))-c0(k)
          end do
          facsgn=1.0
          if (scprod(c1,del) .lt. 0.0) facsgn=-1.0
          call norm(del,facsgn)
          call findshift(co,r,list,c0,del,nlist+1,nlist-nlistdel,
         -  rlambda,lmax,nzero,maxrec)
          nlistdel=0
          rlammax=scprod(c1,del)
          idiagplane=0
          if (rlambda .ge. rlammax) then
            write (6,1003) list(nlist+1),list(nlist+2),list(nlist+3)
            rlambda=rlammax
            idiagplane=1
            go to 90
          end if
          call transc(c0,del,rlambda)
          call newdist(r,co,list,c0,nlstorg,maxrec)
          rlambda=0.0
          ix=list(lmax)
          do ip=1,np
            nopp=0
            call getindex(nlist,ip,iv,i1,i2)
            do k=1,3
              c1(k)=co(k,list(i1))-co(k,ix)
              c2(k)=co(k,list(i2))-co(k,ix)
              c3(k)=co(k,list(iv))-co(k,ix)
              c4(k)=c0(k)-co(k,ix)
            end do
            call vprd(c1,c2,ca)
            if (scprod(ca,c3)*scprod(ca,c4) .lt. 0.0) then
              nopp=nopp+1
              iopp(nopp)=ip
            end if
          end do
          if (nopp .eq. 1) then
            ip=nlist+iopp(1)
            call swapl(list,r,nlist+1,ip,0,maxrec)
            write (6,1004) list(lmax),list(nlist+1),list(nlist+2),
         -    list(nlist+3)
            nlistdel=nlistdel+1
            nlist=nlist+1
            np=np-1
            go to 33
          else if (nopp .eq. 2) then
            do ic=1,2
              ip=iopp(ic)
              call getindex(nlist,ip,iv,i1,i2)
              call angles(dist2(co(1,i1),co(1,i2)),r(i1),r(i2),
         -                caix,cai(1),cai(2))
              if (cai(1)*cai(2) .gt. 0.0) then
                call swapl(list,r,nlist+ip,lmax,0,maxrec)
                call swapl(list,r,nlist,lmax,0,maxrec)
                nlistdel=nlistdel+1
                write (6,1005) list(nlist),
         -        list(nlist+1),list(nlist+2),list(nlist+3)
                go to 40
              end if
            end do
            call swapl(list,r,nlist+iopp(1),nlist+1,0,maxrec)
            call swapl(list,r,nlist+iopp(2),nlist+2,0,maxrec)
            nlistdel=2
            nlist=nlist+2
            np=2
            go to 30
          end if
          np=4
          call swapl(list,r,nlist,lmax,-1,maxrec)
    90    call transc(c0,del,rlambda)
          call newdist(r,co,list,c0,nlstorg,maxrec)
          call shiftmol(co,n,c0,cn,-1.0)
          rminmax=0.0
          do ip=1,np
            ii=list(nlist+ip)
            rd(ip)=sqrt(cn(1,ii)**2+cn(2,ii)**2+cn(3,ii)**2)
            if (rminmax .lt. rd(ip)) rminmax=rd(ip)
          end do
          rmin=rminmax
          write (6,1000) (list(nlist+ip),ip=1,np)
          ndiff=0
          do ip=2,np
            if (abs(rd(ip)-rmin) .gt. 0.001) ndiff=ndiff+1
          end do
          if (ndiff-idiagplane .gt. 0) then
              print *,'PROGRAM ERROR: The radii of the points on',
         -    ' the sphere are different:'
             write (6,1010) (rd(ii),ii=1,np)
          end if
          call chksphr(cn,ih,n,nnh,rmin,czero)
          return
    1000  format(' --- Sphere-spanning atoms:',4i6)
    1001  format(' --- Diameter found spanned by atoms',2i6)
    1002  format(' --- Center of circle outside the triangle',3i6)
    1003  format(' --- Diagonal plane found spanned by atoms',3i6)
    1004  format(' --- Sphere center is outside one tetrahedron face',4i6)
    1005  format(' --- Sphere center is outside two tetrahedron faces',4i6)
    1010  format('Radii=',4f8.4)
          end
          subroutine swapl(list,r,nlist,lmax,nlincr,maxrec)
          dimension list(maxrec),r(maxrec)
          call swapi4(list(nlist),list(lmax))
          rr=r(nlist)
          r(nlist)=r(lmax)
          r(lmax)=rr
          nlist=nlist+nlincr
          return
          end
          subroutine lpshiftc(c,list,nlist,del,c0,np,maxrec)
          dimension c(3,maxrec),list(maxrec),del(3),c0(3)
          do k=1,3
            del(k)=0.0
            do ip=1,np
              del(k)=del(k)+c(k,list(nlist+ip))
            end do
            del(k)=del(k)/np-c0(k)
          end do
          call norm(del,1.0)
          return
          end
          subroutine findshift(c,r,list,c0,del,is,nlist,rlambda,lmax,nzero,
         -  maxrec)
          dimension c(3,maxrec),r(maxrec),list(maxrec),c0(3),del(3)
          nzero=0
          rl2=r(is)
          rl=sqrt(rl2)
          coslrl=0.0
          do k=1,3
            coslrl=coslrl+del(k)*(c(k,list(is))-c0(k))
          end do
          rlambda=rl2
          do i=1,nlist
            ri2=r(i)
            ri=sqrt(ri2)
            cosiri=0.0
            do k=1,3
              cosiri=cosiri+del(k)*(c(k,list(i))-c0(k))
            end do
            if (coslrl .ne. cosiri) then
              rlambdai=(rl2-ri2)/(2.0*(coslrl-cosiri))
            else
              rlambdai=0.0
            end if
            if (rlambdai .lt. rlambda .and. rlambdai .ge. 0.0) then
              rlambda=rlambdai
              lmax=i
            end if
            if (rlambdai .lt. 1.e-4 .and. rlambdai .ge. 0.0) then
              call swapl(list,r,nlist-nzero,lmax,-1,maxrec)
              lmax=nlist-nzero
              nzero=nzero+1
            end if
          end do
          return
          end
          subroutine getindex(nlist,ip,iv,i1,i2)
          iv=nlist+ip
          i1=nlist+mod(ip,3)+1
          i2=nlist+mod(ip+1,3)+1
          return
          end
          subroutine transc(c0,del,rlambda)
          dimension c0(3),del(3)
          do k=1,3
            c0(k)=c0(k)+rlambda*del(k)
          end do
          return
          end
          subroutine newdist(r,c,list,c0,n,maxrec)
          dimension r(maxrec),c(3,maxrec),list(maxrec),c0(3)
          do i=1,n
            li=list(i)
            r(i)=dist2(c(1,li),c0)
          end do
          return
          end
          subroutine chksphr(c,ih,n,nnh,rmin,czero)
          dimension c(3,n),ih(n),czero(3)
          do ii=1,nnh
            i=ih(ii)
            rr=dist2(c(1,i),czero)
            if (rr-0.001 .gt. rmin**2) then
              print *,'PROGRAM ERROR: Atom ',i,' is outside the sphere'
              rr=sqrt(rr)
              print *,'  rmin=',rmin,' r=',rr
            end if
          end do
          return
          end
          subroutine angles(e1,e2,e3,ca1,ca2,ca3)
          ee1=sqrt(e1)
          ee2=sqrt(e2)
          ee3=sqrt(e3)
          ca1=(e2+e3-e1)/(2.0*ee2*ee3)
          ca2=(e1+e3-e2)/(2.0*ee1*ee3)
          ca3=(e1+e2-e3)/(2.0*ee1*ee2)
          return
          end
          subroutine normplane(a,b,c,rn)
          dimension a(3),b(3),c(3),rn(3)
          dimension d1(3),d2(3)
          do k=1,3
            d1(k)=a(k)-b(k)
            d2(k)=c(k)-b(k)
          end do
          call vprd(d1,d2,rn)
          call norm(rn,1.0)
          return
          end
          subroutine radcirc(a,b,c,r)
          dimension a(3),b(3),c(3)
          call angdistw(b,a,c,rHB,rb,rac,angabc)
          sabc=sin(angabc)
          if (sabc .lt. 0.00001) then
            r=999999.9
          else
            r=rac/(sin(angabc)*2.0)
          end if
          return
          end
          subroutine pseudorot(a,n,ix,nmem,nneig,ineig,psr5,psr,npsr,ansrun,
         -  incgen,z,r,sinpsrs,cospsrs,q,qs,q2s,zav,zsq,zavs,zsqs,
         -  iprint,iout,nconf,radtodeg,maxng,maxrec)
          real*8 sinpsrs,cospsrs,qs,q2s,zavs,zsqs
          dimension a(3,n),ix(nmem),nneig(n),ineig(maxng,n),psr5(5),
         -  psr(nmem),z(nmem),r(3,nmem),sinpsrs(nmem),cospsrs(nmem),
         -  q(nmem),qs(nmem),q2s(nmem)
          character*1 ansrun
          dimension r0(3),r1(3),r2(3),rnorm(3),theta(5)
          if (nmem .eq. 0) return
          npsr=0
          pi=atan(1.0)*4.0
          denomfac=2.0*(sin(36.0*pi/180.0)+sin(72.0*pi/180.0))
          do i=1,nmem
            if (ix(i) .lt. 1 .or. ix(i) .gt. n) then
              print *,'ERROR: invalid atomindex:',ix(i)
              return
            end if
            j=mod(i,nmem)+1
            do in=1,nneig(ix(i))
              if (ineig(in,ix(i)) .eq. ix(j)) go to 100
            end do
            write (iout,1000) ix(i),ix(j),sqrt(dist2(a(1,ix(i)),a(1,ix(j))))
    100     continue
          end do
          npsr=(nmem-1)/2
          if (nconf .eq. 1) then
            zsqs=0.d0
            zavs=0.d0
            do i=1,npsr
              sinpsrs(i)=0.d0
              cospsrs(i)=0.d0
              qs(i)=0.d0
              q2s(i)=0.d0
            end do
          end if
          if (nmem .eq. 5) then
            do it=1,5
              theta(it)=dihangl(a,ix(mod(it-1,5)+1),ix(mod(it,5)+1),
         -      ix(mod(it+1,5)+1),ix(mod(it+2,5)+1),0,maxrec)
            end do
            do id=0,4
              psr0=radtodeg*atan(((theta(mod(2+id,5)+1)+
         -         theta(mod(4+id,5)+1))-(theta(mod(1+id,5)+1)+
         -         theta(mod(3+id,5)+1)))/(theta(mod(id,5)+1)*denomfac))
              if (theta(mod(id,5)+1) .lt. 0) psr0=psr0+180.0
              psr5(id+1)=psr0
            end do
          end if
          call zeroit(r0,3)
          call zeroit(r1,3)
          call zeroit(r2,3)
          do i=1,nmem
            do k=1,3
              r0(k)=r0(k)+a(k,ix(i))
            end do
          end do
          do i=1,nmem
            do k=1,3
              r(k,i)=a(k,ix(i))-r0(k)/nmem
              r1(k)=r1(k)+r(k,i)*sin(2.0*pi*(i-1)/float(nmem))
              r2(k)=r2(k)+r(k,i)*cos(2.0*pi*(i-1)/float(nmem))
            end do
          end do
          call vprd(r1,r2,rnorm)
          rnmag=sqrt(rnorm(1)**2+rnorm(2)**2+rnorm(3)**2)
          do k=1,3
            rnorm(k)=rnorm(k)/rnmag
          end do
          zsq=0.0
          do i=1,nmem
            z(i)=scprod(rnorm,r(1,i))
            zsq=zsq+z(i)**2
          end do
          zav=sqrt(zsq)
          if (nconf .gt. 0) then
            zavs=zavs+zav
            zsqs=zsqs+zsq
          end if
          sinsum=0.0
          cossum=0.0
          do m=2,npsr
            do i=1,nmem
              sinsum=sinsum-z(i)*sin(2*pi*m*(i-1-incgen)/float(nmem))
              cossum=cossum+z(i)*cos(2*pi*m*(i-1-incgen)/float(nmem))
            end do
            q(m)=sqrt((2.0/float(nmem))*(sinsum**2+cossum**2))
            tn=sinsum/cossum
            sqdenom=sqrt(1.0+tn*tn)
            sn=tn/sqdenom
            cs=1.0/sqdenom
            if (sinsum .lt. 0 .and. sn .gt. 0.0) sn=-sn
            if (cossum .lt. 0 .and. cs .gt. 0.0) cs=-cs
            if (nconf .gt. 0) then
              sinpsrs(m)=sinpsrs(m)+sn
              cospsrs(m)=cospsrs(m)+cs
              qs(m)=qs(m)+q(m)
              q2s(m)=q2s(m)+q(m)**2
            end if
            psr(m)=atansc(sn,cs,1,radtodeg)
          end do
          if (npsr .gt. 0)  then
            if (nmem .eq. 5) then
              psrndb=psr5(1)
              do id=1,4
                psrcorr=psr5(id+1)-id*144.0
                if (abs(psrcorr+360.0-psr5(id+1)) .lt.
         -          abs(psrcorr-psr5(id+1))) psrcorr=psrcorr+360.0
                if (abs(psrcorr-360.0-psr5(id+1)) .lt.
         -          abs(psrcorr-psr5(id+1))) psrcorr=psrcorr-360.0
                psrav=psrav+psrcorr
                psr5(id+1)=psrcorr
              end do
              psrav=psrav/5.0
            end if
            if (iprint .eq. 1) then
              if (ansrun .eq. '5') write (iout,1003) psrndb
              if (nmem .eq. 1) write (iout,1005) psr5,psrav
              write (iout,1007) zav
              write (iout,1006) 'angles',(psr(i),i=2,npsr)
              write (iout,1006) 'amplitudes',(q(i),i=2,npsr)
            end if
          end if
          return
    1000  format(' WARNING: atoms ',i6,' and ',i6,' are not bonded, dij=',
         -  f8.3,' A',/,10x,'- ring is not complete')
    1003  format(' Torsion-based pseudorotation angle, NDB convention=',
         -  f8.3,' deg')
    1005  format(' Phase corrected torsion-based pseudorotation angles ',
         -  'with all origins:',/,5x,5f8.3,' deg   Mean=',f8.3,' deg')
    1006  format(' General puckering ',a,' (Cremer & Pople)=',/,(10f8.2))
    1007  format(' Root mean square distance from the mean plane=',f8.2,
         -  ' A')
          end
          subroutine getring(line,index,ix5,irescol1,irescol2,
         -  inamcol1,inamcol2,n,numres,iresring,iresno,ifres,ilres,nmem,
         -  ansrun,noask,incgen,iapex,maxring,maxrec)
          character* 132 line(maxrec)
          dimension index(maxrec),ix5(maxring),iresno(n),ifres(maxrec),
         -  ilres(maxrec)
          character*1 ansrun
          character*2 s5name(5),pname(5),s6name(6)
          character*4 atomnam
          character*15 question
          data s5name /'C1','C2','C3','C4','O4'/
          data s6name /'C1','C2','C3','C4','C5','O5'/
          data pname /'CA','CB','CG','CD','N '/
          data question /'Ring member #  '/
          notfound=0
    100   if (noask .eq. 0)
         -   call quiz(ansrun,irtyp,' ',' ',0,'ring type',9,0,5,6,0)
          if (ansrun .eq. 'd') then
            nmem=0
            return
          else if (ansrun .eq. 'g') then
            call getint('Number of atoms in the ring',27,nmem,1,MAXRING,
         -    nmem,0)
            do i=1,nmem
              write (question(14:15),1000) i
              call getint(question,15,999999,1,n,ix5(i),00)
            end do
            incgen=0
          else if (noask .eq. 0) then
            call getint('Residue number of the ring',26,0,1,numres,iresring,
         -    0)
            if (iresring .lt. 1 .or. iresring .gt. iresno(n)) then
              write (6,1001) iresring,iresno(n)
              go to 100
             end if
          end if
          if (ansrun .eq. '6') then
            nmem=6
            incgen=5
            do i=1,nmem
              do ia=ifres(iresring),ilres(iresring)
                atomnam=line(index(ia))(inamcol1:inamcol1+3)
                call leftadjust4(atomnam,atomnam)
                if (atomnam(1:2) .eq. s6name(i) .and.
         -          atomnam(3:3) .ne. ' ') then
                  ix5(i)=ia
                  go to 110
                end if
              end do
              write (6,1002) s6name(i),iresring,
         -      line(index(ifres(iresring)))(irescol1:irescol2)
              notfound=1
    110       continue
            end do
          else if (ansrun .eq. '5') then
            nmem=5
            incgen=4
            do i=1,nmem
              do ia=ifres(iresring),ilres(iresring)
                atomnam=line(index(ia))(inamcol1:inamcol1+3)
                call leftadjust4(atomnam,atomnam)
                if (atomnam(1:2) .eq. s5name(i) .and.
         -          atomnam(3:3) .ne. ' ') then
                  ix5(i)=ia
                  go to 120
                end if
              end do
              notfound=1
              write (6,1002) s5name(i),iresring,
         -      line(index(ifres(iresring)))(irescol1:irescol2)
    120       continue
            end do
          else if (ansrun .eq. 'p') then
            nmem=5
            incgen=4
            do i=1,nmem
              do ia=ifres(iresring),ilres(iresring)
                atomnam=line(index(ia))(inamcol1:inamcol1+3)
                call leftadjust4(atomnam,atomnam)
                if (atomnam(1:2) .eq. pname(i)) then
                  ix5(i)=ia
                  go to 130
                end if
              end do
              notfound=1
              write (6,1002) pname(i),iresring,
         -      line(index(ifres(iresring)))(irescol1:irescol2)
    130       continue
            end do
          end if
          nnamcol=inamcol2-inamcol1+1
          if (notfound .eq. 1) then
            nmem=0
          else
            if (nnamcol .gt. 0) then
            write (6,1003) (ix5(i),line(index(ix5(i)))(irescol1:irescol2),
         -    line(index(ix5(i)))(inamcol1:inamcol2),i=1,nmem)
            iapex=ix5(incgen+1)
            write (6,1007) iapex,' ',
         -    line(index(ix5(incgen+1)))(irescol1:irescol2),
         -    line(index(ix5(incgen+1)))(inamcol1:inamcol2)
            else
              write (6,1004) (ix5(i),i=1,nmem)
              write (6,1007) iapex
            end if
          end if
          return
    1000  format(i2)
    1001  format(' ERROR: residue number ',i5,' is outside the [0,',i5,
         -  '] range')
    1002  format(' ERROR: ring atom ',a,' is not found in residue ',i4,
         -  ' (',a,')')
    1003  format(' Calculations for ring',/,5(i6,' ',a,1x,a))
    1004  format(' Calculations for ring',/,(5i6))
    1007  format(' Apex of ring: atom',i6,a,'(',a,1x,a,')')
          end
          subroutine diagonal(cn,ih,n,nnh,edge,ioppbc,cell,ncell,
         -  ixyzhex,closorgd,closest)
          dimension cn(3,n),ih(n),edge(3),cell(3,27),ixyzhex(3)
          dimension rot(3,3)
          closorgd=distminimg(cn,ih,n,nnh,edge,ioppbc,cell,ncell,ixyzhex,
         -  inod,jnod)
          sq2=sqrt(edge(1)**2+edge(2)**2)
          sq3=sqrt(edge(1)**2+edge(2)**2+edge(3)**2)
          rot(1,1)= edge(1)/sq3
          rot(1,2)=-edge(2)/sq3
          rot(1,3)=-edge(3)/sq3
          rot(2,1)= edge(2)/sq2
          rot(2,2)= edge(1)/sq2
          rot(2,3)=0.0
          rot(3,1)= edge(1)*edge(3)/(sq2*sq3)
          rot(3,2)=-edge(2)*edge(3)/(sq2*sq3)
          rot(3,3)= sq2/sq3
          call rotate_c(cn,n,rot,cn,'DIAGONAL',8)
          closest=distminimg(cn,ih,n,nnh,edge,ioppbc,cell,ncell,ixyzhex,
         -  innd,jnnd)
          return
          end
          subroutine checkwall(ioppbc,edge,cmin,cmax,c,cell,ncell1,ncell,
         -  ih,nslt,nnh,walld)
          dimension edge(3),cmin(3),cmax(3),c0(3),c(3,nslt),ih(nslt),
         -  cell(3,27)
          if (ioppbc .eq. 1 .or. ioppbc .eq. 2) then
            call extension(c,ih,nnh,1,nslt,cmin,cmax,c0,0,0,v)
            walld=1000.0
            do k=1,3
              wd=(edge(k)-(cmax(k)-cmin(k)))/2.0
              if (wd .lt. walld) walld=wd
            end do
          else
            walld=1.0
            do ia=1,nslt
              call genimdist(c(1,ia),cell,ncell1,ncell,icmin,rmin2)
              if (icmin .gt. 1) walld=-1.0
            end do
          end if
          return
          end
          subroutine trystat(opt,try,ntry,label,llabel)
          dimension try(200)
          character*(*) label
          nt=min0(200,ntry)
          nopt=0
          do it=1,nt
            if (abs(try(it)-opt)/abs(abs(try(it))+abs(opt)) .lt. 0.00001)
         -    nopt=nopt+1
          end do
          write (6,1000) label(1:llabel),nopt
          if (nopt .eq. 0) print *,'WARNING: best orientation was ',
         -  'optimzed from the input conformation'
          if (nopt .eq. 1) print *,
         -  'WARNING: more random trys are likely to reach better optimum'
          return
    1000  format(' The number of times the optimal ',a,' was reached=',i3)
          end
          subroutine optimizebound(co,cn,cnew,ih,nslt,nnh,n,rot,mintyp,
         -  ixyzhex,i2dopt,ftol)
          dimension co(3,n),cn(3,n),cnew(3,n),ih(n),rot(3,3)
          dimension edge(3),cell(3,27),ixyzhex(3)
          dimension simplex(4,3),angle(3),vertex(4)
          if (i2dopt .eq. 0) then
            call zeroit(simplex,12)
            do i=1,3
              simplex(i,i)=0.1
            end do
            do i=1,4
              do k=1,3
                angle(k)=simplex(i,k)
              end do
              vertex(i)=touch(co,ih,nslt,nnh,edge,ioppbc,cell,ncell,
         -      ixyzhex,angle,rot,mintyp,0,cnew)
            end do
            call amoeba(simplex,vertex,4,3,3,ftol,iter,co,cnew,ih,nslt,nnh,
         -    edge,ioppbc,cell,ncell,ixyzhex,rot,mintyp)
          else
            call opt2d(co,cnew,ih,n,nslt,nnh,edge,ioppbc,cell,ncell,
         -    ixyzhex,angle,rot,ftol,mintyp,i2dopt,iter)
          end if
          print *,'--- Number of iterations=',iter
          call rotate_c(co,n,rot,cn,'OPTBOUND',8)
          return
          end
          subroutine optimize(co,cn,cnew,ih,nslt,nnh,n,edge,edgen,edge_gen,
         -  ioppbc,npbc,ireduce,cell,ncell,cellalt,volnew,nwnew,
         -  closlim,closorg,closest,rot,ixyzhex,inn,jnn,ichk,iunsat,
         -  istickout,i2dopt,ftol)
          dimension co(3,n),cn(3,n),cnew(3,n),ih(n),edge(3),edgen(3),
         -  edge_gen(3,3),cell(3,27),cellalt(3,27),rot(3,3),ixyzhex(3)
          dimension cmin(3),cmax(3),edgenn(3)
          dimension simplex(4,3),angle(3),vertex(4)
          iunsat=0
          istickout=0
          call checkwall(ioppbc,edge,cmin,cmax,co,cell,1,ncell,
         -  ih,nslt,nnh,walldist)
          if (walldist .lt. 0.0) then
            volnew=1.e+33
            print *,'Optimization skipped because solute is out of the box'
            istickout=1
            return
          end if
          closorg=distminimg(co,ih,nslt,nnh,edge,ioppbc,cell,ncell,ixyzhex,
         -  inno,jnno)
          if (nslt .lt. 3000 .and. ichk .eq. 1) then
            clo=distminck(co,ih,nslt,nnh,cell,cellalt,ioppbc,ncell,
         -    inno1,jnno1)
            if (abs(closorg-clo) .gt. 0.0001) print *,
         -    'PROGRAM ERROR: Original distance=',closorg,' Check=',clo
          end if
          if (i2dopt .eq. 0) then
            call zeroit(simplex,12)
            do i=1,3
              simplex(i,i)=0.1
            end do
            do i=1,4
              do k=1,3
                angle(k)=simplex(i,k)
              end do
              vertex(i)=touch(co,ih,nslt,nnh,edge,ioppbc,cell,ncell,
         -      ixyzhex,angle,rot,1,0,cnew)
            end do
            call amoeba(simplex,vertex,4,3,3,ftol,iter,co,cnew,ih,nslt,nnh,
         -    edge,ioppbc,cell,ncell,ixyzhex,rot,1)
          else
            call opt2d(co,cnew,ih,n,nslt,nnh,edge,ioppbc,cell,ncell,
         -    ixyzhex,angle,rot,ftol,1,i2dopt,iter)
          end if
          print *,'--- Number of iterations=',iter
          call rotate_c(co,n,rot,cn,'OPTIMIZE',8)
          closest=distminimg(cn,ih,nslt,nnh,edge,ioppbc,cell,ncell,ixyzhex,
         -  inn,jnn)
          write (6,2006) closorg,closest
          if (closest .gt. closlim .and. ireduce .eq. 1) then
            if (npbc .gt. 1) then
              call cellreduce(0,cn,ih,nslt,nnh,edge,edgen,edge_gen,ioppbc,
         -      npbc,cell,ncell,cellalt,ixyzhex,closest,volnew,nwnew)
              call trnsfr(edgenn,edgen,3)
            else
              call trnsfr(edgenn,edge,3)
            end if
            call cellreduce(1,cn,ih,nslt,nnh,edgenn,edgen,edge_gen,ioppbc,
         -    npbc,cell,ncell,cellalt,ixyzhex,closlim,volnew,nwnew)
            write (6,2007) volnew,nwnew
            call crorgn(edge,edge_gen,ioppbc,3,ncell,cell,cellalt,
         -    ixyzhex,rinscr,rcirc)
          else if (ireduce .eq. 1) then
            print *,'Smallest image distance is unsatisfactory:',closest
            iunsat=1
          end if
          return
    2006  format(' Initial and optimized smallest image distances=',
         -  f5.2,f6.2,' A')
    2007  format(' Smallest reduced volume=',f10.2,' A**3 accomodating ',i6,
         -  ' waters')
          end
          subroutine reoptimize(c,copt,c2,ih,nslt,nnh,n,edge,edgeopt,
         -  edge_gen,ioppbc,npbc,ireduce,cell,cellalt,ncell,volopt,volnew,
         -  closlim,closopt,closest,rot0,bestrot,inopt,jnopt,inn,jnn,
         -  ixyzhex,iunsat,istickout,impr,i2dopt,ftol)
          dimension c(3,n),copt(3,n),c2(3,n),ih(n),edge(3),edgeopt(3),
         -  edge_gen(3,3),edgen(3),cell(3,27),cellalt(3,27),rot0(3,3),
         -  bestrot(3,3),rotopt(3,3),ixyzhex(3)
          impr=0
          volnew=volopt
          call optimize(c,c,c2,ih,nslt,nnh,n,edge,edgen,edge_gen,ioppbc,
         -  npbc,ireduce,cell,ncell,cellalt,volnew,nwnew,closlim,closorg,
         -  closest,rotopt,ixyzhex,inn,jnn,1,iunsat,istickout,i2dopt,ftol)
          if (istickout .gt. 0) return
          if (ireduce .eq. 1) then
            if (volnew .lt. volopt) then
              volopt=volnew
              closopt=closest
              inopt=inn
              jnopt=jnn
              call trnsfr(copt,c,3*n)
              call trnsfr(edgeopt,edgen,3)
              call matprod(rotopt,rot0,bestrot)
              impr=1
            end if
          else
            if (closest .gt. closopt) then
              closopt=closest
              inopt=inn
              jnopt=jnn
              call trnsfr(copt,c,3*n)
              call matprod(rotopt,rot0,bestrot)
              impr=1
            end if
          end if
          return
          end
          subroutine symfit(c,co,c1,n,ioppbc,bestrot)
          dimension c(3,n),co(3,n),c1(3,n),bestrot(3,3)
          dimension nrot(3,8),kk(3),rot0(3,3),rot(3,3,3),rotopt(3,3)
          data nrot /4,4,4, 2,2,2, 4,4,4, 6,2,2, 6,2,2, 4,4,4, 4,4,4, 4,4,4/
          pi2=2.0*acos(-1.0)
          d0=dist2n(c,co,n)
          ncha=0
          do k=1,3
            call unitmat(rot(1,1,k))
            k1=mod(k,3)+1
            k2=mod(k+1,3)+1
            angle=pi2/float(nrot(k,ioppbc))
            rot(k1,k1,k)=cos(angle)
            rot(k2,k2,k)=rot(k1,k1,k)
            rot(k1,k2,k)=sin(angle)
            rot(k2,k1,k)=-rot(k1,k2,k)
          end do
          do k1=1,nrot(1,ioppbc)
            kk(1)=k1
            do k2=1,nrot(2,ioppbc)
              kk(2)=k2
              do k3=1,nrot(3,ioppbc)
                kk(3)=k3
                call unitmat(rot0)
                do k=1,3
                  do i=1,kk(k)
                    call matprod(rot(1,1,k),rot0,rot0)
                  end do
                end do
                call rotate_c(c,n,rot0,c1,'SYMFIT1',7)
                d1=dist2n(co,c1,n)
                if (d1 .lt. d0-1.0) then
                  ncha=ncha+1
                  call trnsfr(rotopt,rot0,9)
                  d0=d1
                end if
              end do
            end do
          end do
          if (ncha .gt. 0) then
            call rotate_c(c,n,rotopt,c,'SYMFIT',6)
            call matprod(rotopt,bestrot,bestrot)
          end if
          return
          end
          subroutine alignlongax(c,n,edge,rot,longax)
          dimension c(3,n),edge(3),rot(3,3)
          dimension permute(3,3)
          character*1 xyz(3)
          data xyz /'X','Y','Z'/
          edgelong=amax1(edge(1),edge(2),edge(3))
          if (edge(longax) .eq. edgelong) return
          call zeroit(permute,9)
          k=1
          longedge=0
          do while (longedge .eq. 0 .and. k .le. 3)
            if (edge(k) .eq. edgelong) longedge=k
            k=k+1
          end do
          permute(longedge,longax)=1.0
          print *,'longedge,longax=',longedge,longax
          kx=mod(longedge,3)+1
          ky=mod(longax,3)+1
          permute(kx,ky)=1.0
          print *,'kx,ky=',kx,ky
          kx=mod(kx,3)+1
          ky=mod(ky,3)+1
          permute(kx,ky)=1.0
          print *,'kxx,kyy=',kx,ky
          write (6,2001) ((permute(i,j),j=1,3),i=1,3)
          write (6,2000) xyz(longax),xyz(longedge)
          call rotate_c(c,n,permute,c,'ALIGNLONG',9)
          call rotate_c(edge,1,permute,edge,'ALIGNLONG1',10)
          call matprod(permute,rot,rot)
          return
    2000  format(' System is rotated to make the ',a,' axis the longest ',
         -  '(current longest: ',a,' axis)')
    2001  format(' Permute:',/,(3f4.1))
          end
          subroutine checkreschargesum(nslt,iresno,isegno,line,index,
         -  irescol1,irescol2,iresncol1,iresncol2,isegcol1,isegcol2,iqcol1,
         -  iqcol2,charge,molsltlim,label,llabel,resnames,ifres,
         -  ixres,ixchrg,ixnochrg,nreschrg,iallzero,iallnonpos,iallnonneg,
         -  ichecksavedq,ifixq,reportqmin,iout,maxrsd,maxrec)
          dimension index(maxrec),iresno(maxrec),ifres(maxrec),
         -  isegno(maxrec),ixchrg(maxrec),ixnochrg(maxrec),charge(maxrec),
         -  molsltlim(3,maxrsd),ixres(maxrec)
          character*(*) label
          character*8 resnames(maxrsd)
          character* 132 line(maxrec)
          character*8 rnprev
          character*6 rnuprev
          real*8 qsum
          character*19 segline
          data segline /' Segment     (    )'/
          nrescol=irescol2-irescol1+1
          nresncol=iresncol2-iresncol1+1
          iresprev=iresno(1)
          ixresprev=ixres(1)
          isegprev=isegno(1)
          ndigits=3
          nsegm=isegno(nslt)
          isegnoprev=0
          if (reportqmin .lt. 0.0) call getreal(
         -  'Minimum deviation from integral residue charge to print',55,
         -  0.0,reportqmin,1,000)
          do isg=1,nsegm
            iallzero=1
            iallnonpos=1
            iallnonneg=1
            nreschrg=0
            nresnochrg=0
            nresck=0
            nonintegral=0
            iallzerores=1
            qrsum=0.0
            qsum=0.d0
            qdevmax=0.d0
            do ia=molsltlim(1,isg),molsltlim(2,isg)
              ir=iresno(ia)
              is=isegno(ia)
              if (nsegm .gt. 1 .and. is .gt. isegnoprev) then
                write (segline(9:12),1006) isg
                ncol=12
                if (isegcol2 .gt. isegcol1) then
                  segline(15:15+isegcol2-isegcol1)=
         -          line(index(ia))(isegcol1:isegcol2)
                  ncol=19
                end if
                write (6,1008) segline(1:ncol)
              end if
              isegnoprev=is
              q=charge(ia)
              if (q .lt. 0.0) iallnonneg=0
              if (q .gt. 0.0) iallnonpos=0
              if (q .ne. 0.0) iallzero=0
              if (q .ne. 0.0) iallzerores=0
              if (ir .ne. iresprev .or. is .ne. isegprev .or.
         -        ia .eq. molsltlim(2,isg)) then
                rnprev(1:nrescol)=line(index(ia-1))(irescol1:irescol2)
                rnuprev(1:nresncol)=line(index(ia-1))(iresncol1:iresncol2)
                qscheck=qrsum
                if (ia .eq. nslt .or. ia .eq. molsltlim(2,isg))
         -        qscheck=qscheck+q
                if (isinteger(qscheck,ndigits,qoffset) .eq. 0) then
                  if (abs(qoffset) .ge. reportqmin)
         -          write (6,1000) label(1:llabel),iresprev,
         -            rnuprev(1:nresncol),rnprev(1:nrescol),qscheck
                  nonintegral=nonintegral+1
                  if (abs(qoffset) .gt. qdevmax) qdevmax=abs(qoffset)
                else if (abs(qscheck) .gt. 0.1) then
                  nreschrg=nreschrg+1
                  ixchrg(nreschrg)=ixresprev
                end if
                if (iallzerores .eq. 1) then
                  nresnochrg=nresnochrg+1
                  ixnochrg(nresnochrg)=ixresprev
                end if
                qrsum=0.0
                iresprev=ir
                ixresprev=ixres(ia)
                isegprev=is
                nresck=nresck+1
                iallzerores=1
              end if
              qrsum=qrsum+q
              qsum=qsum+q
            end do
            if (iallzero .eq. 1) then
              write (6,1005) ' ',isg
            else
              if (iallnonneg .eq. 1) write (6,1005) ' positive or ',isg
              if (iallnonpos .eq. 1) write (6,1005) ' negative or ',isg
            end if
            if (iallzero+iallnonpos+iallnonneg .eq. 0 .or. nslt .le. 10)then
              nerr=0
              if (ichecksavedq .eq. 1) then
                do ia=molsltlim(1,isg),molsltlim(2,isg)
                  read(line(index(ia))(iqcol1:iqcol2),*,err=555,end=555) q
                  if (abs(q-charge(ia)) .gt. 0.0001 .and. nerr .lt. 10) then
                    write (6,1004) ia,charge(ia),q
                    nerr=nerr+1
                  end if
                  go to 556
    555           nerr=nerr+1
                  if (nerr .le. 10) print *,'ERROR: Invalid charge on atom',
         -          ia,':',line(index(ia))(iqcol1:iqcol2)
                  if (nerr .eq. 10)
         -            print *,'Further error messages are suppressed'
    556           continue
                end do
              end if
              write (iout,1001) nresck,label(1:llabel),qsum
              if (nonintegral .gt. 0) write (iout,1009) nonintegral
              if (nerr .gt. 0)
         -      print *, 'WARNING: ',nerr,' atom records had errors'
              qsum4=qsum
              if (isinteger(qsum4,ndigits,qoffset) .eq. 0)
         -      print *,'WARNING: Total charge is not integer'
              if (nresnochrg .gt. 0 .and. iallzero .eq. 0) write (iout,1007)
         -      (ixnochrg(ir),resnames(ixnochrg(ir))(1:nrescol),
         -      ir=1,nresnochrg)
              if (nreschrg .gt. 0) write (iout,1002)
         -      (iresno(ifres(ixchrg(ir))),resnames(ixchrg(ir))(1:nrescol),
         -       ir=1,nreschrg)
              if (nonintegral .gt. 0) then
                if (nresck .gt. 1) write (iout,1003) qdevmax
                if (ifixq .eq. -1) call askyn(
         -      'Do you want to redistribute charges to integral resid sums'
         -        ,58,1,-1,ifixq,126,0)
                if (ifixq .gt. 0) then
                  qmin=10.0**(-ndigits)
                  qround=10.0**(-ndigits-2)
                  qrsum=0.0
                  qcorrsum=0.0
                  iresf=1
                  iresprev=iresno(1)
                  isegprev=isegno(1)
                  do ia=molsltlim(1,isg),molsltlim(2,isg)
                    ir=iresno(ia)
                    is=isegno(ia)
                    read(line(index(ia))(iqcol1:iqcol2),*) q
                    if (ir .ne. iresprev .or. is .ne. isegprev .or.
         -              ia .eq. molsltlim(2,isg)) then
                      qscheck=qrsum
                      if (ia .eq. molsltlim(2,isg)) qscheck=qscheck+q
                      ii=isinteger(qscheck,ndigits,qoffset)
                      qcorrsum=qcorrsum-qoffset
                      if (ii .eq. 0) then
                        ntotchunks=abs(qoffset)/qmin
                        qmins=qmin
                        if (qoffset .gt. 0.0) qmins=-qmin
                        qdistr=ntotchunks*qmins
                        qdistr1=(ntotchunks+1)*qmins
                        if (abs(qoffset+qdistr) .gt.
         -                  abs(qoffset+qdistr1))then
                          qdistr=qdistr1
                          ntotchunks=ntotchunks+1
                        end if
                        natsres=ia-iresf
                        nchunks=ntotchunks/natsres
                        nchunkext=ntotchunks-natsres*nchunks
                        do ja=iresf,ia-1
                          qadd=nchunks*qmins
                          if (nchunkext .gt. 0 .and. ja-iresf .lt.nchunkext)
         -                  qadd=qadd+qmins
                          qfix=charge(ja)+qadd
                          call putreal(line(index(ja))(iqcol1:iqcol2),
         -                  iqcol2-iqcol1+1,qfix,ndigits)
                          charge(ja)=qfix
                        end do
                      end if
                      qrsum=0.0
                      iresprev=ir
                      isegprev=is
                      iresf=ia
                    end if
                    qrsum=qrsum+q
                  end do
                  if (abs(qcorrsum) .gt. abs(qmin)) print *,
         -          'WARNING: total charge distributed is not zero:',
         -          qcorrsum
                end if
              end if
            end if
          end do
          return
    1000  format(' Charge sum on ',a,i6,' (',a,1x,a,') is not integer:',
         -  f10.4)
    1001  format(' Checked ',i6,1x,a,'s for charge sum. Total charge=',
         -  f10.5,' e')
    1002  format(' Charged residues (residues with nonintegral charges ',
         -  'omitted):',/,5(i5,'(',a,')'))
    1003  format(' Largest absolute deviation from integral charge=',f8.5)
    1004  format(' Program ERROR: solute atom',i6,' charge saved=',f8.5,
         -  ' charge read=',f8.5)
    1005  format(' WARNING: all charges are',a,'zero in segment',i4)
    1006  format(i4)
    1007  format(' WARNING: the following residues have no charges:',/,
         -  5(i5,'(',a,')'))
    1008  format(a)
    1009  format(' Number of residues with nonintegral charge sum=',i4)
          end
          subroutine checknameforAC(nslt,line,index,inamcol1,inamcol2,
         -  maxrec)
          dimension index(maxrec)
          character* 132 line(maxrec)
          common /logging/ logfile,ipredict
          naromc=0
          ichangeatoc=0
          do ia=1,nslt
            ifc=inamcol1
            call nextchar(line(index(ia)),ifc,inamcol2)
            if (line(index(ia))(ifc:ifc) .eq. 'A') then
              naromc=naromc+1
              if (naromc .eq. 1) then
                if (ipredict .eq. 0) then
                  print *,'Atom names starting with A may stand for ',
         -          'aromatic carbons'
                  call askyn('Do you want to change A*** atoms to C***',40,
         -          1,1,ichangeatoc,0,0)
                else
                  write (6,1001)
                  ichangeatoc=1
                end if
              end if
              if (ichangeatoc .eq. 1) line(index(ia))(ifc:ifc)='C'
            end if
          end do
          if (naromc .gt. 0) write (6,1000) naromc
          return
    1000  format(' Number of atomnames changed from A*** to C***=',i4)
    1001  format(' Atoms with name A*** (assumed to be aromatic carbons) ',
         -  'are renamed to C***',/,
         -  ' To avoid this, do not make the input predictable')
          end
          subroutine checkfordup(numres,n,ifres,ilres,iresno,resnames,
         -  atnames,line,index,ndupdel,ideldup,iaddnum,iaskdup,maxrec,
         -  nrescol,inamcol1,inamcol2,nnamcol,idcol)
          dimension ifres(numres),ilres(numres),iresno(n),index(n)
          character*8 resnames(numres),atnames(n),newname
          character*132 line(maxrec)
          do ir=1,numres
            do ia=ifres(ir)+1,ilres(ir)
              do ja=ifres(ir),ia-1
                if (line(index(ia))(idcol:idcol) .eq. ' ' .and.
         -          line(index(ja))(idcol:idcol) .eq. ' ') then
                  if (atnames(ia)(1:nnamcol) .eq. atnames(ja)(1:nnamcol))
         -                                                           then
                    call lastchar(atnames(ia),lc,nnamcol)
                    if (iaskdup .eq. 1) then
                      write (6,2000) resnames(ir)(1:nrescol),iresno(ia),
         -              ia,ja,atnames(ia)(1:nnamcol)
                      call askyn('Do you want to delete the duplicate',35,1,
         -              -1,ideldup,0,0)
                      if (ideldup .eq. 0) then
                        if (lc .lt. nnamcol) then
                          call askyn(
         -                  'Do you want to add numbers to differentiate',
         -                  43,1,1,iaddnum,0,0)
                        end if
                      end if
                      call askyn(
         -             'Do you want to the same action with all duplicates',
         -              50,0,1,iaskdup,0,0)
                    end if
                    if (iaddnum .eq. 1) then
                      newname=atnames(ia)
                      nmax=10**(nnamcol-lc)-1
                      iadd=1
                      match=1
                      do while (iadd .lt. nmax .and. match .eq. 1)
                        call writeint(newname,lc+1,iadd,nnamcol-lc)
                        match=0
                        jaa=ifres(ir)
                        do while (jaa .lt. ia .and. match .eq. 0)
                          jaa=jaa+1
                          if (atnames(jaa)(1:nnamcol) .eq.
         -                    newname(1:nnamcol)) match=1
                        end do
                        iadd=iadd+1
                      end do
                      if (match .eq. 0) then
                        atnames(ia)=newname
                        line(index(ia))(inamcol1:inamcol2)=
         -                newname(1:nnamcol)
                      else
                        print *,'Sorry, could not find a different i',
         -                'new name for ',atnames(ia)(1:nnamcol)
                      end if
                    else if (ideldup .eq. 1) then
                      line(index(ia))(idcol:idcol)='*'
                      ndupdel=ndupdel+1
                    end if
                  end if
                end if
              end do
            end do
          end do
          if (ndupdel .gt. 0)
         -  write (6,*) 'Number of duplicate names deleted=',ndupdel
          return
    2000  format(' Residue ',a,i6,' atoms',2i7,' have same name:',a)
          end
          subroutine checkprotchir(c,n,line,index,ifres,nneig,ineig,
         -  inamcol1,inamcol2,irescol1,irescol2,iresncol1,iresncol2,
         -  nminus0,nplus0,nminus,nplus,ild,iverb,maxneig,maxrsd,maxrec)
          dimension c(3,maxrec),nneig(n),ineig(maxneig,n),index(maxrec),
         -  ifres(maxrec)
          character*1 ild(maxrsd)
          character* 132 line(maxrec)
          character*8 atnam
          lnam=inamcol2-inamcol1+1
          ncheck=0
          nminus=0
          nplus=0
          nplusminus=0
          nhgen=0
          iresno=0
          read (line(index(1))(iresncol1:iresncol2),*) iresnoprev
          icafound=0
          do ia=1,n
            atnam(1:lnam)=line(index(ia))(inamcol1:inamcol2)
            if (lnam .eq. 4) atnam(5:8)='    '
            call leftadjustn(atnam,atnam,8)
            read (line(index(ia))(iresncol1:iresncol2),*) iresno
            if (atnam(1:4) .eq. 'CA  ') then
              icafound=1
              ic=0
              in=0
              icb=0
              iha=0
              nfound=0
              ica=ia
              ierr=0
              do iaa=1,nneig(ia)
                ing=ineig(iaa,ia)
                atnam(1:lnam)=line(index(ing))(inamcol1:inamcol2)
                if (lnam .eq. 4) atnam(5:8)='    '
                call leftadjustn(atnam,atnam,8)
                call lookforneig(atnam(1:4),'C   ',ing,ic,nfound,ica,ierr)
                call lookforneig(atnam(1:4),'N   ',ing,in,nfound,ica,ierr)
                call lookforneig(atnam(1:4),'CB  ',ing,icb,nfound,ica,ierr)
                call lookforneig(atnam(1:4),'HA  ',ing,iha,nfound,ica,ierr)
              end do
              if (ierr .eq. 0) then
                if (nfound .eq. 3 .and. iha .eq. 0) then
                  iha=maxrec
                  nfound=nfound+1
                  do k=1,3
                    c(k,maxrec)=c(k,ica)+
         -            (3.0*c(k,ica)-c(k,icb)-c(k,in)-c(k,ic))
                  end do
                  nhgen=nhgen+1
                end if
                if (nfound .eq. 4) then
                  ncheck=ncheck+1
                  call checkchir(c,maxrec,ica,in,iha,icb,ic,isg)
                  if (isg .lt. 0) then
                    nminus=nminus+1
                    ild(ncheck)='D'
                  else if (isg .gt. 0)  then
                    nplus=nplus+1
                    ild(ncheck)='L'
                  end if
                else
                  nplusminus=nplusminus+1
                  ncheck=ncheck+1
                  ild(ncheck)='-'
                end if
              else
                nplusminus=nplusminus+1
                ncheck=ncheck+1
                ild(ncheck)='e'
              end if
            end if
            if (iresno .ne. iresnoprev) then
              if (icafound .eq. 0) then
                nplusminus=nplusminus+1
                ncheck=ncheck+1
                ild(ncheck)='-'
              end if
              iresnoprev=iresno
              icafound=0
            end if
          end do
          if (nhgen .gt. 0)
         -  print *,'Number of HAs generated for chirality check=',nhgen
          if (nminus0 .ge. 0 .and. nplus0 .ge .0) then
            nchch=iabs(nminus-nminus0)+iabs(nplus-nplus0)
            if (nchch .gt. 0)
         -    print *,'PROGRAM ERROR:',nchch,' CA atom(s) changed chirality'
          else
            nchch=0
          end if
          if (iverb .gt. 0 .or. nchch .gt. 0) then
            if (nplus+nminus .gt. 0) then
              write (6,1000) nplus+nminus,nplus,nminus,nplusminus
              if (nplus*nminus .ne. 0) then
                call print1charlist(ild,ncheck,line,index,ifres,irescol1,
         -        irescol2,maxrec)
              end if
              if (nminus .gt. 0) write(6,1001)
            else
              print *,'No chiral CA atom was found'
            end if
          end if
          return
    1000  format(i6,' chiral CAs were found, ',i5,' in L and ',i5,' in D ',
         -  'conformation',/,i6,' achiral CAs were found (glycine)')
    1001  format(' NOTE: chiral peptide center in D conformation was found')
          end
          subroutine lookforneig(atnam4,label,ing,ilabel,nfound,ica,ierr)
          character*4 atnam4,label
          if (atnam4 .eq. label) then
            if (ilabel .gt. 0) then
              write (6,1000) ica,label,ilabel,ing
              ierr=ierr+1
            else
              ilabel=ing
              nfound=nfound+1
            end if
          end if
          return
    1000  format(' ERROR: CA atom # ',i6,' has extra ',a,' neighbour:',2i7)
          end
          subroutine print1charlist(charlist,nlist,line,index,ifres,
         -  irescol1,irescol2,maxrec)
          character*1 charlist(nlist)
          character*(*) line(maxrec)
          dimension index(maxrec),ifres(maxrec)
          character*1 aa1(50)
          character*8 resname
          lresname=irescol2-irescol1+1
          i0=0
          do while (i0 .lt. nlist)
            print *
            imax=i0+min0(50,nlist-i0)
            write (6,1001)'Chirality:',(charlist(i),i=i0+1,imax)
            iimax=imax-i0
            do i=i0+1,imax
              ii=i-i0
              resname(1:lresname)=line(index(ifres(i)))(irescol1:irescol2)
              call leftadjustline(resname,1,lresname)
              call changeprot(resname,aa1(ii),2)
            end do
            write (6,1001)'Residue:  ',(aa1(ii),ii=1,iimax)
            moddiv=1
            nline=alog10(float(imax))+1
            do iline=1,nline
              write (6,1002) (mod(i/moddiv,10),i=i0+1,imax)
              moddiv=moddiv*10
            end do
            i0=i0+50
          end do
          return
    1001  format(1x,a10,50a1)
    1002  format(11x,50i1)
          end
          subroutine checkchir(c,n,i0,i1,i2,i3,i4,isg)
          dimension c(3,n)
          dimension d01(3),d02(3),d34(3),rnorm12(3)
          call arrdiff(c(1,i1),c(1,i0),d01,3)
          call arrdiff(c(1,i2),c(1,i0),d02,3)
          call arrdiff(c(1,i4),c(1,i3),d34,3)
          call vprd(d01,d02,rnorm12)
          isg=1
          if (scprod(d34,rnorm12) .lt. 0.0) isg=-1
          return
          end
          subroutine cellreduce(it,c,ih,n,nnh,edge,edgen,edge_gen,ioppbc,
         -  npbc,cell,ncell,cellalt,ixyzhex,closmn,volnew,nwnew)
          dimension c(3,n),ih(n),edge(3),edgen(3),edge_gen(3,3),cell(3,27),
         -  cellalt(3,27),ixyzhex(3)
          dimension edgenn(3),delxyz(3)
          if (closmn .eq. 0.0) then
            call crorgn(edge,edge_gen,ioppbc,3,ncell,cell,cellalt,
         -    ixyzhex,rinscr,rcirc)
            closmin=distminimg(c,ih,n,nnh,edge,ioppbc,cell,ncell,ixyzhex,
         -    inn,jnn)
          else
            closmin=closmn
          end if
          call trnsfr(edgen,edge,3)
          call trnsfr(edgenn,edge,3)
          call zeroit(delxyz,3)
          delsum=0.0
          icmax=npbc
          if (it .eq. 1) icmax=1
          do ic=1,icmax
            del=0.01
            if (icmax .gt. 1) then
              edgenn(ic)=edge(ic)-del
            else
              do k=1,3
                edgenn(k)=edge(k)*(1.0-del/edge(1))
              end do
            end if
            call crorgn(edgenn,edge_gen,ioppbc,3,ncell,cell,cellalt,
         -    ixyzhex,rinscr,rcirc)
            dnew=distminimg(c,ih,n,nnh,edgenn,ioppbc,cell,ncell,ixyzhex,
         -    inn,jnn)
            if (dnew .ge. closmin-1.e-4) then
              edgen(ic)=edgenn(ic)
              del=0.5
              nred=0
              maxred=25
              do while (del .gt. 0.005 .and. nred .lt. maxred)
                nred=nred+1
                if (icmax .gt. 1) then
                  edgenn(ic)=edgen(ic)-del
                else
                  do k=1,3
                    edgenn(k)=edgen(k)*(1.0-del/edge(1))
                  end do
                end if
                call crorgn(edgenn,edge_gen,ioppbc,3,ncell,cell,cellalt,
         -        ixyzhex,rinscr,rcirc)
                dnew=distminimg(c,ih,n,nnh,edgenn,ioppbc,cell,ncell,ixyzhex,
         -        inn,jnn)
                if (dnew .gt. closmin-1.e-4) then
                  if (icmax .gt. 1) then
                    edgen(ic)=edgenn(ic)
                    delxyz(ic)=delxyz(ic)+del
                  else
                    call trnsfr(edgen,edgenn,3)
                    delsum=delsum+del
                  end if
                  del=2.0*del
                else
                  del=del/2.0
                end if
              end do
            else if (icmax .gt. 1) then
              edgenn(ic)=edgenn(ic)+del
            end if
          end do
          if (icmax .gt. 1) then
            write (6,1000) (delxyz(k),k=1,3)
          else
            delfac=(1.0-delsum/edge(1))
            write (6,1001) delfac
          end if
          call prtcell(ioppbc,edgen,edge_gen,0.0,volnew,nwnew,0)
          return
    1000  format(5x,' Anisotropic cell contraction achieved by:',3f6.2,' A')
    1001  format(5x,' Isotropic cell contraction by a factor of ',f6.4)
          end
          subroutine getedge(co,cn,ih,n,nnh,c0,edge,edge_gen,ioppbc,npbc,
         -  ireduce,cell,ncell,cellalt,ixyzhex,closlim,list,iatnum,cv,
         -  maxrec)
          dimension list(maxrec),iatnum(maxrec)
          dimension co(3,n),cn(3,n),ih(n),c0(3),edge(3),edge_gen(3,3),
         -  cell(3,27),cv(n),cellalt(3,27),ixyzhex(3)
          character*1 xyz
          common /axislab/ xyz(3)
          dimension cmin(3),cmax(3),edgen(3)
          data kmax /0/
          width=closlim/2.0
          if (ioppbc .eq. 3 .or. (ioppbc .ge. 6 .and. ioppbc .le. 8)) then
            print *,'Cell parameter obtained from smallest enclosing ',
         -          'sphere:'
            call compact(co,cn,iatnum,ih,n,nnh,c0,rmin,rorgext,rorgcom,
         -    list,np,nlist,1,cv,maxrec)
            write (6,1003) rmin
            if (ioppbc .eq. 3) then
              edge(1)=(rmin+width)*sqrt(2.0)
            else if (ioppbc .eq. 6 .or. ioppbc .eq. 7) then
              edge(1)=(rmin+width)*2.0/sqrt(3.0)
            else if (ioppbc .eq. 8) then
              edge(1)=2.0*(rmin+width)
            end if
          else if (ioppbc .gt. 0) then
            call extension(co,ih,nnh,1,n,cmin,cmax,c0,0,1,v)
            do k=1,3
              write (6,1004) xyz(k),c0(k),cmin(k),cmax(k)
              edge(k)=cmax(k)-cmin(k)+2.0*width
            end do
            if (ioppbc .eq. 2) then
              write (6,1000) (xyz(k),cmin(k),cmax(k),k=1,3)
            else if (ioppbc .eq. 1) then
              emax=0
              do k=1,3
                if (edge(k) .gt. emax) then
                  emax=edge(k)
                  kmax=k
                end if
              end do
              do k=1,3
                edge(k)=emax
              end do
              write (6,1001) xyz(kmax),cmin(kmax),cmax(kmax)
            else
              ix1=ixyzhex(1)
              write (6,1002) xyz(ix1),cmin(ix1),cmax(ix1),
         -     (xyz(ixyzhex(k)),k=2,3),
         -     (cmin(ixyzhex(k)),cmax(ixyzhex(k)),k=2,3)
               edge(2)=(amax1((cmax(ixyzhex(2))-cmin(ixyzhex(2))),
         -     (cmax(ixyzhex(3))-cmin(ixyzhex(3))))+2.0*width)*2.0/sqrt(3.0)
              edge(3)=edge(2)
            end if
            call shiftmol(co,n,c0,cn,-1.0)
          end if
          call prtcell(ioppbc,edge,edge_gen,0.0,volnew,nwnew,1)
          if (ireduce .eq. 1) then
            if (npbc .gt. 1) then
              call cellreduce(0,cn,ih,n,nnh,edge,edgen,edge_gen,ioppbc,npbc,
         -      cell,ncell,cellalt,ixyzhex,0.0,volnew,nwnew)
              call trnsfr(edge,edgen,3)
            end if
            call cellreduce(1,cn,ih,n,nnh,edge,edgen,edge_gen,ioppbc,npbc,
         -    cell,ncell,cellalt,ixyzhex,closlim,volnew,nwnew)
            call trnsfr(edge,edgen,3)
          end if
          return
    1000  format(' Initial edges of the rectangle are based on the X, Y,',
         -  ' and Z extensions:',/,5x,3(1x,a1,f8.3,' - ',f8.3,5x))
    1001  format(' Initial edge of the cube is based on the ',a1,
         -  ' extension:',f8.3,' - ',f8.3)
    1002  format(' Initial length of the prism based the ',a,' extension:',
         -  ' (',f8.3,' - ',f8.3,')',/,' Initial edge of the hexagon ',
         -  'based on the ',a,' and ',a,' extensions:',
         -  /,' (',f8.3,' - ',f8.3,'), (',f8.3,' - ',f8.3,')')
    1003  format(' Inscribed sphere radius=',f10.5)
    1004  format(1x,a1,' c0=',f10.5,' cmin=',3f10.5,' cmax=',3f10.5)
          end
          subroutine prtcell(ioppbc,edge,edge_gen,r,vol,nw,iprtopt)
          dimension edge(3),edge_gen(3,3)
          common /numbers/ sq3,sq3inv,sq3p2,sq2p3
          dimension c0(3)
          if (iprtopt .lt. 0) then
            iprt=3
            iout=-iprtopt
          else
            iprt=iprtopt
            iout=6
          end if
          if (ioppbc .eq. 1) then
            vol=edge(1)**3
            if (iprt .gt. 0) write (iout,1001) edge(1)
          else if (ioppbc .eq. 2) then
            vol=edge(1)*edge(2)*edge(3)
            if (iprt .gt. 0) write (iout,1002) edge
          else if (ioppbc .eq. 3) then
            vol=2.0*edge(1)**3
            if (iprt .gt. 0) write (iout,1003) edge(1)
          else if (ioppbc .eq. 4) then
            vol=edge(1)*edge(2)**2*3.0*sqrt(3.0)/2.0
            if (iprt .gt. 0) write (iout,1004) edge(1),edge(2)
          else if (ioppbc .eq. 5) then
            edgex=edge(3)
            edgey=edge(2)
            edgep=edge(1)
            w=sqrt(edgey**2-edgex**2/4.0)
            h=(w-edgex/(2.0*sqrt(3.0)))/2.0
            vol=edgep*edgex*w
            obang=180.0-(180.0/3.14159)*acos(edgex/(2.0*edgey))
            if (iprt .gt. 0) write (iout,1005) edgep,obang,edgey,edgex
          else if (ioppbc .eq. 6 .or. ioppbc .eq. 7) then
            vol=4.0*edge(1)**3
            if (iprt .gt. 0) then
              rhex=edge(1)/sq3p2
              cx_c=2.0*edge(1)
              cx_a=cx_c*sq3p2
              write (iout,1006) edge(1),rhex,cx_c,cx_a
            end if
          else if (ioppbc .eq. 8) then
            vol=edge(1)**3/sqrt(2.0)
            if (iprt .gt. 0) write (iout,1008) edge(1)
          else if (ioppbc .eq. 9) then
            call vprd(edge_gen(1,2),edge_gen(1,3),c0)
            vol=abs(scprod(edge_gen(1,1),c0))
            if (iprt .gt. 0) write (iout,1009) edge(1)
          else if (ioppbc .eq. 10) then
            write (iout,*) 'Inputtted image cell centers'
          else if (ioppbc .eq. 11) then
            vol=4.0*3.141592/3.0*r**3
            iprt=3
            if (iprt .gt. 0) write (iout,1010) r
          else if (ioppbc .eq. -1) then
            vol=4.0*3.141592/3*r**3
            iprt=3
          else
            print *,'PROGRAM ERROR: invalid PBC option in prtcell:',ioppbc
            return
          end if
          nw=vol/(30.090)
          if (iprt .eq. 1) write (iout,2000) vol,nw
          if (iprt .eq. 2) write (iout,2001) vol,nw
          return
    1001  format(' Edge of the cube=',f11.6,' A')
    1002  format(' Edges of the rectangle=',3f11.6,' A')
    1003  format(' FCC cell parameter used=',f11.6,' A')
    1004  format(' Hexagonal prism length=',f11.6,
         -  ' A hexagon edge=',f11.6,' A')
    1005  format(' Hexagonal prism (skewed) length=',f11.6,
         -  ' A Obtuse angle=',f8.2,' deg',/,' Obtuse axis length=',f11.6,
         -  ' A Cartesian axis length=',f11.6,' A')
    1006  format(' Truncated octahedron',/,
         -  ' Distance of square face from the center=',f11.6,' A',/,
         -  ' Distance of hexagonal face from the center=',f11.6,' A',/,
         -  ' Charmm     cell X-parameter=',f11.6,' A',/,
         -  ' Amber/NAMD cell X-parameter=',f11.6,' A')
    1008  format(' Diameter of the close-packed sphere=',f11.6,' A')
    1009  format(' Edge length of the paralellepid=',f11.6,' A')
    1010  format(' Radius of the boundary sphere=',f11.6,' A')
    2000  format(' Volume=',f15.2,' A**3',' Number of waters that fit in=',
         -  i9)
    2001  format(' Optimal volume=',f11.2,' A**3',
         -  ' Number of waters that fit in=',i6)
          end
          subroutine crorgn(edg,edge_gen,ioppbc,ndim,ncell,cell,cellalt,
         -  ixyzhex,rinscr,rcirc)
          dimension edg(3),edge_gen(3,3),cell(3,27),cellalt(3,27)
          common /pbcrotmat/ torot_ac(3,3),torot_ca(3,3),tofac_ac,tofac_ca
          dimension y(3),x(3),yx(3),yy(3),ixyzhex(3),cx(3),cy(3),cz(3)
          data edgex /0.0/,edgey /0.0/,edge /0.0/,edgep /0.0/,d /0.0/
          if (ioppbc .eq. -1) return
          onethird=1.0/3.0
          sq22p3=sqrt(2.0)*2.0/3.0
          sq3=sqrt(3.0)
          sq3p2=sq3/2.0
          sq2p3=sqrt(2.0/3.0)
          if (ioppbc .eq. 1) then
            edgex=edg(1)
            edgey=edg(1)
            edge=edg(1)
          else if (ioppbc .eq. 2) then
            edgex=edg(1)
            edgey=edg(2)
            edge=edg(3)
          else if (ioppbc .eq. 3) then
            edge=edg(1)
          else if (ioppbc .eq. 4) then
            edgex=edg(1)
            edge=edg(2)
          else if (ioppbc .eq. 5) then
            edgep=edg(1)
            edgex=edg(3)
            edgey=edg(2)
          else if (ioppbc .eq. 6 .or. ioppbc .eq. 7) then
            edge=edg(1)
          else if (ioppbc .eq. 8) then
            d=edg(1)
          else if (ioppbc .eq. 9) then
            call zeroit(cx,3)
            cx(1)=edg(1)
            cy(1)=-edg(1)/3.0
            cy(2)=edg(1)*sq22p3
            cy(3)=0.0
            cz(1)=edg(1)/3.0
            cz(2)=cy(2)/2.0
            cz(3)=edg(1)*sq2p3
            call trnsfr(edge_gen(1,1),cx,3)
            call trnsfr(edge_gen(1,2),cy,3)
            call trnsfr(edge_gen(1,3),cz,3)
          else if (ioppbc .eq. 11) then
            d=edg(1)
          end if
          threp2=1.5
          call zeroit(cell,3*27)
          go to (10,10,30,40,50,60,60,80,90,100,110),ioppbc
          print *,'PROGRAM ERROR: invalid ioppbc in crorgn=',ioppbc
          stop
    10    ncell=27
          y(1)=0.
          y(2)=edge
          y(3)=- edge
          yx(1)=0.0
          yx(2)=edgex
          yx(3)=-edgex
          yy(1)=0.0
          yy(2)=edgey
          yy(3)=-edgey
          ii=0
          do i=1,ndim
            x(3)=y(i)
            do k=1,ndim
              x(2)=yy(k)
              do l=1,ndim
                x(1)=yx(l)
                ii=ii+1
                do j=1,3
                  cell(j,ii)=x(j)
                end do
              end do
            end do
          end do
          rcirc=sqrt(edgex**2+edgey**2+edge**2)/2.0
          rinscr=amin1(edgex,edgey,edge)/2
          go to 999
    30    ncell=19
          do i=2,5
            cell(2,i)=-edge
            cell(3,i)=-edge
          end do
          cell(2,2)=edge
          cell(3,2)=edge
          cell(2,4)=edge
          cell(3,5)=edge
          do i=2,5
            cell(1,4+i)=cell(2,I)
            cell(3,4+i)=cell(3,i)
            cell(1,8+i)=cell(2,I)
            cell(2,8+i)=cell(3,i)
          end do
          cell(1,14)=-2.0*edge
          cell(1,15)=-cell(1,14)
          cell(2,16)=cell(1,14)
          cell(2,17)=-cell(2,16)
          cell(3,18)=cell(1,14)
          cell(3,19)=-cell(3,18)
          rcirc=edge
          rinscr=edge/sqrt(2.0)
          go to 999
    40    continue
          ncell=21
          cell(ixyzhex(3),2)=-edge*sq3p2
          cell(ixyzhex(2),2)=-edge*threp2
          cell(ixyzhex(3),3)=-edge*sq3
          cell(ixyzhex(3),4)=-edge*sq3p2
          cell(ixyzhex(2),4)=edge*threp2
          do k=5,7
            l=9-k
            cell(ixyzhex(2),k)=cell(ixyzhex(2),l)
            cell(ixyzhex(3),k)=-cell(ixyzhex(3),l)
          end do
          do k=1,7
            l1=k+7
            l2=k+14
            cell(ixyzhex(1),l1)=edgex
            cell(ixyzhex(1),l2)=-edgex
            cell(ixyzhex(2),l1)=cell(ixyzhex(2),k)
            cell(ixyzhex(2),l2)=cell(ixyzhex(2),k)
            cell(ixyzhex(3),l1)=cell(ixyzhex(3),k)
            cell(ixyzhex(3),l2)=cell(ixyzhex(3),k)
          end do
          rcirc=sqrt((edgex/2.0)**2+edge**2)
          rinscr=amin1(edgex/2.0,edge*sq3p2)
          go to 999
    50    continue
          ncell=21
          w=sqrt(edgey**2-edgex**2/4.0)
          h=(w-edgex/(2.0*sqrt(3.0)))/2.0
          cell(ixyzhex(3),2)=-edgex/2.0
          cell(ixyzhex(2),2)=-w
          cell(ixyzhex(3),3)=-edgex
          cell(ixyzhex(3),4)=cell(ixyzhex(3),2)
          cell(ixyzhex(2),4)=-cell(ixyzhex(2),2)
          do k=5,7
            l=9-k
            cell(ixyzhex(2),k)=cell(ixyzhex(2),l)
            cell(ixyzhex(3),k)=-cell(ixyzhex(3),l)
          end do
          do k=1,7
            l1=k+7
            l2=k+14
            cell(ixyzhex(1),l1)=edgep
            cell(ixyzhex(1),l2)=-edgep
            cell(ixyzhex(2),l1)=cell(ixyzhex(2),k)
            cell(ixyzhex(2),l2)=cell(ixyzhex(2),k)
            cell(ixyzhex(3),l1)=cell(ixyzhex(3),k)
            cell(ixyzhex(3),l2)=cell(ixyzhex(3),k)
          end do
          rcirc=sqrt((edgep/2.0)**2+amax1((w-h)**2,(edgex/2.0)**2+h**2))
          rinscr=amin1(edgep,edgex,w-h)/2.0
          go to 999
    60    ncell=15
          do i=2,6,2
            cell(i/2,i) =2.0*edge
            cell(i/2,i+1) = -2.0*edge
          end do
          ic=7
          do ix=1,2
            do iy=1,2
              do iz=1,2
                ic=ic+1
                cell(1,ic)=(-1)**(ix)*edge
                cell(2,ic)=(-1)**(iy)*edge
                cell(3,ic)=(-1)**(iz)*edge
              end do
            end do
          end do
          if (ioppbc .eq. 7) then
            call trnsfr(cellalt,cell,ncell*3)
            call rotate_c(cell,ncell,torot_ca,cell,'CRORGN',6)
          end if
          rcirc=edge*sqrt(5.0)/2.0
          rinscr=edge
          go to 999
    80    ncell=19
          cell(1,2)=d
          cell(1,3)=d/2.0
          cell(2,3)=d*sq3p2
          cell(1,4)=d/2.0
          cell(2,4)=-d*sq3p2
          cell(1,5)=-d
          cell(1,6)=-d/2.0
          cell(2,6)=d*sq3p2
          cell(1,7)=-d/2.0
          cell(2,7)=-d*sq3p2
          cell(2,8)=d/sq3
          cell(1,9)=d/2.0
          cell(2,9)=-d/(2.0*sq3)
          cell(1,10)=-d/2.0
          cell(2,10)=-d/(2.0*sq3)
          cell(2,11)=-d*2.0/sq3
          cell(1,12)=d
          cell(2,12)=+d/sq3
          cell(1,13)=-d
          cell(2,13)=d/sq3
          call trnsfr(cell(1,14),cell(1,8),18)
          do k=8,13
            cell(1,k+6)=cell(1,k)
            cell(2,k+6)=cell(2,k)
            cell(3,k)=d*sq2p3
            cell(3,k+6)=-cell(3,k)
          end do
          rcirc=d*3.0/(sqrt(5.0)*2.0)
          rinscr=d/2.0
          go to 999
    90    ncell=1
          do ix=-1,1
            do iy=-1,1
              do iz=-1,1
                if (ix .ne. 0 .or. iy .ne. 0 .or. iz .ne. 0) then
                  ncell=ncell+1
                  do k=1,3
                    cell(k,ncell)=ix*edge_gen(k,1)+iy*edge_gen(k,2)+
         -            iz*edge_gen(k,3)
                  end do
                end if
              end do
            end do
          end do
          if (ncell .ne. 27) then
            print *,'PROGRAM ERROR: ncell=',ncell,' (instead of 27)'
            stop
          end if
          do k=1,3
            cz(k)=(edge_gen(k,1)+edge_gen(k,2)+edge_gen(k,3))/2.0
          end do
          rinscr=edg(1)*onethird/2.0
          rcirc=sqrt(scprod(cz,cz))
          go to 999
    100   ncell=1
          rinscr=0.0
          rcirc=0.0
          go to 999
    110   ncell=1
          rinscr=d
          rcirc=d
    999   return
          end
          subroutine updatecell(inptrajtyp,edge)
          dimension edge(3)
          real*8 xtlabc,xtlabc0
          common /boxdat/ xtlabc(6),xtlabc0(6),box(3),box0(3),edge_gen(3,3),
         -  cell0(3,27),cell(3,27),cellalt(3,27),
         -  ncell,ioppbc,noboxinfoar,noboxinfow,noboxrep,
         -  istuner,iboxtypfound,ixcrd(3),ixang(3),ixyzhex(3),
         -  ixyzhextraj(3),isizewarn
          character*1 xyz
          common /axislab/ xyz(3)
          real*8 cellfac
          dimension cellfac(3),ixyzhextrajcharmm(3)
          data ixyzhextrajcharmm /3,2,1/
          if (ioppbc .eq. 5) then
            if (ixyzhextraj(1) .eq. 0) then
              call trnsfi(ixyzhextraj,ixyzhextrajcharmm,3)
              write (6,1000) xyz(ixyzhextraj(1)),'hexagon prism axis'
              write (6,1000) xyz(ixyzhextraj(2)),
         -      'axis crossing a hexagon vertex'
              print *,'If this is wrong, modify the subroutine updatecell'
            end if
            if (inptrajtyp .eq. 1) then
              do k=1,3
                edge(k)=xtlabc(ixcrd(ixyzhextraj(k)))
              end do
            else
              do k=1,3
                edge(k)=box(ixyzhextraj(k))
              end do
            end if
            call crorgn(edge,edge_gen,ioppbc,3,ncell,cell,cellalt,
         -    ixyzhex,rins,rc)
          else
            if (inptrajtyp .eq. 1) then
              do k=1,3
                cellfac(k)=xtlabc(ixcrd(k))/xtlabc0(ixcrd(k))
              end do
            else
              do k=1,3
                cellfac(k)=box(k)/box0(k)
              end do
            end if
            do ic=1,ncell
              do k=1,3
                cell(k,ic)=cell0(k,ic)*cellfac(k)
              end do
            end do
          end if
           return
    1000  format(' NOTE: trajectory assumes ',a,' to be the ',a)
          end
          subroutine genimdist(crm,cell,ncell1,ncell,icmin,rmin2)
          dimension crm(3),cell(3,27)
          rmin2=1000000.0
          icmin=0
          do ic=ncell1,ncell
            r2=dist2(crm,cell(1,ic))
            if (r2 .lt. rmin2) then
              rmin2=r2
              icmin=ic
            end if
          end do
          if (icmin .eq. 0) then
            write (6,1717) crm,((i,cell(k,i),k=1,3),i=ncell1,ncell)
    1717    format(' ERROR: ic=0 for crm=',3f10.5,/,(' cell',i3,'=',3f10.5))
            stop
          end if
          return
          end
          subroutine genimdist123dim(crm,cell,ncell1,ncell,ixyzexcld,
         -  ixyzincld,icmin,rmin2)
          dimension crm(3),cell(3,27)
          if (ixyzincld+ixyzexcld .eq. 0) then
            call genimdist(crm,cell,ncell1,ncell,icmin,rmin2)
          else if (ixyzexcld .gt. 0) then
            rmin2=1000000.0
            do ic=ncell1,ncell
              if (cell(ixyzexcld,ic) .eq. 0.0) then
                r2=dist2(crm,cell(1,ic))
                if (r2 .lt. rmin2) then
                  rmin2=r2
                  icmin=ic
                end if
              end if
            end do
          else
            rmin2=1000000.0
            do ic=ncell1,ncell
              nz=0
              do k=1,3
                if (k .ne. ixyzincld) then
                  if (cell(k,ic) .eq. 0.0) nz=nz+1
                end if
              end do
              if (nz .eq. 2) then
                r2=(crm(ixyzincld)-cell(ixyzincld,ic))**2
                if (r2 .lt. rmin2) then
                  rmin2=r2
                  icmin=ic
                end if
              end if
            end do
          end if
          return
          end
          subroutine distminsetup(edge,ioppbc)
          dimension edge(3)
          common /distmindata/ ef1,ef2,ef3,ef4,edgep,edgep2,edgey,edgex,
         -  edgex2,w,h,et1,et2,et3,et4,edge2(3),edghalf,edgsq3p2,edgp2sq3,
         -  edgsq2p3,edgpsq3,edg2psq3
          common /numbers/ sq3,sq3inv,sq3p2,sq2p3
          if (ioppbc .eq. 3) then
            ef1=2.0*edge(1)
            ef2=4.0*edge(1)
            ef3=2.0*edge(1)**2
            ef4=4.0*edge(1)**2
          else if (ioppbc .eq. 4) then
            edgep=edge(1)
            edgep2=edgep/2.0
            w=edge(2)*1.5
            h=edge(2)/2.0
            edgex2=edge(2)*sq3p2
            edgex=edge(2)*sq3
          else if (ioppbc .eq. 5) then
            edgep=edge(1)
            edgep2=edgep/2.0
            edgey=edge(2)
            edgex=edge(3)
            edgex2=edgex/2.0
            w=sqrt(edgey**2-edgex**2/4.0)
            h=(w-edgex/(2.0*sq3))/2.0
          else if (ioppbc .eq. 6 .or. ioppbc .eq. 7) then
            et1=4.0*edge(1)
            et2=4.0*edge(1)**2
            et3=2.0*edge(1)
            et4=3.0*edge(1)**2
          else if (ioppbc .eq. 1) then
            do k=1,3
              edge(k)=edge(1)
              edge2(k)=edge(1)/2.0
            end do
          else if (ioppbc .eq. 8) then
            edghalf=edge(1)/2.0
            edgsq3p2=edge(1)*sq3p2
            edgsq2p3=edge(1)*sqrt(2.0/3.0)
            edgp2sq3=edge(1)/(2.0*sq3)
            edgpsq3=edge(1)/sq3
            edg2psq3=edge(1)/sq3p2
          else
            do k=1,3
              edge2(k)=edge(k)/2.0
            end do
          end if
          return
          end
          subroutine distmincalc(ioppbc,cell,ncell,ixyzhex,edge,dc1,dc2,
         -  dc3,icell,sum)
          dimension cell(3,ncell),ixyzhex(3),edge(3)
          common /distmindata/ ef1,ef2,ef3,ef4,edgep,edgep2,edgey,edgex,
         -  edgex2,w,h,et1,et2,et3,et4,edge2(3),edghalf,edgsq3p2,edgp2sq3,
         -  edgsq2p3,edgpsq3,edg2psq3
          common /numbers/ sq3,sq3inv,sq3p2,sq2p3
          dimension dc123(3),d(3),summ(7)
          if (ioppbc .eq. 3) then
            sum=dc1**2+dc2**2+dc3**2
            icell=1
            d1=abs(dc1)
            if (abs(dc2) .gt. d1) d1=abs(dc2)
            if (abs(dc3) .gt. d1) d1=abs(dc3)
            d1=-d1*ef2+ef4
            d2=abs(dc1)+abs(dc2)
            if (abs(dc2)+abs(dc3) .gt. d2)
         -    d2=abs(dc2)+abs(dc3)
            if (abs(dc1)+abs(dc3) .gt. d2)
         -    d2=abs(dc1)+abs(dc3)
            d2=-d2*ef1+ef3
            if (d1 .lt. d2) then
              sum1=sum+d1
            else
              sum1=sum+d2
            end if
            if (sum .gt. sum1) then
              sum=sum1
              icell=2
            end if
          else if (ioppbc .eq. 4 .or. ioppbc .eq. 5) then
            dc123(1)=dc1
            dc123(2)=dc2
            dc123(3)=dc3
            dcc1=abs(dc123(ixyzhex(1)))
            dcc2=abs(dc123(ixyzhex(2)))
            dcc3=abs(dc123(ixyzhex(3)))
            icell=2
            if (dcc3 .gt. edgex2) then
              if (h+sq3inv*(dcc3-edgex2) .le. dcc2) then
                dcc3=dcc3-edgex2
                dcc2=dcc2-w
              else
                dcc3=dcc3-edgex
              end if
            else
              if (h+sq3inv*(edgex2-dcc3) .le. dcc2) then
                dcc3=dcc3-edgex2
                dcc2=dcc2-w
              else
                icell=1
              end if
            end if
            if (dcc1 .gt. edgep2) then
              dcc1=dcc1-edgep
              icell=2
            end if
            sum=dcc1**2+dcc2**2+dcc3**2
          else if (ioppbc .eq. 1 .or. ioppbc .eq. 2) then
            dcc1=abs(dc1)
            dcc2=abs(dc2)
            dcc3=abs(dc3)
            icell=1
            if (dcc1 .gt. edge2(1)) then
              dcc1=dcc1-edge(1)
              icell=2
            end if
            if (dcc2 .gt. edge2(2)) then
              dcc2=dcc2-edge(2)
              icell=2
            end if
            if (dcc3 .gt. edge2(3)) then
              dcc3=dcc3-edge(3)
              icell=2
            end if
            sum=dcc1**2+dcc2**2+dcc3**2
          else if (ioppbc .eq. 6) then
            sum=dc1**2+dc2**2+dc3**2
            icell=1
            ad1=abs(dc1)
            ad2=abs(dc2)
            ad3=abs(dc3)
            dsum=ad1+ad2+ad3
            dmax=amax1(ad1,ad2,ad3)
            d1=-dmax*et1+et2
            d2=-dsum*et3+et4
            dminn=amin1(d1,d2)
            if (dminn .lt. 0.0) then
              sum=sum+dminn
              icell=2
            end if
          else if (ioppbc .eq. 6 .or. ioppbc .eq. 7) then
            icell=1
            d(1)=dc1
            d(2)=dc2
            d(3)=dc3
            call genimdist(d,cell,1,ncell,icmin,rmin2)
            if (icmin .gt. 1) icell=2
          else if (ioppbc .eq. 8) then
            dax=abs(dc1)
            day=abs(dc2)
            daz=abs(dc3)
            dsx=dc1*dc1
            dsy=dc2*dc2
            dsz=dc3*dc3
            summ(1)=dsx+dsy+dsz
            dax2=(dax-edghalf)**2
            dax3=(dax-edge(1))**2
            day2=(day-edgsq3p2)**2
            summ(2)=dax2+day2+dsz
            summ(3)=dax3+dsy+dsz
            day4=(dc2-edgpsq3)**2
            day5=(dc2+edgp2sq3)**2
            daz1=(daz-edgsq2p3)**2
            summ(4)=dsx+day4+daz1
            summ(5)=dax2+day5+daz1
            day6=(dc2+edg2psq3)**2
            day7=(dc2-edgpsq3)**2
            summ(6)=dsx+day6+daz1
            summ(7)=dax3+day7+daz1
            sum=summ(1)
            icell=1
            do ic=2,7
              if (summ(ic) .lt. sum) then
                sum=summ(ic)
                icell=ic
               end if
            end do
          else if (ioppbc .eq. 0) then
            d(1)=dc1
            d(2)=dc2
            d(3)=dc3
            call genimdist(d,cell,1,ncell,icmin,sum)
          end if
          return
          end
          subroutine extension(c,ih,nnh,nstart,n,cmin,cmax,c0,iprint,
         -  ivcheck,vol)
          dimension c(3,n),ih(n),cmin(3),cmax(3),c0(3)
          character*1 xyz
          common /axislab/ xyz(3)
          do k=1,3
            cmin(k)=1.e+25
            cmax(k)=-1.e+25
          end do
          do k=1,3
            if (nnh .gt. 0) then
              do ii=nstart,nnh
                i=ih(ii)
                if (c(k,i) .lt. cmin(k)) cmin(k)=c(k,i)
                if (c(k,i) .gt. cmax(k)) cmax(k)=c(k,i)
              end do
            else
              do i=nstart,n
                if (c(k,i) .lt. cmin(k)) cmin(k)=c(k,i)
                if (c(k,i) .gt. cmax(k)) cmax(k)=c(k,i)
              end do
            end if
            c0(k)=(cmax(k)+cmin(k))/2.0
          end do
          vol=1.0
          do k=1,3
            vol=vol*(cmax(k)-cmin(k))
          end do
          if (iprint .gt. 0)
         -  write (6,1000) (xyz(k),cmin(k),c0(k),cmax(k),k=1,3),vol
          if (ivcheck .eq. 1) then
            do k=1,3
              imax=cmax(k)
              if (imax .eq. 9999) write (6,1001) xyz(k)
            end do
            if (vol/n .gt. 1000.0) then
              write (6,1002) vol,n
              if (iprint .eq. 0)
         -      write (6,1000) (xyz(k),cmin(k),c0(k),cmax(k),k=1,3)
              call askstop(0)
            end if
          end if
          return
    1000  format(3(' Smallest, middle and largest ',a1,
         -  ' coordinate values=',3f9.4,/),
         -  ' Volume of enclosing rectangle=',f12.2,' A^3')
    1001  format(' WARNING: input structure contains ',a1,' coordinate ',
         -  'value(s) of 9999.0',/,10x,'indicating undefined values')
    1002  format(' WARNING: initial enclosing rectangle volume (',e12.4,
         -  ' for',i7,' atoms)',/,8x,'suggests corrupted input structure')
          end
          subroutine shiftmol(c,n,c0,cnew,fac)
          dimension c(3,n),cnew(3,n),c0(3)
    C     Center the molecule at c0
          do i=1,n
            do k=1,3
              cnew(k,i)=c(k,i)+fac*c0(k)
            end do
          end do
          return
          end
          subroutine check_rotmat(rot,lab,llab,ifail,iverb)
          dimension rot(3,3)
          character*(*) lab
          common /rotwarn/ nrotwarn,nrottest,devmax
          dimension u(3,3)
          data u /1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0/
          ifail=0
          nrottest=nrottest+1
          do i=1,3
            do j=1,3
              sum=0.0
              do k=1,3
                sum=sum+rot(i,k)*rot(j,k)
              end do
              if (abs(sum-u(i,j)) .gt. 0.99) then
                ifail=1
                write (6,1000) 'PROGRAM ERROR',lab(1:llab),i,j,sum
              else if (abs(sum-u(i,j)) .gt. 0.1) then
                if (nrotwarn .lt. 00)
         -        write (6,1000) 'WARNING',lab(1:llab),i,j,sum
                nrotwarn=nrotwarn+1
                if (devmax .lt. abs(sum-u(i,j))) devmax=abs(sum-u(i,j))
              end if
            end do
          end do
          if (ifail .gt. 0 .or. iverb .gt. 0) write (6,1001) rot
          return
    1000  format(1x,a,': rotation matrix error in call ',a,/,
         -  ' SUM rot(',i1,',k)*rot(',i1,',k)=',e12.5)
    1001  format(' The rotation matrix in rotate_c:',/,(3e13.5))
          end
          subroutine rotate_c(c,n,rot,cnew,lab,llab)
          dimension c(3,n),rot(3,3),cnew(3,n),cn(3)
          character*(*) lab
          iverb=0
          call check_rotmat(rot,lab,llab,ifail,iverb)
          do im=1,n
            cn(1)=rot(1,1)*c(1,im)+rot(1,2)*c(2,im)+rot(1,3)*c(3,im)
            cn(2)=rot(2,1)*c(1,im)+rot(2,2)*c(2,im)+rot(2,3)*c(3,im)
            cn(3)=rot(3,1)*c(1,im)+rot(3,2)*c(2,im)+rot(3,3)*c(3,im)
            call trnsfr(cnew(1,im),cn,3)
          end do
          return
          end
          subroutine getxyz(q1,lq1,q2,lq2,default,c,noneg,ihelp)
          character*(*) q1,q2
          dimension c(3)
          character*1 xyz(3)
          character*80 quiz
          data xyz /'X','Y','Z'/
          quiz(1:lq1)=q1(1:lq1)
          lquiz=lq1+1
          quiz(lquiz+1:lquiz+lq2)=q2(1:lq2)
          lquiz=lquiz+lq2
          do k=1,3
            quiz(lq1+1:lq1+1)=xyz(k)
            call getreal(quiz,lquiz,default,c(k),noneg,ihelp)
          end do
          return
          end
          subroutine transrot(c,ct,atw,atwtemp,rot,xyzmin,c0,edge_gen,
         -  molsltlim,nmolslt,nmolsltnoion,minresflag,n,nslt,nslv,npbc,
         -  ixyzhex,nneig,ineig,iatnum,molresflag,ixres,atnames,latnam,
         -  resnames,lresnam,iresno,it1,it2,it3,iaskshift,nconf,nosegid,pi,
         -  maxrsd,maxneig,mxat)
          dimension c(3,mxat),ct(3,mxat),atw(mxat),atwtemp(mxat),
         -  edge_gen(3,3),nneig(mxat),iatnum(mxat),ineig(maxneig,mxat),
         -  molresflag(maxrsd),ixres(mxat),rot(3,3),xyzmin(3),it1(mxat),
         -  it2(mxat),it3(mxat),molsltlim(3,maxrsd),ixyzhex(3),crep(3),
         -  c0(3),iresno(mxat)
          character*8 atnames(mxat),resnames(maxrsd)
          character*1 xyz,ans
          common /axislab/ xyz(3)
          dimension edge(3),cell(3,27),cellalt(3,27),x(3),y(3),z(3),cent(3),
         -  c00(3)
          parameter (MAXBRANCH=200)
          dimension ia_branch(MAXBRANCH),ia_predef(3,MAXBRANCH),
         -  r_predef(MAXBRANCH),ba_predef(MAXBRANCH),ta_predef(MAXBRANCH),
         -  loopmem(MAXBRANCH)
          ans=' '
          do while (ans .ne. 'q')
            if (iaskshift .eq. 1) then
              call quiz(ans,itranstyp,' ',' ',0,
         -      '(additional) conformation transformation type',45,0,5,6,
         -      00)
            else
              ans='r'
            end if
            if (ans .eq. 's' .or. ans .eq. 'p' .or. ans .eq. 'a' .or.
         -      ans .eq. 'h') then
              shiftfac=1.0
              if (ans .eq. 's') then
                call getxyz('Value to add to the ',20,' coordinates',12,0.0,
         -        xyzmin,0,0)
              else if (ans .eq. 'p') then
                call getint('Index of atom to be shifted',27,1,1,n,ias,0)
                write (6,1008) 'selected',atnames(ias)(1:latnam),
         -        resnames(ixres(ias))(1:lresnam),iresno(ias)
                if (ias .gt. nslt)
         -        print *,'WARNING: atom ',ias,' is a solvent atom'
                call getxyz('New ',4,' coordinate of the selected atom',
         -        32,0.0,xyzmin,0,0)
                do k=1,3
                  xyzmin(k)=xyzmin(k)-c(k,ias)
                end do
              else
                shiftfac=-1.0
                call quiz(ans,ictp,'g',' ',0,'molecular center',16,2,5,6,25)
                if (ans .eq. 'g') then
                   call trnsfr(xyzmin,c0,3)
                else
                  call cofms(c,xyzmin,n,atw)
                end if
              end if
              call shiftmol(c,n,xyzmin,c,shiftfac)
              write (6,1002) xyzmin
            end if
            if (ans .eq. 'c' .or. ans .eq. 'p') then
              call setpbccell(' ',0,edge,edge_gen,cell,ncell,cellalt,
         -      ixyzhex,npbc,ioppbc,iusepbc,vol,nw,rinscr,rcirc,1)
              call setrepats(nmolslt,molsltlim,nslt,nneig,ineig,
         -      molresflag,minresflag,it1,it2,maxneig,maxrsd)
              call setpbcdim(ioppbc,ixyzhex,ixyzexcld,ixyzincld,xyz)
              if (nosegid .eq. 1) print *,'WARNING: PDB file had no ',
         -      'segment ID - solute is considered a single molecule'
              if (ans .eq. 'c') then
                do ia=1,nslt
                  atwtemp(ia)=atw(ia)
                  if (molresflag(ixres(ia)) .gt. minresflag) atwtemp(ia)=0.0
                end do
                if (ioppbc .eq. 6 .or. ioppbc .eq. 7)
         -        call askyn('Do you want to try both TO orientations',39,
         -          -1,1,icellalt,137,0)
                call systemcenter(n,nmolslt,nmolsltnoion,molsltlim,c,ct,it1,
         -        atwtemp,cell,ncell,cellalt,icellalt,0,0,nslt,nslv,0,0,
         -        imcent,nconf,mxat,maxrsd)
              else
                do is=1,nmolslt
                  natoms=molsltlim(2,is)-molsltlim(1,is)+1
                  if (molsltlim(3,is) .eq. 0) then
                    call cofms(c(1,molsltlim(1,is)),crep,natoms,atw)
                  else
                    call trnsfr(crep,c(1,molsltlim(3,is)),3)
                  end if
                  call pbcreset(c(1,molsltlim(1,is)),natoms,crep,
         -          cell,ncell,0,0,img)
                end do
                nsw=(n-nslt)/nslv
                do iw=1,nsw
                  call pbcreset(c(1,nslt+(iw-1)*nslv+1),nslv,
         -          c(1,nslt+(iw-1)*nslv+1),cell,ncell,0,0,img)
                end do
              end if
            else if (ans .eq. 'r') then
              call genrot(rot,pi,iax,angle)
              if (iax .eq. -1) then
                call unitmat(rot)
                ans='q'
              else
                call rotate_c(c,n,rot,c,'TRANSROT',8)
                if (iax .eq. 0) write (6,1000) rot
                if (iax .gt. 0) write (6,1001) xyz(iax),angle
              end if
            else if (ans .eq. 'b') then
              call getint('Atom index to put at the origin',31,1,1,nslt,
         -      iacent,000)
              call getint('Atom index to put on the X axis',31,1,1,nslt,
         -      iaxax,000)
              call getint('Atom index to put in the X-Y plane',34,1,1,nslt,
         -      iaxyplane,000)
              write (6,1008) 'at the origin',atnames(iacent)(1:latnam),
         -        resnames(ixres(iacent))(1:lresnam),iresno(iacent)
              write (6,1008) 'on the X axis',atnames(iaxax)(1:latnam),
         -        resnames(ixres(iaxax))(1:lresnam),iresno(iaxax)
              write (6,1008) 'in the X-Y plane',
         -      atnames(iaxyplane)(1:latnam),
         -      resnames(ixres(iaxyplane))(1:lresnam),iresno(iaxyplane)
              call trnsfr(xyzmin,c(1,iacent),3)
              call shiftmol(c,n,xyzmin,c,-1.0)
              call trnsfr(x,c(1,iaxax),3)
              call norm(x,1.0)
              call trnsfr(y,c(1,iaxyplane),3)
              call vprd(x,y,z)
              call vprd(z,x,y)
              call norm(y,1.0)
              call norm(z,1.0)
              do k=1,3
                rot(1,k)=x(k)
                rot(2,k)=y(k)
                rot(3,k)=z(k)
              end do
              write (6,1000) ((rot(i,j),j=1,3),i=1,3)
              call rotate_c(c,n,rot,c,'TRANSROTb',9)
            else if (ans .eq. 'l') then
              deffac=1.54/0.83
              print *,'Default factor converts ChemAxon SDF file units to ',
         -      'Angstrom'
              call getreal('Factor to multiply the coordinates with',39,
         -      deffac,scfac,1,000)
              do ia=1,n
                do k=1,3
                  c(k,ia)=scfac*c(k,ia)
                end do
              end do
            else if (ans .eq. 'e') then
              if (n .gt. nslt) then
                print *,'System includes solvents that will be deleted'
                call askstop(1)
                n=nslt
              end if
              im1=1
              im2=2
              if (nmolslt .lt. 2) then
                print *,'Solute is a single molecule - nothing to separate'
              else
                if (nmolslt .gt. 2) then
                  call getint('Index of solute molecule to move',32,1,1,
         -          nmolslt,im1,000)
                  call getint('Index of solute molecule to move away from',
         -          42,2,1,nmolslt,im2,000)
                end if
                call getreal('Distance to move',16,5.0,dmove,0,000)
                call setrepats(nmolslt,molsltlim,nslt,nneig,ineig,
         -        molresflag,minresflag,it1,it2,maxneig,maxrsd)
                call zeroit(cent,3)
                do im=1,nmolslt
                  if (im .eq. im1 .or. im .eq. im2) then
                    if (molsltlim(3,im) .gt. 0) then
                      call trnsfr(ct(1,im),c(1,molsltlim(3,im)),3)
                    else if (molsltlim(3,im) .eq. 0) then
                      call extension(c,it1,0,molsltlim(1,im),
         -            molsltlim(2,im),x,y,ct(1,im),0,0,v)
                    else
                      call zeroit(c00,3)
                      do ia=molsltlim(1,im),molsltlim(2,im)
                        do k=1,3
                          c00(k)=c00(k)+c(k,ia)
                        end do
                      end do
                      do k=1,3
                        ct(k,im)=c00(k)/(molsltlim(2,im)-molsltlim(1,im)+1)
                      end do
                    end if
                    do k=1,3
                      cent(k)=cent(k)+ct(k,im)
                    end do
                  end if
                end do
                do k=1,3
                  cent(k)=cent(k)/2.0
                end do
                write (6,1003) cent
                r2=0.0
                do k=1,3
                  x(k)=ct(k,im1)-cent(k)
                  r2=r2+x(k)**2
                end do
                write (6,1004) im1,x
                r2=sqrt(r2)
                do k=1,3
                  y(k)=cent(k)+x(k)*(r2+dmove)/r2
                end do
                write (6,1005) im1,y
                do ia=molsltlim(1,im1),molsltlim(2,im1)
                  do k=1,3
                    c(k,ia)=c(k,ia)+(y(k)-ct(k,im1))
                  end do
                end do
              end if
            else if (ans .eq. 'w') then
              call getint('Index of the chiral center atom',31,999999,1,
         -      nslt,iachir,000)
              if (iatnum(iachir) .ne. 6)
         -      print *,'NOTE atom selected is not a carbon'
              write (6,1008) 'selected',atnames(iachir)(1:latnam),
         -        resnames(ixres(iachir))(1:lresnam),iresno(iachir)
              write (6,1006) (i,ineig(i,iachir),
         -      atnames(ineig(i,iachir))(1:latnam),
         -      resnames(ixres(ineig(i,iachir)))(1:lresnam),
         -      iresno(ineig(i,iachir)),i=1,nneig(iachir))
              if (nneig(iachir) .ne. 4) print *,'Number of neighbors is ',
         -      nneig(iachir),' instead of 4)'
              call getint('Index of the 1st neighbor to swap (1/2/3/4/)',
         -      44,999999,1,nneig(iachir),ixchir1,000)
              ixchir2=ixchir1
              do while (ixchir2 .eq. ixchir1)
                call getint('Index of the 2nd neighbor to swap (1/2/3/4/)',
         -        44,999999,1,nneig(iachir),ixchir2,000)
              end do
              iachir1=ineig(ixchir1,iachir)
              iachir2=ineig(ixchir2,iachir)
              ixchir3=1
              do while (ixchir3 .eq. ixchir1 .or. ixchir3 .eq. ixchir2)
                ixchir3=ixchir3+1
              end do
              iachir3=ineig(ixchir3,iachir)
              rchir1=sqrt(dist2(c(1,iachir),c(1,iachir1)))
              rchir2=sqrt(dist2(c(1,iachir),c(1,iachir2)))
              call trnsfi(it1,nneig,nslt)
              call findbranch(iachir,iachir1,iachir3,c,nbranch1,ia_branch,
         -      ia_predef,r_predef,ba_predef,ta_predef,nneig,it1,ineig,it2,
         -      it3,loopmem,nslt,atnames,latnam,resnames,lresnam,ixres,
         -      iresno,ifail1,maxneig,maxrsd,mxat,maxbranch)
              write (6,1007) iachir1,nbranch1
              call findbranch(iachir,iachir2,iachir3,c,nbranch2,
         -      ia_branch(nbranch1+1),ia_predef(1,nbranch1+1),
         -      r_predef(nbranch1+1),ba_predef(nbranch1+1),
         -      ta_predef(nbranch1+1),nneig,it1,ineig,it2,it3,loopmem,nslt,
         -      atnames,latnam,resnames,lresnam,ixres,iresno,ifail2,
         -      maxneig,maxrsd,mxat,maxbranch)
              write (6,1007) iachir2,nbranch2
              if (ifail1+ifail2 .eq. 0) then
                write (6,1009) iachir1,
         -        atnames(ineig(ixchir1,iachir))(1:latnam),
         -        resnames(ixres(ineig(ixchir1,iachir)))(1:lresnam),
         -        iresno(ineig(ixchir1,iachir)),iachir2,
         -        atnames(ineig(ixchir2,iachir))(1:latnam),
         -        resnames(ixres(ineig(ixchir2,iachir)))(1:lresnam),
         -        iresno(ineig(ixchir2,iachir))
                call unitvec(c(1,iachir),c(1,iachir1),x)
                call unitvec(c(1,iachir),c(1,iachir2),y)
                do k=1,3
                  c(k,iachir1)=c(k,iachir)+y(k)*rchir1
                  c(k,iachir2)=c(k,iachir)+x(k)*rchir2
                end do
                if (nbranch1 .gt. 0) write (6,1010) iachir1,(i,ia_branch(i),
         -        atnames(ia_branch(i))(1:latnam),
         -        resnames(ixres(ia_branch(i)))(1:lresnam),
         -        iresno(ia_branch(i)),i=1,nbranch1)
                call buildbranch(c,nbranch1,ia_branch,
         -        ia_predef,r_predef,ba_predef,ta_predef,pi,mxat,maxbranch)
                if (nbranch2 .gt. 0) write (6,1010) iachir1,
         -        (i,ia_branch(nbranch1+i),
         -        atnames(ia_branch(i))(1:latnam),
         -        resnames(ixres(ia_branch(i)))(1:lresnam),
         -        iresno(ia_branch(i)),i=1,nbranch2)
                call buildbranch(c,nbranch2,
         -        ia_branch(nbranch1+1),ia_predef(1,nbranch1+1),
         -        r_predef(nbranch1+1),ba_predef(nbranch1+1),
         -        ta_predef(nbranch1+1),pi,mxat,maxbranch-nbranch1)
              end if
              print *,'NOTE: new conformation may involve clashes!'
            end if
          end do
          return
    1000  format(' System was rotated with the rotation matrix:',/,
         -  (10x,3f11.7))
    1001  format(' System was rotated arount the ',a1,'-axis by',f8.1,
         -  ' deg')
    1002  format(' System was translated by <',2(f9.3,','),f9.3,'> A')
    1003  format(' Center of centers;',3f10.5)
    1004  format(' im=',i4,' center vector=',3f10.5)
    1005  format(' im=',i4,' shifted center vector=',3f10.5)
    1006  format(' Neighbor atoms of the chiral center:',/,
         -  (i3,' index=',i6,1x,a,1x,a,i6))
    1007  format(' Branch on atom ',i6,' consists of ',i4,
         -  ' additional atoms')
    1008  format(' Atom ',a,': ',a,1x,a,i5)
    1009  format(' First swapping atoms',i6,1x,a,1x,a,i5,' and',
         -  i6,1x,a,1x,a,i5)
    1010  format(' Atoms moved in the branch on atom',i6,':',/,
         -  (i3,1x,i6,1x,a,1x,a,i5))
          end
          subroutine findbranch(iachir,inchir,i3chir,c,nbranch,ia_branch,
         -  ia_predef,r_predef,ba_predef,ta_predef,nneig,nneig_sav,ineig,
         -  iused,iparent,loopmem,nslt,atnames,latnam,resnames,
         -  lresnam,ixres,iresno,ifail,maxneig,maxrsd,maxat,maxbranch)
          dimension c(3,maxat),ia_branch(maxbranch),ia_predef(3,maxbranch),
         -  r_predef(maxbranch),ba_predef(maxbranch),ta_predef(maxbranch),
         -  nneig(maxat),nneig_sav(maxat),ineig(maxneig,maxat),iused(maxat),
         -  iparent(maxat),loopmem(maxbranch),ixres(maxat),iresno(maxat)
          character*8 atnames(maxat),resnames(maxrsd)
          ifail=0
          nbranch=0
          if (nneig(inchir) .eq. 1) return
    100   call zeroiti(iused,0,nslt)
          iused(iachir)=1
          iused(inchir)=1
          in0=0
          do in=1,nneig(inchir)
            if (ineig(in,inchir) .eq. iachir) in0=in
          end do
          if (in0 .eq. 0) then
            print *,'PROGRAM ERROR in findbranch: iachir is not among the ',
         -    'neighbors of inchir'
            ifail=1
            return
          end if
          iparent(inchir)=iachir
          iparent(iachir)=i3chir
          nbranch=1
          ia_branch(nbranch)=inchir
          iused(ia_branch(nbranch))=1
          itry=1
          do while (itry .le. nbranch)
            iatry=ia_branch(itry)
            do while(nneig(iatry) .gt. 0)
              ianext=ineig(nneig(iatry),iatry)
              if (ianext .eq. iachir .and. iatry .ne. inchir) then
                print *,'Branch on atom ',inchir,' is a ring'
                loopmem(1)=ianext
                loopmem(2)=iatry
                nmem=2
                ip=iparent(iatry)
                do while (ip .ne. inchir)
                  nmem=nmem+1
                  loopmem(nmem)=ip
                  ip=iparent(ip)
                end do
                nmem=nmem+1
                loopmem(nmem)=inchir
                print *,'Have to break one bond in the ring'
                write (6,2002) (i,loopmem(i),atnames(loopmem(i))(1:latnam),
         -        resnames(ixres(loopmem(i)))(1:lresnam),
         -        iresno(loopmem(i)),loopmem(i+1),
         -        atnames(loopmem(i+1))(1:latnam),
         -        resnames(ixres(loopmem(i+1)))(1:lresnam),
         -        iresno(loopmem(i+1)),i=1,nmem-1)
                call getint('Bond # to break (1/2/3/...)',27,nmem-1,1,
         -        nmem-1,ibreak,000)
                i1=loopmem(ibreak)
                i2=loopmem(ibreak+1)
                write (6,2003) i1,atnames(i1)(1:latnam),
         -        resnames(ixres(i1))(1:lresnam),iresno(i1),
         =        i2,atnames(i2)(1:latnam),
         -        resnames(ixres(i2))(1:lresnam),iresno(i2)
                print *,'NOTE: swapped ring will be distorted!'
                call trnsfi(nneig,nneig_sav,nslt)
                call breakbond0(i1,i2,nslt,nneig,ineig,ifail,maxneig)
                go to 100
              end if
              if (iused(ianext) .eq. 0) then
                iused(ianext)=1
                nbranch=nbranch+1
                if (nbranch .gt. maxbranch) then
                  write (6,2000) maxbranch
                  call trnsfi(nneig,nneig_sav,nslt)
                  ifail=1
                  return
                end if
                ia_branch(nbranch)=ianext
                iparent(ianext)=iatry
              end if
              nneig(iatry)=nneig(iatry)-1
            end do
            itry=itry+1
          end do
          do ia=2,nbranch
            iaa=ia-1
            ian=ia_branch(ia)
            ia_branch(iaa)=ian
            ia1=iparent(ian)
            ia2=iparent(ia1)
            ia3=iparent(ia2)
            ia_predef(1,iaa)=ia1
            ia_predef(2,iaa)=ia2
            ia_predef(3,iaa)=ia3
            r_predef(iaa)=sqrt(dist2(c(1,ian),c(1,ia1)))
            ba_predef(iaa)=angleijk(c,maxat,ian,ia1,ia2,6)
            ta_predef(iaa)=dihangl(c,ia3,ia2,ia1,ian,0,maxrat)
          end do
          nbranch=nbranch-1
          call trnsfi(nneig,nneig_sav,nslt)
          return
    2000  format(' Number of atoms in the two branches exceed ',i5,
         -  ' - increase the parameter MAXBRANCH')
    2002  format(' List of bonds in the ring:',/,
         -  (i3,' Bond',i6,1x,a,1x,a,i5,' - ',i6,1x,a,1x,a,i5))
    2003  format(' Breaking bond ',i6,1x,a,1x,a,i5,' - ',i6,1x,a,1x,a,i5)
          end
          subroutine buildbranch(c,nbranch,ia_branch,
         -  ia_predef,r_predef,ba_predef,ta_predef,pi,maxat,maxbranch)
          dimension c(3,maxat),ia_branch(maxbranch),ia_predef(3,maxbranch),
         -  r_predef(maxbranch),ba_predef(maxbranch),ta_predef(maxbranch)
          do ia=1,nbranch
            call addatom(1,c(1,ia_predef(1,ia)),c(1,ia_predef(3,ia)),
         -    c(1,ia_predef(2,ia)),c(1,ia_predef(1,ia)),c(1,ia_branch(ia)),
         -    r_predef(ia),ba_predef(ia),ta_predef(ia),0.0,ia_branch(ia),
         -    pi,0,ifail)
          end do
          return
          end
          subroutine setpbcdim(ioppbc,ixyzhex,ixyzexcld,ixyzincld,xyz)
          dimension ixyzhex(3)
          character*1 xyz(3),ans
          ixyzexcld=0
          ixyzincld=0
          if (ioppbc .ne. 3 .and. ioppbc .ne. 5 .and.
         -    ioppbc .ne. 6 .and. ioppbc .ne. 7 .and.
         -    ioppbc .ne. 9 .and. ioppbc .ne. -1) then
            call getint('Number of PBC dimensions',24,3,1,3,npbcdim,110)
            if (npbcdim .eq. 2) then
              if (ioppbc .eq. 4 .or. ioppbc .eq. 5) then
                ixyzexcld=ixyzhex(1)
                print *,'Hexagonal prism - exluded axis:',xyz(ixyzexcld)
              else
                call quiz(ans,ixyzexcld,' ',
         -        'to exclude from the PBC calculation',-35,'axis',4,
         -        0,5,6,0)
              end if
            else if (npbcdim .eq. 1) then
              if (ioppbc .eq. 4 .or. ioppbc .eq. 5) then
                ixyzincld=ixyzhex(1)
                print *,'Hexagonal prism - included axis:',xyz(ixyzincld)
              else
                call quiz(ans,ixyzincld,' ',
         -        'to include in the PBC calculation',-33,'axis',4,
         -         0,5,6,0)
              end if
            end if
          end if
          return
          end
          subroutine euler(r,fi,ps,th)
          dimension r(3,3)
          sfi=sin(fi)
          cfi=cos(fi)
          sps=sin(ps)
          cps=cos(ps)
          sth=sin(th)
          cth=cos(th)
          r(1,1)=cps*cfi-cth*sfi*sps
          r(2,1)=-sps*cfi-cth*sfi*cps
          r(3,1)=sth*sfi
          r(1,2)=cps*sfi+cth*cfi*sps
          r(2,2)=-sps*sfi+cth*cfi*cps
          r(3,2)=-sth*cfi
          r(1,3)=sth*sps
          r(2,3)=sth*cps
          r(3,3)=cth
          return
          end
          subroutine ranort(r,i2dopt)
          dimension r(3,3),rn(3)
          if (i2dopt .eq. 0) then
            call randpx(3,rn)
            fir=rn(1)*3.141592*2.0
            Psr=rn(3)*3.141592*2.0
            Cth=-1.0+2.0*Rn(2)
            sth=sqrt(1.0-Cth*cth)
            sfi=sin(fir)
            cfi=cos(fir)
            sps=sin(psr)
            cps=cos(psr)
            r(1,1)=cps*cfi-cth*sfi*sps
            r(2,1)=-sps*cfi-cth*sfi*cps
            r(3,1)=sth*sfi
            r(1,2)=cps*sfi+cth*cfi*sps
            r(2,2)=-sps*sfi+cth*cfi*cps
            r(3,2)=-sth*cfi
            r(1,3)=sth*sps
            r(2,3)=sth*cps
            r(3,3)=cth
          else
            call randpx(1,rn)
            fir=rn(1)*3.141592*2.0
            sfi=sin(fir)
            cfi=cos(fir)
            call zeroit(r,9)
            r(i2dopt,i2dopt)=1.0
            ix=mod(i2dopt,3)+1
            iy=mod(i2dopt+1,3)+1
            r(ix,ix)=cfi
            r(ix,iy)=sfi
            r(iy,ix)=-sfi
            r(iy,iy)=cfi
          end if
          return
          end
          subroutine unitvec(r1,r2,e)
          dimension r1(3),r2(3),e(3)
          call arrdiff(r2,r1,e,3)
          call norm(e,1.0)
          return
          end
          subroutine unitmat(r)
          dimension r(3,3)
          do i=1,3
            do j=1,3
              r(i,j)=0.0
            end do
            r(i,i)=1.0
          end do
          return
          end
          subroutine rot90(ix,r)
          dimension r(3,3)
          call unitmat(r)
          iy=mod(ix,3)+1
          iz=mod(ix+1,3)+1
          r(iy,iy)=0.0
          r(iz,iz)=0.0
          r(iy,iz)=1.0
          r(iz,iy)=-1.0
          return
          end
          subroutine randpx_init(iseed)
          integer*4 ixo
          common /rangen/ ixo
          ixo=iseed
          return
          end
          subroutine randpx(n,rno)
          integer*4 ixo,iy
          common /rangen/ ixo
          dimension rno(n)
          do i=1,n
            iy=ixo*314159269+453806245
            iy=ibclr(iy,31)
            rno(i)=float(iy)/2.1474836E+09
            ixo=iy
          end do
          return
          end
          subroutine scramble(ix,n)
          dimension ix(n)
          dimension rand(1)
          call indexit(ix,1,n,0)
          left=n
          do i=1,n
            call randpx(1,rand)
            is1=i+rand(1)*left
            ix0=ix(is1)
            ix(is1)=ix(i)
            ix(i)=ix0
            left=left-1
          end do
          return
          end
          subroutine chkort(rot)
          dimension rot(3,3),rt(3,3)
          do i=1,3
            do j=1,3
              sum=0.0
              do k=1,3
                sum=sum+rot(i,k)*rot(j,k)
              end do
              rt(i,j)=sum
            end do
          end do
          write (6,1000) rt
    1000  format(' Orthogonality check:'/,(3f10.6))
          return
          end
          subroutine norm(d,fac)
          dimension d(3)
          sum=0.0
          do k=1,3
            sum=sum+d(k)**2
          end do
          if (sum .gt. 0.0) then
            do k=1,3
              d(k)=fac*d(k)/sqrt(sum)
            end do
          end if
          return
          end
          subroutine arrsum(a,b,c,n)
          dimension a(n),b(n),c(n)
          do i=1,n
            c(i)=a(i)+b(i)
          end do
          return
          end
          subroutine arrdiff(a,b,c,n)
          dimension a(n),b(n),c(n)
          do i=1,n
            c(i)=a(i)-b(i)
          end do
          return
          end
          subroutine darrdiff(a,b,c,n)
          real*8 a(n),b(n),c(n)
          do i=1,n
            c(i)=a(i)-b(i)
          end do
          return
          end
          subroutine arrdistsd(a1,a2,dist,dist2)
          real*8 a1,a2,dist,dist2
          real*8 x,y,z
          dimension a1(3),a2(3)
          x=a1(1)-a2(1)
          y=a1(2)-a2(2)
          z=a1(3)-a2(3)
          dist2=x*x+y*y+z*z
          dist=dsqrt(dist2)
          return
          end
          subroutine trnsfr(a,b,n)
          dimension a(n),b(n)
          do i=1,n
            a(i)=b(i)
          end do
          return
          end
          subroutine trnsfi(ia,ib,n)
          dimension ia(n),ib(n)
          do i=1,n
            ia(i)=ib(i)
          end do
          return
          end
          subroutine trnsfrd(a,b,n)
          real*8 a(n),b(n)
          do i=1,n
            a(i)=b(i)
          end do
          return
          end
          subroutine copyintgreal(intgv,realv,itor)
          if (itor .eq. 0) then
            call copyirr(realv,0)
            call copyiri(intgv,1)
          else
            call copyiri(intgv,0)
            call copyirr(realv,1)
          end if
          return
          end
          subroutine copyirr(realv,iread)
          common /janus/ realvar
          if (iread .eq. 1) realv=realvar
          if (iread .eq. 0) realvar=realv
          return
          end
          subroutine copyiri(intgv,iread)
          common /janus/ intgvar
          if (iread .eq. 1) intgv=intgvar
          if (iread .eq. 0) intgvar=intgv
          return
          end
          subroutine lastchar(line,ifc,len)
          character*(*) line
          do i=1,len
            ifc=len-i+1
            if (line(ifc:ifc) .ne. ' ')  return
          end do
          if (ifc .eq. 1 .and. line(1:1) .eq. ' ') ifc=0
          return
          end
          subroutine findnextchar(char,line,ic,len)
          character*1 char
          character*(*) line
          do while (line(ic:ic) .ne. char .and. ic .lt. len)
            ic=ic+1
          end do
          return
          end
          subroutine nextchar(line,ifc,len)
          character*(*) line
          character*1 tab,ctrlM
          common /tab/ tab,ctrlM
          if (ifc .gt. len-1) return
          ifc1=ifc
          do i=ifc1,len-1
            ifc=i
            if (line(i:i) .ne. ' ' .and. line(i:i) .ne. tab) then
              return
            end if
          end do
          ifc=len
          return
          end
          subroutine nextblank(line,ifc,len)
          character*(*) line
          character*1 tab,ctrlM
          common /tab/ tab,ctrlM
          if (ifc .gt. len-1) return
          ifc1=ifc
          do i=ifc1,len-1
            ifc=i
            if (line(i:i) .eq. ' ' .or. line(i:i) .eq. tab) then
              return
            end if
          end do
          ifc=len
          return
          end
          subroutine nextstring(line,ifc,ic1,ic2,len)
          character*(*) line
          call nextchar(line,ifc,len)
          if (line(ifc:ifc) .eq. '"' .or. line(ifc:ifc) .eq. "'") then
            ifc0=ifc
            ifc=ifc+1
            ic1=ifc
            if (line(ifc0:ifc0) .eq. '"') then
              call findnextchar('"',line,ifc,len)
            else
              call findnextchar("'",line,ifc,len)
            end if
            if (ifc .eq. len) then
              print *,'No closing quote was found'
              stop
            end if
            ic2=ifc-1
            ifc=ifc+1
          else
            ic1=ifc
            call nextblank(line,ifc,len)
            ic2=ifc-1
          end if
          return
          end
          subroutine laststring(line,icf,icl,lline,len)
          character*(*) line
          ic=1
          icl=1
          do while (icl .lt. lline)
            call nextstring(line,ic,icf,icl,len)
            ic=icl+1
          end do
          return
          end
          subroutine opt2d(c,cnew,ih,n,nslt,nnh,edge,ioppbc,cell,ncell,
         -  ixyzhex,angle,rot,ftol,mintyp,i2dopt,iter)
          dimension c(3,n),cnew(3,n),ih(n),edge(3),cell(3,27),rot(3,3),
         -  angle(3),ixyzhex(3)
          al=0.0
          angle(1)=al
          dl=touch(c,ih,nslt,nnh,edge,ioppbc,cell,ncell,ixyzhex,angle,rot,
         -  mintyp,i2dopt,cnew)
          ar=0.1
          angle(1)=ar
          dr=touch(c,ih,nslt,nnh,edge,ioppbc,cell,ncell,ixyzhex,angle,rot,
         -  mintyp,i2dopt,cnew)
          am=(al+ar)/2.0
          angle(1)=am
          dm=touch(c,ih,nslt,nnh,edge,ioppbc,cell,ncell,ixyzhex,angle,rot,
         -  mintyp,i2dopt,cnew)
          iter=0
          do while (abs(dl-dr) .gt. ftol)
            iter=iter+1
            if (dm .le. dl .and. dm .le. dr) then
              if (dl .lt. dr) then
                ar=am
                am=(al+ar)/2.0
                dr=dm
              else
                al=am
                am=(al+ar)/2.0
                dl=dm
              end if
              angle(1)=am
              dm=touch(c,ih,nslt,nnh,edge,ioppbc,cell,ncell,ixyzhex,
         -      angle,rot,mintyp,i2dopt,cnew)
            else if (dl .le. dm .and. dl .le. dr) then
              d=-(am-al)
              ar=am
              dr=dm
              am=al
              dm=dl
              al=am+d
              angle(1)=al
              dl=touch(c,ih,nslt,nnh,edge,ioppbc,cell,ncell,ixyzhex,
         -      angle,rot,mintyp,i2dopt,cnew)
            else
              d=+(ar-am)
              al=am
              dl=dm
              am=ar
              dm=dr
              ar=am+d
              angle(1)=ar
              dr=touch(c,ih,nslt,nnh,edge,ioppbc,cell,ncell,ixyzhex,
         -      angle,rot,mintyp,i2dopt,cnew)
            end if
            if (mod(iter,05) .eq. 0) write (6,1000) iter,dm,abs(dl-dr),ftol
          end do
          return
    1000  format(' 2D opt it',i5,' dm=',f9.5,' |dl-dr|=',f11.6,' tol=',f9.6)
          end
          subroutine fixup(rc,co,cn,n,aw)
          dimension rc(3,n),co(3,n),cn(3,n),aw(n)
          dimension como(3),a(3,3),b(3,3),orient(3,3)
          call cofms(co,como,n,aw)
          call trnsfr(a,rc,9)
          do i=1,3
            do j=1,3
              b(i,j)=co(i,j)-como(i)
            end do
          end do
          call ormat(orient,a,b,n,1,6)
          call rotate_c(rc,n,orient,cn,'FIXUP',5)
          call shiftmol(cn,n,como,cn,1.0)
          return
          end
          subroutine makewat(c,na,roh,ahohd,radtodeg)
          dimension c(3,na)
          do i=1,na
            c(i,1)=0.0
            c(3,i)=0.0
          end do
          ahoh=ahohd/(radtodeg*2.0)
          xw=roh*cos(ahoh)
          yw=roh*sin(ahoh)
          c(1,2)=xw
          c(1,3)=xw
          c(2,2)=yw
          c(2,3)=-yw
          return
          end
          subroutine grelcd(cs,csr,natms,aw)
          dimension cs(3,natms),csr(3,natms),aw(natms),cmcrd(3)
          call cofms(cs,cmcrd,natms,aw)
          do i=1,natms
            do k=1,3
              csr(k,i)=cs(k,i)-cmcrd(k)
            end do
          end do
          return
          end
          subroutine cofms(csa,rmass,natm,aw)
          dimension csa(3,natm),rmass(3),aw(natm)
          rmx=0.
          rmy=0.
          rmz=0.
          wmol=0.
          do i=1,natm
            wmol=wmol+aw(i)
            rmx=rmx+aw(i)*csa(1,i)
            rmy=rmy+aw(i)*csa(2,i)
            rmz=rmz+aw(i)*csa(3,i)
          end do
          if (wmol .eq. 0.0) wmol=1.0
          rmass(1)=rmx/wmol
          rmass(2)=rmy/wmol
          rmass(3)=rmz/wmol
          return
          end
          subroutine ormat(orm,a,b,natoms,iverb,iout)
    C*****Compute the rotation matrix orm  by solving the following equation
    C         important - only rotation , no translation.
    C     ++++++++++++++++++++++++++++++
    C     the elements of a and b are preserved.
          dimension a(3,3),b(3,3),orm(3,3),d(3,3),e(3,3)
          if (natoms .eq. 1) go to 40
          if (natoms .eq. 2) go to 20
          do i=1,3
            do k=1,3
              d(k,i)=a(k,i)-a(k,1)
              e(k,i)=b(k,i)-b(k,1)
            end do
          end do
          call vprod(d,2,3,1)
          call vprod(d,1,2,3)
          call vprod(e,2,3,1)
          call vprod(e,1,2,3)
          dsum=0.0
          do k=1,3
            dsum=dsum+abs(d(k,1))
          end do
          if (dsum .gt. 1.e-6) go to 30
          if (iverb .gt. 0) write (iout,1000)
    20    dsum=0.0
          do k=1,3
            d(k,1)=a(k,2)-a(k,1)
            dsum=dsum+abs(d(k,1))
            e(k,1)=b(k,2)-b(k,1)
            d(k,2)=0.0
            e(k,2)=0.0
          end do
    C     Create the second vector as perpendicular to the bond
          if (dsum .gt. 1.e-6) go to 25
          if (iverb .gt. 0) write (iout,1002)
          go to 40
    25    do k=1,3
            if (abs(d(k,1)) .le. 1.e-7) then
              d(k,2)=1.0
              go to 23
            end if
          end do
          d(2,2)=1.0
          d(3,2)=-d(2,1)/d(3,1)
    23    call vprod(d,1,2,3)
          do k=1,3
            if (abs(e(k,1)) .le. 1.e-7) then
              e(k,2)=1.0
              go to 26
            end if
          end do
          e(2,2)=1.0
          e(3,2)=-e(2,1)/e(3,1)
    26    call vprod(e,1,2,3)
    30    call mnorm(d)
          call mnorm(e)
          do i=1,3
            do j=1,3
              sum=0.0
              do k=1,3
                sum=sum+e(i,k)*d(j,k)
              end do
              orm(i,j)=sum
            end do
          end do
          return
    40    call unitmat(orm)
          return
    1000  format(' NOTE: the first three solute atoms are on',
         -  ' the same line - two-atom algorithm will be used')
    1002  format(1x,20('-'),' NOTE: the two atoms of a diatomic solute ',
         -  'coincide - unit matrix will be used as orientation matrix')
          end
          subroutine matprod(r1,r2,r3)
          dimension r1(3,3),r2(3,3),r3(3,3),r(3,3)
          do i=1,3
            do j=1,3
              rr=0.0
              do k=1,3
                rr=rr+r1(i,k)*r2(k,j)
              end do
              r(i,j)=rr
            end do
          end do
          call trnsfr(r3,r,9)
          return
          end
          subroutine dsmatvec(rot,din,dout)
          real*8 din(3),dout(3),d(3)
          dimension rot(3,3)
          do k=1,3
            rr=0.0
            do i=1,3
              rr=rr+din(i)*rot(k,i)
            end do
            d(k)=rr
          end do
          call trnsfrd(dout,d,3)
          return
          end
          subroutine vprod(r,i,j,k)
          dimension r(3,3)
          r(1,k)=r(2,i)*r(3,j)-r(2,j)*r(3,i)
          r(2,k)=r(3,i)*r(1,j)-r(3,j)*r(1,i)
          r(3,k)=r(1,i)*r(2,j)-r(1,j)*r(2,i)
          return
          end
          subroutine vprd(a,b,c)
          dimension a(3),b(3),c(3)
          c(1)=a(2)*b(3)-b(2)*a(3)
          c(2)=a(3)*b(1)-b(3)*a(1)
          c(3)=a(1)*b(2)-b(1)*a(2)
          return
          end
          subroutine dvprd(a,b,c)
          implicit real*8(a-h,o-z)
          dimension a(3),b(3),c(3)
          c(1)=a(2)*b(3)-b(2)*a(3)
          c(2)=a(3)*b(1)-b(3)*a(1)
          c(3)=a(1)*b(2)-b(1)*a(2)
          return
          end
          subroutine mnorm(r)
    C*****Normalizes the matrix r
          dimension r(3,3)
          do i=1,3
            rr=0.0
            do k=1,3
              rr=rr+r(k,i)**2
            end do
            rr=sqrt(rr)
            do k=1,3
              r(k,i)=r(k,i)/rr
            end do
          end do
          return
          end
          subroutine dmnorm(r)
          real*8 r,rr
          dimension r(3,3)
          do i=1,3
            rr=0.0
            do k=1,3
              rr=rr+r(k,i)**2
            end do
            rr=sqrt(sngl(rr))
            do k=1,3
              r(k,i)=r(k,i)/rr
            end do
          end do
          return
          end
          subroutine indexit(index,ifirst,ilast,incr)
          dimension index(ilast)
          do i=ifirst,ilast
            index(i)=i+incr
          end do
          return
          end
          subroutine reverseindex(indexrev,indexorig,ifres,ifirst,ilast,max)
          dimension indexrev(max),indexorig(max),ifres(max)
          call zeroiti(indexrev,0,max)
          do i=ifirst,ilast
            indexrev(indexorig(ifres(i)))=i
          end do
          return
          end
          subroutine zeroit(a,n)
          dimension a(n)
          do k=1,n
            a(k)=0.0
          end do
          return
          end
          subroutine zeroitd(a,n)
          real*8 a(n)
          do k=1,n
            a(k)=0.0
          end do
          return
          end
          subroutine zeroiti(ia,i0,n)
          dimension ia(n)
          do k=i0+1,n
            ia(k)=0
          end do
          return
          end
          subroutine zeroiti2(ia,i0,n)
          integer*2 ia(n)
          do k=i0+1,n
            ia(k)=0
          end do
          return
          end
          subroutine angdistw(c1,c2,c3,roh1,roh2,rhh,ahoh)
          dimension c1(3),c2(3),c3(3)
          real*8 cosa,rroh1,rroh2,droh1,droh2
          rroh1=(c1(1)-c2(1))**2+(c1(2)-c2(2))**2+(c1(3)-c2(3))**2
          rroh2=(c1(1)-c3(1))**2+(c1(2)-c3(2))**2+(c1(3)-c3(3))**2
          rrhh=(c2(1)-c3(1))**2+(c2(2)-c3(2))**2+(c2(3)-c3(3))**2
          droh1=dsqrt(rroh1)
          droh2=dsqrt(rroh2)
          rhh=sqrt(rrhh)
          cosa=(rroh1+rroh2-rrhh)/(2.d0*droh1*droh2)
          ahoh=dacoscheck(cosa,ccc,1,6,'ANGDISTW')
          roh1=droh1
          roh2=droh2
          return
          end
          subroutine changeprot(resnam,resnam1,iaaconv)
          character*8 resnam
          character*1 aanames1,resnam1
          character*2 mmodtoamb
          character*3 aanames3
          common /atnamcon/ mmodtoamb(100),aanames1(58),aanames3(58),
         -  naanames,nnanames,nnammnames,nnames,ixwatnam
          inf=1
          inl=naanames+nnanames
          if (iaaconv .eq. 1) then
            resnam='***     '
            do i=inf,inl
              if (resnam1 .eq. aanames1(i)) then
                resnam(1:3)=aanames3(i)
                return
              end if
            end do
          else if (iaaconv .eq. 2) then
            resnam1='*'
            call leftadjustn(resnam,resnam,8)
            do i=inf,inl
              if (resnam(1:3) .eq. aanames3(i)) then
                resnam1=aanames1(i)
                return
              end if
            end do
          else
            print *,'PROGRAM ERROR: invalid iaaconv in changeprot=',iaaconv
          end if
          return
          end
          subroutine atnamtoatnum(atomnam,mmctype)
          character*8 atomnam
          character*1 anam1(20)
          character* 132 line
          data anam1 /'H',3*' ','B','C','N','O','F',5*' ','P','S',
         -  3*' ','K'/
          line(1:5)=atomnam
          line(6:6)='X'
          ic=1
          call nextchar(line,ic,132)
          if (ic .le. 8) then
            do i=1,20
              if (atomnam(ic:ic) .eq. anam1(i)) then
                 mmctype=i
                 return
              end if
            end do
          end if
          mmctype=0
          return
          end
          subroutine nninit(nneig,nhbneig,ineig,nhneig,nnneig,ncneig,
         -  nsneig,npneig,nfirst,n,ihbinit,maxng)
          dimension nneig(n),ineig(maxng,n),nhbneig(n),nhneig(n),
         -  nnneig(n),ncneig(n),nsneig(n),npneig(n)
          if (ihbinit .eq. 1) then
            do i=nfirst,n
              call zeroiti(ineig(1,i),0,maxng)
              nhbneig(i)=0
            end do
          end if
          do i=nfirst,n
            nhneig(i)=0
            ncneig(i)=0
            nnneig(i)=0
            nsneig(i)=0
            npneig(i)=0
            nneig(i)=0
          end do
          return
          end
          subroutine nnlist(nslt,islvw,nslv,n,iatnum,ifchrg,c,nneig,nneiga,
         -  nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,line,irescol1,
         -  irescol2,inamcol1,inamcol2,index,nconfig,innlist,molresflag,
         -  hblimfac,angmin,ihbondcalc,indices,nbox,isegno,ixres,maxrepconf,
         -  nowarn,nframe,radtodeg,LEVTEST,maxbox,maxng,maxrsd,maxrec)
          dimension nneig(n),ineig(maxng,n),iatnum(n),c(3,n),nhbneig(n),
         -  nneiga(n),nhneig(n),nnneig(n),ncneig(n),nsneig(n),npneig(n),
         -  molresflag(maxrsd),index(n),indices(maxbox,maxrec),nbox(maxrec),
         -  isegno(n),ixres(n),ifchrg(n)
          character* 132 line(maxrec)
          character*4 atnami
          character*8 resnami
          character*4 namfcg
          common /connatdat/ ramax(99),ramax2(99),hlimfac,ianfg(99),
         -  namfcg(100),nrmw
          common /clonedat/ nclone,iaclnf(1000),iaclnl(1000),ncopcln(1000)
          if (innlist .gt. 0) then
            return
          else
            innlist=1
          end if
          do i=1,99
            ramax2(i)=ramax(i)**2
          end do
          call nninit(nneig,nhbneig,ineig,nhneig,nnneig,ncneig,
         -  nsneig,npneig,1,n,1,maxng)
          numsolv=(n-nslt)/nslv
          do is=1,numsolv
            call nnlist0o(nslt+(is-1)*nslv+1,nslt+is*nslv,iatnum,c,nneig,
         -    nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,line,
         -    irescol1,irescol2,inamcol1,inamcol2,index,maxng,hblimfac,
         -    maxrec)
          end do
          ntestclone=0
          nhb=nslt
          if (ihbondcalc .eq. 1) nhb=n
          if (nclone .eq. 0) then
            call nnlist0(1,nhb,nslt,islvw,iatnum,ifchrg,c,nneig,
         -    nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,line,
         -    irescol1,irescol2,inamcol1,inamcol2,index,maxng,
         -    hblimfac,angmin,ihbondcalc,indices,nbox,ixres,isegno,ifail,
         -    nframe,radtodeg,maxbox,maxrec,LEVTEST)
          else
            call nnlist0(1,iaclnf(1)-1,nslt,islvw,iatnum,ifchrg,c,nneig,
         -    nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,line,
         -    irescol1,irescol2,inamcol1,inamcol2,index,maxng,
         -    hblimfac,angmin,ihbondcalc,indices,nbox,ixres,isegno,ifail,
         -    nframe,radtodeg,maxbox,maxrec,LEVTEST)
            ifirst=iaclnf(1)
            ntestclone=ifirst-1
            do ic=1,nclone
              ilast=ifirst+iaclnl(ic)-iaclnf(ic)
              call nnlist0(ifirst,ilast,nslt,islvw,iatnum,ifchrg,c,nneig,
         -      nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,line,
         -      irescol1,irescol2,inamcol1,inamcol2,index,maxng,hblimfac,
         -      angmin,ihbondcalc,indices,nbox,ixres,isegno,ifail,nframe,
         -      radtodeg,maxbox,maxrec,LEVTEST)
             do id=2,ncopcln(ic)
               do ia=ifirst,ilast
                 ianew=ia+(id-1)*(ilast-ifirst+1)
                 nneig(ianew)=nneig(ia)
                 nneiga(ianew)=nneiga(ia)
                 nhbneig(ianew)=nhbneig(ia)
                 nhneig(ianew)=nhneig(ia)
                 nnneig(ianew)=nnneig(ia)
                 nsneig(ianew)=nsneig(ia)
                 npneig(ianew)=npneig(ia)
                 call trnsfi(ineig(1,ianew),ineig(1,ia),maxng)
               end do
             end do
             ifirst=ifirst+ncopcln(ic)*(ilast-ifirst+1)
             ilast=ifirst-1
            end do
            if (ilast .lt. nslt)
         -    call nnlist0(ilast+1,nslt,nslt,islvw,iatnum,ifchrg,c,nneig,
         -      nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,line,
         -      irescol1,irescol2,inamcol1,inamcol2,index,maxng,hblimfac,
         -      angmin,ihbondcalc,indices,nbox,ixres,isegno,ifail,nframe,
         -      radtodeg,maxbox,maxrec,LEVTEST)
            nclone=0
          end if
          if (LEVTEST .gt. 0) then
            ntest=nslt
            if (ntestclone .gt. 0) ntest=ntestclone
            print *,'NN comparison test  for ',ntest,' atoms'
            do i=1,ntest
              write (77,7811) i,(ineig(j,i),j=1,maxng)
            end do
            call nninit(nneig,nhbneig,ineig,nhneig,nnneig,ncneig,
         -    nsneig,npneig,1,ntest,1,maxng)
            call nnlist0o(1,ntest,iatnum,c,nneig,nhbneig,
         -    ineig,nhneig,nnneig,ncneig,nsneig,npneig,line,irescol1,
         -    irescol2,inamcol1,inamcol2,index,maxng,hblimfac,maxrec)
            do i=1,ntest
              write (78,7811) i,(ineig(j,i),j=1,maxng)
            end do
          end if
          do i=1,n
            nneiga(i)=nneig(i)
          end do
          do i=1,n
            if (iatnum(i) .ge. 88 .and. iatnum(i) .le. 90 .and.
         -      nneig(i) .gt. 0) then
              nn=nneig(i)
              do in=1,nn
                ia=ineig(in,i)
                if (ia .lt. 88 .or. ia .gt. 90) then
                  nneig(ia)=nneig(ia)+1
                  ineig(nneig(ia),ia)=i
                end if
              end do
            end if
          end do
          nlim=n
          if (nslv .eq. 1) nlim=nslt
          if (nowarn .eq. 0) then
            nslvmsg=0
            do ia=1,nlim
              if (nneig(ia) .eq. 0 .and. molresflag(ixres(ia)) .lt. 2) then
                imol1=0
                if (ia .eq. 1) then
                  if (isegno(ia) .ne. isegno(ia+1)) imol1=1
                else if (ia .eq. nlim) then
                  if (isegno(ia) .ne. isegno(ia-1)) imol1=1
                else
                  if (isegno(ia) .ne. isegno(ia-1) .and.
         -            isegno(ia) .ne. isegno(ia+1)) imol1=1
                end if
                if (imol1 .eq. 0 .and. ramax2(iatnum(ia)) .gt. 0.0) then
                  if (nslvmsg .le. 25) then
                    if (inamcol2 .ge. inamcol1) then
                      resnami='     '
                      resnami=line(index(ia))(irescol1:irescol2)
                      atnami=line(index(ia))(inamcol1:inamcol2)
                      if (resnami(1:3) .ne. 'HOH' .and.
         -                nconfig .le. maxrepconf)
         -              write (6,2003) ia,atnami,resnami,iatnum(ia)
                    else
                      if (nconfig .le. maxrepconf)
         -              write (6,2002) ia,iatnum(ia)
                    end if
                    if (nslvmsg .eq. 25)
         -            print *,'Solvent related warnings are turned off'
                  else
                  end if
                  if (ia .gt. nslt)nslvmsg=nslvmsg+1
                end if
              end if
            end do
            if (nslvmsg .gt. 25) write (6,2001) nslvmsg
          end if
          return
    2001  format(' WARNING: A total of ',i7,' solvent atoms had no bonds')
    2002  format(' WARNING: atom ',i6,' (atomic #=',i2,
         -  ') has no bonds at all')
    2003  format(' WARNING: atom ',i6,' (',a4,1x,a6,', atomic #=',i2,
         -  ') has no bonds at all')
    7811  format(i6,' in=',(20i6))
          end
          subroutine nnlist0(nfirst,n,nslt,islvw,iatnum,ifchrg,c,nneig,
         -  nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,line,
         -  irescol1,irescol2,inamcol1,inamcol2,index,maxng,hblimfac,angmin,
         -  ihbondcalc,indices,nbox,ixres,isegno,ifail,nframe,radtodeg,
         -  maxbox,maxrec,LEVTEST)
          dimension nneig(n),ineig(maxng,n),iatnum(n),ifchrg(n),c(3,n),
         -  nhbneig(n),nhneig(n),nnneig(n),ncneig(n),nsneig(n),npneig(n),
         -  index(n),indices(maxbox,maxrec),nbox(maxrec),ixres(n),isegno(n)
          common /connatdat/ ramax(99),ramax2(99),hlimfac,ianfg(99),
         -  namfcg(100),nrmw
          character* 132 line(maxrec)
          ifail=0
          if (n .lt. nfirst) return
          if (n .eq. 1) then
            nneig(1)=0
            nhbneig(1)=0
            return
          end if
          nn=0
          do ia=nfirst,n
            if (isegno(ia) .eq. -1) nn=nn+1
          end do
          if (nn .gt. 0 .or. ihbondcalc .eq. 1) then
            call nnlist00(nfirst,n,nslt,islvw,iatnum,ifchrg,c,nneig,nhbneig,
         -    ineig,nhneig,nnneig,ncneig,nsneig,npneig,line,irescol1,
         -    irescol2,inamcol1,inamcol2,index,maxng,hblimfac,angmin,
         -    indices,nbox,ixres,isegno,ifail,nframe,radtodeg,maxbox,maxrec,
         -    LEVTEST)
            if (ifail .gt. 0) go to 2000
            return
          else
            isg=isegno(nfirst)
            ifat=nfirst
            ilat=nfirst
            do while (isg .le. isegno(n))
              do while (isegno(ilat) .eq. isg .and. ilat .lt. n)
                ilat=ilat+1
              end do
              if (isegno(ilat-1) .ne. isegno(ilat) .and. ilat .le. n)
         -       ilat=ilat-1
              if (ilat .lt. n) then
                if (isegno(ilat+1) .ne. isegno(ilat)+1) then
                  write (6,1000) ilat,isegno(ilat),ilat+1,isegno(ilat+1)
                  call nninit(nneig,nhbneig,ineig,nhneig,nnneig,ncneig,
         -          nsneig,npneig,nfirst,n,1,maxng)
                  call nnlist00(nfirst,n,nslt,islvw,iatnum,ifchrg,c,nneig,
         -          nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,line,
         -          irescol1,irescol2,inamcol1,inamcol2,index,maxng,
         -          hblimfac,angmin,indices,nbox,ixres,isegno,ifail,nframe,
         -      radtodeg,maxbox,maxrec,LEVTEST)
                  if (ifail .gt. 0) go to 2000
                  return
                end if
              end if
              isg=isg+1
              call nnlist00(ifat,ilat,nslt,islvw,iatnum,ifchrg,c,nneig,
         -      nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,line,
         -      irescol1,irescol2,inamcol1,inamcol2,index,maxng,hblimfac,
         -      angmin,indices,nbox,ixres,isegno,ifail,nframe,radtodeg,
         -      maxbox,maxrec,LEVTEST)
              ifat=ilat+1
              ilat=ilat+1
            end do
          end if
          if (ifail .eq. 0) return
    2000  call nninit(nneig,nhbneig,ineig,nhneig,nnneig,ncneig,
         -  nsneig,npneig,nfirst,n,1,maxng)
          call nnlist0o(nfirst,n,iatnum,c,nneig,nhbneig,ineig,nhneig,nnneig,
         -  ncneig,nsneig,npneig,line,irescol1,irescol2,inamcol1,inamcol2,
         -  index,maxng,hblimfac,maxrec)
          return
    1000  format(' Segments are not contiguous: isegno(',i5,')=',i4,
         -  ' isegno(',i5,')=',i4)
          end
          subroutine nnlist00(nfirst,n,nslt,islvw,iatnum,ifchrg,c,nneig,
         -  nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,line,
         -  irescol1,irescol2,inamcol1,inamcol2,index,maxng,hblimfac,angmin,
         -  indices,nbox,ixres,isegno,ifail,nframe,radtodeg,maxbox,maxrec,
         -  LEVTEST)
          dimension nneig(n),ineig(maxng,n),iatnum(n),ifchrg(n),c(3,n),
         -  nhbneig(n),nhneig(n),nnneig(n),ncneig(n),nsneig(n),
         -  npneig(n),index(n),indices(maxbox,maxrec),nbox(maxrec),ixres(n),
         -  isegno(n)
          common /connatdat/ ramax(99),ramax2(99),hlimfac,ianfg(99),
         -  namfcg(100),nrmw
          character* 132 line(maxrec)
          character*4 atnami,atnamj
          character*8 resnami,resnamj
          dimension nxyz(3),ix(3),xyzmin(3),xyzmax(3),centinp(3),
         -  nh12(4)
          ifail=0
          if (n .lt. nfirst) return
          ra2max=ramax2(iatnum(1))
          ra2min=ra2max
          do i=nfirst,n
            if (ra2min .gt. ramax2(iatnum(i))) ra2min=ramax2(iatnum(i))
            if (ra2max .lt. ramax2(iatnum(i))) ra2max=ramax2(iatnum(i))
          end do
          ramn=sqrt(ra2min)
          ramx=sqrt(ra2max)
          if (ramx .lt. 0.01) then
            if (nrmw .eq. 0)
         -    print *,'WARNING: no atomic number could be deduced'
            ramx=0.5
            nrmw=nrmw+1
          end if
          div=ramx*hblimfac+0.01
          call extension(c,nneig,0,nfirst,n,xyzmin,xyzmax,centinp,0,0,v)
          call gridspace(c,isegno,nfirst,n,xyzmin,xyzmax,div,
         -  nxyz,nx,nxy,nbox,ix,indices,ifail,0,LEVTEST,maxbox,maxrec)
          nmb=0
          if (ifail .gt. 0) return
          do i1=1,nxyz(1)
            do i2=1,nxyz(2)
              do i3=1,nxyz(3)
                indexi=i1+nx*(i2-1)+nxy*(i3-1)
                ni=nbox(indexi)
                if (nmb .lt. ni) nmb=ni
                if (LEVTEST .gt. 2) write (88,1002) i1,i2,i3,indexi,ni
                if (ni .gt. 0) then
                  do j1=max0(1,i1-1),i1
                    do j2=max0(1,i2-1),min0(nxyz(2),i2+(i1-j1))
                      j3lim=i3
                      if (i1 .gt. j1 .or. i2. gt. j2) j3lim=j3lim+1
                      do j3=max0(1,i3-1),min0(j3lim,nxyz(3))
                        indexj=j1+nx*(j2-1)+nxy*(j3-1)
                        nj=nbox(indexj)
                        if (indexi .eq. indexj) then
                          ij=0
                        else
                          ij=1
                        end if
                        if (LEVTEST .gt. 2)
         -                write (88,1012) j1,j2,j3,indexj,nj
                        do jj=1,nj
                          j=indices(jj,indexj)
                          if (inamcol2 .ge. inamcol1) then
                            resnamj='     '
                            resnamj=line(index(j))(irescol1:irescol2)
                            atnamj=line(index(j))(inamcol1:inamcol2)
                          end if
                          ii1=1
                          if (ij .eq. 0) ii1=jj+1
                          do ii=ii1,ni
                            i=indices(ii,indexi)
                            numhyd=0
                            if (iatnum(j) .eq. 1) numhyd=1
                            if (iatnum(i) .eq. 1) numhyd=numhyd+1
                            if (numhyd .lt. 2 .and. ramax2(iatnum(i))*
         -                      ramax2(iatnum(j)) .gt. 0.0) then
                              r2=dist2(c(1,i),c(1,j))
                              rlm=amax1(ramax2(iatnum(i)),ramax2(iatnum(j)))
                              if (numhyd .eq. 1) rlm=rlm*hlimfac
                              if (r2 .le. rlm .and.
         -                        ifchrg(i)+ifchrg(j) .eq. 0) then
                                if (i .le. nslt .or. j .le. nslt) then
                                  call savebond(i,j,iatnum,nneig,ineig,
         -                          nhbneig,nhneig,ncneig,nnneig,npneig,
         -                          nsneig,resnamj,atnamj,maxng,n,0,
         -                          inamcol1,inamcol2,LEVTEST)
                                  resnami='     '
                                  resnami=line(index(i))(irescol1:irescol2)
                                  atnami=line(index(i))(inamcol1:inamcol2)
                                  call savebond(j,i,iatnum,nneig,ineig,
         -                          nhbneig,nhneig,ncneig,nnneig,npneig,
         -                          nsneig,resnami,atnami,maxng,n,0,
         -                        inamcol1,inamcol2,LEVTEST)
                                end if
                              else if (numhyd .eq. 1) then
                                if (iatnum(i)*iatnum(j) .ne. 6 .and.
         -                          ifchrg(i)+ifchrg(j) .eq. 0) then
                                  rlimhb2=(rlm/hlimfac)*hblimfac**2
                                  if (islvw .eq. 2 .or.
         -                            i .le. nslt .or. j .le. nslt)
         -                          call maybehbond(r2,i,j,nneig,nhbneig,
         -                            ineig,inamcol1,inamcol2,rlimhb2,
         -                            atnami,resnami,n,maxng)
                                end if
                              else if (numhyd .eq. 0 .and. islvw .gt. 0)then
                                if (i .gt. nslt .and. ifchrg(j) .gt. 0 .or.
         -                          j .gt. nslt .and. ifchrg(i) .gt. 0) then
                                  rlimhb2=rlm*hblimfac**2
                                  call maybehbond(r2,i,j,nneig,nhbneig,
         -                          ineig,inamcol1,inamcol2,rlimhb2,atnami,
         -                          resnami,n,maxng)
                                end if
                              end if
                            end if
                          end do
                        end do
                      end do
                    end do
                  end do
                end if
              end do
            end do
          end do
          if (LEVTEST .gt. 0)
         -  write (6,2001) nmb,100.0*float(nmb)/float(maxbox)
          do ia=nfirst,n
            if (iatnum(ia) .eq. 1) then
              call get_heavyat(ia,nneig,ineig,ixres,nframe,ihb0,maxng,
         -      maxrec)
              nhbng=nhbneig(ia)
              do ja=1,nhbneig(ia)
                ihb=ineig(maxng+1-ja,ia)
                if (ihb .gt. 0) then
                  ihbdel=0
                  if (ihb0 .gt. 0) call checkhbclose(c,n,ia,ihb,
         -          'hydrogen bonded',15,ihbdel)
                  if (ihb0 .gt. 0 .and. ihbdel .eq. 0) then
                    call checkhbclose(c,n,ia,ihb0,
         -            'hydrogen bonded',15,ihbdel)
                    call checkhbclose(c,n,ihb0,ihb,
         -            'hydrogen-bond donor bond',24,ihbdel)
                  end if
                  if (ihb0 .gt. 0 .and. ihbdel .eq. 0) then
                    call angdistw(c(1,ia),c(1,ihb),c(1,ihb0),rHB,rb,rab,ang)
                    ang=ang*radtodeg
                  else
                    ang=angmin-1.0
                  end if
                  if (ang .lt. angmin .or. iatnum(ihb0) .eq. 6) then
                    ineig(maxng+1-ja,ia)=0
                    nremia=0
                    do ii=maxng+1-nhbneig(ihb),maxng
                      if (ineig(ii,ihb) .eq. ia) then
                        ineig(ii,ihb)=0
                        nremia=1
                      end if
                    end do
                    if (nremia .eq. 0) then
                      print *,'PROGRAM ERROR: atom ',ia,
         -            ' is not on the HB list of atom',ihb
                      write (6,*) '(trying to remove) ',ihb,' ihb:',
         -              (ineig(maxng-in+1,ihb),in=1,nhbneig(ihb))
                    end if
                  end if
                end if
              end do
            else if (ifchrg(ia) .gt. 0 .and. islvw .gt. 0) then
              nhbng=nhbneig(ia)
              do ja=1,nhbneig(ia)
                ihb=ineig(maxng+1-ja,ia)
                if (ihb .gt. 0) then
                  idrop=0
                  if (iatnum(ihb) .eq. 1) then
                    idrop=1
                  else
                    if (ihb .le. nslt) print *,'PROGRAM ERROR: atom ',ia,
         -            ' is a cation but is ','H-bonded to a non-solvent'
                    if (iatnum(ihb) .ne. 8) print *,'PROGRAM ERROR: atom ',
         -            ia,' is H-bonded to a cation but is not an oxygen'
                    nnh=0
                    do in=1,nneig(ihb)
                      jn=ineig(in,ihb)
                      if (iatnum(jn) .eq. 1) then
                        nnh=nnh+1
                        nh12(nnh)=jn
                      end if
                    end do
                    if (nnh .ne. 2) then
                      if (nframe .eq. 0) write (6,2000) ihb,nnh
                      if (nframe .gt. 0) write (6,2000) ihb,nnh,' ',nframe
                    end if
                    call angdistw(c(1,ihb),c(1,ia),c(1,nh12(1)),rHB,rb,
         -            rab,ang)
                    ang=ang*radtodeg
                    if (ang .lt. angmin) then
                      call angdistw(c(1,ihb),c(1,ia),c(1,nh12(2)),rHB,rb,
         -              rab,ang)
                      ang=ang*radtodeg
                    end if
                    if (ang .lt. angmin) idrop=2
                  end if
                  if (idrop .gt. 0) then
    C               Drop
                    print *,'DROP cation bond ',ia,' - ',ihb,
         -            ' idrop=',idrop,' ang=',ang
                    ineig(maxng+1-ja,ia)=0
                    nremia=0
                    do ii=maxng+1-nhbneig(ihb),maxng
                      if (ineig(ii,ihb) .eq. ia) then
                        ineig(ii,ihb)=0
                        nremia=1
                      end if
                    end do
                    if (nremia .eq. 0) then
                      print *,'PROGRAM ERROR: atom ',ia,
         -            ' is not on the HB list of atom',ihb
                      write (6,*) '(trying to remove) ',ihb,' ihb:',
         -              (ineig(maxng-in+1,ihb),in=1,nhbneig(ihb))
                    end if
                  end if
                end if
              end do
            end if
          end do
          do ia=nfirst,n
            ndel=0
            do ja=1,nhbneig(ia)
              if (ineig(maxng-ja+1,ia) .eq. 0) then
                ndel=ndel+1
              else
                ineig(maxng-ja+1+ndel,ia)=ineig(maxng-ja+1,ia)
              end if
            end do
            nhbneig(ia)=nhbneig(ia)-ndel
          end do
          call checkhblist(n,ineig,nhbneig,maxng)
          return
    1002  format(' NNLIST00 i1,2,3=',3i4,' indexi=',i6,' ni=',i4)
    1012  format(' NNLIST00 j1,2,3=',3i4,' indexj=',i6,' nj=',i4)
    2000  format(' WARNING: water oxygen ',i6,' has',i3,' hydrogens bonded',
         -  ' to it',a,' Nframe=',i6)
    2001  format(' Geometry-based linked-cell NN search, max # of ',
         -  'atoms/cell=',i3,' (',f5.1,' %)')
          end
          subroutine get_heavyat(ia,nneig,ineig,ixres,nframe,ihb0,maxneig,
         -  maxrec)
          dimension nneig(maxrec),ineig(maxneig,maxrec),ixres(maxrec)
          ihb0=0
          nx=0
          ing_prev=0
          do iaa=1,nneig(ia)
            ing=ineig(iaa,ia)
            if (nneig(ia) .eq. 1 .or. ixres(ia) .eq. ixres(ing)) then
              ihb0=ineig(iaa,ia)
              ing_prev=ing
              nx=nx+1
              if (nx .gt. 1) then
                if (nx .eq. 2)
         -        write (6,2002) ia,ixres(ia),ing,ixres(ing_prev)
                write (6,2002) ia,ixres(ia),ing,ixres(ing)
              end if
            end if
          end do
          if (nx .gt. 1) then
            if (nframe .eq. 0) write (6,2001) ia,nx
            if (nframe .gt. 0) write (6,2001) ia,nx,' ',nframe
          end if
          return
    2001  format(' WARNING: Hbond donor H ',i6,' has ',i3,' bond(s)',a,
         -  ' Nframe=',i6)
    2002  format(' H atom',i6,' ixres',i5,' is bonded to atom',i6,' ixres',
         -  i5) 
          end
          subroutine nnlisthph_sltb(n,ianchor2,iselfanc,indexa,nneig,
         -  n14neig,nhbneig,ineig,c,rhphmax,isltb,isegno,nosameseg,bondlab,
         -  lbondlab,indices,nbox,ifail,maxng,maxbox,maxrec)
          dimension indexa(n),nneig(n),n14neig(n),nhbneig(n),
         -  ineig(maxng,n),c(3,n),isegno(n),indices(maxbox,maxrec),
         -  nbox(maxrec)
          character*(*) bondlab
          dimension nxyz(3),ix(3),xyzmin(3),xyzmax(3),centinp(3)
          LEVTEST=0
          rhphmax2=rhphmax**2
          ifail=0
          call extension(c,nneig,0,1,n,xyzmin,xyzmax,centinp,0,1,v)
          div=amin1(5.001,rhphmax+0.001)
          rphmin=0.0
          call gridspace(c,isegno,1,n,xyzmin,xyzmax,div,
         -  nxyz,nx,nxy,nbox,ix,indices,ifail,1,LEVTEST,maxbox,maxrec)
          call zeroiti(nneig,0,n)
          call zeroiti(nhbneig,0,n)
          do i1=1,nxyz(1)
            do i2=1,nxyz(2)
              do i3=1,nxyz(3)
                indexi=i1+nx*(i2-1)+nxy*(i3-1)
                ni=nbox(indexi)
                if (LEVTEST .gt. 2) write (88,1002) i1,i2,i3,indexi,ni
                if (ni .gt. 0) then
                  do j1=max0(1,i1-1),i1
                    do j2=max0(1,i2-1),min0(nxyz(2),i2+(i1-j1))
                      j3lim=i3
                      if (i1 .gt. j1 .or. i2. gt. j2) j3lim=j3lim+1
                      do j3=max0(1,i3-1),min0(j3lim,nxyz(3))
                        indexj=j1+nx*(j2-1)+nxy*(j3-1)
                        nj=nbox(indexj)
                        if (indexi .eq. indexj) then
                          ij=0
                        else
                          ij=1
                        end if
                        if (LEVTEST .gt. 2)
         -                write (88,1003) j1,j2,j3,indexj,nj
                        do jj=1,nj
                          ja=indices(jj,indexj)
                          ii1=1
                          if (ij .eq. 0) ii1=jj+1
                          do ii=ii1,ni
                            ia=indices(ii,indexi)
                            idoit=0
                            if (indexa(ia) .gt. 0 .and.
         -                      indexa(ja) .gt. 0) then
                              if (iselfanc .eq. 1) idoit=1
                            else if (indexa(ia)*indexa(ja) .lt. 0) then
                              if (ianchor2 .eq. 0) idoit=1
                            end if
                            if (nosameseg .eq. 1 .and.
         -                      isegno(ia) .eq. isegno(ja)) idoit=0
                            if (isltb .eq. 1) then
                              if (idoit .eq. 1) then
                                if (iabs(indexa(ia)) .eq. iabs(indexa(ja)))
         -                        idoit=0
                              end if
                            end if
                            if (idoit .eq. 1) then
                              do in=1,n14neig(ia)
                                if (ja .eq. ineig(in,ia)) idoit=0
                              end do
                            end if
                            if (idoit .eq. 1) then
                              r2=dist2(c(1,ia),c(1,ja))
                              if (r2 .le. rhphmax2) then
                                if (nhbneig(ia) .eq. maxng .or.
         -                          nhbneig(ia) .eq. maxng) then
                                  write (6,2000) bondlab(1:lbondlab),maxng
                                  ifail=1
                                  return
                                else
                                  nhbneig(ia)=nhbneig(ia)+1
                                  ineig(maxng-nhbneig(ia)+1,ia)=ja
                                  nhbneig(ja)=nhbneig(ja)+1
                                  ineig(maxng-nhbneig(ja)+1,ja)=ia
                                end if
                              end if
                            end if
                          end do
                        end do
                      end do
                    end do
                  end do
                end if
              end do
            end do
          end do
          if (LEVTEST .gt. 0) then
            do ia=1,n
              if (nhbneig(ia) .gt. 0) then
                write (88,1004) ia,(ineig(maxng-ja+1,ia),ja=1,nhbneig(ia))
              end if
            end do
          end if
          return
    1002  format(' NNLISTHPH i1,2,3=',3i4,' indexi=',i6,' ni=',i4)
    1003  format(' NNLISTHPH j1,2,3=',3i4,' indexj=',i6,' nj=',i4)
    1004  format(' NNLISTHPH ia=',i4,' nhblist:',100i4)
    2000  format(' ERROR: Maximum number of ',a,' neighbors (',i3,') is ',
         -  'exceeded')
          end
          subroutine nnlistmpx(n,nanchorr,nanchorn,indexa,indexov,iatnum,
         -  nneig,nhbneig,c,isegno,indices,nbox,rmpxlim,it1,it2,it3,it4,it5,
         -  temp1,temp2,ifail,maxbox,maxrec)
          dimension indexa(n),indexov(n),iatnum(n),nneig(n),nhbneig(n),
         -  c(3,n),isegno(maxrec),indices(maxbox,maxrec),
         -  nbox(maxrec),it1(n),it2(n),it3(n),it4(n),it5(n),temp1(n),
         -  temp2(n)
          dimension nxyz(3),ix(3),xyzmin(3),xyzmax(3),centinp(3)
          LEVTEST=0
          ifail=0
          call extension(c,nneig,0,1,n,xyzmin,xyzmax,centinp,0,1,v)
          div=rmpxlim
          if (rmpxlim .gt. 5.0) div=5.0
          rphmin=0.0
          call gridspace(c,isegno,1,n,xyzmin,xyzmax,div,
         -  nxyz,nx,nxy,nbox,ix,indices,ifail,1,LEVTEST,maxbox,maxrec)
          nboxes=nxyz(1)*nxyz(2)*nxyz(3)
          call zeroiti(it1,0,n)
          do ia=1,nanchorr
            if (iatnum(indexa(ia)) .ne. 1) it1(indexa(ia))=1
          end do
          do ia=1,nanchorn
            if (iatnum(indexov(ia)) .ne. 1) it1(indexov(ia))=2
            write (77,*) 'Ni=',ia,' Rix=',indexov(ia),
         -    ' IA=',iatnum(indexov(ia))
          end do
          do ib=1,nboxes
            nb=nbox(ib)
            call indexit(it2,1,nb,0)
            do ia=1,nb
              temp1(ia)=it1(indices(ia,ib))
            end do
            call mrgsrt(6,it2,temp1,nb,it3,it4,it5,temp2,n)
            call trnsfi(it5,indices(1,ib),nb)
            do ia=1,nb
              indices(ia,ib)=it5(it2(ia))
            end do
          end do
          do ib=1,nboxes
            if (nbox(ib) .gt. 0) then
              ia=1
              do while (it1(indices(ia,ib)) .eq. 0 .and. ia .lt. nbox(ib))
                ia=ia+1
              end do
              if (it1(indices(ia,ib)) .gt. 0) then
                if (it1(indices(ia,ib)) .eq. 1) then
                  it3(ib)=ia
                  do while (it1(indices(ia,ib)) .eq. 1 .and.
         -                  ia .lt. nbox(ib))
                    ia=ia+1
                  end do
                  if (it1(indices(ia,ib)) .eq. 2) then
                    it4(ib)=ia
                  else
                    it4(ib)=nbox(ib)+1
                  end if
                else
                  it3(ib)=nbox(ib)+1
                  it4(ib)=ia
                end if
              else
                it3(ib)=nbox(ib)+1
                it4(ib)=nbox(ib)+1
              end if
            end if
          end do
          call zeroiti(nneig,0,n)
          call zeroiti(nhbneig,0,n)
          call zeroiti(it2,0,n)
          do ia=1,n
            temp2(ia)=999999.9
          end do
          do i1=1,nxyz(1)
            do i2=1,nxyz(2)
              do i3=1,nxyz(3)
                indexi=i1+nx*(i2-1)+nxy*(i3-1)
                ni=nbox(indexi)
                if (LEVTEST .gt. 2) write (88,1002) i1,i2,i3,indexi,ni
                if (ni .gt. 0) then
                  do j1=max0(1,i1-1),i1
                    do j2=max0(1,i2-1),min0(nxyz(2),i2+(i1-j1))
                      j3lim=i3
                      if (i1 .gt. j1 .or. i2. gt. j2) j3lim=j3lim+1
                      do j3=max0(1,i3-1),min0(j3lim,nxyz(3))
                        indexj=j1+nx*(j2-1)+nxy*(j3-1)
                        nj=nbox(indexj)
                        if (nj .gt. 0) then
                          if (indexi .eq. indexj) then
                            ij=0
                          else
                            ij=1
                          end if
                          if (LEVTEST .gt. 2)
         -                  write (88,1003) j1,j2,j3,indexj,nj
                          do iaa=it3(indexi),it4(indexi)-1
                            ia=indices(iaa,indexi)
                            do jaa=it4(indexj),nj
                              ja=indices(jaa,indexj)
                              r2=dist2(c(1,ia),c(1,ja))
                              if (r2 .lt. temp2(ia)) then
                                temp2(ia)=r2
                                it2(ia)=ja
                              end if
                              if (r2 .lt. temp2(ja)) then
                                temp2(ja)=r2
                                it2(ja)=ia
                              end if
                            end do
                          end do
                          do iaa=it4(indexi),ni
                            ia=indices(iaa,indexi)
                            do jaa=it3(indexj),it4(indexj)-1
                              ja=indices(jaa,indexj)
                              r2=dist2(c(1,ia),c(1,ja))
                              if (r2 .lt. temp2(ia)) then
                                temp2(ia)=r2
                                it2(ia)=ja
                              end if
                              if (r2 .lt. temp2(ja)) then
                                temp2(ja)=r2
                                it2(ja)=ia
                              end if
                            end do
                          end do
                        end if
                      end do
                    end do
                  end do
                end if
              end do
            end do
          end do
          if (LEVTEST .gt. 0) then
            do ia=1,n
              if (it1(ia) .eq. 1) then
                if (it2(ia) .gt. 0) then
                  if (it2(it2(ia)) .eq. ia) then
                    write (88,1004) ia,it2(ia),sqrt(temp2(ia))
                  end if
                end if
              end if
            end do
          end if
          return
    1002  format(' NNLISTMPX i1,2,3=',3i4,' indexi=',i6,' ni=',i4)
    1003  format(' NNLISTMPX j1,2,3=',3i4,' indexj=',i6,' nj=',i4)
    1004  format(' NNLISTMPX MPX pair:',2i6,' Dist=',f8.3,' A')
          end
          subroutine gridspace(c,isegno,nfirst,n,xyzmin,xyzmax,div,nxyz,
         -  nx,nxy,nbox,ix,indices,ifail,istop,LEVTEST,maxbox,maxrec)
          dimension c(3,n),isegno(n),nxyz(3),ix(3),xyzmin(3),xyzmax(3),
         -  nbox(maxrec),indices(maxbox,maxrec)
          do k=1,3
            nxyz(k)=(xyzmax(k)-xyzmin(k))/div+1
          end do
          nx=nxyz(1)
          nxy=nxyz(1)*nxyz(2)
          if (LEVTEST .gt. 0)
         -  write (88,1000) div,nx,nxy,nxyz,xyzmin,xyzmax
          ngrid=nxyz(1)*nxyz(2)*nxyz(3)
          do while (ngrid .gt. maxrec)
            divo=div
            div=div*(float(ngrid)/float(maxrec))**(1.0/3.0) + 0.1
            print *,'Grid size increased from ',divo,' to ',div,
         -    ' - increase MAXREC to ',ngrid,' to avoid it'
            do k=1,3
              nxyz(k)=(xyzmax(k)-xyzmin(k))/div+1
            end do
            ngrid=nxyz(1)*nxyz(2)*nxyz(3)
            nx=nxyz(1)
            nxy=nxyz(1)*nxyz(2)
          end do
          if (LEVTEST .gt. 0)
         -  write (88,1000) div,nx,nxy,nxyz,xyzmin,xyzmax
          call zeroiti(nbox,0,ngrid)
          maxboxcount=0
          do i=nfirst,n
            if (isegno(i) .ne. -1) then
              do k=1,3
                ix(k)=(c(k,i)-xyzmin(k))/div+1
              end do
              indexi=ix(1)+nx*(ix(2)-1)+nxy*(ix(3)-1)
              if (LEVTEST .gt. 1) write (88,1001) i,indexi,ix
              nbox(indexi)=nbox(indexi)+1
              if (nbox(indexi) .le. maxbox) then
                indices(nbox(indexi),indexi)=i
              else
                print *,'Too many atoms in a box'
                if (istop .eq. 0) then
                  print *,'Slow bond generator will be used for now'
                  print *,'Increase MAXNEIG and recompile to avoid it'
                  ifail=1
                  return
                else
                  print *,'Reduce distance threshold or'
                  print *,'increase MAXNEIG and recompile'
                  stop
                end if
              end if
            end if
          end do
          return
    1000  format(' GRIDSPACE div=',f7.2,' nx,nxy=',2i8,
         -  ' nxyz=',3i4,/,' xyzmin=',3f10.5,' xyzmax=',3f10.5)
    1001  format(' GRIDSPACE i,indexi=',2i6,' ix=',3i4)
          end
          subroutine maybehbond(r2,i,j,nneig,nhbneig,ineig,inamcol1,
         -  inamcol2,rlimhb2,atnami,resnami,n,maxng)
          dimension nneig(n),nhbneig(n),ineig(maxng,n)
          character*4 atnami
          character*8 resnami
          if (r2 .lt. rlimhb2) then
            maxngij=max0(nneig(i)+nhbneig(i),nneig(j)+nhbneig(j))
            if (maxngij .lt. maxng) then
              ineig(maxng-nhbneig(i),i)=j
              nhbneig(i)=nhbneig(i)+1
              ineig(maxng-nhbneig(j),j)=i
              nhbneig(j)=nhbneig(j)+1
            else
              if (inamcol2 .lt. inamcol1) then
                write (6,2000) i,maxng
              else
                 write (6,2001) i,atnami,resnami,maxng
              end if
              write (6,2002) maxngij
            end if
          end if
          return
    2000  format(' ERROR: atom',i6,' has more than ',i2,' neighbours',
         -  ' and hydrogen bonds')
    2001  format(' ERROR: atom',i6,' (',a4,a6,') has more than ',i2,
         -  ' neighbours and hydrogen bonds')
    2002  format(' - increase the parameter MAXNEIG and recompile')
          end
          subroutine checkhbclose(c,n,i1,i2,label,llabel,ihbdel)
          dimension c(3,n)
          character*(*) label
          dij2=dist2(c(1,i1),c(1,i2))
          if (dij2 .lt. 0.5) then
            if (dij2 .lt. 0.001) then
              write (6,1000) 'ERROR',i1,i2,label(1:llabel),sqrt(dij2)
              ihbdel=1
            else
              write (6,1000) 'WARNING',i1,i2,label(1:llabel),sqrt(dij2),
         -      ' - hydrogen bond is deleted'
            end if
          end if
          return
    1000  format(1x,a,': atoms ',i6,' and ',i6,' are listed as ',a,/,
         -  ' but are only',f8.5,' A apart',a)
          end
          subroutine nnlistsim(nfirst,n,c,nneig,ineig,indices,nbox,
         -  rcut,ifail,maxng,nnlistlen,maxbox,maxrec,LEVTEST)
          dimension nneig(n),ineig(maxng,nnlistlen),c(3,n),
         -  indices(maxbox,maxrec),nbox(maxrec)
          dimension nxyz(3),ix(3),xyzmin(3),xyzmax(3),centinp(3)
          if (n .gt. nnlistlen) then
            print *,'Redimension the program with maxat > ',10*n
            ifail=1
            return
          end if
          div=rcut+0.1
          rcut2=rcut**2
          ifail=0
          if (n .lt. nfirst) return
          call extension(c,nneig,0,nfirst,n,xyzmin,xyzmax,centinp,0,0,v)
          call zeroiti(nneig,0,n)
          do k=1,3
            nxyz(k)=(xyzmax(k)-xyzmin(k))/div+1
          end do
          nx=nxyz(1)
          nxy=nxyz(1)*nxyz(2)
          if (LEVTEST .gt. 0)
         -  write (88,1000) div,nx,nxy,nxyz,xyzmin,xyzmax
          ngrid=nxyz(1)*nxyz(2)*nxyz(3)
          do while (ngrid .gt. maxrec)
            divo=div
            div=div*(float(ngrid)/float(maxrec))**(1.0/3.0) + 0.1
            print *,'Grid size increased from ',divo,' to ',div,
         -    ' - increase maxrec to ',ngrid,' to avoid it'
            do k=1,3
              nxyz(k)=(xyzmax(k)-xyzmin(k))/div+1
            end do
            ngrid=nxyz(1)*nxyz(2)*nxyz(3)
          end do
          nx=nxyz(1)
          nxy=nxyz(1)*nxyz(2)
          if (LEVTEST .gt. 0)
         -  write (88,1000) div,nx,nxy,nxyz,xyzmin,xyzmax
          call zeroiti(nbox,0,ngrid)
          nboxmax=0
          do i=nfirst,n
             do k=1,3
               ix(k)=(c(k,i)-xyzmin(k))/div+1
             end do
             indexi=ix(1)+nx*(ix(2)-1)+nxy*(ix(3)-1)
             if (LEVTEST .gt. 1) write (88,1001) i,indexi,ix
             nbox(indexi)=nbox(indexi)+1
             if (nboxmax .lt. nbox(indexi)) nboxmax=nbox(indexi)
             if (nbox(indexi) .le. maxbox) then
               indices(nbox(indexi),indexi)=i
             else
               ifail=1
             end if
          end do
          if (ifail .gt. 0) then
            print *,'Too many atoms in a box - ',
         -    'increase maxbox or MAXREC and recompile'
            return
          end if
          do i1=1,nxyz(1)
            do i2=1,nxyz(2)
              do i3=1,nxyz(3)
                indexi=i1+nx*(i2-1)+nxy*(i3-1)
                ni=nbox(indexi)
                if (LEVTEST .gt. 2) write (88,1002) i1,i2,i3,indexi,ni
                if (ni .gt. 0) then
                  do j1=max0(1,i1-1),i1
                    do j2=max0(1,i2-1),min0(nxyz(2),i2+(i1-j1))
                      j3lim=i3
                      if (i1 .gt. j1 .or. i2. gt. j2) j3lim=j3lim+1
                      do j3=max0(1,i3-1),min0(j3lim,nxyz(3))
                        indexj=j1+nx*(j2-1)+nxy*(j3-1)
                        nj=nbox(indexj)
                        if (i1 .eq. j1 .and. i2 .eq. j2 .and.
         -                  i3 .eq. j3) then
                          ij=0
                        else
                          ij=1
                        end if
                        if (LEVTEST .gt. 2)
         -                write (88,1012) j1,j2,j3,indexj,nj
                        do jj=1,nj
                          j=indices(jj,indexj)
                          ii1=1
                          if (ij .eq. 0) ii1=jj+1
                          do ii=ii1,ni
                            i=indices(ii,indexi)
                            r2=dist2(c(1,i),c(1,j))
                            if (r2 .le. rcut2) then
                              if (nneig(i) .lt. maxng .and.
         -                        nneig(j) .lt. maxng) then
                              nneig(i)=nneig(i)+1
                              ineig(nneig(i),i)=j
                              nneig(j)=nneig(j)+1
                              ineig(nneig(j),j)=i
                              else
                                print *,'Redimension the program for more',
         -                        ' neighbors in nnlistsim'
                                ifail=1
                                return
                              end if
                            end if
                          end do
                        end do
                      end do
                    end do
                  end do
                end if
              end do
            end do
          end do
          maxnn=0
          do i=nfirst,n
            if (nneig(i) .gt. maxnn) maxnn=nneig(i)
          end do
          return
    1000  format(' NNLISTSIM div=',f10.5,' nx,nxy=',2i4,
         -  ' nxyz=',3i4,/,' xyzmin=',3f10.5,' xyzmax=',3f10.5)
    1001  format(' NNLISTSIM i,indexi=',2i6,' ix=',3i4)
    1002  format(' NNLISTSIM i1,2,3=',3i4,' indexi=',i6,' ni=',i4)
    1012  format(' NNLISTSIM j1,2,3=',3i4,' indexj=',i6,' nj=',i4)
          end
          subroutine decidebondcut(ian1,ian2,rlim)
          common /connatdat/ ramax(99),ramax2(99),hlimfac,ianfg(99),
         -  namfcg(100),nrmw
          rlim=amax1(ramax2(ian1),ramax2(ian2))
          if (ian1 .eq. 1 .or. ian2 .eq. 1) rlim=rlim*hlimfac
          return
          end
          subroutine savebond(i,j,iatnum,nneig,ineig,nhbneig,nhneig,
         -  ncneig,nnneig,npneig,nsneig,resnamj,atnamj,maxng,n,nosort,
         -  inamcol1,inamcol2,LEVTEST)
          dimension nneig(n),ineig(maxng,n),iatnum(n),nhbneig(n),
         -  nhneig(n),nnneig(n),ncneig(n),nsneig(n),npneig(n)
          character*4 atnamj
          character*8 resnamj
          if (LEVTEST .gt. 0) write (88,*) 'SAVEBOND i,j,=',i,j
          if (iatnum(j) .ge. 88 .and. iatnum(j) .le. 90 .or.
         -     iatnum(i) .lt. 88 .or. iatnum(i) .gt. 90) then
             maxngij=max0(nneig(i)+nhbneig(i),nneig(j)+nhbneig(j))
            if (maxngij .lt. maxng) then
              if (nneig(j) .gt. 0 .and. nosort .eq. 0) then
                if (i .gt. ineig(nneig(j),j)) then
                  ineig(nneig(j)+1,j)=i
                else
                  nnj=nneig(j)
                  do inn=1,nnj
                    in=nnj-inn+1
                    if (i .gt. ineig(in,j)) go to 11
                  end do
                  in=0
    11            in0=in+1
                  do inn=in0,nnj
                    in=nnj-inn+in0
                    ineig(in+1,j)=ineig(in,j)
                  end do
                  ineig(in0,j)=i
                end if
              else
                ineig(nneig(j)+1,j)=i
              end if
              nneig(j)=nneig(j)+1
              if (iatnum(i) .eq. 1) nhneig(j)=nhneig(j)+1
              if (iatnum(i) .eq. 6) ncneig(j)=ncneig(j)+1
              if (iatnum(i) .eq. 7) nnneig(j)=nnneig(j)+1
              if (iatnum(i) .eq. 16) nsneig(j)=nsneig(i)+1
              if (iatnum(i) .eq. 15) npneig(j)=npneig(i)+1
            else
              if (inamcol2 .ge. inamcol1) then
                write (6,2001) j,atnamj,resnamj,maxng
              else
                write (6,2000) j,maxng
              end if
              write (6,2002) maxngij
            end if
          end if
          return
    2000  format(' ERROR: atom',i6,' has more than ',i2,' neighbours',
         -  ' and hydrogen bonds')
    2001  format(' ERROR: atom',i6,' (',a4,a6,') has more than ',i2,
         -  ' neighbours and hydrogen bonds')
    2002  format(' - increase the parameter MAXNEIG and recompile')
          end
          subroutine nnlistslv(nfirst,n,iatnum,c,nneig,nhneig,ineig,maxng)
          dimension nneig(n),nhneig(n),ineig(maxng,n),iatnum(n),c(3,n)
          call zeroiti(nneig,nfirst-1,n)
          do i=nfirst,n
            do j=i+1,n
              r2=dist2(c(1,i),c(1,j))
              call decidebondcut(iatnum(i),iatnum(j),rlim)
              if (r2 .le. rlim .and. iatnum(i)+iatnum(j) .gt. 2) then
                nneig(i)=nneig(i)+1
                nneig(j)=nneig(j)+1
                ineig(nneig(i),i)=j
                ineig(nneig(j),j)=i
                if (iatnum(i) .eq. 1) nhneig(j)=nhneig(j)+1
                if (iatnum(j) .eq. 1) nhneig(i)=nhneig(i)+1
              end if
            end do
          end do
          return
          end
          subroutine nnlist0o(nfirst,n,iatnum,c,nneig,nhbneig,ineig,nhneig,
         -  nnneig,ncneig,nsneig,npneig,line,irescol1,irescol2,inamcol1,
         -  inamcol2,index,maxng,hblimfac,maxrec)
          dimension nneig(n),ineig(maxng,n),iatnum(n),c(3,n),nhbneig(n),
         -  nhneig(n),nnneig(n),ncneig(n),nsneig(n),npneig(n),index(n)
          common /connatdat/ ramax(99),ramax2(99),hlimfac,ianfg(99),
         -  namfcg(100),nrmw
          character* 132 line(maxrec)
          character*4 atnami
          character*8 resnami
          if (n .eq. nfirst) return
          do i=nfirst,n
            if (inamcol2 .ge. inamcol1) then
              resnami='     '
              resnami=line(index(i))(irescol1:irescol2)
              atnami=line(index(i))(inamcol1:inamcol2)
            end if
            j1=i+1
            do j=j1,n
              r2=dist2(c(1,i),c(1,j))
              call decidebondcut(iatnum(i),iatnum(j),rlim)
              if (r2 .le. rlim .and. iatnum(i)+iatnum(j) .gt. 2 .and.
         -        ramax2(iatnum(i))*ramax2(iatnum(j)) .gt. 0.0) then
                call savebond(j,i,iatnum,nneig,ineig,nhbneig,nhneig,ncneig,
         -        nnneig,npneig,nsneig,resnami,atnami,maxng,n,1,
         -        inamcol1,inamcol2,0)
                call savebond(i,j,iatnum,nneig,ineig,nhbneig,nhneig,ncneig,
         -        nnneig,npneig,nsneig,resnami,atnami,maxng,n,1,
         -        inamcol1,inamcol2,0)
              else if (iatnum(i)  .eq. 1 .and. iatnum(j) .gt. 1 .and.
         -             iatnum(j) .ne. 6 .or.
         -             iatnum(j)  .eq. 1 .and. iatnum(i) .gt. 1 .and.
         -             iatnum(i) .ne. 6 )  then
                if (r2 .lt. rlim*(hblimfac/hlimfac)) then
                  if (max0(nneig(i)+nhbneig(i),nneig(j)+nhbneig(j)) .lt.
         -            maxng) then
                    ineig(maxng-nhbneig(i),i)=j
                    nhbneig(i)=nhbneig(i)+1
                    ineig(maxng-nhbneig(j),j)=i
                    nhbneig(j)=nhbneig(j)+1
                  else
                    if (inamcol2 .lt. inamcol1)
         -            write (6,2000) i,maxng
                    if (inamcol2 .ge. inamcol1)
         -            write (6,2001) i,atnami,resnami,maxng
                    write (6,2002)
                  end if
                end if
              end if
            end do
          end do
          return
    2000  format(' ERROR: atom',i6,' has more than ',i2,' neighbours',
         -  ' and hydrogen bonds')
    2001  format(' ERROR: atom',i6,' (',a4,a6,') has more than ',i2,
         -  ' neighbours and hydrogen bonds')
    2002  format(' - increase the parameter MAXNEIG and recompile')
          end
          subroutine bondcheck(iout,nfirst,n,iatnum,nneig,ineig,maxng,c,
         -  maxdist,line,irescol1,irescol2,inamcol1,inamcol2,index,rlim,
         -  nerr,maxrec)
          dimension nneig(n),ineig(maxng,n),c(3,n),iatnum(n),index(n),
         -  rlim(maxng)
          character* 132 line(maxrec)
          character*2 iatnm2
          common /atnam/ aw(99),nval(99),nvalmax(99),mmofan(99),
         -  mmatno(64),iatnm2(99)
          nerr=0
          nwarn=0
          nvalence=-1
          do i=nfirst,n
            if (iatnum(i) .gt. 0) nvalence=nval(iatnum(i))
            if (nneig(i) .gt. nvalence .and. nvalence .gt. 0) then
              do jj=1,nneig(i)
                j=ineig(jj,i)
                call decidebondcut(iatnum(i),iatnum(j),rlim(jj))
                rlim(jj)=sqrt(rlim(jj))
              end do
              write (iout,1000) i,iatnm2(iatnum(i)),
         -      line(index(i))(irescol1:irescol2),
         -      line(index(i))(inamcol1:inamcol2),nvalence,
         -      (ineig(j,i),line(index(ineig(j,i)))(irescol1:irescol2),
         -      line(index(ineig(j,i)))(inamcol1:inamcol2),
         -      sqrt(dist2(c(1,i),c(1,ineig(j,i)))),rlim(j),j=1,nneig(i))
              nerr=nerr+1
            end if
          end do
          if (nerr .gt. 0) then
            write (iout,1002) nerr
            write (6,1002) nerr
          else
            write (iout,*) 'No valence errors found'
          end if
          do i=nfirst,n
            do jj=1,nneig(i)
              j=ineig(jj,i)
              if (iabs(i-j) .gt. maxdist .and. i .lt. j .and.
         -        (iatnum(i) .ne. 32 .or. iatnum(j) .ne. 32)) then
                write (iout,1001) i,line(index(i))(irescol1:irescol2),
         -        line(index(i))(inamcol1:inamcol2),
         -        j,line(index(j))(irescol1:irescol2),
         -        line(index(j))(inamcol1:inamcol2),maxdist
                nwarn=nwarn+1
              end if
            end do
          end do
          return
    1000  format(' Atom',i7,1x,a2,' (',a4,1x,a4,') has more than',i2,
         -  ' bonds:',/,('   Bond to',i6,' (',a4,1x,a4,') d=',f4.2,
         -  ' A (threshold=',f4.2,' A)'))
    1001  format(' Bond exists between atoms',i6,' (',a4,1x,a4,') and ',
         -  i6,' (',a4,1x,a4,')',/,' but they are more than ',i4,
         -  ' atoms apart')
    1002  format(' !!! Number of valence errors found=',i3)
          end
          subroutine contactcheck(iout,nslt,n,iatnum,c,line,irescol1,
         -  irescol2,inamcol1,inamcol2,index,ctlimfac,bondminfac,
         -  isltonly,naslv,nneig,ineig,isegno,ioppbc,cell,ncell,edge,
         -  ixyzhex,molsltlim,nmolslt,nerr,maxng,maxrec)
          character* 132 line(maxrec)
          dimension iatnum(n),c(3,n),index(n),nneig(n),ineig(maxng,n),
         -  isegno(n),cell(3,ncell),edge(3),ixyzhex(3),molsltlim(3,nmolslt)
          common /connatdat/ ramax(99),ramax2(99),hlimfac,ianfg(99),
         -  namfcg(100),nrmw
          character*2 iatnm2
          common /atnam/ aw(99),nval(99),nvalmax(99),mmofan(99),
         -  mmatno(64),iatnm2(99)
          dimension rij(3)
          character*4 pbclab
          character*4 atnami
          character*8 resnami
          dimension rpbc(3)
          nbshort=0
          rminshort=1000.0
          nerr=0
          do i=1,nslt
            if ((iatnum(i) .lt. 88 .or. iatnum(i) .gt. 90)
         -      .and. isegno(i) .ge. 0) then
              if (inamcol2 .ge. inamcol1) then
                resnami='     '
                resnami=line(index(i))(irescol1:irescol2)
                atnami=line(index(i))(inamcol1:inamcol2)
              end if
              do jj=1,nneig(i)
                j=ineig(jj,i)
                if (j .gt. i) then
                  r2=dist2(c(1,i),c(1,j))
                  call decidebondcut(iatnum(i),iatnum(j),rlim)
                  rlim=rlim*bondminfac
                  if (r2 .lt. rlim) then
                    nerr=nerr+1
                    r=sqrt(r2)
                    if (inamcol2 .lt. inamcol1) then
                      write (iout,2002) i,iatnm2(iatnum(i)),j,
         -              iatnm2(iatnum(j)),r,sqrt(rlim)
                    else
                      write (iout,2003) i,resnami,atnami,j,
         -              line(index(j))(irescol1:irescol2),
         -              line(index(j))(inamcol1:inamcol2),
         -              r,sqrt(rlim)
                    end if
                    nbshort=nbshort+1
                    if (rminshort .gt. r) rminshort=r
                  end if
                end if
              end do
            end if
          end do
          if (ioppbc .ge. 0) call distminsetup(edge,ioppbc)
          ncsltintra=0
          ncsltinter=0
          ncsltinterpbc=0
          rminsltintra=1000.0
          rminsltinter=1000.0
          rminsltinterpbc=1000.0
          do im=1,nmolslt
            do i=molsltlim(1,im),molsltlim(2,im)
              if ((iatnum(i) .lt. 88 .or. iatnum(i) .gt. 90)
         -        .and. isegno(i) .ge. 0) then
                if (inamcol2 .ge. inamcol1) then
                  resnami='     '
                  resnami=line(index(i))(irescol1:irescol2)
                  atnami=line(index(i))(inamcol1:inamcol2)
                end if
                do j=i+1,molsltlim(2,im)
                  if ((iatnum(j) .lt. 88 .or. iatnum(j) .gt. 90)
         -            .and. isegno(j) .ge. 0) then
                    ibonded=0
                    do in=1,nneig(i)
                      if (j .eq. ineig(in,i)) ibonded=1
                    end do
                    if (ibonded .eq. 0) then
                      r2=dist2(c(1,i),c(1,j))
                      call decidebondcut(iatnum(i),iatnum(j),rlim)
                      rlimct=rlim*ctlimfac
                      if (r2 .le. rlimct) then
                        nerr=nerr+1
                        r=sqrt(r2)
                        if (inamcol2 .lt. inamcol1) then
                          write (iout,2000) 'Slt NB ',i,
         -                  iatnm2(iatnum(i)),j,iatnm2(iatnum(j)),
         -                  r,sqrt(rlimct)
                        else
                          write (iout,2001) 'Slt NB ',i,resnami,atnami,j,
         -                  line(index(j))(irescol1:irescol2),
         -                  line(index(j))(inamcol1:inamcol2),
         -                  r,sqrt(rlimct)
                        end if
                        ncsltintra=ncsltintra+1
                        if (rminsltintra .gt. r) rminsltintra=r
                      end if
                    end if
                  end if
                end do
                do jm=im+1,nmolslt
                  do j=molsltlim(1,jm),molsltlim(2,jm)
                    if ((iatnum(j) .lt. 88 .or. iatnum(j) .gt. 90)
         -              .and. isegno(j) .ge. 0) then
                      pbclab='    '
                      if (ioppbc .ge. 0) then
                        call arrdiff(c(1,i),c(1,j),rpbc,3)
                        call distmincalc(ioppbc,cell,ncell,ixyzhex,edge,
         -                rpbc(1),rpbc(2),rpbc(3),icmin,r2)
                        if (icmin .gt. 1) pbclab=' PBC'
                      else
                        r2=dist2(c(1,i),c(1,j))
                      end if
                      call decidebondcut(iatnum(i),iatnum(j),rlim)
                      rlimct=rlim*ctlimfac
                      if (r2 .le. rlimct) then
                        nerr=nerr+1
                        r=sqrt(r2)
                        if (inamcol2 .lt. inamcol1) then
                          write (iout,2000) 'Slt-Slt',i,
         -                  iatnm2(iatnum(i)),j,iatnm2(iatnum(j)),
         -                  r,sqrt(rlimct),pbclab
                        else
                          write (iout,2001) 'Slt-Slt',i,resnami,
         -                  atnami,j,line(index(j))(irescol1:irescol2),
         -                  line(index(j))(inamcol1:inamcol2),
         -                  r,sqrt(rlimct),pbclab
                        end if
                        if (pbclab .eq. ' PBC') then
                          ncsltinterpbc=ncsltinterpbc+1
                          if (rminsltinterpbc .gt. r) rminsltinterpbc=r
                        else
                          ncsltinter=ncsltinter+1
                          if (rminsltinter .gt. r) rminsltinter=r
                        end if
                        if (ioppbc .gt. 0) then
                          call arrdiff(c(1,i),c(1,j),rij,3)
                          call genimdist(rij,cell,1,ncell,icminn,rmin2)
                          if (abs(rmin2-r2) .gt. 0.1 .or.
         -                   icmin .eq. 1 .and. icminn .gt. 1 .or.
         -                   icmin .gt. 1 .and. icminn .eq. 1)
         -                  write (iout,2009) sqrt(rmin2),r2,icmin,icminn
                        end if
                      end if
                    end if
                  end do
                end do
              end if
            end do
          end do
          if (isltonly .eq. 1) go to 999
          nsv=(n-nslt)/naslv
          ncsltslv=0
          ncsltslvpbc=0
          rminsltslv=1000.0
          rminsltslvpbc=1000.0
          do ia=1,nslt
            do jm=1,nsv
              pbclab='    '
              icmin=1
              jm0=nslt+(jm-1)*naslv
              call arrdiff(c(1,ia),c(1,jm0+1),rpbc,3)
              if (ioppbc .ge. 0) then
                call distmincalc(ioppbc,cell,ncell,ixyzhex,edge,
         -        rpbc(1),rpbc(2),rpbc(3),icmin,r2)
                if (icmin .gt. 1) pbclab=' PBC'
              else
                r2=rpbc(1)**2+rpbc(2)**2+rpbc(3)**2
              end if
              isvclose=1
              if (r2 .lt. 25.0) then
                if (pbclab .eq. ' PBC') call genimdist(rpbc,cell,
         -        1,ncell,icminw,rmin2)
                do ja=2,naslv
                  call arrdiff(c(1,ia),c(1,jm0+ja),rpbc,3)
                  if (pbclab .eq. ' PBC') then
                    do k=1,3
                      rpbc(k)=rpbc(k)-cell(k,icminw)
                    end do
                  end if
                  r2j=rpbc(1)**2+rpbc(2)**2+rpbc(3)**2
                  if (r2j .lt. r2) then
                    r2=r2j
                    isvclose=ja
                  end if
                end do
                ja=jm0+isvclose
                call decidebondcut(iatnum(ia),iatnum(ja),rlim)
                rlimct=rlim*ctlimfac
                if (r2 .lt. rlimct) then
                  r=sqrt(r2)
                  nerr=nerr+1
                  if (inamcol2 .lt. inamcol1) then
                    write (iout,2005) ia,iatnm2(ia),jm,ja,iatnm2(ja),
         -           r,sqrt(rlimct),pbclab
                  else
                    write (iout,2006) ia,line(index(ia))(irescol1:irescol2),
         -            line(index(ia))(inamcol1:inamcol2),ja,
         -            iatnm2(iatnum(ja)),jm,r,sqrt(rlimct),pbclab
                  end if
                  if (pbclab .eq. ' PBC') then
                    ncsltslvpbc=ncsltslvpbc+1
                    if (rminsltslvpbc .gt. r) rminsltslvpbc=r
                  else
                    ncsltslv=ncsltslv+1
                    if (rminsltslv .gt. r) rminsltslv=r
                  end if
                  if (ioppbc .gt. 0) then
                    call arrdiff(c(1,ia),c(1,ja),rij,3)
                    call genimdist(rij,cell,1,ncell,icminn,rmin2)
                    if (abs(rmin2-r2) .gt. 0.1 .or.
         -             icmin .eq. 1 .and. icminn .gt. 1 .or.
         -             icmin .gt. 1 .and. icminn .eq. 1)
         -            write (iout,2009) sqrt(rmin2),r2,icmin,icminn
                  end if
                end if
              end if
            end do
          end do
          ncslvslv=0
          ncslvslvpbc=0
          rminslvslv=1000.0
          rminslvslvpbc=1000.0
          do im=1,nsv
            im0=nslt+(im-1)*naslv
            do jm=im+1,nsv
              jm0=nslt+(jm-1)*naslv
              call arrdiff(c(1,im0+1),c(1,jm0+1),rpbc,3)
              icmin=1
              pbclab='    '
              if (ioppbc .ge. 0) then
                call distmincalc(ioppbc,cell,ncell,ixyzhex,edge,
         -        rpbc(1),rpbc(2),rpbc(3),icmin,r2)
                if (icmin .gt. 1) pbclab=' PBC'
              else
                r2=rpbc(1)**2+rpbc(2)**2+rpbc(3)**2
              end if
              isvclose=1
              jsvclose=1
              if (r2 .lt. 25.0) then
                if (pbclab .eq. ' PBC') call genimdist(rpbc,cell,
         -        1,ncell,icminw,rmin2)
                do ia=1,naslv
                  do ja=1,naslv
                    call arrdiff(c(1,im0+ia),c(1,jm0+ja),rpbc,3)
                    if (pbclab .eq. ' PBC') then
                      do k=1,3
                        rpbc(k)=rpbc(k)-cell(k,icminw)
                      end do
                    end if
                    r2j=rpbc(1)**2+rpbc(2)**2+rpbc(3)**2
                    if (r2j .lt. r2) then
                      r2=r2j
                      isvclose=ia
                      jsvclose=ja
                    end if
                  end do
                  iac=im0+isvclose
                  jac=jm0+jsvclose
                  call decidebondcut(iatnum(iac),iatnum(jac),rlim)
                  rlimct=rlim*ctlimfac
                  r=sqrt(r2)
                  if (r2 .lt. rlimct) then
                     nerr=nerr+1
                    write (iout,2007) iac,iatnm2(iatnum(iac)),im,jac,
         -            iatnm2(iatnum(jac)),jm,r,sqrt(rlimct),pbclab
                    if (pbclab .eq. ' PBC') then
                      ncslvslvpbc=ncslvslvpbc+1
                      if (rminslvslvpbc .gt. r) rminslvslvpbc=r
                    else
                      ncslvslv=ncslvslv+1
                      if (rminslvslv .gt. r) rminslvslv=r
                    end if
                    if (ioppbc .gt. 0) then
                      call arrdiff(c(1,iac),c(1,jac),rij,3)
                      call genimdist(rij,cell,1,ncell,icminn,rmin2)
                      if (abs(rmin2-r2) .gt. 0.1 .or.
         -               icmin .eq. 1 .and. icminn .gt. 1 .or.
         -               icmin .gt. 1 .and. icminn .eq. 1)
         -              write (iout,2009) sqrt(rmin2),r2,icmin,icminn
                    end if
                  end if
                end do
              end if
            end do
          end do
    999   if (rminshort .eq. 1000.0) rminshort=0.0
          if (nbshort .gt. 0) then
            write (iout,2008) 'short bonds',nbshort,rminshort
            write (6,2008) 'short bonds',nbshort,rminshort
          else
            write (iout,*) 'No short bonds found'
          end if
          if (ncsltintra .gt. 0) then
            write (iout,2008) 'solute intramolecular clashes',
         -    ncsltintra,rminsltintra
            write (6,2008) 'solute intramolecular clashes',
         -    ncsltintra,rminsltintra
            else
              write (iout,*) 'No solute intramolecular clashes found'
            end if
          if (nmolslt .gt. 1) then
            if (ncsltinter .gt. 0) then
              write (iout,2008) 'solute intermolecular non-PBC clashes',
         -      ncsltinter,rminsltinter
              write (6,2008) 'solute intermolecular non-PBC clashes',
         -      ncsltinter,rminsltinter
            else
              write (iout,*) 'No solute intramolecular clashes found'
            end if
            if (ioppbc .ge. 0)  then
              if (ncsltinterpbc .gt. 0) then
                write (iout,2008) 'solute intermolecular PBC clashes',
         -        ncsltinterpbc,rminsltinterpbc
                write (6,2008) 'solute intermolecular PBC clashes',
         -        ncsltinterpbc,rminsltinterpbc
              else
                write (iout,*) 'No solute intermolecular PBC clashes found'
              end if
            end if
          end if
          if (isltonly .eq. 0) then
            if (ncsltslv .gt. 0) then
              write (iout,2008) 'solute -solvent non-PBC clashes',
         -      ncsltslv,rminsltslv
              write (6,2008) 'solute-solvent non-PBC clashes',
         -      ncsltslv,rminsltslv
            else
              write (iout,*) 'No solute-solvent non-PBC clashes found'
            end if
            write (iout,2008) 'solvent-solvent non-PBC clashes',
         -    ncslvslv,rminslvslv
            if (ioppbc .ge. 0) then
              if (ncsltslvpbc .gt. 0) then
                write (iout,2008) 'solute -solvent PBC clashes',
         -        ncsltslvpbc,rminsltslvpbc
                write (6,2008) 'solute-solvent PBC clashes',
         -        ncsltslvpbc,rminsltslvpbc
              else
                write (iout,*) 'No solute-solvent PBC clashes found'
              end if
              if (ncslvslvpbc .gt. 0) then
                write (iout,2008) 'solvent-solvent PBC clashes',
         -        ncslvslvpbc,rminslvslvpbc
                write (6,2008) 'solvent-solvent PBC clashes',
         -        ncslvslvpbc,rminslvslvpbc
              else
                write (iout,*) 'No solvent-solvent PBC clashes found'
              end if
            end if
          end if
          return
    2000  format(1x,a,' clash: d[',i5,' (',a2,') - ',i5,'(',a2,')]=',
         -  f4.2,' A (<',f4.2,')',a)
    2001  format(1x,a,' clash: d[',i5,' (',a4,1x,a5,') - ',i5,
         -  ' (',(a4,1x,a4),')]=',f4.2,' A (<',f4.2,')',a)
    2002  format(' Too short bond: d[',i5,' (',a2,') - ',i5,'(',a2,')]=',
         -  f6.2,' A (<',f4.2,')')
    2003  format(' Too short bond: d[',i5,' (',a4,1x,a5,') - ',
         -  i5,'(',a4,1x,a5,')]=',f4.2,' A (<',f4.2,')')
    2005  format(' Solvent clash: d(',i5,1x,a2,' - ',
         -  i7,1x,a2,' slv #',i6,')=',f4.2,' A (<',f4.2,')',a)
    2006  format(' Solvent clash: d(',i5,1x,a4,1x,a4,' - ',
         -  i7,1x,a2,' slv #',i6,')=',f4.2,' A (<',f4.2,')',a)
    2007  format(' Solvent clash: d(',i7,1x,a2,' #',i6,' - ',
         -  i7,1x,a2,' #',i6,')=',f4.2,' A (<',f4.2,')',a)
    2008  format(' !!! Number of ',a,' found=',i7,' Min=',f4.2,' A')
    2009  format(' PROGRAM ERROR: r(check)=',f9.4,' r(calc)=',f9.4,
         -  ' icmin,n=',2i3)
          end
          subroutine filterbonds(n,nbfound,nhbdist,rhbdist,nhbpers,itrackf,
         -  itrackl,itrack,maxlenon,maxlenoff,iframeunit,framefac,nframe,
         -  indexbond,label,llabel,line,index,inamcol1,inamcol2,irescol1,
         -  irescol2,iresno,isegno,ixres,ixresno,ixsegno,ifres,numres,
         -  nresslt,ianc_anc,isc,bondtype,lbondtype,percmin,percmax,
         -  minresdist,maxresdist,nochange,percbond,iuselaston,iauc,iaucw,
         -  inpfile,namleni,temp,it1,it2,it3,it4,irrix,itemp1,iout,maxrec,
         -  maxrsd,mxbonds,mxframes,mxcopy)
          dimension index(maxrec),nhbdist(mxbonds),rhbdist(mxbonds),
         -  nhbpers(mxbonds),itrackf(mxbonds),itrackl(mxbonds),
         -  itrack(mxframes),maxlenon(mxbonds),maxlenoff(mxbonds),
         -  indexbond(mxbonds),iresno(maxrec),isegno(maxrec),ixres(maxrec),
         -  ixresno(maxrsd),ixsegno(maxrsd),ifres(maxrec),ianc_anc(mxbonds),
         -  isc(maxrec),percbond(maxrec),temp(maxrec),it1(mxbonds),
         -  it2(mxbonds),it3(mxbonds),it4(mxbonds),irrix(maxrec),
         -  itemp1(maxrec)
          character*(*) label,bondtype,inpfile
          character*80 bond,listfile
          character*132 line(maxrec)
          parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
          parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
         -  (6*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
          common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),ing(MAX2D,MAX2D),
         -  ihbtores(MAXBONDS),nusepair(MAXBONDS),nhb_atot(MAXBONDS),
         -  nhb_rtot(MAXBONDS),a1(MAXBONDS),a2(MAXBONDS),fill(IFILL2)
          common /bondpairs/ ihbpair(2,MAXBONDS),ihb_pair_res(3,MAXBONDS)
          dimension limperc(6),nplim(6),npbsum(6)
          data limperc /1,2,5,10,20,50/
          character*6 bondlab
          ioutl=0
          nochange=1
          call getfiltlims(0.0,100.0,1,nresslt-1,percmin,percmax,
         -  minresdist,maxresdist,nresslt,nochange,label,llabel,' ',1,
         -  iout)
          do ip=1,6
            nplim(ip)=max0(1,nframe/(100/limperc(ip)))
            npbsum(ip)=0
          end do
          nhbsum=0
          nbb=0
          naa=0
          call zeroit(percbond,n)
          do ii=1,nbfound
            i=indexbond(ii)
            temp(i)=100.0*float(nhbdist(i))/float(nframe)
            nhbsum=nhbsum+nhbdist(i)
            do ip=1,6
              if (nhbdist(i) .gt. nplim(ip)) npbsum(ip)=npbsum(ip)+1
            end do
            if (ianc_anc(i) .eq. 1) naa=naa+1
            if (isc(ihbpair(1,i))*isc(ihbpair(2,i)) .eq. 0) nbb=nbb+1
          end do
          do ip=1,6
            write (iout,1007) limperc(ip),npbsum(ip)
          end do
          if (naa .gt. 0) write (iout,1008)
          if (nbb .gt. 0) write (iout,1009)
          nhbsumtot=nhbsum
          iallkept=1
          if (nochange .eq. 0) then
            ndel=0
            nmindel=0
            nmaxdel=0
            nmindistdel=0
            nmaxdistdel=0
            do ii=1,nbfound
              i=indexbond(ii)
              p=temp(i)
              ir1=ihbpair(1,i)
              ir2=ihbpair(2,i)
              iresdist=iabs(ixres(ihbpair(1,i))-ixres(ihbpair(2,i)))
              if (iresdist .lt. minresdist .or. iresdist .gt. maxresdist
         -      .or. p .lt. percmin .or. p .gt. percmax) then
                ndel=ndel+1
                if (p .lt. percmin) then
                  nmindel=nmindel+1
                  it1(nmindel)=i
                else if (p .gt. percmax) then
                  nmaxdel=nmaxdel+1
                  it2(nmaxdel)=i
                end if
                if (iresdist .lt. minresdist) then
                  nmindistdel=nmindistdel+1
                  it3(nmindistdel)=i
                else if (iresdist .gt. maxresdist) then
                  nmaxdistdel=nmaxdistdel+1
                  it4(nmaxdistdel)=i
                end if
              else
                indexbond(ii-ndel)=indexbond(ii)
              end if
            end do
            iallkept=0
            if (ndel .gt. 0) then
              nbfound=nbfound-ndel
              if (nmindel .gt. 0) then
                write (iout,1002) nmindel,'infrequent'
                do ib=1,nmindel
                  call bonddescr(it1(ib),ihbpair,line,index,iresno,isegno,
         -          inamcol1,inamcol2,irescol1,irescol2,bond,lbond,bondlab,
         -          lbondlab,nbb,ianc_anc,isc,ia1,ia2,ir1,ir2,maxrec,
         -          MAXBONDS)
                  write (iout,1005) 'BD',ib,it1(ib),bond(1:lbond),
         -          temp(it1(ib)),bondlab(1:lbondlab),
         -          rhbdist(it1(ib))/nhbdist(it1(ib))
                  nhbsum=nhbsum-nhbdist(it1(ib))
                end do
              end if
              if (nmaxdel .gt. 0) then
                write (iout,1002) nmaxdel,'persistent'
                do ib=1,nmaxdel
                  call bonddescr(it2(ib),ihbpair,line,index,iresno,isegno,
         -          inamcol1,inamcol2,irescol1,irescol2,bond,lbond,bondlab,
         -          lbondlab,nbb,ianc_anc,isc,ia1,ia2,ir1,ir2,maxrec,
         -          MAXBONDS)
                  write (iout,1005) 'BD',ib,it2(ib),bond(1:lbond),
         -          temp(it2(ib)),bondlab(1:lbondlab),
         -          rhbdist(it2(ib))/nhbdist(it2(ib))
                  nhbsum=nhbsum-nhbdist(it2(ib))
                end do
              end if
              if (nmindistdel .gt. 0) then
                write (iout,1002) nmindistdel,'close'
                do ib=1,nmindistdel
                  call bonddescr(it3(ib),ihbpair,line,index,iresno,isegno,
         -          inamcol1,inamcol2,irescol1,irescol2,bond,lbond,bondlab,
         -          lbondlab,nbb,ianc_anc,isc,ia1,ia2,ir1,ir2,maxrec,
         -          MAXBONDS)
                  write (iout,1005) 'BD',ib,it3(ib),bond(1:lbond),
         -          temp(it3(ib)),bondlab(1:lbondlab),
         -          rhbdist(it3(ib))/nhbdist(it3(ib))
                  nhbsum=nhbsum-nhbdist(it3(ib))
                end do
              end if
              if (nmaxdistdel .gt. 0) then
                write (iout,1002) nmaxdistdel,'distant'
                do ib=1,nmaxdistdel
                  call bonddescr(it4(ib),ihbpair,line,index,iresno,isegno,
         -          inamcol1,inamcol2,irescol1,irescol2,bond,lbond,bondlab,
         -          lbondlab,nbb,ianc_anc,isc,ia1,ia2,ir1,ir2,maxrec,
         -          MAXBONDS)
                  write (iout,1005) 'BD',ib,it4(ib),bond(1:lbond),
         -          temp(it4(ib)),bondlab(1:lbondlab),
         -          rhbdist(it4(ib))/nhbdist(it4(ib))
                  nhbsum=nhbsum-nhbdist(it4(ib))
                end do
              end if
              write (6,1003) label(1:llabel),nbfound
            else
              write (iout,*) 'All bonds are kept'
              iallkept=1
            end if
          end if
          write (iout,1004) nbfound,label(1:llabel)
          call zeroiti(irrix,0,n)
          call zeroiti(itemp1,0,numres)
          iaucw=0
          loffmin=0
          iauctype=0
          nseg_scr=0
          nreusemax=nframe
          call askyn('Do you want to calculate bond autocorrelation',45,
         -  1,-1,iauc,0,0)
          if (iauc .eq. 1)
         -  call auc_params(iauctype,lastframeinp,loffmin,nreusemax,
         -    nseg_scr,iaucw,nframe,iframeunit,framefac,'Bond',4,
         -    iuselaston,iout,mxframes)
          nauc_extra=0
          call askyn(
         -  'Do you want a list of bonded atom pairs',35,1,-1,ilistfile,0,7)
          if (ilistfile .eq. 1) then
            ioutl=50
            call changeext(inpfile,listfile,namleni,llistfile,'pls',3,0,0)
    
            call openfile(50,0,' ',1,'new',listfile,llistfile,notfnd,0,1,1,
         -    1,0)
            write (6,1012) listfile(1:llistfile)
            write (iout,1012) listfile(1:llistfile)
          end if
          do ib=1,nbfound
            i=indexbond(ib)
            call bonddescr(i,ihbpair,line,index,iresno,isegno,inamcol1,
         -    inamcol2,irescol1,irescol2,bond,lbond,bondlab,lbondlab,nbb,
         -    ianc_anc,isc,ia1,ia2,ir1,ir2,maxrec,MAXBONDS)
            if (ilistfile .eq. 1) write (ioutl,1001) ia1,ia2
            irrix(ia1)=irrix(ia1)+nhbdist(i)
            irrix(ia2)=irrix(ia2)+nhbdist(i)
            itemp1(ir1)=itemp1(ir1)+nhbdist(i)
            itemp1(ir2)=itemp1(ir2)+nhbdist(i)
            write (iout,1005) 'BF',ib,i,bond(1:lbond),temp(i),
         -    bondlab(1:lbondlab),rhbdist(i)/nhbdist(i)
            if (iauc .eq. 1)
         -    call persistence(nhbdist(i),nhbpers(i),itrackf(i),itrackl(i),
         -      maxlenon(i),maxlenoff(i),iframeunit,framefac,nframe,
         -      iuselaston,iout)
            if (iuselaston .eq. 1) then
              lentrack=itrackl(i)-itrackf(i)+1
            else
              lentrack=nframe-itrackf(i)+1
            end if
            percon=float(nhbdist(i))/float(lentrack)
            if (iauc .gt. 0) then
              call getbondtrack(i,itrack,ifirstframe,lastframe,30,nframe)
              call autocorr(ib,i,itrack,ifirstframe,lastframe,iframeunit,
         -      framefac,iauctype,lastframeinp,nreusemax,percon,loffmin,
         -      nseg_scr,nauc_extra,nframe,iout,mxframes)
            end if
          end do
          if (ilistfile .eq. 1) close (ioutl)
          call checkdim(mxcopy+nauc_extra,mxcopy,'MAXCOPY',7,
         -  'number of AUCs',14,iout)
          do ia=1,n
            percbond(ia)=float(irrix(ia))/float(nframe)
          end do
          write (iout,1006) bondtype(1:lbondtype),'=',
         -  float(nhbsumtot)/float(nframe)
          if (iallkept .eq. 0) write (iout,1006) bondtype(1:lbondtype),
         -  ' without the deleted ones=',float(nhbsum)/float(nframe)
          write (iout,1019) 'atom'
          do ia=1,n
            ir=ixres(ia)
            if (irrix(ia) .gt. 0) write (iout,1011)
         -    line(index(ia))(inamcol1:inamcol2),ia,
         -    line(index(ifres(ir)))(irescol1:irescol2),ixresno(ir),
         -    ixsegno(ir),float(irrix(ia))/float(nframe)
          end do
          write (iout,1019) 'residue'
          do ir=1,numres
            if (itemp1(ir) .gt. 0) write (iout,1010)
         -    line(index(ifres(ir)))(irescol1:irescol2),ixresno(ir),
         -    ixsegno(ir),float(itemp1(ir))/float(nframe)
          end do
          return
    1001  format(2i8)
    1002  format(' === List of ',i4,1x,a,' bonds filtered out:')
    1003  format(' Number of ',a,' bonds left after filtering=',i5)
    1004  format(/,' === List of ',i4,1x,a,' bonds left after filtering:')
    1005  format(1x,a,'#',i5,' (',i5,')',a,' % formed=',f6.1,' %',a,' <d>=',
         =  f5.2)
    1006  format(' Total number of ',a,' bonds per frame',a,f6.1)
    1007  format(' # of bonds occuring more than ',i3,'% of time:',i4)
    1008  format(' Lines ending with AA describe anchor-anchor bonds')
    1009  format(' Labels BB,SS,BS,SB refer to backbone-backbone, ',
         -  'sidechain-sidechain,',/,
         -  ' backbone-sidechain, sidechain-backbone bonds, resp.')
    1010  format(' Residue ',a,i5,' C/S',i2,': <Nbond>/frame=',f6.3)
    1011  format(' Atom ',a,i7,' Residue ',a,i5,' C/S',i2,
         -  ': <Nbond>/frame=',f6.3)
    1012  format(' List of contact atom pair indices are written to file',/,
         -  1x,a)
    
    1019  format(/,' === Number of bonds formed per frame for each ',a)
          end
          subroutine getfiltlims(percmind,percmaxd,minresdistd,
         -  maxresdistd,percmin,percmax,minresdist,maxresdist,
         -  nresslt,nochange,label,llabel,bondtyp,lbondtyp,iout)
          character*(*) label,bondtyp
          call getreal('MINimum percentage presence',27,percmind,percmin,1,
         -  7)
          call getreal('MAXimum percentage presence',27,percmaxd,percmax,1,
         -  7)
          if (percmin .gt. 0.0 .or. percmax .lt. 100.0) then
            nochange=0
            write (iout,1000) bondtyp(1:lbondtyp),label(1:llabel),percmin,
         -    percmax
          end if
          call getint('MINimum residue-residue sequence distance',41,
         -  0,minresdistd,0,minresdist,8)
          call getint('MAXimum residue-residue sequence distance',41,
         -  maxresdistd,1,nresslt-1,maxresdist,8)
          if (minresdist .gt. 0 .or. maxresdist .lt. nresslt-1) then
            nochange=0
            write (iout,1001) bondtyp(1:lbondtyp),label(1:llabel),
         -    minresdist,maxresdist
          end if
    1000  format(' Plotting and correlation calculation will exclude ',a,a,
         -  ' bonds',/,5x,'that are present in less than ',f6.1,'% of the ',
         -  'time or',/,5x,'more than ',f6.1,'% of the time')
    1001  format(' Plotting and correlation calculation will exclude ',a,a,
         -  ' bonds',/,5x,'whose residue-residue distance is less than ',i4,
         -  ' or greater than ',i5)
          end
          subroutine auc_params(iauctype,lastframeinp,loffmin,nreusemax,
         -  nseg_scr,iaucw,nframe,iframeunit,framefac,label,llabel,
         -  iuselaston,iout,mxframes)
          character*(*) label
          character*6 frunit
          common /frameunit/ lfrunit(4),frunit(4)
          character*1 ans
          dimension lauc_type(5)
          character*60 auc_type(5)
          data auc_type /
         -  'AUC data generation is ended at the last ON state',
         -  'AUC data generation is ended at the last frame of the track',
         -  'Track is padded with additional zeros',
         -  'Track is padded by reusing the last stretch of the track',
         -  'Track is padded by random 0/1 string, p(1)=fraction on'/,
         -  lauc_type /49,59,37,56,54/
          call quiz(ans,iauctype,'o',' ',0,
         -  'autocorrelation calculation mode',32,0,5,6,000)
          write (iout,1013) auc_type(iauctype)(1:lauc_type(iauctype))
          lastframeinp=0
          if (iauctype .gt. 2) then
            call getint('Frame number to pad the tracks to',33,mxframes,1,
         -    mxframes,lastframeinp,000)
            write (iout,1014) lastframeinp
          end if
          if (iauctype .gt. 3) then
            write (6,1015)
            call getint(
         -    'Length of the off stretch to shift to zero padding',50,
         -    mxframes,1,mxframes,loffmin,000)
            if (loffmin .lt. mxframes) write (iout,1016) loffmin
            if (iauctype .eq. 4) then
              call getint('Maximum number of frames to reuse',33,nframe,
         -      1,nframe,nreusemax,000)
              if (nreusemax .lt. nframe) write (iout,1017) nreusemax
              call getint(
         -      'Number of segments to scramble before reusing a track',
         -      53,0,1,100,nseg_scr,000)
              if (nseg_scr .gt. 0) write (iout,1012) nseg_scr
            end if
          end if
          call askyn(
         -  'Do you want to write the full autocorrelation function file',
         -  55,1,-1,iaucw,0,0)
          write (iout,1011) label(1:llabel)
          if (iuselaston .eq. 1) write (iout,1000)
          if (iuselaston .eq. 0) write (iout,1001)
          write (iout,1002)
          if (iframeunit .eq. 1) then
            write (iout,1010) nframe
            if (iaucw .eq. 1) write (iout,1004) max0(1,nframe/20)
          else
            write (iout,1008) nframe*framefac,
         -    frunit(iframeunit)(1:lfrunit(iframeunit))
            if (iaucw .eq. 1) write (iout,1009) 10*framefac,
         -    frunit(iframeunit)(1:lfrunit(iframeunit)),
         -    max0(1,nframe/20)*framefac,
         -    frunit(iframeunit)(1:lfrunit(iframeunit))
          end if
          return
    1000  format(' Ltrack: #of frames between first on to the last on')
    1001  format(' Ltrack: #of frames between first on to the last frame')
    1002  format(' Non: # frames the bond was on; Nbreak: Number of breaks',
         -  /,' <Lon>,<Loff>: Average length of a contiguous on and ',
         -  'off track, resp.',/,' Lon(max),Loff(max): longest contiguous ',
         -  'on and off track, resp.',/,' %break: ',
         -  '100*(Ltrack-Non)/Ltrack')
    1004  format(' AUC(1-10): Autocorrelation for the first 10 frames',
         -  /,' AUC(incr): Autocorrelation at ',i6,' frame intervals')
    1008  format(' Length of the trajectory analyzed=',f10.2,1x,a)
    1009  format(' AUC(1-10): Bond autocorrelation for the first',f8.2,1x,a,
         -  /,' AUC(incr): Bond autocorrelation at',f8.2,1x,a,' intervals')
    1010  format(' Number of frames analyzed=',i5)
    1011  format(/,' === ',a,' autocorrelation results')
    1012  format(' Reused tracks will be scrambled in ',i4,' segments')
    1013  format(1x,a)
    1014  format(' Tracks will be extended until frame number ',i6)
    1015  format(' If the trajectory ended well before the last frame then',
         -  ' 0 padding will be used')
    1016  format(' If the end of the trajectory contains an all 0 stretch ',
         -  'longer than',i7,' than',/,' the padding will switch to 0s')
    1017  format(' Reused tracks will be limited to the last',i6,' frames ',
         -  'of each track')
          end
          subroutine bonddescr(ib,ihbpair,line,index,iresno,isegno,
         -  inamcol1,inamcol2,irescol1,irescol2,bond,lbond,bondlab,
         -  lbondlab,nbb,ianc_anc,isc,ia1,ia2,ir1,ir2,maxrec,maxbonds)
          dimension ihbpair(2,maxbonds),index(maxrec),iresno(maxrec),
         -  isegno(maxrec),ianc_anc(maxbonds),isc(maxrec)
          character*132 line(maxrec)
          character*(*) bondlab
          character*2 sc_lab(2,2)
          character*(*) bond
          data sc_lab /'BB','SB','BS','SS'/
          ia1=ihbpair(1,ib)
          ia2=ihbpair(2,ib)
          ir1=iresno(ia1)
          ir2=iresno(ia2)
          write (bond,1000)
         -    line(index(ia1))(inamcol1:inamcol2),ia1,
         -    line(index(ia1))(irescol1:irescol2),ir1,isegno(ia1),
         -    line(index(ia2))(inamcol1:inamcol2),ia2,
         -    line(index(ia2))(irescol1:irescol2),ir2,isegno(ia2)
          lbond=2*(inamcol2-inamcol1+irescol2-irescol1+2)+38
          lbondlab=1
          bondlab=' '
          if (nbb .gt. 0) then
            bondlab(lbondlab+1:lbondlab+3)=
         -    sc_lab(isc(ihbpair(1,ib))+1,isc(ihbpair(2,ib))+1)
              lbondlab=lbondlab+2
            end if
            if (ianc_anc(ib) .eq. 1) then
              bondlab(lbondlab+1:lbondlab+3)=' AA'
              lbondlab=lbondlab+3
            end if
          return
    1000  format(1x,a,i6,1x,a,i4,' C/S',i2,' - ',a,i6,1x,a,i4,' C/S',i2)
          end
          subroutine persistence(nhbdist,nhbpers,itf,itl,maxlenon,
         -  maxlenoff,iframeunit,framefac,nframe,iuselaston,iout)
          character*6 frunit
          common /frameunit/ lfrunit(4),frunit(4)
          if (iuselaston .eq. 1) lentrack=itl-itf+1
          if (iuselaston .eq. 0) lentrack=nframe-itf+1
          rlenb=float(nhbdist)/float(nhbpers+1)
          rlenoff=float(lentrack-nhbdist)/float(nhbpers)
          percbreak=100.0*float(lentrack-nhbdist)/float(lentrack)
          write (iout,1003) nhbpers,percbreak,lentrack,nhbdist,itf,itl
          write (iout,1005) rlenb,rlenoff,maxlenon,maxlenoff,frunit(1)
          if (iframeunit .eq. 2) write (iout,1007) rlenb*framefac,
         -  rlenoff*framefac,maxlenon*framefac,maxlenoff*framefac,
         -  frunit(iframeunit)(1:lfrunit(iframeunit))
          if (iframeunit .gt. 2) write (iout,1006) rlenb*framefac,
         -  rlenoff*framefac,maxlenon*framefac,maxlenoff*framefac,
         -  frunit(iframeunit)(1:lfrunit(iframeunit))
          return
    1003  format('   Nbreak=',i5,' %off=',f5.1,' Ltrack=',i5,' Non=',i5,
         -  ' First on=',i5,' Last on=',i5)
    1005  format(' <Lon>=',f9.1,' <Loff>=',f9.1,' Lon(max)=',i9,
         -  ' Loff(max)=',i9,1x,a)
    1006  format(' <Lon>=',f9.4,' <Loff>=',f9.4,' Lon(max)=',f9.4,
         -  ' Loff(max)=',f9.4,1x,a)
    1007  format(' <Lon>=',f9.2,' <Loff>=',f9.2,' Lon(max)=',f9.2,
         -  ' Loff(max)=',f9.2,1x,a)
          end
          subroutine printbondlist(iangpr,itorpr,n1,n2,nstta,cslt,nneig,
         -  ineig,line,inamcol1,inamcol2,irescol1,irescol2,iresncol1,
         -  iresncol2,index,cv,ichiral,maxneig,radtodeg,iout,maxrec)
          character* 132 line(maxrec)
          dimension cslt(3,nstta),nneig(nstta),ineig(maxneig,nstta),
         -  index(nstta),cv(nstta),ichiral(nstta)
          character*8 lab
          data lab /' CHIRAL '/
          dimension ang(28),iang(2,28)
          do ia=n1,n2
            if (nneig(ia) .ne. 1) then
              do in=1,nneig(ia)
                cv(in)=sqrt(dist2(cslt(1,ia),cslt(1,ineig(in,ia))))
                if (cv(in) .lt. 0.1) then
                  write (iout,2265) ineig(in,ia)
                end if
              end do
              llab=1
              if (ichiral(ia) .gt. 0) llab=8
              write (iout,2148) ia,line(index(ia))(inamcol1:inamcol2),
         -      line(index(ia))(iresncol1:iresncol2),
         -      line(index(ia))(irescol1:irescol2),lab(1:llab),nneig(ia)
              write (iout,2149) (ineig(in,ia),
         -      line(index(ineig(in,ia)))(inamcol1:inamcol2),
         -      line(index(ineig(in,ia)))(irescol1:irescol2),
         -      line(index(ineig(in,ia)))(iresncol1:iresncol2),cv(in),
         -      in=1,nneig(ia))
              if (iangpr .eq. 1 .and. nneig(ia) .ge. 2) then
                nnlim=min0(8,nneig(ia))
                nang=0
                do in1=1,nnlim
                  do in2=in1+1,nnlim
                    nang=nang+1
                    ang(nang)=radtodeg*angleijk(cslt,nstta,ineig(in1,ia),ia,
         -            ineig(in2,ia),iout)
                    iang(1,nang)=ineig(in1,ia)
                    iang(2,nang)=ineig(in2,ia)
                  end do
                end do
                write (iout,2142) (iang(1,i),ia,iang(2,i),ang(i),i=1,nang)
              end if
              if (itorpr .eq. 1) then
                do in=1,nneig(ia)
                  inj=ineig(in,ia)
                  if (inj .gt. in) then
                    nnlim1=min0(8,nneig(ia))
                    nnlim2=min0(8,nneig(inj))
                    nang=0
                    do in1=1,nnlim1
                      inn1=ineig(in1,ia)
                      if (inn1 .ne. inj) then
                        do in2=in1+1,nnlim2
                          inn2=ineig(in2,inj)
                          if (inn2 .ne. ia) then
                            nang=nang+1
                            ang(nang)=dihangl(cslt,inn1,ia,inj,inn2,0,
         -                    maxrec)
                            iang(1,nang)=inn1
                            iang(2,nang)=inn2
                          end if
                        end do
                      end if
                    end do
                    write (iout,2182) (' ',iang(1,i),ia,inj,iang(2,i),
         -            radtodeg*ang(i),i=1,nang)
                  end if
                end do
              end if
            end if
          end do
          return
    2142  format(2('  Angle(',i5,'-',i5,'-',i5,')=',f8.3,' deg'))
    2148  format(i6,' (',a,1x,a,1x,a,')',a,'-',i3,' neighbours:')
    2149  format((7x,2(i5,' (',a,1x,a,1x,a,') r=',f6.4,' A')))
    2182  format(2(a,' Torsion(',i5,'-',i5,'-',i5,'-',i5,')=',f7.2,' deg'))
    2265  format(' ----- WARNING: unphysically short bond with atom',i7)
          end
          subroutine findfg(n0,n,ian,nfgmem,ifgstr,ifgaix,indxfg,
         -  ixfg,ifgtyp,itypfg,nfg,iout,nneig,nneigh,nneiga,ineig,iwfg,
         -  inpcrdtyp,ioins,ic1,ic2,ir1,ir2,irn1,irn2,line,index,maxng,
         -  maxrec)
          dimension nneig(n),ineig(maxng,n),nneigh(n),nneiga(n),
         -  ian(n),nfgmem(n),ifgstr(n),ifgaix(n),ixfg(n),
         -  indxfg(n),ifgtyp(n),itypfg(n),index(n)
          character* 132 line(maxrec)
          character*2 iatnm2
          common /atnam/ aw(99),nval(99),nvalmax(99),mmofan(99),
         -  mmatno(64),iatnm2(99)
          character*1 sp
          character*4 namfcg
          common /connatdat/ ramax(99),ramax2(99),hlimfac,ianfg(99),
         -  namfcg(100),nrmw
          dimension in12(2)
          data sp /' '/,ityp /0/
          nfg=0
          nverr=0
          call zeroiti(itypfg,n0-1,n)
          nverr=0
          do i=n0,n
            if (nneiga(i) .gt. nval(ian(i)) .and. nval(ian(i)) .gt. 0) then
              if (inpcrdtyp .le. ioins) then
                write (iout,1001)
         -        i,line(index(i))(ic1:ic2),line(index(i))(ir1:ir2),
         -        line(index(i))(irn1:irn2),ian(i),nneiga(i),
         -        (ineig(j,i),line(index(ineig(j,i)))(ic1:ic2),
         -        line(index(ineig(j,i)))(ir1:ir2),
         -        line(index(ineig(j,i)))(irn1:irn2),j=1,nneiga(i))
              else
                write (iout,1002) i,ian(i),nneiga(i),
         -      (ineig(j,i),j=1,nneiga(i))
              end if
              itypfg(i)=100
              nfg=nfg+1
              indxfg(i)=nfg
              nverr=nverr+1
            end if
          end do
          if (nverr .gt. 0) then
            call askyn('Do you want to break any bond',29,1,1,ibreak,0,0)
            if (ibreak .gt. 0) then
              do while (.true.)
                call getintline(
         -        'Atomindices of the bond to be broken (0,0 to quit)',50,
         -        1,n,in12,2,00)
                if (in12(1) .eq. 0 .and. in12(2) .eq. 0) go to  100
                call breakbond(in12(1),in12(2),n0,n,nneig,ineig,nneiga,
         -        nneigh,ian,ifail,maxng)
                call breakbond(in12(2),in12(1),n0,n,nneig,ineig,nneiga,
         -        nneigh,ian,ifail,maxng)
              end do
            end if
          end if
    100   do i=n0,n
            if (ian(i) .eq. 8 .and. itypfg(i) .eq. 0 .and.
         -       nneiga(i) .gt. 0) then
              if (nneiga(i) .eq. 1 .and. ian(ineig(1,i)) .eq. 6) then
                inn1=ineig(1,i)
                nnn1=nneiga(inn1)
                noxy=0
                do j=1,nnn1
                  if (ian(ineig(j,inn1)) .eq. 8 .and.
         -          nneiga(ineig(j,inn1)) .eq. 1) noxy=noxy+1
                end do
                if (noxy .eq. 2) then
                  nfg=nfg+1
                  indxfg(inn1)=nfg
                  itypfg(inn1)=27
                  do j=1,nnn1
                    in=ineig(j,inn1)
                    if (ian(in) .eq. 8 .and. nneiga(in) .eq. 1 .and.
         -              itypfg(in) .eq. 0) then
                      indxfg(in)=nfg
                      itypfg(in)=27
                    end if
                  end do
                else
                  nfg=nfg+1
                  indxfg(i)=nfg
                  indxfg(inn1)=nfg
                  itypfg(i)=17
                  itypfg(inn1)=17
                end if
              else if (nneiga(i) .eq. 2 .and. nneigh(i) .eq. 0) then
                nfg=nfg+1
                indxfg(i)=nfg
                if (ian(ineig(1,i)) .ne. 15 .and. ian(ineig(2,i)) .ne. 15)
         -        itypfg(i)=19
                if (ian(ineig(1,i)) .eq. 15 .or. ian(ineig(2,i)) .eq. 15)
         -        itypfg(i)=20
              else if (nneiga(i) .eq. 2 .and. nneigh(i) .eq. 1) then
                nfg=nfg+1
                indxfg(i)=nfg
                itypfg(i)=21
                nn=nneiga(i)
                do j=1,nn
                  in=ineig(j,i)
                  if (ian(in) .eq. 1 .and. itypfg(in) .eq. 0) then
                    indxfg(ineig(j,i))=nfg
                    itypfg(ineig(j,i))=21
                  end if
                end do
              end if
            else if (ian(i) .eq. 15 .and. itypfg(i) .eq. 0) then
              nfg=nfg+1
              indxfg(i)=nfg
              itypfg(i)=22
              iong=0
              nn=nneiga(i)
              do j=1,nn
                in=ineig(j,i)
                if (ian(in) .eq. 8 .and. itypfg(in) .eq. 0 .and.
         -        nneiga(in) .eq. 1) then
                  iong=iong+1
                  indxfg(in)=nfg
                  itypfg(in)=22
                end if
              end do
              if (iong .ne. 2) write (iout,1000) i,iong
            end if
          end do
          do i=n0,n
            if (ian(i) .eq. 6 .and. itypfg(i) .eq. 0) then
              nfg=nfg+1
              ityp=(10-(nneiga(i)*(nneiga(i)+1))/2)+nneigh(i)+1
              if (ityp .lt. 0) ityp=99
              indxfg(i)=nfg
              itypfg(i)=ityp
              nn=nneiga(i)
              if (nn .gt. 0) then
                do j=1,nn
                  in=ineig(j,i)
                  if (ian(in) .eq. 1 .and. itypfg(in) .eq. 0) then
                    indxfg(in)=nfg
                    itypfg(in)=ityp
                  end if
                end do
              end if
            else if (ian(i) .eq. 7 .and. itypfg(i) .eq. 0) then
              nfg=nfg+1
              if (nneiga(i) .lt. 4)
         -      ityp=(6-(nneiga(i)*(nneiga(i)+1))/2)+nneigh(i)+11
              if (nneiga(i) .eq. 4) ityp=23+nneigh(i)
              indxfg(i)=nfg
              itypfg(i)=ityp
              nn=nneiga(i)
              if (nn .gt. 0) then
                do j=1,nn
                  in=ineig(j,i)
                  if (ian(in) .eq. 1 .and. itypfg(in) .eq. 0) then
                    indxfg(in)=nfg
                    itypfg(in)=ityp
                  end if
                end do
              end if
            end if
          end do
          do i=n0,n
            if (itypfg(i) .eq. 0 .and. nneiga(i) .gt. 0) then
              if (ian(i) .eq. 1 .and. itypfg(ineig(1,i)) .eq. 17) then
                nfg=nfg+1
                indxfg(i)=nfg
                itypfg(i)=18
              end if
            end if
          end do
          do i=n0,n
            if (itypfg(i) .eq. 0 .and. ian(i) .eq. 16) then
              if (nneiga(i) .eq. 2) then
                if (nneigh(i) .gt. 0) then
                  itp=29
                  nfg=nfg+1
                  indxfg(i)=nfg
                  itypfg(i)=itp
                  do ing=1,2
                    in=ineig(ing,i)
                    if (ian(in) .eq. 1 .and. itypfg(in) .eq. 0) then
                      indxfg(in)=nfg
                      itypfg(in)=itp
                    end if
                  end do
                else
                  nfg=nfg+1
                  indxfg(i)=nfg
                  itypfg(i)=28
                end if
              end if
            end if
          end do
          do i=n0,n
            if (itypfg(i) .eq. 0) then
              ianfgi=ianfg(ian(i))
              if (ianfgi .gt. 0) then
                if (nneiga(i) .eq. 0) ianfgi=ianfgi+1
                nfg=nfg+1
                indxfg(i)=nfg
                itypfg(i)=ianfgi
              end if
            end if
          end do
          do i=n0,n
            if (itypfg(i) .eq. 0) then
              nfg=nfg+1
              indxfg(i)=nfg
              itypfg(i)=99
            end if
          end do
          nmem=0
          do if=1,nfg
            ifgstr(if)=nmem+1
            do ia=n0,n
              if (indxfg(ia) .eq. if) then
                nmem=nmem+1
                ifgaix(nmem)=ia
              end if
              nfgmem(if)=nmem-ifgstr(if)+1
            end do
            ifgtyp(if)=itypfg(ifgaix(ifgstr(if)))
          end do
          nfgn=0
          do it=1,100
            do if=1,nfg
              if (ifgtyp(if) .eq. it) then
                nfgn=nfgn+1
                ixfg(nfgn)=if
              end if
            end do
          end do
          if (iwfg .gt. 0) then
            do igg=1,nfg
              ig=ixfg(igg)
              ig1=ifgstr(ig)
              ig2=ig1+nfgmem(ig)-1
              do iat=ig1,ig2
                iaa=ifgaix(iat)
                nna=nneig(iaa)
                if (inpcrdtyp .le. ioins) then
                  write (iwfg,2045) igg,namfcg(ifgtyp(ig)),
         -          iaa,line(index(iaa))(ic1:ic2),
         -          line(index(iaa))(ir1:ir2),
         -          line(index(iaa))(irn1:irn2),(ineig(in,iaa),
         -          line(index(ineig(in,iaa)))(ic1:ic2),
         -          line(index(ineig(in,iaa)))(ir1:ir2),
         -          line(index(ineig(in,iaa)))(irn1:irn2),in=1,nna)
                else
                  write (iwfg,2044) igg,namfcg(ifgtyp(ig)),
         -          iaa,iatnm2(ian(iaa)),(sp,ineig(in,iaa),
         -          iatnm2(ian(ineig(in,iaa))),in=1,nna)
                end if
              end do
            end do
          end if
          return
    1000  format(' ERROR: phosporus(',i4,') has',i2,' oxygens')
    1001  format(' ERROR: atom',i6,' (',a,1x,a,1x,a,' atomic no=',i2,')',
         -    ' has',i3,' neighbours: ',/,3(i6,' (',a,1x,a,1x,a,') '))
    1002  format(' ERROR: atom',i6,', atomic no=',i2,
         -    ' has',i3,' neighbours: ',(10i6))
    2044  format(' Fg',i6,2x,a4,' (',i5,1x,a2,')',' neighbours:',a1,
         -  '(',i5,1x,a2,')',a1,'(',i5,1x,a2,')',a1,'(',i5,1x,a2,')',a1,
         -  /,(5x,5('(',i5,1x,a2,')',a1)))
    2045  format(' Fg',i6,2x,a4,' (',i5,1x,a4,1x,a4,1x,a,') Neigbours:',/,
         -  (9x,3('(',i5,1x,a4,1x,a4,1x,a,') ')))
          end
          subroutine breakbond(i1,i2,n0,n,nneig,ineig,nneiga,nneigh,ian,
         -  ifail,maxng)
          dimension nneig(n),ineig(maxng,n),nneiga(n),nneigh(n),ian(n)
          ifail=0
          if (i1 .lt. n0 .or. i1 .gt. n .or.
         -    i2 .lt. n0 .or. i2 .gt. n) then
            print *,'ERROR: invalid atomindices: ',i1,i2
            ifail=1
            return
          end if
          idel=0
          do in=1,nneiga(i1)
            if (ineig(in,i1) .eq. i2) idel=in
          end do
          if (idel .eq. 0) then
            write (6,1000) i2,i1
            ifail=1
          else
            if (ian(ineig(idel,i1)) .eq. 1) nneigh(i1)=nneigh(i1)-1
            do in=idel+1,nneig(i1)
              ineig(in-1,i1)=ineig(in,i1)
            end do
            nneig(i1)=nneig(i1)-1
            nneiga(i1)=nneiga(i1)-1
          end if
          return
    1000  format(' ERROR: atom ',i5,' is not on the neighbour list of atom',
         -  i6)
          end
          subroutine breakbond0(i1,i2,n,nneig,ineig,ifail,maxng)
          dimension nneig(n),ineig(maxng,n)
          ifail=0
          if (i1 .lt. 1 .or. i1 .gt. n .or.
         -    i2 .lt. 1 .or. i2 .gt. n) then
            print *,'ERROR: invalid atomindices: ',i1,i2
            ifail=1
            return
          end if
          idel=0
          do in=1,nneig(i1)
            if (ineig(in,i1) .eq. i2) idel=in
          end do
          if (idel .eq. 0) then
            write (6,1000) i2,i1
            ifail=1
          else
            do in=idel+1,nneig(i1)
              ineig(in-1,i1)=ineig(in,i1)
            end do
            nneig(i1)=nneig(i1)-1
          end if
          idel=0
          do in=1,nneig(i2)
            if (ineig(in,i2) .eq. i1) idel=in
          end do
          if (idel .eq. 0) then
            write (6,1000) i1,i2
            ifail=1
          else
            do in=idel+1,nneig(i2)
              ineig(in-1,i2)=ineig(in,i2)
            end do
            nneig(i2)=nneig(i2)-1
          end if
          return
    1000  format(' ERROR: atom ',i5,' is not on the neighbour list of atom',
         -  i6)
          end
          subroutine bondord(iatnum,mmtype,nattot,nneig,ineig,nhneig,ibnd,
         -  maxneig,c,index,nntemp,nvalx,inc1,inc2,irc1,irc2,line,nconfig,
         -  maxrepconf,maxrec)
          dimension c(3,nattot),iatnum(nattot),mmtype(nattot),nneig(nattot),
         -  ineig(maxneig,nattot),nhneig(nattot),ibnd(maxneig,nattot),
         -  index(nattot),nntemp(nattot),nvalx(nattot)
          character* 132 line(maxrec)
          character*2 iatnm2
          common /atnam/ aw(99),nval(99),nvalmax(99),mmofan(99),
         -  mmatno(64),iatnm2(99)
          character*4 dbonds(3,100),dbres(100),thisres,thisresl,
         -  atnaml,atnam1l
          character*8 resnam
          dimension ifres(100),ilres(100)
          real*8 cosa
          data jmin /0/
          data dbonds /'TYR ','CG  ','CD1 ','TYR ','CE1 ','CZ  ',
         -  'TYR ','CE2 ','CD2 ','PHE ','CG  ','CD1 ',
         -  'PHE ','CE1 ','CZ  ','PHE ','CE2 ','CD2 ',
         -  'HSD ','CG  ','CD2 ',
         -  'TRP ','CG  ','CD1 ','TRP ','CD2 ','CE2 ',
         -  'TRP ','CZ2 ','CH2 ','TRP ','CZ3 ','CE3 ',
         -  'ADE ','C4  ','C5  ','GUA ','C4  ','C5  ',
         -  'CYT ','C5  ','C6  ','THY ','C5  ','C6  ',
         -  'URA ','C5  ','C6  ',
         -  252*'    '/,resnam /'     '/
          thisres='****'
          ndres=0
          do i=1,100
            if (thisres .ne. dbonds(1,i)) then
              thisres=dbonds(1,i)
              ndres=ndres+1
              dbres(ndres)=thisres
              ifres(ndres)=i
              if (ndres .gt. 1) ilres(ndres-1)=i-1
            end if
          end do
          ndres=ndres-1
          if (nconfig .eq. 1) then
            print  *,'Built in double bond list:'
            do i=1,ndres
              write (6,1101) i,dbres(i),
         -      (dbonds(2,j),dbonds(3,j),j=ifres(i),ilres(i))
            end do
          end if
          ncgeneric=0
          do i=1,nattot
            mmtype(i)=0
            if (iatnum(i) .eq. 6 .or. iatnum(i) .eq. 7) then
              if (nneig(i) .eq. 4 .or.
         -        (iatnum(i) .eq. 7 .and. nneig(i) .eq. 3)) then
                mmtype(i)=3
              else if (nneig(i) .gt. 1) then
                angav=0
                do in=1,nneig(i)
                  d1s=0.0
                  d2s=0.0
                  d12s=0.0
                  in1=in+1
                  if (in1 .gt. nneig(i)) in1=1
                  do k=1,3
                    dx1=c(k,ineig(in,i))-c(k,i)
                    dx2=c(k,ineig(in1,i))-c(k,i)
                    d1s=d1s+dx1*dx1
                    d2s=d2s+dx2*dx2
                    d12s=d12s+dx1*dx2
                  end do
                  cosa=dble(d12s)/sqrt(d1s*d2s)
                  ang=(180.0/3.141592)*dacoscheck(cosa,ccc,1,6,'BONDORD')
                  angav=angav+ang
                end do
                angav=angav/nneig(i)
                if (angav .gt. 150.0) then
                  mmtype(i)=1
                else if (angav .gt. 117.0) then
                  mmtype(i)=2
                else
                  mmtype(i)=3
                end if
              else if (nneig(i) .gt. 0) then
                if (iatnum(ineig(1,i)) .eq. 16) then
                  mmtype(i)=6
                else
                  mmtype(i)=14
                  ncgeneric=ncgeneric+1
                end if
              end if
            end if
          end do
          do i=1,nattot
            if (nneig(i) .eq. 1 .and.
         -    (iatnum(i) .eq. 6 .or. iatnum(i) .eq. 7)) then
              if (mmtype(ineig(1,i)) .eq. 1 .or.
         -        mmtype(ineig(1,i)) .eq. 2) then
                if (iatnum(i) .eq. 6) mmtype(i)=2
                if (iatnum(i) .eq. 7) mmtype(i)=1
              end if
              if (mmtype(ineig(1,i)) .eq. 3) mmtype(i)=3
            end if
          end do
          do i=1,nattot
            if (nval(iatnum(i)) .le. 0)
         -    write (6,2005) i,iatnum(i),nval(iatnum(i))
            nvalx(i)=nval(iatnum(i))-nneig(i)
            if (nvalx(i) .lt. 0) then
              if (nvalx(i)+(nvalmax(iatnum(i))-nval(iatnum(i))) .lt. 0 .and.
         -        nconfig .lt. maxrepconf) write (6,2001) i,line(index(i))
         -        (inc1:inc2),nneig(i),nval(iatnum(i)),iatnum(i)
              nvalx(i)=0
            else if (iatnum(i) .eq. 6 .and. nneig(i) .gt. 1 .and.
         -    nneig(i) .lt. 4 .and. nhneig(i) .eq. 0) then
              if (nneig(i) .eq. 3) then
                if (mmtype(i) .eq. 3) nvalx(i)=nvalx(i)-1
              else if (nneig(i) .eq. 2) then
                if (mmtype(i) .eq. 2) nvalx(i)=nvalx(i)-1
                if (mmtype(i) .eq. 3) nvalx(i)=nvalx(i)-2
              end if
            end if
          end do
          do i=1,nattot
            if (iatnum(i) .eq. 6 .and. nneig(i) .eq. 1) then
              if (mmtype(ineig(1,i)) .eq. 1 .or.
         -        mmtype(ineig(1,i)) .eq. 2) nvalx(i)=nvalx(i)-2
              if (mmtype(ineig(1,i)) .eq. 3) nvalx(i)=nvalx(i)-3
            end if
          end do
          do i=1,nattot
            nntemp(i)=nneig(i)
            do j=1,nneig(i)
              ibnd(j,i)=1
            end do
          end do
          thisres='****'
          do i=1,nattot
            resnam='        '
            resnam=line(index(i))(irc1:irc2)
            imod=0
            if (resnam(1:4) .ne. thisres) then
              thisres=resnam(1:4)
              call leftadjust4(thisres,thisresl)
              if (thisresl(1:2)  .eq. 'HS') thisresl='HSD '
              do ir=1,ndres
                if (thisresl .eq. dbres(ir)) then
                  imod=ir
                  go to 1100
                end if
              end do
            end if
    1100    if (imod .gt. 0) then
              call leftadjust4(line(index(i))(inc1:inc2),atnaml)
              do irl=ifres(imod),ilres(imod)
                if (atnaml .eq. dbonds(2,irl)) then
                  do j=1,nneig(i)
                    in1=ineig(j,i)
                    call leftadjust4(line(index(in1))(inc1:inc2),atnam1l)
                    if (atnam1l .eq. dbonds(3,irl)) then
                      ibnd(j,i)=ibnd(j,i)+1
                      nvalx(i)=nvalx(i)-1
                      do jj=1,nneig(in1)
                        if (ineig(jj,in1) .eq. i) then
                          ibnd(jj,in1)=ibnd(jj,in1)+1
                          nvalx(in1)=nvalx(in1)-1
                          go to 1200
                        end if
                      end do
                      print *,'Cant add reverse bond i,in1=',i,in1
                    end if
                  end do
                end if
              end do
            end if
    1200    continue
          end do
          if (nconfig .eq. 1) write (6,2002)
          naddtot=0
          nvalerr=0
    300   nadd=0
          do i=1,nattot
            if (nntemp(i) .eq. 1) then
              ii=i
    200       in1=ineig(1,ii)
              nn1=nntemp(in1)
              do j=1,nn1
                if (ineig(j,in1) .eq. ii) jn1=j
              end do
              if (nvalx(ii) .gt. 0 .and. nvalx(in1) .gt. 0) then
                ndel=min0(nvalx(ii),nvalx(in1))
                nadd=nadd+ndel
                nvalx(ii)=nvalx(ii)-ndel
                nvalx(in1)=nvalx(in1)-ndel
                ibnd(1,ii)=ibnd(1,ii)+ndel
                ibnd(jn1,in1)=ibnd(jn1,in1)+ndel
                if (nvalx(ii) .gt. 0) then
                  nvalx(ii)=-nvalx(ii)
                  nvalerr=nvalerr+1
                end if
                call swapng(ineig,ibnd,in1,jn1,nn1,nattot,maxneig)
                nntemp(ii)=0
                nntemp(in1)=nntemp(in1)-1
                if (nntemp(in1) .eq. 1) then
                  ii=in1
                  go to 200
                end if
              end if
            end if
          end do
          naddtot=naddtot+nadd
          if (nadd .gt. 0) go to 300
          if (naddtot .gt. 0 .and. nconfig .le. maxrepconf)
         -   print *,naddtot,' tree bond orders added'
          nadd=0
          do 310 i=1,nattot
            if (nvalx(i) .gt. 0) then
              nn=nneig(i)
              ibomin=1000
              do j=1,nn
                if (nvalx(ineig(j,i)) .gt. 0 .and. ibomin .gt.
         -          ibnd(j,i)) then
                  ibomin=ibnd(j,i)
                  jmin=j
                end if
              end do
              if (ibomin .lt. 1000) then
                nadd=nadd+1
                ibnd(jmin,i)=ibnd(jmin,i)+1
                jn=ineig(jmin,i)
                nnj=nneig(jn)
                do k=1,nnj
                  if (ineig(k,jn) .eq. i) ibnd(k,jn)=ibnd(k,jn)+1
                end do
                nvalx(i)=nvalx(i)-1
                nvalx(jn)=nvalx(jn)-1
                if (nvalx(i) .eq. 0) go to 310
              end if
            end if
    310   continue
          if (nadd .gt. 0 .and. nconfig .le. maxrepconf)
         -  print *,nadd,' loop bond orders added'
          nadd=0
          do i=1,nattot
            if (nvalmax(iatnum(i)) .gt. nval(iatnum(i))) then
              if (nneig(i) .lt. nvalmax(iatnum(i))) then
                ibosum=0
                do in=1,nneig(i)
                  ibosum=ibosum+ibnd(in,i)
                end do
                if (nvalx(i) .ge. 0) nvalx(i)=nvalmax(iatnum(i))-ibosum
                if (ibosum .lt. nvalmax(iatnum(i))) then
                  do in=1,nneig(i)
                    i1=ineig(in,i)
                    if (nvalx(i1) .gt. 0) then
                      ibnd(in,i)=ibnd(in,i)+1
                      do in1=1,nneig(i1)
                        if (ineig(in1,i1) .eq. i)
         -                ibnd(in1,i1)=ibnd(in1,i1)+1
                      end do
                      nvalx(i1)=nvalx(i1)-1
                      if (nvalx(i) .gt. 0) nvalx(i)=nvalx(i)-1
                      nadd=nadd+1
                    end if
                  end do
                end if
              end if
            end if
          end do
          if (nadd .gt. 0) print *,nadd,' N+ type bond orders added'
          nswap=0
    400   nvxe=0
          do i=1,nattot
            if (nvalx(i) .gt. nvalmax(iatnum(i))-nval(iatnum(i))) then
              nvxe=nvxe+1
            end if
          end do
          if (nvxe .gt. 0) then
            nadd=0
            do i=1,nattot
              if (nvalx(i) .gt. 0 .and. iatnum(i) .ne. 7) then
                do in=1,nntemp(i)
                  i1=ineig(in,i)
                  do in1=1,nntemp(i1)
                    i2=ineig(in1,i1)
                    if (ibnd(in1,i1) .gt. 1 .and. i2 .ne. i) then
                      do in2=1,nntemp(i2)
                        i3=ineig(in2,i2)
                        if (i3 .ne. i1 .and. nvalx(i3) .gt. 0) then
                          call swapng(ineig,ibnd,i2,in2,nntemp(i2),nattot,
         -                  maxneig)
                          do in3=1,nntemp(i3)
                            if (ineig(in3,i3) .eq. i2) call
         -                    swapng(ineig,ibnd,i3,in3,nntemp(i3),nattot,
         -                      maxneig)
                          end do
                          ibnd(nntemp(i3),i3)=ibnd(nntemp(i3),i3)+1
                          nvalx(i3)=nvalx(i3)-1
                          nntemp(i3)=nntemp(i3)-1
                          call swapng(ineig,ibnd,i,in1,nntemp(i),nattot,
         -                  maxneig)
                          do in21=1,nntemp(i1)
                            if (ineig(in21,i1) .eq. i) call
         -                    swapng(ineig,ibnd,i,in21,nntemp(i1),nattot,
         -                  maxneig)
                          end do
                          ibnd(nntemp(i),i)=ibnd(nntemp(i),i)+1
                          nvalx(i)=nvalx(i)-1
                          nntemp(i)=nntemp(i)-1
                          nadd=nadd+1
                          go to 410
                        end if
                      end do
                    end if
                  end do
                end do
              end if
    410       continue
            end do
            nswap=nswap+nadd
            if (nadd .gt. 0) go to 400
          end if
          if (nswap .gt. 0) print *,nswap,' bond orders added by swapping'
          nvxe=0
          do i=1,nattot
            if (nvalx(i) .gt. nvalmax(iatnum(i))-nval(iatnum(i))) then
              nvxe=nvxe+1
            end if
          end do
          if (nconfig .lt. maxrepconf) write (6,2000) nvxe
          do i=1,nattot
            if (iatnum(i) .eq. 6) then
              nunsatur=mmtype(i)+1-nneig(i)
              if (nunsatur .gt. 0) then
                if (mmtype(i) .eq. 3) mmtype(i)=3+nunsatur
                if (mmtype(i) .eq. 2) mmtype(i)=6+nunsatur
                if (mmtype(i) .eq. 1) mmtype(i)=9+nunsatur
              end if
            else if (iatnum(i) .eq. 7) then
              if (mmtype(i) .eq. 3) then
                if (nneig(i) .eq. 4) then
                  mmtype(i)=32
                else if (nneig(i) .eq. 3) then
                  mmtype(i)=26
                else if (nneig(i) .eq. 2) then
                  mmtype(i)=27
                else if (nneig(i) .eq. 1) then
                  mmtype(i)=28
                end if
              else if (mmtype(i) .eq. 2) then
                if (nneig(i) .eq. 3) then
                  mmtype(i)=31
                else if (nneig(i) .eq. 2) then
                  mmtype(i)=25
                else if (nneig(i) .eq. 1) then
                  mmtype(i)=30
                end if
              else if (mmtype(i) .eq. 1) then
                mmtype(i)=24
              end if
            else if (iatnum(i) .eq. 8) then
              if (nneig(i) .eq. 1 .and. ibnd(1,i) .eq. 2) then
                mmtype(i)=15
              else
                mmtype(i)=mmofan(iatnum(i))
              end if
            else if (iatnum(i) .eq. 1) then
              if (nneig(i) .lt. 1) then
                write (6,2003) i
                mmtype(i)=mmofan(iatnum(i))
              else
                if (iatnum(ineig(1,i)) .eq. 8) then
                  mmtype(i)=42
                else if (iatnum(ineig(1,i)) .eq. 7) then
                  mmtype(i)=43
                else if (iatnum(ineig(1,i)) .eq. 6 .or.
         -          iatnum(ineig(1,i)) .eq. 15 .or.
         -          iatnum(ineig(1,i)) .eq. 16) then
                  mmtype(i)=41
                else
                  mmtype(i)=mmofan(iatnum(i))
                end if
              end if
            else
              mmtype(i)=mmofan(iatnum(i))
            end if
          end do
          do i=1,nattot
            if (mmtype(i) .eq.  0) write (6,2004) i,iatnum(i),nneig(i)
          end do
          if (ncgeneric .gt. 0)
         -  print *,'WARNING:',ncgeneric,' carbon types were set to generic'
          return
    1101  format(i4,1x,a4,3x,10(' (',a4,'- ',a4,')'))
    2000  format(' Number of atoms with unsatisfied valence=',i6)
    2001  format(' WARNING: no of neighbours of atom',i5,'(',a4,')=',i2,
         -  ' exceeds valence (',i1,') ',' atno=',i4)
    2002  format(' Bond orders will be determined by a simple algorithm',/,
         -  '   - possibly some multiple bonds will not be recognized',/,
         -  '   - for example, united atoms may not recognized as such')
    2003  format(' WARNING: Hydrogen ',i6,' has no bond')
    2004  format(' ERROR: Atom ',i5,' has no atomtype. ',/,
         -  8x,'Atomic number=',i3,' Number of neighbors=',i3)
    2005  format(' ERROR: Atom ',i5,' atomic number ',i3,' has invalid ',
         -  'valence:',i3)
          end
          subroutine findbackbone(n0,n,iwout,nneig,ineig,
         -  nneiga,ineiga,in1,in2,ir1,ir2,line,blankline,index,iback,
         -  isideback,iparent,list,maxng,maxbox,maxrec)
          dimension nneig(n),nneiga(n),ineig(maxng,n),ineiga(maxbox,n),
         -  index(n),iback(n),isideback(n),iparent(n),list(n)
          character* 132 line(maxrec),blankline,linep
          ifirst=n0
          ilast=0
          ibb=0
          do while (ilast .lt. n)
            write (iwout,1005)
            call growchain(n0,n,0,ifirst,ial,nsteps,nneig,ineig,
         -    list,iparent,iback,ilast,maxng)
            call growchain(n0,n,0,ial,iaf,lbackb,nneig,ineig,
         -    list,iparent,iback,iii,maxng)
            do ia=n0,n
              nneiga(ia)=nneig(ia)
              call trnsfi(ineiga(1,ia),ineig(1,ia),nneig(ia))
            end do
            do ia=1,lbackb
              iba=iback(ia)
              if (ia .gt. 1) then
                do in=1,nneiga(iba)
                  if (ineiga(in,iba) .eq. iback(ia-1)) then
                    ineiga(in,iba)=ineiga(nneiga(iba),iba)
                    nneiga(iba)=nneiga(iba)-1
                    go to 201
                  end if
                end do
              end if
    201       if (ia .lt. lbackb) then
                do in=1,nneiga(iba)
                  if (ineiga(in,iba) .eq. iback(ia+1)) then
                    ineiga(in,iba)=ineiga(nneiga(iba),iba)
                    nneiga(iba)=nneiga(iba)-1
                    go to 202
                  end if
                end do
              end if
    202       continue
            end do
            do ia=1,lbackb
              iba=iback(ia)
              do in=1,nneiga(iba)
                ina=ineiga(in,iba)
                do ja=1,nneiga(ina)
                  if (ineiga(ja,ina) .eq. iba) then
                    ineiga(ja,ina)=ineiga(nneiga(ina),ina)
                    nneiga(ina)=nneiga(ina)-1
                    go to 200
                  end if
                end do
    200         continue
              end do
            end do
            do ia=1,lbackb
              iba=iback(ia)
              ibn1=0
              lchainmax=0
              do in=1,nneiga(iba)
                ibna=ineiga(in,iba)
                if (nneiga(ibna) .gt. 0) then
                  call growchain(n0,n,iba,ibna,ial,nsteps,nneiga,ineiga,
         -          list,iparent,isideback,iii,maxbox)
                  if (lchainmax .lt. nsteps) then
                    lchainmax=nsteps
                    ichainmax=ibna
                  end if
                else if (ibn1 .eq. 0) then
                  ibn1=ibna
                end if
              end do
              if (lchainmax .gt. 0) then
                call growchain(n0,n,iba,ichainmax,ial,nsteps,nneiga,ineiga,
         -        list,iparent,isideback,iii,maxbox)
              end if
              linep=blankline
              ibb=ibb+1
              write (linep(20:26),1003) ibb
              write (linep(27:44),1000) iba,
         -      line(index(iba))(ir1:ir2),line(index(iba))(in1:in2)
              if (ibn1 .gt. 0) then
                write (linep(1:18),1000) ibn1,
         -        line(index(ibn1))(ir1:ir2),line(index(ibn1))(in1:in2)
                linep(18:18)='-'
              end if
              if (lchainmax .gt. 0) then
                ic0=44
                do ic=1,lchainmax
                  icis=isideback(lchainmax-ic+1)
                  write (linep(ic0+1:ic0+18),1000) icis,
         -          line(index(icis))(ir1:ir2),line(index(icis))(in1:in2)
                  linep(ic0:ic0)='-'
                  ic0=ic0+18
                  if (mod(ic,2) .eq. 0 .and. ic .ne. lchainmax) then
                    write (iwout,1002) linep(1:79)
                    linep=blankline
                    ic0=44
                  end if
                end do
              end if
              write (iwout,1002) linep(1:79)
            end do
            if (ilast .ne. n) write (iwout,1004)
            ifirst=ilast+1
          end do
          return
    1000  format(i5,' (',a4,a5,') ')
    1002  format(a)
    1003  format('BB',i4,':')
    1004  format(/,'New backbone start',/)
    1005  format(/,' Backbone search ',/,
         -  ' BB  seqno: atomindex (residue name atom name)')
          end
          subroutine growchain(n0,n,n00,iaf,ial,nsteps,nneig,ineig,
         -  list,iparent,ichain,imax,maxng)
          dimension nneig(n),ineig(maxng,n),list(n),iparent(n),ichain(n)
          nsteps=0
          imax=0
          call zeroiti(iparent,n0-1,n)
          if (n00 .ne. 0) iparent(n00)=n00
          iparent(iaf)=iaf
          ic=iaf
          ilistf=1
          ilistl=1
          list(ilistf)=ic
          imax=ic
          do while (ilistl .ge. ilistf)
            nsteps=nsteps+1
            ilist=ilistl
            do il=ilistf,ilistl
              ic=list(il)
              do in=1,nneig(ic)
                ia=ineig(in,ic)
                if (ia .ge. n0 .and. ia .le. n) then
                  if (iparent(ia) .eq. 0) then
                    iparent(ia)=ic
                    ilist =ilist+1
                    list(ilist)=ia
                    if (ia .gt. imax) imax=ia
                  end if
                end if
              end do
            end do
            ilistf=ilistl+1
            ilistl=ilist
          end do
          ial=list(ilist)
          ic=ial
          ichain(1)=ic
          do ia=2,nsteps+1
            ic=iparent(ic)
            ichain(ia)=ic
          end do
          return
          end
          subroutine swapng(ineig,ibnd,ia,n1,n2,n,maxng)
          dimension ineig(maxng,n),ibnd(maxng,n)
          if (n1 .lt. n2) then
            call swapi4(ineig(n1,ia),ineig(n2,ia))
            call swapi4(ibnd(n1,ia),ibnd(n2,ia))
          end if
          return
          end
          subroutine swapi4(i1,i2)
          ii=i1
          i1=i2
          i2=ii
          return
          end
          subroutine sortatresrtf(line,n,nslt,index,indexn,indexo,isegno,
         -  itemp1,irescol1,irescol2,iresncol1,iresncol2,isegcol1,isegcol2,
         -  inamcol1,inamcol2,inpcrdtyp,nconfig,maxrec)
          character* 132 line(maxrec)
          dimension isegno(n),index(n),indexo(n),indexn(maxrec),itemp1(n)
          character*4 ires,reso,resn,atnam,sego,segn
          character*8 convdat
          character*200 sfilename
          common /savedat/ mxresdat,maxcondat,ifst(1000),ilst(1000),
         -  nres,iresgen,lsfilename,ires(1000),convdat(7,10000),sfilename
          character*5 crdext
          common /iotypes/ iocha,iochaex,iobpdb,iocpdb,ioa3pdb,ioa4pdb,
         -  iommod,iommc,iommc4,iogro,iomol2,iomae,iocif,ioxxx,ioins,
         -  ionxyz,iosxyz,iosxyzrq,iograsp,iofull,lext(19),crdext(19)
          nresproc=0
          natproc=0
          reso='    '
          sego='    '
          ireso=0
          nresnotfound=0
          ifaslt=1
          call trnsfi(indexo,index,n)
          call zeroiti(indexn,0,n)
          lench=irescol2-irescol1+1
          lens=isegcol2-isegcol1+1
          numlen=iresncol2-iresncol1+1
          do ia=1,n
            resn=line(index(ia))(irescol1:irescol2)
            segn=line(index(ia))(isegcol1:isegcol2)
            if (numlen .eq. 5) then
              read (line(index(ia))(iresncol1:iresncol2),1000,err=999) iresn
            else if (numlen .eq. 4) then
              read (line(index(ia))(iresncol1:iresncol2),1001,err=999) iresn
            else
              print *,'Invalid resnum length=',numlen
              stop
            end if
            if (ia .eq. n .or. iresn .ne. ireso .or.
         -      segn(1:lens) .ne. sego(1:lens)) then
              ilaslt=ia-1
              if (ia .eq. n) ilaslt=n
              nats=ilaslt-ifaslt+1
              if (nresproc .gt. 0) then
                call findname(reso,ires,1,nres,ix,lench)
                if (ix .gt. 0) then
                  ifadb=ifst(ix)
                  iladb=ilst(ix)
                  natsdb=iladb-ifadb+1
                  if (nats .ne. natsdb) write (6,2000) reso,nats,natsdb
                  nnotfound=0
                  natsdbfound=0
                  do iaa=ifaslt,ilaslt
                    atnam=line(index(iaa))(inamcol1:inamcol2)
                    call leftadjust4(atnam,atnam)
                    if (idigit(atnam(1:1),1) .eq. 1)
         -            call regularpdb(atnam,atnam,-1)
                    do ira=ifadb,iladb
                      if (atnam .eq. convdat(2,ira)(1:4)) then
                        indexn(ira-ifadb+ifaslt)=iaa
                        natsdbfound=natsdbfound+1
                        go to 100
                      end if
                    end do
                    write (6,2001) iaa,
         -            line(index(iaa))(inamcol1:inamcol2),reso
                    nnotfound=nnotfound+1
                    itemp1(nnotfound)=iaa
    100             continue
                  end do
                  if (natsdbfound .lt. natsdb)
         -          write (6,2003) reso,natsdbfound,natsdb
                  if (nnotfound .gt. 0) then
                    ndel=0
                    do iaa=ifaslt,ifaslt+iladb-ifadb+1
                      if (indexn(iaa) .gt. 0) then
                        indexn(iaa-ndel)=indexn(iaa)
                        if (ndel .gt. 0) indexn(iaa)=0
                      else
                        ndel=ndel+1
                      end if
                    end do
                    nmoved=0
                    do iaa=ifaslt,ilaslt
                      if (indexn(iaa) .eq. 0) then
                        nmoved=nmoved+1
                        indexn(ilaslt-nnotfound+nmoved)=itemp1(nmoved)
                      end if
                    end do
                  end if
                else if (n .le. nslt) then
                  nresnotfound=nresnotfound+1
                  call indexit(indexn,ifaslt,ilaslt,0)
                end if
              end if
              nresproc=nresproc+1
              sego=segn
              reso=resn
              ireso=iresn
              ifaslt=ilaslt+1
            end if
          end do
          if (nresnotfound .gt. 0) print *,
         -  'The number of residues not found in the database=',nresnotfound
          ndel=0
          do ia=1,n
            if (indexn(ia) .eq. 0) then
              ndel=ndel+1
              print *,'PROGRAM ERROR: atom ',ia,' is misplaced'
            end if
          end do
          if (ndel .gt. 0) then
            print *,'PROGRAM ERROR:',ndel,' atoms were not taken care of'
            print *,'- aborting rearrangement'
            return
          end if
          do ia=1,n
            index(ia)=indexo(indexn(ia))
            isegno(ia)=isegno(indexn(ia))
          end do
          if (ndel .gt. 0) print *,'Number of atom records deleted=',ndel
          if (inpcrdtyp .eq. iommod) then
            do ia=1,n
              do ib=1,6
                ic1=6+(ib-1)*8
                ic2=ic1+4
                read (line(index(ia))(ic1:ic2),1000) iold
                if (iold .gt. 0)
         -        write (line(index(ia))(ic1:ic2),1000) indexn(iold)
              end do
            end do
          end if
          if (nconfig .eq. 1) then
            print *,'Number of residues processed=',nresproc-1
            if (nresnotfound .gt. 0) then
               print *,'WARNING: ',nresnotfound,
         -     ' solute residues were not found in the RTF info file'
              call askstop(0)
            end if
          end if
          return
    999   write (6,2002) ia,index(ia),line(index(ia))(iresncol1:iresncol2)
          stop
    1000  format(i5)
    1001  format(i4)
    2000  format(' WARNING: number of atoms in the input residue ',a4,/,
         -  ' differs from the number in the RTF info file:',i5,' vs',i5)
    2001  format(' No match was found for atom ',i4,2x,a4,' residue ',a4,/,
         -  ' - it will be moved to the end of this residue')
    2002  format(' ERROR: invalid residue number for atom no',i5,
         - ' line no',i5,':',a)
    2003  format(' WARNING: not all atoms in the input residue ',a4,/,
         -  ' were matched to the RTF info file:',i5,' vs',i5)
          end
          subroutine PDBtommc(resn,atomn,ptype,char,indx,gcent,igr,
         -  ideoxymmc,ifile,nunknown,nunknownr)
          character*1 gcent,ans1
          character*4 ptype
          character*8 resn,resnam,atomn,atomnam
          character*4 ires
          character*8 convdat,grpinfo
          character*200 sfilename
          common /savedat/ mxresdat,maxcondat,ifst(1000),ilst(1000),
         -  nres,iresgen,lsfilename,ires(1000),convdat(7,10000),sfilename
          ptype='****'
          char=0.0
          gcent=' '
          igr=0
          call leftadjustn(atomn,atomnam,8)
          call leftadjustn(resn,resnam,8)
          if (ifile .eq. 2) then
            if (resnam .eq. 'ADE     ' .or. resnam .eq. 'GUA     ' .or.
         -    resnam .eq. 'CYT     ') then
              if (ideoxymmc .eq. -1) then
                call getname(ans1,len,
         -        'Nucleic acid type (D for Deoxy, R Oxy)',38,1,'',0,0,0,0)
                ideoxymmc=1
                if (ans1 .eq. 'r' .or. ans1 .eq. 'R') ideoxymmc=0
              end if
              resnam(2:4)=resnam(1:3)
              if (ideoxymmc .eq. 0) resnam(1:1)='R'
              if (ideoxymmc .eq. 1) resnam(1:1)='D'
            else if (resnam .eq. 'THY  ') then
              ideoxymmc=1
              resnam='DTHY    '
            else if (resnam .eq. 'URA     ') then
              resnam='RURA    '
              ideoxymmc=0
            end if
          else if (ifile .eq. 3) then
          else if (ifile .eq. 4) then
          end if
          do i=1,nres
            if (resnam(1:4) .eq. ires(i)) then
              do j=ifst(i),ilst(i)
                if (atomnam(1:4) .eq. convdat(2,j)(1:4)) then
                  ptype=convdat(3,j)(1:4)
                  read (convdat(4,j),1001) char
                  grpinfo=convdat(5,j)
                  go to 100
                end if
              end do
              do ii=1,nres
                if (ires(ii) .eq. 'ACE ' .or. ires(ii) .eq. 'NME ' .or.
         -          (ires(ii)(2:4) .eq. 'POM' .and.
         -           ires(ii)(1:1) .eq. resnam(1:1))) then
                  do j=ifst(ii),ilst(ii)
                    if (atomnam(1:4) .eq. convdat(2,j)(1:4)) then
                      ptype=convdat(3,j)(1:4)
                      read (convdat(4,j),1001) char
                      grpinfo=convdat(5,j)
                      go to 100
                    end if
                  end do
                end if
              end do
              if (iresgen .gt. 0) then
                do j=ifst(iresgen),ilst(iresgen)
                  if (atomnam(1:4) .eq. convdat(2,j)(1:4)) then
                    ptype=convdat(3,j)(1:4)
                    read (convdat(4,j),1001) char
                    grpinfo=convdat(5,j)
                    go to 100
                  end if
                end do
              end if
              write (6,2000) atomnam,resnam,indx
              nunknown=nunknown+1
              return
    100       if (grpinfo(1:5) .eq. 'GROUP') then
                read(grpinfo(6:6),1003) igcnt
                if (igcnt .eq. 1) gcent='G'
                read(grpinfo(7:8),1004) igr
              end if
              return
            end if
          end do
          write (6,2001) resnam
          nunknownr=nunknownr+1
          return
    1001  format(f8.0)
    1003  format(i1)
    1004  format(i2)
    2000  format(' ERROR: atomname=',a5,' resname=',a5,' (',i5,')',
         -  ' not found in conversion table')
    2001  format(' ERROR: resname=',a4,' not found in conversion ',
         -  'table')
          end
          subroutine getconvdat(ifflist,ilflist,ncol,nconvdat,iconvtyp,
         -  n,line,index,inamcol1,inamcol2,nnamcol,irescol1,irescol2,
         -  igrpinfo,maxrec)
          character* 132 line(maxrec)
          dimension index(n)
          character*1 ans1
          character*80 inpline
          character*4 ires
          character*8 convdat
          character*200 sfilename
          common /savedat/ mxresdat,maxcondat,ifst(1000),ilst(1000),
         -  nres,iresgen,lsfilename,ires(1000),convdat(7,10000),sfilename
          character*8 atnam
          character*200 filenames(5)
          dimension iconvtyps(5),lfilenames(5)
          data lfilenames /18,15,11,13,13/,iconvtyps /2,1,1,1,2/
          data filenames /'cha_prot19_rtf.dat',
         -  'amb_prot_ua.dat','amb_all.dat','amb_all94.dat','cha_all22.dat'/
          character*57 RTFtyps
          common /explainRTF/ RTFtyps(4)
          if (ilflist .gt. 5) then
            print *,'PROGRAM ERROR: conversion list limit=',ilflist,' > 5'
            stop
          end if
          nleadsp=0
          nleaddigit=0
          igrpinfo=0
          do ia=1,n
            atnam(1:nnamcol)=line(index(ia))(inamcol1:inamcol2)
            if (atnam(1:1) .eq. ' ') nleadsp=nleadsp+1
            if (idigit(atnam(1:1),1) .eq. 1) nleaddigit=nleaddigit+1
          end do
          write (6,2006) RTFtyps
          write (6,2007) -1,'User-supplied',' ','RTF file'
          write (6,2007) 0,'User-supplied',
         -  ' conversion data file ','in Simulaid format'
          do i=ifflist,ilflist
            write (6,2007) i,'Simulaid-supplied ',
         -    'conversion data file ',filenames(i)(1:lfilenames(i))
          end do
    120   call getint('The number corresponding to your choice',39,999999,
         -  0,ilflist,ifile,49)
          iconvtyp=0
          if (ifile .eq. 0) then
            call getname(sfilename,lsfilename,'Name of the conversion file',
         -    27,200,'',0,0,0,0)
            if (ncol .gt. 2) call quiz(ans1,iconvtyp,' ',' ',0,
         -    'PF label type',13,0,5,6,00)
          else if (ifile .ge. ifflist) then
            sfilename=filenames(ifile)
            lsfilename=lfilenames(ifile)
            iconvtyp=iconvtyps(ifile)
          else if (ifile .ne. -1) then
            print *,'Invalid number'
            go to 120
          end if
          nconvdat=0
          ntypedat=0
          if (ifile .ge. 0) then
            iuconv=80
            call openfile(iuconv,0,'conversion information',22,'old',
         -    sfilename,lsfilename,notfnd,1,1,0,0,0)
            write (6,2005) sfilename(1:lsfilename)
            do while (.true.)
              read (iuconv,1001,end=110) inpline
              nconvdat=nconvdat+1
              if (nconvdat .lt. maxcondat) then
                read (inpline,*,err=999) (convdat(k,nconvdat),k=1,ncol)
              else
                write (6,2001) maxcondat
                stop
              end if
            end do
    999     write (6,2000) i,inpline
            stop
    110     close (iuconv)
            print *,'Number of conversions read=',nconvdat
          end if
          if (ifile .ge. 0)
         -    call askyn('Do you want to read RTF file(s) (too)',
         -      37,1,-1,ichrtf,0,0)
          if (ichrtf .eq. 1 .or. ifile .lt. 0) then
            call getrtfdat(nconvdat,5,iconvtyp,ntypedat)
          end if
          nres=1
          iresgen=0
          ires(nres)=convdat(1,1)(1:4)
          ifst(nres)=1
          do i=2,nconvdat
            if (convdat(1,i) .ne. convdat(1,i-1)) then
              ilst(nres)=i-1
              nres=nres+1
              if (nres .gt. mxresdat) then
                write (6,2004) mxresdat,sfilename(1:lsfilename)
                stop
              end if
              ires(nres)=convdat(1,i)(1:4)
              ifst(nres)=i
              if (ires(nres) .eq. '    ') iresgen=nres
            end if
          end do
          ilst(nres)=nconvdat
          nleadspcd=0
          nleaddigitcd=0
          do i=2,nconvdat
            if (convdat(2,1)(1:1) .eq. ' ') nleadspcd=nleadspcd+1
            if (idigit(convdat(2,1)(1:1),1) .eq. 1)
         -    nleaddigitcd=nleaddigitcd+1
            if (convdat(5,nconvdat)(1:5) .eq. 'GROUP') igrpinfo=1
          end do
          ipdbin=0
          if (float(nleaddigit)/float(n) .gt. 0.01) ipdbin=1
          ipdbcd=0
          if (float(nleaddigitcd)/float(nconvdat) .gt. 0.01) ipdbcd=1
          if (ipdbin .eq. 1 .and. ipdbcd .eq. 0) then
            write (6,2002)
            call askyn('Do you want to de-regularize them',33,1,1,idereg,0,
         -    0)
            if (idereg .eq. 1) then
              call fixrecform(line,index,n,3,inamcol1,inamcol2,
         -      irescol1,irescol2,maxrec)
            end if
          end if
          return
    1001  format(a80)
    2000  format(' ERROR: invalid conversion data record, record no:',
         -  i5,':',a)
    2001  format(' ERROR: Data file has more than',i5,' lines')
    2002  format(' Input names appear to be in regular PDB format ',
         -  '(e.g., 2HG1)',/,'but the conversion data do not (i.e., HG12)')
    2004  format(' ERROR: Maximum number of different residues ',
         -  '(',i4,') is exceeded in file',/,5x,a)
    2005  format(' Residue and atomname conversion table is in file ',a)
    2006  format(/,' Conversion information can be obtained from ',/,
         -  3x,'a) conversion data files (see list below) and/or',/,
         -  3x,'b) RTF file(s) ',/,4(a,/),
         -  /,' Current options:')
    2007  format(i3,2x,a,a,a)
          end
          subroutine getrtfdat(nconvdat,ncol,iconvtyp,ntypedat)
          character*80 linep,linech,lineprev
          character*4 ires,resnam,atnam,atnamo,potnam,attyp
          character*200 sfilename,rtffile,parmfile
          character*8 convdat
          common /savedat/ mxresdat,maxcondat,ifst(1000),ilst(1000),
         -  nres,iresgen,lsfilename,ires(1000),convdat(7,10000),sfilename
          character*1 lc
          dimension sig(1000),eps(1000),attyp(1000)
          data ictyp /0/,igrprev /0/,numat /0/
    C     Read Charmm Amber or Gromacs topology (RTF) file
          nconvdat0=nconvdat
          iconvtyp=0
    200   namlena=0
          call openfile(15,0,'RTF',3,'old',rtffile,namlena,notfnd,0,1,1,0,0)
          ifound=0
          nlread=0
          do while (ifound .eq. 0)
            read (15,1000,end=999) linech
            ic=1
            if (linech(1:1) .eq. ' ') call nextchar(linech,ic,80)
            if (linech(ic:ic+3) .eq. 'DONE') then
              ifound=1
              ictyp=1
              write (6,2002) 'Amber'
            else if (linech(ic:ic+3) .eq. 'RESI' .or.
         -           linech(ic:ic+3) .eq. 'PRES') then
              ifound=1
              ictyp=2
              write (6,2002) 'Charmm'
            else if (linech(ic:ic) .eq. '[') then
              ifound=1
              ictyp=3
              write (6,2002) 'Gromacs'
              print *,'NOTE: only four-character names are used for now'
            end if
          end do
          if (iconvtyp .gt. 0) then
            if (iconvtyp .ne. ictyp) then
              write (6,2003)
              iconvtyp=0
            end if
          else
            iconvtyp=ictyp
          end if
          rewind 15
          if (iconvtyp .eq. 1) then
            read (15,1000) linech
            read (15,1000) linech
            ic=1
            call nextblank(linech,ic,80)
            write (6,2004) linech(1:ic-1)
            read (15,1000) linech
            nlread=3
            do while (linech(1:4) .ne. 'STOP')
              read (15,1000,end=999) linech
              read (15,1000,end=999) linech
              nlread=nlread+2
              ic=1
              if (linech(1:1) .ne. ' ') icinc=-1
              if (linech(ic:ic) .eq. ' ') call nextchar(linech,ic,80)
              resnam=linech(ic:ic+3)
              read (15,1000) linech
              read (15,1000) linech
              read (15,1000) linech
              nlread=nlread+3
              atnam='xxxx'
              atnamo=atnam
              do while (atnam .ne. '    ')
                call blankout(linech,1,80)
                read (15,1000) linech
                nlread=nlread+1
                ic=1
                call nextchar(linech,ic,80)
                if (ic .eq. 80) then
                  atnam='    '
                else
                  call nextblank(linech,ic,80)
                  call nextchar(linech,ic,80)
                  atnam=linech(ic:ic+3)
                  if (atnam .ne. atnamo .and. atnam .ne. 'DUMM') then
                    nconvdat=nconvdat+1
                    do icl=1,ncol
                      convdat(icl,nconvdat)='        '
                    end do
                    convdat(1,nconvdat)(1:4)=resnam
                    convdat(2,nconvdat)(1:4)=atnam
                    call nextblank(linech,ic,80)
                    call nextchar(linech,ic,80)
                    convdat(3,nconvdat)(1:2)=linech(ic:ic+1)
                    do is=1,8
                      call nextblank(linech,ic,80)
                      call nextchar(linech,ic,80)
                    end do
                    ic1=ic
                    call nextblank(linech,ic,80)
                    convdat(4,nconvdat)(1:ic-ic1)=linech(ic1:ic-1)
                    write (convdat(5,nconvdat),2001) 1,1
                    atnamo=atnam
                  end if
                end if
              end do
              do while (linech(1:4) .ne. 'DONE')
                read (15,1000) linech
                nlread=nlread+1
              end do
              read (15,1000,end=999) linech
              nlread=nlread+1
            end do
          else if (iconvtyp .eq. 2) then
            igr=0
            newgr=1
            do while (.true.)
              read (15,1000,end=999) linech
              nlread=nlread+1
              ic=1
              if (linech(1:1) .eq. ' ') call nextchar(linech,ic,80)
              if (linech(ic:ic+3) .eq. 'RESI' .or.
         -        linech(ic:ic+3) .eq. 'PRES') igr=0
              if (linech(ic:ic+3) .eq. 'GROU') then
                igr=igr+1
                newgr=1
              else if (linech(ic:ic+3) .eq. 'ATOM') then
                nconvdat=nconvdat+1
                do icol=1,ncol
                  convdat(icol,nconvdat)='        '
                end do
                convdat(1,nconvdat)(1:4)=resnam
                ic=ic+4
                call nextchar(linech,ic,80)
                convdat(2,nconvdat)(1:4)=linech(ic:ic+3)
                ic=ic+4
                call nextchar(linech,ic,80)
                convdat(3,nconvdat)(1:4)=linech(ic:ic+3)
                ic=ic+4
                ic0=ic
                lc=linech(ic:ic)
                do while (idigit(lc,2) .eq. 1 .and. ic .lt. ic0+14)
                  ic=ic+1
                  lc=linech(ic:ic)
                end do
                if (ic-ic0 .gt. 2) then
                  call readreal(linech,ic0,ic-1,charge)
                else
                  charge=0.0
                  write (6,2006) (convdat(k,nconvdat)(1:4),k=1,3)
                end if
                write (convdat(4,nconvdat),2000) charge
                write (convdat(5,nconvdat),2001) newgr,igr
                if (newgr .eq. 1) newgr=0
              else if (linech(ic:ic+3) .eq. 'RESI' .or.
         -             linech(ic:ic+3) .eq. 'PRES') then
                resnam='    '
                ic=ic+4
                call nextchar(linech,ic,80)
                icl=ic
                call nextblank(linech,ic,80)
                resnam=linech(icl:ic-1)
              end if
            end do
          else
            lookres=1
            do while (.true.)
              call blankout(linech,1,80)
              read (15,1000,end=999) linech
              nlread=nlread+1
              ic=1
              if (linech(ic:ic) .eq. ' ') call nextchar(linech,ic,80)
    100       if (lookres .eq. 1) then
                if (linech(ic:ic) .eq. '[') then
                  call nextblank(linech,ic,80)
                  call nextchar(linech,ic,80)
                  if (linech(ic:ic+4) .eq. 'atoms') then
                    igrprev=0
                    ic=1
                    call getname4(ic,lineprev,resnam,80,1)
                    lookres=0
                    numat=0
                  end if
                  lineprev=linech
                end if
              else
                if (linech(ic:ic) .eq. '[') then
                  lookres=1
                  lineprev=linech
                  if (numat .eq. 1) go to 100
                else
                  call getname4(ic,linech,atnam,80,1)
                  call getname4(ic,linech,potnam,80,-1)
                  if (ic .gt. 72) then
                    lookres=1
                  else
                    nconvdat=nconvdat+1
                    numat=numat+1
                    do icol=1,ncol
                      convdat(icol,nconvdat)='        '
                    end do
                    convdat(1,nconvdat)(1:4)=resnam
                    convdat(2,nconvdat)(1:4)=atnam
                    convdat(3,nconvdat)(1:4)=potnam
                    call nextchar(linech,ic,80)
                    icf=ic
                    call nextblank(linech,ic,80)
                    read (linech(icf:ic-1),*,err=900) charge
                    write (convdat(4,nconvdat),2000) charge
                    call nextchar(linech,ic,80)
                    read (linech(ic:ic),*,err=900) igr
                    newgr=0
                    if (igr .ne. igrprev) newgr=1
                    write (convdat(5,nconvdat),2001) newgr,igr
                    igrprev=igr
                  end if
                end if
              end if
            end do
          end if
    999   close (15)
          print *,'Finished reading',nlread,' lines'
          if (ictyp .eq. 0) then
            print *,'ERROR: file ',rtffile(1:namlena),' is not an RTF file'
          else
            print *,'Number of conversions read from this file=',
         -    nconvdat-nconvdat0
          end if
          call askyn('Do you have an other RTF file',29,1,0,morefile,0,0)
          if (morefile .eq. 1) go to 200
          if (ncol .gt. 5) then
            ntypedat=0
    300     namlenp=0
            call openfile(16,0,'PARAM',5,'old',parmfile,namlenp,notfnd,
         -    0,1,1,0,0)
            if (ictyp .eq. 1) then
              print *,'Amber parameter file read is not implemented yet'
            else if (ictyp .eq. 2) then
              linep(1:4)='    '
              do while (linep(1:4) .ne. 'NONB')
                read (16,1000) linep
              end do
              call lastchar(linep,ic,80)
              lc=linep(ic:ic)
              do while (lc .eq. '-')
                read (16,1000) linep
                call lastchar(linep,ic,80)
                lc=linep(ic:ic)
              end do
              do while (ic .gt. 1)
                linep(1:1)=' '
                read (16,1000,end=998) linep
                icf=1
                call nextchar(linep,icf,80)
                if (icf .lt. 80) then
                  ntypedat=ntypedat+1
                  attyp(ntypedat)=linep(icf:icf+3)
                  icf=icf+3
                  call nextchar(linep,icf,80)
                  call nextblank(linep,icf,80)
                  call nextchar(linep,icf,80)
                  icl=icf
                  call nextblank(linep,icl,80)
                  call readreal(linep,icf,icl-1,epsilon)
                  icf=icl
                  call nextchar(linep,icf,80)
                  icl=icf
                  call nextblank(linep,icl,80)
                  call readreal(linep,icf,icl-1,sigma)
                  eps(ntypedat)=-epsilon
                  sig(ntypedat)=2.0*sigma/2.0**(1.0/6.0)
                end if
                call lastchar(linep,ic,80)
                if (ic .eq. 1 .and. linep(1:1) .eq. '!') ic=2
              end do
              print *,'Read ',ntypedat,' nonbonded parameters'
            else if (ictyp .eq. 3) then
              print *,'Gromacs parameter file read is not implemented yet'
            end if
    998     close (16)
            call askyn('Do you have an other PARAM file',31,1,0,morefile,0,
         -    0)
            if (morefile .eq. 1) go to 300
            notype=0
            do ic=1,nconvdat
              do it=1,ntypedat
                if (convdat(3,ic)(1:4) .eq. attyp(it)) then
                  write (convdat(6,ic),2000) eps(it)
                  write (convdat(7,ic),2000) sig(it)
                  go to 980
                end if
                notype=notype+1
                write (convdat(6,ic),2000) 0.0
                write (convdat(7,ic),2000) 0.0
              end do
    980       continue
            end do
            if (notype .gt. 0) print *,'WARNING: ',notype,
         -  ' atoms in the RTF file have no LJ parameters'
          end if
          return
    900   write (6,2005) linech,resnam,atnam,potnam,charge,igr
    1000  format(a)
    2000  format(f8.4)
    2001  format('GROUP',i1,i2)
    2002  format(' RTF file is in ',a,' format')
    2003  format(' ERROR: RTF file  format is incompatible with the ',
         -  'conversion file read')
    2004  format(' Amber database name:',a)
    2005  format(' ERROR in Gromacs atom record :',/,a,/,' resnam=',
         -  a4,' atnam=',a4,' potnam=',a4,' charge=',f7.4,' igr=',i2)
    2006  format(' WARNING: residue ',a,' atom ',a,' type ',a,
         -  ' has no charge entry (0 is assumed)')
          end
          subroutine find_ambertyp(inpt,flag,lflag,form,lform)
          character*(*)flag,form
          character*80 liner
          rewind inpt
          liner(1:1)=' '
          do while (liner(1:lflag) .ne. flag(1:lflag))
            read(inpt,1010,end=100) liner
          end do
          call blankout(liner,1,80)
          read(inpt,1010,end=100) liner
          if (liner(1:7) .eq. '%FORMAT') then
            call lastchar(liner,lc,80)
            form=liner(8:lc)
            lform=lc-7
          end if
          return
    100   print *,'Format not found after flag ',flag(1:lflag)
    1010  format(a)
          stop
          end
          subroutine findname(name,list,ifrst,lenlist,ix,lench)
          character*(*) name,list
          dimension list(lenlist)
          ix=0
          do i=ifrst,lenlist
            if (name(1:lench) .eq. list(i)(1:lench)) then
              ix=i
              return
            end if
          end do
          return
          end
          subroutine pickname(query,lquery,list,llist,nlist,ix)
          character*(*) query,list(nlist)
          dimension llist(nlist)
          character*80 line
          maxlen=0
          do i=1,nlist
            if (llist(i) .gt. maxlen) maxlen=llist(i)
          end do
          if (maxlen .gt. 76) then
            print *,'PROGRAM ERROR: list item is longer than 76 chars'
            stop
          end if
          do i=1,nlist
            line(1:llist(i))=list(i)(1:llist(i))
            call blankout(line,llist(i)+1,maxlen+1)
            write (line(maxlen+2:maxlen+3),1001) i
            write (6,1000) line(1:maxlen+3)
          end do
          call getint(query,lquery,0,1,nlist,ix,000)
          return
    1000  format(1x,a)
    1001  format(i2)
          end
          subroutine checkdupnames(namelist,lnamelist,n,label,llabel,idup)
          character*(*) namelist,label
          dimension namelist(n)
          idup=0
          do i=2,n
            call findname(namelist(i),namelist,1,i-1,ix,lnamelist)
            if (ix .gt. 0) then
              idup=1
              if (llabel .gt. 0) write (6,1000) label(1:llabel),
         -        i,ix,namelist(i)(1:lnamelist)
            end if
          end do
          return
    1000  format(' Duplicate found in list ',a,
         -  ': list(',i4,')=list(',i4,')=',a)
          end
          subroutine maketraj(nconfig,maxconf,c,c1,rprox,cv,ih,nslt,n,naslv,
         -  islvw,ntitltr,trtitle,line,altcol,inscol,ninsres,inpcrdtyp,
         -  newinp,inptrajtyp,ioutrajtyp,mmctrajtyp,iout,iatnum,ifchrg,
         -  innlist,iresno,ixres,atnames,resnames,segnames,charge,isegno,
         -  marker,ntitlin,title,ireseq,iresnrestart,iresidrestart,nneig,
         -  nneiga,nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,numres,
         -  numslv,resnamslv,blankline,mmtype,ibnd,index,indexn,indexo,
         -  indexs,icntrl,icntrlr,ifree,molresflag,idupl,itemp1,ireorder,
         -  icellfound,natsdel,nwrmax,hblimfac,angmin,iqspaceask,keeprem,
         -  iwriteatsym,radtodeg,etot,noheadchange,maxrepconf,maxng,mxres,
         -  maxrec)
          dimension icntrl(20),icntrlr(20),ifree(n)
          character*1 altcol(maxrec),inscol(maxrec)
          character*80 trtitle(32)
          character* 132 line(maxrec),blankline
          character*80 title
          character*4 segnames(mxres)
          character*8 resnamslv,atnames(maxrec),resnames(mxres)
          character*6 marker(16)
          dimension c(3,maxrec),c1(3,maxrec),rprox(maxrec),cv(maxrec),
         -  ih(maxrec),nneig(maxrec),ineig(maxng,maxrec),iatnum(maxrec),
         -  ifchrg(maxrec),charge(maxrec),nhbneig(maxrec),nneiga(maxrec),
         -  nhneig(maxrec),nnneig(maxrec),ncneig(maxrec),nsneig(maxrec),
         -  npneig(maxrec),isegno(maxrec),iresno(maxrec),ixres(maxrec),
         -  mmtype(maxrec),ibnd(maxng,maxrec),index(maxrec),indexn(maxrec),
         -  indexo(maxrec),indexs(maxrec),molresflag(mxres),idupl(mxres),
         -  itemp1(maxrec)
          character*5 crdext
          common /iotypes/ iocha,iochaex,iobpdb,iocpdb,ioa3pdb,ioa4pdb,
         -  iommod,iommc,iommc4,iogro,iomol2,iomae,iocif,ioxxx,ioins,
         -  ionxyz,iosxyz,iosxyzrq,iograsp,iofull,lext(19),crdext(19)
          real*8 xtlabc,xtlabc0
          common /boxdat/ xtlabc(6),xtlabc0(6),box(3),box0(3),edge_gen(3,3),
         -  cell0(3,27),cell(3,27),cellalt(3,27),
         -  ncell,ioppbc,noboxinfoar,noboxinfow,noboxrep,
         -  istuner,iboxtypfound,ixcrd(3),ixang(3),ixyzhex(3),
         -  ixyzhextraj(3),isizewarn
          character*1 xyz
          common /axislab/ xyz(3)
          common /saveinfo/ nwrite,nfreeatwrite
          character*4 pflsv(100)
          character*8 namesv(100)
          dimension cmin(3),cmax(3),shiftmmc(3),iasv(100),qsv(100)
          real*8 detot
          data ifsavdef /1/,incrtdef /1/,ifsavvdef/0/,ichvers /27/,
         -  nfixatdef /0/,tsfsdef /1.0/,ndegfree /0/
          character*4 charmmheader(2)
          character*11 charmmheadname(2)
          data charmmheader/'CORD','VELD'/
          data charmmheadname/'coordinates','velocities '/
          limic11=1
          if (nconfig .eq. 1) then
            limic11=0
            nwrite=n-natsdel
            if (natsdel .gt. 0)
         -    print *,'Number of atoms written in a configuration=',nwrite
            if (ioppbc .eq. -1) then
              do k=1,3
                box0(k)=999.0
                box(k)=999.0
              end do
              noboxinfow=1
            else
              noboxinfow=0
            end if
            iboxdef=-1
            if (iboxtypfound .gt. 0) iboxdef=1
            if ((ioutrajtyp .eq. 1 .or. ioutrajtyp .eq. 3) .and.
         -       ioppbc .ge. 0)
         -    call askyn('Do you want box information written',35,
         -      0,iboxdef,noboxinfow,0,0)
            if (ioutrajtyp .eq. 1) then
              if (noheadchange .eq. 0) then
                if (noboxinfow .eq. 0) then
                  icntrl(11)=1
                  if (ioppbc .ge. 0) then
                    write (6,1104)
                    call askyn('Do you want repeated box information',36,
         -            0,1,noboxrep,0,0)
                    if (noboxrep .eq. 0) icntrl(11)=2
                  end if
                  if (noboxinfoar .eq. -1) then
                    print *,'Only rectangular box input is implemented'
                    do k=1,3
                      call getreal(
         -              'Box dimension in the '//xyz(k)//' direction',32,
         -              999999.0,xk,1,0)
                      xtlabc(ixcrd(k))=xk
                      xtlabc(ixang(k))=90.0d0
                    end do
                  end if
                else
                  icntrl(11)=0
                  call zeroitd(xtlabc,6)
                end if
              else
                icntrl(11)=icntrlr(11)
              end if
            else if (ioutrajtyp .eq. 2) then
              noboxrep=1
              irepdef=-1
              if (iboxtypfound .gt. 1) irepdef=1
              if (ioppbc .ge. 0) then
                call askyn('Do you want repeated box information',36,
         -        0,irepdef,noboxrep,127,9)
              end if
              if (inptrajtyp .eq. 1. and. icntrl(11) .ne. -1) then
                do k=1,3
                  box(k)=xtlabc(ixcrd(k))
                end do
              else if (icellfound .eq. 0 .and. ioppbc .ge. 0) then
                call getxyz('Initial box dimension in the ',29,
         -        ' direction',10,999999.0,box,1,0)
              end if
            end if
            if (ioutrajtyp .eq. 1) then
              icntrl(1)=maxconf
              if (inptrajtyp .eq. 1) then
                incrtdef=icntrlr(2)
                ifsavdef=icntrlr(3)
                ifsavvdef=icntrlr(5)
                ndegfree=icntrlr(8)
                nfixatdef=icntrlr(9)
                ichvers=icntrlr(20)
                call copyintgreal(icntrlr(10),tsakma,1)
                tsfsdef=tsakma*48.88821
              end if
              if (noheadchange .eq. 0) then
                call getint('Number of fixed atoms to put in the header',
         -        42,nfixatdef,1,n,icntrl(9),50)
                call getint(
         -        'Coordinate saving frequency to put in the header',48,
         -        ifsavdef,1,0,icntrl(3),50)
                call getint('Previous run steps to put in the header',39,
         -        incrtdef,1,0,icntrl(2),50)
                call getint(
         -        'Velocity saving frequency to put in the header',46,
         -        ifsavvdef,1,0,icntrl(5),50)
                call getint('Charmm version to put in the header',35,
         -        ichvers,1,40,icntrl(20),50)
                call getreal('Time step/fs to put in the header',33,tsfsdef,
         -        tsfs,1,0)
                tsakma=tsfs/48.88821
                call copyintgreal(icntrl(10),tsakma,0)
                icntrl(4)=maxconf*ifsavdef
                print *,'Number of creation steps=',icntrl(4)
                call askyn(
         -       'Do you want to create a velocity trajectory (VELD)',50,
         -       1,-1,icharmmheader,0,0)
                icharmmheader=icharmmheader+1
                write (6,1103) charmmheadname(icharmmheader),
         -        charmmheader(icharmmheader)
              else
                icntrl(2)=icntrlr(2)
                icntrl(3)=icntrlr(3)
                icntrl(5)=icntrlr(5)
                icntrl(8)=icntrlr(8)
                icntrl(9)=icntrlr(9)
                icntrl(10)=icntrlr(10)
                icntrl(20)=icntrlr(20)
                icharmmheader=1
              end if
              nfreeat=n-icntrl(9)
              nfreeatwrite=nfreeat
              nfadel=0
              if (natsdel .gt. 0) then
                if (ioutrajtyp .eq. 1 .and. icntrl(9) .gt. 0) then
                  nfadel=0
                  do ia=1,nfreeat
                    if (indexs(ifree(ia)) .eq. 0) then
                      nfadel=nfadel+1
                    else
                      ifree(ia-nfadel)=ifree(ia)
                    end if
                  end do
                  nfreeatwrite=nfreeat-nfadel
                end if
              end if
              if (inptrajtyp .eq. 1) then
                if (natsdel .gt. 0) ndegfree=ndegfree-3*nfadel
              else
                ndegfree=nfreeatwrite*3-6
              end if
              icntrl(8)=ndegfree
              write (iout) charmmheader(icharmmheader),icntrl
              write (iout) ntitltr,(trtitle(i),i=1,ntitltr)
              write (iout) nwrite
              if (icntrl(9) .gt. 0) write (iout) (ifree(i),i=1,nfreeatwrite)
            else if (ioutrajtyp .eq. 2) then
              write (iout,1000) trtitle(1)
            else if (ioutrajtyp .eq. 3) then
              call extension(c,ih,0,1,nslt,cmin,cmax,shiftmmc,0,0,v)
              write (6,1101) shiftmmc
            else if (ioutrajtyp .gt. 5) then
              print *,'PROGRAM ERROR: invalid trajectory type:',
         -      ioutrajtyp
            end if
          end if
          if (ireorder .gt. 0) then
            ndel=0
            do i=1,nwrmax
              if (indexs(i) .gt. 0) then
                do k=1,3
                  c1(k,i-ndel)=c(k,indexs(i))
                end do
              else
                ndel=ndel+1
              end if
            end do
            nwrite=nwrmax-ndel
          end if
          if (ioutrajtyp .eq. 1) then
            if (icntrl(11) .gt. limic11) write (iout) xtlabc
            if (ireorder .eq. 0) then
              if (icntrl(9) .eq. 0 .or. nconfig .eq. 1) then
                do k=1,3
                  write (iout) (c(k,i),i=1,nwrite)
                end do
              else
                do k=1,3
                  write (iout) (c(k,ifree(i)),i=1,nfreeatwrite)
                end do
              end if
            else
              if (icntrl(9) .eq. 0 .or. nconfig .eq. 1) then
                do k=1,3
                  write (iout) (c1(k,i),i=1,nwrite)
                end do
              else
                do k=1,3
                  write (iout) (c1(k,ifree(i)),i=1,nfreeatwrite)
                end do
              end if
            end if
          else if (ioutrajtyp .eq. 2) then
            if (ireorder .eq. 0) then
              write (iout,1001) ((c(k,i),k=1,3),i=1,nwrite)
            else
              write (iout,1001) ((c1(k,i),k=1,3),i=1,nwrite)
            end if
            if ((nconfig .eq. 1 .and. ioppbc .gt. 0) .or. noboxrep .eq. 0)
         -    write (iout,1001) box
          else if (ioutrajtyp .eq. 3) then
            if (mmctrajtyp .eq. 1) then
              detot=etot
              nwat=(n-nslt)/naslv
              write (iout) nwat,n,1.0d0,nconfig,0,
         -      0,0,1,nslt,detot,0.d0,0.d0,0.d0,0.d0,0.0
              if (ireorder .eq. 0) then
                write (iout) ((c(k,i),k=1,3),i=1,n)
              else
                write (iout) ((c1(k,i),k=1,3),i=1,n)
              end if
              if (noboxinfow .eq. 0) write (iout) box
            else
              print *,'Non-binary MMC trajectory write is not implemented'
              stop
            end if
          else if (ioutrajtyp .eq. 4 .or.
         -         (ioutrajtyp .eq. 5 .and. nconfig .eq. 1)) then
            inptp=inpcrdtyp
            inpcrdtyporg=inpcrdtyp
            if (nconfig .gt. 1 .and. newinp .eq. 0) then
              inptp=iommod
            end if
            call writeconf(iout,inptp,iommod,inpcrdtyporg,nwrite,nwrite,
         -    nslt,naslv,islvw,iasv,namesv,qsv,pflsv,1,1,0,iatnum,ifchrg,
         -    nconfig,innlist,c,rprox,cv,ixres,iresno,atnames,resnames,
         -    segnames,charge,isegno,altcol,inscol,ninsres,marker,ntitlin,0,
         -    title,ireseq,iresnrestart,iresidrestart,nneig,nneiga,nhbneig,
         -    ineig,nhneig,nnneig,ncneig,nsneig,npneig,numres,numslv,
         -    resnamslv,line,blankline,mmtype,ibnd,index,indexn,indexo,0,
         -    molresflag,idupl,itemp1,hblimfac,angmin,0,1,0,0,nconfig-1,5,
         -    iqspaceask,0,1,0.0,0,0,0,keeprem,iwriteatsym,radtodeg,
         -    maxrepconf,maxng,mxres,maxrec)
          else
            write (iout,1010) -n,title,((c(k,i),k=1,3),i=1,n)
          end if
          return
    1000  format(a80)
    1001  format(10f8.3)
    1010  format(i5,a,/,(5x,3f12.5))
    1101  format(' The system will be shifted by ',3f10.5)
    1103  format(' Trajectory is assumed to contain ',a,' (header:',a,')')
    1104  format(' For Charmm 27 and higher versions cell information can ',
         -  'be stored ',/,' for each frame. This is required for (T,P,N) ',
         -  'runs')
          end
          subroutine convtraj(ioutrajtyp,inptrajtyp,mmctrajtyp,inpcrdtyp,n,
         -  nslt,naslv,islvw,iatnum,ifchrg,innlist,ih,c,co,c1,c2,rprox,cv,
         -  iresno,ixres,ifres,ilres,ires_ref,ifres_ref,ilres_ref,atnames,
         -  resnames,segnames,charge,isegno,isegno_ref,segid4,ixseg1,ixseg2,
         -  marker,asterisk,ntitlin,title,ireseq,iresnrestart,iresidrestart,
         -  inamcol1,inamcol2,irescol1,irescol2,iseqncol1,iseqncol2,is1,is2,
         -  iqcol1,iqcol2,idcol,nneig,nneiga,nhbneig,ineig,nhneig,nnneig,
         -  ncneig,nsneig,npneig,numres,numslv,resnamslv,line,blankline,
         -  mmtype,ibnd,index,indexn,indexo,indexs,indexdel,index1,index2,
         -  indexsup,atw,edge,ifree,namin,namout,resin,resout,icntrl,
         -  icntrlw,iha,molresflag,altcol,inscol,ninsres,atwtemp,temp,idupl,
         -  itemp1,hblimfac,angmin,iconfsel,numsel,nextconfsel,molsltlim,
         -  nmolslt,nmolsltnoion,nooptquiz,minresflag,iqspaceask,
         -  isuperimpask,iwriteatsym,radtodeg,tofac,irepcall,ipbcinp,
         -  iwriteonly,lentest,maxconfsel,maxrepconf,pi,maxrsd,maxng,maxrec)
          character*1 asterisk,altcol(maxrec),inscol(maxrec)
          character*4 segnames(maxrsd),segid4(maxrsd)
          character* 132 line(maxrec),blankline
          character*80 title,lineinp,trtitle(32)
          dimension iconfsel(maxconfsel)
          dimension icntrl(20),icntrlw(20),molsltlim(3,maxrsd)
          dimension nneig(maxrec),ineig(maxng,maxrec),iatnum(maxrec),
         -  ifchrg(maxrec),c(3,maxrec),co(maxrec),c1(3,maxrec),c2(maxrec),
         -  rprox(maxrec),cv(maxrec),charge(maxrec),nhbneig(maxrec),
         -  nneiga(maxrec),nhneig(maxrec),nnneig(maxrec),ncneig(maxrec),
         -  nsneig(maxrec),npneig(maxrec),isegno(maxrec),isegno_ref(maxrec),
         -  ixseg1(maxrsd),ixseg2(maxrsd),iresno(maxrec),ixres(maxrec),
         -  ifres(maxrec),ilres(maxrec),ires_ref(maxrec),ifres_ref(maxrec),
         -  ilres_ref(maxrec),mmtype(maxrec),ibnd(maxng,maxrec),
         -  index(maxrec),indexn(maxrec),indexo(maxrec),indexs(maxrec),
         -  indexdel(maxrec),index1(maxrec),index2(maxrec),indexsup(maxrec),
         -  atw(maxrec),temp(maxrec),edge(3),ifree(maxrec),ih(maxrec),
         -  molresflag(maxrsd),atwtemp(maxrec),idupl(maxrsd),itemp1(maxrec)
          character*4 namin(maxrec),namout(maxrec),
         -  resin(maxrec),resout(maxrec)
          real*8 xtlabc,xtlabc0
          common /boxdat/ xtlabc(6),xtlabc0(6),box(3),box0(3),edge_gen(3,3),
         -  cell0(3,27),cell(3,27),cellalt(3,27),
         -  ncell,ioppbc,noboxinfoar,noboxinfow,noboxrep,
         -  istuner,iboxtypfound,ixcrd(3),ixang(3),ixyzhex(3),
         -  ixyzhextraj(3),isizewarn
          common /pbcrotmat/ torot_ac(3,3),torot_ca(3,3),tofac_ac,tofac_ca
          character*200 trajnam,outfile
          common /trajname/ trajnam,outfile,ltrajnam,namleno,ifirsttraj,
         -  ifirsttraj2,ilasttraj,ilasttraj2,incrementtraj,incrementtraj2
          common /columnlim/ incol(19),iidcol(19),iialtcol(19),iiinscol(19),
         -  iinamcol(2,19),iirescol(2,19),iiccol(2,19),iiresncol(2,19),
         -  iiseqncol(2,19),iisegcol(2,19),iiresidcol(2,19),iiqcol(2,19),
         -  iipotcol(2,19),iiocccol(2,19),iichemcol(2,19)
          character*5 crdext
          common /iotypes/ iocha,iochaex,iobpdb,iocpdb,ioa3pdb,ioa4pdb,
         -  iommod,iommc,iommc4,iogro,iomol2,iomae,iocif,ioxxx,ioins,
         -  ionxyz,iosxyz,iosxyzrq,iograsp,iofull,lext(19),crdext(19)
          character*8 resnamslv,atnames(maxrec),resnames(maxrsd)
          character*6 marker(16)
          character*1 xyz
          common /axislab/ xyz(3)
          character*11 trajformatname
          common /trajectory/ nmmccheck,iftrajtyp(6),trajformatname(6)
          dimension edgexyz(3),trajrot(3,3),shiftpbc(3),c0(3),crm(3),
         -  rot(3,3)
          character*200 reffile
          character*1 ans,seqtyp,reftyp,chainid,chainid_prev
          character*4 resnam4,atnam4,resnam4n,atnam4n,segid,segid_prev
          character*8 resold,namold
          data inpt /70/,iout /71/,namleno /0/,isort /0/,ishiftpbc /0/,
         -  ishiftocrn /0/,ishiftocnt /0/,ifirst /1/, ilast /999999/,
         -  increment /1/,edgexyz /3*0.0/,iacent /0/,itrajsuperimp /0/
          iusepbc=0
          icellalt=0
          etot=0.0
          call indexit(indexs,1,n,0)
          nnamcol=inamcol2-inamcol1+1
          nrescol=irescol2-irescol1+1
          natsdel=0
          do ia=1,nslt
            atwtemp(ia)=atw(ia)
            if (molresflag(ixres(ia)) .gt. minresflag) atwtemp(ia)=0.0
          end do
          ans='u'
    103   if (nooptquiz .eq. 0) call quiz(ans,isort,'u',' ',0,
         -  'output atom order',17,0,5,6,82)
          nomatch=0
          if (ans .eq. 'u') then
            ireorder=0
            if (inptrajtyp .ne. ioutrajtyp .and. iwriteonly .eq. 1)
         -    write (6,1014)
            call indexit(indexs,1,n,0)
            nwrmax=n
            iedit=0
            if (nooptquiz .eq. 0)
         -    call askyn('Do you want to select atoms to write',36,1,-1,
         -      iedit,00,0)
            if (iedit .gt. 0) then
              call select(line,nrecdel,idcol,asterisk,n,nslt,index,ixres,
         -      is1,is2,iseqncol1,iseqncol2,inamcol1,inamcol2,irescol1,
         -      irescol2,iqcol1,iqcol2,charge,iatnum,nneig,ineig,indexdel,
         -      6,maxng,maxrec)
              natsdel=0
              nwrmax=0
              do ia=1,n
                if (indexdel(ia) .eq. 1) then
                  indexs(ia)=0
                  natsdel=natsdel+1
                else
                  nwrmax=ia
                end if
              end do
              if (natsdel .gt. 0) then
                ireorder=1
                write (6,1001) natsdel,n-natsdel,nwrmax
              else
                write (6,*) 'NOTE: all atoms are kept'
              end if
            end if
          else if (ans .eq. 'r') then
            ireorder=1
            nwrmax=n
            call quiz(seqtyp,ieqtyp,'s',' ',0,'sequence file type',18,0,5,6,
         -    119)
            call zeroiti(indexn,0,n)
            lreffile=0
            if (seqtyp .eq. 's') then
              call openfile(69,0,'index',5,'old',reffile,lreffile,
         -      notfnd,1,1,1,0,0)
              if (notfnd .gt. 0) go to 103
              do ia=1,n
                read(69,1007,end=300) indexs(ia)
                if (indexs(ia) .eq. 0) then
                  nomatch=nomatch+1
                  write (6,1002) ia
                else
                  indexn(indexs(ia))=1
                end if
              end do
            else if (seqtyp .eq. 'p') then
              call openfile(69,0,'index PDB',9,'old',reffile,lreffile,
         -      notfnd,1,1,1,0,0)
              if (notfnd .gt. 0) go to 103
              ia=0
              do while (.true.)
                read(69,1000,end=410) lineinp
                if (lineinp(1:4) .eq. 'ATOM' .or.
         -          lineinp(1:6) .eq. 'HETATM') then
                  ia=ia+1
                  read (lineinp(7:11),*) indexs(ia)
                  if (indexs(ia) .eq. 0) then
                    nomatch=nomatch+1
                    write (6,1002) ia
                  else
                    indexn(indexs(ia))=ia
                  end if
                end if
              end do
    410       if (ia .eq. 0) then
                write (6,1024) reffile(1:lreffile),'PDB'
                go to 103
              end if
              print *,'Read ',ia,' atom records'
            else if (seqtyp .eq. 'c' .or. seqtyp .eq. 'l') then
              call openfile(69,0,'index CRD',9,'old',reffile,lreffile,
         -      notfnd,1,1,1,0,0)
              if (notfnd .gt. 0) go to 103
              nl=0
              do while (lineinp(1:1) .eq. '*' .or. nl .eq. 0)
                read(69,1000,end=500) lineinp
                nl=nl+1
              end do
              if (nl .eq. 1) then
                write (6,1024) reffile(1:lreffile),'Charmm'
                go to 103
              end if
    500       if (seqtyp .eq. 'c') read (lineinp(1:5),*) natread
              if (seqtyp .eq. 'l') read (lineinp(1:10),*) natread
              print *,'Reading ',natread,' atom reacords'
              do ia=1,natread
                read(69,1000,end=400) lineinp
                if (seqtyp .eq. 'c') read (lineinp(1:5),*) indexs(ia)
                if (seqtyp .eq. 'l') read (lineinp(1:10),*) indexs(ia)
                if (indexs(ia) .eq. 0) then
                  nomatch=nomatch+1
                  write (6,1002) ia
                else
                  indexn(indexs(ia))=ia
                end if
              end do
            end if
    400     nz=0
            do ia=1,n
              if (indexn(ia) .eq. 0) then
                nz=nz+1
                write (6,1005) ia
              end if
            end do
            close (69)
            if (nomatch .gt. 0) write (6,1006) nomatch,reffile(1:lreffile)
            if (nz .gt .0) then
              write (6,1004) nz,reffile(1:lreffile)
              stop
            end if
          else if (ioutrajtyp .gt. 3) then
            print *,'Sorry, this option currently only works with PDB or ',
         -    'Charmm or binary MMC files'
            stop
          else
            ireorder=1
            nwrmax=n
            print *,'Specify a structure with the output ordering'
            lreffile=0
            call openfile(69,0,'reference order',15,'old',reffile,lreffile,
         -    notfnd,1,1,1,0,0)
            if (reffile(lreffile-3:lreffile) .eq. '.pdb') then
              ireftyp=iobpdb
              print *,'PDB format assumed'
            else if (reffile(lreffile-3:lreffile) .eq. '.CRD') then
              ireftyp=iocha
              print *,'Charmm CRD format assumed'
            else
              call quiz(reftyp,ireftyp,' ','template',8,
         -      'file form (PDB or CRD)',22,0,5,6,0)
            end if
            if (ireftyp .eq. iocha .or. ireftyp .eq. iochaex) then
              nccol=4
              lineinp(1:1)='*'
              segid_prev='    '
              nsegm=0
              do while (lineinp(1:1) .eq. '*')
                read (69,1000,end=1069) lineinp
              end do
              if (ireftyp .eq. iocha) call readint(lineinp,1,5,nref,4,1,
         -      irerr)
              if (ireftyp .eq. iochaex) call readint(lineinp,1,10,nref,4,1,
         -      irerr)
              do ia=1,nref
                read (69,1000,end=1069) lineinp
                resout(ia)='    '
                resout(ia)(1:nrescol)=
         -        lineinp(iirescol(1,ireftyp):iirescol(2,ireftyp))
                namout(ia)=lineinp(iinamcol(1,ireftyp):iinamcol(2,ireftyp))
                read (lineinp(iiresncol(1,ireftyp):iiresncol(2,ireftyp)),*)
         -        ires_ref(ia)
                segid='    '
                segid=lineinp(iisegcol(1,ireftyp):iisegcol(2,ireftyp))
                if (segid .ne. segid_prev) then
                  nsegm=nsegm+1
                  segid_prev=segid
                end if
                isegno_ref(ia)=nsegm
              end do
            else
              nccol=1
              nref=0
              chainid_prev=' '
              nsegm=0
              do while (.true.)
                read (69,1000,end=101) lineinp
                if (lineinp(1:4) .eq. 'ATOM' .or.
         -          (iha .eq. 1 .and. lineinp(1:6) .eq. 'HETATM')) then
                  nref=nref+1
                  resout(nref)='    '
                  resout(nref)(1:nrescol)=
         -          lineinp(iirescol(1,ireftyp):iirescol(2,ireftyp))
                  namout(nref)=
         -          lineinp(iinamcol(1,ireftyp):iinamcol(2,ireftyp))
                  read (lineinp(iiresncol(1,ireftyp):iiresncol(2,ireftyp)),
         -          *) ires_ref(nref)
                  chainid=lineinp(iisegcol(1,ireftyp):iisegcol(2,ireftyp))
                  if (chainid .ne. chainid_prev) then
                    nsegm=nsegm+1
                    chainid_prev=chainid
                  end if
                  isegno_ref(nref)=nsegm
                end if
              end do
            end if
    101     close (69)
            if (nref .gt. n) then
              write (6,1018) nref,n
              stop
            end if
            call getdupindex(nsegm,segid4,ixseg2)
            print *,'Establishing the input and output name conventions'
            call initnamconv(noconv)
            nrecdel=0
            nrch=0
            nach=0
            isegno_prev=0
            nsegm=0
            do ia=1,n
              if (isegno(ia) .ne. isegno_prev) then
                nsegm=nsegm+1
                segid4(nsegm)='    '
                segid4(nsegm)=line(index(ia))
         -        (iisegcol(1,inpcrdtyp):iisegcol(2,inpcrdtyp))
                isegno_prev=isegno(ia)
              end if
              resold='     '
              resold(1:nrescol)=line(index(ia))(irescol1:irescol2)
              namold='     '
              namold(1:nnamcol)=line(index(ia))(inamcol1:inamcol2)
              atnam4=namold(1:4)
              if (namold(5:5) .ne. ' ') atnam4=namold(2:5)
              resnam4=resold(1:4)
              if (resold(5:5) .ne. ' ') resnam4=resold(2:5)
              if (noconv .eq. 0) then
                call namconv(nrescol,resnam4,atnam4,resnam4n,atnam4n,nrch,
         -        nach,line(index(ia)),idcol,nrecdel)
                resin(ia)=resnam4n
                namin(ia)=atnam4n
              else
               resin(ia)=resnam4
               namin(ia)=atnam4
              end if
            end do
            call getdupindex(nsegm,segid4,ixseg1)
            call residue_contig(n,iresno,isegno,index1,ixseg1,indexo,
         -    indexn,indexs,indexdel,ih,maxrsd,maxrec)
            call set_res_lim(iresno,n,ifres,ilres,nres,index1,1,maxrsd,
         -    maxrec)
            call residue_contig(nref,ires_ref,isegno_ref,index2,ixseg2,
         -    indexo,indexn,indexs,indexdel,ih,maxrsd,maxrec)
            call set_res_lim(ires_ref,nref,ifres_ref,ilres_ref,nres_ref,
         -    index2,1,maxrsd,maxrec)
            reffile=reffile(1:lreffile)//'.sort'
            lreffile=lreffile+5
            call openfile(69,0,'order',5,'new',reffile,lreffile,notfnd,
         -    0,1,1,0,0)
            call zeroiti(indexn,0,n)
            call zeroiti(indexs,0,n)
            ir_ref_prev=0
            ir_ref=1
            ifres_ref(nres_ref+1)=ifres_ref(nres_ref)
            do ir=1,nres
              ir_ref=ir_ref_prev+1
              do while (resin(index1(ifres(ir))) .ne.
         -              resout(index2(ifres_ref(ir_ref)))
         -      .and. ir_ref .le. nres_ref)
                ir_ref=ir_ref+1
              end do
              if (resin(index1(ifres(ir))) .ne.
         -        resout(index2(ifres_ref(ir_ref)))) go to 210
              ir_ref_prev=ir_ref
              do iaa=ifres(ir),ilres(ir)
                ia=index1(iaa)
                do jaa=ifres_ref(ir_ref),ilres_ref(ir_ref)
                  ja=index2(jaa)
                  if (indexn(ja) .eq. 0) then
                    if (namin(ia) .eq. namout(ja)) then
                      indexn(ja)=ia
                      go to 200
                    end if
                  end if
                end do
                nomatch=nomatch+1
    200         continue
              end do
            end do
    210     if (ir_ref .gt. nres_ref) write (6,1010) ir
            do ia=1,n
              indexs(ia)=indexn(ia)
            end do
            noorder=0
            do ia=2,nref
              if (indexs(ia) .ne. indexs(ia)+1) noorder=noorder+1
            end do
            if (noorder .eq. 0) then
              print *,'NOTE: matching kept the original atom order'
              if (n .eq. nref) ireorder=0
            end if
            do ia=1,n
              if (indexs(ia) .gt. 0) then
                lineinp=line(index(indexs(ia)))(1:80)
                resold='     '
                resold(1:nrescol)=lineinp(irescol1:irescol2)
                namold='     '
                namold(1:nnamcol)=lineinp(inamcol1:inamcol2)
                write (69,1021) ia,resout(ia),namout(ia),
         -        resold, namold,indexs(ia)
              else
                write (69,1021) ia,resout(ia),namout(ia),
         -        '****','****',indexs(ia)
              end if
            end do
            write (6,1023) reffile(1:lreffile)
            close (69)
            if (nomatch .gt. 0) then
              write (6,1008) nomatch,reffile(1:lreffile)
              print *,'You may try to modify ',reffile(1:lreffile),
         -      ' and use it to specify the new order'
              call askyn('Do you want to try matching again',33,1,1,newm,0,
         -      0)
              if (newm .gt. 0) go to 103
              print *,'Output trajectory will contain only the matched ',
         -      'atoms'
            else
              print *,'All atoms matched successfully'
            end if
          end if
          call opentraj(c,1,inpt,inptrajtyp,n,ntitltr,trtitle,
         -  inpcrdtyp,ifirst,ilast,increment,maxconf,
         -  ninconf,noutconf,natom,nfreeat,ifree,icntrl,1,mmctrajtyp,
         -  trajnam,ltrajnam,'input trajectory',16,iconfsel,numsel,
         -  1-irepcall,0,0,0,icellfound,notfnd,0,0,lentest_ok,0,ianaltyp,
         -  mx2d,maxconfsel,maxrec)
    102   if (irepcall .eq. 0) then
            if (icellfound .eq. 1) then
              write (6,1012)
              call askyn('Do you want to override the cell size/shape',43,
         -      1,-1,ipbcinp,0,0)
            end if
            if (ipbcinp .eq. 1 .or. icellfound .eq. 0) then
              call setpbccell('',0,edge,edge_gen,cell,ncell,cellalt,
         -      ixyzhex,npbc,ioppbc,iusepbc,vol,nw,rinscr,rcirc,0)
              call trnsfr(cell0,cell,3*ncell)
            end if
          end if
          irot_to=0
          if (icellfound .eq. 1 .and. ipbcinp .eq. 0) then
            if (irepcall .eq. 0) call pbctype(ioppbc,npbc,ixyzhex,0)
            if (inptrajtyp .eq. 1) then
              if (ioppbc .eq. 5) then
                edge(1)=xtlabc0(ixcrd(3))
                edge(2)=xtlabc0(ixcrd(2))
                edge(3)=xtlabc0(ixcrd(1))
                if (ioutrajtyp .ne. inptrajtyp) print *,'WARNING: Skewed ',
         -        'hexagon cell parameters will not be properly converted'
              else
                do k=1,3
                  edge(k)=xtlabc0(ixcrd(k))
                end do
              end if
            else
              call trnsfr(edge,box0,3)
            end if
            tofac=1.0
            ichangeconv=0
            if (ioppbc .eq. 6) then
              call askyn(
         -      'Is the input PBC TO cell in the Amber convention',48,1,-1,
         -      ichangeconv,0,0)
              if (ichangeconv .eq. 1) then
                irot_to=-1
                tofac=tofac_ac
                write (6,1013) 'Charmm'
              end if
            else if (ioppbc .eq. 7) then
              call askyn(
         -      'Is the input PBC TO cell in the Charmm convention',49,1,-1,
         -      ichangeconv,0,0)
              if (ichangeconv .eq. 1) then
                irot_to=1
                tofac=tofac_ca
                write (6,1013) 'Amber'
              end if
            end if
            if (ichangeconv .eq. 0 .and. (ioppbc .eq. 6 .or. ioppbc .eq. 7))
         -    write (6,*) 'NOTE: TO cell orientation read will be kept'
            if (ioppbc .eq. 6) then
              do k=1,3
                edgexyz(k)=edge(k)/2.0
              end do
            else if (ioppbc .eq. 7) then
              do k=1,3
                edgexyz(k)=tofac_ac*edge(k)/2.0
              end do
            else
              call trnsfr(edgexyz,edge,3)
            end if
            call crorgn(edgexyz,edge_gen,ioppbc,3,ncell,cell,cellalt,
         -    ixyzhex,rinscr,rcirc)
            call trnsfr(cell0,cell,3*ncell)
            write (6,1016) edgexyz
            if (ioppbc .gt. 0) iusepbc=1
          end if
          if (ioppbc .eq. 6 .and. inptrajtyp .eq. 2) then
            print *,'Truncated Octahedron type conflicts with input ',
         -    'trajectory type'
            call askyn('Do you want to continue',23,1,-1,icont,20,0)
            if (icont .eq. 0) go to 102
          end if
          itrajrot=0
          call unitmat(trajrot)
          if (nooptquiz .eq. 0) then
            if (irot_to .ne. 0) write (6,1015)
            call askyn(
         -    'Do you want to rotate each snapshot of the trajectory',
         -    53,1,-1,itrajrot,97,0)
            if (itrajrot .gt. 0) then
              itrajsuperimp=0
              call genrot(trajrot,pi,iax,angle)
            else if (isuperimpask .eq. 1) then
              call askyn(
         -   'Do you want to superimpose each frame to the input structure',
         -      60,1,-1,itrajsuperimp,0,6)
              if (itrajsuperimp .gt. 0) then
                write (6,1025)
                call askyn('Do you want to select atoms for overlay',39,
         -          1,-1,ieditoverlay,69,0)
                if (ieditoverlay .gt. 0) then
                  call select(line,nrecdel,idcol,asterisk,n,nslt,index,
         -          ixres,is1,is2,iseqncol1,iseqncol2,inamcol1,inamcol2,
         -          irescol1,irescol2,iqcol1,iqcol2,charge,iatnum,
         -          nneig,ineig,indexdel,6,maxng,maxrec)
                  call masktolist(indexsup,indexdel,n,nfinalov,0)
                else
                  ndel=0
                  do ia=1,nwrmax
                    if (indexs(ia) .eq. 0) then
                      ndel=ndel+1
                    else
                      indexsup(ia-ndel)=indexs(ia)
                    end if
                  end do
                  nfinalov=nwrmax-ndel
                end if
              endif
            end if
            ipbcreset=0
            if (itrajsuperimp .eq. 1) then
              call trnsfr(co,c,3*n)
            else if (iusepbc .gt. 0) then
              call askyn(
         -      'Do you want to reset all molecules into the PBC cell',52,
         -      -1,1,ipbcreset,0,0)
            else
              call setpbccell(
         -      'Do you want to reset all molecules into the PBC cell',52,
         -      edge,edge_gen,cell,ncell,cellalt,ixyzhex,npbc,
         -      ioppbc,ipbcreset,vol,nw,rinscr,rcirc,0)
              call trnsfr(cell0,cell,3*ncell)
            end if
            if (ipbcreset .gt. 0 .and.
         -      (ioppbc .eq. 6 .or. ioppbc .eq. 7)) then
              call askyn('Do you want to try both TO orientations',39, -1,1,
         -      icellalt,137,0)
            end if
          end if
          if (irot_to .eq. -1) then
            call matprod(trajrot,torot_ac,trajrot)
            itrajrot=1
          else if (irot_to .eq. 1) then
            itrajrot=1
            call matprod(trajrot,torot_ca,trajrot)
            itrajrot=1
          end if
          imcenter=0
          if (ipbcreset .gt. 0) then
            call setpbcdim(ioppbc,ixyzhex,ixyzexcld,ixyzincld,xyz)
            call setrepats(nmolslt,molsltlim,nslt,nneig,ineig,
         -    molresflag,minresflag,indexn,indexo,maxng,maxrsd)
            call quiz(ans,iansrun,'o',' ',0,
         -    'origin of the modified cell',27,0,5,6,0)
            if (ans .eq. 'o') then
              ishiftpbc=0
            else if (ans .eq. 'c') then
              call getxyz('',0,' component',10,999999.0,shiftpbc,0,0)
              ishiftpbc=1
            else if (ans .eq. 'a') then
              call getint('Atom index of the atom to be at the center',42,
         -      1,1,n,iacent,0)
              ishiftpbc=2
            end if
            if (ans .ne. 'a' .and. nmolslt .gt. 1) then
              call askyn(
         -      'Do you want to specify the solute molecule in the center',
         -        56,1,-1,imcenterset,0,0)
              if (imcenterset .eq. 1) call getint('Solute molecule number',
         -      22,1,1,nmolslt,imcenter,0)
            end if
            call prtcell(ioppbc,edge,edge_gen,r,vol,nw,1)
          else if (ioppbc .eq. 1 .or. ioppbc .eq. 2) then
            idef=+1
            if (inptrajtyp .eq. ioutrajtyp) idef=-1
            if (ioutrajtyp .eq. 2 .and. nooptquiz .eq. 0) then
              call askyn(
         -      'Do you want to shift the origin to the box corner',
         -      49,1,idef,ishiftocrn,0,0)
              if (ishiftocrn .gt. 0) shfac=+1.0
            end if
            if (ishiftocrn .eq. 0 .and. inptrajtyp .eq. 2) then
              call askyn(
         -      'Do you want to shift the origin to the box center',
         -      49,1,idef,ishiftocnt,0,0)
              if (ishiftocnt .gt. 0) shfac=-1.0
            end if
          end if
          do k=1,3
            box(k)=edge(k)
            xtlabc(ixcrd(k))=edge(k)
            xtlabc(ixang(k))=90.0
            edgexyz(k)=edge(k)/2.0
          end do
          if (noboxinfoar .eq. 0 .and. ipbcreset .eq. 1)
         -  write (6,1009)
          if (numsel .gt. 0) nextconfsel=1
          ifttyp=iftrajtyp(ioutrajtyp)
          if (ioutrajtyp .eq. 3 .and. mmctrajtyp .eq. 1) ifttyp=2
          call openfile(iout,0,'output trajectory',17,'new',outfile,namleno,
         -  notfnd,0,ifttyp,1,0,0)
          if (ioutrajtyp .eq. 1) then
            ifound=0
            i=ntitltr-1
            do while (i .gt. 1 .and. ifound .eq. 0)
              if (trtitle(i)(1:41) .eq.
         -       'Simulaid converted the trajectory in file') then
                trtitle(i+1)=trajnam(1:ltrajnam)
                ifound=1
              end if
              i=i-2
            end do
            if (ifound .eq. 0 .and. ntitltr .lt. 30) then
              trtitle(ntitltr+1)=
         -      'Simulaid converted the trajectory in file'
              trtitle(ntitltr+2)=trajnam(1:ltrajnam)
              ntitltr=ntitltr+2
            end if
          end if
          if (ioutrajtyp .le. 2) then
            if (ioutrajtyp .eq. 2) ntitltr=1
            write (6,1026) title,(trtitle(i),i=1,ntitltr)
            if (ioutrajtyp .eq. 2) then
              call askyn('Do you want to use the structure title for both',
         -      47,1,1,irep,0,0)
              if (irep .eq. 1) trtitle(1)=title
            else
              call askyn('Do you want to add the structure title',
         -      38,1,1,irep,0,0)
              if (irep .eq. 1) then
                ntitltr=min0(32,ntitltr+1)
                trtitle(ntitltr)=title
              end if
            end if
          end if
          nntest=0
          nr50=0
          nr50t=0
          ielim=1
          neskip=0
          do while (ninconf .lt. ilast)
            call readtraj(inpt,inptrajtyp,mmctrajtyp,n,naslv,nwatr,nslt,
         -    trajformatname(inptrajtyp),ntitltr,trtitle,trajnam,ltrajnam,
         -    natom,nfreeat,ifree,icntrl,c,ninconf,noutconf,
         -    increment,inpcrdtyp,ietot,etot,ifail,ifirst,ilast,iconfsel,
         -    numsel,maxrepconf,nmc,lentest,tofac,maxconf,maxconfsel,maxrec)
            if (ifail .gt. 0) stop
            icsel=0
            if (numsel .eq. 0) then
              if (ninconf .ge. ifirst .and.
         -      mod(ninconf-ifirst,increment) .eq. 0) icsel=1
              ifpr=ifirst
            else
              ifpr=iconfsel(nextconfsel)
              if (ninconf .eq. ifpr) then
                icsel=1
                nextconfsel=nextconfsel+1
              else if (ifpr .eq. 0) then
                ninconf=ilast+increment
              end if
            end if
            if (ietot .eq. 1) then
              if (ielim .eq. 1) then
                call askyn('Do you want to give an energy threshold (max)',
         -        45,1,-1,iemax,0,0)
                if (iemax .eq. 1)
         -        call getreal('Energy maximum to use',21,0.0,emax,0,0)
                ielim=0
              end if
              if (iemax .eq. 1 .and. etot .gt. emax) then
                if (icsel .eq. 1) neskip=neskip+1
                icsel=0
              end if
            end if
            if (ninconf .eq. 1 .and. ifpr .gt. 25) print *,
         -    'Searching for first configuration to write - wait ...'
            if (icsel .gt. 0) then
              noutconf=noutconf+1
              if (nntest .eq. 0) then
                call comparetop(c,n,nneig,ineig,iatnum,innlist,nslt,
         -        naslv,cell,ncell,ioppbc,maxng,maxrec)
                nntest=1
              end if
              if (ipbcreset .eq. 1) then
                if (noboxinfoar .eq. 0) call updatecell(inptrajtyp,edge)
                call systemcenter(n,nmolslt,nmolsltnoion,molsltlim,c,c2,
         -        indexn,atwtemp,cell,ncell,cellalt,icellalt,ixyzexcld,
         -        ixyzincld,nslt,naslv,iacent,imcenter,imcenter_set,
         -        noutconf,maxrec,maxrsd)
              end if
              if (itrajsuperimp .gt. 0) then
                call bestoverlay(nfinalov,indexsup,indexsup,co,c,atw,0.d0,
         -        c1,c2,temp,rot,c0,crm,0,0.001,0,maxrec)
                call shiftmol(c,n,crm,c1,-1.0)
                call rotate_c(c1,n,rot,c2,'OVERLAY',7)
                call shiftmol(c2,n,c0,c,+1.0)
              else if (itrajrot .gt. 0) then
                call rotate_c(c,n,trajrot,c,'CONVTRAJ',8)
              end if
              if (ishiftocrn+ishiftocnt .ne. 0)
         -      call shiftmol(c,n,edgexyz,c,shfac)
              call maketraj(noutconf,maxconf,c,c1,rprox,cv,ih,nslt,n,naslv,
         -      islvw,ntitltr,trtitle,line,altcol,inscol,ninsres,inpcrdtyp,
         -      0,inptrajtyp,ioutrajtyp,mmctrajtyp,iout,iatnum,ifchrg,
         -      innlist,iresno,ixres,atnames,resnames,segnames,charge,
         -      isegno,marker,ntitlin,title,ireseq,iresnrestart,
         -      iresidrestart,nneig,nneiga,nhbneig,ineig,nhneig,nnneig,
         -      ncneig,nsneig,npneig,numres,numslv,resnamslv,blankline,
         -      mmtype,ibnd,index,indexn,indexo,indexs,icntrlw,icntrl,ifree,
         -      molresflag,idupl,itemp1,ireorder,icellfound,natsdel,nwrmax,
         -      hblimfac,angmin,iqspaceask,keeprem,iwriteatsym,radtodeg,
         -      etot,nooptquiz,maxrepconf,maxng,mxres,maxrec)
              if (nextconfsel .gt. numsel) go to 9999
            end if
            if (ilast .ne. 999999 .and. ilast .ge. 1000) then
              ilast10=ilast/10
              if (mod(ninconf,ilast10) .eq. 0)
         -      print *,(ninconf/ilast10)*10,'% done'
            end if
          end do
          if (neskip .gt. 0) write (6,1027) emax,neskip,ninconf,noutconf
          return
    300   write (6,1003) ia,reffile(1:lreffile),nomatch
          return
    9999  write (6,1011) noutconf
          return
    1069  write (6,1019)
          stop
    1000  format(a)
    1001  format(' Editing deleted',i7,' atoms. Number of atoms left=',i8,
         -  /,' Highest index of kept atoms=',i8)
    1002  format(' Target atom',i6,' has no original atom assigned to it')
    1003  format(' ERROR: file ',a,' contained only',i7,' matches',/,
         -  8x,'Number of missing matches found=',i5)
    1004  format(' ERROR:',i5,' original atoms are unassigned in file ',a)
    1005  format(' Original atom',i6,' is not assigned a new index')
    1006  format(' NOTE:',i5,' target atoms missing matches in file ',a,/,
         -  6x,'- output trajectory will contain only the matcehd atoms')
    1007  format(59x,i7)
    1008  format(' Matching failed for ',i5,' atoms',/,
         -  ' NOTE: see the file ',a,' for more info.',/,
         -  7x,'You can edit this file to complete the matches')
    1009  format(' Note: Make sure that the PBC information read from ',
         -  'the trajectory',/,
         -  ' is in the same convention as the PBC size specified above')
    1010  format(' WARNING: run out of template residues at the',i6,'-th',
         -  ' input residue')
    1011  format(' Completed writing of the new trajectory with ',i6,
         -  ' configurations')
    1012  format(' Periodic cell information was found')
    1013  format(' NOTE: TO cell will be rotated to conform to the ',a,
         -  ' convention')
    1014  format(' WARNING: trajectory interconversion leaves ',
         -  'the atom order unchanged')
    1015  format(' NOTE: periodic cell will be rotated to follow Charmm vs',
         -  ' Amber/NAMD convention',/,7x,'You can add an additional ',
         -  'rotation.')
    1016  format(' Cell parameters are set from the trajectory to',/,3f10.5)
    1018  format(' ERROR: number of atoms in the reference system (',
         -  i5,')',/,8x,'is more than the input system (',i5,')')
    1019  format(' ERROR: reference configuration file is incomplete')
    1021  format(' Target: #=',i7,' R=',a5,' N=',a5,
         -       ' Orig: R=',a5,' N=',a5,' #=',i7)
    1023  format(' Matching found between the two structures is written ',
         -  'to file:',/,5x,a)
    1024  format(' ERROR: file ',a,' is not a ',a,' file')
    1025  format(' NOTE: superimposing to the input structure contradicts ',
         -  'PBC resets.',/,' If PBC resets are needed, perform it first ',
         -  ' followed by an other run',/,' performing the superimposition',
         -  ' without declaring any',/,' mobile ion or mobile solute ',
         -  'molecule')
    1026  format(' Current structure title:',/,1x,a,/,
         -  ' Current trajectory title:',(/,1x,a))
    1027  format(' Number of frames filtered out with E > ',e12.5,':',i4,/,
         -  ' Number of frames read=',i6,' Number of frames written=',i6)
          end
          subroutine filterslv(c,ian,nslt,n,naslv,numsolv,molsltlim,nsegslt,
         -  index,nconfig,ifilttyp,intftyp,rsltmax,rcvmax,cvmin,ang12min1,
         -  ang12min2,r12max,cvrlim,rneigh,mol11,mol12,mol21,mol22,spacing,
         -  ixdrop,iarepslv,numsolvleft,nhbneig,ineig,ixres,nrecdel,ierr,
         -  iout,mxrec,maxng)
          dimension c(3,n),ian(n),index(n),molsltlim(3,nsegslt),
         -  ixdrop(mxrec),nhbneig(mxrec),ineig(maxng,mxrec),
         -  ixres(mxrec)
          parameter(MAXREC=200000,MAXPHI=400,IFILL10=MAXPHI**3-26*MAXREC)
          real*8 cvsums,cvsums2
          common /nnwork/ cvsums(3,MAXREC),cvsums2(3,MAXREC),
         -  ncvsums(MAXREC),ncvsums2(MAXREC),rnearsq(MAXREC),ianear(MAXREC),
         -  cv(MAXREC),rnearsq2(MAXREC),ianear2(MAXREC),cv2(MAXREC),
         -  indexs(MAXREC),ifirst(MAXREC),ilast(MAXREC),
         -  itemp1(MAXREC),itemp2(MAXREC),itemp3(MAXREC),fill(IFILL10)
          dimension r1(3),r2(3)
          real*8 cvsum(3)
          nrecdel=0
          if (n .le. nslt) then
            write (iout,2001)
            ierr=1
            return
          end if
          if (ifilttyp .gt. 1) rsltmax=amax1(rsltmax,rcvmax,10.0)
          rsltmaxsq=rsltmax**2
          rcvmaxsq=rcvmax**2
          r12maxsq=r12max**2
          rneigh2=rneigh**2
          rminmin=999999.0
          cang12min1=cos(ang12min1*3.141592/180.0)
          cang12min2=cos(ang12min2*3.141592/180.0)
          call zeroiti(ixdrop,0,numsolv)
          if (ifilttyp .le. 3) then
            call calc_cv_rmin(c,ian,nslt,1,nslt,n,numsolv,naslv,iarepslv,
         -    spacing,rsltmax,rcvmax,cvmin,rnearsq,ianear,cv,cvsums,ncvsums,
         -    nconfig,indexs,ifirst,ilast,itemp1,itemp2,itemp3,iout,mxrec)
            do is=1,numsolv
              if (ifilttyp .gt. 1 .and. cv(is) .le. cvmin) ixdrop(is)=1
              if (rsltmax .gt. 0.0 .and. rnearsq(is) .gt. rsltmaxsq)
         -        ixdrop(is)=1
              if (rnearsq(is) .lt. rminmin) rminmin=rnearsq(is)
            end do
          else if (ifilttyp .eq. 4) then
            do is=1,numsolv
              ixdrop(is)=1
            end do
            nkeep=0
            incr=nslt
            idebug=0
            mol2fst=mol21
            do mol1=mol11,mol12
              call calc_cv_rmin(c,ian,nslt,molsltlim(1,mol1),
         -      molsltlim(2,mol1),n,numsolv,naslv,iarepslv,spacing,rsltmax,
         -      rcvmax,cvmin,rnearsq,ianear,cv,cvsums,ncvsums,nconfig,
         -      indexs,ifirst,ilast,itemp1,itemp2,itemp3,iout,mxrec)
              if (intftyp .eq. 3) mol2fst=mol1+1
              do mol2=mol2fst,mol22
                if (mol1 .ne. mol2) then
                  call calc_cv_rmin(c,ian,nslt,molsltlim(1,mol2),
         -          molsltlim(2,mol2),n,numsolv,naslv,iarepslv,spacing,
         -          rsltmax,rcvmax,cvmin,rnearsq2,ianear2,cv2,cvsums2,
         -          ncvsums2,nconfig,indexs,ifirst,ilast,itemp1,itemp2,
         -          itemp3,iout,mxrec)
                  nkeepij=0
                  do is=1,numsolv
                    ikeep=0
                    if (idebug .gt. 0) write (76,9671) is,rnearsq(is),
         -            rnearsq2(is),ianear(is),ianear2(is)
                    if (ianear(is)*ianear2(is) .gt. 0) then
                      d12sq=dist2(c(1,ianear(is)),c(1,ianear2(is)))
                      if (idebug .gt. 0) write (76,*) is,' D=',d12sq
                      if (d12sq .le. r12maxsq) then
                        rlpsum=0.0
                        do k=1,3
                          r1(k)=c(k,ianear(is))-c(k,incr+iarepslv)
                          r2(k)=c(k,ianear2(is))-c(k,incr+iarepslv)
                          rlpsum=rlpsum+r1(k)*r2(k)
                        end do
                        ac=rlpsum/sqrt(abs(rnearsq(is)*rnearsq2(is)))
                        r1sq=r1(1)**2+r1(2)**2+r1(3)**2
                        r2sq=r2(1)**2+r2(2)**2+r2(3)**2
                        if (idebug .gt. 0) write (76,*) is,' AC=',ac,
         -                ' R1SQ,R2SQ=',r1sq,r2sq
                        cang12min=cang12min1
                        if (d12sq .gt. 36.0) cang12min=cang12min2
                        if (ac .lt. cang12min) then
                          if (idebug .gt. 0)
         -                  write (76,9672) is,cv(is),cv2(is),amax1(cv(is),
         -                    cv2(is))/amin1(cv(is),cv2(is))
                          if (amax1(cv(is),cv2(is))/amin1(cv(is),cv2(is))
         -                    .lt. cvrlim) then
                            do k=1,3
                              cvsum(k)=cvsums(k,is)+cvsums2(k,is)
                            end do
                            cv12=1.d0-
         -                    dsqrt(cvsum(1)**2+cvsum(2)**2+cvsum(3)**2)/
         -                    dfloat(ncvsums(is)+ncvsums2(is))
                            if (idebug .gt. 0) write (76,*) is,' CV12=',cv12
                            if (cv12 .gt. cvmin) then
                              ikeep=1
                            end if
                          end if
                        end if
                      end if
                    end if
                    if (idebug .gt. 0) write (76,*) is,' IXDROP=',ixdrop(is)
                    if (rnearsq(is) .lt. rminmin) rminmin=rnearsq(is)
                    if (rnearsq2(is) .lt. rminmin) rminmin=rnearsq2(is)
                    incr=incr+naslv
                    if (ikeep .eq. 1) nkeepij=nkeepij+1
                    if (ikeep .eq. 1 .and. ixdrop(is) .eq. 1) then
                      ixdrop(is)=0
                      nkeep=nkeep+1
                      itemp1(nkeep)=is
                    end if
                  end do
                  if (intftyp .gt. 1)
         -          write (6,2005) nconfig,mol1,mol2,nkeepij
                end if
              end do
            end do
            nempty=0
            do is=1,numsolv
              if (ixdrop(is) .eq. 0) then
                if (amax1(rnearsq(is),rnearsq2(is)) .gt. rneigh2) then
                  nn=0
                  do iss=1,nkeep
                    is2=itemp1(iss)
                    if (is .ne. is2 .and. ixdrop(iss) .eq. 0) then
                      if (dist2(c(1,nslt+(is-1)*naslv+iarepslv),
         -              c(1,nslt+(is2-1)*naslv+iarepslv)) .le. rneigh2)
         -                nn=nn+1
                    end if
                  end do
                  if (nn .eq. 0) then
                    ixdrop(is)=1
                    nempty=nempty+1
                  end if
                end if
              end if
            end do
          else if (ifilttyp .eq. 5) then
            ia0=nslt
            do is=1,numsolv
              nhb=0
              ixdrop(is)=1
              ixres1=0
              do iaa=1,naslv
                ia=ia0+iaa
                do ihb=1,nhbneig(ia)
                  ihbslt=ineig(maxng-ihb+1,ia)
                  if (ihbslt .lt. nslt) then
                    if (nhb .eq. 0) then
                      nhb=nhb+1
                      ixres1=ixres(ihbslt)
                    else if (ixres1 .ne. ixres(ihbslt)) then
                      ixdrop(is)=0
                      go to  100
                    end if
                  end if
                end do
              end do
    100       ia0=ia0+naslv
            end do
          end if
          if (nempty .gt. 0 .and. ifilttyp .eq. 4)
         -   write (iout,2002) nconfig,nempty
          incr=nslt
          ndrop=0
          do is=1,numsolv
            if (ixdrop(is) .eq. 1) then
              ndrop=ndrop+1
            else
              do j=1,naslv
                index(incr+j-naslv*ndrop)=index(incr+j)
              end do
            end if
            incr=incr+naslv
          end do
          nrecdel=nrecdel+ndrop*naslv
          numsolvleft=numsolv-ndrop
          if (ifilttyp .lt. 5) write (iout,2003) nconfig,sqrt(rminmin)
          if (ndrop .eq. 0) then
            write (iout,*) 'NOTE: no solvent was dropped'
          else
            if (ndrop .eq. numsolv) then
              write (iout,*) 'All solvents were dropped'
            else
              write (iout,2004) nconfig,ndrop,numsolvleft
            end if
          end if
          return
    2001  format(' ERROR: there are no solvents to filter')
    2002  format(' Nconfig=',i6,':',i5,' solvents had empty neighbor ',
         -  'sphere')
    2003  format(' Nconfig=',i6,' Closest solute-solvent distance=',f6.2,
         -  ' A')
    2004  format(' Nconfig=',i6,' Number of solvents dropped=',i7,
         -  ' kept=',i6)
    2005  format(' Nconfig=',i6,' Number of interface solvents between ',
         -  'molecules',i4,' and',i4,'=',i3)
    9671  format(i5,' RNSQ,2=',2f10.3,' INEAR,2=',2i8)
    9672  format(i5,' cv,cv2=',2f6.4,' R=',f8.4)
          end
          subroutine calc_cv_rmin(c,ian,nslt,nslt1,nslt2,n,numsolv,naslv,
         -  iarepslv,spacing,rsltmax,rcvmax,cvmin,rnearsq,ianear,cv,cvsums,
         -  ncvsums,nconfig,indexs,ifirst,ilast,itemp1,itemp2,itemp3,iout,
         -  maxrec)
          dimension c(3,n),ian(n),rnearsq(maxrec),ianear(maxrec),
         -  cv(maxrec),ncvsums(maxrec),indexs(maxrec),ifirst(maxrec),
         -  ilast(maxrec),itemp1(maxrec),itemp2(maxrec),itemp3(maxrec)
          real*8 cvsums(3,maxrec)
          dimension edge(3),corner(3),ecell(3),xyzmin(3),xyzmax(3),nxyz(3),
         -  ixyz(3),ixyz1(3),ixyz2(3),d(3),cslv(3)
          real*8 cvsum(3)
          call cellpart(c,ian,itemp1,nslt1,nslt2,0.0,spacing,corner,ecell,
         -  edge,xyzmin,xyzmax,vtot,nxyz,ixyz,itemp3,itemp2,indexs,ifirst,
         -  ilast,ntotcell,0,iout,maxrec)
          if (nconfig .eq. 1)
         -  print *,'Number of boxes in the X, Y, Z direction=',nxyz
          rmax=amax1(rsltmax,rcvmax)
          rmax2=rmax**2
          rcvmax2=rcvmax**2
          if (rsltmax .eq. 0.0) call zeroit(rnearsq,numsolv)
          call zeroit(cv,numsolv)
          call zeroiti(ianear,0,numsolv)
          incr=nslt
          do is=1,numsolv
            call trnsfr(cslv,c(1,incr+iarepslv),3)
            ifar=0
            inside=0
            do k=1,3
              if (cslv(k) .lt. xyzmin(k)) then
                if (xyzmin(k)-cslv(k) .gt. rmax) then
                  ifar=1
                else
                  ixyz1(k)=0
                  ixyz20=(cslv(k)+rmax-xyzmin(k))/ecell(k)
                  ixyz2(k)=min0(nxyz(k)-1,ixyz20+1)
                end if
              else if (cslv(k) .ge. xyzmax(k)) then
                if (cslv(k)-xyzmax(k) .gt. rmax) then
                  ifar=1
                else
                  ixyz10=(cslv(k)-rmax-xyzmin(k))/ecell(k)
                  ixyz1(k)=ixyz10-1
                  ixyz2(k)=nxyz(k)-1
                end if
              else
                ixyz10=(cslv(k)-rmax-xyzmin(k))/ecell(k)
                ixyz1(k)=max0(0,ixyz10-1)
                ixyz20=(cslv(k)+rmax-xyzmin(k))/ecell(k)
                ixyz2(k)=min0(nxyz(k)-1,ixyz20+1)
                inside=inside+1
              end if
            end do
            rmin2=999999.0
            ncvsum=0
            call zeroitd(cvsum,3)
            if (ifar .eq. 0) then
              do ix=ixyz1(1),ixyz2(1)
                do iy=ixyz1(2),ixyz2(2)
                  do iz=ixyz1(3),ixyz2(3)
                    ic=1+ix+iy*nxyz(1)+iz*nxyz(1)*nxyz(2)
                    if (ifirst(ic) .gt. 0) then
                      do ia=ifirst(ic),ilast(ic)
                        rsvst2=dist2(c(1,indexs(ia)),c(1,incr+iarepslv))
                        if (rsvst2 .lt. rmin2) then
                          rmin2=rsvst2
                          ianear(is)=indexs(ia)
                        end if
                        if (rsvst2 .le. rmax2) then
                          if (cvmin .gt. 0.0) then
                            if (rsvst2 .le. rcvmax2) then
                              do k=1,3
                                d(k)=c(k,indexs(ia))-c(k,incr+iarepslv)
                              end do
                              call norm(d,1.0)
                              do k=1,3
                                cvsum(k)=cvsum(k)+d(k)
                              end do
                              ncvsum=ncvsum+1
                            end if
                          end if
                        end if
                      end do
                    end if
                  end do
                end do
              end do
            end if
            incr=incr+naslv
            rnearsq(is)=rmin2
            if (ncvsum .gt. 0) cv(is)=1.d0-
         -    dsqrt(cvsum(1)**2+cvsum(2)**2+cvsum(3)**2)/dfloat(ncvsum)
            ncvsums(is)=ncvsum
            call trnsfrd(cvsums(1,is),cvsum,3)
            if (cv(is) .gt. 1.001) then
              print *,'PROGRAM ERROR: cv > 1.0:',cv(is),' ncvsum=',ncvsum
              stop
            end if
          end do
          return
          end
          subroutine set_res_lim(ires,n,ifres,ilres,nres,index,iuseindex,
         -  maxres,maxn)
          dimension ires(maxn),ifres(maxres),ilres(maxres),index(maxn)
          if (iuseindex .eq. 0) call indexit(index,1,n,0)
          ifres(1)=1
          iresprev=ires(index(1))
          nres=1
          do ia=2,n
            if (ires(index(ia)) .ne. iresprev) then
              ilres(nres)=ia-1
              nres=nres+1
              ifres(nres)=ia
              iresprev=ires(index(ia))
            end if
          end do
          ilres(nres)=n
          return
          end
          subroutine residue_contig(n,ires,isegno,index,ixseg,isr,ifa,ila,
         -  itmp1,itmp2,maxres,max)
          dimension ires(max),isegno(max),index(max),ixseg(maxres),isr(max),
         -  ifa(max),ila(max),itmp1(max),itmp2(max)
          call indexit(index,1,n,0)
          do i=1,n
            isr(i)=(max+1)*ixseg(isegno(i))+ires(i)+1
          end do
          call mrgsrti(6,index,isr,n,ifa,ila,itmp1,itmp2,max)
          return
          end
          subroutine getdupindex(nsegm,segid4,index)
          character*4 segid4(nsegm)
          dimension index(nsegm)
          call indexit(index,1,nsegm,0)
          do is=2,nsegm
            do iss=1,is-1
              if (segid4(is) .eq. segid4(iss)) index(is)=iss
            end do
          end do
          return
          end
          subroutine splittraj_MMC_Amb(inptrajtyp,mmctrajtyp,inpcrdtyp,
         -  nslt,naslv,c,icntrl,ifree,iconfsel,title,trtitle,indexn,indexo,
         -  indexs,lentest,maxconfsel,maxrepconf,maxrec)
          character*80 title,trtitle(32)
          dimension iconfsel(maxconfsel)
          dimension icntrl(20)
          dimension c(3,maxrec),indexn(maxrec),indexo(maxrec),
         -  indexs(maxrec),ifree(maxrec)
          real*8 xtlabc,xtlabc0
          common /boxdat/ xtlabc(6),xtlabc0(6),box(3),box0(3),edge_gen(3,3),
         -  cell0(3,27),cell(3,27),cellalt(3,27),
         -  ncell,ioppbc,noboxinfoar,noboxinfow,noboxrep,
         -  istuner,iboxtypfound,ixcrd(3),ixang(3),ixyzhex(3),
         -  ixyzhextraj(3),isizewarn
          character*200 trajnam,outfile
          common /trajname/ trajnam,outfile,ltrajnam,namleno,ifirsttraj,
         -  ifirsttraj2,ilasttraj,ilasttraj2,incrementtraj,incrementtraj2
          character*11 trajformatname
          common /trajectory/ nmmccheck,iftrajtyp(6),trajformatname(6)
          character*1 xyz
          common /axislab/ xyz(3)
          if (inptrajtyp .ne. 3) then
            print *,'PROGRAM ERROR: input trajectory type is not MMC but ',
         -    trajformatname(inptrajtyp)
            return
          end if
          numsel=0
          inpt=51
          ifirst=1
          ilast=999999
          call opentraj(c,1,inpt,inptrajtyp,n,ntitltr,trtitle,
         -  inpcrdtyp,ifirst,ilast,increment,maxconf,
         -  ninconf,noutconf,natom,nfreeat,ifree,icntrl,1,mmctrajtyp,
         -  trajnam,ltrajnam,'input trajectory',16,iconfsel,numsel,
         -  0,0,0,0,icellfound,notfnd,0,0,lentest,0,ianaltyp,mx2d,
         -  maxconfsel,maxrec)
          ninconf0=ninconf
          if (noboxinfoar .eq. 0) then
            print *,'(T,P,N) run has constant number of solvents'
            return
          end if
          call askyn('Do you want to give the box size',32,0,1,nobox,0,0)
          if (nobox .eq. 0) then
            call getxyz('Box size in the ',17,' direction (A)',14,
         -    999999.0,box,1,0)
            nobox=0
            print *,'Box information is written after the first frame only'
          else
            print *,'No box information is written'
          end if
          ifail=0
          call zeroiti(indexs,0,maxrec)
          do while (ninconf .lt. ilast .and. ifail .eq. 0)
            call readtraj(inpt,inptrajtyp,mmctrajtyp,n,naslv,nwatr,nslt,
         -    trajformatname(inptrajtyp),ntitltr,trtitle,trajnam,ltrajnam,
         -    natom,nfreeat,ifree,icntrl,c,ninconf,noutconf,
         -    increment,inpcrdtyp,ietot,etot,ifail,ifirst,ilast,iconfsel,
         -    numsel,maxrepconf,nmc,lentest,tofac,maxconf,maxconfsel,maxrec)
            numsolv=(n-nslt)/naslv
            indexs(numsolv+1)=indexs(numsolv+1)+1
          end do
          call findlim(indexs,ifst,ilst,maxrec)
          write (6,1001) ifst-1,ilst-1
          do it=ifst,ilst
            if (indexs(it) .gt. 0) then
              indexo(it)=52+(it-ifst)
              lroot=ltrajnam
              if (trajnam(ltrajnam-3:ltrajnam) .eq. '.hst') lroot=lroot-4
              outfile=trajnam
              lroot=lroot+1
              outfile(lroot:lroot)='_'
              loutfile=lroot+1
              call writeint(outfile,loutfile,it-1,lenw)
              outfile(loutfile:loutfile+3)='.trj'
              loutfile=loutfile+3
              open (unit=indexo(it),status='new',form='FORMATTED',
         -      file=outfile(1:loutfile),iostat=iopen)
              if (iopen .eq. 0) then
                print *,'File ',outfile(1:loutfile),' opened'
              else
                print *,'Problem opening file ',outfile(1:loutfile)
                return
              end if
              write (title(60:79),1004) it
              write (indexo(it),1000) title
            end if
          end do
          rewind inpt
          ninconf=ninconf0
          ifail=0
          call zeroiti(indexn,ifst-1,ilst)
          do while (ninconf .lt. ilast .and. ifail .eq. 0)
            call readtraj(inpt,inptrajtyp,mmctrajtyp,n,naslv,nwatr,nslt,
         -    trajformatname(inptrajtyp),ntitltr,trtitle,trajnam,ltrajnam,
         -    natom,nfreeat,ifree,icntrl,c,ninconf,noutconf,
         -    increment,inpcrdtyp,ietot,etot,ifail,ifirst,ilast,iconfsel,
         -    numsel,maxrepconf,nmc,lentest,tofac,maxconf,maxconfsel,maxrec)
            numsolv=(n-nslt)/naslv
            indexn(numsolv+1)=indexn(numsolv+1)+1
            iout=indexo(numsolv+1)
            write (iout,1003) ((c(k,i),k=1,3),i=1,n)
            if (indexn(numsolv+1) .eq. 1 .and. nobox .eq. 0)
         -    write (iout,1003) box0
            if (ilast .ne. 999999 .and. ilast .ge. 1000) then
              ilast10=ilast/10
              if (mod(ninconf,ilast10) .eq. 0)
         -      print *,(ninconf/ilast10)*10,'% done'
            end if
          end do
          do it=ifst,ilst
            write (6,1002) it-1,indexs(it)
            close (indexo(it))
          end do
          close (inpt)
          return
    1000  format(a)
    1001  format(' The number of solvents range from ',i5,' to ',i5)
    1002  format(' Completed writing of trajectory of ',i5,' solvents ',
         -  'with ',i6,' configurations')
    1003  format(10f8.3)
    1004  format(' # of solvents=',i5)
          end
          subroutine savepdb(iu,label,llabel,c,n,mod)
          character*(*) label
          dimension c(3,n)
          parameter (MAXREC=200000)
          character*132 line(MAXREC)
          dimension index(MAXREC)
          common /line_crd/ line,index
          if (mod .le. 1) then
            open(unit=iu,status='new',file=label(1:llabel),iostat=iopen,
         -    form='formatted')
            if (iopen .gt. 0)
         -    open(unit=iu,status='old',file=label(1:llabel),iostat=iopen,
         -        form='formatted')
            if (iopen .eq. 0) then
              print *,'File ',label(1:llabel),' opened'
            else
              return
            end if
            write (iu,1002) label(1:llabel)
          end if
          if (mod .gt. 0) write (iu,1003) mod
          do ia=1,n
            write (line(index(ia))(31:54),1001) (c(k,ia),k=1,3)
            call lastchar(line(index(ia)),lc,132)
            write (iu,1000) line(index(ia))(1:lc)
          end do
          if (mod .gt. 0) then
            write (iu,1004)
          else
            close(iu)
          end if
          return
    1000  format(a)
    1001  format(3f8.2)
    1002  format('REMARK ',a)
    1003  format('MODEL ',i4)
    1004  format('ENDMDL')
          end
          subroutine systemcenter(n,nmolslt,nmolsltnoion,molsltlim,c,ct,it1,
         -  atw,cell,ncell,cellalt,icellalt,ixyzexcld,ixyzincld,nslt,naslv,
         -  iacent,imcenter_r,imcenter,nconf,mxat,maxrsd)
          dimension c(3,mxat),ct(3,mxat),molsltlim(3,maxrsd),cell(3,ncell),
         -  cellalt(3,ncell),it1(mxat),atw(mxat)
          dimension c00(3),c0(3),cmin(3),cmax(3)
          imcenter=imcenter_r
          if (iacent .eq. 0) then
            if (nconf .le. 1) then
              ndrop=0
              do ia=1,nslt
                if (atw(ia) .eq. 0.0) ndrop=ndrop+1
              end do
              print *,'Solute centering will use ',nslt-ndrop,' atoms'
            end if
            if (imcenter .eq. 0) then
              if (nmolslt .eq. 1) then
                imcenter=1
              else
                maxmolats=0
                imc_def=0
                do im=1,nmolslt
                  nmem=molsltlim(2,im)-molsltlim(1,im)+1
                  if (nmem .gt. maxmolats) then
                    maxmolats=nmem
                    imc_def=im
                  end if
                end do
                call askyn(
         -      'Do you want to specify the solute molecule at the center',
         -        56,1,-1,imcenterset,0,0)
                if (imcenterset .eq. 1) then
                  call getint('Solute molecule number',22,1,1,imc_def,
         -          imcenter,0)
                else
                  imcenter=imc_def
                  write (6,1003) imcenter
                end if
              end if
            end if
            if (molsltlim(3,imcenter) .eq. 0) then
              call extension(c,it1,0,molsltlim(1,imcenter),
         -      molsltlim(2,imcenter),cmin,cmax,c00,0,1,v)
              ncentspec=0
            else if (molsltlim(3,imcenter) .eq. -1) then
              call zeroit(c00,3)
              atwsum=0.0
              do ia=molsltlim(1,imcenter),molsltlim(2,imcenter)
                do k=1,3
                  c00(k)=c00(k)+atw(ia)*c(k,ia)
                end do
                atwsum=atwsum+atw(ia)
              end do
              if (atwsum .gt. 0.0) then
                do k=1,3
                  c00(k)=c00(k)/atwsum
                end do
              end if
            else
              call trnsfr(c00,c(1,molsltlim(3,imcenter)),3)
              ncentspec=1
            end if
            if (nconf .le. 1 .and. nmolslt .gt. 1)
         -    write (6,1001) 'molecule',imcenter
          else
            if (iacent .gt. molsltlim(2,nmolslt)) then
              write (6,1002) iacent,molsltlim(2,nmolslt)
              stop
            end if
            call trnsfr(c00,c(1,iacent),3)
            imcenter=1
            do while (molsltlim(2,imcenter) .lt. iacent)
              imcenter=imcenter+1
            end do
            if (nconf .le. 1) write (6,1001) 'atom',iacent
          end if
          if (ixyzexcld .gt. 0) c00(ixyzexcld)=0.0
          if (ixyzincld .gt. 0) then
            do k=1,3
              if (k .ne. ixyzincld) c00(k)=0.0
            end do
          end if
          call shiftmol(c,n,c00,c,-1.0)
          noshift=0
          nmolfst=1
          call molreset(nmolfst,nmolslt,nmolshift,c,ct,molsltlim,it1,
         -  cell,ncell,cellalt,icellalt,imcenter,maxrsd,mxat)
          if (noshift .eq. 1 .and. nmolshift .gt. 0 .and. nconf .le. 10)
         -  print *,'WARNING: ',nmolshift,' centered molecules were ',
         -    'shifted again after recentering'
          nsltnoion=molsltlim(2,nmolsltnoion)
          if (iacent .eq. 0 .and. noshift .eq. 0 .and. nmolslt .gt. 1) then
            if (nsltnoion .gt. 0) then
              call cofms(c,c0,nsltnoion,atw)
              call shiftmol(c,n,c0,c,-1.0)
              call arrsum(c0,c00,c0,3)
              if (nconf .le. 1) write (6,1000) c0
              nmolfst=1
              noshift=1
              call ionreset(nmolfst,nmolslt,nmolshift,c,molsltlim,it1,atw,
         -      cell,ncell,ixyzexcld,ixyzincld,maxrsd,mxat)
            end if
          end if
          nreset=0
          do is=nmolsltnoion+1,nmolslt
            call pbcreset(c(1,molsltlim(1,is)),
         -    molsltlim(2,is)-molsltlim(1,is)+1,c(1,molsltlim(1,is)),
         -    cell,ncell,ixyzexcld,ixyzincld,img)
            if (img .gt. 1) then
              nreset=nreset+1
              call pbcreset(c(1,molsltlim(1,is)),
         -      molsltlim(2,is)-molsltlim(1,is)+1,c(1,molsltlim(1,is)),
         -      cell,ncell,ixyzexcld,ixyzincld,img)
            end if
          end do
          nsw=(n-nslt)/naslv
          do iw=1,nsw
            call extension(c,it1,0,nslt+(iw-1)*naslv+1,nslt+iw*naslv,
         -    cmin,cmax,c0,0,0,v)
            call genimdist(c0,cell,1,ncell,img,d2)
            if (img .gt. 1)
         -    call shiftmol(c(1,nslt+(iw-1)*naslv+1),naslv,cell(1,img),
         -      c(1,nslt+(iw-1)*naslv+1),-1.0)
          end do
          return
    1000  format(' Aggregated solute molecules are shifted by ',3f8.3,
         -  ' A')
    1001  format(' Solute is centered around solute ',a,i6)
    1002  format(' ERROR: solute center requested (',i8,') is outside the ',
         -  'solute atom range (1 - ',i8,')')
    1003  format(' Largest solute molecule (',i6,') selected for center')
          end
          subroutine molreset(nmolfst,nmolslt,nmolshift,c,ct,molsltlim,it1,
         -  cell,ncell,cellalt,icellalt,imcenter,maxrsd,mxat)
          dimension c(3,mxat),ct(3,mxat),molsltlim(3,maxrsd),it1(mxat),
         -  cell(3,ncell),cellalt(3,ncell)
          dimension c0(3),cmin(3),cmax(3),cmincent(3),cmaxcent(3),
         -  cmin12sav(3),cmax12sav(3),cmin12(3),cmax12(3)
          call extension(c,it1,0,molsltlim(1,imcenter),
         -  molsltlim(2,imcenter),cmincent,cmaxcent,c0,0,0,v)
          nmolshift=0
          do im=nmolfst,nmolslt
            ialtopt=0
            if (im .ne. imcenter) then
              ichange=1
              do while (ichange .gt. 0)
                call extension(c,it1,0,molsltlim(1,im),molsltlim(2,im),
         -        cmin,cmax,c0,0,0,v)
                call combinevol(cmin,cmax,cmincent,cmaxcent,cmin12sav,
         -        cmax12sav,volmin)
                imgopt=1
                do img=2,ncell
                  call trnsfr(ct,c,3*molsltlim(2,nmolslt))
                  call shiftmol(c(1,molsltlim(1,im)),
         -          molsltlim(2,im)-molsltlim(1,im)+1,cell(1,img),
         -          ct(1,molsltlim(1,im)),-1.0)
                  call extension(ct,it1,0,molsltlim(1,im),molsltlim(2,im),
         -          cmin,cmax,c0,0,0,v)
                  call combinevol(cmin,cmax,cmincent,cmaxcent,cmin12,cmax12,
         -          vol)
                  if (vol .lt. volmin) then
                    volmin=vol
                    call trnsfr(cmin12sav,cmin12,3)
                    call trnsfr(cmax12sav,cmax12,3)
                    imgopt=img
                  end if
                end do
                do k=1,3
                  cmincent(k)=amin1(cmincent(k),cmin12sav(k))
                  cmaxcent(k)=amax1(cmaxcent(k),cmax12sav(k))
                end do
                if (icellalt .gt. 0) then
                  do img=2,ncell
                    call trnsfr(ct,c,3*molsltlim(2,nmolslt))
                    call shiftmol(c(1,molsltlim(1,im)),
         -            molsltlim(2,im)-molsltlim(1,im)+1,cell(1,img),
         -            ct(1,molsltlim(1,im)),-1.0)
                    call extension(ct,it1,0,molsltlim(1,im),molsltlim(2,im),
         -            cmin,cmax,c0,0,0,v)
                    call combinevol(cmin,cmax,cmincent,cmaxcent,cmin12,
         -            cmax12,vol)
                    if (vol .lt. volmin) then
                      volmin=vol
                      call trnsfr(cmin12sav,cmin12,3)
                      call trnsfr(cmax12sav,cmax12,3)
                      imgopt=img
                      ialtopt=1
                    end if
                  end do
                end if
                if (imgopt .gt. 1) then
                  ichange=1
                  if (ialtopt .eq. 0) then
                    call shiftmol(c(1,molsltlim(1,im)),
         -            molsltlim(2,im)-molsltlim(1,im)+1,cell(1,imgopt),
         -            c(1,molsltlim(1,im)),-1.0)
                  else
                    call shiftmol(c(1,molsltlim(1,im)),
         -            molsltlim(2,im)-molsltlim(1,im)+1,cellalt(1,imgopt),
         -            c(1,molsltlim(1,im)),-1.0)
                  end if
                else
                  ichange=0
                end if
              end do
            end if
          end do
          return
          end
          subroutine combinevol(cmin1,cmax1,cmin2,cmax2,cmin12,cmax12,vol)
          dimension cmin1(3),cmax1(3),cmin2(3),cmax2(3),cmin12(3),cmax12(3)
          vol=1.0
          do k=1,3
            cmin12(k)=amin1(cmin1(k),cmin2(k))
            cmax12(k)=amax1(cmax1(k),cmax2(k))
            vol=vol*(cmax12(k)-cmin12(k))
          end do
          return
          end
          subroutine ionreset(nmolfst,nmolslt,nmolshift,c,molsltlim,it1,atw,
         -  cell,ncell,ixyzexcld,ixyzincld,maxrsd,mxat)
          dimension c(3,mxat),molsltlim(3,maxrsd),it1(mxat),atw(mxat),
         -  cell(3,ncell)
          dimension c0(3),cmin(3),cmax(3)
          nmolshift=0
          do is=nmolfst,nmolslt
            if (molsltlim(3,is) .eq. 0) then
              call extension(c,it1,0,molsltlim(1,is),molsltlim(2,is),
         -      cmin,cmax,c0,0,0,v)
            else if (molsltlim(3,is) .eq. -1) then
              call cofms(c(1,molsltlim(1,is)),c0,
         -      molsltlim(2,is)-molsltlim(1,is)+1,atw)
            else
              call trnsfr(c0,c(1,molsltlim(3,is)),3)
            end if
            call genimdist123dim(c0,cell,1,ncell,ixyzexcld,ixyzincld,
         -    img,rmin2)
            nrep=0
            do while (img .gt. 1 .and. nrep .lt. 10)
              call shiftmol(c(1,molsltlim(1,is)),
         -      molsltlim(2,is)-molsltlim(1,is)+1,cell(1,img),
         -      c(1,molsltlim(1,is)),-1.0)
              if (img .gt. 1) nmolshift=nmolshift+1
              call shiftmol(c0,1,cell(1,img),c0,-1.0)
              call genimdist123dim(c0,cell,1,ncell,ixyzexcld,ixyzincld,
         -      img,rmin2)
              nrep=nrep+1
            end do
          end do
          return
          end
          subroutine setrepats(nsegslt,molsltlim,nslt,nneig,ineig,
         -  molresflag,minresflag,it1,it2,maxneig,maxrsd)
          dimension molsltlim(3,maxrsd),nneig(nslt),ineig(maxneig,nslt),
         -  it1(nslt),it2(nslt),molresflag(maxrsd)
          dimension moltyp(3)
          character*1 ctyp
          character*41 question
          call zeroiti(moltyp,0,3)
          do is=1,nsegslt
            moltyp(molresflag(is)+1)=moltyp(molresflag(is)+1)+1
          end do
          if (moltyp(3) .gt. 0 .and. minresflag .eq. 0) then
            call askyn(
         - 'Do you want to include the molecular residues in the centering',
         -    62,1,1,molrescent,80,0)
            if (molrescent .eq. 1) minresflag=minresflag+1
          end if
          if (nsegslt .le. 1) then
            nsegslt=1
            molsltlim(1,1)=1
            molsltlim(2,1)=nslt
            molsltlim(3,1)=0
          end if
          call quiz(ctyp,ictyp,'g',' ',0,'molecular center',16,0,5,6,25)
          if (ctyp .eq. 'g') then
            do is=1,nsegslt
              molsltlim(3,is)=0
            end do
          else if (ctyp .eq. 'c') then
            do is=1,nsegslt
              molsltlim(3,is)=-1
            end do
          else
            iout=6
            do is=1,nsegslt
              if (ctyp .eq. 't' .and. is .le. 5) iout=6
              call findtcent(ineig,nneig,it1,it2,molsltlim(1,is),
         -      molsltlim(2,is),molsltlim(3,is),iout,maxneig,nslt)
              if (ctyp .eq. 't' .and. is .eq. 6) then
                print *,'Topology center list truncated'
                iout=0
              end if
            end do
            if (ctyp .eq. 'i') then
              do is=1,nsegslt
                write (question,1000) is
    100         call getint(question,41,molsltlim(3,is),1,molsltlim(2,is),
         -        molsltlim(3,is),0)
                if (molsltlim(3,is) .lt. molsltlim(1,is) .or.
         -          molsltlim(3,is) .gt. molsltlim(2,is)) then
                  print *,'Invalid number'
                  go to 100
                end if
              end do
            end if
          end if
          return
    1000  format('PBC center atom for solute molecule #',i4)
          end
          subroutine findtcent(ineig,nneig,iparent,list,n0,n,icent,
         -  iout,maxneig,maxat)
          dimension ineig(maxneig,maxat),nneig(maxat),list(maxat),
         -  iparent(maxat)
          data ilist /0/
          if (n .eq. n0) then
            icent=n0
            return
          end if
          do ir=1,2
            nsteps=0
            do i=n0,n
              iparent(i)=0
            end do
            if (ir .eq. 1) then
              ic=n0
            else
              ic=list(ilist)
            end if
            iparent(ic)=ic
            ilistf=1
            ilistl=1
            list(ilistf)=ic
            do while (ilistl .ge. ilistf)
              nsteps=nsteps+1
              ilist=ilistl
              do il=ilistf,ilistl
                ic=list(il)
                do in=1,nneig(ic)
                  ia=ineig(in,ic)
                  if (ia .ge. n0 .and. ia .le. n) then
                    if (iparent(ia) .eq. 0) then
                      iparent(ia)=ic
                      ilist =ilist+1
                      list(ilist)=ia
                    end if
                  end if
                end do
              end do
              ilistf=ilistl+1
              ilistl=ilist
            end do
          end do
          ic=list(ilist)
          do ia=1,nsteps/2
            ic=iparent(ic)
          end do
          icent=ic
          if (iout .gt. 0) write (iout,1001) icent,n0,n
          return
    1001  format(' Center found:',i5,' in atom range [',i5,',',i6,']')
          end
          subroutine updatesolvents(iaskatnum,iaskname,nmax,n,naslv,iasv,
         -  namesv,resnamslv,qsv,pflsv,iwat,iatnum,nconf,iotyp,maxrec)
          character*4 pflsv(100)
          character*8 namesv,resnamslv
          dimension iasv(100),namesv(100),qsv(100),iatnum(maxrec)
          character*5 crdext
          character*80 question
          common /iotypes/ iocha,iochaex,iobpdb,iocpdb,ioa3pdb,ioa4pdb,
         -  iommod,iommc,iommc4,iogro,iomol2,iomae,iocif,ioxxx,ioins,
         -  ionxyz,iosxyz,iosxyzrq,iograsp,iofull,lext(19),crdext(19)
          if (iaskatnum .eq. 0) then
            call askyn('Is the solvent water (O,H,H)',28,1,1,iwat,0,0)
            if (iwat .eq. 1) then
              naslv=3
              iasv(1)=8
              iasv(2)=1
              iasv(3)=1
              namesv(1)='OH2  '
              namesv(2)='H1   '
              namesv(3)='H2   '
              call getreal('Oxygen charge',13,-0.834,qox,0,0)
              qsv(1)=qox
              qsv(2)=-qox/2.0
              qsv(3)=-qox/2.0
              if (iotyp .eq. ioins .or. iotyp .eq. iommc) then
                if (iotyp .eq. iommc)
         -        print *,"TIP3P oxygen is 'OT' and hydrogen is 'HT'"
                if (iotyp .eq. ioins)
         -        print *,"CVFF oxygen is 'o*' and hydrogen is 'h*'"
                pflsv(1)='    '
                question='Atomtype label for water oxygen'
                call getname(pflsv(1),len,question,31,4,'',0,0,0,0)
                pflsv(2)='    '
                question(26:32)='hydrogen'
                call getname(pflsv(2),len,question,32,4,'',0,0,0,0)
                pflsv(3)=pflsv(2)
              end if
            else
              call getint('Number of atoms in a solvent molecule',37,
         -      999999,1,0,naslv,0)
              do i=1,naslv
                question='Atomic number for solvent atom   '
                write (question(31:33),1000) i
                call getint(question,33,999999,1,99,iasv(i),00)
                if (iaskname .eq. 1) then
                  question='Atom name for solvent atom   '
                  write (question(27:29),1000) i
                  call getname(namesv(i),len,question,29,5,'',0,0,0,0)
                  iasv(i)=ianum(namesv(i),0,len)
                  call getreal('Charge',6,999999.0,qsv(i),0,0)
                  if (iotyp .eq. ioins .or. iotyp .eq. iommc) then
                  question='Atom type label for solvent atom   '
                  write (question(33:35),1000) i
                  call getname(pflsv(i),len,question,35,4,'',0,0,0,0)
                  end if
                end if
              end do
            end if
            if (iaskname .eq. 1 .and. resnamslv .eq. '     ')
         -    call getname(resnamslv,len,'Residue name of the solvent',27,
         -      5,'',0,0,0,0)
            iaskatnum=1
          end if
          if (mod(n-nmax,naslv) .ne. 0) then
            if (nconf .lt. 10) then
              write (6,1003) naslv,n,nmax
              call askstop(0)
            end if
          end if
          ia=nmax
          nmax=n
          do while (ia .lt. n)
            do ias=1,naslv
              iatnum(ia+ias)=iasv(ias)
            end do
            ia=ia+naslv
          end do
          return
    1000  format(i3)
    1003  format(' WARNING: extra atoms dont form full solvents',/,
         -  ' Number of atoms/solvent=',i5,/,
         -  ' Total number of atoms=',i10,/,
         -  ' Number of already existing atoms=',i10)
          end
          subroutine unpacktraj(inptrajtyp,mmctrajtyp,inpcrdtyp,iotyp,
         -  inpcrdtyporg,n,nslt,naslv,islvw,numres,numslv,resnamslv,iatnum,
         -  ifchrg,ixres,atnames,resnames,segnames,altcol,inscol,ninsres,
         -  marker,ireseq,iresnrestart,iresidrestart,c,rprox,cv,charge,
         -  ntitlin,title,nneig,nneiga,nhbneig,ineig,nhneig,nnneig,ncneig,
         -  nsneig,npneig,isegno,iresno,line,blankline,ifree,icntrl,innlist,
         -  mmtype,ibnd,index,indexn,indexo,molresflag,hblimfac,angmin,
         -  ioppbc,cell,ncell,ionefile,imodel,numsel,iconfsel,idupl,
         -  itemp1,nclstmem,numconsec,incr_fileno,nextconfsel,iqspaceask,
         -  keeprem,radtodeg,ioverallconf,lentest,maxconfsel,maxrepconf,
         -  maxng,maxrsd,maxrec,mx2d)
          character* 132 line(maxrec),blankline
          dimension nneig(maxrec),ineig(maxng,maxrec),iatnum(maxrec),
         -  ifchrg(maxrec),ixres(maxrec),c(3,maxrec),rprox(maxrec),
         -  cv(maxrec),nhbneig(maxrec),nneiga(maxrec),isegno(maxrec),
         -  iresno(maxrec),ifree(maxrec),charge(maxrec),nhneig(maxrec),
         -  nnneig(maxrec),ncneig(maxrec),nsneig(maxrec),npneig(maxrec),
         -  mmtype(maxrec),ibnd(maxng,maxrec),index(maxrec),indexn(maxrec),
         -  indexo(maxrec),molresflag(maxrsd),iconfsel(maxconfsel),
         -  idupl(maxrsd),itemp1(maxrec),nclstmem(mx2d),cell(3,ncell)
          real*8 etotsum,etotsum2
          character*1 altcol(maxrec),inscol(maxrec)
          character*4 pflsv(100),segnames(maxrsd)
          character*8 resnamslv,atnames(maxrec),resnames(maxrsd),namesv(100)
          character*6 marker(16)
          character*80 trtitle(32),title
          character*200 inpfile
          dimension icntrl(20)
          common /logging/ logfile,ipredict
          character*5 crdext
          common /iotypes/ iocha,iochaex,iobpdb,iocpdb,ioa3pdb,ioa4pdb,
         -  iommod,iommc,iommc4,iogro,iomol2,iomae,iocif,ioxxx,ioins,
         -  ionxyz,iosxyz,iosxyzrq,iograsp,iofull,lext(19),crdext(19)
          character*200 trajnam,outfile
          common /trajname/ trajnam,outfile,ltrajnam,namleno,ifirsttraj,
         -  ifirsttraj2,ilasttraj,ilasttraj2,incrementtraj,incrementtraj2
          character*11 trajformatname
          common /trajectory/ nmmccheck,iftrajtyp(6),trajformatname(6)
          dimension iasv(100),qsv(100)
          data ifirst /1/,ilast /999999/,increment /1/,inpt /70/
          nmax0=n
          nmax=n
          etotsum=0.d0
          etotsum2=0.d0
          etotmin=1.e+30
          etotmax=-etotmin
          emax=0.0
          netot=0
          neskip=0
          neavskip=0
          ielim=1
          if (numsel .gt. 0) write (6,1010) (iconfsel(i),i=1,numsel)
          call opentraj(c,1,inpt,inptrajtyp,n,ntitltr,trtitle,
         -  inpcrdtyp,ifirst,ilast,increment,maxconf,ninconf,noutconf,
         -  natom,nfreeat,ifree,icntrl,1,mmctrajtyp,trajnam,ltrajnam,
         -  'trajectory',10,iconfsel,numsel,1,0,0,0,icellfound,notfnd,0,
         -  0,lentest,0,0,0,maxconfsel,maxrec)
          if (ionefile .eq. 0) then
            call getname(inpfile,namleni,
         -    'Output coordinate file (without the extension)',46,200,'',0,
         -    0,0,0)
            ic=namleni+1
            inpfile(ic:ic)='.'
            inpfile(ic+1:ic+3)=crdext(iotyp)
            namleni=namleni+4
          else
            call getname(inpfile,namleni,'Output coordinate file',22,200,
         -    '',0,0,0,0)
          end if
          ifail=0
          iaskatnum=0
          nntest=0
          nclustermem=0
          lastwrite=0
          do while (ninconf .lt. ilast .and. lastwrite .eq. 0 .and.
         -          ifail .eq. 0)
            call readtraj(inpt,inptrajtyp,mmctrajtyp,n,naslv,nwatr,nslt,
         -    trajformatname(inptrajtyp),ntitltr,trtitle,trajnam,ltrajnam,
         -    natom,nfreeat,ifree,icntrl,c,ninconf,noutconf,
         -    increment,inpcrdtyp,ietot,etot,ifail,ifirst,ilast,iconfsel,
         -    numsel,maxrepconf,nmc,lentest,1.0,maxconf,maxconfsel,maxrec)
            if (ifail .eq. 0) then
              if (nntest .eq. 0) then
                call comparetop(c,n,nneig,ineig,iatnum,innlist,n,1,
         -        cell,ncell,ioppbc,maxng,maxrec)
                nntest=1
              end if
              ifilenum=0
              if (numsel .gt. 0) then
                if (ninconf .eq. iconfsel(nextconfsel)) then
                  ifilenum=ninconf
                  nclustermem=nclstmem(nextconfsel)
                  if (nextconfsel .eq. numsel) lastwrite=1
                  if (nextconfsel .lt. min0(numsel,maxconfsel))
         -          nextconfsel=nextconfsel+1
                else if (iconfsel(nextconfsel) .eq. 0) then
                  ifail=1
                end if
              else
                if (ninconf .ge. ifirst .and.
         -        mod(ninconf-ifirst,increment) .eq. 0)
         -          ifilenum=noutconf+incr_fileno+1
              end if
              if (ietot .eq. 1) then
                if (ielim .eq. 1) then
                  call askyn(
         -          'Do you want to give an energy threshold (max)',45,1,-1,
         -          iemax,0,0)
                  if (iemax .eq. 1)
         -          call getreal('Energy maximum to use',21,0.0,emax,0,0)
                  ielim=0
                end if
                if (iemax .eq. 1 .and. etot .gt. emax) then
                  if (ifilenum .gt. 0) neskip=neskip+1
                  ifilenum=0
                end if
              end if
              if (ifilenum .gt. 0) then
                noutconf=noutconf+1
                ifnumw=ifilenum
                if (numconsec .gt. 0) ifnumw=noutconf
                if (noutconf .eq. 1 .or. ionefile .eq. 0) then
                  if (ionefile .eq. 0) then
                    call filenamenum(inpfile,namleni,outfile,nl1,ifnumw,+2)
                  else
                    outfile=inpfile
                    nl1=namleni
                  end if
                  call openfile(20,0,'output',6,'new',outfile,nl1,
         -          notfnd,2,1,1,0,ioverallconf)
                  if (notfnd .eq. 1) write (6,1012) outfile(1:nl1)
                  if (notfnd .eq. 1 .or. 
         -            (ipredict .eq. 1 .and. ioverallconf .eq. 0)) then
                    call askyn(
         -            'Do you want to overwrite all existing files',43,1,-1,
         -            ioverallconf,0,0)
                    if (ioverallconf .eq. 0) stop
                    call openfile(20,0,'output',6,'new',outfile,nl1,
         -            notfnd,2,1,1,0,ioverallconf)
                  end if
                end if
                if (n .gt. nmax) then
                  nmax0=nmax
                  call updatesolvents(iaskatnum,1,nmax,n,naslv,iasv,namesv,
         -          resnamslv,qsv,pflsv,iwat,iatnum,noutconf,iotyp,maxrec)
                end if
                call writeconf(20,inpcrdtyp,iotyp,inpcrdtyporg,nmax0,n,nslt,
         -        naslv,islvw,iasv,namesv,qsv,pflsv,1,1,imodel,iatnum,
         -        ifchrg,noutconf,innlist,c,rprox,cv,ixres,iresno,atnames,
         -        resnames,segnames,charge,isegno,altcol,inscol,ninsres,
         -        marker,ntitlin,0,title,ireseq,iresnrestart,iresidrestart,
         -        nneig,nneiga,nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,
         -        npneig,numres,numslv,resnamslv,line,blankline,mmtype,ibnd,
         -        index,indexn,indexo,0,molresflag,idupl,itemp1,hblimfac,
         -        angmin,0,1,0,0,noutconf-1,5,iqspaceask,0,ifilenum,etot,
         -        ietot,nclustermem,0,keeprem,iwriteatsym,radtodeg,
         -        maxrepconf,maxng,maxrsd,maxrec)
                if (ietot .eq. 1) then
                  if (etot .lt. emax) then
                    etotsum=etotsum+etot
                    etotsum2=etotsum2+etot**2
                    if (etot .lt. etotmin) etotmin=etot
                    if (etot .gt. etotmax) etotmax=etot
                    netot=netot+1
                  else
                    neavskip=neavskip+1
                  end if
                end if
                if (ionefile .eq. 0) close (20)
                if (noutconf .eq. 1) inpcrdtyp=iotyp
              end if
            end if
          end do
          if (netot .gt. 0) then
            eav=etotsum/dfloat(netot)
            sd=dsqrt(etotsum2/dfloat(netot)-(etotsum/dfloat(netot))**2)
            write (6,1021) eav,sd,etotmin,etotmax,netot
            if (neavskip .gt. 0 .and. iemax .eq. 0) write (6,1022) neavskip
          end if
          if (ionefile .eq. 1) close (20)
          close(inpt)
          write (6,1011) noutconf
          if (neskip .gt. 0) write (6,2127) neskip,emax
          return
    1010  format(' Unpacking trajectory frames ',(/,10i7))
    1011  format(' Completed unpacking trajectory into ',i6,
         -  ' configurations')
    1012  format(' Problem opening file ',a)
    1021  format(' <E>=',f10.4,' S.D.=',f10.4,' Range: [',f10.4,',',
         -  f10.4,'] (N=',i5,')')
    1022  format(' Note:',i5,' structures with non-negative energy ',
         -  'were skipped for the statistics')
    2127  format(' Note:',i5,' structures with energy >',e12.5,
         -  'were skipped')
          end
          subroutine opentraj(c,irept,inpt,inptrajtyp,n,ntitltr,trtitle,
         -  inpcrdtyp,ifirst,ilast,increment,maxconf,ninconf,noutconf,
         -  natom,nfreeat,ifree,icntrl,iaskalways,mmctrajtyp,inpfile,
         -  namlent,prompt,lprompt,iconfsel,numsel,iverb,notitprint,
         -  icont_traj,idatapath,icellfound,notfnd,iconfirmname,
         -  iopen_rep,lentest,iout_lim,ianaltyp,mx2d,maxconfsel,maxrec)
          dimension c(3,maxrec),ifree(maxrec)
          character*(*) prompt
          character*80 trtitle(32)
          character*200 inpfile
          dimension iconfsel(maxconfsel)
          character*4 chhd
          character*11 trajformatname
          common /trajectory/ nmmccheck,iftrajtyp(6),trajformatname(6)
          real*8 xtlabc,xtlabc0
          common /boxdat/ xtlabc(6),xtlabc0(6),box(3),box0(3),edge_gen(3,3),
         -  cell0(3,27),cell(3,27),cellalt(3,27),
         -  ncell,ioppbc,noboxinfoar,noboxinfow,noboxrep,
         -  istuner,iboxtypfound,ixcrd(3),ixang(3),ixyzhex(3),
         -  ixyzhextraj(3),isizewarn
          real*8 xtlabct
          dimension xtlabct(7),z(10),zz(10),edg(3),icntrl(20)
          character*5 crdext
          common /iotypes/ iocha,iochaex,iobpdb,iocpdb,ioa3pdb,ioa4pdb,
         -  iommod,iommc,iommc4,iogro,iomol2,iomae,iocif,ioxxx,ioins,
         -  ionxyz,iosxyz,iosxyzrq,iograsp,iofull,lext(19),crdext(19)
          character*12 recordn
          call blankout(recordn,1,12)
          icellfound=0
          icrorg=0
          if (inptrajtyp .eq. 0) then
            print *,'PROGRAM ERROR: missing trajectory type for ',
         -    prompt(1:lprompt)
            stop
          end if
          ntry=0
          iform=iftrajtyp(inptrajtyp)
          if (inptrajtyp .eq. 3 .and. mmctrajtyp .eq. 1) iform=2
          noecho=0
          if (iverb .eq. 0) noecho=1
          if (iconfirmname .gt. 0 .and. namlent .gt. 0) then
            print *,'Input trajectory file name=',inpfile(1:namlent)
            call askyn('Do you want to change it',24,1,-1,newn,0,0)
            if (newn .gt. 0) namlent=0
            iconfirmname=0
          end if
    100   call openfile(inpt,0,prompt,lprompt,'old',inpfile,namlent,notfnd,
         -  idatapath,iform,1,noecho,0)
          if (notfnd .eq. 1) return
          rewind inpt
          if (icont_traj .le. 1) then
            ninconf=0
            noutconf=0
          end if
          ntitltr=0
          if (inptrajtyp .eq. 1) then
            recordn='chhd,icntrl '
            read (inpt,err=1098,end=1098) chhd,icntrl
            if (chhd .ne. 'CORD') then
              print *,'ERROR:header label is not CORD: ',chhd
              go to 1099
            end if
            recordn='title       '
            read (inpt,err=1098,end=1099) ntitltr
            if (ntitltr .lt. 1 .or. ntitltr .gt. 32) then
              print *,'WARNING: invalid number of title lines:',
         -      ntitltr
              ntitltr=0
            else
              do i=1,ntitltr
                call blankout(trtitle(i),1,ntitltr)
              end do
              rewind inpt
              read (inpt)
              read (inpt,err=1098,end=1099) ntitltr,
         -      (trtitle(i),i=1,ntitltr)
            end if
            if (notitprint .eq. 0) then
              if (trtitle(1)(1:21) .eq. 'Created by DCD plugin') then
                print *,'Trajectory written by VMD'
              else
                if (ntitltr .gt. 1) then
                  if (trtitle(ntitltr-1)(1:8) .eq. 'Simulaid') then
                    print *,trtitle(ntitltr-1)
                    print *,trtitle(ntitltr)
                  end if
                end if
                if (ntitltr .eq. 2) then
                  ic=0
                  do while (ic .lt. 65 .and.
         -                  trtitle(1)(ic+1:ic+15) .ne. 'CREATED BY NAMD')
                    ic=ic+1
                  end do
                  if (trtitle(1)(ic+1:ic+15) .eq. 'CREATED BY NAMD')
         -          print *,'Trajectory written by NAMD'
                end if
              end if
            end if
            read(inpt,err=1098,end=1099) natom
            if (iverb .gt. 0 .and. natom .ne. n) then
              write (6,1020) natom,n
              call askstop(1)
            end if
            nfreeat = natom - icntrl(9)
            if (chhd .ne. 'CORD') then
              write (6,1003) chhd
              namlent=0
              go to 100
            end if
            if (iverb .gt. 0)
         -    write (6,1001) icntrl(1),nfreeat,icntrl(5),icntrl(20)
            if (n .ne. natom) then
              write (6,1002) n,natom
              call askstop(0)
              n=natom
            end if
            recordn='ifree       '
            if (icntrl(9) .gt. 0)
         -    read (inpt,err=1098,end=1099) (ifree(i),i=1,nfreeat)
            recordn='cell info1'
            if (lentest .eq. 1) then
              icell=0
              xtlabct(7)=999999.9
              read (inpt,err=120,end=120) xtlabct
    120       if (xtlabct(7) .eq. 999999.9) icell=1
            else
              icell=icntrl(11)
              if (icell .eq. 1) icell=2
            end if
            rewind inpt
            read(inpt)
            read(inpt)
            read(inpt)
            if (icntrl(9) .gt. 0) read(inpt)
            if (icell .gt. 0) then
              read (inpt,err=1098,end=1098) (xtlabc(i),i=1,6)
              noboxinfoar=0
              icellfound=1
              iboxtypfound=1
              call trnsfrd(xtlabc0,xtlabc,6)
              if (iverb .gt. 0 .or. ioppbc .eq. 4 .or. ioppbc .eq. 5) then
                write (6,1007) 'size',(xtlabc0(ixcrd(k)),k=1,3)
                write (6,1007) 'angle/cos',(xtlabc0(ixang(k)),k=1,3)
              end if
              if (ioppbc .eq. 1 .or. ioppbc .eq. 2) then
                do k=1,3
                  edg(k)=xtlabc0(ixcrd(k))
                end do
                icrorg=1
              else if (ioppbc .eq. 5) then
                edg(1)=xtlabc0(ixcrd(3))
                edg(2)=xtlabc0(ixcrd(2))
                edg(3)=xtlabc0(ixcrd(1))
                icrorg=1
              end if
              if (lentest .gt. 0) then
                recordn='1st config'
                read(inpt,err=1098,end=1099)
                read(inpt,err=1098,end=1099)
                read(inpt,err=1098,end=1099)
                xtlabct(7)=999999.9
                recordn='cell info2'
                read(inpt,err=130,end=130) xtlabct
    130         if (xtlabct(7) .eq. 999999.9) icell=2
              end if
              if (icell .eq. 2) then
                if (iverb .gt. 0)
         -        print *,'Cell information is read for each configuration'
                iboxtypfound=2
              else
                if (iverb .gt. 0)
         -        print *,'Cell information is read only at start'
              end if
              if (icntrl(11) .eq. 0) then
                print *,'Suspect: icntrl(11)=',icntrl(11)
              end if
            else
              if (iverb .gt. 0) then
                print *,'No cell information'
                if (icntrl(11) .ne. 0)
         -        print *,'Suspect: icntrl(11)=',icntrl(11)
              end if
              noboxinfoar=1
            end if
            icntrl(11)=icell
            rewind inpt
            read(inpt)
            read(inpt)
            read(inpt)
            if (icntrl(9) .gt. 0) read(inpt)
          else if (inptrajtyp .eq. 2) then
            if (nmmccheck .eq. 0 .and. inpcrdtyp .eq. iommc) then
              write (6,1021) n
              call askyn('Do you want to change it (to include solvents)',
         -      46,1,-1,newn,0,0)
              if (newn .eq. 1) call getint('New number of atoms',19,1,1,
         -      maxrec,n,0)
              nmmccheck=1
            else if (iverb .gt. 0) then
              write (6,1021) n
            end if
            recordn='title       '
            call blankout(trtitle(1),1,80)
            read (inpt,1000,err=1098,end=1099) trtitle(1)
            ntitltr=1
            if (iverb .gt. 0) write (6,1010) trtitle(1)
            recordn='first struc.'
            nleft=3*n
            do while (nleft .gt. 0)
              nread=min0(10,nleft)
              read (inpt,1012,err=1098,end=1097) (z(i),i=1,nread)
              nleft=nleft-10
            end do
            noboxinfoar=1
            iboxtypfound=1
            call zeroit(z,10)
            read (inpt,1012,err=1098,end=1097) (z(i),i=1,10)
            call countzeros(z,10,nzero1)
            nzero2=0
            if (nzero1 .ge. 7) then
              icellfound=1
              noboxinfoar=0
              call trnsfr(box0,z,3)
              recordn='secnd struc.'
              nleft=3*n
              do while (nleft .gt. 0)
                nread=min0(10,nleft)
                read (inpt,1012,err=1098,end=1097) (zz(i),i=1,nread)
                nleft=nleft-10
              end do
              call zeroit(zz,10)
              read (inpt,1012,err=1098,end=1097) (zz(i),i=1,10)
              call countzeros(zz,10,nzero2)
              if (nzero2 .ge. 7) then
                noboxrep=0
                if (iverb .gt. 0) print *,'Box information was found after',
         -        ' each structure'
              else if (iverb .gt. 0) then
                print *,'NOTE: Box information appears to be missing after',
         -        ' the first structure'
                iboxtypfound=2
              end if
            else if (iverb .gt. 0) then
              print *,'No box information was found at all'
              iboxtypfound=0
            end if
            if (nzero1 .gt. 7 .and. iverb .gt. 0)
         -    write (6,1006) 'First',(z(k),k=1,3)
            if (nzero2 .gt. 7 .and. iverb .gt. 0)
         -    write (6,1006) 'Second',(zz(k),k=1,3)
            rewind inpt
            read (inpt,1000) trtitle(1)
          else if (inptrajtyp .ge. 3 .and. inptrajtyp .le. 5) then
            ntitltr=0
            if (inptrajtyp .eq. 3) then
              if (noboxinfoar .eq. -1 .and. mmctrajtyp .ne. 1)
         -      call askyn('Is the trajectory from a (T,P,N) run',
         -        36,0,-1,noboxinfoar,0,0)
              if (mmctrajtyp .eq. 1) then
                call binhst_type(inpt,c,ibox,istuner,ieof,6,maxrec)
                if (ieof .gt. 0) call askstop(1)
                if (iopen_rep .eq. 0) then
                  if (ibox .gt. 0) print *,'Box information was found'
                  if (istuner .gt. 0) print *,'Tuning information was found'
                  if (ibox+istuner .eq. 0)
         -          print *,'Neither tuning nor box information was found'
                end if
                if (noboxinfoar .ne. -1 .and. noboxinfoar .ne. 1-ibox) then
                  write (6,1008)
                  call askstop(1)
                end if
                noboxinfoar=1-ibox
                read (inpt,err=1098,end=1999) nwat,natoms
                read (inpt,err=1098,end=1999)
                read (inpt,err=1098,end=1999) box0
    1999        rewind inpt
                if (iverb .gt. 0) write (6,1011) natoms,nwat
                if (iverb .gt. 0 .and. natoms .ne. n) then
                  write (6,1020) natoms,n
                  call askstop(1)
                end if
              end if
              icellfound=1-noboxinfoar
              if (noboxinfoar .eq. 0) iboxtypfound=2
            end if
            call blankout(trtitle(1),1,80)
            trtitle(1)(1:27)='Trajectory generated by MMC'
          else if (inptrajtyp .eq. 6) then
            print *,'Under implementation'
            stop
          else if (inptrajtyp .gt. 6) then
            print *,'Trajectory input type ',inptrajtyp,' is not yet done'
            stop
          end if
          if (iverb .gt. 0) then
            write (6,1013) trajformatname(inptrajtyp),inpfile(1:namlent)
            if (ntitltr .gt. 0)
         -    write (6,1014) (trtitle(i)(1:79),i=1,ntitltr)
          end if
          if (irept .eq. 1) then
            if (icrorg .eq. 1) then
              if (ioppbc .lt. 0) then
                print *,'PBC type is unknown - it is set to cubic'
                ioppbc=1
                npbc=1
                call pbcsize(ioppbc,edg,npbc)
              end if
              call crorgn(edg,edge_gen,ioppbc,3,ncell,cell,cellalt,
         -      ixyzhex,rinscr,rcirc)
              call trnsfr(cell0,cell,3*ncell)
              write (6,1016) edg
            else if (ncell .gt. 0) then
              call trnsfr(cell0,cell,3*ncell)
              if (isizewarn .eq. 1) write (6,1015)
              isizewarn=0
            end if
          end if
          if (icont_traj .eq. 0) then
            if (irept .eq. 1 .or. iaskalways .eq. 1) then
              if (numsel .eq. 0) then
                call askyn('Do you have a list of configurations to read',
         -        44,1,-1,igetlist,0,0)
                if (igetlist .eq. 1) then
                  call getlist(iconfsel,numsel,1,999999,1,maxconfsel)
                  maxconf=numsel
                end if
              else
                maxconf=numsel
              end if
              if (numsel .eq. 0) then
                idefl=ilast
                ideff=max0(1,ifirst)
                if (inptrajtyp .eq. 1) idefl=icntrl(1)
    200         call getrange(ifirst,ideff,ilast,idefl,increment,1,
         -        'structure to use from trajectory',32,0,0)
                if (ilast .eq. 0) ilast=999999
                maxconf=(ilast-ifirst)/increment+1
                if ((ianaltyp .eq. 23 .or. ianaltyp .eq. 24).and.
         -           maxconf .gt. mx2d) then
                  write (6,1022) maxconf,mx2d,mx2d
                  go to 200
                end if
                print *,'Number of configurations to use=',maxconf
              end if
              if (iout_lim .gt. 0) then
                if (numsel .gt. 0) then
                  write (iout_lim,1009) (iconfsel(i),i=1,numsel)
                else if (ianaltyp .ne. 23 .and. ianaltyp .ne. 24) then
                  write (iout_lim,1017) ifirst,ilast,increment
                end if
              end if
            end if
          end if
          icntrl(3)=icntrl(3)*increment
          return
    1097  print *,'Amber trajectory must contain at least 3 structures'
          return
    1098  write (6,1004) trajformatname(inptrajtyp),'invalid'
          print *,'TRTITLE(1)=',trtitle(1)
          print *,'Problem occured while trying to read ',recordn
          if (inptrajtyp .eq. 1) then
            print *,'chhd=',chhd
            print *,'icntrl=',icntrl
            print *,'ntitltr=',ntitltr
          end if
          namlent=0
          ntry=ntry+1
          if (ntry .lt. 3) go to 100
          stop
    1099  write (6,1004) trajformatname(inptrajtyp),'incomplete'
          if (recordn(1:2) .ne. '  ')
         -  print *,'Problem occured while trying to read ',recordn
          namlent=0
          if (inptrajtyp .eq. 1) write (6,1005)
          write (6,1019) inpfile(1:namlent)
          ntry=ntry+1
          if (ntry .lt. 3) go to 100
          stop
    1000  format(a)
    1001  format(' Number of data sets: ',i7,/,
         -  ' Number of free atoms=',i7,' Number of fixed atoms=',i7,/,
         -  ' Charmm version=',i4)
    1002  format(' WARNING: The number of atoms inputted (',i8,
         -  ') is different from',/,10x,'the number of atoms on the ',
         -  'Charmm trajectory file (',i8,')',/,10x,'The trajectory ',
         -  'file value will be used')
    1003  format(' WARNING: Charm trajectory file 4-character ',
         -  'header is incorrect: ',a4,' should be CORD',/,
         -  ' Make sure that Simulaid is compiled with the same byte order',
         -  ' as the DCD file')
    1004  format(' ERROR: ',a,' trajectory file entry is ',a)
    1005  format(' Make sure Simulaid was compiled with the same byte ',
         -  'order',/,' as the trajectory file was run')
    1006  format(' WARNING: ',a,' box information includes zero edges:',
         -  3f7.2)
    1007  format(' Initial PBC box ',a,' information:',3f12.6)
    1008  format(' Conflicting box information - probable progam error')
    1009  format(' Frame numbers selected to be used:',/,(10i6))
    1010  format(' Amber trajectory file title:',/,1x,a)
    1011  format(' MMC binary trajectory - number of atoms=',i10,
         -  ' Number of solvents=',i8)
    1012  format(10f8.3)
    1013  format(1x,a,' trajectory file ',a,' opened')
    1014  format(' Title:',/,(1x,a))
    1015  format(' Make sure that the PBC size read is IDENTICAL to ',
         -  'the size of the first frame')
    1016  format(' Cell edges are set from the trajectory to',/,3f10.5)
    1017  format(' First frame to use=',i6,/,' Last frame to use=',i6,/,
         -  ' Increment=',i5)
    1019  format(' Trajectory file opened: ',a)
    1020  format(' WARNING: number of atoms found (',i8,') differs from ',
         -  'the',/,10x,'number of atoms expected (',i8,')')
    1021  format(' Opening Amber trajectory, number of atoms per structure',
         -  '=',i8)
    1022  format(' ERROR: Number of frames to analyze (',i6,') exceeds ',
         -  'the limit (',i5,')',/,' Increase the inrement or recompile',
         -  ' with the parameter MAX2D > ',i5,/)
          end
          subroutine binhst_read(ihist,c,etoto,nmc,nwatr,ieof,iout,
         -  maxat)
          dimension c(3,maxat)
          real*8 etoto
          real*8 uusfacd,tesi(4)
          ieof=0
          read (ihist,end=888,err=888) nwatr,natomsr,uusfacd,nmc,nidmc,
         -  niaccp,ndaccp,ia0,ia1,etoto,tesi,cplpar
          nmolecr=nwatr+1
          nsvp=0
          if (nwatr .gt. 0) nsvp=(natomsr-(ia1-ia0+1))/nwatr
          if (nwatr .gt. 0) then
            read (ihist,end=999,err=999) ((c(k,ii),k=1,3),ii=ia0,ia1),
         -    (((c(k,ia1+(i-1)*nsvp+j),k=1,3),j=1,nsvp),i=1,nwatr)
          else
            read (ihist,end=999,err=999) ((c(k,ii),k=1,3),ii=ia0,ia1)
          end if
          return
    888   ieof=1
          if (iout .gt. 0) write(iout,*) 'File header is truncated'
          return
    999   ieof=2
          if (iout .gt. 0)
         -   write(iout,*) 'First coordinate record is in error'
          return
          end
          subroutine binhst_type(ihist,c,ibox,istuner,ieof,iout,
         -  maxat)
          dimension c(3,maxat)
          real*8 etoto
          dimension test5(5),test4(4),test3(3)
          character*4 chhd
          read (ihist,end=888,err=888) chhd
          if (chhd .eq. 'CORD' .or. chhd .eq. 'VELD') then
            print *,'Trajectory is a Charmm DCD file'
            stop
          end if
          rewind ihist
          ieof=0
          istuner=0
          ibox=0
          call binhst_read(ihist,c,etoto,nmc,nwatr,ieof,0,maxat)
          read (ihist,end=100,err=100) test5
          rewind ihist
          return
    100   rewind ihist
          call binhst_read(ihist,c,etoto,nmc,nwatr,ieof,0,maxat)
          read (ihist,end=200,err=200) test4
          istuner=1
          rewind ihist
          return
    200   rewind ihist
          ibox=1
          call binhst_read(ihist,c,etoto,nmc,nwatr,ieof,0,maxat)
          read (ihist,end=888,err=888) test3
          read (ihist,end=300,err=300) test5
          rewind ihist
          return
    300   rewind ihist
          istuner=1
    888   ieof=1
          if (iout .gt. 0)
         -   write(iout,*) 'First box info record is in error'
          return
          end
          subroutine countzeros(z,n,nzero)
          dimension z(n)
          nzero=0
          do i=1,n
            if (z(i) .eq. 0.0) nzero=nzero+1
          end do
          return
          end
          subroutine readtraj(inpt,inptrajtyp,mmctrajtyp,n,naslv,nwatr,nslt,
         -  trajformatname,ntitltr,trtitle,trajnam,ltrajnam,natom,
         -  nfreeat,ifree,icntrl,c,ninconf,noutconf,increment,inpcrdtyp,
         -  ietotread,etot,ifail,ifirst,ilast,iconfsel,numsel,maxrepconf,
         -  nmc,lentest,tofac,maxconf,maxconfsel,maxrec)
          dimension c(3,maxrec),ifree(maxrec),icntrl(20),
         -  iconfsel(maxconfsel)
          character*11 trajformatname
          character*80 trtitle(32)
          character* 132 line
          character* 200 trajnam,trajnam_n(2)
          real*8 xtlabc,xtlabc0
          common /boxdat/ xtlabc(6),xtlabc0(6),box(3),box0(3),edge_gen(3,3),
         -  cell0(3,27),cell(3,27),cellalt(3,27),
         -  ncell,ioppbc,noboxinfoar,noboxinfow,noboxrep,
         -  istuner,iboxtypfound,ixcrd(3),ixang(3),ixyzhex(3),
         -  ixyzhextraj(3),isizewarn
          character*1 separatorchar
          common /filenuminfo/ iaskunderscore,separatorchar
          character*1 xyz
          common /axislab/ xyz(3)
          real*8 db(6)
          dimension istune(4),ltrajnam_n(2)
          data k /0/
          ifail=0
          ncol=80
          etot=0.0
          ninconf=ninconf+1
          iverbconf=1
          if (ninconf .gt. maxrepconf) iverbconf=0
          ietotread=0
          if (inptrajtyp .eq. 1) then
            ncol=0
            if (ninconf .eq. 1) then
              limic11=0
              if (natom .gt. n) then
                n=natom
                write (6,1009) n
              end if
            else
              limic11=1
            end if
            if (icntrl(11) .gt. limic11) then
              read(inpt,err=1095,end=1099) (xtlabc(j),j=1,6)
              do k=1,3
                box(k)=xtlabc(ixcrd(k))*tofac
              end do
              noboxinfoar=0
            else
              noboxinfoar=1
            end if
            if (icntrl(9) .gt. 0 .and. ninconf .gt. 1) then
              do k=1,3
                read(inpt,err=1096,end=1099) (c(k,ifree(j)),j=1,nfreeat)
              end do
            else
              do k=1,3
                read(inpt,err=1098,end=1099) (c(k,j),j=1,natom)
              end do
            end if
            nmc=nmc+1
          else if (inptrajtyp .eq. 2) then
            ncol=0
            read (inpt,1012,err=1098,end=1099) ((c(k,i),k=1,3),i=1,n)
            if (noboxinfoar .eq. 0) then
              read (inpt,1012,err=1098,end=1099) box
              if (iboxtypfound .eq. 2) noboxinfoar=1
            end if
            do k=1,3
              xtlabc(ixcrd(k))=box(k)
              xtlabc(ixang(k))=90.0
            end do
            nmc=nmc+1
          else if (inptrajtyp .eq. 3) then
            nsvp=min0(naslv,3)
            ncol=0
            if (mmctrajtyp .eq. 1) then
              ietotread=1
              read (inpt,err=2099,end=1099) nwatr,natr,db(1),nmc,nidmc,
         -      i3,i4,ia0,ia1,(db(i),i=2,6),r1
              etot=db(2)
              if (nwatr .lt. 0 .or. natr .lt. 0 .or. nmc .lt. 0
         -      .or. nwatr .gt. maxrec/naslv .or. natr .gt. maxrec) then
                write (6,1013)
                stop
              end if
              read (inpt,err=2099,end=1099)
         -      ((c(k,j),k=1,3),j=ia0,ia1),(((c(k,ia1+(i-1)*naslv+j),
         -      k=1,3),j=1,nsvp),i=1,nwatr)
              if (noboxinfoar .eq. 0) read (inpt,err=2099,end=1099) box
              if (istuner .gt. 0) then
                read (inpt,err=2099,end=1099) istune
                if (istune(1)+istune(2) .gt. 0)read (inpt,err=2099,end=1099)
                if (istune(3) .gt. 0) read (inpt,err=2099,end=1099)
                if (istune(4) .gt. 0) read (inpt,err=2099,end=1099)
              end if
              n=nslt+nwatr*naslv
            else if (mmctrajtyp .eq. 2 .or. mmctrajtyp .eq. 3) then
              read (inpt,1000,end=1099) line(1:80)
              read (line(1:80),1019,err=1097)
         -      natomp,nmolec,n,ia0,ia1,nmc,cplpar
              n=nslt+(nmolec-1)*naslv
              if (mmctrajtyp .eq. 2) then
                do i=ia0,ia1
                  read (inpt,1000,end=1099) line(1:80)
                  read (line(1:80),1017,err=1098) (c(k,i),k=1,3)
                end do
                do iw=2,nmolec
                  do j=1,nsvp
                    read (inpt,1000,end=1099) line(1:80)
                    read (line(1:80),1017,err=1098)
         -            (c(k,nslt-2*naslv+iw*naslv+j),k=1,3)
                  end do
                end do
              else if (mmctrajtyp .eq. 3) then
                do i=ia0,ia1
                  read (inpt,1000,end=1099) line(1:80)
                  read (line(1:80),1018,err=1098) (c(k,i),k=1,3)
                end do
                do iw=2,nmolec
                  do j=1,nsvp
                    read (inpt,1000,end=1099) line(1:80)
                    read (line(1:80),1018,err=1098)
         -            (c(k,nslt-2*naslv+iw*naslv+j),k=1,3)
                  end do
                end do
              end if
              read (inpt,1015,end=1099) db(1)
              read (inpt,1000,end=1099)
              etot=db(1)
              ietotread=1
              if (noboxinfoar .eq. 0) read (inpt,1010,end=1099) box
            else if (mmctrajtyp .eq. 4) then
              nmc=nmc+1
              nr=0
              line(1:3)='   '
              do while (line(1:3) .ne. 'END')
                call blankout(line,1,80)
                read (inpt,1000,end=1100) line(1:80)
                if (line(1:4) .eq. 'ATOM' .or. line(1:6) .eq. 'HETATM') then
                  nr=nr+1
                  read (line(31:54),1011,err=1098) (c(k,nr),k=1,3)
                else
                  call checkforetot(6,line,ninconf,etot,ietotread,iverbconf)
                end if
              end do
    1100      n=nr
              if (n .eq. 0) then
                if (nr .gt. 0) write (6,1020) ninconf
                ifail=1
                return
              end if
            else if (mmctrajtyp .eq. 5) then
              call blankout(line,1,80)
              read (inpt,1000,end=1099) line(1:80)
              do while (line(1:1) .eq. '*')
                call checkforetot(1,line,ninconf,etot,ietotread,iverbconf)
                read (inpt,1000,end=1099) line(1:80)
              end do
              read(line(1:5),1002,err=1098) n
              do i=1,n
                read (inpt,1000,end=1099) line(1:80)
                read (line(1:50),1003,err=1098) (c(k,i),k=1,3)
              end do
              nmc=nmc+1
            end if
          else if (inptrajtyp .eq. 6) then
    
            nmc=nmc+1
          else if (inptrajtyp .eq. 4 .or.
         -  inptrajtyp .eq. 5 .and. ninconf .eq. 1) then
            ncol=132
            read (inpt,1000,err=1098,end=1099) trtitle(1)
            do i=1,n
              read (inpt,1001,err=1098,end=1099) line
              read (line(53:88),1016,err=1098) (c(k,i),k=1,3)
            end do
            nmc=nmc+1
          else if (inptrajtyp .eq. 5 .and. ninconf .gt. 1) then
            ncol=132
            read (inpt,1000,err=1098,end=1099) line
            do i=1,n
              read (inpt,1000,err=1098,end=1099) line
              read (line(6:41),1016,err=1098) (c(k,i),k=1,3)
            end do
            nmc=nmc+1
          end if
          if (inptrajtyp .gt. 1) then
            do k=1,3
              xtlabc(ixcrd(k))=box(k)*tofac
              xtlabc(ixang(k))=90.0
            end do
          end if
          return
    1095  write (6,1004) ninconf,trajformatname,' xtal   ',' ',inpt
          if (ncol .gt. 0) write (6,1006) line(1:ncol)
          ifail=1
          return
    1096  write (6,1004) ninconf,trajformatname,' coordinate ',xyz(k),inpt
          write (6,*) 'nfreeat,natom=',nfreeat,natom
          if (ncol .gt. 0) write (6,1006) line(1:ncol)
          ifail=1
          return
    1097  write (6,1004) ninconf,trajformatname,' header ',' ',inpt
          if (ncol .gt. 0) write (6,1006) line(1:ncol)
          ifail=1
          return
    1098  write (6,1004) ninconf,trajformatname,' coordinate ',xyz(k),inpt
          if (ncol .gt. 0) write (6,1006) line(1:ncol)
          ifail=1
          return
    1099  if (ilast .eq. 999999) then
            write (6,1008) trajformatname,ninconf-1
            ilast=ninconf-1
          else
            call nextnames(trajnam,ltrajnam,trajnam_n,ltrajnam_n,ntraj)
            ntry=0
            do while (ntry .lt. ntraj)
              ntry=ntry+1
              call opentraj(c,0,inpt,inptrajtyp,n,ntitltr,trtitle,inpcrdtyp,
         -      ifirst,ilast,increment,maxconf,ninconf,noutconf,natom,
         -      nfreeat,ifree,icntrl,1,mmctrajtyp,trajnam_n(ntry),
         -      ltrajnam_n(ntry),'input trajectory',16,iconfsel,numsel,
         -      0,1,2,2,icellfound,notfnd,0,0,lentest,0,0,0,maxconfsel,
         -      maxrec)
              if (notfnd .eq. 0) then
                trajnam=trajnam_n(ntry)
                ltrajnam=ltrajnam_n(ntry)
                write (6,1014) trajnam(1:ltrajnam)
                ntry=ntraj
              end if
            end do
            if (notfnd .gt. 0) then
              write (6,1005) trajformatname,ninconf,
         -     (trajnam_n(ntry)(1:ltrajnam_n(ntry)),ntry=1,ntraj)
              if (ncol .gt. 0) write (6,1007) line(1:ncol)
              ifail=1
            end if
          end if
          return
    2099  print *,'ERROR: invalid binary MMC record found - ending scan'
          ifail=1
          return
    1000  format(a80)
    1001  format(a132)
    1002  format(i5)
    1003  format(20x,3f10.0)
    1004  format(' ERROR: configuration #',i5,' of the ',a6,
         -  ' trajectory has invalid',a,'input ',a,' inpt=',i2)
    1005  format(' ERROR: ',a6,' trajectory unexpectedly ended',/,
         -  8x,'End was found while reading configuration #',i8,/,
         -  ' If the trajectory is in segments, possible names are ',/,
         -  (1x,a))
    1006  format(' Line read:',/,a)
    1007  format(' Last line read:',/,a)
    1008  format(1x,a6,' trajectory was found to contain ',i5,
         -  ' configurations')
    1009  format(' Number of atoms set to ',i6,' from the Charmm ',
         -  'trajectory')
    1010  format(9x,3f10.0)
    1011  format(3f8.0)
    1012  format(10f8.3)
    1013  format(' ERROR: invalid atom/molecule numbers indicate that',/,
         -  8x,'MMC binary trajectory does not have box info saved',/,
         -  ' - restart without asking for drawing the box')
    1014  format(' Next trajectory segment ',a,' opened')
    1015  format(19x,e16.6)
    1016  format(3f12.5)
    1017  format(3f15.5)
    1018  format(5x,3f15.5)
    1019  format(i6,9x,i6,8x,i6,7x,2i6,5x,i9,4x,f8.0)
    1020  format(' ERROR: no ATOM or HETATM record was found when reading',
         -  ' configuration',i6)
          end
          subroutine nextnames(trajnam,ltrajnam,trajnam_n,ltrajnam_n,ntraj)
          character*200 trajnam,trajnam_n(2)
          character*80 ext
          dimension ltrajnam_n(2)
          do i=1,2
            trajnam_n(i)=trajnam
          end do
          lc=ltrajnam
          do while (trajnam(lc:lc) .ne. '.')
            lc=lc-1
          end do
          lext=ltrajnam-lc+1
          ext(1:lext)=trajnam(lc:ltrajnam)
          lc=lc-1
          lv2=lc
          do while (trajnam(lc:lc) .ne. '.' .and.
         -          trajnam(lc:lc) .ne. '_' .and. lc .gt. 1)
            lc=lc-1
          end do
          if (lc .ge. lv2) go to 100
          read (trajnam(lc+1:lv2),*,err=100) nr
          len_nr=lv2-lc
          if (trajnam(lc:lc) .eq. '.') then
            lr=lc+1
            ntraj=2
            lc=lv2+2
            trajnam_n(1)(lv2+1:lc)='_2'
            trajnam_n(1)(lc+1:lc+lext)=ext(1:lext)
            ltrajnam_n(1)=lc+lext
            nr=nr+1
            call writeint(trajnam_n(2),lr,nr,len)
            lc=lr-1
            trajnam_n(2)(lc+1:lc+lext)=ext(1:lext)
            ltrajnam_n(2)=lc+lext
          else
            nv=nr
            lr2=lc-1
            do while (trajnam(lc:lc) .ne. '.' .and. lc .gt. 1)
              lc=lc-1
            end do
            lr=lc+1
            if (lc .ge. lr2) go to 200
            read (trajnam(lc+1:lr2),*,err=200) nr
            nv0=nv
            ntraj=2
            nv=nv+1
            lc=lv2-len_nr+1
            print *,'lv2,lc=',lv2,lc
            call writeint(trajnam_n(1),lc,nv,len)
            lc=lc-1
            trajnam_n(1)(lc+1:lc+lext)=ext(1:lext)
            ltrajnam_n(1)=lc+lext
            nr=nr+1
            lr0=lr
            call writeint(trajnam_n(2),lr,nr,len)
            trajnam_n(2)(lr:lr)='_'
            lr=lr+1
            call writeint(trajnam_n(2),lr,nv0,len)
            lc=lr-1
            trajnam_n(2)(lc+1:lc+lext)=ext(1:lext)
            ltrajnam_n(2)=lc+lext
          end if
          return
    200   continue
          ntraj=2
          lc=lr2+3
          trajnam_n(1)(lr2+1:lc)='.2_'
          lc=lc+1
          call writeint(trajnam_n(1),lc,nv,len)
          lc=lc-1
          trajnam_n(1)(lc+1:lc+lext)=ext(1:lext)
          ltrajnam_n(1)=lc+lext
          lc=lv2
          nv=nv+1
          call writeint(trajnam_n(2),lc,nv,len)
          lc=lc-1
          trajnam_n(2)(lc+1:lc+lext)=ext(1:lext)
          ltrajnam_n(2)=lc+lext
          return
    100   ntraj=2
          lc=lv2+2
          trajnam_n(1)(lv2+1:lc)='.2'
          trajnam_n(1)(lc+1:lc+lext)=ext(1:lext)
          ltrajnam_n(1)=lc+lext
          trajnam_n(2)(lv2+1:lc)='_2'
          trajnam_n(2)(lc+1:lc+lext)=ext(1:lext)
          ltrajnam_n(2)=lc+lext
          return
          end
          subroutine trajlimtest(nframe,MAXFRAMES)
          if (nframe .gt. MAXFRAMES) then
            write (6,1004)
            stop
          end if
    1004  format(' Calculation stopped since this option is limited to ',
         -  'reading ',i8,' frames',/,' Recompile with larger value of ',
         -  'the parameter MAXFRAMES')
          end
          subroutine checkforetot(lmarker,line,iconf,etot,ietot,iverb)
          character* 132 line
          icol=lmarker+1
          call nextchar(line,icol,80)
          if (icol .gt. 80) return
          icol1=icol
          call nextblank(line,icol,80)
          icol=0
          if (line(icol1:icol1+1) .eq. 'E=') then
            icol=icol1+2
          else if (line(icol1:icol1+6) .eq. 'energy=' .or.
         -    line(icol1:icol1+6) .eq. 'Energy=') then
            icol=icol1+7
          end if
          if (icol .gt. icol1) then
            call nextchar(line,icol,80)
            icol1=icol
            call nextblank(line,icol,80)
            read (line(icol1:icol-1),*,err=100) etot
            ietot=1
            if (iverb .gt. 0)
         -    print *,' Structure ',iconf,' Energy read=',etot
          end if
          return
    100   print *,'ERROR: invalid energy value:',line(icol1:icol-1)
          return
          end
          subroutine comparetop(c,n,nneig,ineig,iatnum,innlist,nslt,nslv,
         -  cell,ncell,ioppbc,maxng,mxat)
          dimension c(3,mxat),nneig(mxat),ineig(maxng,mxat),iatnum(mxat),
         -  cell(3,ncell)
          common /connatdat/ ramax(99),ramax2(99),hlimfac,ianfg(99),
         -  namfcg(100),nrmw
          if (innlist .lt. 0) return
          if (innlist .eq. 0) then
            print *,'PROGRAM ERROR: no neighbour list in topology check'
            return
          end if
          discrepmax=0.0
          nfail=0
          do ia=1,n
            do jja=1,nneig(ia)
              ja=ineig(jja,ia)
              if (ja .gt. ia) then
                r2=dist2(c(1,ia),c(1,ja))
                rlm=amax1(ramax2(iatnum(ia)),ramax2(iatnum(ja)))*1.2
                if (iatnum(ia) .eq. 1 .or. iatnum(ja) .eq. 1)
         -         rlm=rlm*hlimfac
                if (r2 .gt. rlm) then
                  nfail=nfail+1
                  if (nfail .le. 25) write (6,1000) ia,ja,sqrt(r2)
                  if (r2 .gt. discrepmax) discrepmax=r2
                end if
              end if
            end do
          end do
          if (nfail .gt. 0) write (6,1001) nfail,sqrt(discrepmax)
          percout=0.0
          if (ioppbc .gt. 0 .and. n-nslt .gt. 100) then
            nout=0
            numslv=(n-nslt)/nslv
            do iw=1,numslv
              call genimdist(c(1,nslt+(iw-1)*nslv+1),cell,1,ncell,img,d2)
              if (img .gt. 1) nout=nout+1
            end do
            if (nout .gt. 0) write (6,1002) nout
            percout=float(100*nout)/float(numslv)
            if (percout .gt. 2.0)
         -    print *,'The PBC cell may have been incorrectly specified'
          end if
          if (nfail .gt. 0 .or. percout .gt. 2.0) then
            call askstop(1)
          else
            print *,'First frame topology and solvent PBC checks passed'
          end if
          return
    1000  format(' Atoms',i6,' and ',i6,' are bonded in the input ',
         -  'structure but ',/,6x,'they are ',f6.2,' A apart in the ',
         -  'first frame of the trajectory')
    1001  format(' There were ',i6,' discrepancies',/,
         -  ' The largest discrepancy=',f8.2,' A',/,
         -  ' Large discrepancies usually arise when the structure file',/,
         -  ' does not correspond to the trajectory.')
    1002  format(i6,' solvents appear to be outside the periodic cell')
          end
          subroutine makeoniom(inpcrdtyp,inpfile,outfiletmp,namleni,
         -  namlentmp,n,nslt,naslv,islvw,c,index,iatnum,ifchrg,indexn,
         -  indexo,indexs,mmtype,isegno,ixres,ih,ibnd,ifgtyp,nneig,nneiga,
         -  nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,molresflag,
         -  hblimfac,angmin,ipotcol1,ipotcol2,iqcol1,iqcol2,irescol1,
         -  irescol2,nrescol,inamcol1,inamcol2,nnamcol,maxrepconf,innlist,
         -  nconfig,line,radtodeg,maxng,maxrsd,maxrec)
          character*200 inpfile,outfiletmp
          character* 132 line(maxrec),ansline
          dimension c(3,n),index(n),iatnum(n),ifchrg(n),indexn(n),indexo(n),
         -  indexs(n),mmtype(n),isegno(n),ixres(n),ih(n),ibnd(maxng,maxrec),
         -  ifgtyp(maxrec),nneig(n),ineig(maxng,n),nhbneig(n),nneiga(n),
         -  nhneig(n),nnneig(n),ncneig(n),nsneig(n),npneig(n),
         -  molresflag(maxrsd)
          character*1 aanames1
          character*2 mmodtoamb
          character*3 aanames3
          common /atnamcon/ mmodtoamb(100),aanames1(58),aanames3(58),
         -  naanames,nnanames,nnammnames,nnames,ixwatnam
          character*2 iatnm2
          common /atnam/ aw(99),nval(99),nvalmax(99),mmofan(99),
         -  mmatno(64),iatnm2(99)
          character*5 crdext
          common /iotypes/ iocha,iochaex,iobpdb,iocpdb,ioa3pdb,ioa4pdb,
         -  iommod,iommc,iommc4,iogro,iomol2,iomae,iocif,ioxxx,ioins,
         -  ionxyz,iosxyz,iosxyzrq,iograsp,iofull,lext(19),crdext(19)
          dimension ihml(3),qhmlsum(3),nonredlist(6)
          character*1 HMtyp,gcent,hml(3),s1
          character*2 ambtyp
          character*4 potnam
          character*8 resnam,atomnam
          character*80 prtline
          data hml /'H','M','L'/
          call changeext(inpfile,outfiletmp,namleni,namlentmp,'onm',3,0,0)
          nosolv=1
          if (n .gt. nslt)
         -  call askyn('Do you want to include the solvents too',39,0,-1,
         -    nosolv,0,0)
          nats=nslt
          if (nosolv .eq. 0) nats=n
          print *,'ONIOM input file: ',outfiletmp(1:namlentmp)
          call openfile(21,0,' ',1,'new',outfiletmp,namlentmp,notfnd,
         -  0,1,1,0,0)
          call quiz(HMtyp,iHMtyp,' ','ONIOM',5,'region definition mode',22,
         -  0,5,6,0)
          if (HMtyp .eq. 'l') then
            print *,'Specify list of H atoms'
            call getlist(indexn,nhigh,1,nslt,1,nslt)
            print *,'Specify list of M atoms'
            call getlist(indexo,nmid,1,nslt,1,nslt)
          else if (HMtyp .eq. 's') then
            call getint('Atom number at the center of the quantum part',45,
         -    1,1,nslt,iqcent,56)
            call getreal('Radius of the H region',22,5.0,rh,1,56)
            call getreal('Radius of the M region',22,10.0,rm,1,56)
          end if
          do i=1,3
            ansline(1:37)='Do you want to keep the '//hml(i)//' layer fixed'
            call askyn(ansline(1:37),37,1,-1,ihml(i),0,0)
          end do
          if (ipotcol1*iqcol1 .gt. 0) then
            mmcformat=1
          else
            mmcformat=2
          end if
          potnam='    '
          resnam='        '
          nunknown=0
          nunknownr=0
          qsum=0.0
          qslt=0.0
          natprt=0
          iconvfile=0
          ideoxymmc=-1
          if (inpcrdtyp .gt. ioins) then
            print *,'ERROR: input format does not have atom names'
            stop
          end if
          if (iqcent .gt. 0) then
            nhigh=0
            nmid=0
            nlow=0
            do ia=1,nats
              if (dist2(c(1,iqcent),c(1,ia)) .le. rh**2) then
                ih(ia)=1
                nhigh=nhigh+1
                indexn(nhigh)=ia
              else if (dist2(c(1,iqcent),c(1,ia)) .le. rm**2) then
                ih(ia)=3
                nmid=nmid+1
              else
                ih(ia)=5
                nlow=nlow+1
              end if
            end do
            call zeroiti(mmtype,0,nats)
            call askyn('Do you want to prevent non C-C bond break',41,1,-1,
         -    icconly,0,0)
            if (icconly .eq. 1) then
              call nnlist(nslt,nslt,naslv,n,iatnum,ifchrg,c,nneig,nneiga,
         -      nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,line,
         -      irescol1,irescol2,inamcol1,inamcol2,index,nconfig,innlist,
         -      molresflag,hblimfac,angmin,0,ibnd,ifgtyp,isegno,ixres,
         -      maxrepconf,0,0,radtodeg,0,maxng,maxng,maxrsd,maxrec)
              nhighprev=nhigh
              nhighprev0=nhigh
              iscan=1
              do while (iscan .eq. 1)
                do iaa=1,nhighprev
                  ia=indexn(iaa)
                  do jaa=1,nneig(ia)
                    ja=ineig(jaa,ia)
                    if (ih(ja) .ne. 1 .and.
         -              (iatnum(ia) .ne. 6 .or. iatnum(ja) .ne. 6)) then
                      if (ih(ja) .eq. 3) nmid=nmid-1
                      if (ih(ja) .eq. 5) nlow=nlow-1
                      nhigh=nhigh+1
                      indexn(nhigh)=ja
                      ih(ja)=1
                    end if
                  end do
                end do
                if (nhigh .eq. nhighprev) iscan=0
                nhighprev=nhigh
              end do
              print *,'Added ',nhigh-nhighprev0,' atoms to H list to avoid',
         -      ' breaking non C-C bonds'
              do iaa=1,nhigh
                ia=indexn(iaa)
                do jaa=1,nneig(ia)
                  ja=ineig(jaa,ia)
                  if (ih(ja) .ne. 1) mmtype(ia)=ja
                end do
              end do
            end if
            nm=0
            do ia=1,nats
              if (ih(ia) .eq. 3) then
                nm=nm+1
                indexo(nm)=ia
              end if
            end do
            if (nm .ne. nmid) print *,'PROGRAM ERROR nm NE nmid:',nm,nmid
            if (icconly .eq. 1) then
              nmidprev=nmid
              nmidprev0=nmid
              iscan=1
              do while (iscan .eq. 1)
                do iaa=1,nmidprev
                  ia=indexo(iaa)
                  do jaa=1,nneig(ia)
                    ja=ineig(jaa,ia)
                    if (ih(ja) .gt. 3 .and.
         -              (iatnum(ia) .ne. 6 .or. iatnum(ja) .ne. 6)) then
                      nlow=nlow-1
                      nmid=nmid+1
                      indexo(nmid)=ja
                      ih(ja)=3
                    end if
                  end do
                end do
                if (nmid .eq. nmidprev) iscan=0
                nmidprev=nmid
              end do
              print *,'Added ',nmid-nmidprev0,' atoms to M list to avoid',
         -      ' breaking non C-C bonds'
              do iaa=1,nmid
                ia=indexo(iaa)
                do jaa=1,nneig(ia)
                  ja=ineig(jaa,ia)
                  if (ih(ja) .eq. 5) mmtype(ia)=ja
                end do
              end do
            end if
          else
            do ia=1,nats
              ih(ia)=5
            end do
            do ia=1,nhigh
              ih(indexn(ia))=1
            end do
            do ia=1,nmid
              ih(indexo(ia))=3
            end do
          end if
          call trnsfi(indexs,indexn,nhigh)
          call trnsfi(indexs(nhigh+1),indexo(nhigh+1),nmid)
          ia=nhigh+nmid
          if (iord .eq. 1) then
            do iaa=1,nats
              if (ih(iaa) .eq. 5) then
                ia=ia+1
                indexs(ia)=iaa
              end if
            end do
            if (ia .ne. nats) print *,'PROGRAM ERROR: ia NE nats:',ia,nats
          else
            call indexit(indexs,1,nats,0)
          end if
          potnam='    '
          resnam='        '
          nunknown=0
          nunknownr=0
          qsum=0.0
          qslt=0.0
          natprt=0
          nfix=0
          iconvfile=0
          ideoxymmc=-1
          call askyn('Do you want to reorder by ONIOM type',36,1,-1,iord,0,
         -  0)
          if (nconfig .eq. 1)
         -  call getconvdat(2,5,5,nconvdat,iconvtyp,n,line,index,
         -    inamcol1,inamcol2,nnamcol,irescol1,irescol2,igrpinfo,maxrec)
          call zeroit(qhmlsum,3)
          do iaa=1,nats
            ia=indexs(iaa)
            atomnam(1:nnamcol)=line(index(ia))(inamcol1:inamcol2)
            if (iqcol1 .gt. 0)
         -    call readreal(line(index(ia)),iqcol1,iqcol2,qslt)
            resnam(1:nrescol)=line(index(ia))(irescol1:irescol2)
            if (nrescol .gt. 3) call blankout(resnam,4,nrescol)
            if (nrescol .gt. 4) call leftadjustn(resnam,resnam,nrescol)
            if (mmcformat .eq. 1) then
              if (inpcrdtyp .eq. ioins) then
                ambtyp=line(index(ia))(ipotcol1:ipotcol2)
              else if (inpcrdtyp .eq. iommod) then
                call readint(line(index(ia)),ipotcol1,ipotcol2,mmodtyp,4,1,
         -        irerr)
                ambtyp=mmodtoamb(mmodtyp)
              end if
              potnam(1:2)=ambtyp
            else if (mmcformat .eq. 2) then
              call PDBtommc(resnam,atomnam,potnam,qslt,ia,gcent,igr,
         -      ideoxymmc,iconvfile,nunknown,nunknownr)
            end if
            layer=(ih(ia)+1)/2
            s1=hml(layer)
            qhmlsum(layer)=qhmlsum(layer)+qslt
            ncol=62
            write (prtline,1266) (c(k,ia),k=1,3),s1
            if (mmtype(ia) .ne. 0) then
              prtline(63:64)=' H'
              write (prtline(65:70),1011) indexs(mmtype(ia))
              ncol=ncol+8
            end if
            ian=max0(1,ianum(atomnam,0,nnamcol))
            prtline(2:3)=iatnm2(ian)
            ic=4
            if (prtline(3:3) .eq. ' ') ic=ic-1
            prtline(ic:ic)='-'
            prtline(ic+1:ic+4)=potnam
            icn=ic+4
            do while (ic .le. icn .and. prtline(ic:ic) .ne. ' ')
              ic=ic+1
            end do
            prtline(ic:ic)='-'
            if (qslt .lt. 0.0) then
              write (prtline(ic+1:ic+7),1267) qslt
              ic=ic+7
            else
              write (prtline(ic+1:ic+6),1268) qslt
              ic=ic+6
            end if
            qsum=qsum+qslt
            layer=(ih(ia)+1)/2
            if (ihml(layer) .eq. 1) then
              nfix=nfix+1
              prtline(ic+2:ic+3)='-1'
            end if
            natprt=natprt+1
            write (21,1010) prtline(1:ncol)
          end do
          call askyn('Do you want to generate topology input too',42,
         -  1,-1,itop,0,0)
          if (itop .eq. 1) then
            call nnlist(nslt,islvw,naslv,n,iatnum,ifchrg,c,nneig,nneiga,
         -    nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,line,
         -    irescol1,irescol2,inamcol1,inamcol2,index,nconfig,innlist,
         -    molresflag,hblimfac,angmin,0,ibnd,ifgtyp,isegno,ixres,
         -    maxrepconf,0,0,radtodeg,0,maxng,maxng,maxrsd,maxrec)
            call bondord(iatnum,mmtype,n,nneig,ineig,nhneig,ibnd,maxng,c,
         -    index,ncneig,nsneig,inamcol1,inamcol2,irescol1,irescol2,line,
         -    nconfig,maxrepconf,maxrec)
            if (nosolv .eq. 0) then
              call askyn('Do you want to add H-H bonds to the solvent',43,
         -      1,-1,ihh,0,0)
              if (ihh .eq. 1) then
                nw=(n-nslt)/naslv
                do iw=1,nw
                  incr=nslt+(iw-1)*naslv
                  do ia1=incr+1,incr+naslv-1
                    atomnam(1:nnamcol)=line(index(ia1))(inamcol1:inamcol2)
                    ian1=max0(1,ianum(atomnam,0,nnamcol))
                    do ia2=ia1+1,incr+naslv
                      atomnam(1:nnamcol)=line(index(ia2))(inamcol1:inamcol2)
                      ian2=max0(1,ianum(atomnam,0,nnamcol))
                      if (ian1 .eq. 1 .and. ian2 .eq. 1) then
                        nneig(ia1)=nneig(ia1)+1
                        nneig(ia2)=nneig(ia2)+1
                        ineig(nneig(ia1),ia1)=ia2
                        ineig(nneig(ia2),ia2)=ia1
                        ibnd(nneig(ia1),ia1)=1
                        ibnd(nneig(ia2),ia2)=1
                      end if
                    end do
                  end do
                end do
              end if
            end if
            write (21,1010)
            do iaa=1,n
              ia=indexs(iaa)
              nn=nneig(ia)
              if (nn .gt. 6) then
                write (6,1270) ia,nn,(ineig(indexs(ja),ia),ja=1,nn)
                nn=6
              else
                nng=0
                do in=1,nn
                  if (ineig(indexs(in),ia) .gt. ia) then
                    nng=nng+1
                    nonredlist(nng)=indexs(in)
                  end if
                end do
                write (21,1260) ia,
         -      (ineig(nonredlist(ja),ia),ibnd(nonredlist(ja),ia),ja=1,nng)
              end if
            end do
          end if
          close(21)
          write (6,1269) outfiletmp(1:namlentmp),
         -  nhigh,nmid,nlow,qhmlsum,qsum,nunknown,natprt,nfix
          call trnsfi(isegno,ih,n)
          return
    1010  format(a)
    1011  format(i6)
    1260  format(i5,6(i6,i3,'.0'))
    1266  format(20x,3f13.7,2x,a1)
    1267  format(f7.4)
    1268  format(f6.4)
    1269  format(' Oniom input file is written to file ',/,7x,a,/
         -  ' Number of atoms in the high, middle and low regions:',3i7,/,
         -  ' Charge sums: H=',f8.4,' M=',f8.4,' L=',f8.4,' Total=',f8.4,
         -  /,' Number of unassigned atoms=',i5,/,
         -  ' Total number of atoms printed=',i6,/,
         -  ' Number of atoms kept fixed=',i6)
    1270  format(' ERROR: Atom ',i5,' has more than 6 neighbours - ',
         -  '(format has to be changed):',/,(10i8))
          end
          subroutine makeamsol(n,c,iatnum,nneig,ineig,iqcol1,iqcol2,line,
         -  index,indexn,inpcrdtyp,nconfig,iout,maxng,maxrec)
          dimension c(3,n),iatnum(n),nneig(n),ineig(maxng,n),
         -  index(n),indexn(n)
          character* 132 line(maxrec)
          character*2 iatnm2
          common /atnam/ aw(99),nval(99),nvalmax(99),mmofan(99),
         -  mmatno(64),iatnm2(99)
          character*5 crdext
          common /iotypes/ iocha,iochaex,iobpdb,iocpdb,ioa3pdb,ioa4pdb,
         -  iommod,iommc,iommc4,iogro,iomol2,iomae,iocif,ioxxx,ioins,
         -  ionxyz,iosxyz,iosxyzrq,iograsp,iofull,lext(19),crdext(19)
          print *,'Generating Amsol 3.5 input config no=',nconfig
          iqsum=0
          if (iqcol1 .gt. 0) then
            qsum=0.0
            do ia=1,n
              call readreal(line(index(ia)),iqcol1,iqcol2,qslt)
              qsum=qsum+qslt
            end do
            if (qsum .gt.  0.0) iqsum=qsum+0.1
            if (qsum .lt.  0.0) iqsum=qsum-0.1
            print *,'Total charge on the molecule is assumed to be ',iqsum,
         -  ' CHECK!'
          else
            call getint('The charge on the molecule',26,999999,1,0,iqsum,0)
          end if
          do i=1,n
            indexn(i)=99
          end do
          do i=1,n
            if (nneig(i) .gt. 0) then
              if (iatnum(i) .eq. 1) then
                if (iatnum(ineig(1,i)) .eq. 6) indexn(i)=1
                if (iatnum(ineig(1,i)) .eq. 7) indexn(i)=2
                if (iatnum(ineig(1,i)) .eq. 8) indexn(i)=3
                if (iatnum(ineig(1,i)) .eq. 16) indexn(i)=4
                if (iatnum(ineig(1,i)) .eq. 15) indexn(i)=14
              else if (iatnum(i) .eq. 6) then
                indexn(i)=1
              else if (iatnum(i) .eq. 7) then
                if (nneig(i) .ge. 3) indexn(i)=5
                if (nneig(i) .le. 2) indexn(i)=6
              else if (iatnum(i) .eq. 8) then
                if (nneig(i) .eq. 1) indexn(i)=8
                if (nneig(i) .eq. 2) indexn(i)=7
              else if (iatnum(i) .eq. 9) then
                indexn(i)=9
              else if (iatnum(i) .eq. 16) then
                indexn(i)=10
              else if (iatnum(i) .eq. 17) then
                indexn(i)=11
              else if (iatnum(i) .eq. 35) then
                indexn(i)=12
              else if (iatnum(i) .eq. 53) then
                indexn(i)=13
              else if (iatnum(i) .eq. 15) then
                indexn(i)=14
              end if
            end if
          end do
          nunknown=0
          do i=1,n
            if (indexn(i) .eq. 99) nunknown=nunknown+1
          end do
          if (nunknown .gt. 0)
         -  print *,'WARNING: ',nunknown,' atoms have no SM1A type'
          write (iout,2049) iqsum
          do i=1,2
            if (ischarmm(inpcrdtyp) .eq. 1 .and. line(i)(1:1) .eq. '*')
         -    call writeline(iout,line(i),2,81,0)
            if ((ispdb(inpcrdtyp) .gt. 0) .and.
         -    (line(i)(1:6) .eq. 'REMARK' .or. line(i)(1:6) .eq. 'HEADER'))
         -       call writeline(iout,line(i),8,87,0)
            if (inpcrdtyp .eq. iommod .and. i .eq. 1) then
               call writeline(iout,line(i),7,86,0)
               call writeline(iout,line(i),87,132,0)
            end if
            if (inpcrdtyp .ge. ioins)
         -    write (iout,*)'Input generated by Simulaid'
          end do
          write (iout,2050) (iatnm2(iatnum(i)),(c(k,i),k=1,3),i=1,n)
          write (iout,*)
          write (iout,1005) (indexn(i),i=1,n)
          close (iout)
          return
    1005  format(i3)
    2049  format('AM1 SM1A T=20000 1SCF XYZ CHARGE=',i2)
    2050  format((a5,3(f10.5,' 0')))
          end
          subroutine analyze(nconfig,inpcrdtyp,inpcrdtyporg,ianaltyp,
         -  extnam1,analfile,inpfile,namleni,line,index,n,nslt,nmolslt,
         -  numres,nresslt,c,atw,rprox,cv,charge,iatnum,ifchrg,ncl,nneig,
         -  nneiga,nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,mmtype,
         -  molsltlim,isegno,altcol,inscol,ninsres,ih,ifgtyp,molresflag,
         -  cres,chn,c2,cdp,cdp2,temp,ibnd,indexn,indexo,indexs,indexa,
         -  indexdel,ifree,icntrl,indexov,indexrmsd,itemp1,itemp2,itemp3,
         -  itemp4,irrix,naslv,islvw,innlist,hblimfac,angmin,iresno,ixres,
         -  ixresno,ixsegno,ifres,ilres,irepav,irepmx,irepeng,irepkm,
         -  irescol1,irescol2,iresncol1,iresncol2,inamcol1,inamcol2,iqcol1,
         -  iqcol2,idcol,segid4,resnamslv,atnames,resnames,irescount1,
         -  irescount2,irescount3,listrefres,listnegres,segnames,ianc_anc,
         -  dssplab,idistdssp,marker,iwhead,nsegslt,isc,reportqmin,ntitlin,
         -  ntitlinw,title,version,iresnrestart,iresidrestart,blankline,
         -  label2d,inptrajtyp,mmctrajtyp,itraj,ireorient,centgra,iconfsel,
         -  numsel,nclstmem,iresshift,lastanal,ifixq,nhbdist,rhbdist,iwt,
         -  rlim,iqspaceask,icharges,iallheavy,keeprem,innlistread,lentest,
         -  pi,radtodeg,asterisk,mflogfile,maxconfsel,maxrepconf,maxng,
         -  maxbox,mxbonds,maxrsd,maxrec,maxrec10,maxrcorr,mx2d)
          dimension nneig(maxrec),ineig(maxng,maxrec),iatnum(maxrec),
         -  c(3,maxrec10),atw(maxrec),cv(maxrec),charge(maxrec),
         -  nhbneig(maxrec),nneiga(maxrec),nhneig(maxrec),nnneig(maxrec),
         -  ncneig(maxrec),nsneig(maxrec),npneig(maxrec),index(maxrec),
         -  ifgtyp(maxrec),molresflag(maxrsd),isegno(maxrec),ifchrg(maxrec),
         -  mmtype(maxrec),iresno(maxrec),ixres(maxrec),ixresno(maxrsd),
         -  ixsegno(maxrsd),ifres(maxrsd),ilres(maxrsd),irepav(mx2d),
         -  irepmx(mx2d),irepeng(mx2d),irepkm(mx2d),irescount1(maxrsd),
         -  irescount2(maxrsd),irescount3(maxrsd),listrefres(maxrsd),
         -  listnegres(maxrsd),ih(maxrec),cres(3,maxrec10),chn(3,maxrec),
         -  c2(3,maxrec),temp(maxrec),ibnd(maxbox,maxrec),ifree(maxrec),
         -  indexov(maxrec),indexrmsd(maxrec),itemp1(maxrec),itemp2(maxrec),
         -  itemp3(maxrec),itemp4(maxrec),irrix(maxrec),indexn(maxrec),
         -  indexo(maxrec),indexs(maxrec),indexa(maxrec),indexdel(maxrec),
         -  iconfsel(maxconfsel),nclstmem(mx2d),idistdssp(9,maxrsd),
         -  icntrl(20),centgra(3),molsltlim(3,maxrsd),ianc_anc(mxbonds),
         -  nhbdist(mxbonds),rhbdist(mxbonds),iwt(mx2d),rlim(maxng),
         -  rprox(maxrec),isc(maxrec)
          real*8 cdp(3,maxrec),cdp2(3,maxrec)
          character*1 asterisk,dssplab(maxrsd),altcol(maxrec),inscol(maxrec)
          character*4 segid4(nsegslt),segnames(maxrsd),extnam1,extnam2,
         -  extnam3
          character*8 resnam,rn,resnamslv,atnames(maxrec),resnames(maxrsd)
          character*6 marker(16)
          character*8 version
          character*24 askcolcode
          character*80 label2d(mx2d)
          character*200 inpfile,analfile,analfile1,analfile2,analfile3,
         -  analfile4,trackfile
          character* 132 line(maxrec),blankline
          character*2 iatnm2
          common /atnam/ aw(99),nval(99),nvalmax(99),mmofan(99),
         -  mmatno(64),iatnm2(99)
          character*11 trajformatname
          common /trajectory/ nmmccheck,iftrajtyp(6),trajformatname(6)
          character*200 trajnam,trajnam2
          common /trajname/ trajnam,trajnam2,ltrajnam,ltrajnam2,ifirsttraj,
         -  ifirsttraj2,ilasttraj,ilasttraj2,incrementtraj,incrementtraj2
          character*80 title,trtitle(32)
          character*4 namfcg
          character*4 tanames
          character*8 tnames
          common /tordat/ ntorn,tanames(4,28),tnames(28)
          common /connatdat/ ramax(99),ramax2(99),hlimfac,ianfg(99),
         -  namfcg(100),nrmw
          real*8 xtlabc,xtlabc0
          common /boxdat/ xtlabc(6),xtlabc0(6),box(3),box0(3),edge_gen(3,3),
         -  cell0(3,27),cell(3,27),cellalt(3,27),
         -  ncell,ioppbc,noboxinfoar,noboxinfow,noboxrep,
         -  istuner,iboxtypfound,ixcrd(3),ixang(3),ixyzhex(3),
         -  ixyzhextraj(3),isizewarn
          common /colorinfo/ ncolcode,maxcolcode
          common /graphics/ npixx,npixy,maxpixx,maxpixy,idwmain,idwplot,
         -  wx,wy,wz,wxdr
          common /rotmat/ matrot0(4,4),matrot(4,4),nomat0
          character*1 xyz
          common /axislab/ xyz(3)
          common /columnlim/ incol(19),iidcol(19),iialtcol(19),iiinscol(19),
         -  iinamcol(2,19),iirescol(2,19),iiccol(2,19),iiresncol(2,19),
         -  iiseqncol(2,19),iisegcol(2,19),iiresidcol(2,19),iiqcol(2,19),
         -  iipotcol(2,19),iiocccol(2,19),iichemcol(2,19)
          character*5 crdext
          common /iotypes/ iocha,iochaex,iobpdb,iocpdb,ioa3pdb,ioa4pdb,
         -  iommod,iommc,iommc4,iogro,iomol2,iomae,iocif,ioxxx,ioins,
         -  ionxyz,iosxyz,iosxyzrq,iograsp,iofull,lext(19),crdext(19)
          dimension edge(3),evals0(3),evecs0(3,3)
          character*4 pflsv(100)
          character*8 namesv(100)
          character*9 decidebend
          character*27 qq
          parameter (MAXBRIDGEATOM=8000,MAXBRIDGETYPE=50,MAXBRIDGELEN=4)
          common /bridges/ ianchor(MAXBRIDGEATOM),
         -  nbridgetype(MAXBRIDGELEN,MAXBRIDGEATOM),
         -  ibridgetype(MAXBRIDGETYPE,MAXBRIDGELEN,MAXBRIDGEATOM),
         -  lpath(MAXBRIDGETYPE,MAXBRIDGELEN,MAXBRIDGEATOM)
          parameter (MAXDDISTR=200,MAXCDLIST=2000,MAXDDBIN=20)
          dimension listpairdist(2,MAXDDISTR),npairdist(MAXDDBIN,MAXDDISTR),
         -  pairdistsum(MAXDDISTR),pairdistsum2(MAXDDISTR),
         -  pairdistwsum(2,MAXDDISTR),pairdistminmax(2,MAXDDISTR),
         -  iclustermem(MAXCDLIST),ifstclst1(MAXDDISTR),
         -  ifstclst2(MAXDDISTR),ilstclst2(MAXDDISTR)
          character*1 typc
          character*21 ssname
          common /dsspnames/ lssname(9),ssname(9),typc(9)
          parameter (MAXRING=50)
          real*8 sinpsrs,cospsrs,qpsrs,qpsr2s,zavs,zsqs
          dimension sinpsrs(MAXRING),cospsrs(MAXRING),qpsr(MAXRING),
         -  qpsrs(MAXRING),qpsr2s(MAXRING)
          dimension psr(MAXRING),ix5(MAXRING),zring(MAXRING),rring(MAXRING)
          dimension iasv(100),qsv(100),ixlist(99),idelseg(1000),ialist(15),
         -  icatlist(15),psr5(5),itypsse(200),ifsse(200),ilsse(200)
          parameter (MAXHX=50)
          common /prokink/ icab(MAXHX),icaa(MAXHX),icb(MAXHX),ica(MAXHX),
         -  inb(MAXHX),ina(MAXHX),icapr,icpr,inpr,nra,nrb,icbpr,icgpr,icdpr,
         -  iprintpk
          common /analparm/ nsltref_f,nsltref_l,rcut_cv,icvtyp
          parameter (MAXFRAMES=50000,MAXCOPY=600)
          parameter (MAXCOPY1=MAXCOPY-1)
          common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
         -  increment,increment2,res(2,MAXFRAMES,MAXCOPY1),
         -  xyplot(2,MAXFRAMES),x0(MAXCOPY),y0(MAXCOPY),nxselres,
         -  ixselres(MAXCOPY)
          common /logging/ logfile,ipredict
          character*1 separatorchar
          common /filenuminfo/ iaskunderscore,separatorchar
          parameter (MAXNHX=12,MAXNHX2=(MAXNHX*(MAXNHX-1)))
          character*2 ap_pa,in_ex
          common /signs/ itmem,normhx,isg2(MAXNHX2),memdir(MAXNHX),ap_pa(3),
         -  in_ex(2)
          dimension iconfsel2(MAXFRAMES),rplot(MAXFRAMES)
          dimension anglechange(MAXHX,MAXNHX),anglechangeref(MAXHX,MAXNHX),
         -  angles(3,MAXNHX),anglesn(3,MAXNHX),helixlen(MAXNHX),
         -  helixlen0(MAXNHX),rcirchx(MAXNHX),turnperres(MAXNHX),
         -  ireshx1(MAXNHX),ireshx2(MAXNHX),iseghx(MAXNHX),nreshx(MAXNHX),
         -  icaahx(MAXHX,MAXNHX),icbahx(MAXNHX),icbreshx(MAXNHX),
         -  indexaxhx(3,MAXNHX),lhxhxlab(MAXNHX2)
          dimension plotdat(2,MAXFRAMES)
          character*24 hxhxlab(MAXNHX2)
          real*8 calph0(3,MAXHX,MAXNHX),perpvec0(3,MAXHX,MAXNHX),
         -  camod(3,MAXHX,MAXNHX),axfact(MAXHX,MAXNHX),
         -  calph(3,MAXHX,MAXNHX),perpvec(3,MAXHX,MAXNHX),
         -  axisdir(3,MAXNHX),axisini(3,MAXNHX),axisend(3,MAXNHX),
         -  helixcent(3,MAXNHX),circ(3,MAXNHX),axisdir0(3,MAXNHX),
         -  axisini0(3,MAXNHX),axisend0(3,MAXNHX),helixcent0(3,MAXNHX),
         -  rn0(3,MAXNHX),rnorm(3,MAXNHX),rms,ddd,sinphisum,cosphisum,
         -  sinpsisum,cospsisum,atwsum
          character*1 axdirchar(MAXNHX)
          dimension crmslt0(3),crmslt(3),rot(3,3),trajrot(3,3),nhelixok(3),
         -  dr(3),caref(3),caprev1(3),caprev2(3),
         -  drincr(3),drimg(3),com1(3),com2(3),indexax(3),
         -  dip1(3),sdxyx1(3),lbondname(6)
          parameter (MAXDISTR=1000,MAXDISTRN=10)
          dimension nframes_err(MAXDISTRN),err12(2,MAXDISTR),
         -  rmsfav(MAXDISTR),rmsfavs(2,MAXDISTR),bl(MAXDISTRN)
          real*8 distrerr(MAXDISTRN,MAXDISTR),rmsfsum(MAXDISTR),
         -  xcum(MAXDISTRN)
          character*1 analtyp,analinp,psrtyp,ansrun,marks(9),unit,ans
          character*1 tmchar,tmchars(2)
          character*4 ext1(45),ext2(45),ext3(45),atnam,bondlab(5)
          character*8 brslv
          character*6 hxoklab(3),crdexti
          character*7 mark0,mark1,mark2
          character*11 xtrajlabs(4),xtrajlab
          character*20 helixcklab
          character*22 bondname(6)
          character*30 shiftlab
          character*80 question,linein,pstitle,system
          character*34 distlab,distlab_cc
          character*36 restitle
          character*22 atomdist
          character*25 prokinklab(5),helixang(6),helixrlab(14),rmsdlab(4),
         -  ramalab(MAXCOPY1),printrlab(10),volumelab(4)
          character*29 resrange
          character*30 talab(MAXCOPY1)
          character*80 plotdescr
          character*100 hostname
          character*200 trajnam1,trajnamr1,trajnamr2
          dimension lprokinklab(5),lhelixang(6),lhelixrlab(14),lrmsdlab(4),
         -  lramalab(MAXCOPY1),lprintrlab(10),lvolumelab(4),
         -  ltalab(MAXCOPY1),ixtor1234(4,MAXCOPY1)
          parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
          dimension it1(MAXBONDS),it2(MAXBONDS),it3(MAXBONDS),it4(MAXBONDS),
         -  it5(MAXBONDS),ixclst(MAXBONDS),index2d(MAXBONDS),
         -  ifhb2d(MAXBONDS),ilhb2d(MAXBONDS),ifa_s(MAXBONDS),
         -  ila_s(MAXBONDS),rmsdlim(MAXBONDS),value(MAXBONDS),engcl(MAX2D),
         -  ifclst1(MAX2D),ilclst1(MAX2D),index2d1(MAX2D),nsimclst1(MAX2D),
         -  ifclst2(MAX2D),ilclst2(MAX2D),index2d2(MAX2D),nsimclst2(MAX2D),
         -  irepmx1(MAX2D),irepmx2(MAX2D),ixshuffle(MAX2D),
         -  ixshuffleref(MAX2D),xtraj(MAXFRAMES)
          data marks /'*','+','#','|','@','%','x','-','='/
          data bondname /'hydrogen bond','hydrophobic bond','salt bridge',
         -  'heavy atom VdW contact','heavy atom MPX contact',
         -  'hydrogen-bond bridge'/
          data lbondname /13,16,11,22,22,20/
          data bondlab /'D..A','C..C','+..-',2*'A..A'/
          data shiftlab /'Helix shift in the Z direction'/
          data prokinklab /'Bend angle','Wobble','Face shift',
         -  'Wobble-Face shift','Pseudorotation phase'/
          data lprokinklab /10,6,10,22,20/
          data helixang /'Global helix X tilt-angle',
         -  'Global helix Y-tilt angle','Global helix Z-tilt angle',
         -  'Helix rotation','Local helix tilt angle','Turn angle per res.'/
          data lhelixang /25,25,25,14,16,19/
          data helixrlab /'Helix length','Curvature radius',
         -  'Total displacement (cent)','X-displacement (cent)',
         -  'Y-displacement (cent)','Z-displacement (cent)',
         -  'Normal-to-bend drift (X)','Normal-to-bend drift (Y)',
         -  'X-displacement (start)','Y-displacement (start)',
         -  'Z-displacement (start)','X-displacement (end)',
         -  'Y-displacement (end)','Z-displacement (end)'/
          data lhelixrlab /12,16,25,3*21,2*24,3*22,3*20/
          data rmsdlab /'RMSD (overlaid)   ','Max dev (overlaid)',
         -              'RMSD              ','Maximum deviation '/
          data lrmsdlab /17,19,4,19/,ltalab /MAXCOPY1*30/,
         -  ramalab/MAXCOPY1*'Residue                  '/,
         -  lramalab /MAXCOPY1*25/
          data volumelab /'V(solvent-excluded shell)',
         -  'V(first solvation shell)','V(solute)','V(interface)'/
          data lvolumelab /25,24,9,12/
          data ext1 /'.nnl','.n14','.fcg','.bnd','.hbn','.hpn','.stb',
         -    '.rsd','.dst','.cnt','.psr','.pkn','.hph','.cvl','.cvr',
         -    '.dss','.hbr','.ram','.dih','.phi','.axd','.rms','.rd2',
         -    '.rdx','.cor','.add','.svl','.pca','.rgh','.sum','.adj',
         -    '.ang','.mld','.ctb',4*'    ','.sdr','.flt','.mpx',4*'    '/
          data ext2 /'    ','    ','.bbn','    ','.ps ','.ps ','.ps ',
         -    '.rsm','.ps ','    ','    ','.ps ','    ','    ','.ps ',
         -    '.ps ','    ','.ps ','.ps ','    ','.ps ','.ps ','.ps ',
         -    '.ps ','.ps ','    ','.ps ','.pdb','.ps ','    ','.ps ',
         -    '.ps ','.mlc','.ps ',4*'    ','.ps ','    ','.ps ',4*'    '/
          data ext3 /7*'    ','.rmp',9*'    ','.rdp',3*'    ','.rmf',
         -  10*'    ','    ',12*'    '/
          data crdexti /'      '/,namlen_root /0/
          data hxoklab /'intact','broken','frayed'/
          data xtrajlabs /' N(frames) ','Picoseconds','Nanoseconds',
         -  'Miliseconds'/,nframes_err /MAXDISTRN*0/
          data lhxhxlab /MAXNHX2*24/
          data tmchars /'i','e'/
          data ifirst /1/, ilast /999999/,ifirst2 /1/, ilast2 /999999/,
         -  nframetotmin /50/,maxdevplot /0/,iunmatchplot /0/,
         -  nhneigmin /0/,numsel2 /0/,noprol /0/
          call testconst(0,1,2,0.0,1.0,2.0,6,nfail,1,'ANST')
          nmc=0
          maxcolcode=8
          iaskcolcode=0
          increment=1
          increment2=1
          call indexit(ixshuffle,1,MAX2D,0)
          call indexit(ixshuffleref,1,MAX2D,0)
          do i=1,MAXFRAMES
            xtraj(i)=i
          end do
          nanos=0
          ncolcode=maxcolcode
          write (askcolcode,2152) maxcolcode
          ireseq=-1
          nframesign=0
          nextconfsel=0
          iseqncol1=iiseqncol(1,inpcrdtyp)
          iseqncol2=iiseqncol(2,inpcrdtyp)
          is1=iisegcol(1,inpcrdtyp)
          is2=iisegcol(2,inpcrdtyp)
          nrescol=irescol2-irescol1+1
          nnamcol=inamcol2-inamcol1+1
          nsegcol=is2-is1+1
          innlistorig=innlist
          call trnsfr(cres,c,3*n)
          ifc=1
          call nextchar(title,ifc,1000)
          call lastchar(title,ltitle,80)
          call blankout(question,1,80)
          question(1:ltitle-ifc+1)=title(ifc:ltitle)
          title=question
          ltitle=ltitle-ifc+1
          ltitle76=min0(ltitle,76)
          natsorig=n
          nsegm=isegno(nslt)
          numanal=0
          iallrama=0
          iconfirmname=0
          iuseinp=0
          limresrange=0
          nhxres=15
          nfravgd=0
          nfravgt=0
    9000  idsspcheck=0
          ltrajnam2=0
          noprintconf=0
          iread2d=0
          etot2=0.0
          itypavg=0
          rmsdplotmax=0.0
          nfreqsd=0
          rmsfdplotmaxlotmax=0.0
          isdtyp=1
          ireadtracks=0
          ilastframe=0
          nbfound=0
          nbresfound=0
          nosameseg=0
          iadjust_xtraj=1
          ionefile=1
          numsolv=(n-nslt)/naslv
          ihbondcalc=0
          ibondtype=0
          inputref=0
          nbondavg=1
          nmcmaxbond=0
          maxbondf=0
          ifstrmsd=1
          nocontigrmsd=0
          ilstrmsd=nresslt
          iconndial=1
          mappdf=0
          if (nconfig .eq. 1) then
            call getatnumlist(n,iatnum,ifchrg,ialist,icatlist,ixlist,nanos)
            ires=0
            nres=0
            do ia=1,n
              if (iresno(ia) .ne. ires) then
                ires=iresno(ia)
                nres=nres+1
                resnames(nres)(1:irescol2-irescol1+1)=
         -        line(index(ia))(irescol1:irescol2)
              end if
            end do
            namleno=0
            namleno1=0
            namleno2=0
            extnam2='    '
            hbf0=hblimfac
            angm0=angmin
            listbridge=0
          end if
    9002  if (nconfig .eq. 1) then
            numanal=numanal+1
    9003    call quiz(analinp,ityp,' ',' ',0,'configuration analysis',22,
         -    0,5,6,0)
            if (analinp .eq. 'q') return
            analtyp=analinp
            if (analinp .eq. 'g') then
              call quiz(analtyp,ityp,' ',' ',0,
         -      'topology/geometry analysis',26,0,5,6,0)
              ianaltyp=ityp
            else if (analinp .eq. 'b') then
              call quiz(analtyp,ityp,' ',' ',0,'bond tracking',13,
         -      0,5,6,0)
              if (analtyp .eq. 'h') ianaltyp=5
              if (analtyp .eq. 'p') ianaltyp=6
              if (analtyp .eq. 's') ianaltyp=7
              if (analtyp .eq. 'b') ianaltyp=17
              if (analtyp .eq. 'c') ianaltyp=34
              if (analtyp .eq. 'm') ianaltyp=37
              if (analtyp .eq. 'u') ianaltyp=41
            else if (analinp .eq. 'y') then
              call quiz(analtyp,ityp,' ',' ',0,
         -      'atomic property calculation',27,0,5,6,101)
              if (analtyp .eq. 'y') ianaltyp=13
              if (analtyp .eq. 'c') ianaltyp=14
              if (analtyp .eq. 'p') ianaltyp=20
            else if (analinp .eq. 'o') then
              call quiz(analtyp,ityp,' ',' ',0,
         -      'molecular property calculation',30,0,5,6,102)
              ianaltyp=26+ityp
              if (analtyp .eq. 'b') then
                if (ispdb(inpcrdtyp) .eq. 0) then
                  print *,'B factors are only used for PDB input'
                else
                  print *,'B-factor segment averages are printed above'
                end if
                go to 9003
              end if
            else if (analinp .eq. 'm') then
              call quiz(analtyp,ityp,' ',' ',0,'RMSD calculation',16,
         -      0,5,6,0)
              ianaltyp=21+ityp
              if (analtyp .eq. 'd') ianaltyp=38
            else if (analinp .eq. 'u') then
              call quiz(analtyp,ityp,' ',' ',0,'distance analysis',17,
         -      0,5,6,0)
              if (analtyp .eq. 'e') ianaltyp=8
              if (analtyp .eq. 'l') ianaltyp=33
              if (analtyp .eq. 'm') ianaltyp=31
              if (analtyp .eq. 'u') ianaltyp=9
              if (analtyp .eq. 't') ianaltyp=26
              if (analtyp .eq. 's') ianaltyp=39
              if (analtyp .eq. 'c') ianaltyp=10
              if (analtyp .eq. 'o') ianaltyp=36
            else
              if (analtyp .eq. 'a') ianaltyp=18
              if (analtyp .eq. 'i') ianaltyp=32
              if (analtyp .eq. 't') ianaltyp=19
              if (analtyp .eq. 'k') ianaltyp=12
              if (analtyp .eq. 'x') ianaltyp=21
              if (analtyp .eq. 'p') ianaltyp=11
              if (analtyp .eq. 's') ianaltyp=16
              if (analtyp .eq. 'v') ianaltyp=15
              if (analtyp .eq. 'f') ianaltyp=40
              ireadcov=0
              if (analtyp .eq. 'n') then
                call askyn('Do you have an input covariance matrix',38,1,-1,
         -        ireadcov,000,0)
                if (ireadcov .eq. 1) then
                  ianaltyp=35
                else
                  ianaltyp=25
                end if
              end if
              if (analtyp .eq. 'd') ianaltyp=30
            end if
            call blankout(resrange,1,29)
            if (analtyp .eq. 'q') go to 9003
            lastanal=ianaltyp
            if (ianaltyp .le.  7 .or. ianaltyp .eq. 11 .or.
         -    ianaltyp .eq. 12 .or. ianaltyp .eq. 16 .or.
         -    ianaltyp .eq. 17 .or. ianaltyp .eq. 19 .or.
         -    ianaltyp .eq. 34 .or. ianaltyp .eq. 40 .or.
         -    ianaltyp .eq. 41) then
              call quiz(ansrun,nntyp,' ',' ',0,'Bond information source',23,
         -      0,5,6,00)
              if (nntyp .gt. 1) then
                call top_to_bond(nntyp,nneig,nhneig,ineig,iatnum,n,0,
         -        itemp1,itemp2,maxng,maxrec)
                innlist=innlistorig
              else
                call askyn('Do you want to change bond thresholds',37,1,
         -        -1,newbondlims,0,8)
                if (newbondlims .eq. 1) then
                  do ianl=1,nanos
                    ian=ialist(ianl)
                    write (linein,2115) iatnm2(ian)
                    call getreal(linein,23,ramax(ian),ramaxnew,1,000)
                    if (ramaxnew .ne. ramax(ian)) then
                      ramax(ian)=ramaxnew
                      innlist=0
                    end if
                  end do
                end if
              end if
            end if
            if (ianaltyp .eq.  3 .or. ianaltyp .eq. 15 .or.
         -      ianaltyp .eq. 30 .or.
         -      ianaltyp .eq. 35 .or. ianaltyp .eq. 36 .or.
         -      ianaltyp .eq. 37 .or. ianaltyp .eq. 38) then
              itraj=0
            else if (ianaltyp .eq. 22 .or. ianaltyp .eq. 23 .or.
         -           ianaltyp .eq. 24 .or. ianaltyp .eq. 25 .or.
         -           ianaltyp .eq. 19 .or. ianaltyp .eq. 32 .or.
         -           ianaltyp .eq. 39) then
              itraj=1
              if (ianaltyp .eq. 22) write (6,2013)
            else
              itrajdef=-1
              if ((ianaltyp .ge. 5 .and. ianaltyp .le. 7) .or.
         -         ianaltyp .eq. 34 .or. ianaltyp .eq. 41 .or.
         -         ianaltyp .eq. 9 .or. ianaltyp .eq. 16 .or.
         -         ianaltyp .eq. 18 .or. ianaltyp .eq. 26) itrajdef=+1
              call askyn('Do you want to analyze a trajectory',35,1,
         -      itrajdef,itraj,0,1)
              if (itraj .eq. 0) iaskcolcode=0
            end if
            ncl=0
            framefac=1.0
            iframeunit=1
            xtrajlab=xtrajlabs(iframeunit)
            if (itraj .eq. 1) then
              if (ianaltyp .eq. 05 .or. ianaltyp .eq. 06 .or.
         -        ianaltyp .eq. 07 .or. ianaltyp .eq. 09 .or.
         -        ianaltyp .eq. 16 .or. ianaltyp .eq. 18 .or.
         -        ianaltyp .eq. 21 .or. ianaltyp .eq. 22 .or.
         -        ianaltyp .eq. 23 .or. ianaltyp .eq. 24 .or.
         -        ianaltyp .eq. 27 .or. ianaltyp .eq. 28 .or.
         -        ianaltyp .eq. 29 .or. ianaltyp .eq. 34 .or.
         -        ianaltyp .eq. 39 .or. ianaltyp .eq. 41) then
                call quiz(unit,iframeunit,'f',' ',0,'trajectory unit',15,
         -        0,5,6,0)
                if (iframeunit .gt. 1) then
                  xtrajlab=xtrajlabs(iframeunit)
                  linein(1:11)=xtrajlab
                  linein(12:45)=' per frames on the trajectory file'
                  call getreal(linein,45,1.0,framefac,1,113)
                  if (ianaltyp .eq. 24) print *,'NOTE: ',
         -          'same time interval is assumed for both trajectories'
                  do i=1,MAXFRAMES
                    xtraj(i)=i*framefac
                  end do
                end if
              end if
            end if
            do ia=1,n
              if (inpcrdtyp .le. ioins) then
                atw(ia)=aw(iatnum(ia))
              else
                atw(ia)=1.0
              end if
              rprox(ia)=1.0
            end do
            if (ianaltyp .eq.  5 .or. ianaltyp .eq.  6  .or.
         -      ianaltyp .eq.  7 .or. ianaltyp .eq. 17 .or.
         -      ianaltyp .eq. 29) then
              if (inpcrdtyp .lt. ioa3pdb) then
                call readcharges(nread,nslt,n,charge,iatnum,isv,
         -        icharges,nerr)
                if (icharges .gt. 0) then
                  call checkreschargesum(nslt,iresno,isegno,line,index,
         -          irescol1,irescol2,iresncol1,iresncol2,is1,is2,iqcol1,
         -          iqcol2,charge,molsltlim,'residue',7,resnames,ifres,
         -          ixres,itemp1,itemp2,nreschrg,iallzero,iallnonpos,
         -          iallnonneg,icharges,ifixq,reportqmin,mflogfile,maxrsd,
         -          maxrec)
                  if (iallzero+iallnonpos+iallnonneg .gt. 0) icharges=0
                else
                  write (6,2035)
                  call askstop(1)
                end if
              end if
            end if
            if (innlist .lt. innlistorig)
         -    call nnlist(n,islvw,naslv,n,iatnum,ifchrg,c,nneig,nneiga,
         -      nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,line,
         -      irescol1,irescol2,inamcol1,inamcol2,index,nconfig,innlist,
         -      molresflag,hblimfac,angmin,ihbondcalc,ibnd,indexo,isegno,
         -      ixres,maxrepconf,0,0,radtodeg,0,maxbox,maxng,maxrsd,maxrec)
            itrajrot=0
            ifailbond=0
            lpstitle=0
            npspages=0
            ipspage=0
            xm=800.0
            ym=900.0
            nframe=0
            nrep=0
            iw0=0
            iw1=0
            iw2=0
            iw4=0
            iw5=0
            ioutpr=0
            ipdfgrd=2
            iedit=0
            ndprow=0
            ndials=0
            noplotdist=0
            iskip2dplot=0
            ietotsaved=0
            ibondcorr=0
            iresbondcorr=0
            ibondprint=0
            itorcorr=0
            call zeroiti(nhbdist,0,mxbonds)
            call zeroit(rhbdist,mxbonds)
            extnam1=ext1(ianaltyp)
            extnam2=ext2(ianaltyp)
            extnam3=ext3(ianaltyp)
            call indexit(indexs,1,MAX2D,0)
            call indexit(index2d,1,MAX2D,0)
            call indexit(ixclst,1,MAX2D,0)
            if (itraj .eq. 0) then
              if (ianaltyp .eq.  9 .or. ianaltyp .eq. 11) extnam1='    '
              if (ianaltyp .eq. 16 .or. ianaltyp .eq. 21 .or.
         -        ianaltyp .eq. 27 .or. ianaltyp .eq. 29) extnam2='    '
              if (ianaltyp .eq. 20) then
                call askyn('Do you want to write a grid potential file',42,
         -        1,-1,igridfile,0,0)
                if (igridfile .eq. 1) extnam2='.grd'
              end if
            end if
            if (ianaltyp .eq. 23 .or. ianaltyp .eq. 24) then
              if (nslt .gt. 200 .and. n/nslt .ge. 2) then
                write (6,2030)
                call askstop(0)
              end if
              if (ianaltyp .eq. 23) call askyn(
         -      'Do you want to read an existing .rd2 file',41,
         -       1,-1,iread2d,90,0)
              if (ianaltyp .eq. 24) call askyn(
         -      'Do you want to read existing .rd2 and .rdx files',48,
         -       1,-1,iread2d,91,0)
              if (iread2d .gt. 0) then
                iw4=44
                itraj=0
                extnam2='    '
              end if
            end if
            if (itraj .eq. 1) then
              nres=ixres(n)
              if (n .gt. nslt .or. inpcrdtyp .eq. iommc) then
                nadd=min0(maxrsd-nres-1,(maxrec-index(n))/naslv-1)
                print *,'Generating information for ',nadd,' additional ',
         -         'solvents for possible use'
                if (n .eq. nslt) then
                  linein(1:45)=
         -          'Number of atoms in a solvent (     ) molecule'
                  linein(31:35)=resnamslv
                  if (resnamslv(1:3) .eq. 'HOH' .or.
         -            resnamslv(1:3) .eq. 'TIP') then
                    naslv=3
                    iatnum(nslt+1)=8
                    iatnum(nslt+2)=1
                    iatnum(nslt+3)=1
                    charge(nslt+1)=-0.834
                    charge(nslt+2)=0.417
                    charge(nslt+3)=0.417
                  else
                    call getint(linein,45,999999,1,0,naslv,0)
                    linein(1:32)='Atomic number of solvent atom 00'
                    do ia=1,naslv
                      write (linein(1:32),2091) ia
                      call getint(linein,32,999999,1,99,iatnum(nslt+ia),0)
                      write (linein(1:32),2092) ia
                      if (icharges .gt. 0)
         -              call getreal(linein,22,0.0,charge(nslt+ia),0,0)
                    end do
                  end if
                end if
                do is=1,nadd
                  nres=nres+1
                  resnames(nres)=resnamslv
                  do ia=1,naslv
                    iatnum(n+(is-1)*naslv+ia)=iatnum(nslt+ia)
                    charge(n+(is-1)*naslv+ia)=charge(nslt+ia)
                    index(n+(is-1)*naslv+ia)=index(n)+(is-1)*naslv+ia
                    line(index(n+(is-1)*naslv+ia))=line(index(nslt+ia))
                    ixres(n+(is-1)*naslv+ia)=nres
                  end do
                end do
              end if
              if (analtyp .eq. 'g' .or. analtyp .eq. 'b' .or.
         -        analtyp .eq. 'y' .or. analtyp .eq. 'o' .or.
         -        analtyp .eq. 'm' .or. analtyp .eq. 'x') then
                call askyn(
         -        'Do you want to rotate each frame of the trajectory',50,
         -        1,-1,itrajrot,0,0)
                if (itrajrot .gt. 0) call genrot(trajrot,pi,iax,angle)
              end if
            end if
            mark0=' '
            lmark0=1
            mark1=' '
            lmark1=1
            mark2=' '
            lmark2=1
            analfile=inpfile
            if (extnam1 .ne. '    ') then
              iw0=40
              if (namleno .ne. 0) close (iw0)
              call strip_cext(analfile,namleni,namleno,lenext)
              analfile(namleno+1:namleno+4)=extnam1
              namleno=namleno+4
              if (extnam1 .eq. '.cvl' .or. extnam1 .eq. '.hph') then
                analfile(namleno+1:namleno+4)='.pdb'
                namleno=namleno+4
                mark0='REMARK '
                lmark0=7
              end if
              if (ianaltyp .eq. 14 .or. ianaltyp .eq. 15) then
                call quiz(ansrun,icvtyp,'o',' ',0,
         -        'circular variance type',22,0,5,6,0)
                  if (icvtyp .eq. 2) then
                    analfile(namleno:namleno)='w'
                    analfile1(namleno1-3:namleno1-3)='w'
                  end if
              end if
              if (iread2d .gt. 0) then
                analfile4=analfile
                lanalfile4=namleno
                analfile(namleno-3:namleno+2)='_a.rd2'
                namleno=namleno+2
                write (6,2036) analfile(1:namleno)
              end if
              call openfile(iw0,0,'analysis',8,'new',analfile,namleno,
         -      notfnd,0,1,1,0,0)
              call datprt(iw0,version,1,mark0,lmark0,hostname,lhostname,
         -      iheadnode,0)
              if (extnam2 .ne. '    ') then
                iw1=41
                if (namleno1 .ne. 0) close (iw1)
                namleno1=namleno
                analfile1=analfile(1:namleno)
                if (extnam2 .eq. '.ps ') then
                  analfile1(namleno+1:namleno+3)='.ps'
                  namleno1=namleno+3
                  mark1='% '
                  lmark1=2
                else if (extnam2 .eq. '.pdb') then
                  analfile1(namleno+1:namleno+4)='.pdb'
                  namleno1=namleno+4
                else
                  analfile1(namleno-3:namleno)=extnam2
                  namleno1=namleno
                end if
                if (itraj .eq. 1 .or. (ianaltyp .ne. 5 .and.
         -          ianaltyp .ne. 6 .and. ianaltyp .ne. 7 .and.
         -          ianaltyp .ne. 34 .and. ianaltyp .ne. 41))
         -        call openfile(iw1,0,'analysis',8,'new',analfile1,namleno1,
         -          notfnd,0,1,1,0,0)
                if (extnam2 .ne. '.grd' .and. extnam2 .ne. '.ps ')
         -        call datprt(iw1,version,1,mark1,lmark1,hostname,lhostname,
         -          iheadnode,0)
              end if
              if (extnam3 .ne. '    ') then
                if (namleno2 .ne. 0) close (iw2)
                iw2=42
                namleno2=namleno
                analfile2=analfile(1:namleno)
                analfile2(namleno-3:namleno)=extnam3
                namleno2=namleno
                if (extnam3 .eq. '.rdp') then
                  analfile2(namleno2+1:namleno2+3)='.ps'
                  namleno2=namleno2+3
                end if
              end if
            end if
            call datprt(6,version,1,' ',1,hostname,lhostname,iheadnode,1)
            if (ianaltyp .eq. 23 .or. ianaltyp .eq. 24 .or.
         -      ianaltyp .eq. 25) then
              if (iheadnode .eq. 1 .and. iread2d .eq. 0) write (6,2037)
            end if
            if (ianaltyp .eq. 12 .or. ianaltyp .eq. 18 .or. ianaltyp .eq. 19
         -    .or. ianaltyp .eq. 21 .or. ianaltyp .eq. 32) then
              call askyn(
         -      'Do you want to calculate angle probability distributions',
         -      56,1,1,ipdfc,0,0)
              if (ipdfc .eq. 1) then
                ioutpr=iw0
    8001        call getint('Angle distribution grid size',28,2,1,30,
         -        ipdfgrd,000)
                if (mod(360,ipdfgrd) .ne. 0) then
                  print *,'Grid size is not a divisor of 360'
                  go to 8001
                end if
                call askyn(
         -        'Do you want to map the angle distributions on the dials',
         -        55,1,1,mappdf,0,0)
              end if
              call askyn('Do you want to draw arcs in the dial plots',42,1,
         -      1,iconndial,0,0)
            end if
            if (ianaltyp .eq.  1) then
              write (6,2024) analfile(1:namleno)
              call askyn('Do you want to print bond angles',32,1,-1,iangpr,
         -      0,0)
              call askyn('Do you want to print torsion angles',35,1,-1,
         -      itorpr,0,0)
              call findchiral(nslt,iatnum,nneig,nhneig,ineig,indexa,maxng)
            else if (ianaltyp .eq.  2) then
              write (6,2000) analfile(1:namleno)
            else if (ianaltyp .eq. 18) then
              if (inpcrdtyp .gt. ioins) then
                print *,'ERROR: this input format does not carry atom names'
                return
              end if
              if (iresno(nslt) .gt. maxframe) then
                write (6,2074) maxframe,'residues',' '
                return
              end if
              write (6,2019) 'Psi and phi angles',analfile(1:namleno)
              write (6,2019) 'Ramachandran plot (Postscript)',
         -      analfile1(1:namleno1)
              xm=500.0
              ym=620.0
              if (itraj .eq. 0) then
                call openps(iw1,xm,ym,title,ltitle76,'Ramachandran plot',
         -        17,analfile,namleni,analfile,0,1,ipspage)
                write (6,2086) 'residue',' ',' ',nres
              else
                pstitle='Ramachandran plot'
                lpstitle=17
                write (6,2086) 'frame',' max(frame)'
                nxselres=0
                maxrp=(maxpres-1)/2
                if (nres .le. maxrp) then
                  call askyn('Do you want dial plots for all residues',39,
         -          1,-1,ialldial,0,0)
                  if (ialldial .eq. 1) then
                    call indexit(ixselres,1,nres,0)
                    nxselres=nres
                  end if
                else
                  ialldial=0
                  print *,'Maximum number of dial plots can be ',
         -          'tracked=',maxrp
                  call getint('Number of residues to track',27,0,1,maxrp,
         -          nxselres,0)
                end if
                if (nxselres .gt. 0) then
                  question(1:38)='Phi & Psi dial pair #   residue number'
                  do ix=1,nxselres
                    write (question(22:23),2001) ix
    8003            isegix=1
                    if (ialldial .eq. 0) then
                      if (nsegm .gt. 1) then
                        isegdef=999999
                        question(25:31)='segment'
                        call getint(question,38,isegdef,1,nsegm,isegix,00)
                        isegdef=isegix
                        question(25:31)='residue'
                      end if
                      call getint(question,38,999999,1,nres,iresix,00)
                      call findsegres(isegno,iresno,ixres,1,nslt,isegix,
         -              iresix,iaf,ixselres(ix),ifail)
                      if (inpcrdtyp .le. ioins)
         -              write (6,2111) isegix,iresix,
         -                resnames(ixselres(ix))(1:nrescol)
                    end if
                    irfound=0
                    icafound=0
                    do ia=1,nslt
                      if (iresno(ia) .eq. ixselres(ix)) then
                        irfound=1
                        atnam=line(index(ia))(inamcol1:inamcol1+3)
                        call leftadjust4(atnam,atnam)
                        if (atnam .eq. 'CA  ') icafound=ia
                      end if
                    end do
                    if (icafound*irfound .eq. 0) then
                      if (irfound .eq. 0) then
                        print *,'Residue # ',ixselres(ix),' is not found'
                      else
                        print *,'Residue # ',ixselres(ix),' has no CA atom'
                      end if
                      if (ialldial .eq. 0) go to 8003
                      ixselres(ix)=0
                    else
                      call ca_to_bb(icafound,iresno,nneig,ineig,index,line,
         -              inamcol1,i1,i2,i4,i5,ires,iprotein,
         -              maxng,maxrec)
                      if (iprotein .eq. 0) then
                        write (6,2104) ixselres(ix)
                        if (ialldial .eq. 0) go to 8003
                        ixselres(ix)=0
                      end if
                    end if
                  end do
                  if (ialldial .eq. 1) then
                    ndel=0
                    do ix=1,nxselres
                      if (ixselres(ix) .eq. 0) then
                        ndel=ndel+1
                      else
                        ixselres(ix-ndel)=ixselres(ix)
                      end if
                    end do
                  end if
                  nxselres=nxselres-1
                  if (nxselres .gt. 1)
         -          call getint('Number of dials to draw in a line',33,
         -            min0(4,nxselres),1,12,ndprow,55)
                  ix0=8
                  if (ndprow .gt. 4) ix0=4
                  if (ndprow .gt. 8) ix0=2
                  do ix=1,nxselres
                    write (ramalab(2*ix-1)(ix0:ix0+13),2023)
         -            ixselres(ix),resnames(ixselres(ix)),'Phi'
                    write (ramalab(2*ix)(ix0:ix0+13),2023) ixselres(ix),
         -            resnames(ixselres(ix)),'Psi'
                    lramalab(2*ix-1)=ix0+13
                    lramalab(2*ix)=ix0+13
                  end do
                  call openfile(iw2,0,'dial plot',9,'new',analfile2,
         -          namleno2,notfnd,0,1,1,0,0)
                  call datprt(iw0,version,1,mark0,lmark0,hostname,lhostname,
         -          iheadnode,0)
                  write (6,2019) 'Phi and Psi dial plots',
         -          analfile2(1:namleno2)
                  call askyn(
         -         'Do you want the Ramachandran plot with all residues',51,
         -            1,-1,iallrama,0,0)
                else
                  print *,'Only the Ramachandran plot will be prepared ',
         -          'using all residues'
                  iallrama=1
                end if
                call ramachandran_init(n,ixres)
              end if
            else if (ianaltyp .eq. 19 .or. ianaltyp .eq. 32) then
              write (6,2019) 'Selected angles',analfile(1:namleno)
              xm=500.0
              ym=620.0
              if (itraj .eq. 1) then
                write (6,2019) 'Dial plots for the selected angles',
         -        analfile1(1:namleno1)
              end if
              if (ianaltyp .eq. 19) then
                call torslistinp(ixtor1234,talab,ltalab,ntorsel,inpcrdtyp,
         -        ioins,line,index,n,nslt,nresslt,iatnum,nneig,ineig,nhneig,
         -        ixres,ixresno,nsegm,isegno,ifres,ilres,iresno,indexs,
         -        listrefres,irescol1,irescol2,inamcol1,inamcol2,maxng,
         -        maxrsd,maxrec,MAXCOPY1)
                ndials=ntorsel
                if (ndials .eq. 0) then
                  print *,'ERROR: no torsions were selected'
                  go to 9003
                end if
              else
                call getint('Number of angles to track',25,0,1,49,
         -        nangsel,0)
                do it=1,nangsel
    8004          question(1:35)='Angle   , atomindices ( 3 numbers )'
                  write (question(6:8),2043) it
                  call getintline(question,35,1,nslt,ixtor1234(1,it),3,0)
                  if (inpcrdtyp .le. ioins)
         -          write (6,2039) 'A',(ixtor1234(k,it),
         -            line(index(ixtor1234(k,it)))(inamcol1:inamcol2),
         -            line(index(ixtor1234(k,it)))(irescol1:irescol2),
         -          k=1,3)
                  nerr=0
                  do k=2,3
                    if (isbonded(ixtor1234(k-1,it),ixtor1234(k,it),
         -              nneig,ineig,n,maxng) .eq. 0) then
                      write (6,2066) (ixtor1234(kk,it),kk=k-1,k),' NOT '
                      nerr=nerr+1
                    end if
                  end do
                  if (isbonded(ixtor1234(1,it),ixtor1234(3,it),
         -            nneig,ineig,n,maxng) .eq. 1) then
                    write (6,2066) ixtor1234(1,it),ixtor1234(3,it),' '
                    nerr=nerr+1
                  end if
                  if (nerr .gt. 0) then
                    call askyn('Do you want to use this angle',29,1,-1,iok,
         -            0,0)
                    if (iok. eq. 0) go to 8004
                  end if
                  call blankout(talab(it),1,30)
                  if (inpcrdtyp .gt. ioins) then
                    write (talab(it),2067) 'A',it,(ixtor1234(k,it),k=1,3)
                  else
                    write (talab(it),2108)
         -            (line(index(ixtor1234(kk,it)))(inamcol1:inamcol1+3),
         -            kk=1,2),line(index(ifres(ixres(ixtor1234(2,it)))))
         -             (irescol1:irescol2),
         -            line(index(ixtor1234(3,it)))(inamcol1:inamcol1+3)
                  end if
                  ltalab(it)=25
                end do
                ndials=nangsel
              end if
              if (ndials .gt. 1) then
                call getint('Number of dials to draw in a line',33,
         -            min0(ndials,3),1,12,ndprow,55)
                call quiz(ans,itorcorr,'j',' ',0,
         -        'Angular (circular) correlation type',35,0,5,6,0)
                itorcorr=itorcorr-1
              else
                ndprow=1
                itorcorr=0
              end if
            else if (ianaltyp .eq.  3) then
              write (6,2019) 'Functional group and bond lists',
         -      analfile(1:namleno)
              write (6,2019) 'Backbone atoms',analfile1(1:namleno1)
            else if (ianaltyp .eq.  4) then
              write (6,2019) 'Bond lengths',analfile(1:namleno)
            else if (ianaltyp .eq. 17) then
              ibondtype=6
              write (6,2002) 'ed bridge ',analfile(1:namleno)
              write (iw0,2127) bondname(ibondtype)(1:lbondname(ibondtype))
              call set_hbondlims(hbf0,hblimfac,angm0,angmin,iw0)
              brslv=resnamslv
              nabr=naslv
              if (islvw .eq. 1) islvw=2
              if (nslt .eq. n) then
    901         call getname(brslv,lbrslv,'Bridge residue name',19,
         -        nrescol,'',0,0,100,0)
                if (brslv(1:nrescol) .ne. resnamslv(1:nrescol)) then
                  ia=1
                  ir=1
                  do while (resnames(ir)(1:nrescol) .ne. brslv(1:nrescol)
         -           .and. ia .lt. nslt)
                    ia=ia+1
                    ir=ixres(ia)
                  end do
                  if (resnames(ir)(1:nrescol) .eq. brslv(1:nrescol)) then
                    iaf=ia
                    do while (resnames(ir)(1:nrescol) .eq. brslv(1:nrescol)
         -             .and. ia .lt. nslt)
                      ia=ia+1
                      ir=ixres(ia)
                    end do
                    nabr=ia-iaf
                    if (resnames(ir)(1:nrescol) .eq. brslv(1:nrescol))
         -            nabr=nabr+1
                  else
                    print *,'ERROR: residue ',brslv(1:nrescol),' not found'
                    go to 901
                  end if
                end if
              end if
              write (6,2042) brslv(1:nrescol),brslv(1:nrescol),nabr
              write (iw0,2042) brslv(1:nrescol),brslv(1:nrescol),nabr
              call getint('Maximum number of bridge residues in a bridge',
         -      45,MAXBRIDGELEN-1,1,MAXBRIDGELEN-1,maxbridgemem,0)
              call gethbanchordef(line,index,nslt,ixres,iresno,iatnum,
         -      indexa,indexo,nanchor,ianchor,iiqcol(1,inpcrdtyp),
         -      iiqcol(2,inpcrdtyp),inpcrdtyp,iobpdb,iocpdb,icharges,qmin,
         -      iw0,inamcol1,resnames,brslv,nrescol,segid4,molsltlim,
         -      nsegslt,isc,nneig,ineig,'Bridge',6,ianchor2,iselfanc,
         -      nosameseg,iqfsel2,22,ifail,maxng,maxrsd,maxrec,
         -      MAXBRIDGEATOM)
              if (ifail .eq. 1) go to 9005
              call zeroiti(nbridgetype,0,nanchor*MAXBRIDGELEN)
              ipb=2*itraj+1
              call askyn('Do you want to print the bridges',32,1,ipb,
         -      listbridge,0,0)
              print *,'Bridge of length 1 is a solute-solute hydrogen bond'
              call getint('Minimum length of bridge to list',32,1,1,
         -      maxbridgemem,minbridgelenprint,000)
              if (itraj .eq. 1) then
                call getint('Minimum percent of frames present to list',41,
         -        0,1,100,minbridgepercprint,000)
              else
                minbridgepercprint=0
              end if
              write (iw0,*)
              call zeroiti(lpath,0,MAXBRIDGETYPE*MAXBRIDGELEN*
         -      MAXBRIDGEATOM)
            else if (ianaltyp .ge.  5 .and. ianaltyp .le. 7 .or.
         -           ianaltyp .eq. 34 .or. ianaltyp .eq. 41) then
              npspages=3
              ibondtype=ianaltyp-4
              if (ianaltyp .eq. 34) ibondtype=4
              if (ianaltyp .eq. 41) ibondtype=5
              if (iallheavy .eq. 1 .and. ibondtype .eq. 2) then
                print *,'There are no hydrogens in the structure'
                call askstop(1)
              end if
              if (itraj .eq. 1) then
                linein='Do you want to calculate '//
         -        bondname(ibondtype)(1:lbondname(ibondtype))//
         -        ' correlation'
                llinein=37+lbondname(ibondtype)
                call askyn(linein,llinein,1,-1,ibondcorr,0,0)
                if (ibondcorr .gt. 0) npspages=npspages+1
                linein='Do you want to calculate residue-aggregated '//
         -        'bond correlation'
                llinein=60
                call askyn(linein,llinein,1,-1,iresbondcorr,0,0)
                if (iresbondcorr .gt. 0) npspages=npspages+1
                linein='Do you want to print every '//
         -        bondname(ibondtype)(1:lbondname(ibondtype))
                llinein=27+lbondname(ibondtype)
                call askyn(linein,llinein,1,-1,ibondprint,0,0)
                if (ibondprint .eq. 1 .and. ibondtype .eq. 1)
         -      write (iw0,2141)
                noprintconf=1-ibondprint
                iaskcolcode=1
                call askyn(
         -        'Do you want to read previously generated bond tracks',52,
         -        1,-1,ireadtracks,0,0)
                if (ireadtracks .gt. 0) then
                  ifail=1
                  do while (ifail .gt. 0)
                    call getname(trackfile,ltrackfile,'Name of track file',
         -            18,80,'',0,0,0,0)
                    iout_track=92
                    call openfile(iout_track,0,'previously written track',
         -            24,'old',trackfile,ltrackfile,notfnd,0,1,1,0,0)
                    call readtrack(iout_track,iw0,30,nbfound,nbresfound,
         -            nres2d,ixres,trackfile,ltrackfile,ianc_anc,ifail,
         -            maxrec)
                  end do
                  xtrajlab=xtrajlabs(iframeunit)
                  npspages=2
                  go to 3001
                end if
                call getint(
         -        'Number of frames to average in the bond number plot',51,
         -        1,1,MAXFRAMES/2,nbondavg,00)
              end if
              if (ianaltyp .eq.  5) then
                write (6,2002) ' ',analfile(1:namleno)
                write (iw0,2127) bondname(ibondtype)(1:lbondname(ibondtype))
                call set_hbondlims(hbf0,hblimfac,angm0,angmin,iw0)
                nres2d=ixres(n)
                if (n .gt. nslt) then
                  call askyn('Do you want to include the solvents',35,1,-1,
         -          isolvent,0,0)
                  if (isolvent .eq. 0) nres2d=ixres(nslt)
                end if
                write (6,2140)
                do i=1,nanos
                  if (icatlist(i) .eq. 0) then
                    if (ialist(i) .ne. 1 .and. ialist(i) .ne. 6)
         -            write (6,2142) iatnm2(ialist(i)),
         -              sqrt(ramax2(ialist(i))*hblimfac)
                  else if (islvw .gt. 0) then
                    write (6,2143)
         -            iatnm2(ialist(i)),sqrt(ramax2(ialist(i))*hblimfac)
                  end if
                end do
                if (itraj .eq. 1) then
                  call gethbanchordef(line,index,nslt,ixres,iresno,iatnum,
         -          indexa,indexo,nanchor,ianchor,iiqcol(1,inpcrdtyp),
         -          iiqcol(2,inpcrdtyp),inpcrdtyp,iobpdb,iocpdb,icharges,
         -          qmin,iw0,inamcol1,resnames,'      ',nrescol,segid4,
         -          molsltlim,nsegslt,isc,nneig,ineig,'Hydrogen bond',13,
         -          ianchor2,iselfanc,nosameseg,iqfsel2,72,ifail,maxng,
         -          maxrsd,maxrec,MAXBRIDGEATOM)
                  if (ifail .eq. 1) go to 9005
                  call indexit(it3,1,MAXBONDS,0)
                  call indexit(it4,1,MAXBONDS,0)
                  iaskcolcode=1
                end if
                innlist=0
              else if (ianaltyp .eq.  6) then
                write (6,2019) 'Hydrophobic bond list',analfile(1:namleno)
                write (iw0,2127) bondname(ibondtype)(1:lbondname(ibondtype))
                call getreal('Hydrophopbic bond length limit',30,5.0,
         -        rhphmax,1,76)
                call getint('Minimum number of carbon-bonded hydrogens',41,
         -        1,1,4,nhneigmin,77)
                call gethphanchordef(line,index,nslt,iresno,iatnum,charge,
         -        indexa,indexn,indexo,nneig,ineig,nhneig,nhneigmin,nanchor,
         -        ianchor,ianchor2,iselfanc,nosameseg,iallheavy,iqcol1,
         -        iqcol2,inpcrdtyp,iobpdb,iocpdb,icharges,ibondtype,iw0,
         -        segid4,molsltlim,nsegslt,bondname(ibondtype),
         -        lbondname(ibondtype),ifail,maxng,maxrec,MAXBRIDGEATOM)
                if (ifail .eq. 1) go to 9005
                call extend_nnlist(nneig,ineig,npneig,nslt,maxng,maxrec)
                nres2d=ixres(nslt)
                innlist=0
              else if (ianaltyp .eq.  7) then
                write (iw0,2127) bondname(ibondtype)(1:lbondname(ibondtype))
                write (6,2019) 'Salt-bridge list',analfile(1:namleno)
                call getreal('Salt-bridge length limit',24,5.0,rsltbmax,1,2)
                call getsltbanchordef(line,index,nslt,iresno,iatnum,charge,
         -        indexa,indexn,indexo,temp,nhneig,ineig,nanchor,ianchor,
         -        ianchor2,iselfanc,nosameseg,iqcol1,iqcol2,inpcrdtyp,
         -        iobpdb,iocpdb,icharges,iw0,irescol1,irescol2,inamcol1,
         -        inamcol2,segid4,molsltlim,nsegslt,isegno,ifail,maxng,
         -        maxrec,MAXBRIDGEATOM)
                if (ifail .eq. 1) go to 9005
                call extend_nnlist(nneig,ineig,npneig,nslt,maxng,maxrec)
                nres2d=ixres(nslt)
                innlist=0
              else if (ianaltyp .eq.  34) then
                write (iw0,2127) bondname(ibondtype)(1:lbondname(ibondtype))
                write (6,2019) 'Heavy-atom contact list',analfile(1:namleno)
                call getreal('Heavy-atom distance threshold',29,5.0,
         -        rhphmax,1,76)
                call gethphanchordef(line,index,nslt,iresno,iatnum,charge,
         -        indexa,indexn,indexo,nneig,ineig,nhneig,nhneigmin,nanchor,
         -        ianchor,ianchor2,iselfanc,nosameseg,iallheavy,iqcol1,
         -        iqcol2,npcrdtyp,iobpdb,iocpdb,icharges,ibondtype,iw0,
         -        segid4,molsltlim,nsegslt,bondname(ibondtype),
         -        lbondname(ibondtype),ifail,maxng,maxrec,MAXBRIDGEATOM)
                if (ifail .eq. 1) go to 9005
                call extend_nnlist(nneig,ineig,npneig,nslt,maxng,maxrec)
                npspages=2
                if (itraj .eq. 1) then
                  ibondcorr=0
                  call askyn('Do you want to print the heavy-atom contacts',
         -          44,1,+1,ihphprint,0,0)
                  noprintconf=1-ihphprint
                  iaskcolcode=1
                end if
                nres2d=ixres(nslt)
                innlist=0
              else if (ianaltyp .eq.  41) then
                write (iw0,2127) bondname(ibondtype)(1:lbondname(ibondtype))
                call getmpxbdef(nslt,indexa,indexov,indexn,segid4,iresno,
         -        molsltlim,nsegslt,nanchorr,nanchorn,iw0,maxrsd)
                call getreal('Maximum distance for contact',28,99999.0,
         -        rmpxlim,1,000)
                if (rmpxlim .lt. 99999.0) write (iw0,2128) rmpxlim
                nres2d=ixres(nslt)
              end if
            else if (ianaltyp .eq. 8) then
              if (inpcrdtyp .gt. ioins) then
                print *,'Input format does not have residue information'
                go to 9002
              end if
              call modrepats
              call getreal('Threshold distance with representative atoms',
         -      44,10.0,resdistlim,1,38)
              call getreal('Threshold distance with closest approach',40,
         -      10.0,resapplim,1,39)
              call askyn(
         -      'Do you want to ignore hydrogens for the closest approach',
         -      56,1,1,ignoreh,106,0)
              if (iresshift .gt. 0) write (6,2029)
              isegdef1=1
              call getresrange(nsegm,indexs,isegno,ixres,iresno,ifres,
         -      'reference residue to use',24,nresslt,nslt,irefres1,
         -      irefres2,isegdef1,irefseg1,irefseg2,listrefres,nrefres,
         -      nrefrange,0,0,maxrsd,maxrec,111)
              write (6,*)
              if (isegdef1 .gt. 0) isegdef2=nsegm
              if (isegdef1 .eq. nsegm) isegdef2=1
              call getresrange(nsegm,indexs,isegno,ixres,iresno,ifres,
         -      'neighbourhood residue to use',28,nresslt,nslt,
         -      inegres1,inegres2,isegdef2,inegseg1,inegseg2,listnegres,
         -      nnegres,nnegrange,0,0,maxrsd,maxrec,111)
              write (6,2050) 'representative',analfile(1:namleno)
              write (6,2050) 'closest',analfile1(1:namleno1)
              if (itraj .gt. 0) then
                if (irefres2-irefres1 .lt. MAX2D .and.
         -         inegres2-inegres1 .lt. MAX2D) then
                  print *,'By default, average distances are based on the ',
         -          'representative atoms'
                  itypavg=1
                  call askyn(
         -          'Do you want to average the contact distances instead',
         -           52,1,-1,iusecont,000,0)
                  itypavg=itypavg+iusecont
                  npspages=1
                  iw4=44
                  if (itypavg .eq. 1) then
                    analfile4=analfile
                    namleno4=namleno
                  else
                    analfile4=analfile1
                    namleno4=namleno1
                  end if
                  analfile4(namleno4+1:namleno4+3)='.ps'
                  namleno4=namleno4+3
                  call openfile(iw4,0,'average distance matrix',23,'new',
         -          analfile4,namleno4,notfnd,0,1,1,0,0)
                  call openps(iw4,500.0,500.0,' ',1,' ',1,inpfile,0,
         -          inpfile,0,1,ipspage)
                else
                  write (6,2112) MAX2D
                end if
              end if
              increst=0
              incsolvrr=0
              numresrr=numres
              idisjoint=1
              if (inegres1 .le. irefres2 .and. inegres2 .ge. irefres1) then
                match=0
                do irr=1,nrefres
                  do irn=1,nnegres
                    if (listrefres(irr) .eq. listnegres(irn)) match=1
                  end do
                end do
                idistjoint=1-match
              end if
              if (idisjoint .eq. 1) then
                call openfile(iw2,0,'contact list',12,'new',analfile2,
         -        namleno2,notfnd,0,1,1,0,0)
                call datprt(iw2,version,1,mark0,lmark0,hostname,lhostname,
         -        iheadnode,0)
                write (6,2050) 'contact',analfile2(1:namleno2)
                call askyn(
         -        'Do you want all neighbors of the interface residues',51,
         -        1,1,increst,57,0)
                if (n .gt. nslt .and. increst .eq. 1) then
                  call askyn('Do you want to include solvent neighbors',40,
         -          1,-1,incsolvrr,0,0)
                  if (incsolvrr .eq. 0) then
                    numresrr=nresslt
                    incsolvrr=-1
                  end if
                end if
              else
                print *,'NOTE: residue ranges overlap; no contact list ',
         -        'will be generated'
                iw2=0
              end if
              call zeroiti(irescount1,0,nresslt)
              call zeroiti(irescount2,0,nresslt)
              call zeroiti(irescount3,0,nresslt)
              irefresinc=ixresno(ixres(molsltlim(1,irefseg1)))-
         -      ixres(molsltlim(1,irefseg1))
              inegresinc=ixresno(ixres(molsltlim(1,inegseg1)))-
         -      ixres(molsltlim(1,inegseg1))
            else if (ianaltyp .eq. 33) then
              if (nmolslt .eq. 1) then
                write (6,*) 'Solute is a single molecule'
                go to 9003
              end if
              write (6,2120) 'COM-COM distance',analfile(1:namleno)
              write (6,2120) 'closest distance',analfile1(1:namleno1)
              call askyn(
         -      'Do you want to ignore hydrogens for the closest approach',
         -      56,1,1,ignoreh,106,0)
              write (iw0,2121) 'center-of-mass distance'
              write (iw1,2121) 'closest approach'
            else if (ianaltyp .eq. 36 .or. ianaltyp .eq. 37 .or.
         -           ianaltyp .eq. 38) then
              iwpdb=0
              if (iresshift .gt. 0) write (6,2156)
              if (ianaltyp .eq. 36) then
                call compare_rrdist(resnames,nrescol,itemp1,temp,irefres1,
         -        irefres2,analfile4,lanalfile4,maxrsd)
                call askyn(
         -        'Do you want to write a PDB file with average changes',52,
         -         1,0,iwpdb,0,0)
              else if (ianaltyp .eq. 37) then
                nres=ixres(nslt)
                call compare_bondmat(resnames,nrescol,itemp1,temp,nres,
         -        analfile4,lanalfile4,maxrsd)
                irefres1=1
                irefres2=nres
                call askyn(
         -        'Do you want to write a PDB file with cumulative changes',
         -         55,1,0,iwpdb,0,0)
              else
                call askyn(
         -        'Do you want to write a PDB file with the differences',52,
         -        1,0,iwpdb,0,0)
                siglev=0.0
                if (iwpdb .eq. 1) call getreal(
         -        'Significance level threshold to set to 0 the difference',
         -        55,0.05,siglev,1,000)
                call compare_rmsf(resnames,nrescol,siglev,temp,analfile4,
         -        lanalfile4,irefres1,irefres2,maxrsd)
              end if
              if (iwpdb .gt. 0) then
                do ir=irefres1,irefres2
                  do ia=ifres(ir),ilres(ir)
                    cv(ia)=temp(ir)
                  end do
                end do
                analfile4(lanalfile4:lanalfile4+2)='db'
                lanalfile4=lanalfile4+1
                iw4=44
                call openfile(iw4,0,'Avg difference labeled PDB',26,
         -        'new',analfile4,lanalfile4,notfnd,0,1,1,0,0)
                call writeconf(iw4,inpcrdtyp,iobpdb,inpcrdtyporg,
         -        nslt,nslt,nslt,naslv,islvw,iasv,namesv,qsv,pflsv,1,
         -        iwhead,0,iatnum,ifchrg,nconfig,innlist,c,rprox,cv,ixres,
         -        iresno,atnames,resnames,segnames,charge,isegno,altcol,
         -        inscol,ninsres,marker,ntitlin,ntitlinw,title,ireseq,
         -        iresnrestart,iresidrestart,nneig,nneiga,nhbneig,ineig,
         -        nhneig,nnneig,ncneig,nsneig,npneig,numres,numslv,
         -        resnamslv,line,blankline,mmtype,ibnd,index,indexn,indexo,
         -        1,molresflag,irescount3,itemp1,hblimfac,angmin,0,1,1,1,0,
         -        3,iqspaceask,ianaltyp,0,0.0,0,0,0,keeprem,iwriteatsym,
         -        radtodeg,maxrepconf,maxng,maxrsd,maxrec)
                close (iw4)
              end if
            else if (ianaltyp .eq. 31) then
              if (inpcrdtyp .gt. ioins) then
                print *,'Input format does not have residue information'
                go to 9002
              end if
              write (6,2046) analfile(1:namleno)
              call quiz(analtyp,idtyp,' ',' ',0,
         -      'residue distance definition',27,0,5,6,0)
              if (analtyp .eq. 'r') then
                resdistdef=7.5
                call modrepats
                ignoreh=0
                irepuse=1
              else
                call askyn(
         -       'Do you want to ignore hydrogens for the closest approach',
         -        56,1,1,ignoreh,106,0)
                irepuse=0
                resdistdef=5.0
              end if
              call getreal('Threshold distance',18,resdistdef,resdistlim,1,
         -      38)
              call quiz(analtyp,iadjtyp,' ',' ',0,'adjacency analysis',18,
         -      0,5,6,108)
              call getint('Highest exponent to raise the adjacency matrix',
         -      46,1,1,100,nexpmax,0)
              call getint('Power interval to plot',22,1,1,100,npint,0)
              call askyn(
         -      'Do you want to scale the column sums to [0,1] range',51,
         -      1,1,iscalesum,000,0)
              isegdef=1
              call getresrange(nsegm,indexs,isegno,ixres,iresno,ifres,
         -      'residue to use',14,nresslt,nslt,ires1,ires2,isegdef,
         -      iseg1,iseg2,listrefres,nresref,nrange,1,1,maxrsd,maxrec,000)
              call askyn('Do you want to mark residues',28,1,0,imarkres,109,
         -      0)
              if (imarkres .eq. 1) then
                iw4=44
                namleno4=0
                call openfile(iw4,0,'residue mark',12,'old',analfile4,
         -        namleno4,notfound,3,1,1,0,0)
                read (iw4,2044,end=771) (itemp4(i-ires1+1),i=ires1,ires2)
     771        close (iw4)
                nmarks=0
                do ii=ires1,ires2
                  i=ii-ires1+1
                  if (itemp4(i) .gt. nmarks) nmarks=itemp4(i)
                end do
                if (ipredict .eq. 0) then
                  do imark=1,nmarks
                    write (6,2056) imark
                    read (5,2095) marks(imark)
                  end do
                else
                  write (6,2045) (i,marks(i),i=1,9)
                end if
              end if
              npspages=1
              call openps(iw1,xm,ym,title,ltitle76,
         -      'Adjacency matrix analysis',25,inpfile,namleni,inpfile,0,1,
         -      ipspage)
            else if (ianaltyp .eq.  9) then
              if (itraj .eq. 1)
         -       write (6,2019) 'Distances measured',analfile(1:namleno)
              write (6,2047)
              call getint('First  atom number',18,1,1,n,ia1,0)
              call getint('Second atom number',18,1,1,n,ia2,0)
              ifirstref=0
              if (itraj .eq. 1) then
                if (ia1 .eq. ia2) then
                  ifirstref=1
                else
                  call askyn(
         -          'Is the first atom fixed on the input structure',46,
         -          1,-1,ifirstref,0,0)
                end if
                print *,'Progression of distance vector will be plotted ',
         -        'projected to a coordinate plane'
                call readax('Axis normal to the plane (1,2,3)',32,3,idax,
         -        indexax)
              end if
              if (ia1 .eq. ia1) then
                write (atomdist,2052) ia1
                pstitle(1:15)=atomdist
                lpstitle=15
              else
                write (atomdist,2053) ia1,ia2
                pstitle(1:22)=atomdist
                lpstitle=22
              end if
              npspages=4
              if (inpcrdtyp .le. ioins) then
                ir1=iresno(ia1)
                ir2=iresno(ia2)
                write (6,2057) ia1,ir1,line(index(ia1))(inamcol1:inamcol2),
         -        line(index(ia1))(irescol1:irescol2),
         -        ia2,ir2,line(index(ia2))(inamcol1:inamcol2),
         -        line(index(ia2))(irescol1:irescol2)
                if (itraj .eq. 1) write (iw0,2057) ia1,ir1,
         -        line(index(ia1))(inamcol1:inamcol2),
         -        line(index(ia1))(irescol1:irescol2),
         -        ia2,ir2,line(index(ia2))(inamcol1:inamcol2),
         -        line(index(ia2))(irescol1:irescol2)
              else
                write (6,2058) ia1,ia2
                if (itraj .eq. 1) write (iw0,2058) ia1,ia2
              end if
              if (ifirstref .eq. 1) then
                write (iw0,2051) inpfile(1:namleni)
                write (6,2051) inpfile(1:namleni)
                call trnsfr(caref,cres(1,ia1),3)
              end if
              call setpbccell('Do you want to use periodic images',34,
         -      edge,edge_gen,cell,ncell,cellalt,ixyzhex,npbc,
         -      ioppbc,iusepbc,vol,nw,rinscr,rcirc,0)
              if (iusepbc .ge. 0) then
                if (ifirstref .eq. 1) then
                  call pbcdist(caref,c(1,ia2),ia1,ia2,cell,ncell,-iw0,
         -          1,img,drincr,dimg)
                  call zeroit(drimg,3)
                  call arrdiff(drimg,cell(1,img),drimg,3)
                end if
              else
                ncell=1
              end if
              xm=800.0
              ym=900.0
            else if (ianaltyp .eq. 10) then
              write (6,2019) 'List of suspicious contacts',
         -      analfile(1:namleno)
              call getreal('CTFAC',5,1.4,ctfac,1,62)
              call getreal('MINFAC',6,0.4,bondminfac,1,62)
              call getint('MAXDIST',7,min0(nslt,50),1,nslt,maxdist,62)
              isltonly=1
              if (n .gt. 2000) print *,'NOTE: This check is SLOW'
              if (nslt .lt. n)
         -      call askyn('Do you want to include the solvents',
         -        35,0,-1,isltonly,0,0)
              if (nsegslt .gt. 3 .and. ischarmm(inpcrdtyp) .eq. 1) then
                call askyn('Do you have LES segments',24,1,-1,iles,0,0)
                if (iles .eq. 1) then
                  qq='Is segment      a duplicate'
                  do is=1,nsegslt
                    qq(12:15)=segid4(is)
                    call askyn(qq,27,1,-1,idelseg(is),0,0)
                  end do
                end if
               write (6,2114)
              end if
              call setmolres(ifres,ilres,isegno,molresflag,
         -      molsltlim,nrescol,irescol1,irescol2,resnames,nresslt,
         -      nmolslt,nsegslt,nmolsltnoion,minresflag,index,indexa,indexs,
         -      line,maxrsd,maxrec)
              call setpbccell('Do you want to use periodic images',34,
         -      edge,edge_gen,cell,ncell,cellalt,ixyzhex,npbc,
         -      ioppbc,iusepbc,vol,nw,rinscr,rcirc,0)
              write (iw0,2061) ctfac,bondminfac,maxdist
              call printbondthres(ialist,nanos,ctfac,bondminfac,
         -      iatnm2,ramax,iw0)
              if (iusepbc .ge. 0) then
                write (iw0,*) 'Intermolecular distances include PBC images'
                call prtcell(ioppbc,edge,edge_gen,r,vol,nw,-iw0)
              end if
              if (nslt .gt. 1000) print *,'Wait ...'
            else if (ianaltyp .eq. 11) then
              if (itraj .eq. 1) then
                call getring(line,index,ix5,irescol1,irescol2,inamcol1,
         -        inamcol2,nslt,numres,iresring,iresno,ifres,ilres,nmem,
         -        psrtyp,0,incgen,iapex,MAXRING,maxrec)
                write (6,2019) 'Pseudorotation angles',analfile(1:namleno)
              end if
            else if (ianaltyp .eq. 12) then
              write (6,2071) analfile(1:namleno)
              extnam1='.pkn'
              iprintpk=0
              irespro=0
              isegpkhx=1
              if (iresshift .gt. 0) write (6,2029)
              if (nsegm .gt. 1) then
    9083        call getint('Segment number of helix',23,1,1,
         -        nsegm,isegpkhx,0)
                call findrange(isegno,1,nslt,isegpkhx,ifseghx,ilseghx,
         -        'segment',7,0,ifail)
                if (ifail .gt. 0) go to 9083
              else
                ifseghx=1
                ilseghx=nslt
              end if
              do while (irespro .eq. 0)
                call getint('Residue number of the kink (Proline)',36,
         -        0,1,iresno(nslt),irespro,0)
                call findresnum(iresno,ixres,irespro,ifseghx,ilseghx,ia,
         -        irfound)
              end do
              ial=ia-1
              irespro=irfound
              resnam(1:nrescol)=line(index(ia))(irescol1:irescol2)
              call leftadjustn(resnam,rn,8)
              noprol=0
              if (rn(1:3) .ne. 'PRO') then
                print *,'NOTE: residue ',irespro,
         -        ' is not a proline but a ',resnam(1:nrescol)
                noprol=1
                iflatproline=0
              else
                call askyn('Do you want to project the proline to a plane',
         -        45,1,-1,iflatproline,96,0)
              end if
    9082      call getint('Number of helix residues before the kink',40,
         -      7,1,MAXHX-1,nrb,0)
              call getint('Number of helix residues after  the kink',40,
         -      7,1,MAXHX-1,nra,0)
              if (nra .lt. 4 .or. nrb .lt. 4) then
                print *,'Minimum helix length is four '
                go to 9082
              end if
              icaonly=-1
              call findprotbackbone(line,index,iresno,ia,inamcol1,
         -      icapr,icpr,inpr,icbpr,icgpr,icdpr,nslt,icaonly,maxrec)
              write (6,2158) 'Proline',0,
         -      line(index(ia-1))(irescol1:irescol2),iresno(ia-1),
         -      icapr,icpr,inpr
              icaa(1)=icapr
              ica(1)=icpr
              ina(1)=inpr
              do ir=1,nra
                call findprotbackbone(line,index,iresno,ia,inamcol1,
         -        icaa(ir+1),ica(ir+1),ina(ir+1),icbx,icgx,icdx,
         -        nslt,icaonly,maxrec)
                write (6,2158) 'After  ',ir,
         -        line(index(ia-1))(irescol1:irescol2),iresno(ia-1),
         -        icaa(ir),ica(ir),ina(ir)
              end do
              do ir=1,nrb
                ia=ial
                ires=iresno(ial)
                do while (iresno(ia) .eq. ires .and. ia .gt. 1)
                  ia=ia-1
                end do
                ial=ia
                ia=ia+1
                call findprotbackbone(line,index,iresno,ia,inamcol1,
         -        icab(ir),icb(ir),inb(ir),icbx,icgx,icdx,nslt,
         -        icaonly,maxrec)
                write (6,2158) 'Before ',ir,
         -        line(index(ia-1))(irescol1:irescol2),iresno(ia-1),
         -        icab(ir),icb(ir),inb(ir)
              end do
              print *,"Kink residue (proline) will be added only to the ",
         -      "helix 'after'"
              if (noprol .eq. 0) then
                call getring(line,index,ix5,irescol1,irescol2,inamcol1,
         -        inamcol2,nslt,numres,irespro,iresno,ifres,ilres,nmem,
         -        'p',1,incgen,iapex,MAXRING,maxrec)
                if (nmem .eq. 0)
         -        print *,'Pseudorotation angle calculation is canceled'
              end if
              write (iw0,2077)
              write (iw0,2040) irespro-nrb,irespro+nra,isegpkhx
              write (resrange(1:22),2087) irespro-nrb,irespro+nra
              write (iw0,2083) irespro
              if (itraj .eq. 1) then
                ndials=5
                if (nmem .eq. 0) ndials=ndials-1
              end if
              nomat0=1
            else if (ianaltyp .eq. 21) then
              itmem=0
    9194      call getint('Number of helices to analyze',28,1,1,MAXNHX,nhx,
         -      0)
              nresrec=nhxres*nhx+3*nhx*(nhx-1)/2
              npspages=nresrec
              if (nresrec .gt. MAXCOPY1) then
                write (6,2161) nresrec,MAXCOPY1
                go to 9194
              end if
              do ihx=1,nhx
                if (nhx .gt. 1) write (6,2159) ihx
                if (nsegm .gt. 1) then
    9183          call getint('Segment number of helix',23,1,1,
         -          nsegm,iseghx(ihx),0)
                  call findrange(isegno,1,nslt,iseghx(ihx),ifseghx,ilseghx,
         -          'segment',7,0,ifail)
                  if (ifail .gt. 0) go to 9183
                else
                  ifseghx=1
                  ilseghx=nslt
                end if
                if (iresshift .gt. 0) write (6,2029)
    9182        call getrange(ireshx1(ihx),999999,ireshx2(ihx),999999,incr,
         -        0,'helix residue',13,iresno(ilseghx),0)
                if (ireshx1(ihx) .lt. iresno(ifseghx)) then
                  write (6,2123) 'less',iresno(ifseghx)
                  go to 9182
                end if
                if (ireshx2(ihx) .gt. iresno(ilseghx)) then
                  write (6,2123) 'greater',iresno(ifseghx)
                  go to 9182
                end if
                nreshx(ihx)=ireshx2(ihx)-ireshx1(ihx)+1
                if (nreshx(ihx) .lt. 4) then
                  print *,'Minimum helix length is four '
                  go to 9182
                else if (nreshx(ihx) .gt. MAXHX-1) then
                  print *,'Maximum helix length is ',MAXHX-1
                  go to 9182
                end if
                print *
                icaonly=0
                do ir=ireshx1(ihx),ireshx2(ihx)
                  ir0=ir
                  call findresnum(iresno,ixres,ir0,ifseghx,ilseghx,ia,
         -          irfound)
                  if (ir0 .eq. 0) go to 9182
                  ir1=ir-ireshx1(ihx)+1
                  ia=ifres(irfound)
                  call findprotbackbone(line,index,iresno,ia,
         -          inamcol1,icaahx(ir1,ihx),ica(ir1),ina(ir1),icb(ir1),
         -          icgx,icdx,nslt,icaonly,maxrec)
                  write (6,2158) ' ',ir,
         -          line(index(icaahx(ir1,ihx)))(irescol1:irescol2),
         -          iresno(icaahx(ir1,ihx)),icaahx(ir1,ihx),ica(ir1),
         -          ina(ir1)
                end do
                if (nhx .gt. 1) then
    9186          call getint(
         -          'Residue number (rn) that defines the helix rotation',
         -          51,0,1,ireshx2(ihx),iresrot,143)
                  if (iresrot .gt. 0) then
                    if (iresrot .lt. ireshx1(ihx)) then
                      print *,'Residue number is outside the ',ireshx1(ihx),
         -              ' - ',ireshx2(ihx),'range'
                      go to 9186
                    end if
                    ir1=iresrot-ireshx1(ihx)+1
                    icbahx(ihx)=icb(ir1)
                    icbreshx(ihx)=ir1
                    if (icb(ir1) .eq .0) then
                      print *,'Residue ',iresrot,' has not CB atom'
                    else
                      print *,'Atom index of the CB defining the rotation=',
         -              icbahx(ihx)
                    end if
                  end if
                end if
    9184        call getint(
         -        'Number of residues to ignore for rotation at each end',
         -        53,0,1,0,incrot,0)
                if (ireshx2(ihx)-ireshx1(ihx)+1-2*incrot .lt. 4) then
                  print *,'ERROR: too few residues remain to form a helix'
                  go to 9184
                end if
              end do
              call askyn('Is this a transmembrane protein',31,1,-1,itmem,0,
         -      0)
              if (itmem .eq. 1) call getint(
         -      'Coordinate axis normal to the membrane (1/2/3)',46,3,1,3,
         -      normhx,0)
              ndials=6
              idebughx=0
              call askyn('Do you want debug output',24,1,-1,idebughx,0,0)
              if (idebughx .gt. 0) then
                call askyn('Do you want to skip bend analysis',33,1,-1,ibx,
         -        0,0)
                if (ibx .gt. 0) idebughx=idebughx+1
              end if
              if (idebughx .lt. 2) call getreal(
         -      'Minimum distance (in A) from axis to count as bend',50,
         -      0.0,axtol,1,0)
              write (iw0,2004) axtol
              if (nhx .gt. 0) write (iw0,2124)
              write (iw0,2007)
              if (itraj .eq. 1) then
                linein(1:45)='Do you want to subtract the solute COM shift '
                linein(46:65)='from the helix shift'
                call askyn(linein,65,1,1,isubcrm,0,0)
                linein(1:41)='Do you want to overlay each frame on the '
                linein(42:60)='reference structure'
                call askyn(linein,60,1,1,ioverlay,0,41)
                if (ioverlay .gt. 0 .and. nsegslt .gt. 1) then
                  linein(1:43)='Do you want to overlay each solute molecule'
                  linein(44:54)=' separately'
                  call askyn(linein,54,1,1,ioverlaym,0,0)
                  if (ioverlaym .gt. 0) ioverlay=ioverlay+1
                end if
                if (idebughx .gt. 0) then
                  linein(1:40)='Do you want to reorient each helix onto '
                  linein(41:59)='the reference helix'
                  call askyn(linein,59,1,1,ireorienthx,0,0)
                else
                  ireorienthx=1
                end if
                idsspcheck=0
                if (icaonly .lt. 1)
         -        call askyn('Do you want to run DSSP check on each frame',
         -          43,1,1,idsspcheck,0,0)
                call zeroiti(nhelixok,0,3)
                if (idsspcheck .eq. 1)
         -        write (iw0,2016) (typc(i),ssname(i)(1:lssname(i)),i=1,9)
              end if
              do ihx=1,nhx
                write (iw0,2015) ihx,ireshx1(ihx),ireshx2(ihx),iseghx(ihx),
         -        icbreshx(ihx)
              end do
            else if (ianaltyp .eq. 13) then
              write (6,2076) 'Hydropathy scale',analfile(1:namleno)
              ihydtyp=0
            else if (ianaltyp .eq. 20) then
              innlist=0
              nl2=0
              call openfile(50,0,'Delphi potential map file',25,'old',
         -      analfile2,nl2,notfnd,0,2,1,0,0)
              call readmap(50,xstart,ystart,zstart,gx,gy,gz,ngx,ngy,ngz,
         -      nconf,c2,maxrec)
              igincr=0
              do while (igincr .lt. 1)
                call getint('Increment to use in reading the potential map',
         -         45,1,1,ngx,igincr,47)
                if (igincr .lt. 1) print *,'Invalid'
              end do
              if (igincr .gt. 1) write (6,2026) igincr
              write (6,2076) 'Delphi potentials',analfile(1:namleno)
              call askyn(
         -      'Do you want to exclude/interpolate grids near atoms',51,
         -      1,-1,iexcl,63,0)
              if (iexcl .gt. 0) then
                call getreal('Minimum distance between an atom and a grid',
         -        43,1.0,rnear,1,63)
                call askyn(
         -        'Do you want to interpolate the excluded grid values',51,
         -        1,-1,interpol,0,0)
              end if
              call askyn('Do you want to query the potential map',38,1,-1,
         -      iquery,64,0)
              iw2=0
              iw3=0
              if (igridfile+iquery .eq. 0) then
                print *,'No action requested'
              else
                if (igridfile .gt. 0) then
                  write (6,2076) 'Delphi grid potentials',
         -          analfile1(1:namleno1)
                  write (iw1,2027) 'Delphi grid potentials'
                  iw2=iw1+1
                  analfile2=analfile1
                  analfile2(namleno1:namleno1)='0'
                  write (6,2076)
         -          'Delphi grid potentials without excluded grids',
         -          analfile2(1:namleno1)
                  call openfile(iw2,0,'grid',4,'new',analfile2,namleno1,
         -          notfnd,0,1,1,0,0)
                  write (iw2,2027)
         -          'Delphi grid potentials without excluded grids'
                  if (interpol .gt. 0) then
                    iw3=iw2+1
                    analfile3=analfile1
                    analfile3(namleno1:namleno1)='1'
                    write (6,2076)
         -          'Delphi grid potentials, interpolating excluded grids',
         -            analfile3(1:namleno1)
                    call openfile(iw3,0,'grid',4,'new',analfile3,namleno1,
         -            notfnd,0,1,1,0,0)
                    write (iw3,2027)
         -            'Delphi grid potentials, interpolating excluded grids'
                  end if
                end if
                call delphigrid(iw1,iw2,iw3,c,n,nslt,xstart,ystart,zstart,
         -        gx,gy,gz,ngx,ngy,ngz,igincr,rnear,igridfile,iexcl,
         -        iquery,interpol)
                if (iw1 .gt. 0) close (iw1)
                if (iw2 .gt. 0) close (iw2)
                if (iw3 .gt. 0) close (iw3)
                if (iexcl .gt. 0) call readmap(50,xstart,ystart,zstart,
         -        gx,gy,gz,ngx,ngy,ngz,nconf,c2,maxrec)
              end if
            else if (ianaltyp .eq. 14) then
              write (6,2076) 'Circular variances',analfile(1:namleno)
              nsltref_f=1
              nsltref_f=nslt
              call getrange(nsltref_f,1,nsltref_l,nslt,incr,0,
         -      'solute atom to include in the CV calculation',44,nslt,000)
              call getreal(
         -      'Distance cutoff for the circular variance calculation',
         -      53,10.0,rcut_cv,1,66)
              islvrep=1
              if (n .gt. nslt) then
                if (naslv .gt. 1)
         -        call getint('Index of the representative solvent atom',
         -          40,1,1,naslv,islvrep,25)
                call askyn('Do you want to sort solvents by CV',34,1,+1,
         -        isortslv,0,0)
                if (isortslv .gt. 0) then
                  write (6,2105)
                  call getreal('CV threshold to count the # of solvents',
         -          39,0.5,cvlim,1,67)
                end if
              end if
            else if (ianaltyp .eq. 15) then
              write (6,2075) 'Circular variance',analfile(1:namleno),
         -      analfile1(1:namleno1)
              xm=500.0
              ym=800.0
              call openps(iw1,xm,ym-20,title,ltitle76,
         -      'Circular variance map',21,inpfile,namleni,inpfile,0,1,
         -      ipspage)
              iaskcolcode=1
              npspages=1
            else if (ianaltyp .eq. 16) then
              write (6,2019)
         -      'Secondary structure assignment according to DSSP',
         -      analfile(1:namleno)
              if (itraj .eq. 1) write (6,2019)
         -       'Secondary structure plot',analfile1(1:namleno1)
              write (iw0,2003)
              if (itraj .eq. 1) then
                call getrange(ifrdssp,1,ilrdssp,nresslt,incr,0,
         -        'residue sequence number to plot',31,nresslt,0)
                if (iresshift .gt. 0) then
                  write (6,2117) 'first',ixresno(ifrdssp)
                  write (6,2117) 'last ',ixresno(ilrdssp)
                  call askyn(
         -          'Do you want to use the actual residue # on the Y axis',
         -          53,1,-1,iuseinp,0,0)
                end if
                call askyn(
         -        'Do you want to calculate turn information (see GW Rose)',
         -        55,1,-1,irose,0,0)
                iwrose=iw0*irose
              else
                ifrdssp=1
                ilrdssp=nresslt
                iwrose=0
              end if
              if (iuseinp .eq. 1) then
                call trnsfi(indexdel,ixresno,nresslt)
                do i=nresslt+1,maxrec
                  indexdel(i)=indexdel(nresslt)+(i-nresslt)
                end do
              end if
              if (iuseinp .eq. 0) call indexit(indexdel,1,nresslt,0)
              call zeroiti(idistdssp,0,9*maxrsd)
              ncolcode=8
              innlist=0
            else if (ianaltyp .eq. 22 .or. ianaltyp .eq. 23 .or.
         -           ianaltyp .eq. 24) then
              iaskcolcode=1
              call zeroiti(indexdel,0,n)
              call indexit(indexov,1,nslt,0)
              nfinalov=nslt
              if (ianaltyp .eq. 23 .or. ianaltyp .eq. 24) then
                absdevmin=100000.0
                absdevmax=0.0
                innlist=0
                xm_2d=600.0
                ym_2d=775.0
    
                xm=xm_2d
                ym=ym_2d
              end if
              noopt2d=0
              if (iread2d .eq. 0) then
                if (ianaltyp .eq. 23 .or. ianaltyp .eq. 24) then
                  write (iw0,2084)
                  call askyn(
         -          'Do you want to superimpose first the frames',43,
         -          0,+1,noopt2d,0,0)
                  if (noopt2d .eq. 0) write (iw0,2116)
         -          'after obtaining the best fit with the Kabsch method'
                  if (noopt2d .eq. 1) write (iw0,2116)
         -           'without superimposition'
                  write (iw0,*)
                  rmsdmin=0.0
                  call getreal(
         -          'MAXimum of the RMSD scale (default: actual maximum)',
         -          51,0.0,rmsdmax,1,53)
                end if
                if (noopt2d .eq. 0) then
                  call askyn('Do you want to select atoms for overlay',39,
         -          1,-1,iedit,69,0)
                  if (iedit .gt. 0) then
                    nrecdel=0
                    call select(line,nrecdel,idcol,asterisk,n,nslt,index,
         -            ixres,is1,is2,iseqncol1,iseqncol2,inamcol1,inamcol2,
         -            irescol1,irescol2,iqcol1,iqcol2,charge,iatnum,
         -            nneig,ineig,indexdel,iw0,maxng,maxrec)
                    call masktolist(indexov,indexdel,nslt,nfinalov,0)
                  end if
                end if
                iqincr=0
                if (nfinalov .eq. nslt) iqincr=1
                call quiz(ans,icalctyp,'a',' ',0,
         -        'atoms for RMSD calculation',26,iqincr,5,6,0)
                if (ans .eq. 'a') then
                  call indexit(indexrmsd,1,nslt,0)
                  nfinalrmsd=nslt
                else if (ans .eq. 'o') then
                  call trnsfi(indexrmsd,indexov,nfinalov)
                  nfinalrmsd=nfinalov
                else
                  nrecdel=0
                  call zeroiti(indexdel,0,n)
                  call select(line,nrecdel,idcol,asterisk,n,nslt,index,
         -          ixres,is1,is2,iseqncol1,iseqncol2,inamcol1,inamcol2,
         -          irescol1,irescol2,iqcol1,iqcol2,charge,iatnum,nneig,
         -          ineig,indexdel,iw0,maxng,maxrec)
                  call masktolist(indexrmsd,indexdel,nslt,nfinalrmsd,0)
                  ifstrmsd=indexrmsd(1)
                  ilstrmsd=indexrmsd(nfinalrmsd)
                  if (ilstrmsd-ifstrmsd+1 .ne. nfinalrmsd) then
                    nocontigrmsd=1
                    write (6,2132)
                    write (iw0,2132)
                  end if
                end if
                if (nfinalrmsd .lt. nslt) limresrange=1
                if (nfinalov .lt. nslt) then
                  write (6,2153) 'overlay',nfinalov,nslt
                  write (iw0,2153) 'overlay',nfinalov,nslt,';',
         -          (indexov(i),i=1,nfinalov)
                else if (noopt2d .eq. 0) then
                  write (6,2154) 'overlay'
                  write (iw0,2154) 'overlay'
                end if
                if (nfinalrmsd .lt. nslt) then
                  write (6,2153) 'RMSD',nfinalrmsd,nslt
                  write (iw0,2153) 'RMSD',nfinalrmsd,nslt,';',
         -          (indexrmsd(i),i=1,nfinalrmsd)
                else
                  write (6,2154) 'RMSD'
                  write (iw0,2154) 'RMSD'
                end if
                atwsum=0.d0
                do iaa=1,nfinalov
                  ia=indexov(iaa)
                  atw(ia)=aw(iatnum(ia))
                  atwsum=atwsum+atw(ia)
                  end do
              end if
              if (ianaltyp .eq. 22) then
                write (6,2098)
                call askyn('Do you want to use the input structure instead',
         -        46,1,-1,inputref,0,0)
                call askyn('Do you want to plot also the maximum deviation',
         -        46,1,-1,maxdevplot,0,0)
                call askyn('Do you want to plot without overlay',35,1,-1,
         -        iunmatchplot,0,0)
                write (iw0,2082)
                npspages=1+iunmatchplot
                if (inptrajtyp .eq. 3) npspages=npspages+1
                call getreal(
         -        'MAXimum of the RMSD scale (default: actual maximum)',
         -        51,0.0,rmsdplotmax,1,0)
                call getreal(
         -        'MAXimum of the max dev scale (default: actual maximum)',
         -        54,0.0,rmaxdevplotmax,1,0)
                if (nresslt .le. MAXDISTR) then
                  call zeroitd(rmsfsum,nresslt)
                  call getreal(
         -          'MAXimum of the RMSF scale (default: actual maximum)',
         -          51,0.0,rmsfplotmax,1,0)
                  call getint('Frequency of plotting error bars',32,
         -          max0(1,nresslt/10),1,max0(1,nresslt/2),nfreqsd,0)
                else
                  write (6,2062) nresslt,MAXDISTR
                  npdpages=npspages-1
                end if
                call zeroitd(cdp,3*nfinalrmsd)
                call zeroitd(cdp2,3*nfinalrmsd)
              end if
              if (ianaltyp .eq. 23) then
                call askyn(
         -        'Do you want to also plot the RMSD distributions',47,
         -        0,+1,noplotdist,93,0)
                ireplot=0
                pstitle='2-D RMSD map'
                lpstitle=12
                if (iread2d .eq. 0) then
                  npspages=3
                  call askyn('Do you want RMSD-based clustering',33,
         -          1,+1,irmsdclust,0,0)
                  call askyn('Do you want to skip plotting the matrix',39,
         -          1,-1,iskip2dplot,121,0)
                  if (irmsdclust .gt. 0)
         -          call askyn(
         -            'Do you want an RMSD map rearranged by clusters',46,
         -            1,1,ireplot,0,0)
                else
                  irmsdclust=0
                  lq=32+lanalfile4
                  question(1:lq)='Input rd2 file name: '
         -          //analfile4(1:lanalfile4)//' - is it OK'
                  call askyn(question,lq,1,1,ians,00,0)
                  if (ians .eq. 0) lanalfile4=0
                  call openfile(iw4,0,'previously written .rd2',23,
         -          'old',analfile4,lanalfile4,notfnd,3,1,1,0,0)
                  extnam2='    '
                  write (6,2019) 'Clustering results',analfile(1:namleno)
                  write (iw0,2064) analfile4(1:namlen4)
                  call read_2drmsd(iw4,system,lsystem,trajnam,ltrajnam,
         -          trajnam2,ltrajnam2,ifirsttraj,ilasttraj,incrementtraj,
         -          ifirsttraj2,ilasttraj2,incrementtraj2,1,rmsdmn,rmsdmx,
         -          nframe,nframex,nframey,ietotsaved,0,limresrange,ierr)
                  if (ierr .gt. 0) go to 9003
                  nframeref=nframe
                  close(iw4)
                  call indexit(iconfsel,1,MAX2D,0)
                  call indexit(ixclst,1,MAX2D,0)
                  call askyn(
         -          'Do you want an RMSD map rearranged by clusters',46,
         -          1,1,ireplot,0,0)
                  call clusterdistr(nframe,iw0,rmsdlim,rmsdmn,rmsdmx,
         -          nhbdist,it1,it2,it3,itemp4,indexn,indexo,ncl,indexa,
         -          iconfsel,ixclst,it4,value,ifa_s,ila_s,ih,cv,0.0,rdclust,
         -          res(1,1,11),ietotsaved,'RMSD',4,1,1,irepav,irepmx,
         -          irepeng,irepkm,engcl,c,chn,c2,1,27,iclstyp,iwt,0,
         -          label2d,80,0,1,1,1,mx2d,maxframe)
                  do i=1,ncl
                    nclstmem(i)=indexo(i)-indexn(i)+1
                  end do
                  call trnsfi(ixshuffle,iconfsel,MAX2D)
                  call countsim(indexn,indexo,iconfsel,ncl,rdclust,rmsdsim,
         -          nsimclst1,iw0,mx2d)
                  call askyn('Do you want to replot the input RMSD map',40,
         -          1,-1,ireplotinp,0,0)
                  if (ireplot .eq. 0) call askyn(
         -          'Do you want an RMSD map rearranged by clusters',46,
         -          1,1,ireplot,0,0)
                  if (ireplot+ireplotinp .gt. 0) then
                    call getint(askcolcode,24,maxcolcode,1,maxcolcode,
         -            ncolcode,95)
                    npspages=2
                    analfile2=analfile
                    analfile2(namleni-2:namleni+6)='rd2_sh.ps'
                    namleno2=namleni+6
                    write (6,2019)
         -            pstitle(1:lpstitle)//' and membership plot',
         -            analfile2(1:namleno2)
                    iw1=iw0+1
                    call openfile(iw1,0,'(shuffled) RMSD map',19,
         -            'new',analfile2,namleno2,notfnd,0,1,1,0,0)
                    call openps(iw1,xm_2d,ym_2d,title(1:76),76,pstitle,
         -            lpstitle,' ',0,analfile4(1:namlen4),
         -            namelen4,npspages,ipspage)
                    if (ireplot .eq. 1) then
                      call indexit(it3,1,MAX2d,0)
                      call adjust_xtraj(xtraj,ifirsttraj,ilasttraj,
         -              incrementtraj,framefac,iadjust_xtraj)
                      call plot2drmsd(nrep,iw0,iw1,xtraj,maxrec,title,
         -              'Frames sorted by clusters',25,0,xtrajlab,11,
         -              ncolcode,maxcolcode,iedit,noopt2d,limresrange,0,
         -              rmsdmin,rmsdmax,absdevmin,absdevmax,rmsdmn,rmsdmx,
         -              indexa,it3,ixshuffle,ixshuffle,indexo,ncl,indexo,
         -              ncl,ym_2d,it1,it2,temp,1,1,noplotdist,0,1,1,
         -              ipspage,0)
                    end if
                    if (ncl .gt. 0)
         -            call clusterplot(iw1,xtraj,value,indexn,indexo,ncl,
         -              ixclst,nframe,xtrajlab,11,ipspage,ireplotinp,mx2d)
                    call indexit(ixshuffle,1,MAX2D,0)
                    if (ireplotinp .eq. 1) then
                      call indexit(it3,1,MAX2d,0)
                      call plothead(iw1,xm_2d,ym_2d,title(1:76),76,
         -              'RMSD file read:'//analfile4(1:namlen4),
         -              namlen4+15,trajnam,ltrajnam,'',0)
                      call plot2drmsd(nrep,iw0,iw1,xtraj,maxrec,title,
         -              'Input RMSD matrix',17,0,xtrajlab,11,ncolcode,
         -              maxcolcode,iedit,
         -              noopt2d,limresrange,0,rmsdmin,rmsdmax,absdevmin,
         -              absdevmax,rmsdmn,rmsdmx,indexa,it3,ixshuffle,
         -              ixshuffle,indexo,0,indexo,0,ym_2d,it1,it2,temp,1,1,
         -              noplotdist,0,1,1,ipspage,0)
                    end if
                  end if
                  go to 9005
                end if
                call indexit(iconfsel,1,MAX2D,0)
              else if (ianaltyp .eq. 24) then
                call getreal(
         -        'MINimum of the RMSD scale (default: actual minimum)',
         -        51,0.0,rmsdmin,1,53)
                if (iread2d .eq. 0) then
                  call askyn('Do you want to find matching structures',39,
         -          1,-1,matchconf,0,0)
                  call getreal('MAXimum RMSD for similarity statistics',38,
         -          2.5,rmsdsim,1,86)
                  if (rmsdsim .gt. 0) matchconf=1
                  pstitle='Cross RMSD map'
                  lpstitle=14
                  npspages=2
                  call indexit(iconfsel,1,MAX2D,0)
                else
                  notfnd=1
                  do while (notfnd .gt. 0)
                    call getname(analfile4,namlen4,
         -            'Name of .rd2 file from the first trajectory',43,
         -             200,'',0,0,0,0)
                    call openfile(iw4,0,'previously written .rd2',23,
         -            'old',analfile4,namlen4,notfnd,0,1,1,0,0)
                  end do
                  write (iw0,2064) analfile4(1:namlen4)
                  call read_2drmsd(iw4,system,lsystem,trajnam1,ltrajnam1,
         -          trajnam1,ltrajnam2x,if,il,inc,if2,il2,inc2,1,rmsdmn,
         -          rmsdmx,nframe1,nframex,nframey,ietotsaved,0,limresrange,
         -          ierr)
                  close (iw4)
                  write (6,2019) 'Clustering results',analfile(1:namleno)
                  call indexit(index2d1,1,MAX2D,0)
                  call indexit(ixclst,1,MAX2D,0)
                  call clusterdistr(nframe1,iw0,rmsdlim,rmsdmn,rmsdmx,
         -          nhbdist,it1,it2,it3,itemp4,ifclst1,ilclst1,ncl1,indexa,
         -          index2d1,ixclst,it4,value,ifa_s,ila_s,ih,cv,0.0,
         -          rdclust,res(1,1,11),ietotsaved,'RMSD',4,1,1,irepav,
         -          irepmx,irepeng,irepkm,engcl,c,chn,c2,1,27,iclstyp,iwt,0,
         -          label2d,80,0,1,1,1,mx2d,maxframe)
                  call trnsfi(irepmx1,irepmx,MAX2D)
                  call trnsfi(ixshuffle,index2d1,MAX2D)
                  call countsim(ifclst1,ilclst1,index2d1,ncl1,rdclust,
         -          rmsdsim1,nsimclst1,iw0,mx2d)
                  namlen4=0
                  notfnd=1
                  do while (notfnd .gt. 0)
                    call getname(analfile4,namlen4,
         -            'Name of .rd2 file from the second trajectory',44,
         -             200,'',0,0,0,0)
                    call openfile(iw4,0,'previously written .rd2',23,
         -            'old',analfile4,namlen4,notfnd,0,1,1,0,0)
                  end do
                  write (iw0,2064) analfile4(1:namlen4)
                  call read_2drmsd(iw4,system,lsystem,trajnam2,ltrajnam2,
         -          trajnam1,ltrajnam2x,if,il,inc,if2,il2,inc2,1,rmsdmn,
         -          rmsdmx,nframe2,nframex,nframey,ietotsaved2,0,
         -          limresrange,ierr)
                  close (iw4)
                  call indexit(index2d2,1,MAX2D,0)
                  call indexit(ixclst,1,MAX2D,0)
                  call clusterdistr(nframe2,iw0,rmsdlim,rmsdmn,rmsdmx,
         -          nhbdist,it1,it2,it3,itemp4,ifclst2,ilclst2,ncl2,indexa,
         -          index2d2,ixclst,it4,value,ifa_s,ila_s,ih,cv,0.0,
         -          rdclust,res(1,1,11),ietotsaved,'RMSD',4,1,1,irepav,
         -          irepmx,irepeng,irepkm,engcl,c,chn,c2,1,27,iclstyp,iwt,0,
         -          label2d,80,0,1,1,1,mx2d,maxframe)
                  call trnsfi(irepmx2,irepmx,MAX2D)
                  call trnsfi(ixshuffleref,index2d2,MAX2D)
                  call countsim(ifclst2,ilclst2,index2d2,ncl2,rmsdsim1,
         -          rmsdsim2,nsimclst2,iw0,mx2d)
                  namlen4=0
                  notfnd=1
                  do while (notfnd .gt. 0)
                    call getname(analfile4,namlen4,
         -            'Name of the previously written .rdx file',40,200,
         -             '',0,0,0,0)
                    analfile=inpfile
                    analfile(namleni+1:namleni+4)='.rdx'
                    call openfile(iw4,0,'previously written .rdx',23,
         -            'old',analfile4,namlen4,notfnd,0,1,1,0,0)
                    extnam2='    '
                  end do
                  call read_2drmsd(iw4,system,lsystem,trajnamr1,ltrajnamr1,
         -          trajnamr2,ltrajnamr2,if,il,inc,if2,il2,inc2,0,rmsdmn,
         -          rmsdmx,nframe2x,nframex,nframey,ietotsaved,0,
         -          limresrange,ierr)
                  nframe=nframex
                  nframeref=nframey
                  write (iw0,2064) analfile4(1:namlen4)
                  nerr=0
                  if (trajnamr1(1:ltrajnamr1) .ne. trajnam1(1:ltrajnam1))
         -            then
                    write (6,2063) 'first',trajnamr1(1:ltrajnamr1),
         -            trajnam1(1:ltrajnam1)
                    nerr=nerr+1
                  end if
                  if (trajnamr2(1:ltrajnamr2) .ne. trajnam2(1:ltrajnam2))
         -            then
                    write (6,2063) 'second',trajnamr2(1:ltrajnamr2),
         -            trajnam2(1:ltrajnam2)
                    nerr=nerr+1
                  end if
                  if (nframex .ne. nframe1 .or. nframey .ne. nframe2) then
                    write (6,2106) nframex,nframey,nframe1,nframe2
                    nerr=nerr+1
                  end if
                  if (nerr .gt. 0) call askstop(1)
                  call askyn(
         -          'Do you want a cross-RMSD map rearranged by clusters',
         -            51,1,1,ireplot,0,0)
                  if (ireplot .eq. 1) then
                    call getint(askcolcode,24,maxcolcode,1,maxcolcode,
         -            ncolcode,95)
                    pstitle='Cluster-ordered cross RMSD map'
                    lpstitle=30
                    npspages=2
                    analfile2=analfile
                    analfile2(namleni-2:namleni+6)='rdx_sh.ps'
                    namleno2=namleni+6
                    write (6,2019) pstitle(1:lpstitle),analfile2(1:namleno2)
                    iw1=iw0+1
                    call openfile(iw1,0,'shuffled cross-RMSD map',23,
         -            'new',analfile2,namleno2,notfnd,0,1,1,0,0)
                    call openps(iw1,xm_2d,ym_2d,title(1:76),76,pstitle,
         -            lpstitle,' ',2,' ',2,npspages,ipspage)
                    call adjust_xtraj(xtraj,ifirst,ilast,increment,
         -            framefac,iadjust_xtraj)
                    call plot2drmsd(nrep,iw0,iw1,xtraj,maxrec,title,
         -            'Frames sorted by clusters',25,ltrajnamr2,xtrajlab,11,
         -            ncolcode,maxcolcode,iedit,noopt2d,limresrange,0,
         -            rmsdmin,rmsdmax,absdevmin,absdevmax,rmsdmn,rmsdmx,
         -            indexa,iconfsel,ixshuffle,ixshuffleref,ilclst1,ncl1,
         -            ilclst2,ncl2,ym_2d,it1,it2,temp,1,0,noplotdist,0,1,
         -            1,ipspage,0)
                    call indexit(ixshuffle,1,MAX2D,0)
                  end if
                  call countsimx(ifclst1,ilclst1,index2d1,ncl1,
         -          ifclst2,ilclst2,index2d2,ncl2,rmsdsim1,iw0,mx2d)
                  write (iw0,*)
                  call getreal('Maximum RMSD for mapping',24,rmsdsim1,
         -          rmsdmapmax,1,87)
                  call mapclustx(2,ifclst1,ilclst1,irepmx1,ncl1,
         -          ifclst2,ilclst2,index2d2,ncl2,it1,it2,
         -          rmsdmapmax,nframe2,trajnam1,ltrajnam1,
         -          trajnam2,ltrajnam2,iw0,mx2d)
                  write (iw0,*)
                  call mapclustx(1,ifclst2,ilclst2,irepmx2,ncl2,
         -          ifclst1,ilclst1,index2d1,ncl1,it1,it2,
         -          rmsdmapmax,nframe1,trajnam1,ltrajnam1,
         -          trajnam2,ltrajnam2,iw0,mx2d)
                  go to 9005
                end if
              end if
              if (iread2d .eq. 0 .and. ianaltyp .gt. 22) write (6,2075)
         -        'RMSD',analfile(1:namleno),analfile1(1:namleno1)
            else if (ianaltyp .eq. 25) then
    9185      call getrange(ifrcorr,1,ilrcorr,ixres(nslt),incrres,1,
         -      'residue to calculate correlation and covariance map',51,
         -       numres,0)
              if ((ilrcorr-ifrcorr+1)/incrres+1 .gt. maxrcorr) then
                write (6,2096) maxrcorr,maxrcorr
                go to 9185
              end if
              iucorrmat=0
              call askyn(
         -      'Do you also want to calculate eigenvalues, eigenvectors',
         -      55,1,-1,ieig,125,0)
              if (ieig .eq. 1) iucorrmat=46
              call askyn('Do you also want to plot the covariance matrix',
         -      46,1,-1,icovmatplot,0,0)
              call modrepats
              ncorr=0
              do ir=ifrcorr,ilrcorr,incrres
                ncorr=ncorr+1
                indexs(ncorr)=ir
                call findat(indexa(ncorr),ifres(ir),ilres(ir),line,index,
         -        irescol1,inamcol1,MAXREC)
              end do
              ncolcode=0
              pstitle=' '
              lpstitle=0
              npspages=2
              ym=800.0
              write (iw0,*) 'Residue covariance and correlation matrix ',
         -     'calculation over a trajectory'
            else if (ianaltyp .eq. 35) then
              call askyn('Is the covariance matrix file binary',36,1,-1,
         -      ibin,000,0)
              if (ibin .eq. 0) then
                call askyn('Is the matrix broken into 5 numbers/line',40,
         -        1,-1,i5num,000,0)
                iformcov=2+i5num
              else
                iformcov=1
              end if
              iw0=40
              iw1=iw0+1
              notfound=1
              do while (notfound .gt. 0)
                call openfile(iw1,0,'input',5,'old',analfile1,lanalfile1,
         -        notfound,0,ibin+1,1,0,0)
                if (notfound .eq. 1) lanalfile1=0
              end do
              call openfile(iw0,0,'output',6,'new',analfile,lanalfile,
         -      notfoundout,0,1,1,0,0)
              if (notfoundout .gt. 0) return
              call askyn('Do you want annotated output',28,1,1,iannout,128,
         -      0)
              call normalmodes(ncorr,iw1,0,iformcov,iw0,
         -      iannout,ierr,index2d,value,ifa_s,ila_s,it1,rmsdlim,MAXBONDS)
              if (ierr .gt. 0) return
              go to 9005
            else if (ianaltyp .eq. 26) then
              write (iw0,2028)
              call askyn(
         -      'Do you want to calculate distances between atom clusters',
         -      56,1,-1,iclusterdist,105,0)
              if (iclusterdist .eq. 0) then
                write (6,2028) ' Enter atom pair indices'
                call getlist(listpairdist,npairs,1,nslt,2,MAXDDISTR)
              else
                call getclusterpairs(npairs,iclustermem,ifstclst1,ifstclst2,
         -        ilstclst2,nslt,0,MAXDDISTR,MAXCDLIST)
              end if
              call zeroit(pairdistsum,npairs)
              call zeroit(pairdistwsum,2*npairs)
              call zeroit(pairdistsum2,npairs)
              call zeroiti(npairdist,0,10*npairs)
              call getreal('Maximum distance to calculate distribution',42,
         -      10.0,rmaxpair,1,65)
              pairgrid=rmaxpair/float(MAXDDBIN)
              do ip=1,npairs
                pairdistminmax(1,ip)=10000.0
                pairdistminmax(2,ip)=-pairdistminmax(1,ip)
              end do
            else if (ianaltyp .eq. 39) then
              write (iw0,2119)
              write (6,2019) 'Atom-atom distances and SDs',
         -      analfile(1:namleno)
              call select(line,nrecdel,idcol,asterisk,n,nslt,index,
         -      ixres,is1,is2,iseqncol1,iseqncol2,inamcol1,inamcol2,
         -      irescol1,irescol2,iqcol1,iqcol2,charge,iatnum,
         -      nneig,ineig,indexdel,6,maxng,maxrec)
              call masktolist(ianchor,indexdel,nslt,nanchor,0)
              call quiz(ans,isdtyp,'n',' ',0,'SD normalization',16,0,5,6,0)
              xm_2d=600.0
              ym_2d=775.0
              pstitle='Atom-Atom distance SD plot'
              lpstitle=26
              call openps(iw1,xm_2d,ym_2d,title(1:76),76,pstitle,
         -      lpstitle,trajnam,ltrajnam,' ',0,npspages,ipspage)
            else if (ianaltyp .eq. 27) then
              call getreal('Solvent radius',14,1.4,rsolv,1,0)
              nranddef=20000*(rsolv/1.4)**2
              call getint('Number of random points for volume calculation',
         -      46,nranddef,1,0,nrand,33)
              write (iw0,2025) rsolv,nrand
              levout=0
              call getint('Print level',11,0,0,0,levout,0)
              nframetotmin=10
              write (6,2019) 'Calculated volumes',analfile(1:namleno)
              if (itraj .eq. 1) write (6,2019) analfile1(1:namleno1)
            else if (ianaltyp .eq. 28) then
              print *,'Select atoms for principal axis calculation'
              call select(line,nrecdel,idcol,asterisk,n,nslt,index,ixres,
         -      is1,is2,iseqncol1,iseqncol2,inamcol1,inamcol2,irescol1,
         -      irescol2,iqcol1,iqcol2,charge,iatnum,nneig,ineig,indexdel,
         -      0,maxng,maxrec)
              call masktolist(indexa,indexdel,n,natspax,0)
              write (6,2099)
              ic=44
              call condenselist(indexa,natspax,ic,6)
              write (iw0,2099)
              ic=44
              call condenselist(indexa,natspax,ic,iw0)
              write (6,2097) analfile(1:namleno)
              if (itraj .eq. 1) then
                write (6,2098)
                call askyn('Do you want to use the input structure instead',
         -        46,1,-1,inputref,0,0)
                xm=800.0
                ym=500.0
                write (6,2019) 'Evolution and distribution plots',
         -        analfile1(1:namleno1)
              end if
            else if (ianaltyp .eq. 29) then
              print *,'Select the atoms for the calculation'
              call select(line,nrecdel,idcol,asterisk,n,nslt,index,ixres,
         -      is1,is2,iseqncol1,iseqncol2,inamcol1,inamcol2,
         -      irescol1,irescol2,iqcol1,iqcol2,charge,iatnum,nneig,ineig,
         -      indexdel,0,MAXNEIG,MAXREC)
              call masktolist(indexa,indexdel,n,ngyrats,0)
              write (6,2100)
              ic=12
              call condenselist(indexa,ngyrats,ic,6)
              write (6,2107) analfile(1:namleno)
              if (itraj .eq. 1) then
                xm=800.0
                ym=500.0
                write (6,2019) 'Evolution and distribution plots',
         -        analfile1(1:namleno1)
              end if
              write (iw0,2100)
              ic=12
              call condenselist(indexa,ngyrats,ic,iw0)
            else if (ianaltyp .eq. 30) then
              print *,'Amber analysis is now under the Miscellaneous menu'
              go to 9005
            else if (ianaltyp .eq. 40) then
              write (6,2019) 'Filtering results',analfile(1:namleno)
              ierr=0
              call getint('Representative atom (center) of the solvent',
         -      43,1,1,naslv,iarepslv,0)
              call getreal('Solvent space grid spacing',26,8.0,spacing,1,
         -      116)
              rsltmax=0.0
              rcvmax=0.0
              cvmin=0.0
              call quiz(ans,ifilttyp,'c',' ',0,'solvent filtering option',
         -      24,0,5,6,000)
              if (ifilttyp .eq. 1 .or. ifilttyp .eq. 3) call getreal(
         -      'Maximum distance from the nearest solute heavy atom',51,
         -      5.0,rsltmax,1,0)
              if (ifilttyp .gt. 1 .and. ifilttyp .lt. 5) call getreal(
         -      'CV calculation cutoff distance',30,15.0,rcvmax,1,0)
              if (ifilttyp .eq. 2 .or. ifilttyp .eq. 3) call getreal(
         -      'Minimum CV to keep a solvent',28,0.65,cvmin,1,0)
              if (ifilttyp .eq. 4) then
                if (nsegslt .lt. 2) then
                  print *,'There is only one solute molecule'
                  return
                else if (nsegslt .eq. 2) then
                  mol11=1
                  mol12=1
                  mol21=2
                  mol22=2
                else
                  print *,'There are ',nsegslt,' solute molecules'
                  call quiz(ans,intftyp,' ',' ',0,'interface partners',18,
         -          0,5,6,0)
                  if (ans .eq. 'p') then
                    call getint('First molecule of the interface',31,1,1,
         -            nsegslt,mol1,000)
                    call getint('Second molecule of the interface',32,
         -            nsegslt,1,nsegslt,mol2,000)
                    mol11=mol1
                    mol12=mol1
                    mol21=mol2
                    mol22=mol2
                  else if (ans .eq. 's') then
                    call getint('Selected interface molecule',27,1,1,
         -            nsegslt,mol1,000)
                    mol11=mol1
                    mol12=mol1
                    mol21=1
                    mol22=nsegslt
                  else
                    mol11=1
                    mol12=nsegslt
                    mol21=1
                    mol22=nsegslt
    
                  end if
                end if
                ang12min1=110.0
                ang12min2=145.0
                r12max=15.0
                cvrlim=3.5
                cvmin=0.60
                rneigh=5.0
                write (6,2125) cvmin,r12max,ang12min1,ang12min2,cvrlim,
         -        rneigh
                call askyn('Do you want to change these limits',34,1,-1,
         -        inp,0,0)
                if (inp .eq. 1) then
                  call getreal('Minimum CV of an interface solvent',34,
         -        cvmin,cvmin,1,0)
                  call getreal(
         -          'Maximum R1-R2 distance of an interface solvent',48,
         -          r12max,r12max,1,0)
                  call getreal(
         -          'Minimum R1-SLV-R2 angle when d(R1-R2) <= 6 A',44,
         -          ang12min1,ang12min1,1,0)
                  call getreal(
         -          'Minimum R1-SLV-R2 angle when d(R1-R2) > 6 A',43,
         -          ang12min2,ang12min2,1,0)
                  call getreal(
         -          'Maximum CV (wrt the two solute molecules) ratio',47,
         -          cvrlim,cvrlim,1,0)
                  call getreal('Radius of sphere that can not be empty',
         -          38,rneigh,rneigh,1,0)
                  write (6,2125)cvmin,r12max,ang12min1,ang12min2,cvrlim,
         -          rneigh
                end if
              else if (ifilttyp .eq. 5) then
                call set_hbondlims(hbf0,hblimfac,angm0,angmin,iw0)
                innlist=0
                ihbondcalc=1
              end if
              analfile1=inpfile
              call strip_cext(analfile1,namleni,namleno,lenext)
              crdexti(1:lenext)=analfile1(namleni-lenext+1:namleni)
              analfile1(namleno+1:namleno+5)='_filt'
              namleno=namleno+5
              namlen_root=namleno
              if (itraj .eq. 1) then
                call askyn(
         -        'Do you want the filtered structures in a single file',52,
         -        1,1,ionefile,0,0)
                write (6,2110) analfile1(1:namlen_root)
                write (iw0,2167)
                if (ifilttyp .eq. 1) write (iw0,2164)
         -        'solute solvent distance'
                if (ifilttyp .eq. 2) write (iw0,2164)
         -        'CV w.r.t. the solute'
                if (ifilttyp .eq. 3) write (iw0,2164)
         -        'solute solvent distance and CV w.r.t. the solute'
                if (ifilttyp .eq. 4) write (iw0,2164) 'interface'
                if (ifilttyp .eq. 1 .or. ifilttyp .eq. 3)
         -        write (iw0,2165) rsltmax
                if (ifilttyp .eq. 2 .or. ifilttyp .eq. 3)
         -        write (iw0,2166) cvmin,rcvmax
              end if
              if (ionefile .eq. 0 .and. (itraj .eq. 1 .or. nconfig .eq. 2))
         -        write (6,2102) analfile1(1:namlen_root),
         -        crdexti(1:lenext)//'.pdb'
            else
              write (6,2041) analtyp
              go to 9002
            end if
            if (iw0 .gt. 0 .and. ianaltyp .ne. 35) then
              if (title(1:4) .ne. '@#$%') write (iw0,*) 'System:',
         -      title(1:ltitle)
              if (itraj .eq. 0) write (iw0,2006)
         -      mark0(1:lmark0),'Structure',inpfile(1:namleni)
              if (itraj .eq. 1) write (iw0,2118) inpfile(1:namleni)
            end if
            if (ianaltyp .ne. 29 .and. ianaltyp .ne. 35) then
              if (iw1 .gt. 0 .and.  extnam2 .ne. '.ps') then
                if (title(1:4) .ne. '@#$%') write (iw1,2014)mark1(1:lmark1),
         -        mark1(1:lmark1),mark1(1:lmark1),title(1:ltitle)
                if (itraj .eq. 0) write (iw1,2006)
         -        mark1(1:lmark1),'Structure',inpfile(1:namleni)
                if (itraj .eq. 1) write (iw1,2118) inpfile(1:namleni)
              end if
              if (iw2 .gt. 0 .and. ianaltyp .ne. 22) then
                if( analfile2(namleno2-2:namleno2) .ne. '.ps ') then
                  if (title(1:4) .ne. '@#$%')
         -          write (iw2,2014)mark2(1:lmark2), mark2(1:lmark2),
         -            mark2(1:lmark2),title(1:ltitle)
                  if (itraj .eq. 0) write (iw2,2006)
         -          mark2(1:lmark2),'Structure',inpfile(1:namleni)
                  if (itraj .eq. 1) write (iw2,2118) inpfile(1:namleni)
                end if
              end if
            end if
          else
            if (iw0 .gt. 0) write (iw0,2173) nconfig,nconfig
            if (iw1 .gt. 0) write (iw1,2173) nconfi,nconfigg
            itraj=0
          end if
          call cofms(cres,crmslt0,nslt,atw)
          if (ianaltyp .eq. 21 .or. ianaltyp .eq. 22 .or. ianaltyp .eq. 23
         -  .or. ianaltyp .eq. 27 .or. ianaltyp .eq. 28 .or. ianaltyp .eq.29
         -  .or. ianaltyp .eq. 33) then
            call askyn('Do you want mass-weighting',26,1,1,masswt,0,0)
            if (masswt .eq. 0) then
              write (iw0,2022)
              do ia=1,n
                atw(ia)=1.0
              end do
            end if
          end if
          if (ibondtype .gt. 0 .and. ibondtype .ne. 1 .and. itraj .eq. 0)
         -  call printanchorlist(bondname,lbondname,ibondtype,ianchor,
         -    nanchor,indexa,indexov,nanchorr,nanchorn,line,index,iresno,
         -    isegno,segid4,inamcol1,inamcol2,irescol1,irescol2,iw0,maxrsd,
         -    maxrec)
          if (iaskcolcode .eq. 1)
         -  call getint(askcolcode,24,maxcolcode,1,maxcolcode,ncolcode,95)
    3001  if (itraj .eq. 0) then
            if (ianaltyp .eq.  1) then
              call printbondlist(iangpr,itorpr,1,nslt,nslt,c,nneig,ineig,
         -      line,inamcol1,inamcol2,irescol1,irescol2,iresncol1,
         -      iresncol2,index,cv,indexa,maxng,radtodeg,iw0,maxrec)
            else if (ianaltyp .eq.  2) then
              call stat14(c,n,nneig,ineig,index,line,nconfig,pi,iatnm2,
         -      irescol1,irescol2,inamcol1,inamcol2,inpcrdtyp,ioins,iw0,
         -      maxrepconf,maxng,maxrec)
            else if (ianaltyp .eq.  3) then
    C---------(S) Functional group analysis, backbone plot
              call findfg(1,n,iatnum,mmtype,indexo,indexn,nhbneig,ih,ifgtyp,
         -      ibnd,nfg,6,nneig,nhneig,nneiga,ineig,iw0,inpcrdtyp,ioins,
         -      inamcol1,inamcol2,irescol1,irescol2,iresncol1,iresncol2,
         -      line,index,maxng,maxrec)
              call findbackbone(1,nslt,iw1,nneig,ineig,nneiga,
         -      ibnd,inamcol1,inamcol2,irescol1,irescol2,line,blankline,
         -      index,indexn,indexo,indexs,ifree,maxng,maxbox,maxrec)
            else if (ianaltyp .eq.  4) then
              call bondlenstat(c,n,iatnum,nneig,ineig,iatnm2,nconfig,
         -      nanos,ixlist,ialist,iw0,inpcrdtyp,ioins,inamcol1,inamcol2,
         -      irescol1,irescol2,line,index,radtodeg,maxrepconf,maxng,
         -      maxrec)
            else if (ianaltyp .eq.  5) then
              call hblist(c,n,nslt,islvw,naslv,iatnum,ifchrg,isegno,nneig,
         -      nneiga,nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,
         -      ixres,nconfig,hbf0,angm0,molresflag,hblimfac,angmin,
         -      iw0,inamcol1,inamcol2,irescol1,irescol2,iresncol1,
         -      iresncol2,blankline,line,index,indexn,ibnd,indexo,isolvent,
         -      1,0,nosameseg,0,radtodeg,maxrepconf,maxng,maxbox,
         -      maxrsd,maxrec)
              if (ireorient .gt. 0) call zeroit(centgra,3)
            else if (ianaltyp .eq.  6 .or. ianaltyp .eq. 34) then
              call nnlisthph_sltb(nslt,ianchor2,iselfanc,indexa,
         -      nneig,npneig,nhbneig,ineig,c,rhphmax,0,isegno,nosameseg,
         -      bondlab(ibondtype),4,ibnd,indexo,ifail,maxng,maxng,
         -      maxrec)
              call hph_sltblist(ibondtype,c,nslt,nhbneig,ineig,iw0,is1,
         -      is2,inamcol1,inamcol2,irescol1,irescol2,iresncol1,
         -      iresncol2,line,index,bondname,lbondname,bondlab(ibondtype),
         -      4,maxng)
            else if (ianaltyp .eq. 41) then
              call nnlistmpx(n,nanchorr,nanchorn,indexa,indexov,iatnum,
         -      nneig,nhbneig,c,isegno,ibnd,indexo,rmpxlim,itemp1,itemp2,
         -      itemp3,itemp4,indexn,temp,cv,ifail,maxng,maxrec)
              call mpxblist(n,itemp1,itemp2,cv,itemp3,itemp4,is1,is2,
         -      inamcol1,inamcol2,irescol1,irescol2,iresncol1,iresncol2,
         -      line,index,ixres,nhbdist,rhbdist,nbfound,nbresfound,nbonds,
         -      c,rmpxlim,ifailbond,iw0,MAXBONDS,maxrec)
            else if (ianaltyp .eq.  7) then
              call nnlisthph_sltb(nslt,ianchor2,iselfanc,indexa,
         -      nneig,npneig,nhbneig,ineig,c,rsltbmax,1,isegno,nosameseg,
         -      bondlab(ibondtype),4,ibnd,indexo,ifail,maxng,maxng,
         -      maxrec)
              call hph_sltblist(ibondtype,c,nslt,nhbneig,ineig,iw0,
         -      is1,is2,inamcol1,inamcol2,irescol1,irescol2,
         -      iresncol1,iresncol2,line,index,bondname,lbondname,
         -      bondlab(3),4,maxng)
            else if (ianaltyp .eq.  8) then
              call rrdist(c,n,nres,ixresno,iresno,ixres,resnames,ifres,
         -      ilres,increst,incsolvrr,irefres1,irefres2,irefseg1,irefseg2,
         -      irefresinc,resdistlim,inegres1,inegres2,inegseg1,inegseg2,
         -      inegresinc,resapplim,listrefres,nrefres,nrefrange,l
         -      istnegres,nnegres,nnegrange,iatnum,ignoreh,0,0,iw0,iw1,iw2,
         -      irescol1,irescol2,inamcol1,inamcol2,is1,is2,irescount1,
         -      irescount2,irescount3,line,index,indexn,indexo,indexs,
         -      indexa,itemp1,itemp2,temp,cv,maxrec,maxrsd)
            else if (ianaltyp .eq.  9) then
              call pbcdist(c(1,ia1),c(1,ia2),ia1,ia2,cell,ncell,0,0,
         -      img,dr,d)
            else if (ianaltyp .eq. 10) then
              call checkunphys(c,nslt,n,naslv,islvw,iatnum,ifchrg,isegno,
         -      idelseg,indexo,nneig,nneiga,nhbneig,ineig,nhneig,nnneig,
         -      ncneig,nsneig,npneig,ixres,line,irescol1,irescol2,inamcol1,
         -      inamcol2,index,nconfig,innlist,molresflag,ioppbc,cell,ncell,
         -      edge,ixyzhex,molsltlim,nmolslt,hblimfac,angmin,ctfac,
         -      bondminfac,maxdist,iles,iw0,isltonly,ibnd,indexn,rlim,
         -      innlistread,0,radtodeg,nerrunphys,maxrepconf,maxng,maxbox,
         -      maxrsd,maxrec)
              if (nerrunphys .eq. 0) write (6,*) 'Nothing untoward detected'
            else if (ianaltyp .eq. 11) then
              write (6,2078)
              nmem=5
              do while (.true.)
                call getring(line,index,ix5,irescol1,irescol2,inamcol1,
         -        inamcol2,nslt,numres,iresring,iresno,ifres,ilres,nmem,
         -        psrtyp,0,incgen,iapex,MAXRING,maxrec)
                if (nmem .eq. 0) go to 9001
                call pseudorot(c,n,ix5,nmem,nneig,ineig,psr5,psr,npsr,
         -        psrtyp,incgen,zring,rring,sinpsrs,cospsrs,qpsr,qpsrs,
         -        qpsr2s,zav,zsq,zavs,zsqs,1,6,0,radtodeg,maxng,maxrec)
                print *
              end do
            else if (ianaltyp .eq. 12) then
              if (noprol .eq. 0)
         -      call pseudorot(c,n,ix5,nmem,nneig,ineig,psr5,psr,npsr,'p',
         -        incgen,zring,rring,sinpsrs,cospsrs,qpsr,qpsrs,qpsr2s,
         -        zav,zsq,zavs,zsqs,1,6,0,radtodeg,maxng,maxrec)
              if (nconfig .gt. 2) iprintpk=0
              call prokinkcalcla(1,c,nslt,bend,wobble,faceshift,
         -      rmsb,rmsa,
         -      iflatproline,ix5,radtodeg,MAXHX)
              if (noprol .eq. 0)
         -      call pseudorot(c,n,ix5,nmem,nneig,ineig,psr5,psr,npsr,'p',
         -        incgen,zring,rring,sinpsrs,cospsrs,qpsr,qpsrs,qpsr2s,
         -        zav,zsq,zavs,zsqs,0,6,0,radtodeg,maxng,maxrec)
              write (iw0,2072) nconfig,bend,wobble,faceshift,
         -      wobble-faceshift,psr(2),rmsb,rmsa
            else if (ianaltyp .eq. 13) then
              call hydropathylist(n,nslt,ixres,resnames,cv,ihydtyp,
         -      maxrsd,maxrec)
              call writeconf(iw0,inpcrdtyp,inpcrdtyp,inpcrdtyporg,n,n,nslt,
         -      naslv,islvw,iasv,namesv,qsv,pflsv,1,iwhead,0,iatnum,ifchrg,
         -      nconfig,innlist,c,rprox,cv,ixres,iresno,atnames,resnames,
         -      segnames,charge,isegno,altcol,inscol,ninsres,marker,ntitlin,
         -      ntitlinw,title,ireseq,iresnrestart,iresidrestart,nneig,
         -      nneiga,nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,
         -      numres,numslv,resnamslv,line,blankline,mmtype,ibnd,index,
         -      indexn,indexo,1,molresflag,irescount3,itemp1,hblimfac,
         -      angmin,0,1,1,1,0,2,iqspaceask,13,0,0.0,0,0,0,keeprem,
         -      iwriteatsym,radtodeg,maxrepconf,maxng,maxrsd,maxrec)
            else if (ianaltyp .eq. 14) then
              call cvlist(c,n,nslt,nsltref_f,nsltref_l,naslv,islvrep,icvtyp,
         -      rcut_cv,rprox,cv,itemp1,c2,temp,indexn,indexo,indexs,chn,
         -      isortslv,cvlim)
              call writeconf(iw0,inpcrdtyp,inpcrdtyp,inpcrdtyporg,n,n,nslt,
         -      naslv,islvw,iasv,namesv,qsv,pflsv,1,iwhead,0,iatnum,ifchrg,
         -      nconfig,innlist,c,rprox,cv,ixres,iresno,atnames,resnames,
         -      segnames,charge,isegno,altcol,inscol,ninsres,marker,ntitlin,
         -      ntitlinw,title,ireseq,iresnrestart,iresidrestart,nneig,
         -      nneiga,nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,
         -      numres,numslv,resnamslv,line,blankline,mmtype,ibnd,index,
         -      indexn,indexo,1,molresflag,irescount3,itemp1,hblimfac,
         -      angmin,0,1,1,1,0,3,iqspaceask,14,0,0.0,0,0,0,keeprem,
         -      iwriteatsym,radtodeg,maxrepconf,maxng,maxrsd,maxrec)
            else if (ianaltyp .eq. 15) then
              call cvplot(c,n,nslt,icvtyp,line,index,indexs,inamcol1,
         -      inamcol2,iresncol1,iresncol2,'CA      ',title,ltitle,
         -      ncolcode,maxcolcode,iw0,iw1,1,maxrec,ipspage)
            else if (ianaltyp .eq. 16) then
              call dssp(c,1,n,nslt,line,index,inamcol1,inamcol2,iresncol1,
         -      iresncol2,nneig,ineig,nneiga,ibnd,indexn,indexo,npneig,
         -      nsneig,nnneig,dssplab,idistdssp,chn,c2,cv,indexs,indexa,
         -      nsse,itypsse,ifsse,ilsse,0,nconfig,iw0,0,1,ifail,radtodeg,
         -      maxrepconf,maxng*10,maxrec/10,maxng*20,maxrec/20,200,
         -      maxrsd,maxrec)
            else if (ianaltyp .eq. 17) then
              call hblist(c,n,nslt,islvw,naslv,iatnum,ifchrg,isegno,nneig,
         -      nneiga,nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,
         -      ixres,nframe,hbf0,angm0,molresflag,hblimfac,angmin,
         -      iw0,inamcol1,inamcol2,irescol1,irescol2,iresncol1,
         -      iresncol2,blankline,line,index,indexn,ibnd,indexo,1,0,1,
         -      nosameseg,0,radtodeg,maxrepconf,maxng,maxbox,maxrsd,maxrec)
              call hbbridge(nanchor,ianchor,indexa,ianchor2,iselfanc,lpath,
         -      nbridgetype,ibridgetype,maxbridgemem,n,nhbneig,ineig,indexn,
         -      indexo,indexs,ixres,resnames,brslv,nabr,nrescol,0,ifail,
         -      listbridge,iw0,maxng,MAXBRIDGELEN,MAXBRIDGETYPE,
         -      minbridgelenprint,maxrsd,maxrec)
              call hbbridgeprint(nanchor,ianchor,lpath,nbridgetype,
         -      ibridgetype,maxbridgemem,line,index,iresno,inamcol1,
         -      inamcol2,irescol1,irescol2,iw0,maxbondcount,
         -      maxhbtype,minbridgelenprint,0,1,MAXBRIDGELEN,MAXBRIDGETYPE,
         -      maxrec)
            else if (ianaltyp .eq. 18) then
              call ramachandran(c,nslt,index,line,nconfig,pi,nresfound,
         -      iresno,ixres,irescol1,irescol2,inamcol1,iw0,
         -      maxng,maxrec)
              call ramachandranplot(nresfound,iw1,xm,iallrama)
            else if (ianaltyp .eq. 32) then
              call angledials(c,nslt,nangsel,ixtor1234,index,line,pi,
         -      irescol1,irescol2,inamcol1,inamcol2,iw0,maxrec)
            else if (ianaltyp .eq. 19) then
              call torsiondials(c,nslt,ntorsel,ixtor1234,index,line,pi,
         -      irescol1,irescol2,inamcol1,inamcol2,iw0,maxrec)
            else if (ianaltyp .eq. 20) then
              call delphilabel(c,n,nslt,xstart,ystart,zstart,gx,gy,gz,cv)
              call writeconf(iw0,inpcrdtyp,inpcrdtyp,inpcrdtyporg,n,n,nslt,
         -      naslv,islvw,iasv,namesv,qsv,pflsv,1,iwhead,0,iatnum,ifchrg,
         -      nconfig,innlist,c,rprox,cv,ixres,iresno,atnames,resnames,
         -      segnames,charge,isegno,altcol,inscol,ninsres,marker,ntitlin,
         -      ntitlinw,title,ireseq,iresnrestart,iresidrestart,nneig,
         -      nneiga,nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,
         -      numres,numslv,resnamslv,line,blankline,mmtype,ibnd,index,
         -      indexn,indexo,1,molresflag,irescount3,itemp1,hblimfac,
         -      angmin,0,1,1,1,0,0,iqspaceask,20,0,0.0,0,0,0,keeprem,
         -      iwriteatsym,radtodeg,maxrepconf,maxng,maxrsd,maxrec)
            else if (ianaltyp .eq. 21) then
              do ihx=1,nhx
                call helixaxis(c,nslt,iw0,calph(1,1,ihx),axisdir(1,ihx),
         -        axisini(1,ihx),axisend(1,ihx),helixcent(1,ihx),
         -        perpvec(1,1,ihx),camod(1,1,ihx),anglechangeref(1,ihx),
         -        circ(1,ihx),rnorm(1,ihx),axfact(1,ihx),axtol,rot,rms,
         -        helixlen(ihx),angles(1,ihx),decidebend,nup,ndown,nrun,
         -        nnear,rcirchx(ihx),turnperres(ihx),anglesn(1,ihx),0,
         -        incrot,nrep,0,nreshx(ihx),icaahx(1,ihx),ihx,nhxres,
         -        idebughx,radtodeg,pi,MAXHX)
                iadssp1=ifres(ixres(icaahx(1,ihx)))
                iadssp2=ilres(ixres(icaahx(nreshx(ihx),ihx)))
                call dssp(c,iadssp1,n,iadssp2,line,index,inamcol1,
         -        inamcol2,iresncol1,iresncol2,nneig,ineig,nneiga,
         -        ibnd,indexn,indexo,npneig,nsneig,nnneig,dssplab,
         -        idistdssp,chn,c2,cv,indexs,indexa,nsse,itypsse,
         -        ifsse,ilsse,ireshx1(ihx)-1,nframe,0,0,0,ifail,radtodeg,
         -        maxrepconf,maxng*10,maxrec/10,maxng*20,
         -        maxrec/20,200,maxrsd,maxrec)
                lhelixcklab=9+1
                write (helixcklab,2160) 'H',ihx
                call checkforhelix(ireshx2(ihx)-ireshx1(ihx)+1,
         -        dssplab,indexn,iw0,hxoklab,ihxok,helixcklab,
         -        lhelixcklab,maxrsd,maxrec)
                nhelixok(ihxok)=nhelixok(ihxok)+1
              end do
              if (nhx .gt. 1) call multihelix(iw0,nhx,nhxres,radtodeg,c,
         -      icaahx,icbahx,icbreshx,maxrec,MAXHX,MAXNHX)
            else if (ianaltyp .eq. 26) then
              if (iclusterdist .eq. 0) then
                call pairdistcalc(c,nslt,npairs,listpairdist,pairdistsum,
         -        pairdistsum2,pairdistwsum,npairdist,pairdistminmax,
         -        pairgrid,iw0,MAXDDBIN,MAXDDISTR)
              else
                call clusterdistcalc(c,nslt,npairs,iclustermem,
         -        ifstclst1,ifstclst2,ilstclst2,pairdistsum,pairdistsum2,
         -        pairdistwsum,npairdist,pairdistminmax,pairgrid,
         -        iw0,MAXDDBIN,MAXDDISTR,MAXCDLIST)
              end if
              call pairdistprint(nframe,npairs,listpairdist,iclusterdist,
         -      iclustermem,ifstclst1,ifstclst2,ilstclst2,pairdistsum,
         -      pairdistsum2,pairdistwsum,npairdist,pairdistminmax,
         -      pairgrid,rmaxpair,line,index,inamcol1,inamcol2,irescol1,
         -      irescol2,iresncol1,iresncol2,inpcrdtyp,ioins,iw0,nslt,
         -      MAXDDBIN,MAXDDISTR,MAXCDLIST,maxrec)
            else if (ianaltyp .eq. 27) then
              call volcalc(nrand,c,nslt,isegno,iatnum,nsegslt,molsltlim,
         -      itemp1,cres,chn,c2,atw,vmac,vshell,vint,vmacsd,vshellsd,
         -      vintsd,vfrstsh,vfrstshsd,rsolv,ih,indexn,indexo,indexs,
         -      indexa,indexdel,1,iw0,levout,maxrsd,maxrec)
            else if (ianaltyp .eq. 28) then
              call princax(c,c2,atw,temp,n,indexdel,evecs0,evals0,iw0,0,1,
         -      radtodeg,0)
              call askyn('Do you want to align the structure to an axis',
         -      45,1,0,ialign,0,0)
              if (ialign .eq. 1) then
                call getint('Axis index (1/2/3) to align',27,3,1,3,iax,000)
                iemax=1
                do k=2,3
                  if (evals0(k) .gt. evals0(iemax)) iemax=k
                end do
                call cofms(c,crmslt,nslt,aw)
                call shiftmol(c,nslt,crmslt,c2,-1.0)
                do k=1,3
                  rot(iax,k)=evecs0(iemax,k)
                  rot(mod(iax,3)+1,k)=evecs0(mod(iemax,3)+1,k)
                  rot(mod(iax+1,3)+1,k)=evecs0(mod(iemax+1,3)+1,k)
                end do
                call rotate_c(c2,n,rot,c2,'PRINCAX',7)
                call writeconf(iw1,inpcrdtyp,inpcrdtyp,inpcrdtyporg,n,n,
         -        nslt,naslv,islvw,iasv,namesv,qsv,pflsv,1,iwhead,0,iatnum,
         -        ifchrg,nconfig,innlist,c2,rprox,cv,ixres,iresno,atnames,
         -        resnames,segnames,charge,isegno,altcol,inscol,ninsres,
         -        marker,ntitlin,ntitlinw,title,ireseq,iresnrestart,
         -        iresidrestart,nneig,nneiga,nhbneig,ineig,nhneig,nnneig,
         -        ncneig,nsneig,npneig,numres,numslv,resnamslv,line,
         -        blankline,mmtype,ibnd,index,indexn,indexo,1,molresflag,
         -        irescount3,itemp1,hblimfac,angmin,0,1,1,1,0,2,iqspaceask,
         -        13,0,0.0,0,0,0,keeprem,iwriteatsym,radtodeg,maxrepconf,
         -        maxng,maxrsd,maxrec)
              else
                close (iw1,status='delete')
              end if
            else if (ianaltyp .eq. 29) then
                call molrad(c,indexa,ngyrats,iw0,MAXREC)
                call celldipole(c,n,nslt,indexa,ngyrats,charge,icharges,atw,
         -        iw0,1)
            else if (ianaltyp .eq. 31) then
              call rrconn(c,n,ires1,ires2,ifres,ilres,iatnum,ignoreh,
         -      irepuse,iadjtyp,iscalesum,resdistlim,nexpmax,npint,ipspage,
         -      npspages,iw0,iw1,line,index,irescol1,inamcol1,
         -      imarkres,marks,itemp4,itemp1,itemp2,itemp3,
         -      temp,inpfile,namleni,analfile4,namleno4,maxrec)
            else if (ianaltyp .eq.  33) then
                call mmdist(c,n,atw,iatnum,nmolslt,molsltlim,c2,temp,
         -        ignoreh,iw0,iw1)
            else if (ianaltyp .eq.  40) then
              if (ifilttyp .eq. 5)
         -      call nnlist(n,islvw,naslv,n,iatnum,ifchrg,c,nneig,nneiga,
         -        nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,line,
         -        irescol1,irescol2,inamcol1,inamcol2,index,nconfig,innlist,
         -        molresflag,hblimfac,angmin,ihbondcalc,ibnd,indexo,isegno,
         -        ixres,maxrepconf,0,0,radtodeg,0,maxbox,maxng,maxrsd,
         -        maxrec)
              call filterslv(c,iatnum,nslt,n,naslv,numsolv,molsltlim,
         -      nsegslt,index,nconfig,ifilttyp,intftyp,rsltmax,rcvmax,cvmin,
         -      ang12min1,ang12min2,r12max,cvrlim,rneigh,mol11,mol12,mol21,
         -      mol22,spacing,itemp1,iarepslv,numsolvleft,nhbneig,ineig,
         -      ixres,nrecdel,ierr,6,maxrec,maxng)
              write (iw0,2126) numsolvleft
              if (nconfig .eq. 2)
         -      call askyn(
         -      'Do you want all filtered structures in a single file',52,
         -        1,1,ionefile,0,0)
              if (numsolvleft .gt. 0) then
                if (nconfig .gt. 1 .and. ionefile .eq. 0) then
                  namleno=namlen_root+1
                  analfile1(namleno:namleno)='.'
                  call writeint(analfile1,namleno,nconfig,lenc)
                  namleno=namleno+lenc
                end if
                if (nconfig .eq. 1 .or. ionefile .eq. 0) then
                  analfile1(namleno+1:namleno+lenext)=crdexti(1:lenext)
                  namleno=namleno+lenext
                  call openfile(45,0,'FILT',4,'new',analfile1,namleno,
         -          notfnd,0,1,1,0,0)
                end if
                call writeout(45,inpcrdtyp,inpcrdtyp,line,index,isegno,
         -        n-nrecdel,marker,1,0,ntitlin,ntitlinw,title,blankline,
         -        1,1,0,0.0,0,0,0,keeprem,iwriteatsym,iatnum,maxrec)
                close (45)
              else
                write (6,2070) nconfig
              end if
            end if
    9001    if (nconfig .eq. 1) go to 9005
          else
            if (ireadtracks .eq. 0) call asktrajform(inptrajtyp,ioutrajtyp,
         -    mmctrajtyp,resnamslv,-1,1)
            inpt=70
            iverbose=1
            notitprint=0
            iopen_rep=0
          end if
          numsolvmin=999999
          numsolvmax=0
          numsolvsum=0
          irepscan=1
          nrepinc=0
          nframeread=0
          if (itraj .eq. 1 .and. ianaltyp .eq. 23) then
            irepscan=0
            ifail=0
            maxconf=999999
            do while (maxconf .gt. mx2d)
              call opentraj(c,1,inpt,inptrajtyp,n,ntitltr,trtitle,
         -      inpcrdtyp,ifirst,ilast,increment,maxconf,ninconf,noutconf,
         -      natom,nfreeat,ifree,icntrl,0,mmctrajtyp,trajnam,ltrajnam,
         -      'trajectory',10,iconfsel,numsel,iverbose,notitprint,0,0,
         -      icellfound,notfnd,iconfirmname,iopen_rep,lentest,iw0,
         -      ianaltyp,mx2d,maxconfsel,maxrec)
            end do
            call save_traj_lim(ifirst,ilast,increment,1)
            if (iw0 .gt. 0) write (iw0,2006) mark0(1:lmark0),
         -    'Trajectory',trajnam(1:ltrajnam)
            write (iw0,2060) 'Trajectory',ifirst,ilast,increment
            nframetot=(ilast-ifirst)/increment+1
            nframetot=nframetot*(nframetot-1)/2
            nframesign=nframetot/10
            ncmem=(maxrec10-n)/nslt+1
            call adjust_xtraj(xtraj,ifirst,ilast,increment,framefac,
         -    iadjust_xtraj)
            write (6,2157) ncmem
            write (iw0,2157) ncmem
            nframe1=0
            nframe2d=0
            ic1=1
            ncop=0
            iehead=1
            do while (ninconf .lt. ilast .and. ifail .eq. 0)
              call readtraj(inpt,inptrajtyp,mmctrajtyp,n,naslv,nwatr,
         -      nslt,trajformatname(inptrajtyp),ntitltr,trtitle,trajnam,
         -      ltrajnam,natom,nfreeat,ifree,icntrl,c(1,ic1),ninconf,
         -      noutconf,increment,inpcrdtyp,ietotsaved,etot,ifail,ifirst,
         -      ilast,iconfsel,numsel,maxrepconf*irepscan,nmc,lentest,1.0,
         -      maxconf,maxconfsel,maxrec)
              if (ietotsaved .eq. 1 .and. iw0 .gt. 0) then
                if (iehead .eq. 1) write (6,*)
         -        'Energies read will be listed on the log file'
                iehead=0
                write (iw0,2175) ninconf,etot
              end if
              icsel=0
              if (ifail .eq. 0) then
                nframeread=nframeread+1
                call selectconf(numsel,ninconf,ifirst,increment,
         -        iconfsel,nextconfsel,nframeref,icsel,ifail,maxconfsel)
              else
                ninconf=ilast
                nframetot=nframe
                if (nframeread .eq. 0) go to 9002
              end if
              if (icsel .eq. 1) then
                ic1=ic1+nslt
                ncop=ncop+1
                it1(ncop)=ninconf
                nframe1=nframe1+1
                res(2,nframe1,11)=etot2
                res(1,nframe1,11)=etot
              end if
              if (ninconf .eq. ilast .or. ncop .eq. ncmem) then
                do nc1=1,ncop
                  nframe=nframe1-ncop+nc1
                  ic1=(nc1-1)*nslt+1
                  do nc2=nc1+1,ncop
                    ic2=(nc2-1)*nslt+1
                    nframeref=nframe1-ncop+nc2
                    write (iw0,2173) nframe,it1(nc1),' ',nframeref,it1(nc2)
                    call rmsd(c(1,ic2),c(1,ic1),nslt,nfinalov,nfinalrmsd,
         -            atw,atwsum,temp,chn,c2,indexov,indexov,noopt2d,
         -            1,indexrmsd,indexrmsd,rot,com1,com2,etot,etot2,iw0,
         -            devmax,devmaxnoopt,maxrec)
                    if (absdevmin .gt. devmax) absdevmin=devmax
                    if (absdevmax .lt. devmax) absdevmax=devmax
                    nframe2d=nframe2d+1
                    call progress_rep(0,nframe2d,nframesign)
                  end do
                end do
                ifirst=nframeread+increment
                nframe2=nframe1
                rewind inpt
                call opentraj(c2,0,inpt,inptrajtyp,n,ntitltr,trtitle,
         -        inpcrdtyp,ifirst,ilast,increment,maxconf,ninconf2,
         -        noutconf,natom,nfreeat,ifree,icntrl,0,mmctrajtyp,trajnam,
         -        ltrajnam,'trajectory',10,iconfsel,numsel2,0,1,0,0,
         -        icellfound,notfnd,iconfirmname,iopen_rep,lentest,0,
         -        ianaltyp,mx2d,maxconfsel,maxrec)
                notitprint=1
                iopen_rep=1
                ic2=1
                ncop2=0
                nframeread2=0
                ifail2=0
                do while (ninconf2 .lt. ilast .and. ifail2 .eq. 0)
                  call readtraj(inpt,inptrajtyp,mmctrajtyp,n,naslv,nwatr,
         -          nslt,trajformatname(inptrajtyp),ntitltr,trtitle,trajnam,
         -          ltrajnam,natom,nfreeat,ifree,icntrl,cres(1,ic2),
         -          ninconf2,noutconf,increment,inpcrdtyp,ietotsaved,etot,
         -          ifail2,ifirst,ilast,iconfsel,numsel2,
         -          maxrepconf*irepscan,nmc,lentest,1.0,maxconf,maxconfsel,
         -          maxrec)
                  icsel=0
                  if (ifail2 .eq. 0) then
                    nframeread2=nframeread2+1
                    call selectconf(numsel,ninconf2,ifirst,increment,
         -            iconfsel,nextconfsel,nframeref,icsel,ifail2,
         -            maxconfsel)
                  end if
                  if (icsel .eq. 1) then
                    ic2=ic2+nslt
                    ncop2=ncop2+1
                    nframe2=nframe2+1
                    it2(ncop2)=ninconf2
                  end if
                  if (ninconf2 .eq. ilast .or. ncop2 .eq. ncmem) then
                    do nc1=1,ncop
                      ic1=(nc1-1)*nslt+1
                      nframe=nframe1-ncop+nc1
                      do nc2=1,ncop2
                        ic2=(nc2-1)*nslt+1
                        nframeref=nframe2-ncop2+nc2
                        write (iw0,2173) nframe,it1(nc1),' ',nframeref,
         -                it2(nc2)
                        call rmsd(c(1,ic1),cres(1,ic2),nslt,nfinalov,
         -                nfinalrmsd,atw,atwsum,temp,chn,c2,indexov,indexov,
         -                noopt2d,1,indexrmsd,indexrmsd,rot,com1,com2,etot,
         -                etot2,iw0,devmax,devmaxnoopt,maxrec)
                        if (absdevmin .gt. devmax) absdevmin=devmax
                        if (absdevmax .lt. devmax) absdevmax=devmax
                        nframe2d=nframe2d+1
                        call progress_rep(0,nframe2d,nframesign)
                      end do
                    end do
                    ic2=1
                    ncop2=0
                  end if
                end do
                numsel2=1
                ic1=1
                ncop=0
                if (ninconf .lt. ilast) then
                  nskip=ninconf
                  rewind inpt
                  call opentraj(c,1,inpt,inptrajtyp,n,ntitltr,trtitle,
         -          inpcrdtyp,ifirst,ilast,increment,maxconf,ninconf,
         -          noutconf,natom,nfreeat,ifree,icntrl,0,mmctrajtyp,
         -          trajnam,ltrajnam,'trajectory',10,iconfsel,numsel,
         -          0,notitprint,1,0,icellfound,notfnd,iconfirmname,
         -          iopen_rep,lentest,iw0,ianaltyp,mx2d,maxconfsel,maxrec)
                  do while (ninconf .lt. nskip)
                    call readtraj(inpt,inptrajtyp,mmctrajtyp,n,naslv,nwatr,
         -            nslt,trajformatname(inptrajtyp),ntitltr,trtitle,
         -            trajnam,ltrajnam,natom,nfreeat,ifree,icntrl,c(1,ic1),
         -            ninconf,noutconf,increment,inpcrdtyp,ietotsaved,etot,
         -            ifail,ifirst,ilast,iconfsel,numsel,
         -            maxrepconf*irepscan,nmc,lentest,1.0,maxconf,
         -            maxconfsel,maxrec)
                  end do
                end if
              end if
            end do
            nframe=nframe1
            nframeref=nframe2+1
            close (inpt)
            write (iw0,2085)
            write (iw0,2020) trajnam(:ltrajnam),nframeread,nframe,' ',
         -    ifirst-1
            if (lpstitle .gt. 0) then
              call openps(iw1,xm,ym,title(1:76),76,pstitle,lpstitle,trajnam,
         -      ltrajnam,trajnam2,0,npspages,ipspage)
            end if
          else if (itraj .eq. 1 .and. ianaltyp .eq. 24) then
            irepscan=0
            ifail1=0
            maxconf=999999
            ifirst1=1
            ifirst2=1
            do while (maxconf .gt. mx2d)
              call opentraj(c,1,inpt,inptrajtyp,n,ntitltr,trtitle,
         -      inpcrdtyp,ifirst1,ilast1,increment1,maxconf,ninconf1,
         -      noutconf,natom,nfreeat,ifree,icntrl,0,mmctrajtyp,trajnam,
         -      ltrajnam,'trajectory',10,iconfsel,numsel,iverbose,
         -      notitprint,0,0,icellfound,notfnd,iconfirmname,iopen_rep,
         -      lentest,iw0,ianaltyp,mx2d,maxconfsel,maxrec)
            end do
            call save_traj_lim(ifirst1,ilast1,increment1,1)
            if (increment1 .gt.  2 .and. nslt .gt. 200) then
              write (6,2090)
              call askstop(0)
            end if
            if (iw0 .gt. 0) write (iw0,2006) mark0(1:lmark0),
         -    'Trajectory',trajnam(1:ltrajnam)
            write (iw0,2060) 'Trajectory',ifirst1,ilast1,increment1
            nframetot1=(ilast1-ifirst1)/increment1+1
            ncmem=(maxrec10-n)/nslt+1
            call adjust_xtraj(xtraj,ifirst1,ilast1,increment1,framefac,
         -    iadjust_xtraj)
            write (6,2157) ncmem
            write (iw0,2157) ncmem
            nframe1=0
            ic11=1
            ncop1=0
            nframe2d=0
            nframeread1=0
            nframesign=1
            inpt2=80
            do while (ninconf1 .lt. ilast1 .and. ifail1 .eq. 0)
              call readtraj(inpt,inptrajtyp,mmctrajtyp,n,naslv,nwatr,
         -      nslt,trajformatname(inptrajtyp),ntitltr,trtitle,trajnam,
         -      ltrajnam,natom,nfreeat,ifree,icntrl,c(1,ic11),ninconf1,
         -      noutconf,increment,inpcrdtyp,ietotsaved,etot,ifail1,ifirst1,
         -      ilast1,iconfsel,numsel,maxrepconf*irepscan,nmc,lentest,1.0,
         -      maxconf,maxconfsel,maxrec)
              icsel=0
              if (ifail1 .eq. 0) then
                nframeread1=nframeread1+1
                call selectconf(numsel,ninconf1,ifirst1,increment1,
         -        iconfsel,nextconfsel,nframeref,icsel,ifail1,maxconfsel)
              else
                ninconf1=ilast
                nframetot1=nframe
                if (nframeread1 .eq. 0) go to 9002
              end if
              if (icsel .eq. 1) then
                ic11=ic11+nslt
                ncop1=ncop1+1
                it1(ncop1)=ninconf1
                nframe1=nframe1+1
                res(2,nframe1,11)=etot2
                res(1,nframe1,11)=etot
              end if
              if (ninconf1 .eq. ilast1 .or. ncop1 .eq. ncmem) then
                call opentraj(cres,0,inpt2,inptrajtyp,n,ntitltr,trtitle,
         -        inpcrdtyp,ifirst2,ilast2,increment2,maxconf,ninconf2,
         -        noutconf,natom,nfreeat,ifree,icntrl,1,mmctrajtyp,
         -        trajnam2,ltrajnam2,'second trajectory',17,iconfsel2,
         -        numsel2,iverbose,1,0,0,icellfound,notfnd,0,iopen_rep2,
         -        lentest,0,ianaltyp,mx2d,maxconfsel,maxrec)
                call save_traj_lim(ifirst2,ilast2,increment2,2)
                if (increment2 .gt.  2 .and. nslt .gt. 200) then
                  write (6,2090)
                  call askstop(0)
                end if
                if (nframe2d .eq. 0) then
                  write (iw0,2006) mark0(1:lmark0),'Second trajectory',
         -          trajnam2(1:ltrajnam2)
                  write (iw0,2060) 'Second trajectory',ifirst2,ilast2,
         -          increment2
                  nframetot2=(ilast2-ifirst2)/increment2+1
                  nframesign=nframetot1*nframetot2/10
                end if
                nframe2=0
                nframeread2=0
                ninconf2=0
                ic21=1
                ncop2=0
                ifail2=0
                do while (ninconf2 .lt. ilast2 .and. ifail2 .eq. 0)
                  call readtraj(inpt2,inptrajtyp,mmctrajtyp,n,naslv,nwatr,
         -          nslt,trajformatname(inptrajtyp),ntitltr,trtitle,trajnam,
         -          ltrajnam,natom,nfreeat,ifree,icntrl,cres(1,ic21),
         -          ninconf2,noutconf,increment,inpcrdtyp,ietotsaved,etot,
         -          ifail2,ifirst2,ilast2,iconfsel,numsel2,
         -          maxrepconf*irepscan,nmc,lentest,1.0,maxconf,maxconfsel,
         -          maxrec)
                  icsel=0
                  if (ifail2 .eq. 0) then
                    nframeread2=nframeread2+1
                    call selectconf(0,ninconf2,ifirst2,increment2,
         -            iconfsel,nextconfsel,nframeref,icsel,ifail2,
         -            maxconfsel)
                  else
                    print *,'TRAJ 2 ENDED NINCONF2=',ninconf2
                    ninconf2=ilast
                    nframetot=nframe2
                    if (nframeread2 .eq. 0) go to 9002
                  end if
                  if (icsel .eq. 1) then
                    ic21=ic21+nslt
                    ncop2=ncop2+1
                    it2(ncop2)=ninconf2
                    nframe2=nframe2+1
                  end if
                  if (ninconf2 .eq. ilast2 .or. ncop2 .eq. ncmem) then
                    do nc1=1,ncop1
                      ic1=(nc1-1)*nslt+1
                      nframe=nframe1-ncop1+nc1
                      do nc2=1,ncop2
                        ic2=(nc2-1)*nslt+1
                        nframeref=nframe2-ncop2+nc2
                        write (iw0,2173) nframe,it1(nc1),' ',nframeref,
         -                it2(nc2)
                        call rmsd(c(1,ic1),cres(1,ic2),nslt,nfinalov,
         -                nfinalrmsd,atw,atwsum,temp,chn,c2,indexov,indexov,
         -                noopt2d,0,indexrmsd,indexrmsd,rot,com1,com2,etot,
         -                etot2,iw0,devmax,devmaxnoopt,maxrec)
                        if (absdevmin .gt. devmax) absdevmin=devmax
                        if (absdevmax .lt. devmax) absdevmax=devmax
                        nframe2d=nframe2d+1
                        call progress_rep(0,nframe2d,nframesign)
                      end do
                    end do
                    ic21=1
                    ncop2=0
                  end if
                end do
                close (inpt2)
                numsel2=1
                ic11=1
                ncop1=0
                iverbose=0
              end if
            end do
            write (iw0,2020) trajnam(:ltrajnam),nframeread,nframe
            if (lpstitle .gt. 0) then
              call openps(iw1,xm,ym,title(1:76),76,pstitle,lpstitle,trajnam,
         -      ltrajnam,trajnam2,ltrajnam2,npspages,ipspage)
            end if
          else if (itraj .eq. 1) then
            if (ireadtracks .gt. 0) go to 8006
            iopen_rep2=0
            nframeref=1
            nextconfsel2=2
            nframe2d=0
            nrep=nrep+1
            nframe=0
            nframeread=0
            ifail=0
            if (nrep .gt. 1 .or. nframeref .gt. 1) then
              iverbose=0
              nrepinc=1
            end if
            ninp=n
            separatorchar='_'
            call opentraj(c,nrep+nrepinc,inpt,inptrajtyp,n,ntitltr,trtitle,
         -    inpcrdtyp,ifirst,ilast,increment,maxconf,ninconf,noutconf,
         -    natom,nfreeat,ifree,icntrl,0,mmctrajtyp,trajnam,ltrajnam,
         -    'trajectory',10,iconfsel,numsel,iverbose,notitprint,0,0,
         -    icellfound,notfnd,iconfirmname,iopen_rep,lentest,iw0,
         -    ianaltyp,mx2d,maxconfsel,maxrec)
            call save_traj_lim(ifirst,ilast,increment,1)
            call adjust_xtraj(xtraj,ifirst,ilast,increment,framefac,
         -    iadjust_xtraj)
            iopen_rep=1
            nerr_int=max0(1,maxconf/MAXDISTRN)
            if (numsel .gt. 0) nextconfsel=1
            if (ianaltyp .eq. 16) then
              maxtrajplot=ilast/increment
              call roundlimint(maxtrajplot,idiv,ndivdssp)
              maxtrajplot=idiv*ndivdssp
              print *,'maxtrajplot,idiv,ndivdssp=',
         -      maxtrajplot,idiv,ndivdssp
            end if
            notitprint=1
            if (ntitltr .gt. 0 .and. title(1:4) .eq. '@#$%') then
              title=trtitle(1)
              if (trtitle(1)(1:21) .eq. 'Created by DCD plugin')
         -      title=trtitle(2)
              call lastchar(title,ltitle,80)
            end if
            if (iw0 .gt. 0 .and. nframeref .eq. 1) write (iw0,2006)
         -    mark0(1:lmark0),'Trajectory',trajnam(1:ltrajnam)
            if (n .ne. ninp) then
              write (6,2034) ninp,n
              write (iw0,2034) ninp,n
              if (nrep .eq. 1 .and. nframe .eq. 0 .and. nframeref .eq. 1)
         -      call askstop(1)
            end if
            if (ibondtype .gt. 0)
         -    call printanchorlist(bondname,lbondname,ibondtype,ianchor,
         -      nanchor,indexa,indexov,nanchorr,nanchorn,line,index,iresno,
         -      isegno,segid4,inamcol1,inamcol2,irescol1,irescol2,iw0,
         -      maxrsd,maxrec)
            if (nrep .eq. 1 .and. nframe .eq. 0 .and. nframeref .eq. 1)then
              if (lpstitle .gt. 0) call openps(iw1,xm,ym,title(1:76),76,
         -      pstitle,lpstitle,trajnam,ltrajnam,trajnam2,ltrajnam2,
         -      npspages,ipspage)
            end if
            if (nframeref .eq. 1) then
              if (ianaltyp .eq. 16 .and. ilast .eq. 999999) then
                call getint('Last configuration in the trajectory',36,
         -        999999,1,0,ilast,0)
              end if
              nframetot=999999
              if (ilast .ne. 999999) then
                nframetot=(ilast-ifirst)/increment+1
                nframesign=nframetot/10
              end if
              if (nframetot .gt. maxframe .and.
         -      (ianaltyp .eq. 12 .or. ianaltyp .eq. 21)) then
                if (ilast .ne. 999999) then
                  write (6,2074) maxframe,'structures',' '
                  close (inpt)
                  return
                else
                  write (6,2074) maxframe,'structures',' you may have to '
                end if
              end if
              if (ianaltyp .eq. 23 .and. increment .gt. 10 .and.
         -        ilast .gt. 1000) then
                write (6,2021)
                call askstop(0)
              end if
              if (nrep .le. 1) then
                if (ianaltyp .eq. 21 .or. ianaltyp .eq. 22)
         -         write (iw0,2012) inpfile(1:namleni)
                if (ianaltyp .eq. 21) then
                  if (isubcrm+ioverlay .gt. 0) then
                    if (ioverlay .eq. 0) write (iw0,2017)
                    if (ioverlay .eq. 1) write (iw0,2018) ' '
                    if (ioverlay .eq. 2)
         -            write (iw0,2018) ' by molecule'
                    atwsum=0.d0
                    do ia=1,nslt
                      atw(ia)=aw(iatnum(ia))
                      atwsum=atwsum+atw(ia)
                    end do
                  end if
                  write (iw0,2085)
                  iextra=0
                  if (itmem .gt. 0)
         -          call askyn('Does the normal point to extracellular',
         -               38,1,1,iextra,0,0)
                  do ihx=1,nhx
                    write (iw0,2010)
                    call helixaxis(cres,nslt,iw0,calph0(1,1,ihx),
         -            axisdir0(1,ihx),axisini0(1,ihx),axisend0(1,ihx),
         -            helixcent0(1,ihx),perpvec0(1,1,ihx),camod(1,1,ihx),
         -            anglechangeref(1,ihx),circ(1,ihx),rn0(1,ihx),
         -            axfact(1,ihx),axtol,rot,rms,helixlen0(ihx),
         -            angles(1,ihx),decidebend,nup,ndown,nrun,nnear,
         -            rcirchx(ihx),turnperres(ihx),anglesn(1,ihx),0,incrot,
         -            nrep,0,nreshx(ihx),icaahx(1,ihx),ihx,nhxres,
         -            idebughx,radtodeg,pi,MAXHX)
                    ihax=0
                    projmax=0.0
                    do k=1,3
                      if (abs(axisdir0(k,ihx)) .gt. projmax) then
                        projmax=abs(axisdir0(k,ihx))
                        ihax=k
                      end if
                    end do
                    axdirchar(ihx)=xyz(ihax)
                    write (6,2129) ihx,axdirchar(ihx)
                    indexaxhx(1,ihx)=ihax
                    indexaxhx(2,ihx)=mod(ihax,3)+1
                    indexaxhx(3,ihx)=mod(ihax+1,3)+1
                    if (itmem .gt. 0) then
                      if (normhx .eq. ihax) then
                        memdir(ihx)=1
                        if (axisdir0(ihax,ihx) .lt. 0) memdir(ihx)=2
                        if (iextra .eq. 0) memdir(ihx)=3-memdir(ihx)
                        tmchar=tmchars(memdir(ihx))
                      else
                        memdir(ihx)=0
                        tmchar='n'
                      end if
                      anghx=acos(abs(axisdir0(normhx,ihx)))*radtodeg
                      write (6,2130) xyz(normhx),anghx
                      call quiz(ans,ihxtyp,tmchar,' ',0,'Helix type',10,0,
         -              5,6,0)
                      memdir(ihx)=ihxtyp-1
                    end if
                    if (memdir(ihx) .eq. 0) then
                       write (iw0,2129) ihx,axdirchar(ihx)
                    else
                      write (iw0,2129) ihx,axdirchar(ihx),' (TM)'
                    end if
                    do ir=2,(ireshx2(ihx)-ireshx1(ihx)+1)
                      call angcomp(perpvec0(1,ir-1,ihx),axisdir0(1,ihx),
         -              perpvec0(1,ir,ihx),anglechangeref(ir,ihx))
                      if (anglechangeref(ir,ihx) .lt. 0.0)
         -              anglechangeref(ir,ihx)=anglechangeref(ir,ihx)+2.0*pi
                    end do
                    do ir=1,(ireshx2(ihx)-ireshx1(ihx)+1)
                      call dvdif(calph0(1,ir,ihx),axisini0(1,ihx),
         -            calph0(1,ir,ihx))
                    end do
                  end do
                  if (nhx .gt. 1) call multihelix(iw0,nhx,nhxres,radtodeg,c,
         -          icaahx,icbahx,icbreshx,maxrec,MAXHX,MAXNHX)
                end if
              end if
              write (iw0,2005)
              write (6,2081) maxrepconf
            end if
            nntest=0
            ilastframe=0
            do while (ninconf .lt. ilast .and. ifail .eq. 0)
              call readtraj(inpt,inptrajtyp,mmctrajtyp,n,naslv,nwatr,
         -      nslt,trajformatname(inptrajtyp),ntitltr,trtitle,trajnam,
         -      ltrajnam,natom,nfreeat,ifree,icntrl,c,ninconf,
         -      noutconf,increment,inpcrdtyp,ietotsaved,etot,ifail,ifirst,
         -      ilast,iconfsel,numsel,maxrepconf*irepscan,nmc,lentest,1.0,
         -      maxconf,maxconfsel,maxrec)
              if (mod(n-nslt,naslv) .ne. 0) then
                write (6,2168) n,nslt,naslv
                call askstop(-1)
              end if
              numsolv=(n-nslt)/naslv
              icsel=0
              if (ifail .eq. 0) then
                nframeread=nframeread+1
                call selectconf(numsel,ninconf,ifirst,increment,
         -        iconfsel,nextconfsel,nframeref,icsel,ifail,maxconfsel)
              else
                ninconf=ilast
                nframetot=nframe
                if (nframeread .eq. 0) go to 9002
              end if
              if (nframe .gt. MAXFRAMES) write (6,2059) MAXFRAMES
              if (icsel .gt. 0) then
                nframe=nframe+1
                if (ianaltyp .eq.  9 .and. ioppbc .ge. 0) then
                  if (nframe .eq. 1) then
                    if (ifirstref .eq. 0 .and. ioppbc .ge. 0) then
                      call pbcdist(c(1,ia1),c(1,ia2),ia1,ia2,cell,ncell,
         -              -iw0,1,img,drincr,dimg)
                      call zeroit(drimg,3)
                      call arrdiff(drimg,cell(1,img),drimg,3)
                    end if
                  else if (noboxinfoar .eq. 0) then
                    call updatecell(inptrajtyp,edge)
                  end if
                end if
                if (nntest .eq. 0 .and. innlist .gt. 0) then
                  call checknnlist(1,n,ineig,nneig,nerr,maxng)
                  call comparetop(c,n,nneig,ineig,iatnum,innlist,nslt,naslv,
         -          cell,ncell,ioppbc,maxng,maxrec)
                  nntest=1
                end if
                if (noprintconf .eq. 0 .and. ianaltyp .ne. 12 .and.
         -        (ianaltyp .ne. 17 .or. listbridge .eq. 1)) then
                  if (iw0 .gt. 0) write (iw0,2173) nframe,ninconf
                  if (iw1 .gt. 0 .and. extnam2 .ne. '.ps ') then
                    write (iw1,2173) nframe,ninconf
                  else if (iw2 .gt. 0 .and. ianaltyp .ne. 22) then
                    if (analfile2(namleno2-2:namleno2) .ne. '.ps ')
         -            write (iw2,2173) nframe,ninconf
                  end if
                end if
                if (itrajrot .gt. 0) call rotate_c(c,n,trajrot,c,
         -        'TRAJROT',7)
                if (ianaltyp .eq.  1) then
                  call printbondlist(iangpr,itorpr,1,nslt,nslt,c,nneig,
         -          ineig,line,inamcol1,inamcol2,irescol1,irescol2,
         -          iresncol1,iresncol2,index,cv,indexa,maxng,radtodeg,
         -          iw0,maxrec)
                else if (ianaltyp .eq.  2) then
                  call stat14(c,n,nneig,ineig,index,line,nframe,pi,iatnm2,
         -          irescol1,irescol2,inamcol1,inamcol2,inpcrdtyp,ioins,iw0,
         -          maxrepconf,maxng,maxrec)
                else if (ianaltyp .eq.  3) then
    C-------------(T) Functional group analysis
                  call findfg(1,n,iatnum,mmtype,indexo,indexn,nhbneig,ih,
         -          ifgtyp,ibnd,nfg,6,nneig,nhneig,nneiga,ineig,iw0,
         -          inpcrdtyp,ioins,inamcol1,inamcol2,irescol1,irescol2,
         -          iresncol1,iresncol2,line,index,maxng,maxrec)
                else if (ianaltyp .eq.  4) then
                  call bondlenstat(c,n,iatnum,nneig,ineig,iatnm2,nframe,
         -          nanos,ixlist,ialist,iw0,inpcrdtyp,ioins,inamcol1,
         -          inamcol2,irescol1,irescol2,line,index,radtodeg,
         -          maxrepconf,maxng,maxrec)
                else if (ianaltyp .eq.  5) then
    		write (77,*) 'ninconf,nframe=',ninconf,nframe,
         -            ' if,il=',ifirst,ilast
                  call hblist(c,n,nslt,islvw,naslv,iatnum,ifchrg,isegno,
         -          nneig,nneiga,nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,
         -          npneig,ixres,nframe,hbf0,angm0,molresflag,hblimfac,
         -          angmin,iw0,inamcol1,inamcol2,irescol1,irescol2,
         -          iresncol1,iresncol2,blankline,line,index,indexn,ibnd,
         -          indexo,isolvent,ibondprint,1,nosameseg,nframe,
         -          radtodeg,maxrepconf,maxng,maxbox,maxrsd,maxrec)
                  if (ifailbond .eq. 0) then
                    call selectbond(ixres,nanchor,ianchor,indexa,ianchor2,
         -            iselfanc,iqfsel2,nhbneig,ineig,nbfound,nbresfound,
         -            nmc,nhbdist,rhbdist,'hydrogen',8,ianc_anc,nosameseg,
         -            isegno,c,it1,it2,nbonds,ifailbond,iw0,maxng,maxrec,
         -            mxbonds)
                    if (maxbondf .lt. nbonds) then
                      maxbondf=nbonds
                      nmcmaxbond=nframe
                    end if
                  else
                    go to 9005
                  end if
                else if (ianaltyp .eq.  6 .or. ianaltyp .eq. 34) then
                  call nnlisthph_sltb(nslt,ianchor2,iselfanc,indexa,
         -          nneig, npneig,nhbneig,ineig,c,rhphmax,0,isegno,
         -          nosameseg,bondlab(ibondtype),4,ibnd,indexo,ifail,
         -          maxng,maxng,maxrec)
                  if (ihphprint .eq. 1)
         -          call hph_sltblist(ibondtype,c,nslt,nhbneig,ineig,iw0,
         -            is1,is2,inamcol1,inamcol2,irescol1,irescol2,
         -            iresncol1,iresncol2,line,index,bondname,lbondname,
         -            bondlab(ibondtype),4,maxng)
                  if (ifailbond .eq. 0) then
                    call selectbond(ixres,nanchor,ianchor,indexa,ianchor2,
         -            iselfanc,0,nhbneig,ineig,nbfound,nbresfound,nmc,
         -            nhbdist,rhbdist,'hydrophobic',11,ianc_anc,nosameseg,
         -            isegno,c,it1,it2,nbonds,ifailbond,iw0,maxng,maxrec,
         -            mxbonds)
                    if (maxbondf .lt. nbonds) then
                      maxbondf=nbonds
                      nmcmaxbond=nframe
                    end if
                  else
                    go to 9005
                  end if
              else if (ianaltyp .eq. 41) then
                call nnlistmpx(n,nanchorr,nanchorn,indexa,indexov,iatnum,
         -        nneig,nhbneig,c,isegno,ibnd,indexo,rmpxlim,itemp1,itemp2,
         -        itemp3,itemp4,indexn,temp,cv,ifail,maxng,maxrec)
                call mpxblist(n,itemp1,itemp2,cv,itemp3,itemp4,is1,is2,
         -        inamcol1,inamcol2,irescol1,irescol2,iresncol1,iresncol2,
         -        line,index,ixres,nhbdist,rhbdist,nbfound,nbresfound,
         -        nbonds,c,rmpxlim,ifailbond,iw0,MAXBONDS,maxrec)
                  if (maxbondf .lt. nbonds) then
                    maxbondf=nbonds
                    nmcmaxbond=nframe
                  end if
                  if (ifailbond .gt. 0) go to 9005
                else if (ianaltyp .eq.  7) then
                  call nnlisthph_sltb(nslt,ianchor2,iselfanc,indexa,
         -          nneig,npneig,nhbneig,ineig,c,rsltbmax,1,isegno,
         -          nosameseg,bondlab(ibondtype),4,ibnd,indexo,ifail,
         -          maxng,maxng,maxrec)
                  if (ibondprint .eq. 1)
         -          call hph_sltblist(ibondtype,c,nslt,nhbneig,ineig,iw0,
         -            is1,is2,inamcol1,inamcol2,irescol1,irescol2,
         -            iresncol1,iresncol2,line,index,bondname,lbondname,
         -            bondlab(3),4,maxng)
                  if (ifailbond .eq. 0) then
                    call selectbond(ixres,nanchor,ianchor,indexa,ianchor2,
         -            iselfanc,0,nhbneig,ineig,nbfound,nbresfound,nmc,
         -            nhbdist,rhbdist,'salt-bridge',11,ianc_anc,nosameseg,
         -            isegno,c,it1,it2,nbonds,ifailbond,iw0,maxng,maxrec,
         -            mxbonds)
                    if (maxbondf .lt. nbonds) then
                      maxbondf=nbonds
                      nmcmaxbond=nframe
                    end if
                  else
                    go to 9005
                  end if
                else if (ianaltyp .eq.  8) then
                  call rrdist(c,n,nres,ixresno,iresno,ixres,resnames,ifres,
         -          ilres,increst,incsolvrr,irefres1,irefres2,irefseg1,
         -          irefseg2,irefresinc,resdistlim,inegres1,inegres2,
         -          inegseg1,inegseg2,inegresinc,resapplim,listrefres,
         -          nrefres,nrefrange,listnegres,nnegres,nnegrange,iatnum,
         -          ignoreh,nframe,itypavg,iw0,iw1,iw2,irescol1,irescol2,
         -          inamcol1,inamcol2,is1,is2,irescount1,irescount2,
         -          irescount3,line,index,indexn,indexo,indexs,indexa,
         -          itemp1,itemp2,temp,cv,maxrec,maxrsd)
                else if (ianaltyp .eq.  9) then
                  if (ifirstref .eq. 0) then
                    if (nframe .gt. 1) then
                      call pbcdist(caprev1,c(1,ia1),ia1,ia2,cell,ncell,-iw0,
         -              nframe,img,drincr,dimg)
                      if (img .gt. 1) then
                        call arrsum(drimg,cell(1,img),drimg,3)
                      end if
                      call pbcdist(caprev2,c(1,ia2),ia1,ia2,cell,ncell,-iw0,
         -              nframe,img,drincr,dimg)
                      if (img .gt. 1) then
                        call arrdiff(drimg,cell(1,img),drimg,3)
                      end if
                    end if
                    call trnsfr(caprev1,c(1,ia1),3)
                    call trnsfr(caprev2,c(1,ia2),3)
                    call arrdiff(c(1,ia2),c(1,ia1),dr,3)
                    call arrsum(dr,drimg,dr,3)
                    d=sqrt(scprod(dr,dr))
                    write (iw0,2049) nframe,
         -            ia1,(c(k,ia1),k=1,3),ia2,(c(k,ia2),k=1,3)
                  else
                    if (nframe .gt. 1) then
                      call pbcdist(caprev2,c(1,ia2),ia1,ia2,cell,ncell,-iw0,
         -              nframe,img,drincr,dimg)
                      if (img .gt. 1) then
                        call arrdiff(drimg,cell(1,img),drimg,3)
                      end if
                    end if
                    call trnsfr(caprev2,c(1,ia2),3)
                    call arrdiff(c(1,ia2),caref,dr,3)
                    call arrsum(dr,drimg,dr,3)
                    dd=scprod(dr,dr)
                    d=sqrt(dd)
                    write (iw0,2048) nframe,ia2,(c(k,ia2),k=1,3)
                  end if
                  write (iw0,2054) nframe,d,dd,dr
                  call trajlimtest(nframe,MAXFRAMES)
                  res(1,nframe,1)=d
                  res(2,nframe,1)=dr(idax)
                  res(1,nframe,2)=dr(indexax(2))
                  res(2,nframe,2)=dr(indexax(3))
                  res(1,nframe,3)=dd
                else if (ianaltyp .eq. 10) then
                  call checkunphys(c,nslt,n,naslv,islvw,iatnum,ifchrg,
         -          isegno,idelseg,indexo,nneig,nneiga,nhbneig,ineig,nhneig,
         -          nnneig,ncneig,nsneig,npneig,ixres,line,irescol1,
         -          irescol2,inamcol1,inamcol2,index,nframe,innlist,
         -          molresflag,ioppbc,cell,ncell,edge,ixyzhex,molsltlim,
         -          nmolslt,hblimfac,angmin,ctfac,bondminfac,maxdist,iles,
         -          iw0,isltonly,ibnd,indexn,rlim,innlistread,nframe,
         -          radtodeg,nerrunphys,maxrepconf,maxng,maxbox,maxrsd,
         -          maxrec)
                else if (ianaltyp .eq. 11) then
                  call pseudorot(c,n,ix5,nmem,nneig,ineig,psr5,psr,npsr,
         -          psrtyp,incgen,zring,rring,sinpsrs,cospsrs,qpsr,qpsrs,
         -          qpsr2s,zav,zsq,zavs,zsqs,1,iw0,nframe,radtodeg,maxng,
         -          maxrec)
                else if (ianaltyp .eq. 12) then
                  if (nframe .gt. maxframe) then
                    write (6,2074) maxframe,'structures',' '
                    go to 8002
                  end if
                  call prokinkcalcla(nrep,c,nslt,bend,wobble,
         -          faceshift,rmsb,rmsa,
         -          iflatproline,ix5,radtodeg,MAXHX)
                  call pseudorot(c,n,ix5,nmem,nneig,ineig,psr5,psr,npsr,
         -          'p',incgen,zring,rring,sinpsrs,cospsrs,qpsr,qpsrs,
         -          qpsr2s,zav,zsq,zavs,zsqs,0,6,nframe,radtodeg,maxng,
         -          maxrec)
                  if (nrep .eq. 1) call savekinkdat(nmem,bend,wobble,
         -          faceshift,psr(2),radtodeg)
                  if (nrep .le. 1) write (iw0,2072) ninconf,bend,wobble,
         -          faceshift,wobble-faceshift,psr(2),rmsb,rmsa
                else if (ianaltyp .eq. 13) then
                  call hydropathylist(n,nslt,ixres,resnames,cv,ihydtyp,
         -          maxrsd,maxrec)
                  call writeconf(iw0,inpcrdtyp,inpcrdtyp,inpcrdtyporg,n,n,
         -          nslt,naslv,islvw,iasv,namesv,qsv,pflsv,1,iwhead,0,
         -          iatnum,ifchrg,nframe,innlist,c,rprox,cv,ixres,iresno,
         -          atnames,resnames,segnames,charge,isegno,altcol,inscol,
         -          ninsres,marker,ntitlin,ntitlinw,title,ireseq,
         -          iresnrestart,iresidrestart,nneig,nneiga,nhbneig,ineig,
         -          nhneig,nnneig,ncneig,nsneig,npneig,numres,numslv,
         -          resnamslv,line,blankline,mmtype,ibnd,index,indexn,
         -          indexo,2,molresflag,irescount3,itemp1,hblimfac,angmin,0,
         -          1,1,1,0,1,iqspaceask,13,1,0.0,0,0,0,keeprem,iwriteatsym,
         -          radtodeg,maxrepconf,maxng,maxrsd,maxrec)
                else if (ianaltyp .eq. 14) then
                  call cvlist(c,n,nslt,nsltref_f,nsltref_l,naslv,islvrep,
         -          icvtyp,rcut_cv,rprox,cv,itemp1,c2,temp,indexn,indexo,
         -          indexs,chn,isortslv,cvlim)
                  call writeconf(iw0,inpcrdtyp,inpcrdtyp,inpcrdtyporg,n,n,
         -          nslt,naslv,islvw,iasv,namesv,qsv,pflsv,1,iwhead,0,
         -          iatnum,ifchrg,nframe,innlist,c,rprox,cv,ixres,iresno,
         -          atnames,resnames,segnames,charge,isegno,altcol,inscol,
         -          ninsres,marker,ntitlin,ntitlinw,title,ireseq,
         -          iresnrestart,iresidrestart,nneig,nneiga,nhbneig,ineig,
         -          nhneig,nnneig,ncneig,nsneig,npneig,numres,numslv,
         -          resnamslv,line,blankline,mmtype,ibnd,index,indexn,
         -          indexo,1,molresflag,irescount3,itemp1,hblimfac,angmin,0,
         -          1,1,1,0,3,iqspaceask,14,1,0.0,0,0,0,keeprem,iwriteatsym,
         -          radtodeg,maxrepconf,maxng,maxrsd,maxrec)
                else if (ianaltyp .eq. 16) then
                  call dssp(c,1,n,nslt,line,index,inamcol1,inamcol2,
         -          iresncol1,iresncol2,nneig,ineig,nneiga,ibnd,indexn,
         -          indexo,npneig,nsneig,nnneig,dssplab,idistdssp,chn,c2,cv,
         -          indexs,indexa,nsse,itypsse,ifsse,ilsse,0,nframe,iw0,
         -          iwrose,nframe,ifail,dtodeg,maxrepconf,maxng*10,
         -          maxrec/10,maxng*20,maxrec/20,200,maxrsd,maxrec)
                  if (ifail .gt. 0) go to 8002
                  call plotdssp(iw1,ifsse,ilsse,itypsse,nsse,ninconf,
         -          maxtrajplot,framefac,ndivdssp,10,title(1:76),76,
         -          xtrajlab,11,'N(res)',6,nframe,ifrdssp,ilrdssp,indexdel)
                else if (ianaltyp .eq. 17) then
                  call hblist(c,n,nslt,islvw,naslv,iatnum,ifchrg,isegno,
         -          nneig,nneiga,nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,
         -          npneig,ixres,nframe,hbf0,angm0,molresflag,hblimfac,
         -          angmin,iw0,inamcol1,inamcol2,irescol1,irescol2,
         -          iresncol1,iresncol2,blankline,line,index,indexn,ibnd,
         -          indexo,1,0,1,nosameseg,nframe,radtodeg,
         -          maxrepconf,maxng,maxbox,maxrsd,maxrec)
                  call hbbridge(nanchor,ianchor,indexa,ianchor2,iselfanc,
         -          lpath,nbridgetype,ibridgetype,maxbridgemem,n,nhbneig,
         -          ineig,indexn,indexo,indexs,ixres,resnames,brslv,nabr,
         -          nrescol,nmc,ifailhbr,listbridge,iw0,maxng,MAXBRIDGELEN,
         -          MAXBRIDGETYPE,minbridgelenprint,maxrsd,maxrec)
                  if (ifailhbr .eq. 1) go to 8002
                else if (ianaltyp .eq. 18) then
                  call ramachandran(c,nslt,index,line,nframe,pi,nresfound,
         -          iresno,ixres,irescol1,irescol2,inamcol1,iw0,
         -          maxng,maxrec)
                  call ramachandranplot(nresfound,iw1,xm,iallrama)
                else if (ianaltyp .eq. 19) then
                call torsiondials(c,nslt,ntorsel,ixtor1234,index,line,pi,
         -        irescol1,irescol2,inamcol1,inamcol2,iw0,maxrec)
                else if (ianaltyp .eq. 20) then
                  call delphilabel(c,n,nslt,xstart,ystart,zstart,gx,gy,gz,
         -          cv)
                  call writeconf(iw0,inpcrdtyp,inpcrdtyp,inpcrdtyporg,n,n,
         -          nslt,naslv,islvw,iasv,namesv,qsv,pflsv,1,iwhead,0,
         -          iatnum,ifchrg,nframe,innlist,c,rprox,cv,ixres,iresno,
         -          atnames,resnames,segnames,charge,isegno,altcol,inscol,
         -          ninsres,marker,ntitlin,ntitlinw,title,ireseq,
         -          iresnrestart,iresidrestart,nneig,nneiga,nhbneig,ineig,
         -          nhneig,nnneig,ncneig,nsneig,npneig,numres,numslv,
         -          resnamslv,line,blankline,mmtype,ibnd,index,indexn,
         -          indexo,1,molresflag,irescount3,itemp1,hblimfac,angmin,0,
         -          1,1,1,0,0,iqspaceask,20,1,0.0,0,0,0,keeprem,iwriteatsym,
         -          radtodeg,maxrepconf,maxng,maxrsd,maxrec)
                else if (ianaltyp .eq. 21) then
                  if (nframe .eq. 1) then
                    do ihx=1,nhx
                      iadssp1=ifres(ixres(icaahx(1,ihx)))
                      iadssp2=ilres(ixres(icaahx(nreshx(ihx),ihx)))
                      call dssp(cres,iadssp1,n,iadssp2,line,index,
         -              inamcol1,inamcol2,iresncol1,iresncol2,nneig,ineig,
         -              nneiga,ibnd,indexn,indexo,npneig,nsneig,nnneig,
         -              dssplab,idistdssp,chn,c2,cv,indexs,indexa,nsse,
         -              itypsse,ifsse,ilsse,ireshx1(ihx)-1,nframe,0,0,0,
         -              ifail,radtodeg,maxrepconf,maxng*10,maxrec/10,
         -              maxng*20,maxrec/20,200,maxrsd,maxrec)
                      lhelixcklab=9+11
                      write (helixcklab,2160) 'Reference h',ihx
                      call checkforhelix(ireshx2(ihx)-ireshx1(ihx)+1,
         -              dssplab,indexn,6,hxoklab,ihxok,helixcklab,
         -              lhelixcklab,maxrsd,maxrec)
                    end do
                  end if
                  if (nrep .eq. 1)
         -          call soluteoverlay(isubcrm,ioverlay,nslt,nsegslt,c,cres,
         -            chn,c2,crmslt0,crmslt,atw,temp,cv,rprox,molsltlim,
         -            indexs,idebughx,iw0,maxrsd,maxrec)
                  do ihx=1,nhx
                    call helixcomp(nslt,nreshx(ihx),calph0(1,1,ihx),
         -            axisdir0(1,ihx),perpvec0(1,1,ihx),axisini0(1,ihx),
         -            axisend0(1,ihx),helixcent0(1,ihx),rn0(1,ihx),
         -            camod(1,1,ihx),axfact,calph(1,1,ihx),axisdir(1,ihx),
         -            perpvec(1,1,ihx),axisini(1,ihx),axisend(1,ihx),
         -            helixcent(1,ihx),anglechange(1,ihx),
         -            anglechangeref(1,ihx),axtol,iw0,torsion,
         -            rotation,nrep,indexaxhx(1,ihx),incrot,ireorienthx,
         -            idebughx,radtodeg,pi,c2,nreshx(ihx),icaahx(1,ihx),ihx,
         -            nhxres,MAXHX,maxrec)
                    if (idsspcheck .eq. 1) then
                      iadssp1=ifres(ixres(icaahx(1,ihx)))
                      iadssp2=ilres(ixres(icaahx(nreshx(ihx),ihx)))
                      call dssp(c,iadssp1,n,iadssp2,line,index,inamcol1,
         -              inamcol2,iresncol1,iresncol2,nneig,ineig,nneiga,
         -              ibnd,indexn,indexo,npneig,nsneig,nnneig,dssplab,
         -              idistdssp,chn,c2,cv,indexs,indexa,nsse,itypsse,
         -              ifsse,ilsse,ireshx1(ihx)-1,nframe,0,0,0,ifail,
         -              radtodeg,maxrepconf,maxng*10,maxrec/10,maxng*20,
         -              maxrec/20,200,maxrsd,maxrec)
                      lhelixcklab=9+1
                      write (helixcklab,2160) 'H',ihx
                      call checkforhelix(ireshx2(ihx)-ireshx1(ihx)+1,
         -              dssplab,indexn,iw0,hxoklab,ihxok,helixcklab,
         -              lhelixcklab,maxrsd,maxrec)
                      nhelixok(ihxok)=nhelixok(ihxok)+1
                    end if
                  end do
                  if (nhx .gt. 1) call multihelix(iw0,nhx,nhxres,radtodeg,c,
         -          icaahx,icbahx,icbreshx,maxrec,MAXHX,MAXNHX)
                else if (ianaltyp .eq. 22) then
                  if (nframe .eq. 1 .and. inputref .eq. 0)
         -          call trnsfr(cres,c,3*nslt)
                  nframeref=0
                  call rmsd(cres,c,nslt,nfinalov,nfinalrmsd,atw,atwsum,temp,
         -          chn,c2,indexov,indexov,0,1,indexrmsd,indexrmsd,rot,com1,
         -          com2,etot,etot2,iw0,devmax,devmaxnoopt,maxrec)
                  do ia=1,nfinalrmsd
                    do k=1,3
                      cdp(k,ia)=cdp(k,ia)+c2(k,indexrmsd(ia))
                      cdp2(k,ia)=cdp2(k,ia)+c2(k,indexrmsd(ia))**2
                    end do
                  end do
                  if (nresslt .le. MAXDISTR .and. nocontigrmsd .eq. 0) then
                    call rmsf(chn,c2,atw,nfinalrmsd,ixres,indexrmsd,
         -            rmsfsum,nresslt,nslt)
                    if (mod(nframe,nerr_int) .eq. 0 .or.
         -              nframe .eq. maxconf) then
                      ns=nframe/nerr_int
                      nframes_err(ns)=nframe
                      do ir=1,nresslt
                        distrerr(ns,ir)=rmsfsum(ir)
                      end do
                    end if
                  end if
                else if (ianaltyp .eq. 25) then
                  call residcorr(c,c,nslt,indexa,ncorr,nframe)
                else if (ianaltyp .eq. 26) then
                  if (iclusterdist .eq. 0) then
                    call pairdistcalc(c,nslt,npairs,listpairdist,
         -            pairdistsum,pairdistsum2,pairdistwsum,npairdist,
         -            pairdistminmax,pairgrid,iw0,MAXDDBIN,MAXDDISTR)
                  else
                    call clusterdistcalc(c,nslt,npairs,iclustermem,
         -            ifstclst1,ifstclst2,ilstclst2,pairdistsum,
         -            pairdistsum2,pairdistwsum,npairdist,pairdistminmax,
         -            pairgrid,iw0,MAXDDBIN,MAXDDISTR,MAXCDLIST)
                  end if
                else if (ianaltyp .eq. 27) then
                  call volcalc(nrand,c,nslt,isegno,iatnum,nsegslt,molsltlim,
         -          itemp1,cres,chn,c2,atw,vmac,vshell,vint,vmacsd,vshellsd,
         -          vintsd,vfrstsh,vfrstshsd,rsolv,ih,indexn,indexo,indexs,
         -          indexa,indexdel,nframe,iw0,levout,maxrsd,maxrec)
                  call trajlimtest(nframe,MAXFRAMES)
                  res(1,nframe,1)=vshell
                  res(2,nframe,1)=vfrstsh
                  res(1,nframe,2)=vmac
                  res(2,nframe,2)=vint
                  res(1,nframe,3)=vshellsd
                  res(2,nframe,3)=vfrstshsd
                  res(1,nframe,4)=vmacsd
                  res(2,nframe,4)=vintsd
                else if (ianaltyp .eq. 28) then
                  if (nframe .eq. 1 .and. inputref .eq. 1)
         -          call princax(cres,c2,atw,temp,n,indexdel,evecs0,evals0,
         -            iw0,inputref,1,radtodeg,0)
                  call princax(c,c2,atw,temp,n,indexdel,evecs0,evals0,iw0,
         -          inputref,0,radtodeg,0)
                else if (ianaltyp .eq. 29) then
                  call molrad(c,indexa,ngyrats,iw0,MAXREC)
                  call celldipole(c,n,nslt,indexa,ngyrats,charge,icharges,
         -          atw,iw0,1)
                else if (ianaltyp .eq. 32) then
                  call angledials(c,nslt,nangsel,ixtor1234,index,line,pi,
         -          irescol1,irescol2,inamcol1,inamcol2,iw0,maxrec)
                else if (ianaltyp .eq.  33) then
                    call mmdist(c,n,atw,iatnum,nmolslt,molsltlim,c2,temp,
         -            ignoreh,iw0,iw1)
                else if (ianaltyp .eq. 39) then
                  call atomdist_sd(c,nslt,ianchor,nanchor,nframe)
                else if (ianaltyp .eq. 40) then
                  if (ifilttyp .eq. 5)
         -          call nnlist(n,islvw,naslv,n,iatnum,ifchrg,c,nneig,
         -          nneiga,nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,
         -          npneig,line,irescol1,irescol2,inamcol1,inamcol2,index,
         -          nconfig,innlist,molresflag,hblimfac,angmin,ihbondcalc,
         -          ibnd,indexo,isegno,ixres,maxrepconf,0,nframe,radtodeg,
         -          0,maxbox,maxng,maxrsd,maxrec)
                  call filterslv(c,iatnum,nslt,n,naslv,numsolv,molsltlim,
         -          nsegslt,index,nframe,ifilttyp,intftyp,rsltmax,rcvmax,
         -          cvmin,ang12min1,ang12min2,r12max,cvrlim,rneigh,mol11,
         -          mol12,mol21,mol22,spacing,itemp1,iarepslv,numsolvleft,
         -          nhbneig,ineig,ixres,nrecdel,ierr,iw0,maxrec,maxng)
                  numsolvsum=numsolvsum+numsolvleft
                  if (numsolvmin .gt. numsolvleft) numsolvmin=numsolvleft
                  if (numsolvmax .lt. numsolvleft) numsolvmax=numsolvleft
                  if (numsolvleft .gt. 0) then
                    namleno=namlen_root
                    if (nframe .gt. 1 .and. ionefile .eq. 0) then
                      namleno=namlen_root+1
                      analfile(namleno:namleno)='.'
                      namleno=namleno+1
                      call writeint(analfile,namleno,nframe,lenc)
                      namleno=namleno-1
                    end if
                    if (nframe .eq. 1 .or. ionefile .eq. 0) then
                      analfile1(namleno+1:namleno+lenext)=crdexti(1:lenext)
                      namleno=namleno+lenext
                      call openfile(45,0,'FILT',4,'new',analfile1,namleno,
         -              notfnd,0,1,1,0,0)
                    end if
                    call writeout(45,inpcrdtyp,inpcrdtyp,line,index,isegno,
         -            n-nrecdel,marker,1,0,ntitlin,ntitlinw,title,
         -            blankline,1,1,0,0.0,0,0,0,keeprem,iwriteatsym,iatnum,
         -            maxrec)
                    if (ionefile .eq. 0) close (45)
                  else
                    write (6,2070) nframe
                  end if
                end if
                if (nframetot .gt. nframetotmin) then
                  if (nframesign .gt. 0) then
                    call progress_rep(nframe,nframe2d,nframesign)
                  else
                    nframetot=(ilast-ifirst+1)/increment
                    nframesign=nframetot/10
                  end if
                end if
              end if
              if ((ninconf-ifirst)/increment .gt. 2) iprintpk=0
              ifirstscan=0
            end do
    8002    close (inpt)
            nmw=0
            if (iw0 .gt. 0) then
              write (iw0,2085)
              write (iw0,2020) trajnam(:ltrajnam),nframeread,nframe,' ',
         -      ifirst-1
              if (ianaltyp .eq. 24) write (iw0,2065) nframeref
            end if
          end if
    8006  if (itraj .eq. 1) then
            call testconst(0,1,2,0.0,1.0,2.0,6,nfail,1,'ANPO')
            if (ntitlin .eq. 0 .and. ltitle .eq. 0) then
              title=trtitle(1)
            end if
            if (iw2 .gt. 0 .and. ianaltyp .ne. 22) then
              if (analfile2(namleno2-2:namleno2) .ne. '.ps ')
         -      write (iw2,2085)
            end if
            if (ianaltyp .eq. 12) then
              write (title,2069) irespro,nra,nrb
              call dialps(iw1,prokinklab,lprokinklab,title,ltitle,resrange,
         -      22,5,ndials,ndprow,nframe,pi,ipspage,0,nfravgd,0,0,0,
         -      iconndial,ioutpr,mappdf,ipdfgrd)
              write (6,2073) analfile1(1:namleno1)
              call trajstat(iw0,ndials,5,prokinklab,lprokinklab,0,1,0,
         -      rmsdlab,lrmsdlab,corr12,0,0,0,' ',1,radtodeg)
            else if (ianaltyp .eq.  9 .or. ianaltyp .eq. 19 .or.
         -           ianaltyp .eq. 21 .or. ianaltyp .eq. 22 .or.
         -           ianaltyp .eq. 23 .or. ianaltyp .eq. 24 .or.
         -           ianaltyp .eq. 26 .or. ianaltyp .eq. 27 .or.
         -           ianaltyp .eq. 28 .or. ianaltyp .eq. 29 .or.
         -           ianaltyp .eq. 32 .or. ianaltyp .eq. 39) then
              if (ianaltyp .eq. 9) then
                irhx0=3+indexax(1)
                irhx1=3+indexax(2)
                irhx2=3+indexax(3)
                call arminmax2(res(1,1,1),1,nframe,2,armin1,armax1,
         -        armin2,armax2,0,2)
                call roundlim(armax1,y1div,ny1div)
                call plot2fun(iw1,2,xtraj,res(1,1,1),res(1,1,1),nframe,
         -        0.0,0.0,0,0.0,y1div,ny1div, 0.0,y2div,ny2div,title,80,
         -        atomdist,22,xtrajlab,11 ,'D',1,helixrlab(irhx0),
         -        lhelixrlab(irhx0),1,0,6,2,1,0,1,0,0,
         -        ipspage,1,1,0)
                call arminmax2(res(1,1,3),1,nframe,1,armin1,armax1,
         -        armin2,armax2,0,2)
                call roundlim(armax1,y1div,ny1div)
                call plot2fun(iw1,1,xtraj,res(1,1,3),res(1,1,3),nframe,
         -        0.0,0.0,0,0.0,y1div,ny1div, 0.0,y2div,ny2div,title,80,
         -        atomdist,22,xtrajlab,11 ,'D^2',3,
         -        'Total displacement square',25,1,0,6,
         -        2,1,0,1,0,0,ipspage,1,1,0)
                call arminmax2(res(1,1,2),1,nframe,2,armin1,armax1,
         -        armin2,armax2,0,2)
                ix=4.0*armin1
                if (armin1 .lt. 0.0) ix=ix-1
                xmn=float(ix)/4.0
                call roundlim(armax1-xmn,xdv,nxdv)
                iy=4.0*armin2
                if (armin2 .lt. 0.0) iy=iy-1
                ymn=float(iy)/4.0
                call roundlim(armax2-ymn,ydv,nydv)
                call plot2fun(iw1,2,xtraj,res(1,1,2),res(1,1,2),nframe,
         -        0.0,0.0,00,xmn,xdv,nxdv,ymn,ydv,nydv,title,80,atomdist,22,
         -        xtrajlab,11 ,helixrlab(irhx1),lhelixrlab(irhx1),
         -        helixrlab(irhx2),lhelixrlab(irhx2),1,
         -        0,6,2,1,0,1,0,0,ipspage,1,1,0)
                plotdescr='Progression of distance vector projected to the '
                plotdescr=plotdescr(1:48)//xyz(indexax(2))//'-'
                plotdescr=plotdescr(1:50)//xyz(indexax(3))//' plane'
                call plot2d(iw1,res(1,1,2),nframe,nfravgt,xmn,xdv,nxdv,
         -        ymn,ydv,nydv,title,80,plotdescr,56,atomdist,22,
         -        xyz(1),1,xyz(2),1,xtrajlab,11,0,0,6,1,ipspage,0,MAXFRAMES)
              else if (ianaltyp .eq. 21) then
                noopen=0
                noclose=1
                now6=0
                lresrange=22
                if (nhx .gt. 1) then
                  now6=1
                  lresrange=29
                end if
                do ihx=1,nhx
                  write (resrange(1:22),2087) ireshx1(ihx),ireshx2(ihx)
                  shiftlab(20:20)=axdirchar(ihx)
                  if (nhx .gt. 1) write (resrange(23:29),2163) ihx
                  incrhx=(ihx-1)*nhxres
                  call dialps(iw1,helixang,lhelixang,title,ltitle,resrange,
         -          lresrange,5,ndials,ndprow,nframe,pi,ipspage,9,nfravgd,
         -          incrhx,noopen,1,iconndial,ioutpr,mappdf,ipdfgrd)
                  noopen=1
                  if (idsspcheck .gt. 0) then
                    write (6,*)
                    write (iw0,*)
                    do k=1,3
                      if (nhx .eq. 1) write (6,2089) hxoklab(k),nhelixok(k)
                      write (iw0,2089) hxoklab(k),nhelixok(k)
                    end do
                  end if
                  do k=1,3
                    printrlab(k)=helixrlab(k)
                    lprintrlab(k)=lhelixrlab(k)
                  end do
                  printrlab(4)=helixrlab(3+indexaxhx(1,ihx))
                  lprintrlab(4)=lhelixrlab(3+indexaxhx(1,ihx))
                  do k=1,2
                    printrlab(4+k)=helixrlab(3+indexaxhx(k+1,ihx))
                    lprintrlab(4+k)=lhelixrlab(3+indexaxhx(k+1,ihx))
                    printrlab(6+k)=helixrlab(8+indexaxhx(k+1,ihx))
                    lprintrlab(6+k)=lhelixrlab(8+indexaxhx(k+1,ihx))
                    printrlab(8+k)=helixrlab(11+indexaxhx(k+1,ihx))
                    lprintrlab(8+k)=lhelixrlab(11+indexaxhx(k+1,ihx))
                  end do
                  write (iw0,2172) ihx
                  call trajstat(iw0,ndials,6,helixang,lhelixang,10,10,7,
         -          printrlab,lprintrlab,corr12,incrhx,itorcorr,now6,' ',1,
         -          radtodeg)
                  call arminmax2(res(1,1,incrhx+7),1,nframe,2,armin1,armax1,
         -          armin2,armax2,0,2)
                  iy1=armin1
                  y1mn=iy1
                  id1=armax1-iy1+1
                  if (mod(id1-iy1,2) .eq. 1 .or. id1. eq. 0) id1=id1+1
                  y1div=float(id1)/10.0
                  iy2=armin2
                  if (armin2 .lt. 0.0) iy2=iy2-1
                  y2mn=iy2
                  call roundlim(armax2-y2mn,y2div,ny2div)
                  call plot2fun(iw1,2,xtraj,res(1,1,incrhx+7),
         -          res(1,1,incrhx+7),nframe,0.0,0.0,00,y1mn,y1div,10,y2mn,
         -          y2div,ny2div,title,80,resrange,lresrange,xtrajlab,11,
         -          'Helix length',12,'Radius of fitted circle',23,1,
         -          0,6,2,1,0,1,0,0,ipspage,1,1,0)
                  call arminmax2(res(1,1,incrhx+8),1,nframe,2,armin1,armax1,
         -          armin2,armax2,0,2)
                  iy1=armin1
                  y1mn=iy1
                  call roundlim(armax1-y1mn,y1div,ny1div)
                  iy2=4.0*armin2
                  if (armin2 .lt. 0.0) iy2=iy2-1
                  y2mn=float(iy2)/4.0
                  call roundlim(armax2-y2mn,y2div,ny2div)
                  call plot2fun(iw1,2,xtraj,res(1,1,incrhx+8),
         -          res(1,1,incrhx+8),nframe,0.0,0.0,00,y1mn,y1div,ny1div,
         -          y2mn,y2div,ny2div,title,80,resrange,lresrange,xtrajlab,
         -          11,'Total helix displacement',24,shiftlab,30,1,
         -          0,6,2,1,0,1,0,0,ipspage,1,1,0)
                  irhx1=3+indexaxhx(2,ihx)
                  irhx2=3+indexaxhx(3,ihx)
                  call arminmax2(res(1,1,incrhx+9),1,nframe,2,armin1,armax1,
         -          armin2,armax2,0,2)
                  ix=4.0*armin1
                  if (armin1 .lt. 0.0) ix=ix-1
                  xmn=float(ix)/4.0
                  call roundlim(armax1-xmn,xdv,nxdv)
                  iy=4.0*armin2
                  if (armin2 .lt. 0.0) iy=iy-1
                  ymn=float(iy)/4.0
                  call roundlim(armax2-ymn,ydv,nydv)
                  call plot2fun(iw1,2,xtraj,res(1,1,incrhx+9),
         -          res(1,1,incrhx+9),nframe,0.0,0.0,00,xmn,xdv,nxdv,ymn,
         -          ydv,nydv,title,80,resrange,lresrange,xtrajlab,11,
         -          helixrlab(irhx1),lhelixrlab(irhx1),helixrlab(irhx2),
         -          lhelixrlab(irhx2),1,0,6,2,1,0,1,0,0,
         -          ipspage,1,1,0)
                  plotdescr='Helix center track in the '//
         -          xyz(indexaxhx(2,ihx))//'-'
                  plotdescr=plotdescr(1:28)//xyz(indexaxhx(3,ihx))//' plane'
                  call plot2d(iw1,res(1,1,incrhx+9),nframe,nfravgt,xmn,
         -          xdv,nxdv,ymn,ydv,nydv,title,ltitle,plotdescr,35,
         -          resrange,lresrange,xyz(indexaxhx(2,ihx)),1,
         -          xyz(indexaxhx(3,ihx)),1,xtrajlab,11,0,0,6,0,ipspage,1,
         -          MAXFRAMES)
                  irhx1=8+indexaxhx(2,ihx)
                  irhx2=8+indexaxhx(3,ihx)
                  call arminmax2(res(1,1,incrhx+10),1,nframe,2,armin1,
         -          armax1,armin2,armax2,0,2)
                  ix=4.0*armin1
                  if (armin1 .lt. 0.0) ix=ix-1
                  xmn=float(ix)/4.0
                  call roundlim(armax1-xmn,xdv,nxdv)
                  iy=4.0*armin2
                  if (armin2 .lt. 0.0) iy=iy-1
                  ymn=float(iy)/4.0
                  call roundlim(armax2-ymn,ydv,nydv)
                  call plot2fun(iw1,2,xtraj,res(1,1,incrhx+10),
         -          res(1,1,incrhx+10),nframe,0.0,0.0,00,xmn,xdv,nxdv,ymn,
         -          ydv,nydv,title,80,resrange,lresrange,xtrajlab,11,
         -          helixrlab(irhx1),lhelixrlab(irhx1),helixrlab(irhx2),
         -          lhelixrlab(irhx2),1,0,6,2,1,0,1,0,0,
         -          ipspage,1,1,0)
                  plotdescr(7:12)='start '
                  call plot2d(iw1,res(1,1,incrhx+10),nframe,nfravgt,
         -          xmn,xdv,nxdv,ymn,ydv,nydv,title,ltitle,plotdescr,35,
         -          resrange,lresrange,xyz(indexaxhx(2,ihx)),1,
         -          xyz(indexaxhx(3,ihx)),1,xtrajlab,11,0,0,6,0,ipspage,1,
         -          MAXFRAMES)
                  irhx1=11+indexaxhx(2,ihx)
                  irhx2=11+indexaxhx(3,ihx)
                  call arminmax2(res(1,1,incrhx+11),1,nframe,2,armin1,
         -          armax1,armin2,armax2,0,2)
                  ix=4.0*armin1
                  if (armin1 .lt. 0.0) ix=ix-1
                  xmn=float(ix)/4.0
                  call roundlim(armax1-xmn,xdv,nxdv)
                  iy=4.0*armin2
                  if (armin2 .lt. 0.0) iy=iy-1
                  ymn=float(iy)/4.0
                  call roundlim(armax2-ymn,ydv,nydv)
                  call plot2fun(iw1,2,xtraj,res(1,1,incrhx+11),
         -          res(1,1,incrhx+11),nframe,0.0,0.0,00,xmn,xdv,nxdv,ymn,
         -          ydv,nydv,title,80,resrange,lresrange,xtrajlab,11 ,
         -          helixrlab(irhx1),lhelixrlab(irhx1),helixrlab(irhx2),
         -          lhelixrlab(irhx2),1,0,6,2,1,0,1,0,0,
         -          ipspage,1,1,0)
                  plotdescr(7:12)=' end  '
                  call plot2d(iw1,res(1,1,incrhx+11),nframe,nfravgt,
         -          xmn,xdv,nxdv,ymn,ydv,nydv,title,ltitle,plotdescr,35,
         -          resrange,lresrange,xyz(indexaxhx(2,ihx)),1,
         -          xyz(indexaxhx(3,ihx)),1,xtrajlab,11,0,0,6,0,ipspage,1,
         -          MAXFRAMES)
                  call arminmax2(res(1,1,incrhx+12),1,nframe,2,armin1,
         -          armax1,armin2,armax2,0,2)
                  xmin=amin1(armin1,armin2,-armax1,-armax2)
                  call roundlim(-10.0*xmin,xdv,nxdv)
                  xdv=xdv/5.0
                  nxdv=nxdv/2
                  xmn=-xdv*nxdv
                  nxdv=2*nxdv
                  linein(1:lresrange)=resrange
                  linein(lresrange+1:lresrange+33)=
         -          ' Helix axis is in the X direction'
                  plotdescr='Track of the projection of the normal to the '
         -          //xyz(indexaxhx(2,ihx))//'-'//xyz(indexaxhx(3,ihx))//
         -          ' plane fitted to the helix bend'
                  call plot2d(iw1,res(1,1,incrhx+12),nframe,nfravgt,
         -          xmn,xdv,nxdv,xmn,xdv,nxdv,title,ltitle,plotdescr,79,
         -          linein,lresrange+33,xyz(1),1,xyz(2),1,xtrajlab,11,0,0,
         -          6,0,ipspage,1,MAXFRAMES)
                  do i=1,nframe
                    scp_ax=res(1,1,incrhx+13)*res(1,i,incrhx+13)+
         -            res(2,1,incrhx+13)*res(2,i,incrhx+13)+
         -            res(1,1,incrhx+14)*res(1,i,incrhx+14)
                    cv(i)=(180./3.141592)*dacoscheck(ddd,scp_ax,0,6,
         -            'HELIXAN')
                  end do
                  call arminmax2(cv,1,nframe,1,armin1,armax1,armin2,armax2,
         -          0,1)
                  iy1=armin1
                  y1mn=iy1
                  call roundlim(armax1-y1mn,y1div,ny1div)
                  iprt=0
                  call plot2fun(iw1,1,xtraj,cv,cv,nframe,0.0,0.0,00,y1mn,
         -          y1div,ny1div,y2mn,y2div,ny2div,title,80,resrange,
         -          lresrange,xtrajlab,11,
         -          'Angle between start and current axes',36,shiftlab,30,
         -          1,iprt,iw0,1,1,0,1,0,0,ipspage,noclose,1,0)
                end do
                if (nhx .gt. 1) then
                  do i=1,4
                    call blankout(printrlab(i),1,25)
                    lprintrlab(i)=25
                  end do
                  incrhx=nhx*nhxres+1
                  incrhx0=1
                  do ihx=1,nhx
                    do jhx=ihx+1,nhx
                      do i=1,nframe
                        ii=res(2,i,incrhx)
                        plotdat(1,i)=float(ii/10000)/50.0
                        plotdat(2,i)=float(mod(ii,10000))/50.0
                        call trnsfr(res(1,i,1),plotdat(1,i),2)
                      end do
                      call arminmax2(plotdat,1,nframe,2,armin1,
         -              armax1,armin2,armax2,0,2)
                      iy1=armin1
                      y1mn=iy1
                      id1=armax1-iy1+1
                      if (mod(id1-iy1,2) .eq. 1 .or. id1. eq. 0) id1=id1+1
                      y1div=float(id1)/10.0
                      iy2=armin2
                      if (armin2 .lt. 0.0) iy2=iy2-1
                      y2mn=iy2
                      call roundlim(armax2-y2mn,y2div,ny2div)
                      write (distlab,2162) ihx,jhx,'1st end-end',' ',
         -              ap_pa(isg2(incrhx0)+2)
                      write (distlab_cc,2162) ihx,jhx,'2nd end-end',' ',
         -              ap_pa(isg2(incrhx0)+2)
                      if (itmem .gt. 0 .and. memdir(ihx)+memdir(jhx) .gt. 0)
         -                then
                        distlab(11:12)=in_ex(memdir(ihx))
                        distlab_cc(11:12)=in_ex(3-memdir(ihx))
                        distlab(13:13)=' '
                        distlab_cc(13:13)=' '
                      end if
                      printrlab(1)(1:22)=distlab(11:32)
                      printrlab(2)(1:22)=distlab_cc(11:32)
                      call plot2fun(iw1,2,xtraj,plotdat,plotdat,nframe,0.0,
         -              0.0,00,y1mn,y1div,10,y2mn,y2div,ny2div,title,80,' ',
         -              1,xtrajlab,11,distlab_cc,32,distlab,32,1,0,6,2,1,0,
         -              1,0,0,ipspage,noclose,1,0)
                      do i=1,nframe
                        ii=res(1,i,incrhx)
                        plotdat(1,i)=float(ii/10000)/50.0
                        plotdat(2,i)=float(mod(ii,10000))/50.0
                        call trnsfr(res(1,i,2),plotdat(1,i),2)
                      end do
                      call arminmax2(plotdat,1,nframe,2,armin1,armax1,
         -              armin2,armax2,0,2)
                      iy1=armin1
                      y1mn=iy1
                      id1=armax1-iy1+1
                      if (mod(id1-iy1,2) .eq. 1 .or. id1. eq. 0) id1=id1+1
                      y1div=float(id1)/10.0
                      iy2=armin2
                      if (armin2 .lt. 0.0) iy2=iy2-1
                      y2mn=iy2
                      call roundlim(armax2-y2mn,y2div,ny2div)
                      write (distlab,2162) ihx,jhx,'closest'
                      write (distlab_cc,2162) ihx,jhx,'center-center'
                      printrlab(3)(1:21)=distlab(11:31)
                      printrlab(4)(1:24)=distlab_cc(11:34)
                      call plot2fun(iw1,2,xtraj,plotdat,plotdat,nframe,0.0,
         -              0.0,00,y1mn,y1div,10,y2mn,y2div,ny2div,title,80,' ',
         -              1,xtrajlab,11,distlab,31,distlab_cc,34,1,0,6,2,1,0,
         -              1,0,0,ipspage,noclose,1,0)
                      write (distlab,2174) ihx,jhx,ap_pa(isg2(incrhx0)+2)
                      call trajstat(iw0,0,1,helixang,lhelixang,4,4,
         -              1,printrlab,lprintrlab,corr12,itorcorr,1,1,distlab,
         -              15,radtodeg)
                      incrhx=incrhx+1
                      incrhx0=incrhx0+1
                    end do
                  end do
                  nhx2tot=(nhx*(nhx-1))/2
                  incrhx=nhx*nhxres+1
                  incrlab=1
                  do ihx=1,nhx
                    do jhx=ihx+1,nhx
                      do i=1,nframe
                        iangs=res(1,i,nhx2tot+incrhx)
                        ang=(float(iangs/10000)/10.0)/radtodeg
                        res(1,i,incrhx)=cos(ang)
                        res(2,i,incrhx)=sin(ang)
                      end do
                      write (hxhxlab(incrlab),2169) ihx,jhx
                      incrlab=incrlab+1
                      incrhx=incrhx+1
                    end do
                  end do
                  call dialps(iw1,hxhxlab,lhxhxlab,title,ltitle,resrange,
         -          lresrange,5,nhx2tot,ndprow,nframe,pi,ipspage,9,
         -          nfravgd,nhx*nhxres,1,1,iconndial,ioutpr,mappdf,ipdfgrd)
                  call trajstat(iw0,nhx2tot,nhx2tot,hxhxlab,lhxhxlab,0,1,
         -          1,printrlab,lprintrlab,corr12,nhx*nhxres,itorcorr,1,
         -          ' ',1,radtodeg)
                  incrhx=nhx*nhxres+1
                  incrlab=1
                  do ihx=1,nhx
                    do jhx=ihx+1,nhx
                      do i=1,nframe
                        iangs=res(1,i,nhx2tot+incrhx)
                        dhang=(float(mod(iangs,10000))/10.0)/radtodeg
                        res(1,i,incrhx)=cos(dhang)
                        res(2,i,incrhx)=sin(dhang)
                      end do
                      write (hxhxlab(incrlab),2170) ihx,jhx
                      incrhx=incrhx+1
                      incrlab=incrlab+1
                    end do
                  end do
                  call dialps(iw1,hxhxlab,lhxhxlab,title,ltitle,resrange,
         -          lresrange,5,nhx2tot,ndprow,nframe,pi,ipspage,9,
         -          nfravgd,nhx*nhxres,1,1,iconndial,ioutpr,mappdf,ipdfgrd)
                  call trajstat(iw0,nhx2tot,nhx2tot,hxhxlab,lhxhxlab,0,1,
         -          1,printrlab,lprintrlab,corr12,nhx*nhxres,1,itorcorr,
         -          ' ',1,radtodeg)
                  nhx2tot2=2*nhx2tot
                  incrhx=nhx*nhxres+1
                  incrhx1=nhx*nhxres+1
                  incrlab=1
                  do ihx=1,nhx
                    do jhx=ihx+1,nhx
                      do i=1,nframe
                        iangs=res(1,i,nhx2tot2+incrhx1)
                        angrot1=(float(iangs/10000)/10.0)/radtodeg
                        angrot2=(float(mod(iangs,10000))/10.0)/radtodeg
                        res(1,i,incrhx)=cos(angrot1)
                        res(2,i,incrhx)=sin(angrot1)
                        res(1,i,incrhx+1)=cos(angrot2)
                        res(2,i,incrhx+1)=sin(angrot2)
                      end do
                      write (hxhxlab(incrlab),2171) ihx,jhx
                      write (hxhxlab(incrlab+1),2171) jhx,ihx
                      incrhx1=incrhx1+1
                      incrhx=incrhx+2
                      incrlab=incrlab+2
                    end do
                  end do
                  call dialps(iw1,hxhxlab,lhxhxlab,title,ltitle,resrange,
         -          lresrange,5,nhx2tot2,ndprow,nframe,pi,ipspage,9,
         -          nfravgd,nhx*nhxres,1,0,iconndial,ioutpr,mappdf,ipdfgrd)
                  call trajstat(iw0,nhx2tot2,nhx2tot2,hxhxlab,lhxhxlab,0,1,
         -          1,printrlab,lprintrlab,corr12,nhx*nhxres,1,itorcorr,
         -          ' ',1,radtodeg)
                end if
              else if (ianaltyp .eq. 19) then
                call dialps(iw1,talab,ltalab,title,ltitle,
         -        'Torsion angle dial plots',24,5,ntorsel,ndprow,nframe,
         -        pi,ipspage,0,nfravgd,0,0,1,iconndial,ioutpr,mappdf,
         -        ipdfgrd)
                call trajstat(iw0,ntorsel,MAXCOPY1,talab,ltalab,0,1,0,
         -        rmsdlab,lrmsdlab,corr12,0,itorcorr,0,' ',1,radtodeg)
                if (itorcorr .gt. 0) then
                  call askyn(
         -          'Do you want to plot the circular correlation matrix',
         -          51,1,-1,iplotccc,0,0)
                  if (iplotccc .eq. 1) call plot_ccc(ntorsel,ioutpr,iw1,
         -          ipspage,talab,ltalab,inpfile,namleni)
                  call askyn(
         -          'Do you want to calculate the eigenvectors/values',48,
         -          1,-1,ieigccc,0,0)
                  if (ieigccc .eq. 1) then
                    call indexit(index2d,1,ndials,0)
                    iout_ccc=47
                    call read_write_ccc(ndials,iout_ccc,+1)
                    call normalmodes(ndials,iout_ccc,nframe,1,iw0,1,ierr,
         -            index2d,temp,ifa_s,ila_s,it1,cv,MAX2D)
                    call read_write_ccc(ndials,iout_ccc,-1)
                    close (iout_ccc,status='delete')
                  end if
                  call askyn(
         -          'Do you want to cluster the angles by the correlation',
         -          52,1,-1,iclstccc,0,0)
                  if (iclstccc .eq. 1) call cluster_ccc(ndials,
         -          talab,ltalab,ixclst,ifclst1,ilclst1,index2d,it1,it2,
         -          it3,it4,' ',1,iw0,inpfile,namleni)
                end if
              else if (ianaltyp .eq. 22) then
                call arminmax2(res(1,1,7),1,nframe,2,armin1,armax1,
         -        armin2,armax2,0,2)
                call roundlim(armax1,y1div,ny1div)
                rmsdmin=armin1
                rmsdmax=armax1
                if (rmsdplotmax .gt. 0.0) then
                  ny1div=10
                  y1div=rmsdplotmax/ny1div
                end if
                call arminmax2(res(2,1,7),1,nframe,2,armin1,armax1,
         -        armin2,armax2,0,2)
                call roundlim(armax1,y2div,ny2div)
                if (rmaxdevplotmax .gt. 0.0) then
                  ny2div=10
                  y2div=rmsdplotmax/ny2div
                end if
                call plot2fun(iw1,maxdevplot+1,xtraj,res(1,1,7),res(1,1,7),
         -        nframe,0.0,0.0,00,0.0,y1div,ny1div, 0.0,y2div,ny2div,
         -        title,80,'Best overlap',12,xtrajlab,11 ,'RMSD',4,
         -        'Maximum deviation',17,1,0,6,2,1,0,1,0,3,
         -        ipspage,1,1,0)
                if (iunmatchplot .eq. 1) then
                  call arminmax2(res(1,1,8),1,nframe,2,armin1,armax1,
         -          armin2,armax2,0,2)
                  call roundlim(armax1,y1div,ny1div)
                  call roundlim(armax2,y2div,ny2div)
                  call plot2fun(iw1,maxdevplot+1,xtraj,res(1,1,8),
         -          res(1,1,8),nframe,0.0,0.0,00,0.0,y1div,ny1div,
         -          0.0,y2div,ny2div,title,80,
         -          'Comparison is done without overlay',34,xtrajlab,11 ,
         -          'RMSD',4,'Maximum deviation',17,1,
         -          0,6,2,1,0,1,0,0,ipspage,1,1,0)
                end if
                call trajstat(iw0,0,6,helixang,lhelixang,4,4,7,rmsdlab,
         -        lrmsdlab,corr12,itorcorr,0,0,' ',1,radtodeg)
                if (inptrajtyp .eq. 3) then
                  call correl(iw0,res(1,1,7),1,'RMSD',4,av1,sd1,res(1,1,9),
         -          1,'Energy',6,av2,sd2,corr,nframe,1,now6)
                  call arminmax2(res(1,1,9),1,nframe,2,armin1,armax1,
         -          armin2,armax2,0,2)
                  write (linein(1:48),2033) corr
                  call scatterps(iw1,rmsdmin,rmsdmax,575.0,armin1,armax1,
         -          720.0,res(1,1,7),res(1,1,9),1,1,nframe,linein,48,1)
                end if
                if (nresslt .le. MAXDISTR .and. nocontigrmsd .eq. 0) then
                  nosd=0
                  do i=1,MAXDISTRN
                    xcum(i)=nframes_err(i)
                  end do
                  do ir=1,nresslt
                    rmsfavs(2,ir)=sqrt(rmsfsum(ir)/float(nframe))
                  end do
                  call rmsf_av(cdp,cdp2,atw,nfinalrmsd,indexrmsd,ixres,
         -           rmsfsum,rmsfav,nframe,nslt,nresslt)
                  nresplot=0
                  ifstres=1
                  do while (nresplot .eq. 0)
                    call getrange(ifstplot,1,ilstplot,nresslt,incr,0,
         -            'residue index in the RMSF plot',30,nresslt,000)
                    if (ifstplot .lt. ixres(ifstrmsd) .or.
         -              ilstplot .gt. ixres(ilstrmsd)) then
                      write (6,2133) ixres(ifstrmsd),ixres(ilstrmsd)
                    else
                      nresplot=ilstplot-ifstplot+1
                      ifstres=ifstplot
                    end if
                  end do
                  do ir=ifstplot,ilstplot
                    rmsfavs(1,ir)=rmsfav(ir)
                    call blockfromcum(bl,distrerr(1,ir),xcum,MAXDISTRN)
                    call batchmean(MAXDISTRN,0,bl,'RMSF error',10,iw0,1,
         -            avg,sd,ci)
                    err12(1,ir)=sd
                    err12(2,ir)=sqrt(ci)
                  end do
                  do ir=ifstplot,ilstplot
                    ci=err12(2,ir)
                    sd=err12(1,ir)
                    if (ci .ne. 999.0) then
                      write (iw0,2155) ir,(rmsfavs(k,ir),k=1,2),sd,' ',ci
                    else
                      write (iw0,2155) ir,(rmsfavs(k,ir),k=1,2),sd
                    end if
                    err12(1,ir)=0.0
                  end do
                  call arminmax2(rmsfavs,ifstplot,ilstplot,2,armin1,
         -          armax1,armin2,armax2,0,2)
                  if (rmsfplotmax .eq. 0.0) then
                    call arminmax2(rmsfavs,ifstplot,ilstplot,2,armin1,
         -            armax1,armin2,armax2,0,2)
                    call roundlim(amax1(armax1,armax2),y1div,ny1div)
                  else
                    ny1div=10
                    y1div=rmsfplotmax/ny1div
                  end if
                  if (ixresno(ifstplot) .ne. ifstplot) then
                    print *,'The residue number of the ',ifstplot,
         -            '-th residue is ',ixresno(ifstplot)
                    call askyn('Do you want to use the residue number',37,
         -            1,+1,iusern,0,0)
                    if (iusern .eq. 1) ifstres=ixresno(ifstplot)
                  end if
                  ixmin=ifstres-mod(ifstres,10)
                  ilstres=ifstres+nresplot-1
                  ixmax=ilstres-mod(ilstres,10)
                  if (mod(ilstres,10) .gt. 0) ixmax=ixmax+10.0
                  xdiv=float(ixmax-ixmin)/10.0
                  xmin=ixmin
                  do ir=1,nresplot
                    cv(ir)=ifstres-1+ir
                  end do
                  plotdescr=
         -        'Residue RMSF wrt average (Cav) and input (Cref) position'
                  call askyn('Do you want error bars plotted on RMSF(Cref)',
         -           44,0,+1,nosd,0,0)
                  armax=amax1(armax1,armax2)
                  if (nosd .eq. 0 .and. rmsfplotmax .eq. 0.0) then
                    armax=armax+1.0
                    call roundlim(armax,y1div,ny1div)
                  end if
                  if (rmsfplotmax .gt. 0.0 .and. rmsfplotmax .lt. armax)
         -          print *,'NOTE part of the RMSF plots will be outside ',
         -            'the plot bounding box'
                  ny2div=ny1div
                  y2div=y1div
                  print *
                  call plot2fun(iw1,2,cv,rmsfavs(1,ifstplot),
         -          err12(1,ifstplot),nresplot,xmin,xdiv,10,0.0,y1div,
         -          ny1div,0.0,y2div,ny2div,title,80,plotdescr,56,'N(res)',
         -          6,'RMSF(Cav)',9,'RMSF(Cref)',10,1,0,6,2,nosd,nfreqsd,1,
         -          0,0,ipspage,0,1,0)
                  call askyn('Do you want to write a PDB file with RMSF',41,
         -          1,0,iwpdb,0,0)
                  if (iwpdb .gt. 0) then
                    do ir=nresslt,1,-1
                      do ia=ifres(ir),ilres(ir)
                        cv(ia)=rmsfav(ir)
                      end do
                    end do
                    analfile2(namleno2:namleno2)='f'
                    analfile2(namleno2+1:namleno2+4)='.pdb'
                    call openfile(iw2,0,'RMSF',4,'new',analfile2,namleno2+4,
         -            notfnd,0,1,1,0,0)
                    write (6,2031) analfile2(1:namleno2+4)
                    call writeconf(iw2,inpcrdtyp,inpcrdtyp,inpcrdtyporg,n,n,
         -            nslt,naslv,islvw,iasv,namesv,qsv,pflsv,1,iwhead,0,
         -            iatnum,ifchrg,nconfig,innlist,c,rprox,cv,ixres,iresno,
         -            atnames,resnames,segnames,charge,isegno,altcol,inscol,
         -            ninsres,marker,ntitlin,ntitlinw,title,ireseq,
         -            iresnrestart,iresidrestart,nneig,nneiga,nhbneig,ineig,
         -            nhneig,nnneig,ncneig,nsneig,npneig,numres,numslv,
         -            resnamslv,line,blankline,mmtype,ibnd,index,indexn,
         -            indexo,1,molresflag,irescount3,itemp1,hblimfac,angmin,
         -            0,1,1,1,0,3,iqspaceask,ianaltyp,0,0.0,0,0,0,keeprem,
         -            iwriteatsym,radtodeg,maxrepconf,maxng,maxrsd,maxrec)
                  end if
                end if
              else if (ianaltyp .eq. 23) then
                noclose=0
                if (irmsdclust .gt. 0) noclose=1
                nframeref=nframeref-1
                call plot2drmsd(nrep,iw0,iw1,xtraj,maxrec,title,'',0,
         -        0,xtrajlab,11,
         -        ncolcode,maxcolcode,iedit,noopt2d,limresrange,
         -        0,rmsdmin,rmsdmax,absdevmin,absdevmax,rmsdmn,rmsdmx,
         -        indexa,indexs,ixshuffle,ixshuffle,indexa,0,indexa,0,
         -        ym_2d,it1,it2,temp,0,1,noplotdist,iskip2dplot,0,
         -        noclose,ipspage,1)
                if (irmsdclust .gt. 0) then
                  inspect=0
                  write (6,2068)
    8010          call trnsfi(iconfsel,indexs,nframe)
                  call clusterdistr(nframe,iw0,rmsdlim,rmsdmn,rmsdmx,
         -          nhbdist,it1,it2,it3,itemp4,indexn,indexo,ncl,
         -          indexa,iconfsel,ixclst,it4,value,ifa_s,ila_s,ih,cv,0.0,
         -          rdclust,res(1,1,11),ietotsaved,'RMSD',4,1,1,irepav,
         -          irepmx,irepeng,irepkm,engcl,c,chn,c2,1,26,iclstyp,iwt,0,
         -          label2d,80,0,1,1,1,mx2d,maxframe)
                  do i=1,ncl
                    nclstmem(i)=indexo(i)-indexn(i)+1
                  end do
                  call countsim(indexn,indexo,iconfsel,ncl,rdclust,rmsdsim,
         -          nsimclst1,iw0,mx2d)
                  if (ireplot .eq. 1) then
                    call trnsfi(ixshuffle,iconfsel,MAX2D)
                    call indexit(it3,1,MAX2D,0)
                    if (inspect .eq. 1) then
                      call openfile(iw1,0,'analysis',8,'old',analfile1,
         -              namleno1,notfnd,0,1,1,0,0)
                      do while (.true.)
                        read (iw1,2005,end=8011) ans
                      end do
    8011              continue
                    end if
                    call plot2drmsd(nrep,iw0,iw1,xtraj,maxrec,title,
         -            'Frames sorted by clusters',25,
         -            0,xtrajlab,11,ncolcode,
         -            maxcolcode,iedit,noopt2d,limresrange,0,rmsdmin,
         -            rmsdmax,absdevmin,absdevmax,rmsdmn,rmsdmx,indexa,
         -            it3,ixshuffle,ixshuffle,indexo,ncl,indexo,ncl,
         -            ym_2d,it1,it2,temp,1,1,noplotdist,iskip2dplot,1,1,
         -            ipspage,0)
                    call askyn('Do you want to inspect the clustered map'//
         -            ' and redo the clustering',64,1,-1,inspect,000,0)
                    if (inspect .gt. 0) then
                      call clusterplot(iw1,xtraj,value,indexn,indexo,ncl,
         -              ixclst,nframe,xtrajlab,11,ipspage,0,mx2d)
                      close (iw1)
                      go to 8010
                    end if
                  end if
                  call clusterplot(iw1,xtraj,value,indexn,indexo,ncl,ixclst,
         -          nframe,xtrajlab,11,ipspage,0,mx2d)
                end if
              else if (ianaltyp .eq. 24) then
                call plot2drmsd(nrep,iw0,iw1,xtraj,maxrec,title,'',0,
         -        ltrajnam2,xtrajlab,11,
         -        ncolcode,maxcolcode,iedit,noopt2d,limresrange,
         -        1,rmsdmin,rmsdmax,absdevmin,absdevmax,rmsdmn,rmsdmx,
         -        indexa,indexs,ixshuffle,ixshuffle,indexa,0,indexa,0,
         -        ym_2d,it1,it2,temp,0,0,noplotdist,0,0,0,ipspage,0)
                if (matchconf .eq. 1)
         -        call matchtraj(rmsdsim,iw0)
                write (6,2038)
                write (iw0,2038)
              else if (ianaltyp .eq. 26) then
                call pairdistprint(nframe,npairs,listpairdist,iclusterdist,
         -        iclustermem,ifstclst1,ifstclst2,ilstclst2,pairdistsum,
         -        pairdistsum2,pairdistwsum,npairdist,pairdistminmax,
         -        pairgrid,rmaxpair,line,index,inamcol1,inamcol2,irescol1,
         -        irescol2,iresncol1,iresncol2,inpcrdtyp,ioins,iw0,nslt,
         -        MAXDDBIN,MAXDDISTR,MAXCDLIST,maxrec)
                call askyn(
         -        'Do you want to a PDB file with bonds for the distances',
         -         54,1,0,iwpdb,0,0)
                if (iwpdb .eq. 1) then
                  analfile4=analfile
                  analfile4(namleno-2:namleno+4)='dsm.pdb'
                  iw4=44
                  call openfile(iw4,0,'PDB with distances marked',25,
         -          'new',analfile4,namleno+4,notfnd,0,1,1,0,0)
                  call writeconf(iw4,inpcrdtyp,iobpdb,inpcrdtyporg,
         -          nslt,nslt,nslt,naslv,islvw,iasv,namesv,qsv,pflsv,1,
         -          iwhead,0,iatnum,ifchrg,nconfig,innlist,c,rprox,cv,ixres,
         -          iresno,atnames,resnames,segnames,charge,isegno,altcol,
         -          inscol,ninsres,marker,ntitlin,ntitlinw,title,ireseq,
         -          iresnrestart,iresidrestart,nneig,nneiga,nhbneig,ineig,
         -          nhneig,nnneig,ncneig,nsneig,npneig,numres,numslv,
         -          resnamslv,line,blankline,mmtype,ibnd,index,indexn,
         -          indexo,1,molresflag,irescount3,itemp1,hblimfac,angmin,
         -          0,1,1,1,0,3,iqspaceask,90+icontyp,0,0.0,0,0,1,keeprem,
         -          iwriteatsym,radtodeg,maxrepconf,maxng,maxrsd,maxrec)
                  do i=1,npairs
                    write (iw4,2131) (listpairdist(j,i),j=1,2)
                  end do
                  write (iw4,2005) 'END'
                  close (iw4)
                  write (6,2019) 'PDB file with distances marked',
         -          analfile4(1:namleno+4)
                end if
              else if (ianaltyp .eq. 39) then
                call plot_atomdist_sd(nslt,line,index,inamcol1,inamcol2,
         -        irescol1,irescol2,iresncol1,iresncol2,ianchor,nanchor,
         -        nframe,indexa,ixshuffle,xtraj,title,trajnam,ltrajnam,
         -        isdtyp,iw0,iw1,ipspage,maxrec)
              else if (ianaltyp .eq. 27) then
                call trajstat(iw0,0,1,helixang,lhelixang,4,4,1,volumelab,
         -        lvolumelab,corr12,0,0,0,' ',1,radtodeg)
                call arminmax2(res(1,1,1),1,nframe,2,armin1,armax1,
         -        armin2,armax2,0,2)
                call setdivxy(armin1,armax1,ny1div,y1div,y1min)
                call setdivxy(armin2,armax2,ny2div,y2div,y2min)
                write (linein,2148) nrand,corr12
                call plot2fun(iw1,2,xtraj,res(1,1,1),res(1,1,3),nframe,
         -        0.0,0.0,0,y1min,y1div,ny1div,y2min,y2div,ny2div,title,80,
         -        linein,70,xtrajlab,11 ,'V(solvent-excluded shell)',25,
         -        'V(first solvation shell)',24,1,0,6,2,00,0,
         -        1,0,4,ipspage,1,1,0)
                call arminmax2(res(1,1,2),1,nframe,2,armin21,armax21,
         -        armin22,armax22,0,2)
                linein(1:1)=' '
                call setdivxy(armin21,armax21,ny1div,y1div,y1min)
                call setdivxy(armin22,armax22,ny2div,y2div,y2min)
                call plot2fun(iw1,2,xtraj,res(1,1,2),res(1,1,4),nframe,
         -        0.0,0.0,0,y1min,y1div,ny1div,y2min,y2div,ny2div,title,80,
         -        linein,01,xtrajlab,11 ,'V(macromolecule)',16,
         -        'V(interface)',12,1,0,6,2,01,1,1,0,0,
         -        ipspage,1,1,0)
                nbin=max0(10,nframe/100)
                call zeroiti(indexo,0,nbin)
                range1=armax1-armin1
                call roundlim(range1,xdiv,nxdiv)
                nx1=armin1/xdiv
                xmin=nx1*xdiv
                facnorm=nbin/amax1(1.0,range1)
                do i=1,nframe
                  ix=min0(nbin,int(facnorm*(res(1,i,1)-armin1))+1)
                  indexo(ix)=indexo(ix)+1
                end do
                histmax=0.0
                do i=1,nbin
                  cv(i)=xmin+(i-0.5)*range1/nbin
                  charge(i)=indexo(i)
                  if (charge(i) .gt. histmax) histmax=charge(i)
                end do
                call roundlim(histmax,y1div,ny1div)
                call plot2fun(iw1,1,cv,charge,res(1,1,3),nbin,xmin,xdiv,
         -        nxdiv,0.0,y1div,ny1div, 0.0,y2div,ny2div,title,80,linein,
         -        36,'V(solvent-excluded shell)',25,xtrajlab,11 ,' ',1,
         -        1,0,6,1,01,0,1,0,0,ipspage,1,1,0)
                call zeroiti(indexo,0,nbin)
                call setdivxy(armin2,armax2,nxdiv,xdiv,xmin)
                facnorm=nbin/amax1(1.0,armax2-armin2)
                do i=1,nframe
                  ix=min0(nbin,int(facnorm*(res(2,i,1)-armin2))+1)
                  indexo(ix)=indexo(ix)+1
                end do
                histmax=0.0
                do i=1,nbin
                  cv(i)=xmin+(i-0.5)*(armax2-armin2)/nbin
                  charge(i)=indexo(i)
                  if (charge(i) .gt. histmax) histmax=charge(i)
                end do
                call roundlim(histmax,y2div,ny2div)
                call plot2fun(iw1,1,cv,charge,res(1,1,3),nbin,xmin,xdiv,
         -        nxdiv,0.0,y1div,ny1div, 0.0,y2div,ny2div,title,80,linein,
         -        36,'V(first solvation shell)',24,xtrajlab,11 ,' ',1,
         -        1,0,6,1,01,0,1,0,0,ipspage,0,1,0)
              else if (ianaltyp .eq. 28) then
                call arminmax2(res(1,1,6),1,nframe,2,armin1,armax1,
         -        armin2,armax2,0,2)
                call setdivxy(armin1,armax1,ny1div,y1div,y1min)
                call setdivxy(armin2,armax2,ny2div,y2div,y2min)
                call setdivxy(0.0,xtraj(nframe),nxdiv,xdiv,xmin)
                write (linein,2101) 'first and second'
                call plot2fun(iw1,2,xtraj,res(1,1,6),res(1,1,6),nframe,xmin,
         -        xdiv,nxdiv,y1min,y1div,ny1div,y2min,y2div,ny2div,title,80,
         -        linein,66,xtrajlab,11 ,'First principal axis',20,
         -        'Second principal axis',21,1,0,6,2,1,0,1,0,
         -        2,ipspage,1,1,0)
                call arminmax2(res(1,1,7),1,nframe,1,armin1,armax1,
         -        armin2,armax2,0,2)
                call setdivxy(armin1,armax1,ny1div,y1div,y1min)
                write (linein,2101) 'third'
                call plot2fun(iw1,1,xtraj,res(1,1,7),res(1,1,7),nframe,xmin,
         -        xdiv,nxdiv,y1min,y1div,ny1div,y2min,y2div,ny2div,title,80,
         -        linein,55,xtrajlab,11 ,'Third principal axis',20,' ',1,
         -        1,0,6,2,1,0,1,0,0,ipspage,0,1,0)
              else if (ianaltyp .eq. 29) then
                call averageres(nframe,res,1,1,MAXFRAMES,MAXCOPY1,rgav,rgsd)
                call averageres(nframe,res,1,2,MAXFRAMES,MAXCOPY1,rhav,rhsd)
                call averageres(nframe,res,2,2,MAXFRAMES,MAXCOPY1,rmxmn,
         -        rmxmnsd)
                write (iw0,2079) rgav,rgsd,1.0/rhav,rhsd,rmxmn
                call arminmax2(res(1,1,1),1,nframe,2,armin1,armax1,
         -        armin2,armax2,0,2)
                call setdivxy(armin1,armax1,ny1div,y1div,y1min)
                call setdivxy(armin2,armax2,ny2div,y2div,y2min)
                call setdivxy(0.0,xtraj(nframe),nxdiv,xdiv,xmin)
                noclose=0
                if (icharges .gt. 0) noclose=1
                call plot2fun(iw1,2,xtraj,res(1,1,1),res(1,1,1),nframe,xmin,
         -        xdiv,nxdiv,y1min,y1div,ny1div,y2min,y2div,ny2div,title,80,
         -        linein,00,xtrajlab,11 ,'Radius of gyration',18,
         -        'Hydrodynamic radius',19,1,0,6,2,1,0,1,0,1,
         -        ipspage,noclose,1,0)
                if (icharges .gt. 0) then
                  call averageres(nframe,res,1,10,MAXFRAMES,MAXCOPY1,avcell,
         -          sdcell)
                  call averageres(nframe,res,2,10,MAXFRAMES,MAXCOPY1,avslt,
         -          sdslt)
                  write (iw0,2080) avcell,sdcell,avslt,sdslt
                  call arminmax2(res(1,1,10),1,nframe,2,armin1,armax1,
         -          armin2,armax2,0,2)
                  call setdivxy(armin1,armax1,ny1div,y1div,y1min)
                  call setdivxy(armin2,armax2,ny2div,y2div,y2min)
                  call averageres(nframe,res,1,11,MAXFRAMES,MAXCOPY1,
         -          dip1(1),sdxyx1(1))
                  call averageres(nframe,res,2,11,MAXFRAMES,MAXCOPY1,
         -          dip1(2),sdxyx1(2))
                  call averageres(nframe,res,1,12,MAXFRAMES,MAXCOPY1,
         -          dip1(3),sdxyx1(3))
                  write (iw0,2088)
         -           'Total cell',(xyz(k),dip1(k),sdxyx1(k),k=1,3)
                  nplot=1
                  if (n .gt. nslt) then
                    nplot=2
                    call averageres(nframe,res,1,13,MAXFRAMES,MAXCOPY1,
         -          dip1(1),
         -            sdxyx1(1))
                    call averageres(nframe,res,2,13,MAXFRAMES,MAXCOPY1,
         -          dip1(2),sdxyx1(2))
                    call averageres(nframe,res,1,14,MAXFRAMES,MAXCOPY1,
         -          dip1(3),sdxyx1(3))
                    write (iw0,2088)
         -            'Solute',(xyz(k),dip1(k),sdxyx1(k),k=1,3)
                  end if
                  call plot2fun(iw1,nplot,xtraj,res(1,1,10),res(1,1,10),
         -          nframe,xmin,xdiv,nxdiv,y1min,y1div,ny1div,y2min,y2div,
         -          ny2div,title,80,linein,00,xtrajlab,11,'Total dipole',
         -          12,'Solute dipole',13,1,0,6,2,1,0,1,0,0,
         -          ipspage,0,1,0)
                  call correl(iw0,res(1,1,1),1,'Radius of gyration',18,
         -          av1,sd1,res(1,1,10),1,'Solute dipole',13,av2,sd2,corr,
         -          nframe,1,0)
                end if
              else if (ianaltyp .eq. 32) then
                call dialps(iw1,talab,ltalab,title,ltitle,
         -        'Angle dial plots',16,5,nangsel,ndprow,nframe,pi,ipspage,
         -        0,nfravgd,0,0,1,iconndial,ioutpr,mappdf,ipdfgrd)
                call trajstat(iw0,nangsel,MAXCOPY1,talab,ltalab,0,1,0,
         -        rmsdlab,lrmsdlab,corr12,0,itorcorr,0,' ',1,radtodeg)
              end if
              if (iw1 .gt. 0) write (6,2073) analfile1(1:namleno1)
            else if (ianaltyp .eq. 8) then
              write (iw0,2113)
              write (iw1,2113)
              if (iw2 .gt. 0) write (iw2,2113)
              call blankout(linein,1,80)
              do ir=1,nresslt
                if (irescount1(ir)+irescount2(ir)+irescount3(ir) .gt. 0)
         -          then
                  write (linein,2114) ir,iresno(ifres(ir)),
         -          resnames(ir)(1:nrescol),
         -          segid4(isegno(ifres(ir)))(1:nsegcol),
         -          irescount1(ir),irescount2(ir),irescount3(ir)
                  call lastchar(linein,lc,80)
                  write (iw0,2005) linein(1:lc)
                  write (iw1,2005) linein(1:lc)
                  if (iw2 .gt. 0) write (iw2,2005) linein(1:lc)
                end if
              end do
              call print_rrdist(itypavg,nframe,irefres1,irefres2,inegres1,
         -      inegres2,listrefres,nrefres,listnegres,nnegres,nrescol,iw0,
         -      iw1,iw4,ipspage,resnames,inpfile,namleni,itemp1,maxrsd)
              call askyn(
         -      'Do you want to write a PDB file with contact counts',51,1,
         -      0,iwpdb,0,0)
              if (iwpdb .gt. 0) then
                call quiz(ans,icontyp,' ',' ',0,'Contact type',12,0,5,6,
         -        0)
                do ir=1,nresslt
                  do ia=ifres(ir),ilres(ir)
                    if (icontyp .eq. 1) then
                      cv(ia)=irescount1(ir)
                    else if (icontyp .eq. 2) then
                      cv(ia)=irescount2(ir)
                    else if (icontyp .eq. 3) then
                      cv(ia)=irescount3(ir)
                    else if (icontyp .eq. 4) then
                      cv(ia)=irescount1(ir)+irescount2(ir)+irescount3(ir)
                    end if
                    rprox(ia)=1.0
                  end do
                end do
                analfile4=analfile1
                analfile4(namleno1-2:namleno1+4)='cnt.pdb'
                iw4=44
                call openfile(iw4,0,'Contact-labeled PDB',19,
         -        'new',analfile4,namleno1+4,notfnd,0,1,1,0,0)
                call writeconf(iw4,inpcrdtyp,iobpdb,inpcrdtyporg,
         -        nslt,nslt,nslt,naslv,islvw,iasv,namesv,qsv,pflsv,1,
         -        iwhead,0,iatnum,ifchrg,nconfig,innlist,c,rprox,cv,ixres,
         -        iresno,atnames,resnames,segnames,charge,isegno,altcol,
         -        inscol,ninsres,marker,ntitlin,ntitlinw,title,ireseq,
         -        iresnrestart,iresidrestart,nneig,nneiga,nhbneig,ineig,
         -        nhneig,nnneig,ncneig,nsneig,npneig,numres,numslv,
         -        resnamslv,line,blankline,mmtype,ibnd,index,indexn,indexo,
         -        1,molresflag,irescount3,itemp1,hblimfac,angmin,0,1,1,1,0,
         -        3,iqspaceask,90+icontyp,0,0.0,0,0,0,keeprem,iwriteatsym,
         -        radtodeg,maxrepconf,maxng,maxrsd,maxrec)
                close (iw4)
              end if
            else if (ianaltyp .eq. 12) then
              write (title,2069) irespro,nra,nrb
              call dialps(iw1,prokinklab,lprokinklab,title,ltitle,resrange,
         -      22,5,ndials,ndprow,nframe,pi,ipspage,0,nfravgd,0,0,0,
         -      iconndial,ioutpr,mappdf,ipdfgrd)
              write (6,2073) analfile1(1:namleno1)
              call trajstat(iw0,ndials,5,prokinklab,lprokinklab,0,1,0,
         -      rmsdlab,lrmsdlab,corr12,0,0,0,' ',1,radtodeg)
            else if (ianaltyp .eq. 25) then
              call openps(iw1,xm,ym-30,title,ltitle,
         -      ' ',1,trajnam,0,trajnam2,ltrajnam2,npspages,ipspage)
              call plotresidcorr(ncorr,nframe,indexa,indexs,
         -      ncolcode,maxcolcode,nrep,iw0,iw1,xm,ym,title,ltitle,
         -      ipspage,iucorrmat,icovmatplot,cv,maxrec)
              if (iucorrmat .gt. 0) then
                close (iw0)
                analfile(namleno+1:namleno+4)='.eig'
                namleno=namleno+4
                write (6,2019) 'Eigenvalues and eigenvectors',
         -        analfile(1:namleno)
                call openfile(iw0,0,'eigenvalues & eigenvectors',26,'new',
         -        analfile,namleno,notfnd,0,1,1,0,0)
                call normalmodes(ncorr,iucorrmat,nframe,
         -        0,iw0,1,ierr,index2d,value,ifa_s,ila_s,it1,rmsdlim,
         -        MAXBONDS)
                close (iucorrmat,status='delete')
              end if
            else if (ianaltyp .eq. 16 .or. ianaltyp .eq. 18) then
              if (ianaltyp .eq. 18) then
                call rainbowscale(iw1,50,450,25,nframe,xtraj(nframe),0.0,
         -        0.0,xtrajlab,11)
                call dialps(iw2,ramalab,lramalab,title,ltitle,' ',0,5,
         -        2*nxselres,ndprow,nframe,pi,ipspage,0,nfravgd,0,0,0,
         -        iconndial,ioutpr,mappdf,ipdfgrd)
                close (iw2)
                call ramachandran_hist(nresfound,resnames,nrescol,iw0,1,0)
                call ramachandran_hist(nresfound,resnames,nrescol,iw0,0,1)
                iw3=iw2+1
                analfile3=analfile
                analfile3(namleno+1:namleno+7)='.trc.ps'
                namleno3=namleno+7
                write (6,2019) '2D traces on the psi-phi map',
         -        analfile3(1:namleno3)
                call openfile(iw3,0,'2D_Rama_trace',13,'new',analfile3,
         -         namleno3,notfnd,0,1,1,0,0)
                analfile2=analfile
                analfile2(namleno+1:namleno+7)='.auc.ps'
                namleno2=namleno+7
                write (6,2019) 'Psi-Phi autocorrelation functions',
         -        analfile2(1:namleno2)
                call openfile(iw2,0,'Psi-Phi autoc',13,'new',analfile2,
         -         namleno2,notfnd,0,1,1,0,0)
                restitle='Residue 00000 (     ) nconf=        '
                incrementac=1
                if (nframe .gt. 500) call getint(
         -        'Frame increment for autocorrelation calculation',47,1,1,
         -        nframe/2,incrementac,0)
                do i=1,nframe/(2*incrementac)
                  rplot(i)=i*incrementac
                end do
                npspages=nxselres
                do ir=1,nxselres
                  if (ir .eq. nxselres) noclose=0
                  iresdr=ixselres(ir)
                  write (restitle(9:13),2103) iresdr
                  restitle(16:15+nrescol)=resnames(iresdr)(1:nrescol)
                  sinphisum=0.d0
                  cosphisum=0.d0
                  sinpsisum=0.d0
                  cospsisum=0.d0
                  do i=1,nframe
                    xyplot(1,i)=dacoscheck(ddd,res(1,i,2*ir-1),0,6,'RAMA')*
         -            radtodeg
                    if (res(2,i,2*ir-1) .lt. 0) xyplot(1,i)=-xyplot(1,i)
                    xyplot(2,i)=dacoscheck(ddd,res(1,i,2*ir),0,6,'RAMA')*
         -            radtodeg
                    if (res(2,i,2*ir) .lt. 0) xyplot(2,i)=-xyplot(2,i)
                    cosphisum=cosphisum+res(1,i,2*ir-1)
                    sinphisum=sinphisum+res(2,i,2*ir-1)
                    cospsisum=cospsisum+res(1,i,2*ir)
                    sinpsisum=sinpsisum+res(2,i,2*ir)
                  end do
                  cosphisum=cosphisum/nframe
                  sinphisum=sinphisum/nframe
                  sqsum=sqrt(cosphisum**2+sinphisum**2)
                  if (sqsum .eq. 0.0) sqsum=1.0
                  cosphisum=cosphisum/sqsum
                  cvphi=1.0-sqsum
                  phiav=dacoscheck(cosphisum,cps,1,6,'PHIAV')*radtodeg
                  if (sinphisum .lt. 0.d0) phiav=-phiav
                  cospsisum=cospsisum/nframe
                  sinpsisum=sinpsisum/nframe
                  sqsum=sqrt(cospsisum**2+sinpsisum**2)
                  if (sqsum .eq. 0.0) sqsum=1.0
                  cospsisum=cospsisum/sqsum
                  psiav=dacoscheck(cospsisum,cps,1,6,'PSIAV')*radtodeg
                  if (sinpsisum .lt. 0.d0) psiav=-psiav
                  cvpsi=1.0-sqsum
                  write (6,2093) iresdr,resnames(iresdr)(1:nrescol),
         -          phiav,cvphi,psiav,cvpsi
                  write (iw0,2093) iresdr,resnames(iresdr)(1:nrescol),
         -          phiav,cvphi,psiav,cvpsi
                  call plot2d(iw3,xyplot,nframe,1,-180.0,30.0,12,
         -          -180.0,30.0,12,title,80,'2D trace on the psi-phi map',
         -          27,restitle,21,'Phi',3,'Psi',3,xtrajlab,11,1,0,6,
         -          npspages,ipspage3,1,MAXFRAMES)
                  call resautocorr(ir,incrementac,ncf,xyplot,MAXFRAMES)
                  write (restitle(29:36),2094) ncf
                  call plot2fun(iw2,1,rplot,xyplot,xyplot,ncf,0.0,0.0,0,
         -          0.0,0.1,10,0.0,0.1,10,
         -          'Psi-Phi autocorrelation function',32,restitle,36,
         -          xtrajlab,11,'Autocorrelation',15,' ',1,
         -          1,0,77,2,1,0,1,0,npspages,ipspage2,1,1,0)
                  npspages=0
                end do
              end if
              write (iw1,*) 'showpage'
              close (iw1)
              if (ianaltyp .eq. 16) then
                write (iw0,2149) (typc(it),ssname(it)(1:lssname(it)),it=1,9)
                write (iw0,2150) (typc(it),it=1,9)
                write (iw0,2151)
         -         (ir,(idistdssp(it,ir),it=1,9),ir=ifrdssp,ilrdssp)
              end if
              close (iw2)
              close (iw3)
            else if (ianaltyp .eq. 17) then
              call hbbridgeprint(nanchor,ianchor,lpath,nbridgetype,
         -      ibridgetype,maxbridgemem,line,index,iresno,inamcol1,
         -      inamcol2,irescol1,irescol2,iw0,maxbondcount,
         -      maxhbtype,minbridgelenprint,minbridgepercprint,nframe,
         -      MAXBRIDGELEN,MAXBRIDGETYPE,maxrec)
            else if (ianaltyp .eq.  5) then
              call finalizebonds(n,nbfound,nbfoundorig,nbresfound,iw0,iw1,
         -      numres,nresslt,npspages,ipspage,nres2d,ibondcorr,
         -      iresbondcorr,nhneigmin,hblimfac,angmin,0.0,inamcol1,
         -      inamcol2,irescol1,irescol2,ifhb2d,ilhb2d,nhbdist,rhbdist,
         -      iframeunit,framefac,title,ltitle,xtrajlab,11,xtraj,value,
         -      ifa_s,ila_s,ih,cv,temp,index,iresno,ifres,isegno,atnames,
         -      resnames,ixres,ixresno,ixsegno,indexa,indexs,index2d,
         -      ianc_anc,isc,ixclst,irepav,irepmx,irepeng,irepkm,rmsdlim,
         -      engcl,it1,it2,it3,it4,it5,irrix,itemp1,itemp2,itemp3,itemp4,
         -      line,'hydrogen',8,ibondtype,label2d,iselfanc,ianchor2,
         -      iresshift,ifailbond,nbondavg,inpfile,namleni,maxbondf,
         -      nmcmaxbond,ncolcode,maxcolcode,maxbondcount,MAXBONDS,maxrsd,
         -      MAXFRAMES,maxrec,mx2d)
            else if (ianaltyp .eq.  6) then
              call finalizebonds(n,nbfound,nbfoundorig,nbresfound,iw0,iw1,
         -      numres,nresslt,npspages,ipspage,nres2d,ibondcorr,
         -      iresbondcorr,nhneigmin,hblimfac,angmin,rhphmax,inamcol1,
         -      inamcol2,irescol1,irescol2,ifhb2d,ilhb2d,nhbdist,rhbdist,
         -      iframeunit,framefac,title,ltitle,xtrajlab,11,xtraj,value,
         -      ifa_s,ila_s,ih,cv,temp,index,iresno,ifres,isegno,atnames,
         -      resnames,ixres,ixresno,ixsegno,indexa,indexs,index2d,
         -      ianc_anc,isc,ixclst,irepav,irepmx,irepeng,irepkm,rmsdlim,
         -      engcl,it1,it2,it3,it4,it5,irrix,itemp1,itemp2,itemp3,itemp4,
         -      line,'hydrophobic',11,ibondtype,label2d,iselfanc,ianchor2,
         -      iresshift,ifailbond,nbondavg,inpfile,namleni,maxbondf,
         -      nmcmaxbond,ncolcode,maxcolcode,maxbondcount,MAXBONDS,maxrsd,
         -      MAXFRAMES,maxrec,mx2d)
            else if (ianaltyp .eq.  34) then
              call finalizebonds(n,nbfound,nbfoundorig,nbresfound,iw0,iw1,
         -      numres,nresslt,npspages,ipspage,nres2d,ibondcorr,
         -      iresbondcorr,nhneigmin,hblimfac,angmin,rhphmax,inamcol1,
         -      inamcol2,irescol1,irescol2,ifhb2d,ilhb2d,nhbdist,rhbdist,
         -      iframeunit,framefac,title,ltitle,xtrajlab,11,xtraj,value,
         -      ifa_s,ila_s,ih,cv,temp,index,iresno,ifres,isegno,atnames,
         -      resnames,ixres,ixresno,ixsegno,indexa,indexs,index2d,
         -      ianc_anc,isc,ixclst,irepav,irepmx,irepeng,irepkm,rmsdlim,
         -      engcl,it1,it2,it3,it4,it5,irrix,itemp1,itemp2,itemp3,itemp4,
         -      line,'heavy-atom contact',18,ibondtype,label2d,iselfanc,
         -      ianchor2,iresshift,ifailbond,nbondavg,inpfile,namleni,
         -      maxbondf,nmcmaxbond,ncolcode,maxcolcode,maxbondcount,
         -      MAXBONDS,maxrsd,MAXFRAMES,maxrec,mx2d)
            else if (ianaltyp .eq.  41) then
              call finalizebonds(n,nbfound,nbfoundorig,nbresfound,iw0,iw1,
         -      numres,nresslt,npspages,ipspage,nres2d,ibondcorr,
         -      iresbondcorr,nhneigmin,hblimfac,angmin,rhphmax,inamcol1,
         -      inamcol2,irescol1,irescol2,ifhb2d,ilhb2d,nhbdist,rhbdist,
         -      iframeunit,framefac,title,ltitle,xtrajlab,11,xtraj,value,
         -      ifa_s,ila_s,ih,cv,temp,index,iresno,ifres,isegno,atnames,
         -      resnames,ixres,ixresno,ixsegno,indexa,indexs,index2d,
         -      ianc_anc,isc,ixclst,irepav,irepmx,irepeng,irepkm,rmsdlim,
         -      engcl,it1,it2,it3,it4,it5,irrix,itemp1,itemp2,itemp3,itemp4,
         -      line,'mutually proximal atom pairs',28,ibondtype,label2d,
         -      iselfanc,ianchor2,iresshift,ifailbond,nbondavg,inpfile,
         -      namleni,maxbondf,nmcmaxbond,ncolcode,maxcolcode,
         -      maxbondcount,MAXBONDS,maxrsd,MAXFRAMES,maxrec,mx2d)
            else if (ianaltyp .eq.  7) then
              call finalizebonds(n,nbfound,nbfoundorig,nbresfound,iw0,iw1,
         -      numres,nresslt,npspages,ipspage,nres2d,ibondcorr,
         -      iresbondcorr,nhneigmin,hblimfac,angmin,rsltbmax,inamcol1,
         -      inamcol2,irescol1,irescol2,ifhb2d,ilhb2d,nhbdist,rhbdist,
         -      iframeunit,framefac,title,ltitle,xtrajlab,11,xtraj,value,
         -      ifa_s,ila_s,ih,cv,temp,index,iresno,ifres,isegno,atnames,
         -      resnames,ixres,ixresno,ixsegno,indexa,indexs,index2d,
         -      ianc_anc,isc,ixclst,irepav,irepmx,irepeng,irepkm,rmsdlim,
         -      engcl,it1,it2,it3,it4,it5,irrix,itemp1,itemp2,itemp3,itemp4,
         -      line,'salt-bridge',11,ibondtype,label2d,iselfanc,ianchor2,
         -      iresshift,ifailbond,nbondavg,inpfile,namleni,maxbondf,
         -      nmcmaxbond,ncolcode,maxcolcode,maxbondcount,MAXBONDS,maxrsd,
         -      MAXFRAMES,maxrec,mx2d)
            else if (ianaltyp .eq. 11) then
              zav=zavs/dfloat(nframe)
              zsd=dsqrt(dabs(zsqs/dfloat(nframe)-zav**2))
              write (6,2008) zav,zsd
              write (iw0,2008) zav,zsd
              pi=atan(1.0)*4.0
              write (6,2009)
              write (iw0,2009)
              do m=2,npsr
                sn=sinpsrs(m)/dfloat(nframe)
                cs=cospsrs(m)/dfloat(nframe)
                psr(m)=atansc(sn,cs,1,radtodeg)
                cvm=1.d0-dsqrt(sinpsrs(m)**2+cospsrs(m)**2)/dfloat(nframe)
                qpsrav=qpsrs(m)/dfloat(nframe)
                qsd=dsqrt(dabs(qpsr2s(m)/dfloat(nframe)-qpsrav**2))
                write (6,2011) m,psr(m),cvm,qpsrav,qsd
                write (iw0,2011) m,psr(m),cvm,qpsrav,qsd
              end do
            else if (ianaltyp .eq. 40) then
              avnumsolv=float(numsolvsum)/float(nframe)
              write (6,2109) avnumsolv,numsolvmin,numsolvmax
              write (iw0,2109) avnumsolv,numsolvmin,numsolvmax
            end if
            iout_track=0
            if (ianaltyp .eq. 5 .or. ianaltyp .eq. 6 .or.
         -      ianaltyp .eq. 7 .or. ianaltyp .eq. 34) then
              if (ireadtracks .eq. 0) then
                call askyn(
         -        'Do you want to write the bond tracks',36,1,-1,itrackw,0,
         -        2)
                if (itrackw .gt. 0) then
                  call getname(trackfile,ltrackfile,
         -          'Name of the bond track file',27,80,'',0,0,000,0)
                  iout_track=92
                  call openfile(92,0,' ',1,'new',trackfile,ltrackfile,
         -          notfnd,0,1,1,0,0)
                  call writetrack(iout_track,iw0,30,nbfoundorig,nres2d,
         -          trackfile,ltrackfile,ianc_anc)
                end if
              end if
              iwconn=0
              if (ilastframe .eq. 0) write (6,2122) 'input structure'
              if (ilastframe .eq. 1) write (6,2122)
         -      'last structure read from the trajectory file'
              question='Do you want a PDB file of the current structure '//
         -      'with % bonds'
              call askyn(question(1:60),60,1,-1,iwpdb,0,0)
              if (iwpdb .eq. 0) then
                call askyn('Do you want a PDB file with lines between the'//
         -        ' residue pairs',59,1,-1,iwconn,140,0)
              else
                call askyn(
         -        'Do you want to add lines between the residue pairs',50,
         -        1,-1,iwconn,140,0)
                iwpdb=1
              end if
              if (iwpdb .gt. 0) then
                call askyn(
         -        'Do you want percentages added to all atoms in a residue',
         -        55,1,-1,icperc,138,0)
                if (icperc .eq. 1) then
                  do ir=1,numres
                    sum=0.0
                    do ia=ifres(ir),ilres(ir)
                      sum=sum+cv(ia)
                    end do
                    if (sum .gt. 0.0) then
                      do ia=ifres(ir),ilres(ir)
                        cv(ia)=sum
                      end do
                    end if
                  end do
                end if
                analfile4=analfile
                lanalfile4=namleno
                analfile4(lanalfile4-2:lanalfile4+4)='pcb.pdb'
                lanalfile4=lanalfile4+4
                iw4=44
                call openfile(iw4,0,'Percent bond labeled PDB',24,
         -        'new',analfile4,lanalfile4,notfnd,0,1,1,0,0)
                call writeconf(iw4,inpcrdtyp,iobpdb,inpcrdtyporg,
         -        nslt,nslt,nslt,naslv,islvw,iasv,namesv,qsv,pflsv,1,
         -        iwhead,0,iatnum,ifchrg,nconfig,innlist,c,rprox,cv,ixres,
         -        iresno,atnames,resnames,segnames,charge,isegno,altcol,
         -        inscol,ninsres,marker,ntitlin,ntitlinw,title,ireseq,
         -        iresnrestart,iresidrestart,nneig,nneiga,nhbneig,ineig,
         -        nhneig,nnneig,ncneig,nsneig,npneig,numres,numslv,
         -        resnamslv,line,blankline,mmtype,ibnd,index,indexn,indexo,
         -        1,molresflag,irescount3,itemp1,hblimfac,angmin,0,1,1,1,0,
         -        3,iqspaceask,ianaltyp,0,0.0,0,0,1,keeprem,iwriteatsym,
         -        radtodeg,maxrepconf,maxng,maxrsd,maxrec)
                if (iwconn .gt. 0) then
                  call writeconn(iw4,ifres,ilres,line,index,inamcol1,
         -          inamcol2,c,n,iresbondcorr,itemp4,nframe,iw0,mxbonds,
         -          maxrsd,maxrec)
                end if
                write (iw4,2005) 'END'
                close (iw4)
              end if
            end if
          end if
    9005  write (iw0,*)
          call datprt(iw0,version,0,mark0,lmark0,hostname,lhostname,
         -  iheadnode,0)
          close (iw0)
          n=natsorig
          iconfirmname=1
          call testconst(0,1,2,0.0,1.0,2.0,6,nfail,1,'ANTD')
          go to 9000
          return
    2000  format(/,' List of 1-4 neighbors, their distances and the ',
         -  'torsion angles will be',/,' written to ',a)
    2001  format(i2)
    2002  format(' Hydrogen-bond',a,'list will be written to file',/,
         -  5x,a)
    2003  format(/,20x,' DSSP (Kabsch-Sander) ANALYSIS',/)
    2004  format(/,20x,' HELIX ORIENTATION ANALYSIS',//,
         -  ' S and E: coordinates of the helix axis initial and ',
         -  'final points (in A)',/,
         -  ' RMS: diagnostic of the irregularities in the helix',/,
         -  ' Len: length of the helix (in A)',/,
         -  ' D: unit vector in the helix direction',/,
         -  ' D-X,D-Y,D-Z angles: the tilt angles of the helix w.r.t. the',
         -  ' laboratory frame',/,
         -  ' Shape: Bent, Random or Oscillating, ',
         -  'based on Nup/dn (nup, ndown), and Ncross',/,
         -  ' Tolerance for being on the axis=',f6.2,
         -  ' (Nax: number of CAs within tolerance)'/,
         -  ' Rc: radius of circle fitted to the alpha carbons',/
         -  ' TPR: turn angle/residue',/,
         -  ' C: coordinates of the center of mass of the helix',/,
         -  ' N-X,N-Y,N-Z angles: the tilt angles of the normal to the ',
         -  ' plane fitting',/,
         -  '    the alpha carbons w.r.t. the laboratory frame',/,
         -  ' Rotation: the angle of revolution of helix around ',
         -  'its axis from the start',/,
         -  ' Local tilt: angle between the first and current ',
         -  'helix axes',/,
         -  ' SD: fluctuation of the rotation angles calculated from ',
         -  'each alpha carbon',/,
         -  ' N/Nr angle: angle between the normals N in the ',
         -  'current and reference state',/)
    2005  format(a)
    2006  format(a,a,' file analyzed:',a)
    2007  format(' Helix axis calculation Copyright 1996 Jon A.Christopher',
         -  ' and Thomas O. Baldwin.',/,
         -  25x,'Computers in Chemistry Vol. 20, pp 338-349 (1989)',/,
         -  ' Axes generated with the algorithm of Kahn ',/,
         -  25x,'Computers in Chemistry Vol 13, pp 185-189 (1989)')
    2008  format(' Average mean distance from the ring plane=',f6.2,
         -  ' A SD=',f6.2)
    2009  format(' Average general puckering coordinates ',
         -  '(Cramer & Pople)=',/,7x,'m   angle    CV      qm     SD')
    2010  format(' Reference structure:')
    2011  format(' SUM ',i3,f8.2,f7.4,2f8.4)
    2012  format(/,' Reference structure file:',a)
    2013  format(' Note: RMSD calculation is working with trajectory ',
         -  'scan only',/,' but a set of PDB or Charmm CRD files can be ',
         -  'read as MMC trajectories')
    2014  format(a,/,a,'System:',/,a,a)
    2015  format(' Residue range of the helix ',i3,':',i5,' - ',i5,
         -  ' (segment ',i3,') Center residue:',i6)
    2016  format(/,' Secondary structure element type:',/,
         -  7(9x,a1,': ',a,/),9x,'?',': Unrecognized',/)
    2017  format(' The COM of each trajectory frame will be shifted to the',
         -  ' reference frame COM')
    2018  format(' Each trajectory frame will be overlaid on the reference',
         -  ' structure',a)
    2019  format(1x,a,' will be written to file ',/,5x,a)
    2020  format(' Scan of trajectory ',a,' finished',/,
         -  ' Number of frames read=',i6,/,' Number of frames analyzed=',i6,
         -  a,/,' Number of frames skipped=',i6)
    2021  format(/,' NOTE: map preparation would be much faster if you ',
         - 'used a trajectory',/,' that has only the frames for which ',
         - 'calculations are required.',/,' Use the trajectory conversion ',
         - 'option of Simulaid to do this')
    2022  format(' NOTE: Mass-weighting is turned off')
    2023  format(i5,1x,a4,1x,a3)
    2024  format(/,' List of neighbors, bondlengths, angles and torsions ',
         -  '(if requested) will be',/,' written to file ',a)
    2025  format(' Solvent radius=',f7.2,' A',/,
         -  ' Number of random point generated=',i10)
    2026  format(' Only every ',i2,'-th grid point will be used')
    2027  format('REMARK ',a)
    2028  format(' Calculation of distance distribution over selected atom',
         -  ' pairs',/,a)
    2029  format(' NOTE: residue numbers refer to the actual residue ',
         -  'number in the input structure')
    2030  format(' WARNING: The presence of a large number of solvents ',
         -  'slows down the calculation',/,10x,'- you may want to ',
         -  'eliminate the solvents using the Edit option')
    2031  format(' PDB file with RMSF as the B factor:',a)
    2033  format('RMSD (X) - Energy (Y) scatterplot. Corr=',f8.5)
    2034  format(' Number of atoms changed from ',i6,' to ',i6,
         -  ' (trajectory)')
    2035  format(' NOTE: lack of charge information may hamper the bond ',
         -  'definitions',/,7x,'- you may want to consider other structure',
         -  ' file formats')
    2036  format(' Simulaid will try to open file ',a,/,
         -  10x,'to write the results on. If this is the file ',
         -  'that you want to read,',/,
         -  10x,'make sure not to overwrite it')
    2037  format(' !!!!! WARNING: This calculation may be quite time ',
         -  'consuming',/,
         -  7x,'Please, log on to a compute node and restart')
    2038  format(' To match clusters of the two trajectory, generate the ',
         -  '2D RMSD map for both',/,' and rerun the cross-RMSD ',
         -  'calculation using the already calculated',/,
         -  ' 2D RMSD and cross-RMSD maps')
    2039  format(1x,a1,':',i5,' (',a,1x,a,')',3(' -',i5,' (',a,1x,a,')'))
    2040  format(' Residue range of the helix:',i5,' - ',i5,' (segment ',i3,
         -  ')')
    2041  format(1x,a,': Invalid selection, try again')
    2042  format(' Bridge residue name=',a,' Number of atoms in residue ',a,
         -  '=',i3)
    2043  format(i3)
    2044  format(100i1)
    2045  format(' Default marks will be used:',/,9(i2,': ',a1))
    2046  format(' Adjacency-matrix analysis result will be written to ',
         -  'file',/,1x,a)
    2047  format(' Enter the indices of the two atoms whose distance is ',
         -  'to be calculated/tracked',/,
         -  ' To track the diffusion of an atom, type the same index',
         -  ' for both atoms')
    2048  format(' N=',i6,' c(',i5,')=',3f11.2,' A')
    2049  format(' N=',i6,' c(',i5,')=',3f11.2,' c(',i5,')=',3f11.2,' A')
    2050  format(/,' Residue neighbour list based on ',a,' atoms will be ',
         -  'written to',/,1x,a)
    2051  format(' First atom is on the reference structure ',a)
    2052  format(i5,' diffusion')
    2053  format(i5,' - ',i5,' distance')
    2054  format(' N=',i6,' D=',f11.2,' D^2=',f11.2,' r=',3f11.2,' A')
    
    2056  format(' Symbol for residue type ',i1,'=',$)
    2057  format(' Calculating distance between atom',i6,' residue',i5,
         -  ' (',a5,a5,') and',/,' atom',i6,' residue',i5,' (',a5,a5,')')
    2058  format(' Calculating distance between atoms',i6,' and',i6)
    2059  format(' WARNING: number of frames exceeded the parameter ',
         -  'MAXFRAMES (',i8,')',/,10x,'Several analysis options fail when',
         -  ' this limit is passed')
    2060  format(1x,a,' first and last frame and increment:',3i7)
    2061  format(' Check for unphysical distances',/,
         -  ' Clash threshold = Bondlength threshold * sqrt(',f8.4,')',/,
         -  ' Short bond threshold = Bondlength threshold * sqrt(',f8.4,')',
         -  /,' Index distance threshold for non-S atoms = ',i4)
    2062  format(' NOTE: The number of solute residues (',i6,') exceeds ',
         -  'the limit (',i5,')',/,' Increase the parameter MAXDISTR and',
         -  ' recompile to calculate RMSF')
    2063  format(' WARNING: ',a,' trajectory name (',a,')',/,8x,
         -  'is different from the trajectory name of the corresponding ',
         -  '2D-RMSD map',/,8x,'(',a,')')
    2064  format(/,' RMSD values were read from file ',a)
    2065  format(' Number of frames used from the second trajectory=',i6)
    2066  format(' WARNING: atoms',i6,' and',i6,' are',a,'bonded',/,
         -  ' You can create bonds with the Edit option')
    2067  format(a1,i2,' i:',i4,3('-',i4))
    2068  format(' NOTE: after quitting clustering you will have the ',
         - 'option of inspecting',/,6x,' the map and repeat the clustering')
    2069  format('Proline kink dials for residue',i5,
         -  ' Pre and post proline helix length=',2i3)
    2070  format(' Configuration ',i6,': all solvents were filtered out')
    2071  format(/,' Calculation of proline kink angles defined by ',
         -  'Visiers et al.',/,
         -  ' Note: kink residue does not have to be a proline',/,
         -  ' Axes generated with the algorithm of Kahn ',/,
         -  ' using the subroutines of J.A. Christopher & T.O. Baldwin',/,
         -  ' Angles are calculated with vector-algebra based code',/,
         -  ' Bend, angle, wobble angle and phase shift will',
         -  ' be written to file',/,1x,a)
    2072  format(i6,' B=',f6.1,' W=',f6.1,' FS=',f6.1,' W-FS=',f6.1,
         -  ' PR=',f6.1,' axis RMS b,a=',f4.2,f5.2)
    2073  format(' The Postscript plots will be written to the file',/,
         -  1x,a)
    2074  format(' Plotting is limited to ',i6,1x,a,/,
         -  ' -',a,'increase the the arrays (maxframe)',/
         -  ,' in the common block /analres/')
    2075  format(1x,a,' map values will be written to file',/,
         -  1x,a,/,' Postscript plot will be written to file',/,1x,a)
    2076  format(1x,a,' will be written into the data column ',
         -  'in file',/,1x,a)
    2077  format(/,20x,' PROLINE KINK CALCULATION',/,
         -  ' bend (B), wobble (W), phase shift (FS)',/,
         -  ' pseudorotation angle of the proline (PR)',/,' Goodness of ',
         -  ' the helices before and after the proline (axis RMS b,f)')
    2078  format(/,' Calculation of pseudorotation angles')
    2079  format(/,' Average radius of gyration=',f10.3,' S.D.=',f10.3,' A',
         -  /,' Average hydrodynamic radius=',f10.3,' S.D.(1/rHD)=',f10.3,/,
         -  ' Average ratio of the largest and smallest moments of ',
         -  'inertia=',f10.3)
    2080  format(/,' Average cell dipole moment=',f10.3,' S.D.=',f10.3,/
         -  ' Average solute dipole moment=',f10.3,' S.D.=',f10.3,' au*A')
    2081  format(/,' NOTE: warnings, summaries (if any) will be turned off',
         -  ' after the',i3,'-th frame')
    2082  format(' Calculation of the RMSD from the input structure',/,
         -  ' both after obtaining the best fit with the Kabsch ',
         -  'method and without fitting',/)
    2083  format(' Kink residue:',i5)
    2084  format(' Calculation of the RMSD matrix between frames of a ',
         -  'trajectory')
    2085  format(/,1x,78('-'))
    2086  format(' Plot entries color coded by the ',a,' number:',/,
         -  ' Red-Yellow-Green-Cyan-Blue <--> 1 -',a,a,i5,')')
    2087  format('Residues',i6,' -',i6)
    2088  format(1x,a,' dipole components:',/,
         -  3(' dip',a,'=',f8.2,' +/-',f6.2))
    2089  format(' Number of ',a,' helices: ',i7)
    2090  format(' WARNING: The calculation would be significantly faster',
         -  ' if a trajectory were first',/,10x,'extracted with only the ',
         -  'frames needed.',/,10x,'- it can be done with the trajectory ',
         -  'conversion option')
    2091  format('Atomic number of solvent atom ',i2)
    2092  format('Partal charge of solvent atom ',i2)
    2093  format(' Residue',i5,' (',a,') <Phi>=',f8.2,' CV=',f6.4,
         -  ' <Psi>=',f8.2,' CV=',f6.4)
    2094  format(i8)
    2095  format(a1)
    2096  format(' Current dimensioning allows only for',i6,' * ',i6,
         -  ' matrix')
    2097  format(' Principal axes calculated will be written to file',/,
         -  1x,a)
    2098  format(' The reference conformation may be the first ',
         -  'conformation of the trajectory'/,' (this is the default) or ',
         -  'the structure inputted at the start')
    2099  format(' Calculation of principal axes. Atoms used:',$)
    2100  format(' Calculation of radii of gyration, hydrodynamic radius ',
         -  ' moments of inertia and',/,
         -  ' (when charges are available) and dipole moment',/
         -  ' Atoms used:',$)
    2101  format(' Angle between inital and current ',a,' principal axis')
    2102  format(' Subsequent structures will be saved into files',/,
         -  1x,a,'*N',a)
    2103  format(i5)
    2104  format(' Residue # ',i6,' has no full backbone - a bond may be ',
         -  'missing',/,' You can add bonds usind the Edit option')
    2105  format(' Solvents will be sorted by increasing CV (out -> in)')
    2106  format(' ERROR: dimensions of the cross-MSD matrix (',i5,' x ',i5,
         -  ')',/,8x,'differ from the lengths of the trajectories read:',
         -  2i6)
    2107  format(' Radius of gyration, hydrodynamic radius moments of ',
         -  'inertia',/,' and (if charges are available) dipole moment ',
         -  'will be written to file'/,1x,a)
    2108  format('A ',a4,'-',a4,'(',a4,') -',a4)
    2109  format(' Average number of filtered solvents=',f8.1,/,
         -  ' Range: [',i6,',',i6,']')
    2110  format(' Filtering summaries are written to file ',a,'.flt')
    2111  format(' Segment',i4,' residue #',i5,' is ',a)
    2112  format(' At least one of the residue ranges exceeds MAX2D (',i5,
         -  ')',/,' - no averages will be calculated')
    2113  format(/,'List of the counts of different tyes of contacts',/)
    2114  format(i5,' resid=',i5,' (',a,1x,a,') Nrepr=',i6,' Nclose=',i6,
         -  ' Ncontact=',i6)
    2115  format(' New value of ramax(',a2,')')
    2116  format(' RMSDs were calculated ',a)
    2117  format(' Actual residue number of the ',a,' residue=',i6)
    2118  format(' Reference structure file=',a)
    2119  format(' Sigma-r plot (SD of interatomic distances'/,
         -  ' Hao Zhou, to be published')
    2120  format(' Molecule-molecule distance matrix based on ',a,/,
         -  ' will be written to ',a)
    2121  format(' Molecule-molecule distance matrix based on ',a,/)
    2122  format(' Current structure is the ',a)
    2123  format(' ERROR: residue number can not be ',a,' than ',i5)
    2124  format(' dist: closest approach distance of two helices',/,
         -  ' cc_dist: distance between two helix centers',/,
         -  ' CAs: the atom numbers of the alpha carbons closest ',
         -  ' to the',/,4x,'point on the helix axis nearest to the other ',
         -  'helix',/,' ang: The angle between two helix axes',/,' dhang: ',
         -  'The torsion angle formed by two helix axes around the line ',
         -  'perpendicular to them',/,' TM: transmembrane helix',/,
         -  'IN: intracellular, EX: extracellular')
    2125  format(' A solvent is considered to be the interface if',/,
         -  ' (a) its CV w.r.t the complex is > ',f6.4,/,
         -  ' (b) Dist(R1,R2) <',f6.1,' where R1, R2 are the two nearest ',
         -  'solute heavy atoms',/,
         -  ' (c) When Dist(R1,R2) <= 6 A, the angle R1-SLV-R2 > ',f10.2,/,
         -  ' (d) When Dist(R1,R2) >  6 A, the angle R1-SLV-R2 > ',f10.2,/,
         -  ' (e) The ratio of the CVs w.r.t the two solute molecules < ',
         -  f6.3,/,' (e) There is at least one solvent or solute atom ',
         -  'within ',f5.1,' A')
    2126  format(' Number of filtered solvents found=',i7)
    2127  format(' Analysis of ',a,'s')
    2128  format(' Mutually proximal atom pairs are dropped if their ',
         -  'distance is > ',f4.1,' A')
    2129  format(' Helix',i3,' direction established from the reference ',
         -  'structure as the ',a,' axis',a)
    2130  format(' Angle between the ',a,'-axis and the helix=',f5.1)
    2131  format('CONECT',2i5)
    2132  format(' Residue list selected is not contiguous - RMSF ',
         -  'calculations will be skipped')
    2133  format(' ERROR: plot range is not within the residue range [',
         -  i6,',',i6,']')
    
    2140  format(' Potentially a hydrogen bond is formed between')
    2141  format(10x,'Calculation of all hydrogen bonds',//,
         -  ' Each line describes a hydrogen bond, formed between ',
         -  ' acceptor A',/,' and donor H (bonded to the heavy atom D) ',
         -  'as follows:',/,5x,'Atom number, atom name, residue number, ',
         -  'residue name for donor atom H',/,
         -  5x,'Atom number, atom name, residue number, ',
         -  'residue name for acceptor atom A',/,
         -  5x,'Hydrogen bond length rHA; hydrogen bond angle D-H-A; and ',
         -  'distance rDA;',/,5x,'Hydrogen bond type X-Y, where X and Y ',
         -  'can be B, S, V, ?',/,5x,'indicating backbone, sidechain, ',
         -  'solvent or undetermined origin',/,
         -  ' For each hydrogen, only the two shortest bond will be ',
         -  'retained',/)
    2142  format('   all ',a2,' atoms within',f6.2,' A of a hydrogen')
    2143  format('   all ',a2,' atoms within',f6.2,' A of a water oxygen')
    2148  format('Number of random points/cell=',i7,
         -  '    Correlation coefficient=',f6.3)
    2149  format(/,' Distribution of the different SS elements:',/,
         -  (1x,a1,' : ',a))
    2150  format(1x,'Residue #',9(4x,a1))
    2151  format(i10,9i5)
    2152  format('Number of colors ( <',i2,')')
    2153  format(' Number of atoms used for ',a,' calculation:',i6,
         -  ' (out of',i6,')',a,' atom list:'/,(15i5))
    2154  format(' All atoms are used for ',a,' calculation')
    2155  format(i5,' RMSF(Cav)=',f6.2,' RMSF(Cref)=',f6.2,' SD=',f6.2,a,
         -  'CI=',f6.2)
    2156  format(' NOTE: residue indices on the plot are residue SEQUENCE',
         -  ' numbers',/,7x,'- see the map to the reside and segment ',
         -  'numbers on the',/,7x,'output of the bond history calculation')
    2157  format(' Number of frames read in a block=',i5)
    2158  format(' Backbone ',a,' rn=',i5,' res=',a,i5,
         -  ' Atnos for CA, C, N=',3i6)
    2159  format(' Specification of helix # ',i2)
    2160  format(1x,a,'elix #',i2)
    2161  format(' ERROR: number of data items (',i5,') exceeds limit (',
         -  i5,')',/,' - reduce the number of helices or increase the ',
         -  'parameter MAXCOPY1')
    2162  format('HX',i2,'-HX',i2,':',a,' dist.',a,'(',a2,')')
    2163  format(' HX#',i3)
    2164  format(' Filtering criterion: ',a)
    2165  format(' Solute solvent distance threshold=',f6.1)
    2166  format(' CV threshold=',f6.1,' CV calculation radius=',f6.1)
    2167  format(/,' Filtering solvents')
    2168  format(' WARNINGN: number of solvent atoms (',i7,'-',i6,') is ',
         -  'not divisible',/,' by the number of atoms/solvent molecule (',
         -  i3,')')
    2169  format('HX',i2,'-HX',i2,' angle         ')
    2170  format('HX',i2,'-HX',i2,' torsion angle ')
    2171  format('HX',i2,' rot vs HX',i2)
    2172  format(/' HELIX',i3,' statistics')
    2173  format(/,' Config #',i6,' (inp #: ',i10,')',a,
         -  'Ref #',i6,' (inp #:',i10,')')
    2174  format('HX',i2,'-HX',i2,' (',a2,'):')
    2175  format(' Trajectory frame ',i6,' Energy=',e12.5)
          end
          subroutine progress_rep(nframe,nframe2d,nframesign)
          nfr=max0(nframe,nframe2d)
          if (mod(nfr,nframesign) .eq. 0) then
            iperc=nfr/nframesign
            if (iperc .lt. 10) write (6,8099) iperc
          end if
    8099  format(' Trajectory scan',i3,'0% done')
          end
          subroutine set_hbondlims(hblimfac_def,hblimfac,angmin_def,
         -  angmin,iout)
          call getreal('H-bond length tolerance factor',30,hblimfac_def,
         -  hblimfac,1,23)
          call getreal('A-H...B angle minimum accepted',30,angmin_def,
         -  angmin,1,24)
          if (iout .gt. 0) write (iout,1000) hblimfac,angmin
          return
    1000  format(' Hydrogen-bond is defined with hblimfac=',f5.2,
         -  ' and H-bond angle minimum=',f5.1)
          end
          subroutine selectconf(numsel,ninconf,ifirst,increment,
         -  iconfsel,nextconfsel,nframeref,icsel,ifail,maxconfsel)
          dimension iconfsel(maxconfsel)
          if (numsel .eq. 0) then
            if (ninconf .ge. ifirst .and.
         -    mod(ninconf-ifirst,increment) .eq. 0) icsel=1
          else
            if (ninconf .eq. iconfsel(nextconfsel)) then
              icsel=1
              nextconfsel=nextconfsel+1
            else if (ninconf .gt. iconfsel(numsel)) then
              if (nframeref .le. 1)
         -      write (6,2060) ninconf,iconfsel(numsel)
              ifail=1
            end if
          end if
          return
    2060  format(' Structure read (',i9,') is beyond the last structure ',
         -  'requested:',i9,/,' Trajetory scan stopped')
          end
          subroutine adjust_xtraj(xtraj,ifirst,ilast,increment,fact,iadjust)
          dimension xtraj(ilast)
          if (iadjust .eq. 0) return
          iadjust=0
          i=0
          if (ifirst .gt. 1 .or. increment .gt. 1) then
            do ii=ifirst,ilast,increment
              i=i+1
              xtraj(i)=i*increment*fact
              MAXI=i
            end do
          end if
          return
          end
          subroutine save_traj_lim(ifirst,ilast,incr,i12)
          character*200 trajnam12
          common /trajname/ trajnam12(2),ltrajnam12(2),ifirsttraj12(2),
         -  ilasttraj12(2),incrementtraj12(2)
          ifirsttraj12(i12)=ifirst
          ilasttraj12(i12)=ilast
          incrementtraj12(i12)=incr
          return
          end
          subroutine write_traj_lim(iout,label,llabel,i12,incr,iplot)
          character*(*) label
          character*200 trajnam12
          common /trajname/ trajnam12(2),ltrajnam12(2),ifirsttraj12(2),
         -  ilasttraj12(2),incrementtraj12(2)
          dimension llab12(2)
          character*8 lab12(2)
          data lab12 /'T','Second t'/,llab12 /1,8/
          if (iplot .eq. 0) then
            if (llabel .gt. 0) write (iout,1000) label(1:llabel)
            write (iout,1001) lab12(i12)(1:llab12(i12)),
         -    trajnam12(i12)(1:ltrajnam12(i12)),
         -    ifirsttraj12(i12),ilasttraj12(i12),incrementtraj12(i12)
          else
            if (incrementtraj12(i12) .gt. 1) then
              write (iout,1002) lab12(i12)(1:llab12(i12)),
         -      trajnam12(i12)(1:ltrajnam12(i12)),
         -      ifirsttraj12(i12),ilasttraj12(i12),incrementtraj12(i12)
            else
              write (iout,1003) lab12(i12)(1:llab12(i12)),
         -      trajnam12(i12)(1:ltrajnam12(i12)),
         -      ifirsttraj12(i12),ilasttraj12(i12)
            end if
          end if
          incr=incrementtraj12(i12)
          return
    1000  format(1x,a)
    1001  format(1x,a,'rajectory analyzed: ',a,' Frames',i7,' - ',i6,
         -  ' Increment:',i5)
    1002  format('(',a,'rajectory analyzed: ',a,' Frames',i7,' - ',i6,
         -  ' Increment:',i5,') show')
    1003  format('(',a,'rajectory analyzed: ',a,' Frames',i7,' - ',i6,
         -  ') show')
          end
          subroutine torslistinp(ixtor1234,talab,ltalab,ntang,inpcrdtyp,
         -  ioins,line,index,n,nslt,nresslt,iatnum,nneig,ineig,nhneig,ixres,
         -  ixresno,nsegm,isegno,ifres,ilres,iresno,indexs,listrefres,
         -  irescol1,irescol2,inamcol1,inamcol2,maxng,maxrsd,maxrec,maxtors)
          dimension ixtor1234(4,maxtors),ltalab(maxtors)
          dimension nneig(n),ineig(maxng,n),iatnum(n),nhneig(n),index(n),
         -  ixres(maxrec),ixresno(maxrsd),isegno(maxrec),ifres(maxrsd),
         -  ilres(maxrsd),iresno(maxrec),indexs(maxrec),listrefres(maxrsd)
          character*30 talab(maxtors)
          character* 132 line(maxrec)
          character*1 ansrun
          character*4 atnami,atnamj
          character*8 resnam
          character*38 question
          call quiz(ansrun,iansrun,' ',' ',1,'torsion list input',18,0,
         -    5,6,0)
          nohrot=0
          if (iansrun .gt. 3) call askyn(
         -    'Do you want to include torsions moving hydrogens only',53,
         -    0,-1,nohrot,0,0)
          ic1=inamcol1
          ic2=inamcol2
          ir1=irescol1
          ir2=irescol2
          nrescol=ir2-ir1+1
          call getresrange(nsegm,indexs,isegno,ixres,iresno,ifres,
         -  'residue to plot',15,nresslt,nslt,irefres1,irefres2,1,
         -  irefseg1,irefseg2,listrefres,nrefres,nrefrange,0,0,maxrsd,
         -  maxrec,111)
          if (iansrun .lt. 5) then
            ntang=0
            do ia=ifres(irefres1),ilres(irefres2)
              resnam(1:nrescol)=line(index(ia))(ir1:ir2)
              call leftadjust4(line(index(ia))(ic1:ic2),atnami)
              do j=1,nneig(ia)
                ja=ineig(j,ia)
                nhneig0=nhneig(ja)*nohrot
                if (ia .lt. ja .and. nneig(ia)-nhneig(ia) .gt. 1 .and.
         -          nneig(ja)-nhneig0 .gt. 1) then
                  call leftadjust4(line(index(ja))(ic1:ic2),atnamj)
                  call checktorbond(resnam,ixres(ia),ixres(ja),atnami,
         -          atnamj,fixbond,ipep,ican,icac,issb)
                  iskiptor=0
                  if (ican .eq. 1 .and. ixres(ia) .eq. irefres1 .or.
         -            icac .eq. 1 .and. ixres(ia) .eq. irefres2) iskiptor=1
                  ihfound=0
                  if (iatnum(ia) .eq. 1 .or. iatnum(ja) .eq. 1) then
                    write (6,2002) ia,resnam(1:nrescol),atnami,ja,
         -            line(index(ja))(ir1:ir2),atnamj
                    ihfound=1
                  end if
                  if (fixbond+ihfound+iskiptor .eq. 0) then
                    dloop=30.0
                    dtor=30.0
                    if (iansrun .eq. 4
         -            .or. (iansrun .eq. 1 .and. ipep .eq. 0)
         -            .or. (iansrun .eq. 2 .and. ipep+ican+icac+issb .eq. 0)
         -            .or. (iansrun .eq. 3 .and. ican+icac .eq. 1)) then
                      if (ntang .eq. maxtors) then
                        write (6,1000) maxtors
                        go to 100
                      end if
                      ntang=ntang+1
                      do ii=1,nneig(ia)
                        iaa=ineig(ii,ia)
                        call leftadjust4(line(index(iaa))(ic1:ic2),atnami)
                        if (iatnum(iaa)*nohrot .ne. 1 .and.
         -                 (iansrun .ne. 3 .or. atnami .ne. 'CB  ')) then
                          ixtor1234(2,ntang)=ia
                          ixtor1234(3,ntang)=ja
                          if (ican .eq. 1) then
                            do jj=1,nneig(ia)
                              iaa=ineig(jj,ia)
                              if (iatnum(iaa) .eq. 6 .and. iaa .ne. ja)
         -                      ixtor1234(1,ntang)=iaa
                            end do
                            do jj=1,nneig(ja)
                              jaa=ineig(jj,ja)
                              call leftadjust4(line(index(jaa))(ic1:ic2),
         -                      atnamj)
                              if (atnamj(1:4) .eq. 'C   ')
         -                      ixtor1234(4,ntang)=jaa
                            end do
                          else if (icac .eq. 1) then
                            do jj=1,nneig(ia)
                              iaa=ineig(jj,ia)
                              if (iatnum(iaa) .eq. 7) ixtor1234(1,ntang)=iaa
                            end do
                            do jj=1,nneig(ja)
                              jaa=ineig(jj,ja)
                              if (iatnum(jaa) .eq. 7) ixtor1234(4,ntang)=jaa
                            end do
                          else
                            do jj=1,nneig(ja)
                              jaa=ineig(jj,ja)
                              if (iatnum(jaa)*nohrot .ne. 1 .and.
         -                        jaa .ne. ia .and. iaa .ne. ja .and.
         -                        iaa .ne. jaa) then
                                ixtor1234(1,ntang)=iaa
                                ixtor1234(4,ntang)=jaa
                              end if
                            end do
                          end if
                          if (ixtor1234(1,ntang)*ixtor1234(1,ntang) .eq. 0)
         -                  then 
                            print *,' Peptide bond C- or N+ is missing'
                            go to 100
                          end if
                        end if
                      end do
                    end if
                  end if
                end if
              end do
            end do
    100      print *,'Number of torsion angles generated=',ntang
          else
            call getint('Number of torsions to track',27,0,1,49,ntang,0)
            do it=1,ntang
    8004      question='Angle   , atomindices ( 4 numbers )'
              nerr=0
              write (question(6:8),2043) it
              call getintline(question,35,1,nslt,ixtor1234(1,it),4,0)
              if (inpcrdtyp .le. ioins)
         -      write (6,2039) 'T',(ixtor1234(k,it),
         -        line(index(ixtor1234(k,it)))(inamcol1:inamcol2),
         -        line(index(ixtor1234(k,it)))(irescol1:irescol2),k=1,4)
              nerr=0
              do k=2,4
                if (isbonded(ixtor1234(k-1,it),ixtor1234(k,it),
         -          nneig,ineig,n,maxng) .eq. 0) then
                  write (6,2066) (ixtor1234(kk,it),kk=k-1,k),' NOT '
                  nerr=nerr+1
                end if
              end do
              do k=3,4
                if (isbonded(ixtor1234(k-2,it),ixtor1234(k,it),
         -          nneig,ineig,n,maxng) .eq. 1) then
                  write (6,2066) (ixtor1234(kk,it),kk=k-1,k),' '
                  nerr=nerr+1
                end if
              end do
              if (isbonded(ixtor1234(1,it),ixtor1234(4,it),
         -        nneig,ineig,n,maxng) .eq. 1) then
                write (6,2066) ixtor1234(1,it),ixtor1234(4,it),' '
                nerr=nerr+1
              end if
              if (nerr .gt. 0) then
                call askyn('Do you want to use this angle',29,1,-1,iok,
         -        0,0)
                if (iok. eq. 0) go to 8004
              end if
            end do
          end if
          do it=1,ntang
            call blankout(talab(it),1,30)
            if (inpcrdtyp .le. ioins) write (talab(it),2069)
         -    (line(index(ixtor1234(k,it)))(inamcol1:inamcol1+3),k=1,3),
         -    line(index(ixtor1234(3,it)))(irescol1:irescol2),
         -    ixresno(ixres(ixtor1234(3,it))),
         -    line(index(ixtor1234(4,it)))(inamcol1:inamcol1+3)
            ltalab(it)=30
          end do
          return
    1000  format(' ERROR: maximum number of torsions (',i4,') exceeded',/,
         -  'Redimension Simulaid with increased value of the parameter ',
         -  'MAXCOPY')
    2002  format(' WARNING: bond ',i5,' (',a,1x,a,') - ',i5,' (',a,1x,a,
         -  ') inlcudes a hydrogen',/,
         -  10x,'Torsion dropped - check the solute geometry')
    2043  format(i3)
    2039  format(1x,a1,':',i5,' (',a,1x,a,')',3(' -',i5,' (',a,1x,a,')'))
    2066  format(' WARNING: atoms',i6,' and',i6,' are',a,'bonded',/,
         -  ' You can create bonds with the Edit option')
    2069  format(2(a4,'-'),a4,'(',a4,i5,')-',a4)
          end
          subroutine settorslim(mask,molsltlim,nslt,nmolslt,iresno,segid4)
          dimension mask(nslt),molsltlim(3,nmolslt),iresno(nslt)
          character*4 segid4(nmolslt)
          call askyn('Do you want to set residue limits for torsions',46,
         -  1,-1,limres,0,0)
          if (limres .gt. 0) then
            call zeroiti(mask,0,nslt)
            if (nmolslt .gt. 1) write (6,2000) (i,segid4(i),i=1,nmolslt)
            idone=0
            do while (idone .eq. 0)
              imol=1
              if (nmolslt .gt. 1) then
                call getint('Molecule number (0 to finish)',29,imol,1,
         -        nmolslt,imol,000)
                if (imol .eq. 0) idone=1
              end if
              if (imol .gt. 0) then
                molf=molsltlim(1,imol)
                moll=molsltlim(2,imol)
    100         call getrange(ifst,iresno(molf),ilst,iresno(moll),1,0,
         -       'residue to move (0 to finish)',29,iresno(moll),0)
                if (ifst*ilst .gt. 0) then
                  iaf=molf
                  do while (iresno(iaf) .lt. ifst .and. iaf .lt. moll)
                      iaf=iaf+1
                  end do
                  if (iresno(iaf) .ne. ifst) then
                    write (6,*) 'ERROR: residue ID ',ifst,' is not found'
                    go to 100
                  end if
                  ial=iaf
                  do while (iresno(ial) .lt. ilst .and. ial .lt. moll)
                    ial=ial+1
                  end do
                  if (iresno(ial) .ne. ilst) then
                    write (6,*) 'ERROR: residue ID ',ilst,' is not found'
                    go to 100
                  end if
                  do while (iresno(ial) .eq. ilst .and. ial .lt. moll)
                    ial=ial+1
                  end do
                  if (iresno(ial) .ne. ilst) ial=ial-1
                  write (6,2001) ifst,ilst,iaf,ial
                  do ia=iaf,ial
                    mask(ia)=1
                  end do
                else
                  idone=1
                end if
              end if
            end do
          else
            do ia=1,nslt
              mask(ia)=1
            end do
          end if
          return
    2000  format(' Molecule/segment IDs:',(5(i3,1x,a4)))
    2001  format(' Residue range [',i5,',',i5,'] includes the atom range [',
         -  i7,',',i7,']')
          end
          subroutine torsinp(nconfig,inpcrdtyp,itform,extnam,analfile,
         -  inpfile,namleni,line,index,n,nslt,c,iatnum,ifchrg,nneig,nneiga,
         -  nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,isegno,ixres,
         -  ibnd,indexo,naslv,islvw,innlist,molresflag,hblimfac,angmin,
         -  irescol1,irescol2,iresncol1,iresncol2,inamcol1,inamcol2,mask,
         -  itemp1,itemp2,pi,radtodeg,maxrepconf,maxng,maxbox,maxrsd,maxrec)
          dimension nneig(n),ineig(maxng,n),iatnum(n),ifchrg(n),c(3,n),
         -  nhbneig(n),nneiga(n),nhneig(n),nnneig(n),ncneig(n),nsneig(n),
         -  npneig(n),index(n),indexo(n),isegno(n),ixres(n),
         -  molresflag(maxrsd),ibnd(maxbox,maxrec),mask(maxrec),
         -  itemp1(maxrec),itemp2(maxrec)
          character*1 ansrun
          character*4 extnam,lan(4),atnami,atnamj
          character*8 tname,resnam,rn
          character*200 inpfile,analfile
          character* 132 line(maxrec)
          character*2 iatnm2
          common /atnam/ aw(99),nval(99),nvalmax(99),mmofan(99),
         -  mmatno(64),iatnm2(99)
          character*11 trajformatname
          common /trajectory/ nmmccheck,iftrajtyp(6),trajformatname(6)
          character*200 trajnam,trajnam2
          common /trajname/ trajnam,trajnam2,ltrajnam,ltrajnam2,ifirsttraj,
         -  ifirsttraj2,ilasttraj,ilasttraj2,incrementtraj,incrementtraj2
          character*4 namfcg
          character*4 tanames
          character*8 tnames
          common /tordat/ ntorn,tanames(4,28),tnames(28)
          common /connatdat/ ramax(99),ramax2(99),hlimfac,ianfg(99),
         -  namfcg(100),nrmw
          common /graphics/ npixx,npixy,maxpixx,maxpixy,idwmain,idwplot,
         -  wx,wy,wz,wxdr
          common /rotmat/ matrot0(4,4),matrot(4,4),nomat0
          common /columnlim/ incol(19),iidcol(19),iialtcol(19),iiinscol(19),
         -  iinamcol(2,19),iirescol(2,19),iiccol(2,19),iiresncol(2,19),
         -  iiseqncol(2,19),iisegcol(2,19),iiresidcol(2,19),iiqcol(2,19),
         -  iipotcol(2,19),iiocccol(2,19),iichemcol(2,19)
          character*5 crdext
          common /iotypes/ iocha,iochaex,iobpdb,iocpdb,ioa3pdb,ioa4pdb,
         -  iommod,iommc,iommc4,iogro,iomol2,iomae,iocif,ioxxx,ioins,
         -  ionxyz,iosxyz,iosxyzrq,iograsp,iofull,lext(19),crdext(19)
          parameter (MAXHX=50)
          common /prokink/ icab(MAXHX),icaa(MAXHX),icb(MAXHX),ica(MAXHX),
         -  inb(MAXHX),ina(MAXHX),icapr,icpr,inpr,nra,nrb,icbpr,icgpr,icdpr,
         -  iprintpk
          parameter (MAXFRAMES=50000,MAXCOPY=600)
          parameter (MAXCOPY6=MAXCOPY-6)
          common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
         -  increment,increment2,bdxy(2,MAXFRAMES),wbxy(2,MAXFRAMES),
         -  fsxy(2,MAXFRAMES),wfsxy(2,MAXFRAMES),psxy(2,MAXFRAMES),
         -  turnpr(2,MAXFRAMES),scalardat(2,MAXFRAMES,MAXCOPY6),
         -  x0(MAXCOPY),y0(MAXCOPY),nxselres,ixselres(MAXCOPY)
          nnamcol=inamcol2-inamcol1+1
          if (nconfig .eq. 1) then
            call quiz(ansrun,nntyp,' ',' ',0,'Bond information source',23,0,
         -    5,6,00)
            if (nntyp .gt. 1 ) then
              call top_to_bond(nntyp,nneig,nhneig,ineig,iatnum,n,0,
         -      itemp1,itemp2,maxng,maxrec)
            else
              print *,'Bonds are defined from the coordinates read'
              call nnlist(nslt,islvw,naslv,n,iatnum,ifchrg,c,nneig,nneiga,
         -      nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,line,
         -      irescol1,irescol2,inamcol1,inamcol2,index,nconfig,innlist,
         -      molresflag,hblimfac,angmin,0,ibnd,indexo,isegno,ixres,
         -      maxrepconf,0,0,radtodeg,0,maxbox,maxng,maxrsd,maxrec)
            end if
            namleno=0
            call quiz(ansrun,iansrun,' ','syntax for',10,
         -    'torsion input generation',24,0,5,6,0)
            if (ansrun .eq. 't') then
              itform=2
              extnam='.mmt'
            else if (ansrun .eq. 'p') then
              itform=3
              extnam='.mmp'
            else if (ansrun .eq. 'r') then
              itform=4
              extnam='.mcs'
            else if (ansrun .eq. 'i') then
              itform=5
              extnam='.mcp'
            else if (ansrun .eq. 'g') then
              itform=6
              extnam='.mcg'
            end if
            if (extnam(2:3) .eq. 'mc')
         -    call getint('Maximum number of terminal hydrogens to rotate',
         -      46,0,1,3,maxhrot,133)
            analfile=inpfile
            if (namleno .ne. 0) close (40)
            namleno=namleni
            analfile(namleno-3:namleno)=extnam
            call openfile(40,0,'analysis',8,'new',analfile,namleno,
         -    notfnd,0,1,1,0,0)
          else
            write (40,2055) nconfig
          end if
          ic1=inamcol1
          ic2=inamcol2
          ir1=iirescol(1,inpcrdtyp)
          ir2=iirescol(2,inpcrdtyp)
          nrescol=ir2-ir1+1
          if (itform .ge. 4 .and. itform .le. 6) then
            if (nconfig .eq. 1) write (6,2001) 'MMC',analfile(1:namleno)
            ntorwr=0
            do ia=1,n
              if (iatnum(ia) .gt. 1 .and. nneig(ia) .gt. 1 .and.
         -      (nneig(ia)-nhneig(ia) .gt. 1 .or. nhneig(ia) .le. maxhrot)
         -      .and. mask(ia) .gt. 0) then
                resnam(1:nrescol)=line(index(ia))(ir1:ir2)
                call leftadjust4(line(index(ia))(ic1:ic2),atnami)
                do j=1,nneig(ia)
                  ja=ineig(j,ia)
                  if (iatnum(ja) .gt. 1 .and. nneig(ja) .gt. 1 .and.
         -           ia .lt. ja .and. (nneig(ja)-nhneig(ja) .gt. 1 .or.
         -             nhneig(ja) .le. maxhrot) .and. mask(ja) .gt. 0) then
                    call leftadjust4(line(index(ja))(ic1:ic2),atnamj)
                    call checktorbond(resnam,ixres(ia),ixres(ja),atnami,
         -            atnamj,fixbond,ipep,ican,icac,issb)
                    if (fixbond .eq. 0) then
                      dloop=30.0
                      dtor=30.0
                      if (itform .eq. 6 .or.
         -              (itform .eq. 4 .and. ipep+ican+icac+issb .eq. 0)
         -              .or. (itform .eq. 5 .and. ipep .eq. 0)) then
                        ntorwr=ntorwr+1
                        call readint(line(index(ia)),iresncol1,iresncol2,
         -                irna,2,1,irerr)
                        write (40,2051) ia,ja,dloop,dtor,ntorwr,
         -                irna,line(index(ia))(ir1:ir2),atnami,
         -                line(index(ja))(ir1:ir2),atnamj
                      end if
                    end if
                  end if
                end do
              end if
            end do
            if (nconfig .le. maxrepconf)
         -    print *,'Number of torsion angles written out=',ntorwr
          else
            if (nconfig .eq. 1)
         -    write (6,2001) 'Macromodel',analfile(1:namleno)
            ntorwr=0
            do ia=1,nslt
              do j=1,nneig(ia)
                ja=ineig(j,ia)
                if (ia .lt. ja .and. mask(ia)*mask(ja) .gt. 0) then
                  do ii=1,nneig(ia)
                    iaa=ineig(ii,ia)
                    do jj=1,nneig(ja)
                      jaa=ineig(jj,ja)
                      if (jaa .ne. ia .and. iaa .ne. ja
         -                .and. iaa .ne. jaa) then
                        tors=dihangl(c,iaa,ia,ja,jaa,1,maxrec)*(180.0/pi)
                        tname='xxxxx'
                        if (inpcrdtyp .le. ioins) then
                          call leftadjust4(line(index(iaa))(ic1:ic2),lan(1))
                          call leftadjust4(line(index(ia))(ic1:ic2),lan(2))
                          call leftadjust4(line(index(ja))(ic1:ic2),lan(3))
                          call leftadjust4(line(index(jaa))(ic1:ic2),lan(4))
                          do i=1,ntorn
                            do k=1,4
                              if (lan(k) .ne. tanames(k,i)) go to 9011
                            end do
                            tname=tnames(i)
                            go to 9013
    9011                    do k=1,4
                              if (lan(4-k+1) .ne. tanames(k,i)) go to 9012
                            end do
                            tname=tnames(i)
                            go to 9013
    9012                    continue
                          end do
    9013                  if (itform .eq. 3) then
                            if (tname .eq. 'xxxxx' .or. tname .eq. 'omega')
         -                    then
                              tname='        '
                            else
                              resnam='        '
                              resnam(1:nrescol)=line(index(ia))(ir1:ir2)
                              call leftadjustn(resnam,rn,8)
                              if (rn .eq. 'PRO     ' .and.
         -                      (tname .eq. 'phi      ' .or.
         -                       tname .eq. 'chi1    '
         -                      .or. tname .eq. 'chi2    '))tname='        '
                            end if
                          end if
                          if (tname .ne. '        ') then
                            write (40,2053) iaa,ia,ja,jaa,tname,
         -                    line(index(iaa))(ic1:ic2),
         -                    line(index(iaa))(ir1:ir2),
         -                    line(index(ia))(ic1:ic2),
         -                    line(index(ia))(ir1:ir2),
         -                    line(index(ja))(ic1:ic2),
         -                    line(index(ja))(ir1:ir2),
         -                    line(index(jaa))(ic1:ic2),
         -                    line(index(jaa))(ir1:ir2),tors
                            ntorwr=ntorwr+1
                          end if
                        else
                          write (40,2054) iaa,ia,ja,jaa,tname
                          ntorwr=ntorwr+1
                        end if
                      end if
                    end do
                  end do
                end if
              end do
            end do
            if (nconfig .le. maxrepconf)
         -    print *,'Number of torsion angles written out=',ntorwr
            if (itform .eq. 3)
         -    print *,'Examine carefully if all the C and N terminal ',
         -    'torsions are present'
          end if
          return
    1000  format(a)
    2001  format(1x,a,' torsion input is written to ',a)
    2051  format(2i5,2f10.4,i5,'    1       1.0     180.0 !',
         -  ' iresa=',i5,1x,a4,1x,a4,'-',a4,1x,a4)
    2053  format(' ITOR',i8,3i7,'     0.0000   180.0000',23x,'!',a5,1x,
         -       3('(',a4,1x,a4,')-'),'(',a4,1x,a4,')',
         -  ' ta=',f7.1)
    2054  format(' ITOR',i8,3i7,45x,a4)
    2055  format(1x,79('-'),/,' Torsion input from configuration # ',i5)
          end
          subroutine top_to_bond(nntyp,nneig,nhneig,ineig,iatnum,n,inp,
         -  itemp1,itemp2,maxng,maxrec)
          dimension nneig(n),nhneig(n),ineig(maxng,n),iatnum(n),
         -  itemp1(maxrec),itemp2(maxrec)
          dimension i8(8)
          character*1 ansrun
          character*25 read_format
          character*80 inpfiletmp,liner
          if (nntyp .eq. 0) then
            call quiz(ansrun,nntyp,' ',' ',0,'Bond information source',23,
         -    0,5,6,00)
            if (nntyp .eq. 1) return 
          end if
          if (nntyp .eq. 2) then
            if (inp .eq. 0) then
              inp_top=62
              nerr=1
              do while (nerr .gt. 0)
                namlenn=0
                call openfile(inp_top,0,'PSF',3,'old',inpfiletmp,namlenn,
         -        notfnd,3,1,1,0,0)
                call find_n_psf(inp_top,liner,nerr,n,natspsf,'!NATOM',6)
                if (n .ne. natspsf) then
                  print *,'Number of atoms in the PSF file (',natspsf,
         -          ' differs from number of atoms (',n,')'
                  if (natspsf .gt. n) then
                    call askstop(1)
                  else
                    stop
                  end if
                end if
              end do
            else
              inp_top=inp
              rewind inp_top
            end if 
            call find_n_psf(inp_top,liner,nerr,0,natbond,'!NBOND',6)
            call checkdim(natbond,maxrec,'MAXREC',6,'number of bonds',15,0)
            call zeroiti(nneig,0,natspsf)
            call zeroiti(nhneig,0,natspsf)
            nwr=natbond
            do while (nwr .gt. 0)
              nb=min0(4,nwr)
              read (inp_top,1108,err=605) (i8(i),i=1,2*nb)
    605       do i=1,nb
                i1=i8(2*(i-1)+1)
                i2=i8(2*i)
                nneig(i1)=nneig(i1)+1
                nneig(i2)=nneig(i2)+1
                ineig(nneig(i1),i1)=i2
                ineig(nneig(i2),i2)=i1
                if (iatnum(i1) .eq. 1) nhneig(i2)=nhneig(i2)+1
                if (iatnum(i2) .eq. 1) nhneig(i1)=nhneig(i1)+1
              end do
              nwr=nwr-nb
            end do
            print *,'Number of bonds read:',natbond
            do i=1,n
            end do
          else if (nntyp .eq. 3) then
    611     if (inp .eq. 0) then
              inp_top=62
              notfnd=1
              do while (notfnd .gt. 0)
                namlenn=0
                call openfile(inp_top,0,'TOP',3,'old',inpfiletmp,namlenn,
         -        notfnd,3,1,1,0,0)
              end do
            else
              inp_top=inp
              rewind inp_top
            end if
            call find_ambertyp(inp_top,'%FLAG BONDS_INC_HYDROGEN',24,
         -    read_format,lread_format)
            call zeroiti(nneig,0,n)
            call zeroiti(nhneig,0,n)
            ierrtop=1
            ic=2
            do while (idigit(read_format(ic:ic),1) .eq. 1)
              ic=ic+1
            end do
            read (read_format(2:ic-1),*,err=613,end=613) ncol
            ic=ic+1
            icc=ic
            do while (idigit(read_format(ic:ic),1) .eq. 1)
              ic=ic+1
            end do
            read (read_format(icc:ic-1),*,err=613,end=613) ndig
            nr=0
            call read_amber_bonds(1,inp_top,nneig,nhneig,ineig,iatnum,
         -    read_format,lread_format,ndig,n,nr,liner,ierr,maxng,maxrec)
            if (liner(1:28) .eq. '%FLAG BONDS_WITHOUT_HYDROGEN') then
              read (inp_top,1000,end=613)
            else
              call find_ambertyp(inp_top,'%FLAG BONDS_WITHOUT_HYDROGEN',28,
         -      read_format,lread_format)
            end if
            call read_amber_bonds(2,inp_top,nneig,nhneig,ineig,iatnum,
         -    read_format,lread_format,ndig,n,nr,liner,ierr,maxng,maxrec)
            natbond=nr
            print *,'Number of bonds read:',natbond
            ierrtop=0
    613     if (ierrtop .eq. 1) then
              print *,'TOP file had some error'
              go to 611
            end if
          else
            print *,'PROGRAM ERROR: invalid NN list code:',nntyp
            stop
          end if
          if (inp .eq. 0) close (inp_top)
          return
    1000  format(a)
    1108  format(8i10)
          end
          subroutine read_amber_bonds(ih,inp_top,nneig,nhneig,ineig,iatnum,
         -  read_format,lread_format,ndig,n,nr,liner,ierr,maxng,maxrec)
          dimension nneig(n),nhneig(n),ineig(maxng,n),iatnum(n)
          character*25 read_format
          character*80 liner
          dimension i20(20)
          ierr=0
          i12=1
          i1=0
          call blankout(liner,1,80)
          do while (liner(1:5) .ne. '%FLAG')
            call blankout(liner,1,80)
            read (inp_top,1000,end=613) liner
            if (liner(1:5) .ne. '%FLAG') then
              call lastchar(liner,lc,80)
              nc=lc/ndig
              read (liner,read_format(1:lread_format),end=613)
         -      (i20(i),i=1,nc)
              do i=1,nc
                if (i12 .eq. 1) then
                  i1=i20(i)/3+1
                  i12=2
                else if (i12 .eq. 2) then
                  i2=i20(i)/3+1
                  nneig(i1)=nneig(i1)+1
                  nneig(i2)=nneig(i2)+1
                  ineig(nneig(i1),i1)=i2
                  ineig(nneig(i2),i2)=i1
                  if (iatnum(i1) .eq. 1) nhneig(i2)=nhneig(i2)+1
                  if (iatnum(i2) .eq. 1) nhneig(i1)=nhneig(i1)+1
                  i12=3
                  if (ih .eq. 1) then
                    if (iatnum(i1) .ne. 1 .and. iatnum(i2) .ne. 1) then
                      write (6,2000) i1,i2,' not'
                      ierr=1
                    end if
                  else 
                    if (iatnum(i1) .eq. 1 .or. iatnum(i2) .eq. 1) then
                      write (6,2000) i1,i2,' '
                      ierr=1
                    end if
                  end if
                else if (i12 .eq. 3) then
                  nr=nr+1
                  call checkdim(nr,maxrec,'MAXREC',6,'number of bonds',
         -          15,0)
                  i12=1
                end if
              end do
            end if
          end do
          if (i12 .ne. 1) then
            print *,'PROGRAM ERROR: bond list length is not a multiple ',
         -    'of three'
            stop
          end if
          return
    613   ierr=1
          return
    1000  format(a)
    2000  format(' (PROGRAM?) ERROR: bond ',i7,' - ',i7,' does',a,
         -  ' involve a hydrogen')
          end
          subroutine gethbanchordef(line,index,nslt,ixres,iresno,iatnum,
         -  indexa,indexo,nanchor,ianchor,iiq1,iiq2,inpcrdtyp,iobpdb,iocpdb,
         -  icharges,qmin,iw0,inamcol1,resnames,brslv,nrescol,segid4,
         -  molsltlim,nsegslt,isc,nneig,ineig,label,llabel,ianchor2,
         -  iselfanc,nosameseg,iqfsel2,iquizhelp,ifail,maxng,maxrsd,maxrec,
         -  maxanchorlist)
          dimension index(maxrec),indexa(maxrec),
         -  indexo(maxrec),ixres(maxrec),iresno(maxrec),iatnum(maxrec),
         -  isc(maxrec),ianchor(maxanchorlist),molsltlim(3,maxrsd),
         -  nneig(maxrec),ineig(maxng,maxrec)
          character*4 segid4(nsegslt)
          character*8 resnames(maxrsd)
          character* 132 line(maxrec)
          character*(*) brslv,label
          character*4 atnam,bridgeats(200)
          character*1 ansrun
          character*4 bbhbats(6)
          data bbhbats /'O   ',' O  ','H   ',' H  ','HN  ',' HN '/,
         -  nbbhbats /6/
          nanchor=0
          iqsel=0
          iallsel=0
          qmin=0.0
          iskipbb=0
          iselbb=0
          nanchorr=0
    9134  ansrun=' '
          iall=0
          do while (iall .eq. 0 .and. ansrun .ne. 'q')
            call quiz(ansrun,iansrun,' ',label,llabel,
         -    'hydrogen bond anchor atoms',26,0,5,6,iquizhelp)
            ifail=0
            if (ansrun .eq. 'b' .or. ansrun .eq. 't') then
              if (ansrun .eq. 'b') then
                do i=1,nbbhbats
                  bridgeats(i)=bbhbats(i)
                end do
                nbridgeats=nbbhbats
                iselbb=1
              else
                call getnamelist(bridgeats,4,nbridgeats,'Anchor atom',11,
         -        200)
              end if
              write (6,7731) label(1:llabel),(bridgeats(i),i=1,nbridgeats)
              do ia=1,nslt
                if (resnames(ixres(ia))(1:nrescol) .ne.
         -          brslv(1:nrescol)) then
                  atnam=line(index(ia))(inamcol1:inamcol1+3)
                  do it=1,nbridgeats
                    if (atnam .eq. bridgeats(it)) then
                      if (nanchor .lt. maxanchorlist) then
                        nanchor=nanchor+1
                        ianchor(nanchor)=ia
                        go to 9133
                      else
                        write (6,2144) maxanchorlist,label(1:llabel)
                        go to 9132
                      end if
                    end if
                  end do
    9133          continue
                end if
              end do
            else if (ansrun .eq. 'c') then
              iqsel=1
            else
              call definelist(ansrun,nslt,nanchor,ianchor,indexo,nsegslt,
         -      segid4,iresno,molsltlim,label,llabel,iallsel,maxanchorlist)
            end if
          end do
          if (iselbb .eq. 0)
         -  call askyn('Do you want to omit protein backbone atoms',42,
         -    1,-1,iskipbb,0,0)
          iqfsel=0
          if (iqsel .eq. 0 .and. icharges .gt. 0) then
            call askyn('Do you want to filter the list by charge',40,
         -    1,-1,iqfsel,0,0)
          end if
          if (iskipbb+iqfsel .gt. 0) iallsel=0
          if (iqsel+iqfsel .gt. 0) then
            if (iiq1 .gt. iiq2) then
              print *,'This input format has no charge information'
              go to 9134
            end if
            if (ischarmm(inpcrdtyp) .eq. 1)
         -    print *,'Charges are read from the WEIGHT column'
            if (inpcrdtyp .eq. iobpdb .or. inpcrdtyp .eq. iocpdb) print *,
         -    'Charges are read from the TEMPERATURE FACTOR column'
            call getreal('Minimum (absolute) charge for an anchor atom',44,
         -    999999.0,qmin,1,0)
            call zeroiti(indexa,0,nslt)
            nzrq=0
            qsum=0.0
            do ia=1,nslt
              if (resnames(ixres(ia))(1:nrescol) .ne.
         -        brslv(1:nrescol)) then
                call readreal(line(index(ia)),iiq1,iiq2,qa)
                if (qa .eq. 0.0) nzrq=nzrq+1
                qsum=qsum+qa
                if (qa .lt. -qmin .or.
         -        (qa .gt. qmin .and. iatnum(ia) .eq. 1)) indexa(ia)=-1
              end if
            end do
            if (nzrq .eq. nslt) then
              print *,'Input structure had all zero charges'
              write (6,2145)
              go to 9134
            else
              print *,'Sum of solute charges read=',qsum
              if (nslt .gt. 10 .and. abs(qsum) .gt. alog(float(nslt)))
         -      write (6,2145)
            end if
            if (iqsel .eq. 1) then
              do ia=1,nslt
                if (indexa(ia) .eq. -1) then
                  if (nanchor .lt. maxanchorlist) then
                    nanchor=nanchor+1
                    ianchor(nanchor)=ia
                  else
                    write (6,2144) maxanchorlist,label(1:llabel),' ',ia
                    go to 9132
                  end if
                end if
              end do
            else
              do iaa=1,nanchor
                if (indexa(ianchor(iaa)) .eq. 0) ianchor(iaa)=0
              end do
              ndel=0
              do ia=1,nanchor
                if (ianchor(ia) .eq. 0) then
                  ndel=ndel+1
                else
                  ianchor(ia-ndel)=ianchor(ia)
                end if
              end do
              nanchor=nanchor-ndel
              print *,'Number of anchor atoms filtered out=',ndel
              if (nanchor .eq. 0 .and. ndel .gt. 0) then
                print *,'PROBLEM: No anchor atoms were left after filtering'
                call askyn('Do you want to repeat the selection',35,
         -        1,+1,iselrep,0,0)
                if (iselrep .eq. 1) go to 9134
                ifail=1
                return
              end if
            end if
          end if
          call getanchormod(ianchor2,iselfanc,nosameseg,iallsel,iw0)
          if (qmin .ne. 0.0) write (iw0,*) 'Anchor atoms were filtered ',
         -  'by a charge threshold of ',qmin
          iqfsel2=0
          if (iqsel+iqfsel .gt. 0)
         -  call askyn(
         -    'Do you want to apply the charge filter to all atoms',51,
         -    1,+1,iqfsel2,0,0)
          if (iqfsel2 .eq. 1) write (iw0,*)
         -  'Charge filter will be applied to all putative anchor atoms'
          if (nanchor .gt. maxanchorlist) then
            write (6,2144) maxanchorlist,label(1:llabel),' ',ia
          end if
          ndelbb=0
          if (iskipbb .gt. 0) then
            do ia=1,nanchor
              ib=ianchor(ia)
              if (isc(ib) .eq. 0) then
                ndelbb=ndelbb+1
              else
                 ianchor(ia-ndelbb)=ianchor(ia)
              end if
            end do
            if (ndelbb .gt. 0) then
              nanchor=nanchor-ndelbb
              write (6,2147) 'backbone atoms',ndelbb
              write (iw0,2147) 'backbone atoms',ndelbb
            end if
          end if
          write (iw0 ,*) 'ANCHOR LIST before ALIPH removal'
          call condenselist(ianchor,nanchor,0,iw0 )
          ndelhc=0
          do ia=1,nanchor
            if (nneig(ia) .eq. 0) then
              ianchor(ia-ndelhc)=ianchor(ia)
            else
              iaa=ianchor(ia)
              if (iatnum(iaa) .eq. 6 .or.
         -      (iatnum(iaa) .eq. 1 .and. iatnum(ineig(1,iaa)) .eq. 6)) then
                ndelhc=ndelhc+1
              else
                ianchor(ia-ndelhc)=ianchor(ia)
              end if
            end if
          end do
          if (ndelhc .gt. 0) then
            nanchor=nanchor-ndelhc
            write (6,2147) 'backbone atoms',ndelhc
            write (iw0,2147) 'carbons and aliphatic hydrogens',ndelhc
          end if
          if (ndelbb+ndelhc .gt. 0) write (iw0,2148) nanchor
          do ia=1,nanchor
            indexa(ianchor(ia))=1
          end do
          return
    9132  if (nanchor .eq. 0) then
            print *,'PROBLEM: No anchor atoms were found'
            call askyn('Do you want to repeat the selection',35,
         -    1,+1,iselrep,0,0)
            if (iselrep .eq. 1) go to 9134
            ifail=1
            return
          end if
          return
    2144  format(' Progam is limited to ',i5,1x,a,' anchor ',
         -  'atoms.',/,' Redimension or break up the run ',a,/,
         -  ' Last solute atom used is the ',i6,'-th')
    2145  format(' Most likely, the charge field does not contain the ',
         -  'charges')
    2147  format(' Number of ',a,' filtered out=',i5)
    2148  format(' Number of hydrogen-bonding anchor atom left=',i5)
    7731  format(1x,a,' anchor atom names:',/,(10(a4,1x)))
          end
          subroutine printanchorlist(label,llabel,ibondtyp,ianchor,nanchor,
         -  indexa,indexov,nanchorr,nanchorn,line,index,iresno,isegno,
         -  segid4,inamcol1,inamcol2,irescol1,irescol2,iout,mxrsd,mxrec)
          dimension ianchor(nanchor),indexa(mxrec),indexov(mxrec),
         -  index(mxrec),iresno(mxrec),isegno(mxrec),llabel(6)
          character*(*) label(6)
          character*4 segid4(mxrsd)
          character*132 line(mxrec)
          write (iout,*)
          if (ibondtyp .ne. 5) then
            write (iout,*) '=== List of ',
         -    label(ibondtyp)(1:llabel(ibondtyp)),' anchor atom indices:'
            call condenselist(ianchor,nanchor,0,iout)
            write (iout,*) '=== List of ',
         -    label(ibondtyp)(1:llabel(ibondtyp)),' anchor atoms:'
            do ia=1,nanchor
              ib=ianchor(ia)
              write (iout,1000) ia,line(index(ib))(irescol1:irescol2),
         -      iresno(ib),segid4(isegno(ib)),
         -      line(index(ib))(inamcol1:inamcol2),ib
            end do
          else
            write (iout,1001) 'reference',nanchorr
            call condenselist(indexa,nanchorr,0,iout)
            write (iout,1001) 'neighbour',nanchorn
            call condenselist(indexov,nanchorn,0,iout)
          end if
          write (iout,*)
          return
    1000  format(i5,' Residue=',a,' (',i5,') Chain/seg=',a,' Atom=',a,
         -  ' (',i6,')')
    1001  format(' Number of ',a,' atoms=',i6,' List:')
          end
          subroutine gethphanchordef(line,index,nslt,iresno,iatnum,charge,
         -  indexa,indexn,indexo,nneig,ineig,nhneig,nhneigmin,nanchor,
         -  ianchor,ianchor2,iselfanc,nosameseg,iallheavy,iiq1,iiq2,
         -  inpcrdtyp,iobpdb,iocpdb,icharges,ibondtype,iw0,segid4,
         -  molsltlim,nsegslt,bondname,lbondname,ifail,maxneig,maxrec,
         -  maxanchorlist)
          dimension index(maxrec),charge(maxrec),iatnum(maxrec),
         -  indexa(maxrec),indexn(maxrec),indexo(maxrec),iresno(maxrec),
         -  ianchor(maxanchorlist),nneig(maxrec),ineig(maxneig,maxrec),
         -  nhneig(maxrec),molsltlim(3,nsegslt)
          character*4 segid4(nsegslt)
          character* 132 line(maxrec)
          character*1 ansrun
          character*(*) bondname
          nanchor=0
          iqsel=0
          qmin=0.0
          call zeroiti(indexa,0,nslt)
          nanchorr=0
    9134  ansrun=' '
          iall=0
          do while (iall .eq. 0 .and. ansrun .ne. 'q')
            call quiz(ansrun,iansrun,' ',' ',1,
         -    'hydrophobic/salt bridge/contact anchor atoms',44,0,5,6,75)
            ifail=0
            call definelist(ansrun,nslt,nanchorr,indexn,indexo,nsegslt,
         -    segid4,iresno,molsltlim,bondname,lbondname,iall,maxanchorlist)
          end do
          iqfsel=0
          if (icharges .gt. 0)
         -  call askyn('Do you want to filter the list by charge',40,
         -    1,-1,iqfsel,0,0)
          if (iqfsel .gt. 0) then
            if (icharges .eq. 1) then
              if (ischarmm(inpcrdtyp) .eq. 1)
         -      print *,'Charges are read from the WEIGHT column'
              if (inpcrdtyp .eq. iobpdb .or. inpcrdtyp .eq. iocpdb) print *,
         -      'Charges are read from the TEMPERATURE FACTOR column'
            end if
            call getreal('Maximum (absolute) charge for an anchor atom',
         -    44,999999.0,qmax,1,0)
            iall=0
          end if
          if (ibondtype .eq. 2) then
    8010    nhpc=0
            do ia=1,nslt
              if (iatnum(ia) .eq. 6 .and. nhneig(ia) .ge. nhneigmin) then
                indexa(ia)=-1
                nhpc=nhpc+1
              end if
            end do
            if (nhneigmin .gt. 0 .and. nhpc .eq. 0) then
              print *,'No H bonded to C was found'
              call askyn('Do you want to just use all carbons',35,1,+1,i0,0,
         -      0)
              if (i0 .eq. 1) then
                nhneigmin=0
                go to 8010
              else
                ifail=1
                return
              end if
            end if
            icofil=0
            if (iallheavy .eq. 0)
         -    call askyn('Do you want to filter out >C=O and C-OH carbons',
         -      47,1,+1,icofil,0,0)
            if (icofil .gt. 0) then
              do ia=1,nslt
                if (indexa(ia) .lt. 0) then
                  idrop=0
                  do in=1,nneig(ia)
                    inc=ineig(in,ia)
                    if (iatnum(inc) .eq. 8) then
                      if (nneig(inc) .eq. 1 .or. nhneig(inc) .gt. 0) idrop=1
                    end if
                  end do
                  if (idrop .eq. 1) indexa(ia)=0
                end if
              end do
            end if
          else
            do ia=1,nslt
              if (iatnum(ia) .ne. 1) indexa(ia)=-1
            end do
          end if
          do ja=1,nanchorr
            ia=indexn(ja)
            if (indexa(ia) .ne. 0) then
              iasel=1
              if (iqfsel .gt. 0) then
                if (icharges .eq. 1) then
                  call readreal(line(index(ia)),iiq1,iiq2,qa)
                else
                  qa=charge(ia)
                end if
                if (qa .lt. -qmax .or. qa .gt. qmax) iasel=0
              end if
              if (iasel .gt. 0) then
                indexa(ia)=-indexa(ia)
                if (nanchor .eq. maxanchorlist) then
                  print *,'Anchor list limit (',maxanchorlist,
         -          ') is reached'
                  nanchorr=ja
                else
                  nanchor=nanchor+1
                  ianchor(nanchor)=ia
                end if
              end if
            else if (ansrun .eq. 'l' .and. iallheavy .eq. 0) then
              print *,'NOTE: atom ',ia,' is not a hydrophobic carbon'
            end if
          end do
          if (nanchor .eq. 0) then
            print *,'PROBLEM: No anchor atoms were found'
            call askyn('Do you want to repeat the selection',35,
         -    1,+1,iselrep,0,0)
            if (iselrep .eq. 1) go to 9134
            ifail=1
            return
          end if
          call getanchormod(ianchor2,iselfanc,nosameseg,iall,iw0)
          do ia=1,nanchor
            indexa(ianchor(ia))=1
          end do
          return
          end
          subroutine getsltbanchordef(line,index,nslt,iresno,iatnum,charge,
         -  indexa,indexn,indexo,chargesum,nhneig,ineig,nanchor,ianchor,
         -  ianchor2,iselfanc,nosameseg,iiq1,iiq2,inpcrdtyp,iobpdb,iocpdb,
         -  icharges,iw0,irescol1,irescol2,inamcol1,inamcol2,segid4,
         -  molsltlim,nsegslt,isegno,ifail,maxneig,maxrec,maxanchorlist)
          dimension index(maxrec),charge(maxrec),indexa(maxrec),
         -  indexn(maxrec),indexo(maxrec),iresno(maxrec),chargesum(maxrec),
         -  iatnum(maxrec),ianchor(maxanchorlist),nhneig(maxrec),
         -  ineig(maxneig,maxrec),molsltlim(3,nsegslt),isegno(maxrec)
          character*4 segid4(nsegslt)
          character* 132 line(maxrec)
          character*1 ansrun
          character*8 saltatname(100),atnam
          nsaltats=0
          qmin=0.0
          call zeroiti(indexa,0,nslt)
          call zeroit(chargesum,nslt)
          call quiz(ansrun,iansrun,' ',' ',1,
         -  'salt-bridge definition mode',27,0,5,6,0)
          if (ansrun .eq. 'c' .or. ansrun .eq. 'b') then
            if (iiq1 .gt. iiq2) then
              print *,'This input format has no charge information'
            else
              if (icharges .eq. 1) then
                if (ischarmm(inpcrdtyp) .eq. 1)
         -        print *,'Charges are read from the WEIGHT column'
                if (inpcrdtyp .eq. iobpdb .or. inpcrdtyp .eq. iocpdb)
         -        print *,
         -          'Charges are read from the TEMPERATURE FACTOR column'
              end if
              call getreal('Minimum (absolute) charge for an anchor atom',
         -      44,999999.0,qmin,1,0)
              do ia=1,nslt
                if (icharges .eq. 1) then
                  call readreal(line(index(ia)),iiq1,iiq2,chargesum(ia))
                else
                  chargesum(ia)=charge(ia)
                end if
              end do
              do ia=1,nslt
                if (iatnum(ia) .ne. 1 .and. iatnum(ia) .ne. 6) then
                  do in=1,nhneig(ia)
                    chargesum(ia)=chargesum(ia)+chargesum(ineig(in,ia))
                  end do
                  if (abs(chargesum(ia)) .ge. qmin) then
                    indexa(ia)=-1
                    nsaltats=nsaltats+1
                  end if
                end if
              end do
            end if
          end if
          if (ansrun .eq. 'l' .or. ansrun .eq. 'b') then
            lname=inamcol2-inamcol1+1
    100     call getnamelist(saltatname,lname,nsaltatnams,
         -    'Salt-bridge forming atom names',30,100)
            print *,'NOTE: only oxygens will be assumend to be negative'
            do ia=1,nslt
              atnam=line(index(ia))(inamcol1:inamcol2)
              call leftadjustn(atnam,atnam,8)
              do in=1,nsaltatnams
                if (atnam(1:lname) .eq. saltatname(in)(1:lname)) then
                  if (iatnum(ia) .ne. 1 .and. iatnum(ia) .ne. 6) then
                    if (indexa(ia) .eq. 0) then
                      nsaltats=nsaltats+1
                      indexa(ia)=-1
                    end if
                  else
                    write (6,2148) ia,atnam(1:lname),iatnum(ia)
                    go to 100
                  end if
                end if
                if (iatnum(ia) .eq. 8) chargesum(ia)=-1.0
              end do
            end do
          end if
          if (nsaltats .eq. 0) then
            print *,'Solute contains no salt-bridge atoms'
            ifail=1
            return
          else
            write (6,2142) nsaltats
            write (iw0,2142) nsaltats
          end if
          nanchorr=0
          call zeroiti(indexn,0,nslt)
    9134  ansrun=' '
          iall=0
          do while (iall .eq. 0 .and. ansrun .ne. 'q')
            call quiz(ansrun,iansrun,' ',' ',1,
         -    'hydrophobic/salt bridge/contact anchor atoms',44,0,5,6,75)
            ifail=0
            call definelist(ansrun,nslt,nanchorr,indexn,indexo,nsegslt,
         -    segid4,iresno,molsltlim,'salt bridge',11,iall,maxanchorlist)
          end do
          nanchor=0
          do ja=1,nanchorr
            ia=indexn(ja)
            if (ia .gt. 0) then
              if (indexa(ia) .lt. 0) then
                indexa(ia)=1
                nanchor=nanchor+1
              end if
            end if
          end do
          if (nanchor .eq. 0) then
            print *,'PROBLEM: No anchor atoms were found'
            call askyn('Do you want to repeat the selection',35,
         -    1,+1,iselrep,0,0)
            if (iselrep .eq. 1) go to 9134
            ifail=1
            return
          end if
          call getanchormod(ianchor2,iselfanc,nosameseg,iall,iw0)
          write (iw0,*) 'Salt-bridge anchor atoms:'
          ia=0
          if (nanchor .gt. maxanchorlist) then
            print *,'Anchor list limit (',maxanchorlist,') is reached'
            ifail=1
          end if
          do ib=1,nslt
            if (indexa(ib) .gt. 0) then
              ia=ia+1
              ianchor(ia)=ib
              write (iw0,2146) ia,line(index(ib))(irescol1:irescol2),
         -      iresno(ib),segid4(isegno(ib)),
         -      line(index(ib))(inamcol1:inamcol2),ib,chargesum(ib)
            end if
            if (chargesum(ib) .lt. 0.0) then
              if (indexa(ib) .eq. 1) indexa(ib)=2
              if (indexa(ib) .eq. -1) indexa(ib)=-2
            end if
          end do
          if (ia .ne. nanchor) then
            print *,'PRORAM ERROR: ia=',ia,' nanchor=',nanchor
          end if
          return
    2142  format(' Number of salt-bridge forming atoms=',i4)
    2146  format(i5,' Residue=',a,' (',i5,') Chain/seg=',a,' Atom=',a,
         -  ' (',i6,') q=',f6.3)
    2148  format(' Atomic number of atom ',i6,' (',a,')=',i3,/,
         -  ' Hydrogens and carbons are not allowed to form salt bridges')
          end
          subroutine getmpxbdef(nslt,indexa,indexov,indexn,segid4,iresno,
         -   molsltlim,nsegslt,nanchorr,nanchorn,iout,maxrsd)
          dimension indexa(nslt),indexov(nslt),indexn(nslt),iresno(nslt),
         -  molsltlim(3,maxrsd)
          character*4 segid4(nslt)
          character*1 ansrun
          call zeroiti(indexa,0,nslt)
    9134  print *,'Define the FIRST contact set'
          maxanchorlist=nslt
          ansrun=' '
          iall=0
          nanchorr=0
          do while (iall .eq. 0 .and. ansrun .ne. 'q')
            call quiz(ansrun,iansrun,' ',' ',1,
         -    'hydrophobic/salt bridge/contact anchor atoms',44,0,5,6,75)
            ifail=0
            call definelist(ansrun,nslt,nanchorr,indexa,indexn,nsegslt,
         -    segid4,iresno,molsltlim,'mpx contact',11,iall,maxanchorlist)
          end do
          print *,'Define the SECOND contact set'
          ansrun=' '
          iall=0
          nanchorn=0
          do while (iall .eq. 0 .and. ansrun .ne. 'q')
            call quiz(ansrun,iansrun,' ',' ',1,
         -    'hydrophobic/salt bridge/contact anchor atoms',44,0,5,6,75)
            ifail=0
            call definelist(ansrun,nslt,nanchorn,indexov,indexn,nsegslt,
         -    segid4,iresno,molsltlim,'mpx contact',11,iall,maxanchorlist)
          end do
          nov=0
          do ia=1,nanchorr
            do ja=1,nanchorn
              if (indexa(ia) .eq. indexov(ja)) then
                 if (nov .lt. 26) print *,'Atoms ', indexa(ia),' and ',
         -         indexov(ja),' are ','in both lists'
                 nov=nov+1
              end if
            end do
          end do
          if (nov .gt. 0) then
            write (6,1002) nov
            call askstop(1)
            go to 9134
          end if
          write (6,1001) nanchorr,nanchorn
          write (iout,1001) nanchorr,nanchorn
          return
    1001  format(' Number of reference atoms=',i6,/,
         -  ' Number of neighbour atoms=',i6)
    1002  format(' Number of atoms in both lists=',i6,/,
         -  ' Mutually proximal contact list can not overlap')
          end
          subroutine definelist(ansrun,nslt,nanchorr,indexn,indexo,nsegslt,
         -  segid4,iresno,molsltlim,label,llabel,iall,maxanchorlist)
          dimension indexn(nslt),indexo(nslt),iresno(nslt),
         -  molsltlim(3,nsegslt)
          character*4 segid4(nsegslt)
          character*1 ansrun
          character*(*) label
          if (ansrun .eq. 'q') then
            if (nanchorr .eq. 0) then
              print *,'No selection was made - all eligible atoms will ',
         -      'be used'
              call indexit(indexn,1,nslt,0)
              nanchorr=nslt
            end if
            return
          else if (ansrun .eq. 'a') then
            call indexit(indexn,1,nslt,0)
            nanchorr=nslt
            iall=1
            return
          else if (ansrun .eq. 'l') then
            call getlist(indexo,nanchoradd,1,nslt,1,maxanchorlist)
            call trnsfi(indexn(nanchorr+1),indexo,nanchoradd)
            nanchorr=nanchorr+nanchoradd
            iall=0
          else if (ansrun .eq. 's') then
            call getint('Segment number',14,1,1,nsegslt,iseganc,0)
            nseg=molsltlim(2,iseganc)-molsltlim(1,iseganc)+1
            call indexit(indexn,nanchorr+1,nanchorr+nseg,
         -    molsltlim(1,iseganc)-nanchorr-1)
            nanchorr=nanchorr+nseg
          else if (ansrun .eq. 'x') then
            call getrange(ifirst,1,ilast,nslt,increment,0,
         -    'anchor atoms',12,nslt,0)
            nanchoradd=ilast-ifirst+1
            call indexit(indexn,nanchorr+1,nanchorr+nanchoradd,
         -    ifirst-nanchorr-1)
            nanchorr=nanchorr+nanchoradd
            iall=0
          else if (ansrun .eq. 'n' .or. ansrun .eq. 'r') then
            if (nsegslt .gt. 1) then
              call getint('Segment number',14,1,1,nsegslt,iseganc,0)
              write (6,2143) segid4(iseganc),(molsltlim(i,iseganc),i=1,2)
            else
              iseganc=1
            end if
            ifss=molsltlim(1,iseganc)
            ilss=molsltlim(2,iseganc)
            if (ansrun .eq. 'n') then
              call getlist(indexo,nanchorres,ifss,ilss,1,maxanchorlist)
            else
              call getrange(ifirstres,iresno(ifss),ilastres,iresno(ilss),
         -      increment,0,'anchor residue',14,nslt,0)
              nanchorres=ilastres-ifirstres+1
              call indexit(indexo,1,nanchorres,ifirstres-1)
            end if
            do ir=1,nanchorres
              iresanc=indexo(ir)
              call findrange(iresno,ifss,ilss,iresanc,ifsr,ilsr,'residue',
         -      7,1,ifail)
              if (ifail .gt. 0) then
                write (6,2147) iresanc,ifss,ilss
              else
                natadd=ilsr-ifsr+1
                call indexit(indexn,nanchorr+1,nanchorr+natadd,
         -        ifsr-nanchorr-1)
                nanchorr=nanchorr+natadd
              end if
            end do
            iall=0
          end if
          if (nanchorr .gt. maxanchorlist) then
            write (6,2144) maxanchorlist,label(1:llabel)
            nanchorr=maxanchorlist
            iall=0
            print *,'Only the first ',nanchorr,' atoms will be anchors'
            call askstop(0)
          end if
          return
    2143  format(' Segment ',a,' atom range [',i6,',',i6,') selected')
    2144  format(' Progam is limited to ',i5,1x,a,' anchor ',
         -  'atoms.',/,' Redimension or break up the run')
    2147  format(' Residue',i6,' is not found in atom range [',i6,' - ',i6,
         -  '] - ignored')
          end
          subroutine getanchormod(ianchor2,iselfanc,nosameseg,iallsel,iout)
          character*8 inout(2)
          character*9 onetwo(2)
          data inout /'excluded','included'/,onetwo/'one end  ','both ends'/
          if (iallsel .eq. 0) then
            call askyn(
         -    'Do you want anchor atoms at both ends',37,1,-1,ianchor2,71,0)
            iselfanc=1
            if (ianchor2 .eq. 0)
         -    call askyn('Do you want exclude anchor-anchor bonds',39,0,-1,
         -      iselfanc,000,0)
          else
            ianchor2=0
            iselfanc=1
          end if
          call askyn('Do you want exclude intra segment/chain bonds',45,1,
         -  -1,nosameseg,000,0)
          if (iout .gt. 0) then
            write (iout,1000) 'Anchor-anchor',inout(iselfanc+1)
            write (iout,1000) 'Intra segment/chain',inout(2-nosameseg)
            write (iout,1001) onetwo(ianchor2+1)
          end if
          return
    1000  format(1x,a,' bonds will be ',a)
    1001  format(' Anchor atom is required at ',a,' of a bond')
          end
          subroutine extend_nnlist(nneig,ineig,n14neig,nslt,maxng,maxrec)
          dimension nneig(maxrec),n14neig(maxrec),ineig(maxng,maxrec)
          call getint('Minimum number of chemical bond to separate',43,
         -  3,1,4,nbondsep,118)
          do ia=1,nslt
            n14neig(ia)=nneig(ia)
            nnprevlev=0
            if (nbondsep .gt. 2) then
              nerr=0
              do lev=1,nbondsep-2
                len=n14neig(ia)
                do in=nnprevlev+1,len
                  inn=ineig(in,ia)
                  do in2=1,nneig(inn)
                    inn2=ineig(in2,inn)
                    ifound=0
                    do iaa=1,len
                      if (inn2 .eq. ia .or. ineig(iaa,ia) .eq. inn2)
         -              ifound=1
                    end do
                    if (ifound .eq. 0) then
                      if (n14neig(ia) .lt. maxng) then
                        n14neig(ia)=n14neig(ia)+1
                        ineig(n14neig(ia),ia)=inn2
                      else
                        write (6,1000) ia,maxng
                        nerr=nerr+1
                      end if
                    end if
                  end do
                end do
                nnprevlev=len
              end do
            end if
          end do
          return
    1000  format(' ERROR: number of 1-3 or 1-4 neighbors of atom ',i6,
         -  'exeeds limit (',i3,')',/,
         -  8x,'- recompile with increased MAXNEIG')
          end
          subroutine checktorbond(resnami,ixresi,ixresj,atnami,atnamj,
         -  fixbond,ipep,ican,icac,issb)
          character*4 atnami,atnamj
          character*8 resnami,resnam
          fixbond=0
          if (ixresi .eq. ixresj) then
            call leftadjustn(resnami,resnam,8)
            if (resnam(1:3) .eq. 'HIS' .or. resnam(1:3) .eq. 'HSE' .or.
         -      resnam(1:3) .eq. 'HSD' .or. resnam(1:3) .eq. 'HSP' .or.
         -      resnam(1:3) .eq. 'HID') then
              if (atnami(1:3) .eq. 'CD2' .or. atnami(1:3) .eq. 'NE2'
         -    .or. atnami(1:3) .eq. 'CE1' .or. atnami(1:3) .eq. 'ND1')
         -       fixbond=1
              if (atnami(1:3) .eq. 'CG ' .and. atnamj(1:3) .ne. 'CB ')
         -       fixbond=1
            else if (resnam(1:3) .eq. 'PRO') then
              if (atnami(1:3) .eq. 'CD ' .or. atnami(1:3) .eq. 'CB '
         -    .or. atnami(1:3) .eq. 'CG ') fixbond=1
              if ((atnami .eq. 'N   ' .and. atnamj .ne. 'C   ') .or.
         -        (atnami .eq. 'CA  ' .and. atnamj .ne. 'C   '))
         -      fixbond=1
            else if (resnam(1:3) .eq. 'PHE') then
              if (atnami(1:2) .eq. 'CE' .or. atnami(1:2) .eq. 'CD'
         -    .or. atnami(1:2) .eq. 'CZ')  fixbond=1
              if (atnami(1:3) .eq. 'CG ' .and. atnamj(1:3) .ne. 'CB ')
         -       fixbond=1
            else if (resnam(1:3) .eq. 'TYR') then
              if (atnami(1:2) .eq. 'CE' .or. atnami(1:2) .eq. 'CD')
         -      fixbond=1
              if (atnami(1:2) .eq. 'CZ' .and. atnamj(1:2) .ne. 'OH')
         -        fixbond=1
              if (atnami(1:3) .eq. 'CG ' .and. atnamj(1:3) .ne. 'CB ')
         -       fixbond=1
            else if (resnam(1:3) .eq. 'TRP') then
              if (atnami(1:2) .eq. 'CE' .or. atnami(1:2) .eq. 'CD'
         -    .or. atnami(1:2) .eq. 'CZ' .or. atnami(1:2) .eq. 'CH'
         -     .or. atnami(1:2) .eq. 'NE')  fixbond=1
              if (atnami(1:3) .eq. 'CG ' .and. atnamj(1:3) .ne. 'CB ')
         -       fixbond=1
            else if (resnam(1:3) .eq. 'ARG') then
              if (atnami(1:2) .eq. 'NE' .and. atnamj(1:2) .eq. 'CZ' .or.
         -        atnami(1:2) .eq. 'CZ' .and. atnamj(1:2) .eq. 'NH')
         -      fixbond=1
           end if
          end if
          if (fixbond .eq. 0) then
            ipep=0
            ican=0
            icac=0
            issb=0
            if ((atnami .eq. 'C      ' .and. atnamj .eq. 'N      ') .or.
         -    (atnamj .eq. 'C      ' .and. atnami .eq. 'N      ')) ipep=1
            if ((atnami .eq. 'CA     ' .and. atnamj .eq. 'N      ') .or.
         -    (atnamj .eq. 'CA     ' .and. atnami .eq. 'N      ')) ican=1
            if ((atnami .eq. 'CA     ' .and. atnamj .eq. 'C      ') .or.
         -    (atnamj .eq. 'CA     ' .and. atnami .eq. 'C      ')) icac=1
            if (atnami .eq. 'SG     ' .and. atnamj .eq. 'SG     ')  issb=1
           end if
          return
          end
          subroutine getatnumlist(n,iatnum,ifchrg,ialist,icatlist,ixlist,
         -  nanos)
          dimension iatnum(n),ifchrg(n),ixlist(99),ialist(15),icatlist(15)
          call zeroiti(ixlist,0,99)
          call zeroiti(icatlist,0,15)
          nanos=0
          do i=1,n
            ifound=0
            do j=1,nanos
              if (iatnum(i) .eq. ialist(j)) then
                ifound=1
                go to 9031
              end if
            end do
    9031    if (ifound .eq. 0) then
              if (nanos .lt. 15) then
                nanos=nanos+1
                ialist(nanos)=iatnum(i)
                ixlist(iatnum(i))=nanos
                icatlist(nanos)=ifchrg(i)
              else
                print *,'ERROR: Number of different elements exceeds',
         -        ' 15 - redimension the program'
                stop
              end if
            end if
          end do
          return
          end
          subroutine printbondthres(ialist,nalist,ctfac,bondminfac,
         -  iatnm2,ramax,iout)
          dimension ialist(nalist)
          character*2 iatnm2(99)
          dimension ramax(99)
          write (iout,1003)
          write (iout,1002) (ialist(i),iatnm2(ialist(i)),i=1,nalist)
          do i=1,nalist
            do j=i,nalist
              call decidebondcut(ialist(i),ialist(j),rlim)
              write (iout,1000) iatnm2(ialist(i)),iatnm2(ialist(j)),
         -      sqrt(rlim),iatnm2(ialist(i)),ramax(ialist(i)),
         -      iatnm2(ialist(j)),ramax(ialist(j))
              if (ctfac .gt. 0.0)
         -      write (iout,1001) sqrt(rlim*ctfac),sqrt(rlim*bondminfac)
            end do
          end do
          return
    1000  format(1x,a2,' - ',a2,' bondlength threshold=',f5.3,
         - 2(' ramax(',a2,')=',f5.3))
    1001  format(9x,'clash threshold=',f5.3,
         -  ' minimum acceptable bondlength=',f5.3)
    1002  format(' Atoms used: ',15(i3,1x,a2))
    1003  format(' Bond threshold for heavy atoms: max(ramax(i),ramax(j))',
         -  /,' Bond threshold with hydrogen: 0.7*max(ramax(i),ramax(j))')
          end
          subroutine findresnum(iresno,ixres,ir,ifirst,ilast,iafound,
         -  irfound)
          dimension iresno(ilast),ixres(ilast)
          ia=ifirst
          do while (iresno(ia) .ne. ir .and. ia .le. ilast)
            ia=ia+1
          end do
          if (ia .gt. ilast) then
            write (6,1000) ir,ifirst,ilast
            ir=0
          end if
          iafound=ia
          irfound=ixres(ia)
          return
    1000  format(' ERROR: residue number',i6,' is not found in atom range',
         - i7,' - ',i7)
          end
          subroutine getresrange(nsegm,indexs,isegno,ixres,iresno,ifres,
         -  label,llabel,numres,nslt,ires1save,ires2save,isegdef,iseg1,
         -  iseg2,listres,listlen,nrange,idefall,ionerange,maxrsd,maxrec,
         -  ihelp)
          dimension indexs(maxrec),isegno(maxrec),ixres(maxrec),
         -  iresno(maxrec),ifres(maxrsd),listres(maxrsd)
          character*(*) label
          common /logging/ logfile,ipredict
          character*80 line
          listlen=0
          nrange=0
          do while (.true.)
            if (nsegm .eq. 1 .and. ipredict .eq. 0) then
              call reverseindex(indexs,iresno,ifres,1,numres,maxrec)
    9156      call getrange(ires1i,iresno(1),ires2i,
         -      iresno(nslt),incr,0,label,llabel,
         -      iresno(nslt),ihelp)
              ires1=indexs(ires1i)
              if (ires1 .eq. 0) write (6,2052) ires1i
              ires2=indexs(ires2i)
              if (ires2 .eq. 0) write (6,2052) ires2i
              if (ires1*ires2 .eq. 0) go to 9156
              iseg1=1
              iseg2=1
              print *,'ires1,ires2,iseg1,iseg2=',ires1,ires2,iseg1,iseg2
            else
              write (6,2039)
              line(1:28)='SEGMENT number of the first '
              lline=28
              line(lline+1:lline+llabel)=label(1:llabel)
              lline=lline+llabel
              if (isegdef .eq. 0) isegdef=1
    9152      call getint(line,lline,isegdef,1,nsegm,iseg1,0)
              call findrange(isegno,1,nslt,iseg1,ifss,ilss,'segment',7,
         -      0,ifail)
              if (ifail .gt. 0) go to 9152
              write (6,2000) iseg1,iresno(ifss),iresno(ilss)
              line(1:7)='RESIDUE'
              call getint(line,lline,iresno(ifss),1,iresno(ilss),irn1,ihelp)
              line(1:28)='SEGMENT number of the last  '
              iseg2def=iseg1
              if (idefall .eq. 1) iseg2def=nsegm
    9153      call getint(line,lline,iseg2def,1,numres,iseg2,ihelp)
              if (iseg2 .lt. iseg1) then
                print *,'ERROR: segment number of the last residue can not',
         -        ' be less than the first'
                 go to 9153
              end if
              call findrange(isegno,1,nslt,iseg2,ifss,ilss,'segment',7,
         -      0,ifail)
              if (ifail .gt. 0) go to 9153
              write (6,2000) iseg2,iresno(ifss),iresno(ilss)
              line(1:7)='RESIDUE'
              call getint(line,lline,iresno(ilss),1,iresno(ilss),irn2,ihelp)
              call findsegres(isegno,iresno,ixres,1,nslt,iseg1,
         -      irn1,ia1,ires1,ifail1)
              call findsegres(isegno,iresno,ixres,ia1+1,nslt,
         -      iseg2,irn2,ia2,ires2,ifail2)
              if (ifail1+ifail2 .gt. 0) go to 9152
              if (ires2 .lt. ires1) then
                write (6,2001) ires2,ires1
                go to 9152
              end if
            end if
            do ir=ires1,ires2
              listlen=listlen+1
              listres(listlen)=ir
            end do
            nrange=nrange+1
            if (nrange .eq. 1) then
              ires1save=ires1
              ires2save=ires2
            else
              ires1save=min0(ires1,ires1save)
              ires2save=max0(ires2,ires2save)
            end if
            if (ionerange .eq. 1) return
            if (iseg1 .ne. iseg2) isegdef=0
            call askyn('Do you want to add an other range',33,1,-1,iadd,0,0)
            if (iadd .eq. 0) return
          end do
          return
    2000  format(' Segment',i4,' includes residues ',i6,' to ',i6)
    2001  format(' ERROR: residue index of the last residue (',i6,') is ',/,
         -  8x,'less than the first residue (',i6,')')
    2039  format(' NOTE: segment numbers and residue ranges are printed ',
         -  'above')
    2052  format(' ERROR: residue number',i6,' does not exist')
          end
          subroutine readax(lab,llab,idef,iax,indx)
          character*(*) lab
          dimension indx(3)
    1000  call getint(lab,llab,idef,1,3,iax,31)
          if (iax .lt. 1 .or. iax .gt. 3) then
            print *,'ERROR: invalid axis'
            go to 1000
          end if
          indx(1)=iax
          indx(2)=mod(iax,3)+1
          indx(3)=mod(iax+1,3)+1
          return
          end
          subroutine findat(iarep,ira1,ira2,line,index,irescol1,inamcol1,
         -  maxrec)
          character* 132 line(maxrec)
          dimension index(maxrec)
          character*3 resnam3,repats,repat0
          character*4 atname,an
          character*8 resnam,rn
          common /represent/ repats(2,50),maxrepat
          resnam='        '
          resnam=line(index(ira1))(irescol1:irescol1+4)
          call leftadjustn(resnam,rn,8)
          resnam3=rn(1:3)
          infound=0
          do i=1,maxrepat
            if (resnam3 .eq. repats(1,i)) infound=i
          end do
          iarep=0
          repat0='CA '
          do ia=ira1,ira2
            if (infound .gt. 0) repat0=repats(2,infound)
            atname=line(index(ia))(inamcol1:inamcol1+3)
            call leftadjust4(atname,an)
            if (an(1:3) .eq. repat0) iarep=ia
          end do
          if (iarep .eq. 0 .and. infound .gt. 0)
         -  write (6,1000) repats(2,infound),repats(1,infound),ira1,ira2
          if (iarep .eq. 0) iarep=ira1
          return
    1000  format(' Representative atom ',a,' for residue ',a,' not found ',
         - 'in atom range',i6,' - ',i6)
          end
          subroutine findapproach(c,irra1,irra2,inra1,inra2,iatnum,ignoreh,
         -  irarepm,itarepm,rmin2,maxrec)
          dimension c(3,maxrec),iatnum(maxrec)
          rmin2=100000.0
          if (ignoreh .eq. 0) then
            do ira=irra1,irra2
              do ita=inra1,inra2
                r2=dist2(c(1,ira),c(1,ita))
                if (r2 .lt. rmin2) then
                  rmin2=r2
                  irarepm=ira
                  itarepm=ita
                end if
              end do
            end do
          else
            do ira=irra1,irra2
              if (iatnum(ira) .gt. 1) then
                do ita=inra1,inra2
                  if (iatnum(ita) .gt. 1) then
                    r2=dist2(c(1,ira),c(1,ita))
                    if (r2 .lt. rmin2) then
                      rmin2=r2
                      irarepm=ira
                      itarepm=ita
                    end if
                  end if
                end do
              end if
            end do
          end if
          return
          end
          subroutine pbcreset(c,n,crep,cell,ncell,ixyzexcld,ixyzincld,img)
          dimension c(3,n),crep(3),cell(3,ncell)
          if (n .eq. 0) return
          call genimdist123dim(crep,cell,1,ncell,ixyzexcld,ixyzincld,
         -  img,rmin2)
          do ia=1,n
            call arrdiff(c(1,ia),cell(1,img),c(1,ia),3)
          end do
          return
          end
          subroutine pbcdist(c1,c2,i1,i2,cell,ncell,iw,nframe,img,r,dist)
          dimension c1(3),c2(3),cell(3,ncell),r(3)
          call arrdiff(c2,c1,r,3)
          call genimdist(r,cell,1,ncell,img,d2)
          dist=sqrt(d2)
          if (img .gt. 1) then
            do k=1,3
              r(k)=r(k)-cell(k,img)
            end do
            if (iw .lt. -1) write (-iw,1002) nframe,img
          end if
          if (iw .eq. 0) write (6,1000) i1,i2,dist,r,img
          if (iw .gt. 0) write (iw,1001) nframe,i1,i2,dist,r,img
          return
    1000  format(' D(',i5,'-',i5,')=',f9.3,' r=',3f9.4,
         -  ' A, PBC image=',i2)
    1001  format(' N=',i6,' D(',i5,'-',i5,')=',f9.3,' r=',3f9.4,
         -  ' A, PBC image=',i2)
    1002  format(' PBC reset at frame # ',i6,' PBC image=',i2)
          end
          subroutine findrange(index,n1,n,ifind,ifirst,ilast,label,llabel,
         -  isilent,ifail)
          dimension index(n)
          character*(*) label
          ifail=0
          ifirst=n1
          do while (index(ifirst) .ne. ifind)
            ifirst=ifirst+1
            if (ifirst .gt. n) then
              if (isilent .eq. 0) print *,'ERROR: subroutine findrange ',
         -      'failed to find ',label(1:llabel),' ',ifind
              ifail=1
              return
            end if
          end do
          ilast=ifirst
          do while (index(ilast) .eq. ifind .and. ilast .lt. n)
            ilast=ilast+1
          end do
          if (ilast .lt. n) ilast=ilast-1
          return
          end
          subroutine findlim(index,ifst,ilst,max)
          dimension index(max)
          i=max
          do while (i .gt. 0 .and. index(i) .eq. 0)
            i=i-1
          end do
          ilst=i
          if (ilst .eq. 0) return
          i=1
          do while (i .lt. ilst .and. index(i) .eq. 0)
            i=i+1
          end do
          ifst=i
          return
          end
          subroutine findsegres(isegno,iresno,ixres,ifst,ilst,iseg,ires,
         -  iaf,irf,ifail)
          dimension isegno(ilst),iresno(ilst),ixres(ilst)
          ifail=0
          do ia=ifst,ilst
            if (isegno(ia) .eq. iseg) then
              if (iresno(ia) .eq. ires) then
                iaf=ia
                irf=ixres(ia)
                return
              end if
            end if
          end do
          write (6,1000) iseg,ires,ifst,ilst
          ifail=1
          return
    1000  format(' ERROR: segment number',i3,' residue ',i4,' was not ',
         -  'found',/,' Atom range searched:',i5,' - ',i5)
          end
          subroutine modrepats
          character*3 repats,resnam3,atnam3
          common /represent/ repats(2,50),maxrepat
          write (6,2000) ((repats(k,i),k=1,2),i=1,maxrepat)
          write (6,2001)
          call askyn('Do you want to add/modify representative atom list',
         -  50,1,-1,ians,0,0)
          if (ians .eq. 1) then
    100     resnam3='   '
            call getname(resnam3,len,
         -    'Residue name to add/modify (hit ENTER to finish)',38,3,
         -    '',0,0,0,0)
            if (resnam3 .eq. '   ') then
              write (6,2000) ((repats(k,i),k=1,2),i=1,maxrepat)
              return
            end if
            atnam3='   '
            call getname(atnam3,len,
         -    'Representative atom name (3 characters maximum)',47,3,
         -    '',0,0,0,3)
            ifound=0
            do i=1,maxrepat
              if (repats(1,i) .eq. resnam3) ifound=i
            end do
            if (ifound .eq. 0) then
              maxrepat=maxrepat+1
              if (maxrepat .gt. 50) then
                print *,'Maximum number of residue names (50) exceeded'
                stop
              end if
              ifound=maxrepat
              repats(1,ifound)=resnam3
            end if
            repats(2,ifound)=atnam3
            go to 100
          end if
          return
    2000  format(' Representative atoms for residues:',/,
         -  (1x,8(a3,'-',a3,2x)))
    2001  format(' Representative atoms for unlisted residues: CA; ',
         -  'if not found, the 1st atom')
          end
          subroutine findprotbackbone(line,index,iresno,ia1,inamcol1,
         -  ica,ic,in,icb,icg,icd,nslt,icaonly,maxrec)
          character* 132 line(maxrec)
          dimension index(maxrec),iresno(maxrec)
          character*4 atnami,atnamj
          ica=0
          ic=0
          in=0
          icb=0
          icg=0
          icd=0
          ia=ia1
          irespro=iresno(ia)
          do while (iresno(ia) .eq. irespro .and. ia .le. nslt)
            atnami=line(index(ia))(inamcol1:inamcol1+3)
            call leftadjust4(atnami,atnamj)
            if (atnamj(1:2) .eq. 'CA') ica=ia
            if (atnamj(1:2) .eq. 'C ') ic=ia
            if (atnamj(1:2) .eq. 'N ') in=ia
            if (atnamj(1:2) .eq. 'CB') icb=ia
            if (atnamj(1:2) .eq. 'CG') icg=ia
            if (atnamj(1:2) .eq. 'CD') icd=ia
            ia=ia+1
          end do
          if (icaonly .eq. -1) then
            if (ica*ic*in .eq. 0) then
              print *,'ERROR: residue ',irespro,' has no CA or C or N'
              stop
            end if
          else if (icaonly .eq. 1) then
            if (ica .eq. 0) then
              print *,'ERROR: residue ',irespro,' has no CA'
              stop
            end if
          else
            if (ica .gt. 0 .and. ic*in .eq. 0) then
              print *,'Residue ',irespro,' has no C or N but CA is present'
              call askyn('Do you want to look for just CAs',32,1,+1,icaonly,
         -      0,0)
              if (icaonly .eq. 0) stop
            end if
          end if
          if (ic .eq. 0) ic=ica
          if (in .eq. 0) in=ica
          ia1=ia
          return
          end
          subroutine findchiral(n,ian,nneig,nhneig,ineig,ichiral,maxneig)
          dimension ian(n),nneig(n),nhneig(n),ineig(maxneig,n),
         -  ichiral(n)
          dimension nnpairs(2,6)
          call zeroiti(ichiral,0,n)
          if (n .gt. 1000) then
            print *,'Chirality search is done for max 1000 atoms'
            return
          end if
          do ia=1,n
            if (nneig(ia) .eq. 4 .and. nhneig(ia) .le. 1) then
              call listsame(ineig(1,ia),ian,4,n,nnpairs,nsamepair)
              if (nsamepair .eq. 0) then
                ichiral(ia)=1
              else
                ipair=nsamepair
                ndiff=0
                do while (ipair .gt. 0)
                  call comparetree(nneig,ineig,ian,ia,nnpairs(1,ipair),
         -          nnpairs(2,ipair),idiff,n,maxneig)
                  if (idiff .eq. 0) then
                    ipair=0
                  else
                    ipair=ipair-1
                    ndiff=ndiff+1
                  end if
                end do
                if (ndiff .eq. nsamepair) ichiral(ia)=1
              end if
            end if
          end do
          return
          end
          subroutine listsame(ineig,ian,nn,n,nnpairs,nsamepair)
          dimension ineig(nn),ian(n),nnpairs(2,6)
          nsamepair=0
          do ia=2,4
            do ja=1,ia-1
              if (ian(ineig(ia)) .eq. ian(ineig(ja))) then
                nsamepair=nsamepair+1
                nnpairs(1,nsamepair)=ineig(ia)
                nnpairs(2,nsamepair)=ineig(ja)
              end if
            end do
          end do
          return
          end
          subroutine comparetree(nneig,ineig,ian,ia,in1,in2,idiff,n,maxneig)
          dimension ian(n),nneig(n),ineig(maxneig,n)
          dimension iused1(1000),iused2(1000),nnpar1(1000),nnoffsp1(1000),
         -  nnpar2(1000),nnoffsp2(1000),nian1(100),nian2(100)
          data noffsp1 /0/,noffsp2 /0/
          call zeroiti(nian1,0,100)
          call zeroiti(nian2,0,100)
          call zeroiti(iused1,0,n)
          call zeroiti(iused2,0,n)
          iused1(ia)=1
          iused1(in1)=1
          iused2(ia)=1
          iused1(in2)=1
          npar1=1
          nnpar1(1)=in1
          npar2=1
          nnpar2(1)=in2
          lev=0
          idiff=0
          do while ((lev .eq. 0 .or. max0(noffsp1,noffsp2) .gt. 0) .and.
         -          idiff .eq. 0)
            noffsp1=0
            do ip=1,npar1
              do in=1,nneig(nnpar1(ip))
                ja=ineig(in,nnpar1(ip))
                if (iused1(ja) .eq. 0) then
                  noffsp1=noffsp1+1
                  nnoffsp1(noffsp1)=ja
                  nian1(ian(ja))=nian1(ian(ja))+1
                  iused1(ja)=1
                end if
              end do
            end do
            noffsp2=0
            do ip=1,npar2
              do in=1,nneig(nnpar2(ip))
                ja=ineig(in,nnpar2(ip))
                if (iused2(ja) .eq. 0) then
                  noffsp2=noffsp2+1
                  nnoffsp2(noffsp2)=ja
                  nian2(ian(ja))=nian2(ian(ja))+1
                  iused2(ja)=1
                end if
              end do
            end do
            idiff=0
            do i=1,50
              idiff=idiff+iabs(nian2(i)-nian1(i))
            end do
            if (idiff .eq. 0) then
              npar1=noffsp1
              if (npar1 .gt. 0) call trnsfi(nnpar1,nnoffsp1,npar1)
              npar2=noffsp2
              if (npar2 .gt. 0) call trnsfi(nnpar2,nnoffsp2,npar2)
            end if
            lev=lev+1
          end do
          return
          end
          subroutine stat14(c,n,nneig,ineig,index,line,nconfig,pi,iatnm2,
         -  ir1,ir2,ic1,ic2,inpcrdtyp,ioins,iw0,maxrepconf,maxng,maxrec)
          dimension nneig(n),ineig(maxng,n),c(3,n),index(n)
          character*2 iatnm2(99)
          character* 132 line(maxrec)
          rmin=1000.0
          rmax=-rmin
          do ia=1,n
            do j=1,nneig(ia)
              ja=ineig(j,ia)
              if (ia .lt. ja) then
                do ii=1,nneig(ia)
                  iaa=ineig(ii,ia)
                  do jj=1,nneig(ja)
                    jaa=ineig(jj,ja)
                    if (jaa .ne. ia .and. iaa .ne. ja
         -              .and. iaa .ne. jaa) then
                      r2=sqrt(dist2(c(1,iaa),c(1,jaa)))
                      if (r2 .gt. rmax) then
                        rmax=r2
                        iamax=iaa
                        jamax=jaa
                      else if (r2 .lt. rmin) then
                        rmin=r2
                        iamin=iaa
                        jamin=jaa
                      end if
                      tors=dihangl(c,iaa,ia,ja,jaa,1,maxrec)*(180.0/pi)
                      if (inpcrdtyp .le. ioins) then
                        write (iw0,2042) iaa,line(index(iaa))(ic1:ic2),
         -               line(index(iaa))(ir1:ir2),
         -               ia,line(index(ia))(ic1:ic2),
         -               line(index(ia))(ir1:ir2),
         -               ja,line(index(ja))(ic1:ic2),
         -               line(index(ja))(ir1:ir2),
         -               jaa,line(index(jaa))(ic1:ic2),
         -               line(index(jaa))(ir1:ir2),r2,tors
                      else
                        write (iw0,2039) iaa,iatnm2(iaa),ia,iatnm2(ia),
         -               ja,iatnm2(ja),jaa,iatnm2(jaa),r2,tors
                      end if
                    end if
                  end do
                end do
              end if
            end do
          end do
          if (nconfig .le. maxrepconf)
         -  write (6,2056) rmin,iamin,jamin,rmax,iamax,jamax
          return
    2039  format(3(i5,' (',a2,') - '),i5,' (',a2,'):',/,
         -  ' 1-4 distance=',f8.3,' torsion angle=',f10.3)
    2042  format(3(i5,' (',a4,1x,a4,') - '),i5,' (',a4,1x,a4,'):',/,
         -  '1-4 distance=',f5.2,' torsion angle=',f7.1)
    2056  format(' Shortest 1-4 distance=',f6.2,' between atoms ',2i6,/,
         -  ' Longest 1-4 distance= ',f6.2,' between atoms ',2i6)
          end
          subroutine ramachandran_init(n,ixres)
          parameter (MAXREC=200000,MAXRSD=70000,MAXNEIG=70,MAXPHI=400)
          parameter (IFILL1=MAXPHI*MAXPHI*MAXPHI-(7+2*MAXNEIG)*MAXREC)
          parameter (IFILL5=(MAXNEIG+6)*MAXREC+IFILL1-44*MAXRSD)
          common /nnwork/ ineig(MAXNEIG,MAXREC),nneig(MAXREC),
         -  nprossacc(6,6,MAXRSD),issprossacc(5,MAXRSD),
         -  ixypross(2,MAXRSD),isspross(MAXRSD),fill(IFILL5)
          dimension ixres(n)
          nres=ixres(n)
          call zeroiti(nprossacc,0,36*nres)
          call zeroiti(issprossacc,0,5*nres)
          return
          end
          subroutine ramachandran(c,n,index,line,nconfig,pi,nresfound,
         -  iresno,ixres,ir1,ir2,ic1,iw0,maxng,mxrec)
          dimension c(3,n),index(n),iresno(n),ixres(n)
          character* 132 line(mxrec)
          parameter (MAXFRAMES=50000,MAXCOPY=600)
          common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
         -  increment,increment2,res(2,MAXFRAMES,MAXCOPY),
         -  x0(MAXCOPY),y0(MAXCOPY),nxselres,ixselres(MAXCOPY)
          parameter (MAXREC=200000,MAXRSD=70000,MAXNEIG=70,MAXPHI=400)
          parameter (IFILL1=MAXPHI*MAXPHI*MAXPHI-(7+2*MAXNEIG)*MAXREC)
          parameter (IFILL5=(MAXNEIG+6)*MAXREC+IFILL1-44*MAXRSD)
          common /nnwork/ ineig(MAXNEIG,MAXREC),nneig(MAXREC),
         -  nprossacc(6,6,MAXRSD),issprossacc(5,MAXRSD),
         -  ixypross(2,MAXRSD),isspross(MAXRSD),fill(IFILL5)
          character*1 prosscode(5)
          character*4 atnam
          data prosscode /'H','E','T','P','C'/
          call trajlimtest(ixres(n),MAXFRAMES)
          nresfound=0
          do ires=1,ixres(n)
            res(1,ires,maxpres)=999.9
            res(2,ires,maxpres)=999.9
          end do
          do ia=1,n
            atnam=line(index(ia))(ic1:ic1+3)
            call leftadjust4(atnam,atnam)
            if (atnam .eq. 'CA  ') then
              i3=ia
              call ca_to_bb(i3,iresno,nneig,ineig,index,line,ic1,
         -      i1,i2,i4,i5,ires,iprotein,maxng,mxrec)
              if (iprotein .gt. 0) then
                phirad=dihangl(c,i1,i2,i3,i4,0,mxrec)
                psirad=dihangl(c,i2,i3,i4,i5,0,mxrec)
                phi=phirad*(180.0/pi)
                psi=psirad*(180.0/pi)
                if (nframe .eq. 0) then
                  write (iw0,1000) phi,psi,ires,line(index(i3))(ir1:ir2)
                else
                  write (iw0,1000) phi,psi,ires,line(index(i3))(ir1:ir2),
         -          ' ',nframe
                  if (nxselres .gt. 0) then
                    do ix=1,nxselres
                      if (ires .eq. ixselres(ix)) then
                        call trajlimtest(nframe,MAXFRAMES)
                        res(1,nframe,2*ix-1)=cos(phirad)
                        res(2,nframe,2*ix-1)=sin(phirad)
                        res(1,nframe,2*ix)=cos(psirad)
                        res(2,nframe,2*ix)=sin(psirad)
                      end if
                    end do
                  end if
                end if
                nresfound=nresfound+1
                call trajlimtest(nresfound,MAXFRAMES)
                res(1,nresfound,maxpres)=phi
                res(2,nresfound,maxpres)=psi
                ixypross(1,nresfound)=ixpross(phi)
                ixypross(2,nresfound)=ixpross(psi)
                nprossacc(ixypross(1,nresfound),
         -                ixypross(2,nresfound),nresfound)=
         -        nprossacc(ixypross(1,nresfound),
         -                  ixypross(2,nresfound),nresfound)+1
              end if
            end if
          end do
          call zeroiti(isspross,0,nresfound)
          ir=1
          do while (ir .le. nresfound)
            ir0=ir
            ixy=ixypross(1,ir)+6*(ixypross(2,ir)-1)
            if (ixy .eq. 8 .or. ixy .eq. 14) then
              irr=ir
              do while (ixy .eq. 8 .or. ixy .eq. 14)
                irr=irr+1
                ixy=0
                if (irr .lt. nresfound)
         -        ixy=ixypross(1,irr)+6*(ixypross(2,irr)-1)
              end do
              if (irr-ir .ge. 4) then
                do i=ir,irr
                  isspross(i)=1
                end do
              end if
              ir=irr+1
            end if
            if (ir .eq. ir0) ir=ir+1
          end do
          ir=1
          do while (ir .le. nresfound)
            ir0=ir
            if (isspross(ir) .eq. 0) then
              ixy=ixypross(1,ir)+6*(ixypross(2,ir)-1)
              if (ixy .eq. 13 .or. ixy .eq. 24 .or. ixy .eq. 29 .or.
         -        ixy .eq. 30 .or. ixy .eq. 28 .or. ixy .eq. 36) then
                irr=ir
                do while (ixy .eq. 13 .or. ixy .eq. 24 .or. ixy .eq. 29 .or.
         -        ixy .eq. 30 .or. ixy .eq. 28 .or. ixy .eq. 36)
                  irr=irr+1
                  ixy=0
                  if (irr .lt. nresfound)
         -          ixy=ixypross(1,irr)+6*(ixypross(2,irr)-1)
                end do
                if (irr-ir .ge. 2) then
                  do i=ir,irr
                    isspross(i)=2
                  end do
                end if
                ir=irr+1
              end if
            end if
            if (ir .eq. ir0) ir=ir+1
          end do
          ir=1
          do while (ir .le. nresfound-1)
            ir0=ir
            if (isspross(ir) .eq. 0 .and. isspross(ir+1) .eq. 0) then
              ixy1=ixypross(1,ir)+6*(ixypross(2,ir)-1)
              ixy2=ixypross(1,ir+1)+6*(ixypross(2,ir+1)-1)
              if ((ixy1 .eq.  8 .and. (ixy2 .eq. 8 .or. ixy2 .eq. 14 .or.
         -        ixy2 .eq. 13)) .or. (ixy1 .eq.  14 .and. (ixy2 .eq. 8 .or.
         -        ixy2 .eq. 14 .or. ixy2 .eq. 13)) .or. (ixy1 .eq. 13 .and.
         -        (ixy2 .eq.  8 .or. ixy2 .eq. 14 .or. ixy2 .eq.  13)) .or.
         -        (ixy1 .eq. 30 .and. (ixy2 .eq. 20 .or. ixy2 .eq. 16 .or.
         -        ixy2 .eq. 17)) .or. (ixy1 .eq. 24 .and. (ixy2 .eq. 20 .or.
         -        ixy2 .eq. 16 .or. ixy2 .eq. 17)) .or. (ixy1 .eq. 20 .and.
         -        (ixy2 .eq. 20 .or. ixy2 .eq. 16 .or. ixy2 .eq.  17)) .or.
         -        (ixy1 .eq. 16 .and. (ixy2 .eq. 20 .or. ixy2 .eq. 16 .or.
         -        ixy2 .eq. 17)) .or. (ixy1 .eq. 17 .and. (ixy2 .eq. 20 .or.
         -        ixy2 .eq. 16 .or. ixy2 .eq. 17)) .or. (ixy1 .eq. 32 .and.
         -        (ixy2 .eq. 8  .or. ixy2 .eq. 14 .or. ixy2 .eq.  13)) .or.
         -        (ixy1 .eq.  4 .and. (ixy2 .eq. 8 .or. ixy2 .eq. 14 .or.
         -        ixy2 .eq. 13))) then
                isspross(ir)=3
                isspross(ir+1)=3
                ir=ir+2
              end if
            end if
            if (ir .eq. ir0) ir=ir+1
          end do
          ir=1
          do while (ir .le. nresfound)
            if (isspross(ir) .eq. 0) then
              ixy=ixypross(1,ir)+6*(ixypross(2,ir)-1)
              if (ixy .eq. 30 .or. ixy .eq. 24) isspross(ir)=4
            end if
            ir=ir+1
          end do
          do ir=1,nresfound
            if (isspross(ir) .eq. 0) isspross(ir)=5
          end do
          do ir=1,nresfound
            if (isspross(ir) .lt. 1 .or. isspross(ir) .gt. 5)
         -    print *,'ir=',ir,' isspross=',isspross(ir)
            issprossacc(isspross(ir),ir)=issprossacc(isspross(ir),ir)+1
          end do
          write (iw0,1002) (prosscode(isspross(ir)),ir=1,nresfound)
          if (nresfound .eq. 0) then
            print *,'ERROR: no protein backbone found'
            stop
          else if (nconfig .le. 1) then
            write (6,1001) nresfound
          end if
          return
    1000  format(2f10.3,' (phi and psi angles) residue#=',i6,' (',a,')',
         -  a,'Frame=',i5)
    1001  format(' Number of protein residues found=',i5)
    1002  format(' PROSS SS codes: ',50a1)
          end
          subroutine angledials(c,n,nangsel,ixang123,index,line,pi,
         -  ir1,ir2,ic1,ic2,iw0,mxrec)
          dimension c(3,n),index(n),ixang123(4,nangsel)
          character* 132 line(mxrec)
          parameter (MAXFRAMES=50000,MAXCOPY=600)
          common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
         -  increment,increment2,res(2,MAXFRAMES,MAXCOPY),
         -  x0(MAXCOPY),y0(MAXCOPY),nxselres,ixselres(MAXCOPY)
          do it=1,nangsel
            phirad=angleijk(c,n,ixang123(1,it),ixang123(2,it),
         -    ixang123(3,it),iw0)
            phi=phirad*(180.0/pi)
            res(1,nframe,it)=cos(phirad)
            res(2,nframe,it)=sin(phirad)
            write (iw0,1000) it,phi,(line(index(ixang123(k,it)))(ic1:ic2),
         -    ixang123(k,it),k=1,3),
         -    line(index(ixang123(2,it)))(ir1:ir2)
          end do
          return
    1000  format(' A',i2,'=',f8.3,' (',a4,i6,')',2(' - (',a4,i6,')'),
         -  ' R2:',a)
          end
          subroutine torsiondials(c,n,ntorsel,ixtor1234,index,line,pi,
         -  ir1,ir2,ic1,ic2,iw0,mxrec)
          dimension c(3,n),index(n),ixtor1234(4,ntorsel)
          character* 132 line(mxrec)
          parameter (MAXFRAMES=50000,MAXCOPY=600)
          common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
         -  increment,increment2,res(2,MAXFRAMES,MAXCOPY),
         -  x0(MAXCOPY),y0(MAXCOPY),nxselres,ixselres(MAXCOPY)
          call trajlimtest(nframe,MAXFRAMES)
          do it=1,ntorsel
            phirad=dihangl(c,ixtor1234(1,it),ixtor1234(2,it),
         -    ixtor1234(3,it),ixtor1234(4,it),0,mxrec)
            phi=phirad*(180.0/pi)
            res(1,nframe,it)=cos(phirad)
            res(2,nframe,it)=sin(phirad)
            write (iw0,1000) it,phi,(line(index(ixtor1234(k,it)))(ic1:ic2),
         -    ixtor1234(k,it),k=1,4),
         -    line(index(ixtor1234(3,it)))(ir1:ir2)
          end do
          return
    1000  format(' T',i3,'=',f8.3,' (',a4,i6,')',3(' - (',a4,i6,')'),
         -  ' R3:',a)
          end
          subroutine ca_to_bb(icaa,iresno,nneig,ineig,index,line,
         -  ic1,icna,ina,ica,inca,ires,iprotein,maxng,mxrec)
          character* 132 line(mxrec)
          dimension iresno(mxrec),index(mxrec),nneig(mxrec),
         -  ineig(maxng,mxrec)
          character*4 atnam
          iprotein=0
          ires=iresno(icaa)
          ina=0
          ica=0
          do j=1,nneig(icaa)
            ja=ineig(j,icaa)
            if (iresno(ja) .ge. ires) then
              atnam=line(index(ja))(ic1:ic1+3)
              call leftadjust4(atnam,atnam)
              if (atnam .eq. 'N   ') ina=ja
              if (atnam .eq. 'C   ') ica=ja
            end if
          end do
          if (ina*ica .gt. 0) then
            icna=0
            inca=0
            do j=1,nneig(ina)
              ja=ineig(j,ina)
              if (iresno(ja) .eq. ires-1) then
                atnam=line(index(ja))(ic1:ic1+3)
                call leftadjust4(atnam,atnam)
                if (atnam .eq. 'C   ') icna=ja
              end if
            end do
            do j=1,nneig(ica)
              ja=ineig(j,ica)
              if (iresno(ja) .gt. ires) then
                atnam=line(index(ja))(ic1:ic1+3)
                call leftadjust4(atnam,atnam)
                if (atnam .eq. 'N   ') inca=ja
              end if
            end do
            if (icna*inca .gt. 0) iprotein=1
          end if
          return
          end
          subroutine ramachandranplot(nres,ips,xm,iallrama)
          parameter (MAXFRAMES=50000,MAXCOPY=600)
          common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
         -  increment,increment2,res(2,MAXFRAMES,MAXCOPY),
         -  x0(MAXCOPY),y0(MAXCOPY),nxselres,ixselres(MAXCOPY)
          xmm=0.9*xm
          ymm=0.9*xm
          xm0=0.09*xm
          ym0=0.20*xm
          if (nframe .le. 1) then
            write (ips,*) 'np'
            write (ips,1001) xm0,ym0,' m'
            write (ips,1001) xm0,ym0+ymm,' l'
            write (ips,1001) xm0+xmm,ym0+ymm,' l'
            write (ips,1001) xm0+xmm,ym0,'   l'
            write (ips,1001) xm0,ym0,' l'
            write (ips,*) 'sk'
            write (ips,1001) xm0,ym0-0.03*ymm,'m'
            write (ips,*) '(-180) show'
            write (ips,1001) xm0+xmm-0.05*xmm,ym0-0.03*ymm,'m'
            write (ips,*) '(+180) show'
            write (ips,1001) xm0+xmm/2.0-0.06*xmm,ym0-0.03*ymm,'m'
            write (ips,*) '(Phi) show'
            write (ips,1001) xm0-0.07*xmm,ym0+0.01*ymm,'m'
            write (ips,*) '(-180) show'
            write (ips,1001) xm0-0.07*xmm,ym0+ymm-0.02*ymm,'m'
            write (ips,*) '(+180) show'
            write (ips,1001) xm0-0.07*xmm,ym0+ymm/2.0-0.02*ymm,'m'
            write (ips,*) '(Psi) show'
            write (ips,*) 'np'
            write (ips,1001) xm0,ym0+1.01*ymm,' m'
          end if
          if (nframe .gt. 0) call rrgbcolor(ips,nframe,nframetot,0)
          nresplot=nxselres
          if (iallrama .eq. 1) nresplot=nres
          i=1
          do while (i .le. nresplot)
            ii=i
            if (iallrama .eq. 0) ii=ixselres(i)
            if (res(1,i,maxpres) .lt. 999.0) then
              if (nframe .eq. 0) call rrgbcolor(ips,i,nres,0)
              xx=xm0+xmm*(res(1,i,maxpres)+180.0)/360.0
              yy=ym0+ymm*(res(2,i,maxpres)+180.0)/360.0
              write (ips,*) 'np'
              write (ips,1001) xx,yy,' 1 0 360 arc'
              write (ips,*) 'sk'
            end if
            i=i+1
          end do
          if (nframe .eq. 0) then
            ixmm=xmm
            ixm0=xm0
            call rainbowscale(ips,ixm0,ixmm,25,nres,0.0,0.0,0.0,'N(res)',6)
            write (ips,*) 'showpage'
            close (ips)
          end if
          return
    1001  format(2f8.1,1x,a)
          end
          subroutine ramachandran_hist(nres,resnames,nrescol,iw,
         -  idistw,isummw)
          character*(*) resnames(nres)
          parameter (MAXREC=200000,MAXRSD=70000,MAXNEIG=70,MAXPHI=400)
          parameter (IFILL1=MAXPHI*MAXPHI*MAXPHI-(7+2*MAXNEIG)*MAXREC)
          parameter (IFILL5=(MAXNEIG+6)*MAXREC+IFILL1-44*MAXRSD)
          common /nnwork/ ineig(MAXNEIG,MAXREC),nneig(MAXREC),
         -  nprossacc(6,6,MAXRSD),issprossacc(5,MAXRSD),
         -  ixypross(2,MAXRSD),isspross(MAXRSD),fill(IFILL5)
          character*1 prosscode(5)
          character*1 prossixy(36)
          dimension iang(6)
          data prosscode /'H','E','T','P','C'/
          data prossixy /'H','N','T','r','l','B', 'I','O','U','q','k','C',
         -               'J','P','V','p','j','D', 'K','Q','W','o','i','E',
         -               'L','R','X','n','h','F', 'G','M','S','m','g','A'/
          if (idistw .gt. 0) then
            write (iw,*)
            do i=1,6
              iang(i)=-120+(i-1)*60
            end do
            do i=1,6
              do j=1,6
                ixy=i+6*(j-1)
                write (iw,1001) iang(i),iang(j),prossixy(ixy)
              end do
            end do
            write (iw,*)
            do ir=1,nres
              write (iw,1002) ir,resnames(ir)(1:nrescol),(iang(j),
         -      (nprossacc(i,j,ir),i=1,6),j=6,1,-1)
            end do
          end if
          if (isummw .gt. 0) then
            do ir=1,nres
              write (iw,1000) ir,resnames(ir)(1:nrescol),
         -      (prosscode(i),issprossacc(i,ir),i=1,5)
            end do
          end if
          return
    1000  format(' Res',i5,' (',a,') PROSS distr:',5(1x,a1,':',i6))
    1001  format(' PROSS SS codes and angles:',(' phi=',i4,' psi=',i4,
         -  ' code=',a1))
    1002  format(' PROSS angular grid distribution for residue ',i5,
         -  ' (',a,'):',6(/,' psi=',i4,':',6i9))
          end
          subroutine bondlenstat(c,n,iatnum,nneig,ineig,iatnm2,nconfig,
         -  nanos,ixlist,ialist,iwbls,inpcrdtyp,ioins,ic1,ic2,ir1,ir2,
         -  line,index,radtodeg,maxrepconf,maxng,maxrec)
          dimension c(3,n),iatnum(n),nneig(n),ineig(maxng,n),index(n),
         -  ixlist(99),ialist(15)
          character* 132 line(maxrec)
          character*2 iatnm2(99)
          character*1 sp
          dimension dmin(15,15),dav(15,15),dsd(15,15),ijmin(2,15,15),
         -  nij(15,15),dmax(15,15),ijmax(2,15,15),dd(15),anmin(15,15,15),
         -  anav(15,15,15),ansd(15,15,15),ijkmin(3,15,15,15),nijk(15,15,15),
         -  anmax(15,15,15),ijkmax(3,15,15,15),anan(15,15)
          real*8 cosa
          data ixl /0/,jxl /0/,sp /' '/
          do i=1,nanos
            do j=1,i
              nij(i,j)=0
              dav(i,j)=0.0
              dsd(i,j)=0.0
              dmax(i,j)=0.0
              dmin(i,j)=10000.0
              ijmin(1,i,j)=0
              ijmax(1,i,j)=0
              ijmin(2,i,j)=0
              ijmax(2,i,j)=0
            end do
          end do
          do i=1,n
            ixll=ixlist(iatnum(i))
            do jj=1,nneig(i)
              j=ineig(jj,i)
              jxll=ixlist(iatnum(j))
              dd(jj)=sqrt((c(1,i)-c(1,j))**2+(c(2,i)-c(2,j))**2+
         -       (c(3,i)-c(3,j))**2)
              if (jxll .le. ixll) then
                ixl=ixll
                jxl=jxll
              else
                ixl=jxll
                jxl=ixll
              end if
              dav(ixl,jxl)=dav(ixl,jxl)+dd(jj)
              dsd(ixl,jxl)=dsd(ixl,jxl)+dd(jj)**2
              nij(ixl,jxl)=nij(ixl,jxl)+1
              if (dmax(ixl,jxl) .lt. dd(jj)) then
                dmax(ixl,jxl)=dd(jj)
                ijmax(1,ixl,jxl)=i
                ijmax(2,ixl,jxl)=j
              end if
              if (dmin(ixl,jxl) .gt. dd(jj)) then
                dmin(ixl,jxl)=dd(jj)
                ijmin(1,ixl,jxl)=i
                ijmin(2,ixl,jxl)=j
              end if
            end do
            if (inpcrdtyp .le. ioins) then
              write (iwbls,2046) i,line(index(i))(ic1:ic2),
         -      line(index(i))(ir1:ir2),
         -      (sp,ineig(j,i),line(index(ineig(j,i)))(ic1:ic2),
         -      line(index(ineig(j,i)))(ir1:ir2),dd(j),j=1,nneig(i))
            else
              write (iwbls,2048) i,iatnm2(iatnum(i)),
         -      (sp,ineig(j,i),iatnm2(iatnum(ineig(j,i))),
         -      dd(j),j=1,nneig(i))
            end if
          end do
          if (nconfig .le. maxrepconf) write (6,2057)
          write (iwbls,2057)
          do i=1,nanos
            do j=1,i
              if (nij(i,j) .gt. 0) dav(i,j)=dav(i,j)/nij(i,j)
              dsd(i,j)=sqrt(abs(dsd(i,j)/nij(i,j)-dav(i,j)**2))
              if (dmin(i,j) .eq. 10000.0) dmin(i,j)=0.0
            end do
            do j=1,i
              if (ijmin(1,i,j) .gt. 0) then
                if (nconfig .le. maxrepconf)
         -       write (6,2047) iatnm2(ialist(i)),
         -         iatnm2(ialist(j)),dmin(i,j),ijmin(1,i,j),ijmin(2,i,j),
         -         dav(i,j),dsd(i,j),dmax(i,j),ijmax(1,i,j),ijmax(2,i,j)
                write (iwbls,2047) iatnm2(ialist(i)),
         -       iatnm2(ialist(j)),dmin(i,j),ijmin(1,i,j),ijmin(2,i,j),
         -       dav(i,j),dsd(i,j),dmax(i,j),ijmax(1,i,j),ijmax(2,i,j)
              end if
            end do
          end do
          do i=1,nanos
            do j=1,nanos
              do k=1,j
                nijk(i,j,k)=0
                anav(i,j,k)=0.0
                ansd(i,j,k)=0.0
                anmax(i,j,k)=0.0
                anmin(i,j,k)=10000.0
                ijkmin(1,i,j,k)=0
                ijkmax(1,i,j,k)=0
                ijkmin(2,i,j,k)=0
                ijkmax(2,i,j,k)=0
                ijkmin(3,i,j,k)=0
                ijkmax(3,i,j,k)=0
              end do
            end do
          end do
          do i=1,n
            ixll=ixlist(iatnum(i))
            do jj=1,nneig(i)
              do kk=1,jj-1
                j=ineig(jj,i)
                k=ineig(kk,i)
                jxll=ixlist(iatnum(j))
                kxll=ixlist(iatnum(k))
                ixl=max0(ixll,jxll,kxll)
                kxl=min0(ixll,jxll,kxll)
                if (ixll .ne. ixl .and. ixll .ne. kxl) jxl=ixll
                if (jxll .ne. ixl .and. jxll .ne. kxl) jxl=jxll
                if (kxll .ne. ixl .and. kxll .ne. kxl) jxl=kxll
                rj=0.0
                rk=0.0
                rjk=0.0
                do l=1,3
                  dj=c(l,i)-c(l,j)
                  dk=c(l,i)-c(l,k)
                  rj=rj+dj*dj
                  rk=rk+dk*dk
                  rjk=rjk+dj*dk
                end do
                cosa=dble(rjk)/sqrt(rj*rk)
                anan(jj,kk)=radtodeg*dacoscheck(cosa,ccc,1,6,'BONDLENSTAT')
                anav(ixl,jxl,kxl)=anav(ixl,kxl,jxl)+anan(jj,kk)
                ansd(ixl,jxl,kxl)=ansd(ixl,kxl,jxl)+anan(jj,kk)**2
                nijk(ixl,jxl,kxl)=nijk(ixl,kxl,jxl)+1
                if (anmax(ixl,jxl,kxl) .lt. anan(jj,kk)) then
                  anmax(ixl,jxl,kxl)=anan(jj,kk)
                  ijkmax(1,ixl,jxl,kxl)=i
                  ijkmax(2,ixl,jxl,kxl)=j
                  ijkmax(3,ixl,jxl,kxl)=k
                end if
                if (anmin(ixl,jxl,kxl) .gt. anan(jj,kk)) then
                  anmin(ixl,jxl,kxl)=anan(jj,kk)
                  ijkmin(1,ixl,jxl,kxl)=i
                  ijkmin(2,ixl,jxl,kxl)=j
                  ijkmin(3,ixl,jxl,kxl)=k
                end if
                if (inpcrdtyp .le. ioins) then
                  write (iwbls,2050) j,line(index(j))(ic1:ic2),
         -          line(index(j))(ir1:ir2),i,line(index(i))(ic1:ic2),
         -          line(index(i))(ir1:ir2),k,line(index(k))(ic1:ic2),
         -          line(index(k))(ir1:ir2),anan(jj,kk)
                else
                  write (iwbls,2051) j,iatnm2(iatnum(j)),
         -          i,iatnm2(iatnum(i)),k,iatnm2(iatnum(k)),anan(jj,kk)
                end if
              end do
            end do
          end do
          if (nconfig .le. maxrepconf) write (6,2058)
          write (iwbls,2058)
          do i=1,nanos
            do j=1,nanos
              do k=1,j
                if (nijk(i,j,k) .gt. 0) then
                  anav(i,j,k)=anav(i,j,k)/nijk(i,j,k)
                  ansd(i,j,k)=sqrt(abs(ansd(i,j,k)/nijk(i,j,k)-
         -          anav(i,j,k)**2))
                end if
                if (anmin(i,j,k) .eq. 10000.0) anmin(i,j,k)=0.0
                if (ijkmin(1,i,j,k) .gt. 0) then
                  if (nconfig .le. maxrepconf)
         -          write (6,2049) iatnm2(ialist(j)),iatnm2(ialist(i)),
         -            iatnm2(ialist(k)),anav(i,j,k),ansd(i,j,k),
         -            ijkmin(2,i,j,k),ijkmin(1,i,j,k),ijkmin(3,i,j,k),
         -            anmin(i,j,k),ijkmax(2,i,j,k),ijkmax(1,i,j,k),
         -            ijkmax(3,i,j,k),anmax(i,j,k)
                  write (iwbls,2049) iatnm2(ialist(j)),iatnm2(ialist(i)),
         -          iatnm2(ialist(k)),anav(i,j,k),ansd(i,j,k),
         -          ijkmin(2,i,j,k),ijkmin(1,i,j,k),ijkmin(3,i,j,k),
         -          anmin(i,j,k),ijkmax(2,i,j,k),ijkmax(1,i,j,k),
         -          ijkmax(3,i,j,k),anmax(i,j,k)
                end if
              end do
            end do
          end do
          return
    2046  format(i5,' From ',a4,1x,a4,a1,'To ',i5,1x,a4,1x,a4,f6.3,';',a1,
         -                            ' To ',i5,1x,a4,1x,a4,f6.3,';',a1,
         -  /,(20x,2(' To ',i5,1x,a4,1x,a4,f6.3,';',a1)))
    2047  format(1x,a2,' - ',a2,f6.3,' (',i5,'-',i5,') < ',f6.3,' (av) +/-',
         -  f4.3,' (SD) < ',f6.3,' (',i5,'-',i5,')')
    2048  format(i5,' From ',a2,1x,' To ',i5,1x,a2,1x,f6.3,';',a1,
         -  ' To ',i5,1x,a2,1x,f6.3,';',a1,' To ',i5,1x,a2,1x,f6.3,';',a1,
         -  /,(15x,3(' To ',i5,1x,a2,1x,f6.3,';',a1)))
    2049  format(' Angle ',a2,'-',a2,'-',a2,' Average=',f8.2,' SD=',f8.2,
         -  ' deg',/,6x,'Min (',i5,'-',i5,'-',i5,')=',f8.2,
         -  ' Max (',i5,'-',i5,'-',i5,')=',f8.2)
    2050  format(' Angle ',i5,' (',a4,1x,a4,') - ',i5,' (',a4,1x,a4,') - ',
         -  i5,' (',a4,1x,a4,')=',f10.5,' deg')
    2051  format(' Angle ',i5,' (',a2,') - ',i5,' (',a2,') - ',
         -  i5,' (',a2,')=',f10.5,' deg')
    2057  format(' Minimum, average and maximum of bond-type lengths')
    2058  format(' Minimum, average and maximum of angle-type values')
          end
          subroutine hblist(c,n,nslt,islvw,naslv,iatnum,ifchrg,isegno,nneig,
         -  nneiga,nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,ixres,
         -  nconfig,hbf0,angm0,molresflag,hblimfac,angmin,iwhbl,ic1,ic2,ir1,
         -  ir2,irn1,irn2,blankline,line,index,indexn,ibnd,indexo,isolvent,
         -  iprint,icallnn,nosameseg,nframe,radtodeg,maxrepconf,
         -  maxng,maxbox,maxrsd,maxrec)
          dimension c(3,n),iatnum(n),ifchrg(n),isegno(n),nneig(n),
         -  ineig(maxng,n),nhbneig(n),nneiga(n),nhneig(n),nnneig(n),
         -  ncneig(n),nsneig(n),npneig(n),ixres(n),index(n),indexn(n),
         -  ibnd(maxbox,maxrec),molresflag(maxrsd),indexo(maxrec)
          character* 132 line(maxrec),linep(25),blankline
          character*1 r1,bbsc(4)
          common /connatdat/ ramax(99),ramax2(99),hlimfac,ianfg(99),
         -  namfcg(100),nrmw
          character*8 resnam
          character*8 atname,atname1,atnamea,atname1a
          dimension rhbl(25),nh12(4)
          data bbsc/'B','S','V','?'/
          data pi /3.2141692/
          innl=0
          nhbats=nslt
          if (isolvent .eq. 1) nhbats=n
          if (hbf0 .ne. hblimfac .or. angm0 .ne. angmin .or.
         -    isegno(1) .ne. isegno(n) .or. icallnn .eq. 1)
         -  call nnlist(nslt,islvw,naslv,nhbats,iatnum,ifchrg,c,nneig,
         -    nneiga,nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,line,
         -    ir1,ir2,ic1,ic2,index,nconfig,innl,molresflag,hblimfac,angmin,
         -    1,ibnd,indexo,isegno,ixres,maxrepconf,1,nframe,radtodeg,
         -    0,maxbox,maxng,maxrsd,maxrec)
          if (iprint .eq. 0) return
          rDHmin=200.0
          rDHmax=0.0
          nhats=0
          atname='        '
          atname1='        '
          resnam='        '
          do i=1,nhbats
            resnam(1:ir2-ir1+1)=line(index(i))(ir1:ir2)
            call changeprot(resnam,r1,2)
            if (i .gt. nslt) then
              indexn(i)=3
            else if (r1 .eq. '*') then
              indexn(i)=4
            else
              indexn(i)=2
              atname(1:ic2-ic1+1)=line(index(i))(ic1:ic1+3)
              call leftadjustn(atname,atnamea,8)
              if (ineig(1,i) .gt. 0) then
                atname1(1:ic2-ic1+1)=line(index(ineig(1,i)))(ic1:ic1+3)
                call leftadjustn(atname1,atname1a,8)
                if (atnamea(1:3) .eq. 'H   ' .or.
         -          atnamea(1:3) .eq. 'HN ') then
                  if (atname1a(1:3) .eq. 'N  ') indexn(i)=1
                else if (atnamea(1:3) .eq. 'O  ') then
                  if (atname1a(1:3) .eq. 'C  ') indexn(i)=1
                end if
              end if
            end if
          end do
          call checkhblist(n,ineig,nhbneig,maxng)
          write (iwhbl,*) 'List of hydrogen bond(s) found:'
          nhbonds=0
          do ia=1,nhbats
            if (iatnum(ia) .eq. 1) then
              ibb=indexn(ia)
              nhats=nhats+1
              nhbia=0
              call get_heavyat(ia,nneig,ineig,ixres,nframe,ihb0,maxng,
         -      maxrec)
              do ja=1,nhbneig(ia)
                ihb=ineig(maxng+1-ja,ia)
                if (nosameseg .eq. 0 .or. isegno(ia) .ne. isegno(ihb)) then
                  nhbia=nhbia+1
                  jbb=indexn(ihb)
                  if (ihb .gt. n)
         -          print *,'ERROR: illegal ihb (',ihb,') at ia=',ia
                  call angdistw(c(1,ia),c(1,ihb),c(1,ihb0),rHB,rb,rab,ang)
                  ang=ang*(180.0/pi)
                  rhbl(ja)=rHB
                  call readint(line(index(ia)),irn1,irn2,irna,2,1,irerr)
                  call readint(line(index(ihb)),irn1,irn2,irnb,2,1,irerr)
                  linep(ja)=blankline
                  write (linep(ja),2040) ia,line(index(ia))(ic1:ic2),irna,
         -          line(index(ia))(ir1:ir2),ihb,line(index(ihb))(ic1:ic2),
         -          irnb,line(index(ihb))(ir1:ir2),rHB,ang,rab,
         -          bbsc(ibb),bbsc(jbb)
                  if (rDHmin .gt. rHB) then
                    rDHmin=rHB
                    imn1=ia
                    imn2=ineig(maxng+1-ja,ia)
                  end if
                  if (rDHmax .lt. rHB) then
                    rDHmax=rHB
                    imx1=ia
                    imx2=ineig(maxng+1-ja,ia)
                  end if
                  nhbonds=nhbonds+1
                end if
              end do
              do ja=1,min0(25,nhbneig(ia))
                call writeline(iwhbl,linep(ja),1,79,0)
              end do
            else if (ifchrg(ia) .gt. 0) then
              nhbng=nhbneig(ia)
              do ja=1,nhbneig(ia)
                ihb=ineig(maxng+1-ja,ia)
                if (ihb .le. nslt) print *,'PROGRAM ERROR: atom ',ia,
         -        ' is a cation but is ','H-bonded to a non-solvent'
                if (iatnum(ihb) .ne. 8) print *,'PROGRAM ERROR: atom ',ia,
         -        ' is H-bonded to a cation but is not an oxygen'
                nnh=0
                do in=1,nneig(ihb)
                  jn=ineig(in,ihb)
                  if (iatnum(jn) .eq. 1) then
                    nnh=nnh+1
                    nh12(nnh)=jn
                  end if
                end do
                if (nnh .ne. 2) then
                  if (nframe .eq. 0) write (6,2000) ihb,nnh
                  if (nframe .gt. 0) write (6,2000) ihb,nnh,' ',nframe
                end if
                call angdistw(c(1,ihb),c(1,ia),c(1,nh12(1)),rHB,rb,rab,ang)
                ang=ang*radtodeg
                if (ang .lt. angmin) then
                  call angdistw(c(1,ihb),c(1,ia),c(1,nh12(2)),rHB,rb,rab,
         -          ang)
                  ang=ang*radtodeg
                end if
                call readint(line(index(ia)),irn1,irn2,irna,2,1,irerr)
                call readint(line(index(ihb)),irn1,irn2,irnb,2,1,irerr)
                linep(ja)=blankline
                write (linep(ja),2041) ia,line(index(ia))(ic1:ic2),irna,
         -        line(index(ia))(ir1:ir2),ihb,line(index(ihb))(ic1:ic2),
         -        irnb,line(index(ihb))(ir1:ir2),rHB,ang
                if (rDHmin .gt. rHB) then
                  rDHmin=rHB
                  imn1=ia
                  imn2=ineig(maxng+1-ja,ia)
                end if
                if (rDHmax .lt. rHB) then
                  rDHmax=rHB
                  imx1=ia
                  imx2=ineig(maxng+1-ja,ia)
                end if
                nhbonds=nhbonds+1
              end do
              do ja=1,min0(25,nhbneig(ia))
                call writeline(iwhbl,linep(ja),1,79,0)
              end do
            end if
          end do
          if (nconfig .le. maxrepconf) then
            if (nhbonds .gt. 0) then
              write (6,2049) nconfig,nhbonds
              write (6,2043) 'Shortest',rDHmin,imn1,imn2
              write (6,2043) 'Longest ',rDHmax,imx1,imx2
              write (iwhbl,2049) nconfig,nhbonds
              write (iwhbl,2043) 'Shortest',rDHmin,imn1,imn2
              write (iwhbl,2043) 'Longest ',rDHmax,imx1,imx2
            else
              if (nhats .eq. 0) then
                print *,'WARNING: structure contains NO hydrogens'
              else
                print *,'No hydrogen bonds found - try with a larger factor'
              end if
            end if
          end if
          return
    2000  format(' WARNING: water oxygen ',i6,' has',i3,' hydrogens bonded',
         -  ' to it',a,' Nframe=',i6)
    2040  format(i5,1x,a4,i4,1x,a4,' -',i5,1x,a4,i4,1x,a4,
         -  ' rHA=',f4.2,' a(D-H..A)=',f6.1,' rDA=',f4.2,1x,a1,'-',a1)
    2041  format(i5,1x,a4,i4,1x,a4,' -',i5,1x,a4,i4,1x,a4,
         -  ' rO+=',f4.2,' a(+..O-H)=',f6.1)
    2043  format(1x,a8,' A...H bond=',f8.3,' between atoms',i5,' and',i5)
    2049  format(' Frame ',i6,' Number of hydrogen bonds found=',i5)
          end
          subroutine hph_sltblist(ibondtype,c,n,nhbneig,ineig,iout,ic1,ic2,
         -  in1,in2,ir1,ir2,irn1,irn2,line,index,bondname,lbondname,rlab,
         -  lrlab,maxng)
          dimension c(3,n),ineig(maxng,n),nhbneig(n),index(n),lbondname(5)
          character*132 line(n)
          character*22 bondname(5)
          character*(*) rlab
          write (iout,1000) bondname(ibondtype)(1:lbondname(ibondtype))
          do ia=1,n
            do jaa=1,nhbneig(ia)
              ja=ineig(maxng-jaa+1,ia)
              call readint(line(index(ia)),irn1,irn2,irnia,2,1,irerr)
              call readint(line(index(ja)),irn1,irn2,irnja,2,1,irerr)
              write (iout,1001) line(index(ia))(ic1:ic2),
         -      ia,line(index(ia))(in1:in2),irnia,line(index(ia))(ir1:ir2),
         -      line(index(ja))(ic1:ic2),ja,line(index(ja))(in1:in2),
         -      irnja,line(index(ja))(ir1:ir2),rlab(1:lrlab),
         -      sqrt(dist2(c(1,ia),c(1,ja)))
            end do
          end do
          return
    1000  format(' List of ',a,'(s) found:')
    1001  format(1x,a,i5,1x,a4,i4,1x,a4,' - ',a,1x,i5,1x,a4,i4,1x,a4,
         -  ' r(',a,')=',f6.1)
          end
          subroutine mpxblist(n,i012,impx,rmpx,itemp,itempres,icc1,icc2,
         -  inc1,inc2,irc1,irc2,irnc1,irnc2,line,index,ixres,nhbdist,
         -  rhbdist,nbfound,nbresfound,nbonds,c,rmax,ifail,iout,mxbonds,
         -  mxrec)
          dimension index(n),ixres(n),i012(n),impx(n),rmpx(n),itemp(n),
         -  itempres(n),nhbdist(mxbonds),rhbdist(mxbonds),c(3,n)
          character*132 line(mxrec)
          parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
          parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
         -  (6*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
          common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),ing(MAX2D,MAX2D),
         -  ihbtores(MAXBONDS),nusepair(MAXBONDS),nhb_atot(MAXBONDS),
         -  nhb_rtot(MAXBONDS),a1(MAXBONDS),a2(MAXBONDS),fill(IFILL2)
          common /bondpairs/ ihbpair(2,MAXBONDS),ihb_pair_res(3,MAXBONDS)
          parameter (MAXFRAMES=50000,MAXCOPY=600,MAXITEMS=2*MAXCOPY-2)
          common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
         -  increment,increment2,ires(MAXITEMS,MAXFRAMES),
         -  scres(2,MAXFRAMES),x0(MAXCOPY),y0(MAXCOPY),nxselres,
         -  ixselres(MAXCOPY)
          nbitmax=30*MAXITEMS
          if (nframe .eq. 0) write (iout,1000)
          if (nframe .gt. 0) write (iout,1000) ' ',nframe
          call zeroiti(itemp,0,n)
          call zeroiti(itempres,0,n)
          ifail=0
          nbonds=0
          do ia=1,n
            if (i012(ia) .eq. 1) then
              ja=impx(ia)
              if (ja .gt. 0) then
                if (impx(ja) .eq. ia) then
                  dist_ia_ja=sqrt(dist2(c(1,ia),c(1,ja)))
                  iskip=0
                  if (rmax .lt. 9999.0) then
                    if (dist_ia_ja .gt. rmax) iskip=1
                  end if
                  if (iskip .eq. 0) then
                    call readint(line(index(ia)),irnc1,irnc2,irnia,2,1,ire)
                    call readint(line(index(ja)),irnc1,irnc2,irnja,2,1,ire)
                    write (iout,1001) line(index(ia))(icc1:icc2),ia,
         -            line(index(ia))(inc1:inc2),irnia,
         -            line(index(ia))(irc1:irc2),line(index(ja))(icc1:icc2),
         -            ja,line(index(ja))(inc1:inc2),irnja,
         -            line(index(ja))(irc1:irc2),sqrt(rmpx(ia))
                    nbonds=nbonds+1
                    if (nframe .gt. 0) then
                      ihb=1
                      do while (ihb .le. nbfound .and.
         -              (ia .ne. ihbpair(1,ihb) .or. ja .ne.ihbpair(2,ihb)))
                        ihb=ihb+1
                      end do
                      if (ihb .gt. nbfound) then
                        nbfound=nbfound+1
                        if (ihb .lt. MAXBONDS) then
                          ihbpair(1,nbfound)=ia
                          ihbpair(2,nbfound)=ja
                        else
                          if (nframe .gt. 0) write (6,1003) nframe
                          if (nframe .gt. 0) write (iout,1003) nframe
                          write (6,1002) mxbonds
                          write (iout,1002) mxbonds
                          call askyn(
         -                  'Do you want to continue without tracking',40,0,
         -                   1,istopscan,112,0)
                          ifail=2*istopscan-1
                        end if
                      else
                        nhbdist(ihb)=nhbdist(ihb)+1
                      end if
                      rhbdist(ihb)=rhbdist(ihb)+dist_ia_ja
                      itemp(ihb)=1
                      ir1=ixres(ia)
                      ir2=ixres(ja)
                      ihb=1
                      do while (ihb .le. nbresfound .and.
         -              (ir1 .ne. ihb_pair_res(1,ihb) .or.
         -               ir2 .ne. ihb_pair_res(2,ihb)))
                        ihb=ihb+1
                      end do
                      if (ihb .gt. nbresfound) then
                        nbresfound=nbresfound+1
                        ihb_pair_res(1,nbresfound)=ir1
                        ihb_pair_res(2,nbresfound)=ir2
                        ihb_pair_res(3,nbresfound)=1
                        ihb_pair_res(3,nbresfound+1)=0
                        itempres(nbresfound)=1
                      else if (itempres(ihb) .eq. 0) then
                        ihb_pair_res(3,ihb)=ihb_pair_res(3,ihb)+1
                        itempres(ihb)=1
                      end if
                    end if
                  end if
                end if
              end if
            end if
          end do
          if (nbfound .le. nbitmax)
         -  call savebitc(ires(1,nframe),itemp,nbfound,30,MAXITEMS)
          return
    1000  format(' List of mutually proximal heavy atom pair(s) found',a,
         -  ' at frame #',i6)
    1001  format(1x,a,i5,1x,a4,1x,i4,',',a4,' - ',a,1x,i5,1x,a4,',',i4,1x,
         -  a4,' r=',f6.1,' A')
    1002  format(' ERROR: maximum number of mutually proximal pairs to ',
         -  'store (',i5,') is exceeded',/,8x,'Reduce the participating ',/,
         -  8x,'atoms or increase the size of the array res in the common',
         -  ' block /analres/')
    1003  format(' Frame number=',i5)
          end
          subroutine checknnlist(nfrst,n,ineig,nneig,nerr,maxng)
          dimension nneig(n),ineig(maxng,n)
          nerr=0
          do ia=nfrst,n
            do ja=1,nneig(ia)
              ib=ineig(ja,ia)
              if (ib .lt. 1 .or. ib .gt. n) then
                print *,'PROGRAM ERROR: atom',ia,' has an invalid ',
         -        'bonded partner'
                nerr=nerr+1
              else if (nneig(ib) .eq. 0) then
                print *,'PROGRAM ERROR: atom',ib,' is bonded to',ia
                print *,'but it has no bonds listed'
                nerr=nerr+1
              else
                do jja=ja+1,nneig(ia)
                  if (ineig(jja,ia) .eq. ib) then
                    print *,'PROGRAM ERROR: ',
         -            'Duplicate bond partner of',ia,':',ib
                    nerr=nerr+1
                  end if
                end do
                do ii=1,nneig(ib)
                  if (ineig(ii,ib) .eq. ia) go to 200
                end do
                print *,'PROGRAM ERROR: atom ',ia,' is not bonded to',ib
                nerr=nerr+1
    200         continue
              end if
            end do
          end do
          if (nerr .gt. 0)
         -  print *,'NN list check for',n,' atoms done # of errors=',nerr
          return
          end
          subroutine checkhblist(n,ineig,nhbneig,maxng)
          dimension nhbneig(n),ineig(maxng,n)
          do ia=1,n
            do ja=1,nhbneig(ia)
              ihb=ineig(maxng+1-ja,ia)
              if (nhbneig(ihb) .eq. 0) then
                print *,'PROGRAM ERROR: atom',ihb,' is on the HB list',
         -        ' of',ia
                print *,'but it has no HB partner listed'
              else
                do jja=1,ja-1
                  if (ineig(maxng+1-jja,ia) .eq. ihb)
         -          print *,'Duplicate H-bond partner of',ia,':',ihb
                end do
                do ii=maxng+1-nhbneig(ihb),maxng
                  if (ineig(ii,ihb) .eq. ia) go to 200
                end do
                print *,'PROGRAM ERROR: atom ',ia,' is not on the HB list',
         -        ' of',ihb
    200         continue
              end if
            end do
          end do
          return
          end
          subroutine checkdim(n,max,param,lparam,name,lname,iout)
          character*(*) param,name
          if (n .gt. max) then
            write (6,2000) name(1:lname),n,max,param(1:lparam)
            if (iout .gt. 0)
         -    write (iout,2000) name(1:lname),n,max,param(1:lparam)
            stop
          end if
          return
    2000  format(' ERROR: ',a,' (',i8,') exceeds limit (',i8,')',/,
         -  ' Increase the parameter ',a,' and recompile')
          end
          subroutine rrdist(c,n,nres,ixresno,iresno,ixres,resnames,ifres,
         -  ilres,increst,incsolvrr,irefres1,irefres2,irefseg1,irefseg2,
         -  irefresinc,resdistlim,inegres1,inegres2,inegseg1,inegseg2,
         -  inegresinc,resapplim,listrefres,nrefres,nrefrange,listnegres,
         -  nnegres,nnegrange,iatnum,ignoreh,nframe,itypavg,iwrrdr,
         -  iwrrdc,iwrrmp,ir1,ir2,ic1,ic2,is1,is2,irescount1,irescount2,
         -  irescount3,line,index,indexn,indexo,itemp1,itemp2,itemp3,
         -  itemp4,temp1,temp2,maxrec,maxrsd)
          dimension c(3,n),iresno(n),ixresno(maxrsd),ixres(n),index(n),
         -  indexn(n),indexo(n),ifres(n),ilres(n),iatnum(n),
         -  listrefres(maxrsd),listnegres(maxrsd),
         -  irescount1(maxrsd),irescount2(maxrsd),irescount3(maxrsd),
         -  itemp1(n),itemp2(n),itemp3(n),itemp4(n),temp1(n),temp2(n)
          character*8 resnames(maxrsd)
          character* 132 line(maxrec)
          parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
          parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
         -  (6*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
          common /nnwork/ sdm(MAX2D,MAX2D),nng(MAX2D),rmsd(MAX2D,MAX2D),
         -  ihbtores(MAXBONDS),nusepair(MAXBONDS),nhb_atot(MAXBONDS),
         -  nhb_rtot(MAXBONDS),a1(MAXBONDS),a2(MAXBONDS),fill(IFILL2)
          call header_rrdist(iwrrdr,nrefrange,nnegrange,resdistlim,
         -  irefseg1,ixresno(irefres1),irefseg2,ixresno(irefres2),irefres1,
         -  irefres2,inegseg1,ixresno(inegres1),inegseg2,ixresno(inegres2),
         -  inegres1,inegres2,incsolvrr,listrefres,listnegres,nrefres,
         -  nnegres,itemp1,maxrsd)
          call header_rrdist(iwrrdc,nrefrange,nnegrange,resapplim,
         -  irefseg1,ixresno(irefres1),irefseg2,ixresno(irefres2),irefres1,
         -  irefres2,inegseg1,ixresno(inegres1),inegseg2,ixresno(inegres2),
         -  inegres1,inegres2,incsolvrr,listrefres,listnegres,nrefres,
         -  nnegres,itemp1,maxrsd)
          call header_rrdist(iwrrmp,nrefrange,nnegrange,0.0,
         -  irefseg1,ixresno(irefres1),irefseg2,ixresno(irefres2),irefres1,
         -  irefres2,inegseg1,ixresno(inegres1),inegseg2,ixresno(inegres2),
         -  inegres1,inegres2,incsolvrr,listrefres,listnegres,nrefres,
         -  nnegres,itemp1,maxrsd)
          write (iwrrdr,1004) 'reference','neighbour','representative atoms'
          write (iwrrdc,1004) 'reference','neighbour','closest approach'
          if (ignoreh .eq. 1) write (iwrrdc,1002) 'Closest approach'
          if (nframe .eq. 1 .and. itypavg .gt. 0) then
            do irr=irefres1,irefres2
              do inr=inegres1,inegres2
                rmsd(irr-irefres1+1,inr-inegres1+1)=0.0
                sdm(irr-irefres1+1,inr-inegres1+1)=0.0
              end do
            end do
          end if
          resdlim2=resdistlim**2
          resalim2=resapplim**2
          call zeroiti(indexo,0,n)
          call zeroiti(indexn,0,n)
          call zeroiti(itemp1,0,n)
          call zeroiti(itemp2,0,n)
          irramin=0
          ncontact1=0
          distcontactsum1=0.0
          ncontact2=0
          distcontactsum2=0.0
          do irrr=1,nrefres
            irr=listrefres(irrr)
            call findat(irarep,ifres(irr),ilres(irr),line,index,
         -    ir1,ic1,maxrec)
            inramin=0
            do inrr=1,nnegres
              inr=listnegres(inrr)
              if (inr .ne. irr) then
                call findat(inarep,ifres(inr),ilres(inr),line,index,
         -        ir1,ic1,maxrec)
                r2=dist2(c(1,irarep),c(1,inarep))
    
                if (r2 .lt. resdlim2) then
                  indexo(irr)=irarep
                  indexo(inr)=inarep
                  call writeprox(iwrrdr,irarep,inarep,line,index,r2,
         -          iresno,ir1,ir2,ic1,ic2,is1,is2,maxrec)
                  itemp1(irr)=1
                  itemp1(inr)=1
                  irescount1(irr)=irescount1(irr)+1
                  irescount1(inr)=irescount1(inr)+1
                  ncontact1=ncontact1+1
                  distcontactsum1=distcontactsum1+r2
                end if
                if (itypavg .eq. 1) then
                  rmsd(irr-irefres1+1,inr-inegres1+1)=
         -          rmsd(irr-irefres1+1,inr-inegres1+1)+sqrt(r2)
                  sdm(irr-irefres1+1,inr-inegres1+1)=
         -          sdm(irr-irefres1+1,inr-inegres1+1)+r2
                end if
                call findapproach(c,ifres(irr),ilres(irr),ifres(inr),
         -        ilres(inr),iatnum,ignoreh,irarepm,inarepm,rmin2,maxrec)
                if (rmin2 .lt. resalim2) then
                  indexn(irr)=1
                  indexn(inr)=1
                  call writeprox(iwrrdc,irarepm,inarepm,line,index,
         -          rmin2,iresno,ir1,ir2,ic1,ic2,is1,is2,maxrec)
                  itemp2(irr)=1
                  itemp2(inr)=1
                  irescount2(irr)=irescount2(irr)+1
                  irescount2(inr)=irescount2(inr)+1
                  ncontact2=ncontact2+1
                  distcontactsum2=distcontactsum2+rmin2
                end if
                if (itypavg .eq. 2) then
                  rmsd(irr-irefres1+1,inr-inegres1+1)=
         -          rmsd(irr-irefres1+1,inr-inegres1+1)+sqrt(rmin2)
                  sdm(irr-irefres1+1,inr-inegres1+1)=
         -          sdm(irr-irefres1+1,inr-inegres1+1)+rmin2
                end if
              end if
            end do
          end do
          if (ncontact1 .gt. 0)
         -  write (iwrrdr,1001) ncontact1,distcontactsum1/ncontact1
          if (ncontact2 .gt. 0)
         -  write (iwrrdc,1001) ncontact2,distcontactsum2/ncontact2
          call writeuniquelist(itemp1,ixresno,nres,resnames,ir2-ir1+1,
         -  iwrrdr,irefres1,irefres2,irefresinc,itemp3,itemp4,
         -  'reference',9,maxrsd)
          call writeuniquelist(itemp1,ixresno,nres,resnames,ir2-ir1+1,
         -  iwrrdr,inegres1,inegres2,inegresinc,itemp3,itemp4,
         -  'neighbour',9,maxrsd)
          call writeuniquelist(itemp2,ixresno,nres,resnames,ir2-ir1+1,
         -  iwrrdc,irefres1,irefres2,irefresinc,itemp3,itemp4,
         -  'reference',9,maxrsd)
          call writeuniquelist(itemp2,ixresno,nres,resnames,ir2-ir1+1,
         -  iwrrdc,inegres1,inegres2,inegresinc,itemp3,itemp4,
         -  'neighbour',9,maxrsd)
          call zeroiti(itemp1,0,n)
          do i=1,nrefres
            itemp1(listrefres(i))=1
          end do
          do i=1,nnegres
            itemp1(listnegres(i))=1
          end do
          call masktolist(itemp2,itemp1,nres,ncomplneg,0)
          if (ncomplneg .gt. 0 .and. increst .gt. 0) then
            write (iwrrdr,1004) 'reference','other','representative atoms'
            write (iwrrdc,1004) 'reference','other','closest approach'
            irramin=0
            do irrr=1,nrefres
              irr=listrefres(irrr)
              if (indexo(irr) .gt. 0 .or. indexn(irr) .eq. 0) then
                call findat(irarep,ifres(irr),ilres(irr),line,index,
         -        ir1,ic1,maxrec)
                inramin=0
                do irrr1=1,ncomplneg
                  irr1=itemp2(irrr1)
                  if ((irr1 .lt. inegres1 .or. irr1 .gt. inegres2)
         -           .and. irr .ne. irr1) then
                    call findat(inarep,ifres(irr1),ilres(irr1),line,
         -            index,ir1,ic1,maxrec)
                    if (indexo(irr) .gt. 0 .and. indexo(irr1) .eq. 0) then
                      r2=dist2(c(1,irarep),c(1,inarep))
                      if (r2 .lt. resdlim2)
         -              call writeprox(iwrrdr,irarep,inarep,line,
         -                index,r2,iresno,ir1,ir2,ic1,ic2,is1,is2,maxrec)
                    end if
                    if (indexn(irr) .gt. 0 .and. indexn(irr1) .eq. 0) then
                      call findapproach(c,ifres(irr),ilres(irr),
         -              ifres(irr1),ilres(irr1),iatnum,ignoreh,irarepm,
         -              inarepm,r2,maxrec)
                      if (r2 .lt. resalim2)
         -              call writeprox(iwrrdc,irarepm,inarepm,line,
         -                index,r2,iresno,ir1,ir2,ic1,ic2,is1,is2,maxrec)
                      end if
                    end if
                end do
              end if
            end do
            write (iwrrdr,1004) 'neighbour','other','representative atoms'
            write (iwrrdc,1004) 'neighbour','other','closest approach'
            inramin=0
            do irrr=1,nnegres
              irr=listnegres(irrr)
              if (indexo(irr) .gt. 0 .or. indexn(irr) .eq. 0) then
                call findat(inarep,ifres(irr),ilres(irr),line,index,
         -        ir1,ic1,maxrec)
                irramin=0
                do irrr1=1,ncomplneg
                  irr1=itemp2(irrr1)
                  if ((irr1 .lt. irefres1 .or. irr1 .gt. irefres2)
         -           .and. irr .ne. irr1) then
                    call findat(irarep,ifres(irr1),ilres(irr1),line,
         -            index,ir1,ic1,maxrec)
                    if (indexo(irr) .gt. 0 .and. indexo(irr1) .eq. 0) then
                      r2=dist2(c(1,irarep),c(1,inarep))
                      if (r2 .lt. resdlim2)
         -              call writeprox(iwrrdr,inarep,irarep,line,
         -                index,r2,iresno,ir1,ir2,ic1,ic2,is1,is2,maxrec)
                    end if
                    if (indexn(irr) .gt. 0 .and. indexn(irr1) .eq. 0) then
                      call findapproach(c,ifres(irr),ilres(irr),
         -              ifres(irr1),ilres(irr1),iatnum,ignoreh,irarepm,
         -              inarepm,r2,maxrec)
                      if (r2 .lt. resalim2)
         -              call writeprox(iwrrdc,irarepm,inarepm,line,
         -                index,r2,iresno,ir1,ir2,ic1,ic2,is1,is2,maxrec)
                      end if
                    end if
                end do
              end if
            end do
          end if
          write (iwrrmp,1003)
          if (ignoreh .eq. 1) write (iwrrmp,1002) 'Contact calculation'
          nrefat=0
          do irr=1,nrefres
            ir=listrefres(irr)
            do ia=ifres(ir),ilres(ir)
              if (ignoreh .eq. 0 .or. iatnum(ia) .gt. 1) then
                nrefat=nrefat+1
                itemp3(nrefat)=ia
              end if
            end do
          end do
          nnegat=0
          do irr=1,nnegres
            ir=listnegres(irr)
            do ia=ifres(ir),ilres(ir)
              if (ignoreh .eq. 0 .or. iatnum(ia) .gt. 1) then
                nnegat=nnegat+1
                itemp4(nnegat)=ia
              end if
            end do
          end do
          do ia=1,n
            temp1(ia)=100000.0
            temp2(ia)=100000.0
          end do
          do iaa=1,nrefat
            ia=itemp3(iaa)
            do jaa=1,nnegat
              ja=itemp4(jaa)
              rijsq=dist2(c(1,ia),c(1,ja))
              if (rijsq .lt. temp1(ia)) then
                itemp1(ia)=ja
                temp1(ia)=rijsq
              end if
              if (rijsq .lt. temp2(ja)) then
                itemp2(ja)=ia
                temp2(ja)=rijsq
              end if
            end do
          end do
          ncontact1=0
          distcontactsum1=0.0
          call zeroiti(indexo,0,n)
          call zeroiti(indexn,0,n)
          do iaa=1,nrefat
            ia=itemp3(iaa)
            if (itemp1(ia) .gt. 0) then
              if (itemp2(itemp1(ia)) .eq. ia) then
                call writeprox(iwrrmp,ia,itemp1(ia),line,index,temp1(ia),
         -        iresno,ir1,ir2,ic1,ic2,is1,is2,maxrec)
                indexo(ixres(ia))=1
                indexn(ixres(itemp1(ia)))=1
                irescount3(ixres(ia))=irescount3(ixres(ia))+1
                irescount3(ixres(itemp1(ia)))=irescount3(ixres(ia))+1
                  ncontact1=ncontact1+1
                  distcontactsum1=distcontactsum1+temp1(ia)
              end if
            end if
          end do
          if (ncontact1 .gt. 0)
         -  write (iwrrmp,1001) ncontact1,distcontactsum1/ncontact1
          call writeuniquelist(indexo,ixresno,nres,resnames,ir2-ir1+1,
         -  iwrrmp,irefres1,irefres2,irefresinc,itemp1,itemp2,
         -  'reference',9,maxrsd)
          call writeuniquelist(indexn,ixresno,nres,resnames,ir2-ir1+1,
         -  iwrrmp,inegres1,inegres2,inegresinc,itemp1,itemp2,
         -  'neighbour',9,maxrsd)
          return
    1001  format(' Number of residue pairs within threshold=',i6,
         -  ' Average distance=',f5.2,' A')
    1002  format(1x,a,' is based on heavy atoms only')
    1003  format(' Contact atom pairs are the atoms that are mutually ',
         -  'proximal to each other')
    1004  format(/,' Residue distances between the ',a,' and ',a,
         -  ' residues, based on the',/,1x,a,':')
          end
          subroutine header_rrdist(iw,nrefrange,nnegrange,resdistlim,
         -  irefseg1,ixrefres1,irefseg2,ixrefres2,irefres1,irefres2,
         -  inegseg1,ixnegres1,inegseg2,ixnegres2,inegres1,inegres2,
         -  incsolvrr,listrefres,listnegres,nrefres,nnegres,itemp,maxrsd)
          dimension listrefres(maxrsd),listnegres(maxrsd),itemp(maxrsd)
          write (iw,*)
          write (iw,2000) 'Reference',irefseg1,ixrefres1,irefseg2,
         -  ixrefres2,irefres1,irefres2
          if (nrefrange .gt. 1) then
            write (iw,2001) 'Reference'
            call zeroiti(itemp,0,maxrsd)
            do i=1,nrefres
              itemp(listrefres(i))=1
            end do
            call condensemask(itemp,1,listrefres(nrefres),iw,maxrsd)
          end if
          write (iw,2000) 'Neighbour',inegseg1,ixnegres1,inegseg2,
         -  ixnegres2,inegres1,inegres2
          if (nnegrange .gt. 1) then
            write (iw,2001) 'Neighbor'
            call zeroiti(itemp,0,maxrsd)
            do i=1,nnegres
              itemp(listnegres(i))=1
            end do
            call condensemask(itemp,1,listnegres(nnegres),iw,maxrsd)
          end if
          write (iw,2003)
          if (resdistlim .gt. 0.0) write (iw,2002) resdistlim
          if (incsolvrr .eq. 1) write (iw,2004) 'included'
          if (incsolvrr .eq. -1) write (iw,2004) 'excluded'
    2000  format(1x,a,' residue range:',/,
         -  ' chain',i3,' res ',i5,' - ', 'chain',i3,' res ',i5,
         -  ' (residue serial #s',i5,' - ',i5,')')
    2001  format(' NOTE: ',a,' residue range has gaps - actual ',
         -  'ranges:')
    2002  format(' Residue pairs will be printed when the calculated ',
         -  'distance is <',f6.2,' A')
    2003  format(" Residues not defined as 'reference' or 'neighbour' ",
         -  "residues are called 'other'")
    2004  format(' Solvents are ',a,' in the additional neighbor list')
          return
          end
          subroutine mmdist(c,n,atw,iatnum,nmolslt,molsltlim,c2,dist,
         -  ignoreh,iw0,iw1)
          dimension c(3,n),atw(n),iatnum(n),molsltlim(3,n),c2(3,n),dist(n)
          real*8 c0(3),atwsum
          do im=1,nmolslt
            call zeroitd(c0,3)
            atwsum=0.d0
            do ia=molsltlim(1,im),molsltlim(2,im)
              atwsum=atwsum+atw(ia)
              do k=1,3
                c0(k)=c0(k)+atw(ia)*c(k,ia)
              end do
              do k=1,3
                c0(k)=c0(k)+atw(ia)*c(k,ia)
              end do
            end do
            do k=1,3
              c2(k,im)=c0(k)/atwsum
            end do
          end do
          do im=1,nmolslt
            do imm=1,nmolslt
              dist(imm)=sqrt(dist2(c2(1,im),c2(1,imm)))
            end do
            write (iw0,1000) im,(dist(imm),imm=1,nmolslt)
            do imm=1,nmolslt
              rdist2=999999.0
              do iam=molsltlim(1,im),molsltlim(2,im)
                if (ignoreh .eq. 0) then
                  do iamm=molsltlim(1,imm),molsltlim(2,imm)
                    d2=dist2(c(1,iam),c(1,iamm))
                    if (d2 .lt. rdist2) rdist2=d2
                  end do
                else
                  if (iatnum(iam) .gt. 1) then
                    do iamm=molsltlim(1,imm),molsltlim(2,imm)
                      if (iatnum(iamm) .gt. 1) then
                        d2=dist2(c(1,iam),c(1,iamm))
                        if (d2 .lt. rdist2) rdist2=d2
                      end if
                    end do
                  end if
                end if
              end do
              dist(imm)=sqrt(rdist2)
            end do
            write (iw1,1000) im,(dist(imm),imm=1,nmolslt)
          end do
          return
    1000  format(' im=',i4,' D=',5f12.5,/,(11x,5f12.5))
          end
          subroutine writeprox(iout,irarep,inarep,line,index,r2,iresno,
         -  ir1,ir2,ic1,ic2,is1,is2,maxrec)
          dimension index(maxrec),iresno(maxrec)
          character* 132 line(maxrec)
          r2=sqrt(r2)
          write (iout,2060) line(index(irarep))(is1:is2),
         -  line(index(irarep))(ir1:ir2),iresno(irarep),
         -  line(index(irarep))(ic1:ic2),
         -  irarep,line(index(inarep))(is1:is2),
         -  line(index(inarep))(ir1:ir2),iresno(inarep),
         -  line(index(inarep))(ic1:ic2),inarep,r2
          return
    2060  format(1x,a,1x,a,' (',i4,') ',a,' (',i5,') - ',a,1x,a,
         -  ' (',i4,') ',a,' (',i5,')  Dist=',f8.3,' A')
          end
          subroutine writeuniquelist(index,ixresno,n,resnames,nrcol,iout,
         -  ires1,ires2,iresinc,itemp1,itemp2,label,llabel,mxrsd)
          dimension index(mxrsd),ixresno(mxrsd),itemp1(mxrsd),itemp2(mxrsd)
          character*(*) label
          character*8 resnames(mxrsd)
          nmem=0
          call zeroiti(itemp1,0,n)
          call zeroiti(itemp2,0,n)
          do i=ires1,ires2
            if (index(i) .ne. 0) then
              nmem=nmem+1
              itemp1(nmem)=i
            else
              itemp2(i)=i
            end if
          end do
          if (nmem .eq. 0) then
            write (iout,1003) 'contact',label(1:llabel)
          else
            write (iout,1000) 'contact',label(1:llabel),
         -   (' (',resnames(itemp1(i))(1:nrcol),ixresno(itemp1(i)),i=1,nmem)
            write (iout,1001) 'contact',label(1:llabel)
            call condensemask(index,ires1,ires2,iout,mxrsd)
            if (iresinc .gt. 0) write (iout,1002) iresinc
          end if
          nnonmem=0
          do i=1,n
            if (itemp2(i) .ne. 0) then
              nnonmem=nnonmem+1
              itemp1(nnonmem)=i
            end if
          end do
          if (nnonmem .gt. 0) then
            write (iout,1000) 'non-contact',label(1:llabel),
         -    (' (',resnames(itemp1(i))(1:nrcol),ixresno(itemp1(i)),
         -    i=1,nnonmem)
            write (iout,1001) 'non-contact',label(1:llabel)
            call condensemask(itemp2,ires1,ires2,iout,mxrsd)
            if (iresinc .gt. 0) write (iout,1002) iresinc
          end if
          return
    1000  format(' Nonredundant list of ',a,1x,a,' residues:',/,
         -  5(a,a,i5,')'))
    1001  format(' Residue SEQUENCE numbers of the ',a,1x,a,' residues:')
    1002  format(' Residue numbers are decremented by',i5,' to give the ',
         -  'sequence numbers')
    1003  format(' List of ',a,1x,a,' residue numbers is empty')
          end
          subroutine condenselist(index,len,incr,iout)
          dimension index(len)
          character*80 line
          i=1
          i1=index(1)
          i2=index(1)
          ic=1
          do while (i .lt. len)
            i=i+1
            if (index(i) .eq. index(i-1)+1 .and. i .lt. len) then
              i2=i2+1
            else
              if (i .eq. len) i2=index(i)
              call printrange(line,i1,i2,ic,incr,iout)
              i1=index(i)
              i2=index(i)
            end if
          end do
          if (ic .gt. 1) write (iout,1000) line(1:ic-2)
          return
    1000  format(1x,a)
          end
          subroutine condensemask(index,ires1,ires2,iout,mxrsd)
          dimension index(mxrsd)
          character*80 line
          ic=1
          i=ires1
          do while (i .le. ires2)
            do while (index(i) .eq. 0 .and. i .le. ires2)
              i=i+1
            end do
            if (i .le. ires2) then
              i1=i
              do while (index(i) .gt. 0 .and. i .le. ires2)
                i=i+1
              end do
              i2=i-1
              call printrange(line,i1,i2,ic,0,iout)
            end if
          end do
          if (ic .gt. 1) write (iout,1000) line(1:ic-2)
          return
    1000  format(1x,a)
          end
          subroutine printrange(line,i1,i2,ic,incr,iout)
          character*(*) line
          if (i1 .eq. i2) then
            if (ic .gt. 72-incr) then
              write (iout,1000) line(1:ic-1)
              ic=1
            end if
            call writeint(line,ic,i1,lenw)
          else
            if (ic .gt. 68-incr) then
              write (iout,1000) line(1:ic-1)
              ic=1
            end if
            call writeint(line,ic,i1,lenw)
            line(ic:ic)='-'
            ic=ic+1
            call writeint(line,ic,i2,lenw)
          end if
          line(ic:ic)=','
          ic=ic+1
          return
    1000  format(1x,a)
          end
          subroutine print_rrdist(itypavg,nframe,irefres1,irefres2,inegres1,
         -  inegres2,listrefres,nrefres,listnegres,nnegres,nrescol,iwrrdr,
         -  iwrrdc,ips,ipspage,resnames,inpfile,namleni,itemp,mxrsd)
          dimension itemp(mxrsd),listrefres(mxrsd),listnegres(mxrsd)
          character*8 resnames(mxrsd)
          character*(*) inpfile
          common /colorinfo/ ncolcode,maxcolcode
          parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
          parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
         -  (6*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
          common /nnwork/ sdm(MAX2D,MAX2D),nng(MAX2D),rmsd(MAX2D,MAX2D),
         -  ihbtores(MAXBONDS),nusepair(MAXBONDS),nhb_atot(MAXBONDS),
         -  nhb_rtot(MAXBONDS),a1(MAXBONDS),a2(MAXBONDS),fill(IFILL2)
          dimension kc(1,1),xyval(1)
          character*4 yclab(1)
          character*14 distlab
          character*80 title2
          real*8 dc(1,1)
          data nyclab /1/,lyclab /1/
          if (ips .eq. 0) return
          if (itypavg .eq. 1) then
            iw=iwrrdr
            distlab='representative'
            ldistlab=14
          else
            iw=iwrrdc
            distlab='closest'
            ldistlab=7
          end if
          title2='Maximum '//distlab(1:ldistlab)//
         -  ' atom based distance to print'
          ltitle2=ldistlab+37
          call getreal(title2,ltitle2,999999.0,rprtmax,1,0)
          title2='Average residue-residue distances based on '//
         -  distlab(1:ldistlab)//' atom distances'
          ltitle2=ldistlab+62
          write (iw,1001) title2(1:ltitle2)
          do irrr=1,nrefres
            irr=listrefres(irrr)
            do inrr=1,nnegres
              inr=listnegres(inrr)
              rmsd(irr-irefres1+1,inr-inegres1+1)=
         -      rmsd(irr-irefres1+1,inr-inegres1+1)/float(nframe)
              sdm(irr-irefres1+1,inr-inegres1+1)=
         -    sqrt(sdm(irr-irefres1+1,inr-inegres1+1)/float(nframe)-
         -    rmsd(irr-irefres1+1,inr-inegres1+1)**2)
              if (rmsd(irr-irefres1+1,inr-inegres1+1) .le. rprtmax)
         -      write (iw,1000) irr,resnames(irr)(1:nrescol),inr,
         -        resnames(inr)(1:nrescol),
         -        rmsd(irr-irefres1+1,inr-inegres1+1),
         -        sdm(irr-irefres1+1,inr-inegres1+1)
            end do
          end do
          call getreal(
         -  'Upper limit of the distance range to color code in the matrix',
         -   61,999999.0,rcmax,1,0)
          rcmin=0.0
          call getint('Number of colors to use',23,5,1,maxcolcode,ncolcode,
         -  0)
          nresx=irefres2-irefres1+1
          nresy=inegres2-inegres1+1
          scalefac=amin1(1.0,500.0/float(max0(nresx,nresy)))
          ixdel=25
          iydel=115
          iytop=0
          incinp=max0(1,500/max0(nresx,nresy))
          call indexit(itemp,1,mxrsd,0)
          call plotmat(ips,kc,rmsd,dc,nresx,nresy,irefres1-1,inegres1-1,
         -  irefres1-1,inegres1-1,1,0,0,iydel,00,iytop,rcmin,rcmax,ncolcode,
         -  maxcolcode,ixdel,iydel,incinp,scalefac,itemp,itemp,itemp,
         -  inpfile,namleni,title2,ltitle2,0,' ',0,xyval,yclab,nyclab,
         -  lyclab,1,MAX2D,1,mxrsd,mxrsd,ipspage,0)
          ixd=ixdel
          if (ncolcode .le. 5) ixd=ixd+60
          call colcodeminmax(ips,ixd,-60,0,ncolcode,maxcolcode,rcmin,rcmax)
          return
    1000  format(' Res #',i6,'(',a,') - Res #',i6,'(',a,'): <d>=',f8.4,
         -  ' A sd=',f8.4)
    1001  format(/,1x,a,' averages over the trajectory',/)
          end
          subroutine plot_ccc(ndials,iout,ips,ipspage,angnames,langnames,
         -  inpfile,namleni)
          dimension langnames(ndials)
          character*(*) angnames(ndials)
          character*(*) inpfile
          common /colorinfo/ ncolcode,maxcolcode
          parameter (MAXPHI=400,MAX2D=5000)
          parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-(MAX2D*MAX2D+MAX2D))
          common /nnwork/ ccc(MAX2D,MAX2D),itemp(MAX2D),fill(IFILL2)
          dimension kc(1,1),xyval(1)
          real*8 dc(1,1)
          character*4 yclab(1)
          character*80 title2
          data nyclab /1/,lyclab /1/
          data title2 /'Circular correlation matrix'/,ltitle2 /28/
          if (ips .eq. 0) return
          rcmin=-1.0
          rcmax=1.0
          call getint('Number of colors to use',23,5,1,maxcolcode,
         -  ncolcode,0)
          scalefac=amin1(1.0,500.0/float(ndials))
          ixdel=25
    !     iydel=115
          iydel=100
          iytop=0
          incinp=max0(1,500/ndials)
          call indexit(itemp,1,ndials,0)
          call plotmat(ips,kc,ccc,dc,ndials,ndials,0,0,0,0,1,0,0,iydel,00,
         -  iytop,rcmin,rcmax,ncolcode,maxcolcode,ixdel,iydel,incinp,
         -  scalefac,itemp,itemp,itemp,inpfile,namleni,title2,ltitle2,0,' ',
         -  0,xyval,yclab,nyclab,lyclab,1,MAX2D,1,MAX2D,MAX2D,ipspage,0)
          ixd=ixdel
          if (ncolcode .le. 5) ixd=ixd+65
          call colcodeminmax(ips,ixd,-65,0,ncolcode,maxcolcode,rcmin,
         -  rcmax)
          call pswrite(ips,150,25,'m',1)
          write (ips,*) '(Range of data: [-1.0,1.0]) show'
          return
          end
          subroutine cluster_ccc(ndials,angnames,langnames,
         -  ixclst,ifclst,ilclst,index2d,it1,it2,it3,it4,label,llabel,iout,
         -  inpfile,namleni)
          dimension langnames(ndials),ixclst(ndials),ifclst(ndials),
         -  ilclst(ndials),index2d(ndials),it1(ndials),it2(ndials),
         -  it3(ndials),it4(ndials)
          character*(*) angnames(ndials),label
          character*(*) inpfile
          parameter (MAXPHI=400,MAX2D=5000)
          parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-(MAX2D*MAX2D+9*MAX2D))
          common /nnwork/ ccc(MAX2D,MAX2D),irepav(MAX2D),irepmx(MAX2D),
         -  irepeng(MAX2D),irepkm(MAX2D),etotsaved(2,MAX2D),cv(MAX2D),
         -  engcl(MAX2D),indexa(MAX2D),fill(IFILL2)
          character*41 clstyp
          common /cluster_typ/ nclstyp,inumclst(9),ireadcutoff(9),
         -  lclstyp(9),clstyp(9)
          character*1 ans
          character*80 line
          do i=1,ndials
            do j=1,ndials
              ccc(i,j)=1.0-abs(ccc(i,j))
            end do
          end do
          nrdclust=0
    8910  call quiz(ans,iclstyp,' ',' ',0,'clustering algorithm',20,
         -  0,5,6,40)
          if (iclstyp .gt. 7) then
            print *,'Sorry, this option is not available here'
            go to 8910
          end if
          write (iout,2060) clstyp(iclstyp),ndials
          write (6,2060) clstyp(iclstyp),ndials
          if (iclstyp .ne. 4) call zeroiti(irepkm,0,ndials)
          if (inumclst(iclstyp) .eq. 1) then
            call getint('Number of clusters requested',28,999999,1,ndials,
         -    nclust,0)
            rdclust=0.0
            write (iout,2061) nclust
          else if (ireadcutoff(iclstyp) .eq. 1) then
            write (line,1014) label(1:llabel)
            call getreal(line,22+llabel,999999.0,rdclust,1,0)
          end if
          call rmsdcluster(rdclust,1,ndials,index2d,iwt,ixclst,ifclst,
         -    ilclst,it1,it2,it3,irepav,irepmx,it4,c,cent,cent_prev,irepkm,
         -    0,iclstyp,0,0,nclust,1,0,ifail,1,' ',1,iout)
          write (iout,7824) (ifclst(i),ilclst(i),i=1,nclust)
     7824 format(' After RMSDCLUSTER Cluster limits: ',('[',i5,',',i5,']'))
          write (iout,6792) 'IXCLST',(ixclst(i),i=1,ndials)
     6792 format(' AFTER RMSDCLUSTER ',a,':',/,(20i5))
          if (ifail .gt. 0) go to 8910
          if (ans .ne. 'k') write (6,2090) label(1:llabel),rdclust,nclust
          call reportclust(ndials,0,1,nclust,ifclst,ilclst,index2d,value,
         -  it1,it2,it3,it4,cv,indexa,irepav,irepmx,irepeng,irepkm,engcl,
         -  nhbdist,etotsaved,0,1,'RMSD',4,1,idistprint,nomemprint,iout,
         -  MAX2D,MAX2D)
          return
    1014  format(a,' cutoff for clustering')
    2060  format(/,' === Clustering method: ',a,/,
         -  ' Number of items to cluster=',i6)
    2061  format(' Number of clusters requested=',i5)
    2090  format(1x,a,' threshold=',f9.2,' number of clusters=',i4)
          end
          subroutine compare_rrdist(resnames,nrescol,itemp,bfac,irefres1,
         -  irefres2,plotfile,lplotfile,mxrsd)
          dimension itemp(mxrsd),bfac(mxrsd)
          character*8 resnames(mxrsd)
          parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
          parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
         -  (6*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
          common /nnwork/ rr1(MAX2D,MAX2D),nng(MAX2D),rr2(MAX2D,MAX2D),
         -  ihbtores(MAXBONDS),nusepair(MAXBONDS),nhb_atot(MAXBONDS),
         -  nhb_rtot(MAXBONDS),a1(MAXBONDS),a2(MAXBONDS),fill(IFILL2)
          common /colorinfo/ ncolcode,maxcolcode
          character*4 yclab(1)
          character*200 plotfile,title2,inpfile1,inpfile2
          character*80 title1
          dimension kc(1,1),xyval(1)
          real*8 dc(1,1)
          data nyclab /1/,lyclab /1/
          ifail=1
          do while (ifail .eq. 1)
            call read_rrdist(rr1,41,'first',5,irefres1,irefres2,inegres1,
         -    inegres2,inpfile1,linpfile1,ifail1,MAX2D)
            call read_rrdist(rr2,41,'second',6,irefres11,irefres22,
         -    inegres11,inegres22,inpfile2,linpfile2,ifail2,MAX2D)
            if (irefres1 .ne. irefres11 .or. irefres2 .ne. irefres22 .or.
         -      inegres1 .ne. inegres11 .or. inegres2 .ne. inegres22) then
              print *,'Residue ranges differ - can not run the comparison'
            else
              ifail=ifail1+ifail2
            end if
            if (ifail .gt. 0) write (6,1005)
          end do
          lplotfile=0
          call openfile(42,0,'average distance matrix difference',34,'new',
         -  plotfile,lplotfile,notfnd,0,1,1,0,0)
          rdmin=99999.0
          rdmax=-rdmin
          call askyn('Do you want absolute values in the difference plot',
         -  50,1,-1,iabsval,0,0)
          call getreal('Maximum distance to show',24,10000.0,dmaxshow,1,132)
          call zeroit(bfac,mxrsd)
          ncount_tot=0
          do irr=irefres1,irefres2
            ir=irr-irefres1+1
            ncount=0
            do inr=inegres1,inegres2
              in=inr-inegres1+1
              diffrn=rr1(ir,in)-rr2(ir,in)
              write (42,1000) irr,resnames(irr)(1:nrescol),
         -      inr,resnames(inr)(1:nrescol),rr1(ir,in),rr2(ir,in),diffrn
              if (iabsval .eq. 1) diffrn=abs(diffrn)
              if (diffrn .lt. rdmin) rdmin=diffrn
              if (diffrn .gt. rdmax) rdmax=diffrn
              if (rr1(ir,in) .gt. dmaxshow .and.
         -        rr2(ir,in) .gt. dmaxshow) then
                rr1(ir,in)=0.0
              else
                rr1(ir,in)=diffrn
                bfac(irr)=bfac(irr)+abs(rr1(ir,in))
                ncount=ncount+1
              end if
            end do
            ncount_tot=ncount_tot+ncount
            write (42,1002) ' N',dmaxshow,ncount
            if (ncount .eq. 0) ncount=1
            bfac(irr)=bfac(irr)/float(ncount)
          end do
          write (42,1002) ' Total n',dmaxshow,ncount_tot
          write (42,1003) dmaxshow
          do irr=irefres1,irefres2
            ir=irr-irefres1+1
            do inr=inegres1,inegres2
              in=inr-inegres1+1
              if (rr1(ir,in) .ne. 0.0) write (42,1004) irr,
         -      resnames(irr)(1:nrescol),inr,resnames(inr)(1:nrescol),
         -      rr1(ir,in),rr2(ir,in)
            end do
          end do
          if (iabsval .eq. 1) rdmin=0.0
          close (42)
          ips=43
          plotfile(lplotfile+1:lplotfile+3)='.ps'
          lplotfile=lplotfile+3
          call openfile(ips,0,'average distance matrix difference',34,'new',
         -  plotfile,lplotfile,notfnd,0,1,1,0,0)
          write (6,1001) plotfile(1:lplotfile),rdmin,rdmax
          title2='Average distance matrix difference plot'
          ltitle2=39
          ltitle1=linpfile1+linpfile2+3
          title1(1:ltitle1)=
         -  inpfile1(1:linpfile1)//' - '//inpfile2(1:linpfile2)
          call openps(ips,500.0,500.0,' ',1,' ',1,plotfile,0,
         -  plotfile,0,1,ipspage)
          call getint('Number of colors to use',23,5,1,maxcolcode,ncolcode,
         -  0)
          nresx=irefres2-irefres1+1
          nresy=inegres2-inegres1+1
          scalefac=amin1(1.0,500.0/float(max0(nresx,nresy)))
          ixdel=25
          iydel=115
          iytop=0
          incinp=max0(1,500/max0(nresx,nresy))
          call indexit(itemp,1,mxrsd,0)
          call plotmat(ips,kc,rr1,dc,nresx,nresy,irefres1-1,inegres1-1,0,0,
         -  1,0,0,iydel,00,iytop,rdmin,rdmax,ncolcode,maxcolcode,ixdel,
         -  iydel,incinp,scalefac,itemp,itemp,itemp,title1,ltitle1,title2,
         -  ltitle2,0,' ',0,xyval,yclab,nyclab,lyclab,1,MAX2D,1,mxrsd,
         -  mxrsd,ipspage,0)
          ixd=ixdel
          if (ncolcode .le. 5) inxd=ixd+60
          call colcodeminmax(ips,ixd,-60,0,ncolcode,maxcolcode,rdmin,rdmax)
          return
    1000  format(' Res #',i6,'(',a,') - Res #',i6,'(',a,'):<d1>=',f6.2,
         -  ' <d2>=',f6.2,' <d1>-<d2>=',f7.3)
    1001  format(' Residue distance difference matrix plots are on file ',a,
         -  /,' Range of differences: [',f10.5,',',f10.5,'] A')
    1002  format(a,'umber of pairs within ',f5.1,' A:',i5)
    1003  format(' Distance changes for pairs closer than ',f5.2,' A')
    1004  format(' Res #',i6,'(',a,') - Res #',i6,'(',a,'):<d1>-<d2>=',f6.2,
         -  ' <d2>=',f6.2)
    1005  format(' NOTE: input file should be the .rsd file written by the',
         -  /,'R<E>sidue distance list option of distance analysis')
          end
          subroutine read_rrdist(rr,inpt,lab,llab,irefres1,irefres2,
         -  inegres1,inegres2,inpmat,linpmat,ifail,mxdim)
          dimension rr(mxdim,mxdim)
          character*(*) lab
          character*80 inpmat,prompt,line
          ifail=0
          prompt(1:llab)=lab(1:llab)
          prompt(llab+1:llab+24)=' residue distance matrix'
          lprompt=llab+24
          linpmat=0
          call openfile(inpt,0,prompt,lprompt,'old',inpmat,linpmat,notfnd,
         -  0,1,1,0,0)
          if (inpmat(linpmat-3:linpmat) .ne. '.rsd' .and.
         -    inpmat(linpmat-3:linpmat) .ne. '.rsm') write (6,1002)
          istart=1
          nresfound=0
          do while (.true.)
            read (inpt,1000,end=999) line
            if (line(1:6) .eq. ' Res #') then
              nresfound=nresfound+1
              read (line(07:12),*,end=888,err=888) irefres
              read (line(26:31),*,end=888,err=888) inegres
              if (istart .eq. 1) then
                istart=0
                irefres1=irefres
                inegres1=inegres
              end if
              read (line(43:50),*,end=888,err=888)
         -      rr(irefres-irefres1+1,inegres-inegres1+1)
            end if
          end do
    999   close (inpt)
          if (nresfound .gt. 0) then
            irefres2=irefres
            inegres2=inegres
            write (6,1001) irefres1,irefres2,inegres1,inegres2,nresfound
          else
            write (6,*) 'ERROR: No residue distance record was found'
            ifail=1
          end if
          return
    888   print *,'ERROR reading record'
          print *,line(1:66)
          close (inpt)
          ifail=1
          return
    1000  format(a)
    1001  format(' Residue ranges found: [',i6,',',i6,'] and [',i6,',',
         -  i6,']',/,' Number of distance records read=',i4)
    1002  format(' WARNING: input file extension is not .rsd or .rsm')
          end
          subroutine compare_bondmat(resnames,nrescol,itemp,bfac,nres,
         -  plotfile,lplotfile,mxrsd)
          dimension itemp(mxrsd),bfac(mxrsd)
          character*8 resnames(mxrsd)
          character(*) plotfile
          parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
          parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
         -  (6*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
          common /nnwork/ rnb1(MAX2D,MAX2D),nng(MAX2D),rnb2(MAX2D,MAX2D),
         -  ihbtores(MAXBONDS),nusepair(MAXBONDS),nhb_atot(MAXBONDS),
         -  nhb_rtot(MAXBONDS),a1(MAXBONDS),a2(MAXBONDS),fill(IFILL2)
          common /colorinfo/ ncolcode,maxcolcode
          character*1 ans
          character*4 yclab(1)
          character*200 title1,title2,inpfile1,inpfile2
          dimension kc(1,1),xyval(1)
          real*8 dc(1,1),sum1,sum2
          data nyclab /1/,lyclab /1/
          call read_bondmat(rnb1,41,'first',5,nres,inpfile1,linpfile1,
         -  itemp,MAX2D)
          call read_bondmat(rnb2,41,'second',6,nres,inpfile2,linpfile2,
         -  itemp,MAX2D)
          lplotfile=0
          write (6,1004)
          call openfile(42,0,'residue bond matrix difference',30,'new',
         -  plotfile,lplotfile,notfnd,0,1,1,0,0)
          call quiz(ans,idifftyp,' ',' ',0,'bond-difference plot type',25,
         -  0,5,6,000)
          rnbmin=99999.9
          rnbmax=-rnbmin
          sum1=0.d0
          sum2=0.d0
          isum1=0
          isum2=0
          call zeroit(bfac,nres)
          do ir=1,nres
            do in=1,nres
              sum1=sum1+rnb1(ir,in)
              sum2=sum2+rnb2(ir,in)
              if (rnb1(ir,in) .gt. 0.0 .and. rnb2(ir,in) .eq. 0.0)
         -      isum1=isum1+1
              if (rnb1(ir,in) .eq. 0.0 .and. rnb2(ir,in) .gt. 0.0)
         -      isum2=isum1+1
              diff=rnb1(ir,in)-rnb2(ir,in)
              write (42,1000) ir,resnames(ir)(1:nrescol),
         -      in,resnames(in)(1:nrescol),diff
              if (diff .lt. rnbmin) rnbmin=diff
              if (diff .gt. rnbmax) rnbmax=diff
              if (idifftyp .eq. 1) then
                rnb1(ir,in)=diff
              else if (idifftyp .eq. 2) then
                rnb1(ir,in)=abs(diff)
              else if (idifftyp .eq. 3) then
                if (rnb1(ir,in) .eq. 0.0 .and. rnb2(ir,in) .gt. 0.0) then
                  rnb1(ir,in)=+1.0
                else if (rnb1(ir,in) .gt. 0.0 .and.rnb2(ir,in) .eq. 0.0)then
                  rnb1(ir,in)=-1.0
                else
                  rnb1(ir,in)=0.0
                end if
              end if
              bfac(ir)=bfac(ir)+rnb1(ir,in)
            end do
          end do
          if (idifftyp .eq. 2) then
            rnbmax=amax1(abs(rnbmin),abs(rnbmax))
            rnbmin=0.0
          else if (idifftyp .eq. 3) then
            rnbmax=1.0
            rnbmin=-1.0
          end if
          write (6,1003) inpfile1(1:linpfile1),sum1,isum1
          write (6,1003) inpfile2(1:linpfile2),sum2,isum2
          write (6,1002) rnbmin,rnbmax
          if (idifftyp .ne. 3) then
            call getreal('Minimum difference to show',26,rnbmin,rnbmin,1,0)
            call getreal('Maximum difference to show',26,rnbmax,rnbmax,1,0)
          end if
          close (42)
          ips=43
          plotfile(lplotfile+1:lplotfile+3)='.ps'
          lplotfile=lplotfile+3
          call openfile(ips,0,'residue bond matrix difference',30,'new',
         -  plotfile,lplotfile,notfnd,0,1,1,0,0)
          write (6,1001) plotfile(1:lplotfile)
          title2='Average distance matrix difference plot'
          ltitle2=39
          if (idifftyp .eq. 2) then
            title2(ltitle2+1:ltitle2+18)=' - absolute values'
            ltitle2=ltitle2+18
          else if (idifftyp .eq. 3) then
            title2(ltitle2+1:ltitle2+27)=' - signs of the differences'
            ltitle2=ltitle2+27
          end if
          ltitle1=linpfile1+linpfile2+3
          title1(1:ltitle1)=
         -  inpfile1(1:linpfile1)//' - '//inpfile2(1:linpfile2)
          call openps(ips,500.0,500.0,' ',1,' ',1,plotfile,0,
         -  plotfile,0,1,ipspage)
          call getint('Number of colors to use',23,5,1,maxcolcode,ncolcode,
         -  0)
          scalefac=amin1(1.0,500.0/float(nres))
          ixdel=25
          iydel=115
          iytop=0
          incinp=max0(1,500/nres)
          call indexit(itemp,1,mxrsd,0)
          call plotmat(ips,kc,rnb1,dc,nres,nres,0,0,0,0,1,0,0,iydel,00,
         -  iytop,rnbmin,rnbmax,ncolcode,maxcolcode,ixdel,iydel,incinp,
         -  scalefac,itemp,itemp,itemp,title1,ltitle1,title2,ltitle2,0,' ',
         -  0,xyval,yclab,nyclab,lyclab,1,MAX2D,1,mxrsd,mxrsd,ipspage,0)
          ixd=ixdel
          if (ncolcode .le. 5) inxd=ixd+60
          call colcodeminmax(ips,ixd,-60,0,ncolcode,maxcolcode,rnbmin,
         -  rnbmax)
          return
    1000  format(' Res #',i6,'(',a,') - Res #',i6,'(',a,'): <nb1>-<nb2>=',
         -  f6.3)
    1001  format(' Residue bond difference matrix plots are on file ',a)
    1002  format(' Range of differences: [',f6.3,',',f6.3,'] A')
    1003  format(' Sum of bonds in ',a,'=',f10.3,' sum of (+) changes=',i6)
    1004  format(' Comparing two residue-residue bond frequency matrices',/,
         -  ' written by the bond-tracking option of Simulaid')
          end
          subroutine read_bondmat(rnb,inpt,lab,llab,nres,inpmat,linpmat,
         -  itemp,mxdim)
          dimension rnb(mxdim,mxdim),itemp(nres)
          character*(*) lab
          character*80 inpmat,prompt,line
          do ir=1,nres
            do jr=1,nres
              rnb(ir,jr)=0.0
            end do
          end do
          prompt(1:llab)=lab(1:llab)
          prompt(llab+1:llab+28)=' residue-residue bond matrix'
          lprompt=llab+28
          linpmat=0
          call openfile(inpt,0,prompt,lprompt,'old',inpmat,linpmat,notfnd,
         -  0,1,1,0,0)
          call indexit(itemp,1,nres,0)
          do while (line(1:19) .ne. ' Average number of ' .and.
         -  line(1:12) .ne. ' iy(orig):')
            call blankout(line,1,80)
            read (inpt,1000,end=999) line
          end do
          ixf=0
          ixl=1
          if (line(1:12) .eq. ' iy(orig):') then
            ifr=1
            ilr=10
            call lastchar(line,lc,80)
            if (lc .lt. 73) ilr=ilr-(73-lc)/5
            read (line(24:73),1002,end=888,err=888) (itemp(i),i=ifr,ilr)
            do while (lc .eq. 73)
              ifr=ilr+1
              ilr=ilr+10
              call blankout(line,1,80)
              read (inpt,1000,end=999) line
              call lastchar(line,lc,80)
              if (lc .lt. 73) ilr=ilr-(73-lc)/5
              read (line(24:73),1002,end=888,err=888) (itemp(i),i=ifr,ilr)
            end do
            do while (line(1:19) .ne. ' Average number of ')
              read (inpt,1000,end=999) line
            end do
          end if
          iymin=99999
          iymax=0
          read (inpt,1000,end=999) line
          do while (.true.)
            ixf=1
            ixl=0
            if (line(10:18) .eq. 'iy(orig)=') then
              read (line(19:23),*,end=888,err=888) iyorig
              read (line(5:8),*,end=888,err=888) iy
              if (itemp(iy) .ne. iyorig) then
                write (6,1003) iy,iyorig,itemp(iy)
                stop
              end if
              if (iy .lt. iymin) iymin=iy
              if (iy .gt. iymax) iymax=iy
              ixf=1
              ixl=ixf+9
              read (line(25:74),1001,end=888,err=888)
         -      (rnb(itemp(irx),iyorig),irx=ixf,ixl)
              read (inpt,1000,end=999) line
              do while(line(10:18) .ne. 'iy(orig)=' .and.
         -             line(1:17) .ne. ' Fraction of time')
                ixf=ixl+1
                ixl=ixf+9
                read (line(25:74),1001,end=888,err=888)
         -        (rnb(itemp(irx),iyorig),irx=ixf,ixl)
                read (inpt,1000,end=999) line
              end do
              if (line(1:17) .eq. ' Fraction of time') go to 999
            end if
          end do
    999   close (inpt)
          write (6,1004) iymin,iymax
          return
    888   print *,'ERROR reading record ixf,ixl=',ixf,ixl
          print *,line(1:66)
          close (inpt)
          return
    1000  format(a)
    1001  format(10f5.2)
    1002  format(10i5)
    1003  format(' PROGRAM ERROR: iy=',i5,' iyorig=',i5,' iyorig(iy)=',i5)
    1004  format(' Bond matrix info read for indices [',i5,',',i5,']')
          end
          subroutine compare_rmsf(resnames,nrescol,siglev,bfac,plotfile,
         -  lplotfile,irmin,irmax,mxrsd)
          dimension bfac(mxrsd)
          character*8 resnames(mxrsd)
          parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
          parameter (MAXRSD=70000)
          parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-4*MAXRSD)
          common /nnwork/ rmsf1(MAXRSD),rmsf2(MAXRSD),sd1(MAXRSD),
         -  sd2(MAXRSD),fill(IFILL2)
          common /colorinfo/ ncolcode,maxcolcode
          character*(*) plotfile
          common /t_test/ t_test_CI_1(5),t_test_CI_2(5),t_test_table(5,30)
          character*200 inpfile1,inpfile2
          call read_rmsf(rmsf1,sd1,41,'first',5,irmin,irmax,
         -  inpfile1,linpfile1,MAXRSD)
          call read_rmsf(rmsf2,sd2,42,'second',6,irmin2,irmax2,
         -  inpfile2,linpfile2,MAXRSD)
          if (irmin .ne. irmin2 .or. irmax .ne. irmax2) then
            print *,'Residue ranges differ - can not run the comparison'
            return
          end if
          lplotfile=0
          call openfile(42,0,'RMSF difference',15,'new',
         -  plotfile,lplotfile,notfnd,0,1,1,0,0)
          call zeroit(bfac,irmax)
          n1=10
          n2=10
          do ir=irmin,irmax
            rmsf_diff=rmsf1(ir)-rmsf2(ir)
            s12=sd1(ir)**2/n1+sd2(ir)**2/n2
            t=abs(rmsf_diff)/sqrt(s12)
            dof=s12**2/((sd1(ir)**2/n1)**2/(n1-1)+(sd2(ir)**2/n2)**2/(n2-1))
            idof=dof
            idof=min0(30,max0(1,idof))
            isig=1
            sig=1.0
            do while (t .gt. t_test_table(isig,idof) .and. isig .lt. 5)
              sig=t_test_CI_2(isig)
              isig=isig+1
            end do
            if (isig .eq. 5) then
              if (t .gt. t_test_table(isig,idof)) then
                sig=t_test_CI_2(isig)
              else
                isig=isig-1
              end if
            end if
            write (42,1001) ir,resnames(ir)(1:nrescol),rmsf1(ir),sd1(ir),
         -    rmsf2(ir),sd2(ir),rmsf_diff,t,dof,t_test_CI_2(isig)
            if (siglev .gt. 0.0 .and. sig .gt. siglev) rmsf_diff=0.0
            bfac(ir)=rmsf_diff
          end do
          return
    1001  format(i6,1x,a,' F1=',f5.1,' sd=',f5.1,' F2=',f5.1,
         -  ' sd2=',f5.1,' D=',f5.1,' t=',f5.1,' df=',f4.1,' p<',f5.3)
          end
          subroutine read_rmsf(rmsf,sd,inpt,lab,llab,irmin,irmax,
         -  inpfile,linpfile,mxres)
          dimension rmsf(mxres),sd(mxres)
          character*(*) lab
          character*200 inpfile,prompt,line
          prompt(1:llab)=lab(1:llab)
          prompt(llab+1:llab+5)=' RMSF'
          lprompt=llab+5
          linpfile=0
          call openfile(inpt,0,prompt,lprompt,'old',inpfile,linpfile,notfnd,
         -  0,1,1,0,0)
          istart=1
          irmin=0
          ir=0
          call zeroit(rmsf,mxres)
          call zeroit(sd,mxres)
          do while (.true.)
            read (inpt,1000,end=999) line
            if (line(7:10) .eq. 'RMSF') then
              read (line(1:6),*,end=888,err=888) ir
              read (line(11:16),*,end=888,err=888) rmsf_ir
              read (line(21:26),*,end=888,err=888) sd_ir
              if (irmin .eq. 0) irmin=ir
              if (ir .gt. 0 .and. ir .le. mxres) then
                rmsf(ir)=rmsf_ir
                sd(ir)=sd_ir
              else
                write (6,1002) ir,1,mxres
              end if
            end if
          end do
    999   close (inpt)
          irmax=ir
          write (6,1003) irmax
          return
    888   print *,'ERROR reading record'
          print *,line(1:66)
          close (inpt)
          write (6,1001)
          return
    1000  format(a)
    1001  format(' Residue range found: [',i6,',',i6,']')
    1002  format(' ERROR: residue # read (',i6,') is outside the range [',
         -  i6,',',i6,']')
    1003  format(' Number of RMSF records found=',i6)
          end
          subroutine rrconn(c,n,numres1,numres2,ifres,ilres,iatnum,
         -  ignoreh,irepuse,iadjtyp,iscalesum,resdistlim,nexpmax,npint,
         -  ipspage,npspages,ilog,iplot,line,index,ir1,ic1,
         -  imarkres,marks,imarks,iarep,iconnsum,itemp,rconnsum,inpfile,
         -  linpfile,markfile,lmarkfile,maxrec)
          dimension c(3,n),index(n),ifres(numres2),ilres(numres2),
         -  iatnum(n),imarks(numres2),iarep(n),iconnsum(n),itemp(n),
         -  rconnsum(n)
          character*1 marks(9)
          character* 132 line(maxrec)
          character*(*) inpfile,markfile
          parameter (MAXPHI=400,MAXCONN=2900,MAXCONN10=10*MAXCONN)
          parameter (IFILL8=MAXPHI*MAXPHI*MAXPHI-3*MAXCONN*MAXCONN
         -  -11*MAXCONN)
          common /nnwork/ rij1(MAXCONN,MAXCONN),rij2(MAXCONN,MAXCONN),
         -  rij3(MAXCONN,MAXCONN),xres(MAXCONN),yres(MAXCONN10),fill(IFILL8)
          dimension ifg(10),imf(10),iml(10),iexpplot(10),lfclab(10)
          character*8 fclab(10)
          character*200 title1,title2
          data connmax /0.0/
          write (6,1003) numres1,numres2
          if (iadjtyp .eq. 1)
         -   write (ilog,1005) '0/1 (integer)','matrix product'
          if (iadjtyp .eq. 2)
         -   write (ilog,1005) '0.0-1.0 (weighted)','matrix product'
          if (iadjtyp .eq. 3)
         -  write (ilog,1005) '0.0-1.0 (weighted)','matrix product-like sum'
          resdistlim2=resdistlim**2
          numres=numres2-numres1+1
          do i1=1,numres
            do i2=1,numres
              rij1(i1,i2)=0.0
              rij2(i1,i2)=0.0
              rij3(i1,i2)=0.0
            end do
          end do
          if (irepuse .gt. 0) then
            write (ilog,1001) 'representative atoms',resdistlim
            title2='Distances based on representative atoms;'
            ltitle2=40
            do irr=numres1,numres2
              call findat(iarep(irr),ifres(irr),ilres(irr),line,index,
         -     ir1,ic1,maxrec)
            end do
            do i1=numres1+1,numres2
              ii1=i1-numres1+1
              do i2=numres1,i1-1
                ii2=i2-numres1+1
                rijsq=dist2(c(1,iarep(i1)),c(1,iarep(i2)))
                if (rijsq .lt. resdistlim2) then
                  rij1(ii1,ii2)=rijsq
                  rij1(ii2,ii1)=rijsq
                end if
              end do
            end do
          else
            write (ilog,1001) 'closest approach',resdistlim
            title2='Distances based on closest approach;'
            ltitle2=36
            if (ignoreh .eq. 1) write (ilog,1002)
            do i1=numres1+1,numres2
              ii1=i1-numres1+1
              do i2=numres1,i1-1
                ii2=i2-numres1+1
                call findapproach(c,ifres(i1),ilres(i1),ifres(i2),
         -        ilres(i2),iatnum,ignoreh,iarep1,iarep2,rijsq,maxrec)
                if (rijsq .lt. resdistlim2) then
                  rij1(ii1,ii2)=rijsq
                  rij1(ii2,ii1)=rijsq
                end if
              end do
            end do
          end if
          do i1=2,numres
            do i2=1,i1-1
              if (rij1(i1,i2) .gt. 0.0) then
                if (iadjtyp .eq. 1) then
                  rij=1.0
                else
                  if (rij1(i1,i2) .lt. 9.0) then
                    rij=1.0
                  else
                    r=sqrt(rij1(i1,i2))
                    rij=(resdistlim-r)/(resdistlim-3.0)
                  end if
                end if
                rij1(i1,i2)=rij
                rij1(i2,i1)=rij
                rij2(i1,i2)=rij
                rij2(i2,i1)=rij
                rij3(i1,i2)=rij
                rij3(i2,i1)=rij
              end if
            end do
          end do
          do i=1,numres
            do j=1,numres
              itemp(j)=rij1(i,j)
            end do
            write (ilog,1009) i,(itemp(j),j=1,numres)
          end do
          do i=1,10
            ifg(i)=1
            imf(i)=(i-1)*numres+1
            iml(i)=i*numres
          end do
          do i=1,numres
            xres(i)=i
          end do
          nexpplot=0
          do nexp=1,nexpmax
            if (nexp .gt. 1) then
              do i1=1,numres
                do i2=1,numres
                  sum=0.0
                  if (iadjtyp .lt. 3) then
                    do k=1,numres
                      sum=sum+rij1(i1,k)*rij2(k,i2)
                    end do
                  else
                    do k=1,numres
                      if (rij1(i1,k) .gt. 0.0 .and. rij2(k,i2) .gt. 0.0)
         -              sum=sum+rij1(i1,k)+rij2(k,i2)
                    end do
                  end if
                  rij3(i1,i2)=sum
                end do
              end do
            end if
            do i1=1,numres
              colsum=0.0
              do i2=1,numres
                colsum=colsum+rij3(i1,i2)
                rij2(i1,i2)=rij3(i1,i2)
              end do
              rconnsum(i1)=colsum
            end do
            connmax=0.0
            do i=1,numres
              if (rconnsum(i) .gt. connmax) connmax=rconnsum(i)
            end do
            if (iscalesum .eq. 1) then
              do i=1,numres
                iconnsum(i)=100.0*rconnsum(i)/connmax
              end do
            else
              scalefac=1.0
              nlog=alog10(connmax)
              if (nlog .gt. 3) scalefac=10.0**(2-nlog)
              do i=1,numres
                iconnsum(i)=rconnsum(i)*scalefac
              end do
            end if
            write (ilog,1000) nexp,(iconnsum(i),i=1,numres)
            if ((mod(nexp,npint) .eq. 1 .or. nexp .eq. nexpmax .or.
         -      npint .eq. 1) .and. nexpplot .lt. 10) then
              nexpplot=nexpplot+1
              iexpplot(nexpplot)=nexp
              write (fclab(nexpplot),1004) nexp
              lfclab(nexpplot)=8
              if (iscalesum .eq. 0) then
                do i=1,numres
                  yres(imf(nexpplot)-1+i)=iconnsum(i)
                end do
                ny=5
                ydiv=0.0
              else
                do i=1,numres
                  yres(imf(nexpplot)-1+i)=(nexpplot-1)+rconnsum(i)/connmax
                end do
                ny=nexpplot
                ydiv=1.0
              end if
            end if
          end do
          nmarksum=0
          nmarkup=0
          nmarkdown=0
          nsumup=0
          nsumdown=0
          do i=1,numres
            if (rconnsum(i) .gt. connmax/2.0) then
              nsumup=nsumup+1
            else
              nsumdown=nsumdown+1
            end if
            if (imarks(i) .gt. 0) then
              nmarksum=nmarksum+1
              if (rconnsum(i) .gt. connmax/2.0) then
                nmarkup=nmarkup+1
              else
                nmarkdown=nmarkdown+1
              end if
            end if
          end do
          if (nmarksum .gt. 0) then
            write (ilog,1007) nmarksum,float(nmarkup)/float(nmarksum),
         -    float(nmarkdown)/float(nmarksum),numres,
         -    float(nsumup)/float(numres),float(nsumdown)/float(numres)
          else
            write (ilog,1008) inpfile(1:linpfile)
          end if
          title1='Adjacency matrix analysis for file '
          ltitle1=35
          title1(ltitle1+1:ltitle1+linpfile)=inpfile(1:linpfile)
          ltitle1=ltitle1+linpfile
          write (title2(ltitle2+1:ltitle2+14),1006) resdistlim
          ltitle2=ltitle2+14
          if (iadjtyp .eq. 1) then
            title2(ltitle2+1:ltitle2+27)=' 0/1 matrix, matrix product'
            ltitle2=ltitle2+27
          else
            title2(ltitle2+1:ltitle2+34)=' 0.0-1.0 matrix, product-like sum'
            ltitle2=ltitle2+34
          end if
          if (imarkres .gt. 0) then
            title2(ltitle2+1:ltitle2+13)='; Mark file: '
            ltitle2=ltitle2+13
            title2(ltitle2+1:ltitle2+lmarkfile)=markfile(1:lmarkfile)
            ltitle2=ltitle2+lmarkfile
          end if
          call rounddiv(numres,10,nx,nxdiv)
          xdiv=nxdiv
          call plotnps(xres,yres,MAXCONN,MAXCONN10,nexpplot,imf,iml,ifg,
         -  0.0,1.0,0.0,xdiv,nx,0.0,ydiv,ny,1,ltitle1,title1,ltitle2,title2,
         -  'Residue #',9,fclab,lfclab,imarkres,imarks,marks,iplot,ipspage,
         -  npspages,inperr,ilog)
          return
    1000  format(' Bond density (scaled); Adjacency matrix power=',i2,/,
         -  (20i4))
    1001  format(' Adjacency is based on ',a,/,
         -  ' Distance threshold =',f5.2,' A')
    1002  format(' Closest approach is based on heavy atoms only')
    1003  format(' Adjacency matrix analysis for the residue range [',i5,
         -  ',',i5,']')
    1004  format('Power=',i2)
    1005  format(' Matrix: ',a,' Operation: ',a)
    1006  format(' RRmax=',f4.1,' A;')
    1007  format(' # of marks=',i4,' x up=',f5.3,' x down=',f5.3,
         -  ' # of res=',i4,' x up=',f5.3,' x down=',f5.3)
    1008  format(' No marks were found for file ',a)
    1009  format(i4,1x,10i1,1x,10i1,1x,10i1,1x,10i1,1x,10i1,1x,/,
         -  (5x,5(10i1,1x)))
          end
          subroutine rounddiv(max,maxdiv,ndiv,idiv)
          dimension limits (27)
          data limits /1,2,5,24*1/
          do i=1,8
            do k=1,3
              limits(3*i+k)=10*limits(3*(i-1)+k)
            end do
          end do
          do i=1,27
            if (max .le. limits(i)*maxdiv) then
              idiv=limits(i)
              ndiv=(max-1)/idiv +1
              return
            end if
          end do
          idiv=limits(27)
          ndiv=(max-1)/idiv +1
          return
          end
          subroutine pairdistcalc(c,nslt,npairs,listpairdist,pairdistsum,
         -  pairdistsum2,pairdistwsum,npairdist,pairdistminmax,pairgrid,
         -  iout,maxddbin,maxddistr)
          dimension c(3,nslt),listpairdist(2,maxddistr),
         -  npairdist(maxddbin,maxddistr),pairdistsum(maxddistr),
         -  pairdistsum2(maxddistr),pairdistwsum(2,maxddistr),
         -  pairdistminmax(2,maxddistr)
          do ip=1,npairs
            d2=dist2(c(1,listpairdist(1,ip)),c(1,listpairdist(2,ip)))
            d=sqrt(d2)
            if (d .lt. pairdistminmax(1,ip)) pairdistminmax(1,ip)=d
            if (d .gt. pairdistminmax(2,ip)) pairdistminmax(2,ip)=d
            pairdistsum(ip)=pairdistsum(ip)+d
            pairdistsum2(ip)=pairdistsum2(ip)+d2
            pairdistwsum(1,ip)=pairdistwsum(1,ip)+d/d2**3
            pairdistwsum(2,ip)=pairdistwsum(2,ip)+1.0/d2**3
            id=d/pairgrid+1.0
            if (id .gt. maxddbin) id=maxddbin
            npairdist(id,ip)=npairdist(id,ip)+1
            if (iout .gt. 0) write (iout,1000) (listpairdist(k,ip),k=1,2),d
          end do
          return
    1000  format(' Atom',i7,' - atom',i7,' distance=',f5.2)
          end
          subroutine clusterdistcalc(c,nslt,npairs,iclustermem,
         -  ifstclst1,ifstclst2,ilstclst2,pairdistsum,pairdistsum2,
         -  pairdistwsum,npairdist,pairdistminmax,pairgrid,iout,
         -  maxddbin,maxpairs,maxclustermem)
          dimension c(3,nslt),iclustermem(maxclustermem),
         -  ifstclst1(maxpairs),ifstclst2(maxpairs),ilstclst2(maxpairs),
         -  npairdist(maxddbin,maxpairs),pairdistsum(maxpairs),
         -  pairdistsum2(maxpairs),pairdistwsum(2,maxpairs),
         -  pairdistminmax(2,maxpairs)
          data d2 /0.0/
          do ip=1,npairs
            d2max=100000.0
            do i1=ifstclst1(ip),ifstclst2(ip)-1
              do i2=ifstclst2(ip),ilstclst2(ip)
                d2=dist2(c(1,iclustermem(i1)),c(1,iclustermem(i2)))
                if (d2 .lt. d2max) d2max=d2
              end do
            end do
            d=sqrt(d2)
            if (d .lt. pairdistminmax(1,ip)) pairdistminmax(1,ip)=d
            if (d .gt. pairdistminmax(2,ip)) pairdistminmax(2,ip)=d
            pairdistsum(ip)=pairdistsum(ip)+d
            pairdistsum2(ip)=pairdistsum2(ip)+d2
            pairdistwsum(1,ip)=pairdistwsum(1,ip)+d/d2**3
            pairdistwsum(2,ip)=pairdistwsum(2,ip)+1.0/d2**3
            id=d/pairgrid+1.0
            if (id .gt. maxddbin) id=maxddbin
            npairdist(id,ip)=npairdist(id,ip)+1
            if (iout .gt. 0) write (iout,1000) ip,d
          end do
          return
    1000  format(' Pair ',i3,' distance=',f5.2)
          end
          subroutine pairdistprint(nframe,npairs,listpairdist,iclusterdist,
         -  iclustermem,ifstclst1,ifstclst2,ilstclst2,pairdistsum,
         -  pairdistsum2,pairdistwsum,npairdist,pairdistminmax,pairgrid,
         -  rmaxpair,line,index,inamcol1,inamcol2,irescol1,irescol2,
         -  iresncol1,iresncol2,inpcrdtyp,ioins,iout,nslt,maxddbin,
         -  maxddistr,maxcdlist,maxrec)
          dimension listpairdist(2,maxddistr),npairdist(maxddbin,maxddistr),
         -  iclustermem(maxcdlist),ifstclst1(maxddistr),
         -  ifstclst2(maxddistr),ilstclst2(maxddistr),
         -  pairdistsum(maxddistr),pairdistsum2(maxddistr),
         -  pairdistwsum(2,maxddistr),pairdistminmax(2,maxddistr),
         -  index(nslt)
          character*3 star3
          character*8 an1,an2,rn1,rn2,irn1,irn2
          character* 132 line(maxrec)
          character*80 pline
          dimension dist(100)
          data star3 /' * '/,nnamcol /0/,nrescol /0/,nresncol /0/,
         -  an1 /'        '/,an2 /'        '/,rn1 /'        '/,
         -  rn2 /'        '/,irn1 /'        '/,irn2 /'        '/
          if (nframe .gt. 1) write (iout,1003) rmaxpair,pairgrid
          nnamcol=inamcol2-inamcol1+1
          nrescol=irescol2-irescol1+1
          nresncol=iresncol2-iresncol1+1
          do ip=1,npairs
            write (iout,*)
            davg=pairdistsum(ip)/nframe
            dwavg=(pairdistwsum(2,ip)/nframe)**(-1.0/6.0)
            sd=sqrt(abs(pairdistsum2(ip)/nframe-davg**2))
            if (iclusterdist .eq. 0) then
              i1=listpairdist(1,ip)
              i2=listpairdist(2,ip)
            else
              pline(1:10)=' Cluster1:'
              ncol=10
              ip11=ifstclst1(ip)
              ip21=ifstclst2(ip)
              ip12=ip21-1
              ip22=ilstclst2(ip)
              if (inpcrdtyp .le. ioins) then
                nnamcol=inamcol2-inamcol1+1
                nrescol=irescol2-irescol1+1
                ncolinc=nnamcol+nrescol+7
                do i=ip11,ip12
                  write (pline(ncol+1:ncol+5),1009) iclustermem(i)
                  ncol=ncol+6
                  pline(ncol:ncol)=' '
                  pline(ncol+1:ncol+nnamcol)=
         -          line(index(iclustermem(i)))(inamcol1:inamcol2)
                  ncol=ncol+nnamcol+1
                  pline(ncol:ncol)=' '
                  pline(ncol+1:ncol+nrescol)=
         -          line(index(iclustermem(i)))(irescol1:irescol2)
                  ncol=ncol+nrescol+1
                  pline(ncol:ncol)=' '
                end do
              else
                ncolinc=5
                do i=ip11,ip12
                  write (pline(ncol+1:ncol+ncolinc),1009)iclustermem(i)
                  ncol=ncol+ncolinc
                end do
              end if
              if (ncol+(ip22-ip21+1)*ncolinc+10 .gt. 80) then
                write (iout,1007) pline(1:ncol)
                ncol=0
              end if
              pline(ncol+1:ncol+10)=' Cluster2:'
              ncol=ncol+10
              if (inpcrdtyp .le. ioins) then
                do i=ip21,ip22
                  write (pline(ncol+1:ncol+5),1009) iclustermem(i)
                  ncol=ncol+6
                  pline(ncol:ncol)=' '
                  pline(ncol+1:ncol+nnamcol)=
         -          line(index(iclustermem(i)))(inamcol1:inamcol2)
                  ncol=ncol+nnamcol+1
                  pline(ncol:ncol)=' '
                  pline(ncol+1:ncol+nrescol)=
         -          line(index(iclustermem(i)))(irescol1:irescol2)
                  ncol=ncol+nrescol+1
                  pline(ncol:ncol)=' '
                end do
              else
                do i=ip21,ip22
                  write (pline(ncol+1:ncol+ncolinc),1009)iclustermem(i)
                  ncol=ncol+ncolinc
                end do
              end if
              if (ncol .gt. 70) then
                write (iout,1007) pline(1:ncol)
                write (iout,1010) davg
              else
                write (pline(ncol+1:ncol+10),1010) davg
                write (iout,1007) pline(1:ncol+10)
              end if
            end if
            if (nframe .gt. 1) write (iout,1004) ip,davg,sd,
         -    (pairdistminmax(k,ip),k=1,2),dwavg
            if (inpcrdtyp .le. ioins) then
              an1(1:nnamcol)=line(index(i1))(inamcol1:inamcol2)
              an2(1:nnamcol)=line(index(i2))(inamcol1:inamcol2)
              rn1(1:nrescol)=line(index(i1))(irescol1:irescol2)
              rn2(1:nrescol)=line(index(i2))(irescol1:irescol2)
              irn1(1:nresncol)=line(index(i1))(iresncol1:iresncol2)
              irn2(1:nresncol)=line(index(i2))(iresncol1:iresncol2)
              write (iout,1000) i1,an1(1:nnamcol),rn1(1:nrescol),
         -      irn1(1:nresncol),i2,an2(1:nrescol),rn2,irn2(1:nresncol)
            end if
            if (nframe .gt. 1) then
              write (iout,1002) (npairdist(k,ip),k=1,maxddbin)
              write (iout,*)
              pdmax=0.0
              do ic=1,maxddbin
                dist(ic)=float(npairdist(ic,ip))/float(nframe)
                if (dist(ic) .gt. pdmax) pdmax=dist(ic)
              end do
              maxperc=100
              distfact=10.0
              if (pdmax .lt. 0.3) then
                maxperc=30
                distfact=0.3
              else if (pdmax .lt. 0.5) then
                maxperc=50
                distfact=0.5
              else if (pdmax .lt. 0.8) then
                maxperc=80
                distfact=0.8
              end if
              write (iout,1006)
              if (maxddbin .le. 20) then
                lbin=3
              else if (maxddbin .le. 30) then
                lbin=2
              else if (maxddbin .le. 60) then
                lbin=1
              else
                print *,'ERROR: too many bins to plot - distributions ',
         -        'will be only printed'
                lbin=0
              end if
              if (maxddbin .eq. 20) then
                lastcol=12+lbin*maxddbin
                pline(lastcol:lastcol)='|'
                do il=10,1,-1
                  call blankout(pline,1,lastcol-1)
                  pline(11:11)='|'
                  if (il .eq. 10) write (pline(5:9),1008) maxperc
                  do ic=1,maxddbin
                    if (dist(ic) .gt. distfact*float(il-1)/10.0)
         -            pline(12+(ic-1)*lbin:11+ic*lbin)=star3
                  end do
                  write (iout,1007) pline(1:72)
                end do
                write (iout,1006)
                write (iout,1005) ((rmaxpair/5.0)*i,i=1,5)
              else
                print *,'Sorry, only MAXDDBIN=20 works for now'
              end if
            else
              write (iout,1011) ip,davg,dwavg
            end if
          end do
          return
    1000  format(' Atom',i7,' (',a,1x,a,1x,a,') - atom',i7,' (',a,1x,a,1x,a,
         -  ')')
    1002  format(' Distribution :',10i6,/,(15x,10i6))
    1003  format(' Distance distributions are limited to the 0 -',f5.1,
         -  ' A range; bin size=',f5.3,' A')
    1004  format(' Pair',i4,' <d>=',f5.2,' SD=',f5.2,' Min=',f5.2,
         -  ' Max=',f5.2,' NMR(<d>)=',f5.2)
    1005  format(11x,5f12.2)
    1006  format(10x,'|',5(3('-+-'),'-|-'),'|')
    1007  format(a)
    1008  format(i3,' %')
    1009  format(i5)
    1010  format(' <d>=',f5.2)
    1011  format(' Pair',i4,' <d>=',f5.2,' NMR(<d>)=',f5.2,' A')
          end
          subroutine histogram(r,n,rmaxi,rbin,label,llabel,ihistogram,iout,
         -  mxh)
          dimension r(n)
          dimension ihistogram(mxh)
          character*(*) label
          if (rmaxi .eq. 0.0) then
            rmin=1.e32
            rmax=-rmin
            do i=1,n
              if (r(i) .lt. rmin) rmin=r(i)
              if (r(i) .gt. rmax) rmax=r(i)
            end do
          else
            rmin=0.0
            rmax=rmaxi
          end if
          ng=(rmax-rmin)/rbin+1.0
          if (ng .lt. 2) then
            write (6,1001) rmin,rmax,rbin
            return
          end if
          call zeroiti(ihistogram,0,ng)
          do i=1,n
            ix=ng*(r(i)-rmin)/(rmax-rmin)+1 
            if (ix .lt. 1) ix=1
            if (ix .gt. ng) ix=ng
            ihistogram(ix)=ihistogram(ix)+1
          end do
          write (iout,1008) n,label(1:llabel),rbin,rmin,rmax,
         -  (ihistogram(i),i=1,ng)
          return
    1001  format(' Range: [',e12.5,' - ',e12.5,'] and bin size ',f8.3,
         -  ' does not give a histogram') 
    1008  format(' Histogram of ',i5,1x,a,/,' Binsize=',f8.3,' in the ',
         -  f8.3,' - ',f8.3,' range:',/,(10i6))
          end
          subroutine checkunphys(c,nslt,n,naslv,islvw,iatnum,ifchrg,isegno,
         -  idelseg,indexo,nneig,nneiga,nhbneig,ineig,nhneig,nnneig,ncneig,
         -  nsneig,npneig,ixres,line,irescol1,irescol2,inamcol1,inamcol2,
         -  index,nconfig,innlist,molresflag,ioppbc,cell,ncell,edge,ixyzhex,
         -  molsltlim,nmolslt,hblimfac,angmin,ctfac,bondminfac,maxdist,iles,
         -  iwchk,isltonly,indices,nbox,rlim,innlistread,nframe,radtodeg,
         -  nerr,maxrepconf,maxng,maxbox,maxrsd,maxrec)
          dimension nneig(n),ineig(maxng,n),iatnum(n),ifchrg(n),c(3,n),
         -  idelseg(1000),indexo(n),nhbneig(n),nneiga(n),nhneig(n),
         -  nnneig(n),ncneig(n),nsneig(n),npneig(n),ixres(n),
         -  molresflag(maxrsd),index(n),indices(maxbox,maxrec),nbox(maxrec),
         -  isegno(n),cell(3,ncell),edge(3),ixyzhex(3),molsltlim(3,nmolslt),
         -  rlim(maxng)
          character* 132 line(maxrec)
          call bondcheck(iwchk,1,nslt,iatnum,nneig,ineig,maxng,c,maxdist,
         -  line,irescol1,irescol2,inamcol1,inamcol2,index,rlim,nbonderr,
         -  maxrec)
          if (isltonly .eq. 0) nlim=n
          if (isltonly .eq. 1) nlim=nslt
          if (iles .eq. 1) then
            nmark=0
            call trnsfi(indexo,isegno,nslt)
            do ia=1,nslt
              if (idelseg(isegno(ia)) .eq. 1) nmark=nmark+1
              if (idelseg(isegno(ia)) .eq. 1) isegno(ia)=-1
            end do
          end if
          if (innlistread .eq. 0)
         -  call nnlist(nslt,islvw,naslv,nlim,iatnum,ifchrg,c,nneig,nneiga,
         -    nhbneig,ineig,nhneig,nnneig,ncneig,nsneig,npneig,line,
         -    irescol1,irescol2,inamcol1,inamcol2,index,nconfig,innlist,
         -    molresflag,hblimfac,angmin,0,indices,nbox,isegno,ixres,
         -    maxrepconf,1,nframe,radtodeg,0,maxbox,maxng,maxrsd,maxrec)
          call contactcheck(iwchk,nslt,n,iatnum,c,line,irescol1,irescol2,
         -  inamcol1,inamcol2,index,ctfac,bondminfac,isltonly,
         -  naslv,nneig,ineig,isegno,ioppbc,cell,ncell,edge,ixyzhex,
         -  molsltlim,nmolslt,ncontacterr,maxng,maxrec)
            if (iles .eq. 1) call trnsfi(isegno,indexo,nslt)
          nerr=nbonderr+ncontacterr
          return
          end
          subroutine helixaxis(c,nslt,iw0,calph,axisdir,axisini,axisend,
         -  helixcent,perpvec,camod,anglechangeref,circ,rn,axfact,axtol,rot,
         -  rms,helixlen,angles,decidebend,nup,ndown,nrun,nnear,rcirc,
         -  turnperres,anglesn,irot,incrot,nrep,irefang,nreshx,icaahx,ihx,
         -  nhxres,idebughx,radtodeg,pi,maxhlx)
          dimension c(3,nslt),rot(3,3),anglechangeref(maxhlx),icaahx(maxhlx)
          real*8 camod(3,maxhlx),axfact(maxhlx),perpvec(3,maxhlx),
         -  calph(3,maxhlx),axisdir(3),axisini(3),axisend(3),helixcent(3),
         -  circ(3),rn(3)
          real*8 rms
          dimension angles(3),anglesn(3)
          character*9 decidebend
          parameter (MAXFRAMES=50000,MAXCOPY=600)
          common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
         -  increment,increment2,res(2,MAXFRAMES,MAXCOPY),
         -  x0(MAXCOPY),y0(MAXCOPY),nxselres,ixselres(MAXCOPY)
          character*60 message
          real*8 ddistsq
          character*9 decide(6)
          data decide/'Too short','Bent     ','Random   ',
         -  'Alternate','Too long ','         '/
          iprintkahn=0
          it=0
          do ir=1,nreshx
            do k=1,3
              calph(k,ir)=c(k,icaahx(ir))
            end do
          end do
          if (irot .eq. 1) then
            do ir=1,nreshx
              call dsmatvec(rot,calph(1,ir),calph(1,ir))
            end do
          end if
          message=
         - 'Helix                                                       '
          call kahn(calph,nreshx,.true.,axisdir,axisini,axisend,rms,
         -  iprintkahn, message,maxhlx)
          rmsa=rms
          if (idebughx .gt. 0) then
            write (77,7011) 'axis direction',axisdir
            write (77,7011) 'initial position',axisini
            write (77,7011) 'end position',axisend
            write (77,*) 'Helix quality rms=',rms
            write (77,7012) nreshx,(icaahx(ir),ir=1,nreshx)
          end if
          if (nrep .le. 1) then
            do ir=1,nreshx
              call calcperp(axisini,axisdir,calph(1,ir),camod(1,ir),
         -      perpvec(1,ir),it)
            end do
            call checkbend(calph,axisdir,camod,axfact,perpvec,helixcent,
         -    nreshx,nup,ndown,nrun,nnear,axtol,rcirc,circ,rn,ibtyp,
         -    idebughx)
          end if
          if (nrep .le. 1) then
            do k=1,3
              anglesn(k)=dacoscheck(rn(k),ccc,1,6,'HELIXNORMAL')
            end do
            helixlen=dsqrt(ddistsq(axisini,axisend))
            do k=1,3
              angles(k)=dacoscheck(axisdir(k),ccc,1,6,'HELIXAXIS')
            end do
            call calcturnperres(turnperres,nreshx,incrot,perpvec,axisdir,
         -    anglechangeref,irefang,pi,maxhlx)
            nframes=max0(1,nframe)
            incr=(ihx-1)*nhxres
            call trajlimtest(nframe,MAXFRAMES)
            res(1,nframes,incr+7)=helixlen
            res(2,nframes,incr+7)=rcirc
            do k=1,3
              res(1,nframes,incr+k)=cos(angles(k))
              res(2,nframes,incr+k)=sin(angles(k))
            end do
            res(1,nframes,incr+6)=cos(turnperres)
            res(2,nframes,incr+6)=sin(turnperres)
            res(1,nframes,incr+13)=axisdir(1)
            res(2,nframes,incr+13)=axisdir(2)
            res(1,nframes,incr+14)=axisdir(3)
            res(2,nframes,incr+14)=helixcent(1)
            res(1,nframes,incr+15)=helixcent(2)
            res(2,nframes,incr+15)=helixcent(3)
            decidebend=decide(ibtyp)
            if (iw0 .gt. 0) call printhelix(iw0,axisini,axisend,helixcent,
         -    rms,helixlen,axisdir,angles,decidebend,nup,ndown,nrun,nnear,
         -    rcirc,turnperres,anglesn,ihx,radtodeg)
          end if
          return
    7011  format(' Helix ',a,'=',3f10.4)
    7012  format(' # of HX res=',i2,(' icaa:',20i5))
          end
          subroutine multihelix(iw0,nhx,nhxres,radtodeg,c,icaahx,
         -  icbahx,icbreshx,maxat,maxhx,mxnhx)
          dimension c(3,maxat),icaahx(maxhx,mxnhx),
         -  icbahx(mxnhx),icbreshx(mxnhx)
          parameter (MAXFRAMES=50000,MAXCOPY=600)
          common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
         -  increment,increment2,res(2,MAXFRAMES,MAXCOPY),
         -  x0(MAXCOPY),y0(MAXCOPY),nxselres,ixselres(MAXCOPY)
          parameter (MAXNHX=12,MAXNHX2=(MAXNHX*(MAXNHX-1)))
          character*2 ap_pa,in_ex
          common /signs/ itmem,normhx,isg2(MAXNHX2),memdir(MAXNHX),ap_pa(3),
         -  in_ex(2)
          dimension ax1(3),ax2(3),cent1(3),cent2(3),c12(3),ct1(3),ct2(3),
         -  ct12(3),torsats(3,4),s1(3),s2(3),e1(3),e2(3),exs1(3),
         -  exs2(3),exe1(3),exe2(3)
          real*8 dargin,dax1(3),dax2(3),dc12(3),dax1_dax2,dc12_1,dc12_2,
         -  dscprod
          character*80 line
          ixres=nhx*nhxres+1
          nframes=max0(1,nframe)
          nhx2tot=(nhx*(nhx-1))/2
          i0line=0
          call blankout(line,1,80)
          do ihx=1,nhx
            incr1=(ihx-1)*nhxres
            ax1(1)=res(1,nframes,incr1+13)
            ax1(2)=res(2,nframes,incr1+13)
            ax1(3)=res(1,nframes,incr1+14)
            cent1(1)=res(2,nframes,incr1+14)
            cent1(2)=res(1,nframes,incr1+15)
            cent1(3)=res(2,nframes,incr1+15)
            halflen1=res(1,nframes,incr1+7)/2.0
            do jhx=ihx+1,nhx
              incr2=(jhx-1)*nhxres
              ax2(1)=res(1,nframes,incr2+13)
              ax2(2)=res(2,nframes,incr2+13)
              ax2(3)=res(1,nframes,incr2+14)
              cent2(1)=res(2,nframes,incr2+14)
              cent2(2)=res(1,nframes,incr2+15)
              cent2(3)=res(2,nframes,incr2+15)
              halflen2=res(1,nframes,incr2+7)/2.0
              ax1_ax2=scprod(ax1,ax2)
              ang=dacoscheck(dargin,ax1_ax2,0,6,'MULTIHELIX')*radtodeg
              dist_cc=sqrt(dist2(cent1,cent2))
              call arrdiff(cent1,cent2,c12,3)
              c12_1=scprod(c12,ax1)
              c12_2=scprod(c12,ax2)
              parfact=1.0
              if (abs(ax1_ax2) .lt. 0.01) then
                a1=-c12_1
                a2=c12_2
                write (iw0,1001) ihx,jhx,'perpendicular'
              else if (abs(ax1_ax2) .gt. 0.99) then
                if (abs(ax1_ax2) .gt. 0.999) then
                  a2=0.0
                  call project(cent2,cent1,ax1,ct1,a1)
                  write (iw0,1001) ihx,jhx,'parallel'
                  parfact=0.1
                else
                  do k=1,3
                    dax1(k)=ax1(k)
                    dax2(k)=ax2(k)
                    dc12(k)=c12(k)
                  end do
                  dax1_dax2=dscprod(dax1,dax2)
                  dc12_1=dscprod(dc12,dax1)
                  dc12_2=dscprod(dc12,dax2)
                  a1=(dc12_2-dc12_1/dax1_dax2)/(1.d0/dax1_dax2-dax1_dax2)
                  a2=(dc12_1-dc12_2/dax1_dax2)/(dax1_dax2-1.d0/dax1_dax2)
                end if
              else
                a1=(c12_2-c12_1/ax1_ax2)/(1.0/ax1_ax2-ax1_ax2)
                a2=(c12_1-c12_2/ax1_ax2)/(ax1_ax2-1.0/ax1_ax2)
              end if
              call paramx(cent1,ax1,a1,ct1)
              call paramx(cent2,ax2,a2,ct2)
              call arrdiff(ct1,ct2,ct12,3)
              c12norm=sqrt(scprod(ct12,ct12))
              tst1=scprod(ct12,ax1)/c12norm
              tst2=scprod(ct12,ax2)/c12norm
              if ((tst1+tst2)*parfact .gt. 0.01) then
                if (tst1+tst2 .lt. 0.1) then
                  write (6,1002) 'Probable',ihx,jhx,tst1,tst2
                  write (iw0,1002) 'Probable',ihx,jhx,tst1,tst2
                else
                  write (6,1002) '',ihx,jhx,tst1,tst2
                  write (iw0,1002) '',ihx,jhx,tst1,tst2
                end if
              end if
              if (a1 .lt. -halflen1 .or. a1 .gt. halflen1 .or.
         -        a2 .lt. -halflen2 .or. a2 .gt. halflen2) then
                noproj=0
                d2min=99999.0
                call paramx(cent2,ax2,-halflen2,s2)
                call paramx(cent2,ax2,halflen2,e2)
                call paramx(cent1,ax1,-halflen1,s1)
                call paramx(cent1,ax1,halflen1,e1)
                call project(s1,cent2,ax2,exs1,as1)
                call project(e1,cent2,ax2,exe1,ae1)
                call project(s2,cent1,ax1,exs2,as2)
                call project(e2,cent1,ax1,exe2,ae2)
                if (a1 .lt. -halflen1) then
                  if (amax1(as2,ae2) .lt. -halflen1) noproj=1
                else if (a1 .gt. halflen1) then
                end if
                if (a2 .lt. -halflen2) then
                  if (amax1(as1,ae1) .lt. -halflen2) noproj=1
                else if (a2 .gt. halflen2) then
                end if
                if (d2min .lt. 99999.0) then
                  write (iw0,1003) ihx,jhx
                else
                  if (noproj .eq. 0)
         -          write (iw0,1004) 'mismatch between',ihx,jhx
                  if (noproj .eq. 1)
         -          write (iw0,1004) 'no overlap between',ihx,jhx
                end if
              end if
              angrot1=0.0
              if (icbahx(ihx) .gt. 0) then
                call trnsfr(torsats(1,4),c(1,icbahx(ihx)),3)
                call project(c(1,icbahx(ihx)),cent1,ax1,torsats(1,3),a)
                call arrsum(torsats(1,3),ax1,torsats(1,2),3)
                call project(cent2,cent1,ax1,s1,ac1)
                call arrdiff(cent2,s1,ct12,3)
                ct12norm=sqrt(scprod(ct12,ct12))
                do k=1,3
                  ct12(k)=ct12(k)/ct12norm
                end do
                call arrsum(torsats(1,2),ct12,torsats(1,1),3)
                angrot1=dihangl(torsats,1,2,3,4,1,4)*radtodeg
              end if
              angrot2=0.0
              if (icbahx(jhx) .gt. 0) then
                call trnsfr(torsats(1,4),c(1,icbahx(jhx)),3)
                call project(c(1,icbahx(jhx)),cent2,ax2,torsats(1,3),a)
                call arrsum(torsats(1,3),ax2,torsats(1,2),3)
                call project(cent1,cent2,ax2,s2,ac1)
                call arrdiff(cent1,s2,ct12,3)
                ct12norm=sqrt(scprod(ct12,ct12))
                do k=1,3
                  ct12(k)=ct12(k)/ct12norm
                end do
                call arrsum(torsats(1,2),ct12,torsats(1,1),3)
                angrot2=dihangl(torsats,1,2,3,4,1,4)*radtodeg
              end if
              dist=sqrt(dist2(ct1,ct2))
              idist=int(50.0*dist)
              idist_cc=int(50.0*dist_cc)
              res(1,nframes,ixres)=10000*idist+idist_cc
              call dee(nframes,ixres-nhx*nhxres,ax1,ax2,cent1,cent2,
         -      halflen1,halflen2,distss,disthh,isg2ij)
              idist_ss=int(50.0*distss)
              idist_hh=int(50.0*disthh)
              res(2,nframes,ixres)=10000*idist_ss+idist_hh
              call trnsfr(torsats(1,2),ct1,3)
              call trnsfr(torsats(1,3),ct2,3)
              call paramx(ct1,ax1,halflen1,torsats(1,1))
              call paramx(ct2,ax2,halflen2,torsats(1,4))
              dhang=dihangl(torsats,1,2,3,4,1,4)*radtodeg
              iang=int(10.0*ang)
              idhang=int(10.0*dhang)
              res(1,nframes,nhx2tot+ixres)=10000*iang+idhang
              call trnsfr(torsats(1,2),cent1,3)
              call trnsfr(torsats(1,3),cent2,3)
              call paramx(cent1,ax1,halflen1,torsats(1,1))
              call paramx(cent2,ax2,halflen2,torsats(1,4))
              dhang_cc=dihangl(torsats,1,2,3,4,1,4)*radtodeg
              iamin1=icaahx(icbreshx(ihx),ihx)
              iamin2=icaahx(icbreshx(jhx),jhx)
              res(2,nframes,nhx2tot+ixres)=dhang_cc
              idist_ar1=int(10.0*angrot1)
              idist_ar2=int(10.0*angrot2)
              res(1,nframes,2*nhx2tot+ixres)=10000*idist_ar1+idist_ar2
              write (iw0,1005) ihx,jhx,dist,dist_cc,distss,disthh,
         -      ap_pa(isg2ij+2)
              write (iw0,1006) ihx,jhx,ang,dhang,dhang_cc,iamin1,iamin2
              write (iw0,1007) ihx,jhx,angrot1,jhx,ihx,angrot2
              ixres=ixres+1
            end do
          end do
          return
    1001  format(' Helices',i3,' and',i3,' are ',a)
    1002  format(1x,a,' PROGRAM ERROR: ihx,jhx=',2i3,' c12.m1=',f8.3,
         -  ' c12.m2=',f8.5)
    1003  format(' NOTE: closest HX',i2,' - HX',i2,' contact is outside ',
         -  'the helices')
    1004  format(' NOTE: ',a,' HX',i2,' - HX',i2,
         -  ' projections')
    1005  format(' HXs#',i2,' - ',i3,' dist=',f7.2,' cc_dist=',f7.2,
         -  ' dee1=',f7.2,' dee2=',f7.2,1x,a)
    1006  format(' HXs#',i2,' - ',i3,' ang=',f7.2,' dhang=',f7.2,
         -   ' dhang_cc=',f7.2,' CAs:',i5,i6)
    1007  format(' HX',i2,' rotation wrt HX',i2,'=',f7.2,
         -  ' HX',i2,' rotation wrt HX',i2,'=',f7.2)
          end
          subroutine project(x,c,ax,p,a)
          dimension x(3),c(3),ax(3),p(3)
          a=scprod(ax,x)-scprod(ax,c)
          do k=1,3
            p(k)=c(k)+a*ax(k)
          end do
          return
          end
          subroutine paramx(cent,ax,a,x)
          dimension cent(3),ax(3),x(3)
          do k=1,3
           x(k)=cent(k)+a*ax(k)
          end do
          return
          end
          subroutine dee(nframe,isg_i,ax1,ax2,cent1,cent2,halflen1,halflen2,
         -  distss,disthh,isg2ij)
          dimension ax1(3),ax2(3),cent1(3),cent2(3),s1(3),s2(3),h1(3),h2(3)
          parameter (MAXNHX=12,MAXNHX2=(MAXNHX*(MAXNHX-1)))
          character*2 ap_pa,in_ex
          common /signs/ itmem,normhx,isg2(MAXNHX2),memdir(MAXNHX),ap_pa(3),
         -  in_ex(2)
          call paramx(cent1,ax1,-halflen1,s1)
          call paramx(cent1,ax1,+halflen1,h1)
          if (nframe .eq. 1) then
            call paramx(cent2,ax2,-halflen2,s2)
            call paramx(cent2,ax2,+halflen2,h2)
            dds1s2=dist2(s1,s2)
            dds1h2=dist2(s1,h2)
            ddh1h2=dist2(h1,h2)
            ddh1s2=dist2(h1,s2)
            if (dds1s2 .le. dds1h2 .and. ddh1h2 .le. ddh1s2) then
              isg2(isg_i)=1
            else if (dds1s2 .gt. dds1h2 .and. ddh1h2 .gt. ddh1s2) then
              isg2(isg_i)=-1
            else
              if (dds1s2+ddh1h2 .lt. dds1h2+ddh1s2) then
                isg2(isg_i)=1
              else
                isg2(isg_i)=-1
              end if
            end if
          end if
          call paramx(cent2,ax2,-isg2(isg_i)*halflen2,s2)
          call paramx(cent2,ax2,+isg2(isg_i)*halflen2,h2)
          distss=sqrt(dist2(s1,s2))
          disthh=sqrt(dist2(h1,h2))
          isg2ij=isg2(isg_i)
          return
          end
          subroutine printhelix(iw0,axisini,axisend,cent,rms,helixlen,
         -  axisdir,angles,decidebend,nup,ndown,nrun,nnear,rcirc,turnperres,
         -  anglesn,ihx,radtodeg)
          real*8 axisdir(3),axisini(3),axisend(3),cent(3),rms
          dimension angles(3),anglesn(3)
          character*9 decidebend
          write (iw0,1000) ihx,axisini,axisend,helixlen,axisdir,
         -  (radtodeg*angles(k),k=1,3),rms,decidebend,nup,ndown,nrun-1,
         -  nnear,rcirc,radtodeg*turnperres,cent,(radtodeg*anglesn(k),k=1,3)
          return
    1000  format(' HX#',i3,' S=',3f9.4,' E=',3f9.4,' Len=',f5.2,/,
         -  ' D=',3f10.6,' D-X,D-Y,D-Z angles=',3f7.2,/,
         -  ' RMS=',f5.2,' Shape:',a9,' Nup/dn=',2i3,' Ncross=',i2,
         -  ' Nax=',i2,' Rc=',f6.1,' TPR=',f6.2,/,
         -  ' C=',3f10.5,' N-X,N-Y,N-Z angles=',3f7.2)
          end
          subroutine soluteoverlay(isubcrm,ioverlay,nslt,nsegslt,c,cres,cc1,
         -  cc2,crmslt0,crmslt,atw,atw1,overlaysds,overlaysh,molsltlim,
         -  itemp,idebughx,iw0,maxrsd,maxat)
          dimension c(3,maxat),cres(3,maxat),cc1(3,maxat),cc2(3,maxat),
         -  crmslt0(3),crmslt(3),atw(nslt),atw1(nslt),molsltlim(3,maxrsd),
         -  itemp(maxat),overlaysds(maxat),overlaysh(maxat)
          dimension crmshift(3),com1(3),com2(3),rot(3,3)
          call zeroit(crmshift,3)
          if (isubcrm+ioverlay .eq. 0) then
            call trnsfr(cc2,c,3*nslt)
          else
            call cofms(c,crmslt,nslt,atw)
            call arrdiff(crmslt,crmslt0,crmshift,3)
            if (ioverlay .eq. 0) then
              do ia=1,nslt
                call arrdiff(c(1,ia),crmshift,cc2(1,ia),3)
              end do
            else if (ioverlay .eq. 1) then
              call indexit(itemp,1,nslt,0)
              call bestoverlay(nslt,itemp,itemp,cres,c,atw,0.d0,
         -      cc1,cc2,atw1,rot,com1,com2,idebughx,0.001,iw0,maxat)
              call shiftmol(c,nslt,com2,cc2,-1.0)
              call rotate_c(cc2,nslt,rot,cc2,'HELIX',5)
              call shiftmol(cc2,nslt,com1,cc2,+1.0)
              overlaysd=sdsumix(nslt,cres,cc2,atw,0,itemp,devmax,maxat)
            else
              do is=1,nsegslt
                nats=molsltlim(2,is)-molsltlim(1,is)+1
                ifat=molsltlim(1,is)
                call indexit(itemp,1,nats,0)
                call bestoverlay(nats,itemp,itemp,cres(1,ifat),c(1,ifat),
         -        atw(ifat),0.d0,cc1(1,ifat),cc2(1,ifat),atw1,rot,com1,com2,
         -        idebughx,0.001,iw0,maxat)
                call shiftmol(c(1,ifat),nats,com2,cc2(1,ifat),-1.0)
                call rotate_c(cc2(1,ifat),nats,rot,cc2(1,ifat),'HELIXs',6)
                call shiftmol(cc2(1,ifat),nats,com1,cc2(1,ifat),+1.0)
                overlaysds(is)=sdsumix(nats,cres(1,ifat),cc2(1,ifat),
         -        atw(ifat),0,itemp,devmax,maxat)
                overlaysh(is)=sqrt(dist2(com1,com2))
              end do
            end if
          end if
          if (ioverlay .eq. 0) then
            write (iw0,1004) crmshift
          else if (ioverlay .eq. 1) then
            write (iw0,1004) crmshift,' RMSD=',overlaysd
          else if (ioverlay .eq. 2) then
            write (iw0,1003)
         -   (overlaysh(is),sqrt(overlaysds(is)),is=1,nsegslt)
          else if (isubcrm .gt. 0) then
            write (iw0,1004) crmshift
          end if
          return
    1003  format(' (Molecular shift, RMSD):',4(' (',f8.2,',',f8.2,')'))
    1004  format(' Solute COM shift=',3f8.2,a,f8.2)
          end
          subroutine helixcomp(nslt,nres,calph0,dir0,perpvec0,start0,end0,
         -  cent0,rn0,camod,axfact,calph,dir,perpvec,start,end,cent,
         -  anglechange,anglechangeref,axtol,iw0,torsion,
         -  rotation,nrep,indexax,incrot,ireorienthx,idebughx,radtodeg,
         -  pi,cc2,nreshx,icaahx,ihx,nhxres,maxhx,maxat)
          dimension anglechange(maxhx),anglechangeref(maxhx),indexax(3),
         -  cc2(3,maxat),icaahx(maxhx)
          real*8 calph0(3,maxhx),dir0(3),start0(3),end0(3),cent0(3),rn0(3),
         -  perpvec0(3,maxhx),camod(3,maxhx),axfact(maxhx),calph(3,maxhx),
         -  dir(3),start(3),end(3),cent(3),perpvec(3,maxhx)
          parameter (MAXFRAMES=50000,MAXCOPY=600)
          common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
         -  increment,increment2,res(2,MAXFRAMES,MAXCOPY),
         -  x0(MAXCOPY),y0(MAXCOPY),nxselres,ixselres(MAXCOPY)
          character*2 iatnm2
          common /atnam/ aw(99),nval(99),nvalmax(99),mmofan(99),
         -  mmatno(64),iatnm2(99)
          real*8 org(3),dev(3),startg(3),endg(3),circ(3),rn(3),xx(3),yy(3),
         -  startw(3),endw(3),dirw(3),dirdotdir0,ddot,rms,devs(3),deve(3)
          dimension rot(3,3),corig(3,3),ccurr(3,3),shift(3),angles(3),
         -  anglesn(3)
          character*9 decidebend
          incrhx=(ihx-1)*nhxres
          iverbort=1
          if (nframe .gt. 10 .or. nrep .gt. 1) iverbort=0
          if (nrep .eq. 1 .and. nframe .eq. 1 .and. idebughx .gt. 0)
         -  write (iw0,1001) 'initial',cent0,
         -  ((calph0(k,ir),k=1,3),ir=1,nres)
          it=0
          call helixaxis(cc2,nslt,0,calph,dirw,startw,endw,cent,perpvec,
         -  camod,anglechangeref,circ,rn,axfact,axtol,rot,
         -  rms,helixlen,angles,decidebend,nup,ndown,nrun,nnear,rcirc,
         -  turnperres,anglesn,0,incrot,nrep,1,nreshx,icaahx,ihx,nhxres,
         -  idebughx,radtodeg,pi,MAXHX)
          call trnsfrd(start,startw,3)
          call trnsfrd(end,endw,3)
          call trnsfrd(dir,dirw,3)
          if (nrep .eq. 1 .and. idebughx .gt. 0) write (iw0,1001)
         -  'current',cent,((calph(k,ir),k=1,3),ir=1,nres)
          do ir=1,nres
            call dvdif(calph(1,ir),start,calph(1,ir))
          end do
          call dvdif(end,start,end)
          do k=1,3
            shift(k)=start(k)
          end do
          call zeroitd(start,3)
          call trnsfrd(startg,start,3)
          call trnsfrd(endg,end,3)
          if (nrep .eq. 1) then
            dirdotdir0=ddot(dir,dir0)
            rotation=dacoscheck(dirdotdir0,ccc,1,6,'HELIXCOMP')
            res(1,nframe,incrhx+5)=cos(rotation)
            res(2,nframe,incrhx+5)=sin(rotation)
            call dvdif(cent,cent0,dev)
            res(1,nframe,incrhx+8)=dsqrt(ddot(dev,dev))
            res(2,nframe,incrhx+8)=dev(indexax(1))
            res(1,nframe,incrhx+9)=dev(indexax(2))
            res(2,nframe,incrhx+9)=dev(indexax(3))
            call dvdif(startw,start0,devs)
            res(1,nframe,incrhx+10)=devs(indexax(2))
            res(2,nframe,incrhx+10)=devs(indexax(3))
            call dvdif(endw,end0,deve)
            res(1,nframe,incrhx+11)=deve(indexax(2))
            res(2,nframe,incrhx+11)=deve(indexax(3))
            if (idebughx .gt. 0 .and. dirdotdir0 .gt. 0.001)
         -   write (iw0,1001) 'current',cent,((calph(k,ir),k=1,3),ir=1,nres)
            if (ireorienthx .eq. 1) then
              call dcross(dir0,dir,org)
              do k=1,3
                corig(k,1)=0.0
                ccurr(k,1)=0.0
                corig(k,2)=dir0(k)
                ccurr(k,2)=dir(k)
                corig(k,3)=org(k)
                ccurr(k,3)=org(k)
              end do
              call ormat(rot,ccurr,corig,3,iverbort,iw0)
              do ir=1,nres
                call dsmatvec(rot,calph(1,ir),calph(1,ir))
              end do
              call trnsfrd(dir,dir0,3)
              if (idebughx .gt. 0) write (iw0,1001) 'current reoriented',
         -      cent,((calph(k,ir),k=1,3),ir=1,nres)
            end if
            do ir=1,nres
              call calcperp(start,dir,calph(1,ir),org,perpvec(1,ir),it)
            end do
            nflip=0
    100     rotav=0
            rotav2=0
            changemin=100.0
            changemax=0.0
            nflipprev=nflip
            do ir=1,nres
              call angcomp(perpvec0(1,ir),dir0,perpvec(1,ir),angchange)
              rotav=rotav+angchange
              rotav2=rotav2+angchange**2
              if (angchange .lt. changemin) changemin=angchange
              if (angchange .gt. changemax) changemax=angchange
              anglechange(ir)=angchange
            end do
            torsion=rotav/nres
            sd=sqrt(abs(rotav2/nres-torsion**2))
            if (changemax-changemin .gt. pi/2.0) then
              do ir=1,nres
                do k=1,3
                  xx(k)=-perpvec(k,ir)
                end do
                call angcomp(perpvec0(1,ir),dir0,xx,angchange)
                if (abs(angchange-torsion) .lt.
         -        abs(anglechange(ir)-torsion)) then
                  call trnsfrd(perpvec(1,ir),xx,3)
                  nflip=nflip+1
                end if
              end do
              if (nflip .le. nres .and. nflip .gt. nflipprev) go to 100
            end if
            if (nflip .gt. 0) then
              call calcturnperres(turnperres,nres,incrot,perpvec,dir,
         -      anglechangeref,1,pi,MAXHX)
              res(1,nframe,incrhx+6)=cos(turnperres)
              res(2,nframe,incrhx+6)=sin(turnperres)
            end if
            res(1,nframe,incrhx+4)=cos(torsion)
            res(2,nframe,incrhx+4)=sin(torsion)
            call dcross(dir0,rn0,xx)
            call dcross(rn0,xx,yy)
            do k=1,3
              rot(1,k)=yy(k)
              rot(2,k)=xx(k)
              rot(3,k)=rn0(k)
            end do
            if (ddot(rn,rn0) .lt. 0.d0) call dvmul(rn,-1.0d0,rn)
            call dsmatvec(rot,rn,xx)
            res(1,nframe,incrhx+12)=xx(1)
            res(2,nframe,incrhx+12)=xx(2)
            call printhelix(iw0,startw,endw,cent,rms,helixlen,dirw,angles,
         -    decidebend,nup,ndown,nrun,nnear,rcirc,turnperres,anglesn,ihx,
         -    radtodeg)
            rn_rn0=radtodeg*dacoscheck(ddot(rn,rn0),ccc,1,6,'HELIXNORMALS')
            write (iw0,1000) radtodeg*torsion,radtodeg*sd,radtodeg*rotation,
         -    rn_rn0,dev,dsqrt(ddot(dev,dev))
          end if
          if (nrep .lt. 0) return
          return
    1000  format(' Rotation=',f9.2,' SD=',f7.2,
         -  ' Local tilt=',f9.2,' N/Nr angle:',f8.3,/,
         -  ' X,Y,Z displacements=',3f8.2,' Absolute displacement=',f8.2)
    1001  format(' ',a,' helix cent:',3f12.3,/,' Alpha C:',(3f12.3))
          end
          subroutine angcomp(v0,d0,v,ang)
          real*8 v0(3),d0(3),v(3),v01(3),ddot
          ang=dacoscheck(ddot(v0,v)/dsqrt(ddot(v0,v0)*ddot(v,v)),ccc,1,
         -  6,'ANGCOMP')
          call dcross(v0,v,v01)
          if (ddot(v01,d0) .lt. 0.d0) ang=-ang
          return
          end
          subroutine calcturnperres(turnperres,nres,incrot,perpvec,axisdir,
         -  anglechangeref,irefang,pi,MAXHX)
          real*8 perpvec(3,MAXHX),axisdir(3)
          dimension anglechangeref(MAXHX)
          nresu=nres-2*incrot
          a11=(2*nresu**3+3*nresu**2+nresu)/6
          a21=(nresu*(nresu+1))/2
          a12=a21
          a22=nresu
          b1=0.0
          b2=0.0
          turna=0.0
          nturn=0
          turnchangeav=0.0
          do ir=2+incrot,nres-incrot
            call angcomp(perpvec(1,ir-1),axisdir,perpvec(1,ir),turnchange)
            if (turnchange .lt. 0.0) turnchange=turnchange+2.0*pi
            if (irefang .eq. 1) then
              if (abs(turnchange-anglechangeref(ir)) .gt.
         -        abs((turnchange-2.0*pi)-anglechangeref(ir)))
         -      turnchange=turnchange-2.0*pi
            end if
            turnchangeav=turnchangeav+turnchange
            turna=turna+turnchange
            b1=b1+(ir-incrot)*turna
            b2=b2+turna
          end do
          turnperres=(a22*b1-a12*b2)/(a22*a11-a12*a21)
          turnchangeav=turnchangeav/float(nres-2*incrot-1)
          return
          end
          subroutine prokinkcalcla(nrepc,c,nslt,bend,wobble,faceshift,
         -  rmsb,rmsa,
         -  iflatproline,ix5,radtodeg,maxhlx)
          dimension c(3,nslt),ix5(5)
          real*8 calph(3,maxhlx),axisdirb(3),axisinib(3),axisendb(3),
         -  axisdira(3),axisinia(3),axisenda(3),rms
          parameter (MAXHX=50)
          common /prokink/ icab(MAXHX),icaa(MAXHX),icb(MAXHX),ica(MAXHX),
         -  inb(MAXHX),ina(MAXHX),icapr,icpr,inpr,nra,nrb,icbpr,icgpr,icdpr,
         -  iprintpk
          character*60 message
          real*8 ddot,dmag,cosa,pro_alphC,orig,origa,orig3,orig4,
         -  perpvec,perpveca,perpvec3,perpvec4,perpvec34,enda,
         -  bmin3C,bmin4C,zax,xx,prolinering,p0,ringnorm,axfact,rr
          dimension pro_alphC(3),orig(3),origa(3),orig3(3),orig4(3),
         -  perpvec(3),perpveca(3),perpvec3(3),perpvec4(3),perpvec34(3),
         -  bmin3C(3),bmin4C(3),enda(3),zax(3),xx(3),prolinering(3,5),
         -  p0(3),ringnorm(3),axfact(5)
          iprintkahn=0
          do k=1,3
            calph(k,1)=c(k,icapr)
          end do
          do ir=1,nra
            do k=1,3
              calph(k,ir+1)=c(k,icaa(ir+1))
            end do
          end do
          message=
         - 'Helix after the kink                                        '
          call kahn(calph,nra+1,.true.,axisdira,axisinia,axisenda,
         -  rms,iprintkahn, message,MAXHX)
          rmsa=rms
          if (iprintpk .gt. 1) then
            write (6,7011) 'after','axis',axisdira
            write (6,7011) 'after','init',axisinia
            write (6,7011) 'after','end ',axisenda
            print *,'rms=',rms
          end if
          do ir=1,nrb
            do k=1,3
              calph(k,ir)=c(k,icab(ir))
            end do
          end do
          message=
         -  'Helix before the kink                                       '
          call kahn(calph,nrb,.true.,axisdirb,axisinib,axisendb,rms,
         -  iprintkahn, message,MAXHX)
          rmsb=rms
          if (iprintpk .gt. 1) then
            write (6,7011) 'before','axis',axisdirb
            write (6,7011) 'before','init',axisinib
            write (6,7011) 'before','end ',axisendb
            print *,'RMS=',rms
          end if
          iac=icapr
          im3=icab(3)
          im4=icab(4)
          do k=1,3
            pro_alphC(k)=c(k,icapr)
            bmin3C(k)=c(k,im3)
            bmin4C(k)=c(k,im4)
          end do
          if (iflatproline .eq. 1) then
            do i=1,5
              do k=1,3
                prolinering(k,i)=c(k,ix5(i))
              end do
            end do
            call fitpoints(prolinering,5,3,p0,ringnorm,axfact,iprintpk)
            call dvdif(pro_alphC,p0,xx)
            rr=ddot(xx,ringnorm)
            do k=1,3
              pro_alphC(k)=pro_alphC(k)+rr*ringnorm(k)
            end do
          end if
          cosa=-ddot(axisdira,axisdirb)
          bend=dacoscheck(cosa,ccc,1,6,'PROK-B')*radtodeg
          call calcperp(axisendb,axisdirb,pro_alphC,orig,perpvec,iprintpk)
          call dvsum(orig,axisdira,enda)
          call calcperp(axisinib,axisdirb,enda,origa,perpveca,iprintpk)
          call dvdif(origa,enda,xx)
          cc=dmag(xx)
          if (cc .lt. 0.01) print *,'Wobble is suspect'
          cosa=ddot(perpvec,perpveca)
          wobble=dacoscheck(cosa,ccc,1,6,'PROK-W')*radtodeg
          call dcross(axisdirb,perpvec,zax)
          if (ddot(zax,perpveca) .gt. 0.d0) wobble=-wobble
          call calcperp(axisinib,axisdirb,bmin3C,orig3,perpvec3,iprintpk)
          call calcperp(axisinib,axisdirb,bmin4C,orig4,perpvec4,iprintpk)
          call dvnorm(perpvec)
          call dvnorm(perpvec3)
          call dvnorm(perpvec4)
          do k=1,3
            perpvec34(k)=(perpvec3(k)+perpvec4(k))/2.d0
          end do
          call dvnorm(perpvec34)
          cosa=ddot(perpvec,perpvec34)
          faceshift=dacoscheck(cosa,ccc,1,6,'PROK-FS')*radtodeg
          cosa3=ddot(perpvec,perpvec3)
          cosa4=ddot(perpvec,perpvec4)
          if (cosa3 .gt. cosa4) faceshift=-faceshift
          if (nrepc .lt. 0) return
          return
    7011  format(' Helix ',a,': ',a,'=',3f10.4)
          end
          subroutine calcperp(start,dir,from,orig,perpvec,itest)
          real*8 start,dir,from,orig,perpvec
          dimension start(3),dir(3),from(3),orig(3),perpvec(3)
          real*8 ddot,dmag,dsx,xx,ddsx,perpvecfac
          dimension dsx(3),xx(3)
          call dvdif(from,start,dsx)
          ddsx=ddot(dir,dsx)
          do k=1,3
            perpvec(k)=dir(k)*ddsx-dsx(k)
          end do
          call dvnorm(perpvec)
          perpvecfac=ddot(perpvec,dsx)
          do k=1,3
            orig(k)=from(k)-perpvecfac*perpvec(k)
          end do
          if (itest .gt. 0) then
            write (6,1000) 'Start     ',start
            write (6,1000) 'Dir       ',dir,' Magn=',dmag(dir)
            write (6,1000) 'From      ',from
            write (6,1000) 'Orig      ',orig
            write (6,1000) 'Perpvec   ',perpvec,' Magn=',dmag(dir)
            if (itest .gt. 1) then
              cc=ddot(dir,perpvec)
              print *,'Dir . Perpvec (->0)=',cc
              call dvdif(start,orig,xx)
              cc=ddot(dir,xx)/dmag(xx)
              print *,'Dir . (orig-start) (->1)=',cc
            end if
          end if
          return
    1000  format(1x,a10,3f12.6,a,f12.6)
          end
          subroutine savekinkdat(nmem,bend,wobble,faceshift,psr,radtodeg)
          parameter (MAXFRAMES=50000,MAXCOPY=600)
          parameter (MAXCOPY6=MAXCOPY-6)
          common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
         -  increment,increment2,bdxy(2,MAXFRAMES),wbxy(2,MAXFRAMES),
         -  fsxy(2,MAXFRAMES),wfsxy(2,MAXFRAMES),psxy(2,MAXFRAMES),
         -  turnpr(2,MAXFRAMES),scalardat(2,MAXFRAMES,MAXCOPY6),
         -  x0(MAXCOPY),y0(MAXCOPY),nxselres,ixselres(MAXCOPY)
          bdxy(2,nframe)=sin(bend/radtodeg)
          bdxy(1,nframe)=cos(bend/radtodeg)
                wbxy(2,nframe)=sin(wobble/radtodeg)
          wbxy(1,nframe)=cos(wobble/radtodeg)
          fsxy(2,nframe)=sin(faceshift/radtodeg)
          fsxy(1,nframe)=cos(faceshift/radtodeg)
          wfs=wobble-faceshift
          wfsxy(2,nframe)=sin(wfs/radtodeg)
          wfsxy(1,nframe)=cos(wfs/radtodeg)
          if (nmem .gt. 0) then
            psxy(2,nframe)=sin(psr/radtodeg)
            psxy(1,nframe)=cos(psr/radtodeg)
          end if
          return
          end
          subroutine princax(c,co,aw,awo,n,indxdel,evecs0,evals0,iprint,
         -  inputref,irefcall,radtodeg,LEVTEST)
          dimension c(3,n),co(3,n),aw(n),awo(n),indxdel(n),evecs0(3,3),
         -  evals0(3)
          parameter (MAXFRAMES=50000,MAXCOPY=600)
          common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
         -  increment,increment2,res(2,MAXFRAMES,MAXCOPY),
         -  x0(MAXCOPY),y0(MAXCOPY),nxselres,ixselres(MAXCOPY)
          common /pcadat/ evecsprev(3,3),angprev(3)
          real*8 ddd
          character*1 signlab(3)
          dimension com(3),index(3),ifa(3),ila(3),itemp(3),temp(3),
         -  overlap(3,3),evecs(3,3),evals(3),ang(3),evecstemp(3,3),
         -  tenssave(3,3)
          real*8 tensinert(3,3),diag(3),offdiag(3)
          data signlab /3*' '/
          if (iprint .eq. 0)  then
            iout=6
          else
            iout=iprint
          end if
          write (iout,*)
          nfinal=n
          call trnsfr(co,c,3*n)
          call trnsfr(awo,aw,n)
          call extract(co,indxdel,3,n,nfinal)
          call extract(awo,indxdel,1,n,nfinal)
          call cofms(co,com,nfinal,aw)
          call zeroitd(tensinert,9)
          awsum=0.0
          do ia=1,nfinal
            do i=2,3
              do j=1,i-1
                tensinert(i,j)=tensinert(i,j)+
         -        aw(ia)*(co(i,ia)-com(i))*(co(j,ia)-com(j))
              end do
            end do
            tensinert(1,1)=tensinert(1,1)+aw(ia)*
         -    ((co(2,ia)-com(2))**2+(co(3,ia)-com(3))**2)
            tensinert(2,2)=tensinert(2,2)+aw(ia)*
         -    ((co(1,ia)-com(1))**2+(co(3,ia)-com(3))**2)
            tensinert(3,3)=tensinert(3,3)+aw(ia)*
         -    ((co(1,ia)-com(1))**2+(co(2,ia)-com(2))**2)
          end do
          do i=2,3
            do j=1,i-1
               tensinert(j,i)=tensinert(i,j)
            end do
          end do
          do i=1,3
            do j=1,3
               tenssave(j,i)=tensinert(i,j)
            end do
          end do
          call dtred2(tensinert,3,3,diag,offdiag)
          call dtqli(diag,offdiag,3,3,tensinert,ierr)
          if (ierr .gt. 0) then
            write (6,2004)
            write (iout,2004)
            return
          end if
          do k=1,3
            evals(k)=diag(k)
          end do
          call indexit(index,1,3,0)
          call mrgsrt(6,index,evals,3,ifa,ila,itemp,temp,3)
          do k=1,3
            do l=1,3
              evecs(k,l)=tensinert(l,index(k))
            end do
          end do
          if (LEVTEST .gt. 1) then
            do i=1,3
              do j=1,3
                s=0.0
                do k=1,3
                  s=s+tenssave(i,k)*evecs(j,k)
                end do
                evecstemp(i,j)=s/evals(j)
              end do
            end do
            if (LEVTEST .gt. 2) then
              write (iout,7777) 'evecstest',((evecstemp(i,k),i=1,3),k=1,3)
              write (iout,7777) 'evecs',((evecs(k,i),i=1,3),k=1,3)
            end if
            do i=1,3
              rmin=100.0
              rmax=-100.0
              do j=1,3
                if (evecstemp(j,i) .ne. 0.0) then
                  r=evecs(i,j)/evecstemp(j,i)
                  if (rmin .gt. r) rmin=r
                  if (rmax .lt. r) rmax=r
                end if
              end do
              if (abs(rmax-rmin) .gt. 0.01)
         -      write (iout,*) 'eval failure=',rmax-rmin
            end do
          end if
          if (irefcall .eq. 1) then
            call trnsfr(evals0,evals,3)
            call trnsfr(evecs0,evecs,9)
            write (iout,2000) (i,evals(i),(evecs(i,k),k=1,3),' ',i=1,3)
            write (6,2000) (i,evals(i),(evecs(i,k),k=1,3),' ',i=1,3)
            call trnsfr(evecsprev,evecs0,9)
            return
          end if
          if (nframe .le. 1) then
            if (inputref .eq. 0) then
              call trnsfr(evals0,evals,3)
              call trnsfr(evecs0,evecs,9)
              call zeroit(ang,3)
            end if
          end if
          call indexit(index,1,3,0)
          if (nframe .gt. 1 .or. inputref .eq. 1) then
            if (LEVTEST .gt. 0) then
              call overlapcheck(evecsprev,evecs,overlap,index,nneg)
              write (iout,7777) 'overlap with previous frame',
         -      ((overlap(k,i),i=1,3),k=1,3)
              write (iout,*) 'index=',index
              if (nneg .gt. 0) write (iout,2003) (overlap(index(i),i),i=1,3)
              call overlapcheck(evecs0,evecs,overlap,index,nneg)
              write (iout,7777) 'overlap with reference frame',
         -      ((overlap(k,i),i=1,3),k=1,3)
              write (iout,*) 'index=',index
              if (nneg .gt. 0) write (iout,2003) (overlap(index(i),i),i=1,3)
            end if
            call overlapcheck(evecs0,evecs,overlap,index,nneg)
            do i=1,3
              ang(i)=radtodeg*
         -      dacoscheck(ddd,abs(overlap(index(i),i)),0,6,'PRINCAX')
            end do
          end if
          if (nframe .gt. 0) then
            call trajlimtest(nframe,MAXFRAMES)
            res(1,nframe,1)=evecs(1,1)
            res(2,nframe,1)=evecs(1,2)
            res(1,nframe,2)=evecs(1,3)
            res(2,nframe,2)=evecs(2,1)
            res(1,nframe,3)=evecs(2,2)
            res(2,nframe,3)=evecs(2,3)
            res(1,nframe,4)=evecs(3,1)
            res(2,nframe,4)=evecs(3,2)
            res(1,nframe,5)=evecs(3,3)
            res(1,nframe,6)=ang(1)
            res(2,nframe,6)=ang(2)
            res(1,nframe,7)=ang(3)
          end if
          if (nframe .le. 1 .and. inputref .eq. 0)
         -   call indexit(index,1,3,0)
          write (iout,2000)
         -  (i,evals(index(i)),(evecs(i,k),k=1,3),signlab(i),i=1,3)
          if (nframe .gt. 0) write (iout,2001) ang
          if (irefcall .eq. 0) call trnsfr(evecsprev,evecs,9)
          return
    2000  format(' Evalue ',i1,'=',f15.4,' Principal axes=',3f9.5,1x,a)
    2001  format(' Angles between initial and current principal axes=',
         -  3f8.2,' deg')
    2003  format(' Negative overlap found:',3f6.1)
    2004  format(' Calculation aborted due to diagonalization failure')
    7777  format(1x,a,':',/,(3f10.5))
          end
          subroutine molrad(c,index,nats,iout,maxats)
          dimension c(3,maxats),index(nats)
          parameter (MAXFRAMES=50000,MAXCOPY=600)
          common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
         -  increment,increment2,res(2,MAXFRAMES,MAXCOPY),
         -  x0(MAXCOPY),y0(MAXCOPY),nxselres,ixselres(MAXCOPY)
          real*8 rg,rh,rav(3),rgten(3,3),diag(3),offdiag(3),diagmin,diagmid,
         -  diagmax
          write (iout,*)
          call zeroitd(rav,3)
          call zeroitd(rgten,9)
          do ia=1,nats
            do k=1,3
              rav(k)=rav(k)+c(k,index(ia))
            end do
          end do
          do k=1,3
            rav(k)=rav(k)/nats
          end do
          rg=0.d0
          do ia=1,nats
            rg=rg+(c(1,index(ia))-rav(1))**2+(c(2,index(ia))-rav(2))**2+
         -    (c(3,index(ia))-rav(3))**2
          end do
          rg=rg/nats
          rg=sqrt(rg)
          rh=0.d0
          do ia=1,nats
            do ja=ia+1,nats
              rij=dist2(c(1,index(ia)),c(1,index(ja)))
              if (rij .lt. 1.e-5) then
                write (6,1000) ia,ja
              else
                rh=rh+1.0/sqrt(rij)
              end if
              do k=1,3
                do l=1,3
                  rgten(k,l)=rgten(k,l)+(c(k,index(ia))-c(k,index(ja)))*
         -          (c(l,index(ia))-c(l,index(ja)))
                end do
              end do
            end do
          end do
          rh=2.0*rh/nats**2
          do k=1,3
            do l=1,3
              rgten(k,l)=rgten(k,l)/float(nats**2)
            end do
          end do
          call dtred2(rgten,3,3,diag,offdiag)
          call dtqli(diag,offdiag,3,3,rgten,ierr)
          if (ierr .gt. 0) then
            write (6,1004)
            write (iout,1004)
            return
          end if
          diagmin=dmin1(diag(1),diag(2),diag(3))
          diagmax=dmax1(diag(1),diag(2),diag(3))
          diagmid=0.d0
          if (diagmax .eq. diagmin) then
            diagmid=diagmin
          else
            do k=1,3
              if (diag(k) .ne. diagmin .and. diag(k) .ne. diagmax)
         -      diagmid=diag(k)
            end do
          end if
          rmaxmin=1.0
          if (diagmin .ne. 0.d0) rmaxmin=diagmax/diagmin
          asph=diagmax-0.5*(diagmin+diagmid)
          acyl=diagmid-diagmin
          rsa=1.5*(diag(1)**2+diag(2)**2+diag(3)**2)/
         -  (diag(1)+diag(2)+diag(3))**2-0.5
          if (nframe .gt. 0) then
            call trajlimtest(nframe,MAXFRAMES)
            write (iout,1001) nframe,rg,1/rh
            res(1,nframe,1)=rg
            res(2,nframe,1)=1.0/rh
            res(1,nframe,2)=rh
            res(2,nframe,2)=rmaxmin
          else
            write (iout,1002) rg,1/rh
          end if
          write (iout,1003) diag,rmaxmin,asph,acyl,rsa
          return
    1000  format(' Atoms ',i6,' and ',i6,' are too close')
    1001  format(' Frame',i6,' R(gyration)=',f9.3,' R(hydrodynamic)=',f9.3)
    1002  format(' R(gyration)=',f9.3,' R(hydrodynamic)=',f9.3)
    1003  format(' Moments of inertia=',3f10.3,' M(max)/M(min)=',f10.3,/,
         -  ' Asphericity=',f8.3,' Acylindricity=',f8.3,
         -  ' Relative shape anisotropy=',f8.3)
    1004  format(' Calculation aborted due to diagonalization failure')
          end
          subroutine overlapcheck(evecsprev,evecs,overlap,index,nneg)
          dimension evecsprev(3,3),evecs(3,3),overlap(3,3),index(3)
          dimension absoverlap(3,3)
          data imax1 /0/,jmax1 /0/,imax2 /0/,jmax2 /0/
          call zeroit(overlap,9)
          do i=1,3
            do j=1,3
              do k=1,3
                overlap(i,j)=overlap(i,j)+evecsprev(i,k)*evecs(j,k)
              end do
              absoverlap(i,j)=abs(overlap(i,j))
            end do
          end do
          call zeroiti(index,0,3)
          omax=0.0
          do i=1,3
            do j=1,3
              if (omax  .lt. absoverlap(i,j)) then
                omax=absoverlap(i,j)
                imax1=i
                jmax1=j
              end if
            end do
          end do
          index(imax1)=jmax1
          omax=0.0
          do i=1,3
            if (i .ne. imax1) then
              do j=1,3
                if (j .ne. jmax1) then
                  if (omax  .lt. absoverlap(i,j)) then
                    omax=absoverlap(i,j)
                    imax2=i
                    jmax2=j
                  end if
                end if
              end do
            end if
          end do
          index(imax2)=jmax2
          do i=1,3
            if (index(i) .eq. 0) index(i)=6/(jmax1*jmax2)
          end do
          nneg=0
          do i=1,3
            if (overlap(index(i),i) .lt. 0.0) nneg=nneg+1
          end do
          return
          end
          subroutine correl(iout,res1,ic1,name1,lname1,av1,sd1,res2,ic2,
         -  name2,lname2,av2,sd2,corr,n,iavsdcalc,now6)
          dimension res1(2,n),res2(2,n)
          character*(*) name1,name2
          real*8 sum12,sum1,sum2,sum11,sum22
          if (iavsdcalc .gt. 0) then
            sum1=0.d0
            sum2=0.d0
            sum11=0.d0
            sum22=0.0d0
            do i=1,n
              sum1=sum1+res1(ic1,i)
              sum11=sum11+res1(ic1,i)**2
              sum2=sum2+res2(ic2,i)
              sum22=sum22+res2(ic2,i)**2
            end do
            av1=sum1/n
            av2=sum2/n
            sd1=dsqrt(dabs(sum11/n-av1**2))
            sd2=dsqrt(dabs(sum22/n-av2**2))
            write (6,1001) name1(1:lname1),av1,sd1
            write (6,1001) name2(1:lname2),av2,sd2
          end if
          sum12=0.d0
          do i=1,n
            sum12=sum12+res1(ic1,i)*res2(ic2,i)
          end do
          sum12=sum12/n
          corr=0.0
          if (sd1*sd2 .gt. 0.0) corr=(sum12-av1*av2)/(sd1*sd2)
          if (now6 .eq. 0)
         -  write (6,1000) name1(1:lname1),name2(1:lname2),corr
          write (iout,1000) name1(1:lname1),name2(1:lname2),corr
          return
    1000  format(1x,a25,' - ',a25,' correlation=',f8.5)
    1001  format(1x,a25,' Average=',f15.6,' S.D.=',f16.5)
          end
          subroutine trajstat(iout,ndials,maxdials,angname,langname,nrdat,
         -  maxrdat,irescolf,rname,lrname,corr12,incrres,icorr,now6,
         -  title,ltitle,radtodeg)
          character*(*) angname(maxdials),rname(maxrdat),title
          dimension langname(maxdials),lrname(maxrdat)
          parameter (MAXFRAMES=50000,MAXCOPY=600)
          common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
         -  increment,increment2,res(2,MAXFRAMES,MAXCOPY),
         -  x0(MAXCOPY),y0(MAXCOPY),nxselres,ixselres(MAXCOPY)
          parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
          parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-MAX2D*MAX2D)
          common /nnwork/ ccc(MAX2D,MAX2D),fill(IFILL2)
          dimension cv(MAXCOPY),av_r(MAXCOPY),sd_r(MAXCOPY),lcorrtyp(2)
          real*8 ddd,sum,sum2,sinsum,cossum,sinsum_ab,sinsum2,cossum2,
         -  sinsum2_a,sinsum2_b,sin_ai,sin_bi,av_a(MAXCOPY),ang_ai,ang_aj,
         -  ang_bi,ang_bj,sin_aij,r12,r13,r23,csd,ssd,csc,crs,crc
          character*26 corrtyp(2)
          data corrtyp /'Fisher & Lee','Jammalamadaka and SenGupta'/,
         -  lcorrtyp /12,26/
          write (iout,*)
          if (ltitle .gt. 1) write (iout,*) title(1:ltitle)
          if (maxdials .gt. MAXCOPY-1) then
            write (6,2004) maxdials,MAXCOPY
            stop
          end if
          if (nframe .lt. 1) return
          do id=1,ndials
            sinsum=0.d0
            cossum=0.d0
            do i=1,nframe
              cossum=cossum+res(1,i,incrres+id)
              sinsum=sinsum+res(2,i,incrres+id)
            end do
            sum=dsqrt(sinsum**2+cossum**2)
            cv(id)=1.0-sum/nframe
            cossum=cossum/sum
            av_a(id)=dacoscheck(cossum,csum,1,6,'TRAJSTAT')
            if (sinsum .lt. 0.d0) av_a(id)=-av_a(id)
            if (now6 .eq. 0) write (6,2078) angname(id)(1:langname(id)),
         -    av_a(id)*radtodeg,cv(id)
            write (iout,2078) angname(id)(1:langname(id)),
         -    av_a(id)*radtodeg,cv(id)
          end do
          do irdat=1,nrdat
            id=irescolf+(irdat-1)/2
            ic=mod(irdat-1,2)+1
            sum=0.d0
            sum2=0.d0
            do i=1,nframe
              sum=sum+res(ic,i,incrres+id)
              sum2=sum2+res(ic,i,incrres+id)**2
            end do
            av_r(irdat)=sum/nframe
            sd_r(irdat)=dsqrt(dabs(sum2/nframe-av_r(irdat)**2))
            if (now6 .eq. 0) write (6,2077) rname(irdat)(1:lrname(irdat)),
         -    av_r(irdat),sd_r(irdat)
            write (iout,2077)
         -    rname(irdat)(1:lrname(irdat)),av_r(irdat),sd_r(irdat)
          end do
          if (icorr .gt. 0) then
            if (ndials .gt. 0) then
              if (ndials .le. 10 .and. now6 .eq. 0)
         -      write (6,2001) corrtyp(icorr)(1:lcorrtyp(icorr))
              write (iout,2001) corrtyp(icorr)(1:lcorrtyp(icorr))
              do id=1,ndials
                ccc(id,id)=1.0
                do jd=id+1,ndials
                  sinsum_ab=0.d0
                  sinsum2_a=0.d0
                  sinsum2_b=0.d0
                  if (icorr .eq. 1) then
                    do i=1,nframe
                      ang_ai=dacoscheck(ddd,res(1,i,incrres+id),0,6,
         -              'TRAJSTAT')
                      if (res(2,i,incrres+id) .lt. 0.0) ang_ai=-ang_ai
                      ang_bi=dacoscheck(ddd,res(1,i,incrres+jd),0,6,
         -              'TRAJSTAT')
                      if (res(2,i,incrres+jd) .lt. 0.0) ang_bi=-ang_bi
                      do j=i+1,nframe
                        ang_aj=dacoscheck(ddd,res(1,j,incrres+id),0,6,
         -                'TRAJSTAT')
                        if (res(2,j,incrres+id) .lt. 0.0) ang_aj=-ang_aj
                        ang_bj=dacoscheck(ddd,res(1,j,incrres+jd),0,6,
         -                'TRAJSTAT')
                        if (res(2,j,incrres+jd) .lt. 0.0) ang_bj=-ang_bj
                        sin_aij=dsin(ang_ai-ang_aj)
                        sin_bij=dsin(ang_bi-ang_bj)
                        sinsum_ab=sinsum_ab+sin_aij*sin_bij
                        sinsum2_a=sinsum2_a+sin_aij**2
                        sinsum2_b=sinsum2_b+sin_bij**2
                      end do
                    end do
                  else
                    do i=1,nframe
                      ang_ai=dacoscheck(ddd,res(1,i,incrres+id),0,6,
         -              'TRAJSTAT')
                      if (res(2,i,incrres+id) .lt. 0.0) ang_ai=-ang_ai
                      ang_bi=dacoscheck(ddd,res(1,i,incrres+jd),0,6,
         -              'TRAJSTAT')
                      if (res(2,i,incrres+jd) .lt. 0.0) ang_bi=-ang_bi
                      sin_ai=dsin(ang_ai-av_a(id))
                      sin_bi=dsin(ang_bi-av_a(jd))
                      sin_aij=sin_ai*sin_bi
                      sinsum_ab=sinsum_ab+sin_aij
                      sinsum2_a=sinsum2_a+sin_ai**2
                      sinsum2_b=sinsum2_b+sin_bi**2
                    end do
                  end if
                  ccorr=(sinsum_ab)/dsqrt(sinsum2_a*sinsum2_b)
                  if (ndials .le. 10 .and. now6 .eq. 0)
         -          write (6,2000) angname(id)(1:langname(id)),
         -            angname(jd)(1:langname(jd)),ccorr
                  write (iout,2000) angname(id)(1:langname(id)),
         -          angname(jd)(1:langname(jd)),ccorr
                  ccc(id,jd)=ccorr
                  ccc(jd,id)=ccorr
                end do
              end do
            end if
            if (nrdat .gt. 0) then
              if (now6 .eq. 0) write (6,2002) ' '
              write (iout,2002) ' '
              do irdat=1,nrdat
                id=irescolf+(irdat-1)/2
                ic=mod(irdat-1,2)+1
                do jrdat=irdat+1,nrdat
                  jd=irescolf+(jrdat-1)/2
                  jc=mod(jrdat-1,2)+1
                  call correl(iout,res(1,1,incrres+id),ic,
         -          rname(irdat),lrname(irdat),av_r(irdat),sd_r(irdat),
         -          res(1,1,incrres+jd),jc,rname(jrdat),lrname(jrdat),
         -          av_r(jrdat),sd_r(jrdat),corr,nframe,0,now6)
                  if (irdat .eq. 1 .and. jrdat .eq. 2) corr12=corr
                end do
              end do
            end if
            if (ndials*nrdat .gt. 0) then
              if (ndials .le. 10 .and. now6 .eq. 0) write (6,2003)
              write (iout,2003)
              do id=1,ndials
                do jrdat=1,nrdat
                  corrsum=0.d0
                  jd=irescolf+(jrdat-1)/2
                  jc=mod(jrdat-1,2)+1
                  sinsum=0.d0
                  sinsum2=0.d0
                  cossum=0.d0
                  cossum2=0.d0
                  crc=0.d0
                  crs=0.d0
                  csc=0.d0
                  do i=1,nframe
                    ang_ai=dacoscheck(ddd,res(1,i,incrres+id),0,6,
         -            'TRAJSTAT')
                    if (res(2,i,incrres+id) .lt. 0.0) ang_ai=-ang_ai
                    c=res(1,i,incrres+id)
                    s=res(2,i,incrres+id)
                    x=res(jc,i,incrres+jd)
                    crc=crc+x*c
                    crs=crs+x*s
                    csc=csc+s*c
                    sinsum=sinsum+s
                    cossum=cossum+c
                    sinsum2=sinsum2+s**2
                    cossum2=cossum2+c**2
                    corrsum=corrsum+ang_ai*x
                  end do
                  corrsum=corrsum*radtodeg
                  cav=cossum/nframe
                  sav=sinsum/nframe
                  csd=(cossum2/nframe-cav**2)
                  ssd=(sinsum2/nframe-sav**2)
                  if (csd .gt. 0.d0 .and. ssd .gt. 0.d0) then
                    csd=dsqrt(csd)
                    ssd=dsqrt(ssd)
                    r12=(crc/nframe-cav*av_r(jrdat))/(csd*sd_r(jrdat))
                    r13=(crs/nframe-sav*av_r(jrdat))/(ssd*sd_r(jrdat))
                    r23=(csc/nframe-sav*cav)/(csd*ssd)
                    ccorr=(r12**2+r13**2-2.0*r12*r13*r23)/(1-r23**2)
                  else
                    ccorr=0.0
                  end if
                  if (ndials .le. 10 .and. now6 .eq. 0)
         -          write (6,2000) angname(id)(1:langname(id)),
         -            rname(jrdat)(1:lrname(jrdat)),ccorr
                  write (iout,2000) angname(id)(1:langname(id)),
         -          rname(jrdat)(1:lrname(jrdat)),ccorr
                end do
              end do
            end if
          end if
          return
    2000  format(1x,a,' - ',a25,' ccc=',f8.5)
    2001  format(' ccc: Circular correlation coefficient (',a,')')
    2002  format(/,a,'Pearson correlation coefficient')
    2003  format(' ccc: Linear-circular correlation coefficient (Mardia)')
    2004  format(' PROGRAM ERROR: argument maxdials of subroutine trajstat',
         -  ' exceeds',/,' the parameter MAXCOPY (',i4,' vs ',i4,')')
    2077  format(1x,a,' average=',f10.2,' S.D.=',f8.2,a,'CV=',f8.5)
    2078  format(1x,a,' average=',f10.2,' CV=',f8.5)
          end
          subroutine volcalc(nrand,c,na,isegno,ian,nsegslt,molsltlim,
         -  icellno,rvdw,rvdwsolv2,rvdwsolv,rvdwsolv22,vmac,vshell,vint,
         -  vmacsd,vshellsd,vintsd,vfrstsh,vfrstshsd,rsolv,ixcell,index,
         -  ifirst,ilast,itemp1,itemp2,nconfig,iout,levout,maxrsd,maxrec)
          dimension c(3,na),isegno(na),ian(na),rvdw(na),icellno(na),
         -  rvdwsolv2(na),rvdwsolv(na),rvdwsolv22(na),molsltlim(3,maxrsd),
         -  ixcell(na),index(maxrec),ifirst(maxrec),ilast(maxrec),
         -  itemp1(maxrec),itemp2(maxrec)
          parameter (MAXINTVOL=10)
          dimension corner(3),edge(3),rand(3),r(3),ri(3),rj(3),xyzmin(3),
         -  xyzmax(3),ecell(3),rvdwan(99),rijexmn(1000),
         -  rij2mnmx(1000),iamn(1000),ing(MAXINTVOL),
         -  nintij(MAXINTVOL,MAXINTVOL),nxyz(3),ixyz(3)
          character*80 line
          data rvdwan /1.2,4*0.0,2.0,1.5,1.4,1.35,5*0.0,1.9,1.85,1.8,
         -  17*0.0,1.95,64*0.0/
          rsolv2=2.0*rsolv
          rvdwmax=2.0
          padding=rvdwmax+rsolv
          spacing=rvdwmax+2.0*rsolv
          call cellpart(c,ian,itemp1,1,na,padding,spacing,corner,ecell,edge,
         -  xyzmin,xyzmax,vtot,nxyz,ixyz,icellno,itemp2,index,ifirst,ilast,
         -  ntotcell,levout,iout,maxrec)
          ncell=0
          do ic=1,ntotcell
            if (ifirst(ic) .ne. 0) then
              ncell=ncell+1
              ixcell(ncell)=ic
            end if
          end do
          call zeroiti(itemp1,0,ntotcell)
          do ic=1,ncell
            icell=ixcell(ic)-1
            ixyz(1)=mod(icell,nxyz(1))
            icell=(icell-ixyz(1))/nxyz(1)
            ixyz(2)=mod(icell,nxyz(2))
            ixyz(3)=(icell-ixyz(2))/nxyz(2)
            do ix=max0(0,ixyz(1)-1),min0(nxyz(1)-1,ixyz(1)+1)
              do iy=max0(0,ixyz(2)-1),min0(nxyz(2)-1,ixyz(2)+1)
                do iz=max0(0,ixyz(3)-1),min0(nxyz(3)-1,ixyz(3)+1)
                  icng=1+ix+nxyz(1)*iy+nxyz(1)*nxyz(2)*iz
                  itemp1(icng)=1
                end do
              end do
            end do
          end do
          nrancell=0
          do ic=1,ntotcell
            if (itemp1(ic) .gt. 0) then
              nrancell=nrancell+1
              itemp1(nrancell)=ic
            end if
          end do
          if (nconfig .lt. 2) then
            write (iout,1003) ecell,ntotcell,ncell,nrancell,rsolv2
            write (6,1003) ecell,ntotcell,ncell,nrancell,rsolv2
            if (nsegslt .gt.  MAXINTVOL)  then
              write (iout,1005) nsegslt,MAXINTVOL
              write (6,1005) nsegslt,MAXINTVOL
            end if
          end if
          if (levout .gt. 0) write (iout,7000) nxyz,ntotcell,nrancell,ncell
          do ia=1,na
            rvdw(ia)=rvdwan(ian(ia))
            rvdwsolv(ia)=rvdw(ia)+rsolv
            rvdwsolv2(ia)=(rvdw(ia)+rsolv)**2
            rvdwsolv22(ia)=(rvdw(ia)+2.0*rsolv)**2
            if (levout .gt. 4)
         -    write (iout,7001) ia,ian(ia),rvdw(ia),isegno(ia)
          end do
          nmac=0
          nshell=0
          nfrstsh=0
          nint=0
          nmacprev=0
          nshellprev=0
          nfrstshprev=0
          nintprev=0
          nrandprev=0
          vmacsm=0.0
          vshellsm=0.0
          vfrstshsm=0.0
          vintsm=0.0
          vmacsm2=0.0
          vshellsm2=0.0
          vfrstshsm2=0.0
          vintsm2=0.0
          if (nsegslt .le. MAXINTVOL) call zeroiti(nintij,0,MAXINTVOL**2)
          nrand10=max0(1,nrand/10)
          do ir=1,nrand
            call randpx(3,rand)
            do ic=1,nrancell
              icell=itemp1(ic)-1
              ixyz(1)=mod(icell,nxyz(1))
              icell=(icell-ixyz(1))/nxyz(1)
              ixyz(2)=mod(icell,nxyz(2))
              ixyz(3)=(icell-ixyz(2))/nxyz(2)
              if (levout .gt. 3) write (iout,7003) ir,ic,icell,ixyz
              do k=1,3
                r(k)=corner(k)+(ixyz(k)+rand(k))*ecell(k)
              end do
              do im=1,nsegslt
                rijexmn(im)=100000.0
                rij2mnmx(im)=100000.0
              end do
              call zeroiti(iamn,0,nsegslt)
              do ix=max0(0,ixyz(1)-1),min0(nxyz(1)-1,ixyz(1)+1)
                do iy=max0(0,ixyz(2)-1),min0(nxyz(2)-1,ixyz(2)+1)
                  do iz=max0(0,ixyz(3)-1),min0(nxyz(3)-1,ixyz(3)+1)
                    icn=1+ix+nxyz(1)*iy+nxyz(1)*nxyz(2)*iz
                    if (ifirst(icn) .gt. 0) then
                      do iaa=ifirst(icn),ilast(icn)
                        ia=index(iaa)
                        rij2=dist2(r,c(1,ia))
                        if (levout .gt. 4)
         -                write (iout,7004) iaa,ia,ix,iy,iz,icn,rij2
                        im=isegno(ia)
                        if (rij2 .lt. rij2mnmx(im)) then
                          rijex=sqrt(rij2)-rvdw(ia)
                          if (rijex .lt. rijexmn(im)) then
                            rijexmn(im)=rijex
                            rij2mnmx(im)=(rvdwmax+rijex)**2
                            iamn(im)=ia
                          end if
                        end if
                      end do
                    end if
                  end do
                end do
              end do
              nng=0
              rijexmin=10000.0
              do im=1,nsegslt
                if (iamn(im) .gt. 0) then
                  if (rijexmn(im) .lt. rijexmin) then
                    rijexmin=rijexmn(im)
                    iamin=iamn(im)
                  end if
                  rij2mnmx(im)=(rvdw(iamn(im))+rijexmn(im))**2
                end if
                if (iamn(im) .gt. 0) then
                  if (rij2mnmx(im) .le. rvdwsolv22(iamn(im))) then
                    nng=nng+1
                    ing(nng)=im
                  end if
                end if
              end do
              if (rijexmin .le. 0.0) then
                nmac=nmac+1
              else if (rijexmin .le. rsolv) then
                nshell=nshell+1
                if (levout .eq. 2) then
                  call blankout(line,1,80)
                  line(1:4)='ATOM'
                  line(22:22)='S'
                  line(13:16)='He  '
                  line(18:20)='SHL'
                  write (line(7:11),2004) nshell
                  write (line(23:26),2003) 1
                  write (line(31:54),2002) r
                  write (line(55:60),2001) 1.0
                  write (line(61:66),2001) 0.0
                end if
              else if (rijexmin .le. rsolv2) then
                nfrstsh=nfrstsh+1
              end if
              if (nng .gt. 1) then
                nrint=0
                do in=1,nng
                  ia=iamn(ing(in))
                  do jn=1,in-1
                    ja=iamn(ing(jn))
                    ijint=0
                    if (rij2mnmx(in) .lt. rvdwsolv2(ia) .and.
         -              rij2mnmx(jn) .lt. rvdwsolv2(ja)) then
                      ijint=1
                    else
                      rij2=dist2(c(1,ia),c(1,ja))
                      if (rij2 .le. (rvdwsolv(ia)+rvdwsolv(ja))**2) then
                        rijsum=0.0
                        do k=1,3
                          ri(k)=c(k,ia)-r(k)
                          rj(k)=c(k,ja)-r(k)
                          rijsum=rijsum+ri(k)*rj(k)
                        end do
                        ac=rijsum/sqrt(abs(rij2mnmx(in)*rij2mnmx(jn)))
                        acmax=(rvdwsolv2(ia)+rvdwsolv2(ja)-rij2)/
         -                (2.0*rvdwsolv(ia)*rvdwsolv(ja))
                        if (ac .le. acmax) ijint=1
                      end if
                    end if
                    if (ijint .eq. 1) then
                      nrint=nrint+1
                      if (nsegslt .le. MAXINTVOL)
         -              nintij(in,jn)=nintij(in,jn)+1
                    end if
                  end do
                end do
                if (nrint .gt. 0) then
                  nint=nint+1
                  if (levout .eq. 3) then
                    call blankout(line,1,80)
                    line(1:4)='ATOM'
                    line(22:22)='I'
                    line(13:16)='He  '
                    line(18:20)='INT'
                    write (line(7:11),2004) nint
                    write (line(23:26),2003) 1
                    write (line(31:54),2002) r
                    write (line(55:60),2001) 1.0
                    write (line(61:66),2001) 0.0
                    write (77,2000) line(1:80)
                  end if
                end if
              end if
            end do
            if (mod(ir,nrand10) .eq. 0) then
              if (nconfig .eq. 1 .and. ir+nrand10 .le. nrand) then
                vshell=vtot*float(nshell)/float(ntotcell*ir)
                vfrstsh=vtot*float(nshell+nfrstsh)/float(ntotcell*ir)
                vmac=vtot*float(nmac)/float(ntotcell*ir)
                vint=vtot*float(nint)/float(ntotcell*ir)
                write (iout,1000) ir,vmac,vshell,vfrstsh,vint
              end if
              rndiff=float(ntotcell*(ir-nrandprev))
              vm10=vtot*float(nmac-nmacprev)/rndiff
              vmacsm=vmacsm+vm10
              vmacsm2=vmacsm2+vm10**2
              vs10=vtot*float(nshell-nshellprev)/rndiff
              vshellsm=vshellsm+vs10
              vshellsm2=vshellsm2+vs10**2
              vf10=vtot*float((nshell+nfrstsh)-(nshellprev+nfrstshprev))/
         -      rndiff
              vfrstshsm=vfrstshsm+vf10
              vfrstshsm2=vfrstshsm2+vf10**2
              vi10=vtot*float(nint-nintprev)/rndiff
              vintsm=vintsm+vi10
              vintsm2=vintsm2+vi10**2
              nmacprev=nmac
              nshellprev=nshell
              nfrstshprev=nfrstsh
              nintprev=nint
              nrandprev=ir
            end if
          end do
          vshell=vtot*float(nshell)/float(ntotcell*nrand)
          vfrstsh=vtot*float(nshell+nfrstsh)/float(ntotcell*nrand)
          vmac=vtot*float(nmac)/float(ntotcell*nrand)
          vint=vtot*float(nint)/float(ntotcell*nrand)
          vmacsd=sqrt(abs(vmacsm2/10.0-(vmacsm/10.0)**2)/9.0)
          vshellsd=sqrt(abs(vshellsm2/10.0-(vshellsm/10.0)**2)/9.0)
          vfrstshsd=sqrt(abs(vfrstshsm2/10.0-(vfrstshsm/10.0)**2)/9.0)
          vintsd=sqrt(abs(vintsm2/10.0-(vintsm/10.0)**2)/9.0)
          write (iout,1000) nrand,vmac,vshell,vfrstsh,vint,' ',
         -  vmacsd,vshellsd,vfrstshsd,vintsd
          if (nsegslt .le. MAXINTVOL .and. nsegslt .gt. 2) then
            write (iout,1001) (in,in=1,nsegslt)
            do in=1,nsegslt
              write (iout,1002) molsltlim(1,in),molsltlim(2,in),in,
         -      (vtot*float(nintij(in,jn))/float(ntotcell*nrand),jn=1,in)
            end do
          end if
          return
    1000  format(' Nr=',i7,' Vslt=',f10.1,' Vxsh=',f9.1,' Vfsh=',f9.1,
         -  ' Vint=',f9.1,' A**2',a,/,
         -  11x,'   SD=',f10.1,'   SD=',f9.1,'   SD=',f9.1,'   SD=',f9.1)
    1001  format(' Interface volume between solute molecules',/,
         -  3x,10i7)
    1002  format(i6,' - ',i6,i3,10f7.1)
    1003  format(' Copies of random points will be placed in ',
         -  'rectangles of dimension',/,f10.5,2(' * ',f10.5),' A**3',/,
         -  ' There are',i6,' such cells',i5,' of them contains solute',/,
         -  ' Translated copies will be placed into all occupied cells and',
         -  ' its neighbors,',/,' a total of',i6,' cells',
         -  ' Nr: result for Nr random numbers',/
         -  ' Vslt: estimate of solute volume (in A^3)',/,
         -  ' Vxsh: estimate of solvent-excludes shell volume (in A^3)',/,
         -  ' Vfsh: estimate of first solvation shell volume (in A^3)',/,
         -  '       shell thickness=',f5.2,' A',/,
         -  ' Vint: estimate of the interface volume volume (in A^3)',/)
    1005  format(' NOTE: The number of solute molecules (',i5,') exceeds',
         -  i4,/,' - pairwise interface volumes will not be calculated')
    2000  format(a)
    2001  format(f6.3)
    2002  format(3f8.3)
    2003  format(i4)
    2004  format(i5)
    7000  format(' nyxz=',3i3,' ntotcell=',i4,' nrancell=',i4,' ncell=',i4)
    7001  format(' ia,ian=',2i4,' rvdw(ia)=',f8.2,'isegno=',i4)
    7003  format(' ir,ic,icell=',3i5,' ixyz=',3i3)
    7004  format(' iaa,ia=',2i5,' ixyz=',3i3,' icn=',i5,' rij2=',e12.5)
          end
          subroutine summarize_amber_csv(resnames,minmaxlab1,mxrsd)
          character*8 resnames(mxrsd)
          character*1 minmaxlab1(mxrsd)
          character*1000 line
          parameter (MAXREC=200000,MAXRSD=70000,MAXPHI=400)
          parameter (MAXCOL=36)
          character*30 title(MAXCOL),label(4),syslabel
          character*30 source(3)
          character*1 ans,types1(4)
          character*26 err_typ(2)
          character*80 atitle
          character*200 inpstatfile,outtabfile
          parameter (IFILL7=MAXPHI*MAXPHI*MAXPHI-(2*MAXCOL+10)*MAXREC
         -  -6*MAXRSD)
          common /nnwork/ data(MAXCOL,MAXREC),err(MAXCOL,MAXREC),
         -  ixr1(MAXREC),ixr2(MAXREC),col1(MAXREC),col2(MAXREC),
         -  ixfres(MAXREC),ixlres(MAXREC),tabrowsum(MAXREC),ixcol(MAXREC),
         -  ixrow(MAXREC),iresix(MAXREC),colsum(MAXRSD),colsumm(MAXRSD),
         -  colmin(MAXRSD),colmax(MAXRSD),ixcolmin(MAXRSD),ixcolmax(MAXRSD),
         -  fill(IFILL7)
          dimension rmin(MAXCOL),rmax(MAXCOL),ltitle(MAXCOL),llabel(4),
         -  lsource(3),lerr_typ(2),ixprint(MAXCOL)
          data ires /0/,types1 /'c','r','l','d'/
          data label /'COMPLEX','RECEPTOR','LIGAND','DELTAS'/
          data source /'Total Energy Decomposition',
         -  'Sidechain Energy Decomposition',
         -  'Backbone Energy Decomposition'/,lsource /26,20,29/
          data err_typ /'Standard Deviation','Standard Error of the Mean'/
          data llabel /7,8,6,6/,iresrow1p /0/,iresrow2p /0/,irescol1p /0/,
         -  irescol2p /0/,lerr_typ/18,26/
          len=1000
          inpt=20
          linpstatfile=10
          call blankout(inpstatfile,1,80)
          do while (inpstatfile(linpstatfile-2:linpstatfile) .ne. 'csv')
            linpstatfile=0
            call openfile(inpt,0,'statistics',10,'old',inpstatfile,
         -    linpstatfile,notfnd,0,1,1,1,0)
            if (inpstatfile(linpstatfile-2:linpstatfile) .ne. 'csv')
         -    print *,'ERROR: file extension is not csv'
          end do
          outtabfile=inpstatfile
          outtabfile(linpstatfile-2:linpstatfile)='sum'
          iout=21
          call openfile(iout,0,' ',1,'new',outtabfile,
         -  linpstatfile,notfnd,0,1,1,1,0)
          write (iout,2000) inpstatfile(1:linpstatfile)
          ipairs=0
          ierr=0
          idecomp=0
          irepeat=0
          call blankout(line,1,len)
          line(1:1)='|'
          do while (line(1:1) .eq. '|')
            call blankout(line,1,len)
            read (inpt,1000,end=999) line
          end do
          if (line(1:9) .eq. 'idecomp =') read (line(10:11),*) idecomp
          if (idecomp .eq. 4) ipairs=1
          call blankout(atitle,1,80)
          read (inpt,1000,end=999) atitle
          call lastchar(atitle,latitle,80)
          call getskipcomma(inpt,line,len,llab,ifail)
          lsyslabel=llab
          syslabel(1:lsyslabel)=line(1:llab)
          call findname(syslabel,label,1,4,nc,lsyslabel)
          write (6,*) atitle(1:latitle)
          write (iout,*) atitle(1:latitle)
    100   call quiz(ans,nt,types1(nc),'d',0,'Data type to tabulate',21,0,
         -  5,6,0)
          if (nt .ne. nc) then
            do while (line(1:llabel(nt)) .ne. label(nt)(1:llabel(nt)))
              call getskipcomma(inpt,line,len,llab,ifail)
              if (ifail .gt. 0) then
                write (6,1019) label(nt)(1:llabel(nt)),
         -        outtabfile(1:linpstatfile)
                if (irepeat .gt. 0) stop
                rewind inpt
                go to 100
              end if
            end do
          end if
          call quiz(ans,ns,'t',' ',0,'Data source to tabulate',23,0,5,6,0)
          do while (line(1:lsource(ns)) .ne. source(ns)(1:lsource(ns)))
            call getskipcomma(inpt,line,len,llab,ifail)
            if (ifail .gt. 0) then
              write (6,1019) source(ns)(1:lsource(ns)),
         -      outtabfile(1:linpstatfile)
              if (irepeat .gt. 0) stop
              rewind inpt
              go to 100
            end if
          end do
          write (iout,1017) 'type',label(nt)(1:llabel(nt))
          write (iout,1017) 'source',source(ns)(1:lsource(ns))
          call blankout(line,1,len)
          read (inpt,1000) line
          ic=1
          ncol=0
          call findnextchar(',',line,ic,len)
          ic=ic+1
          call findnextchar(',',line,ic,len)
          ic1=ic+1
          do while (ic .lt. len)
            call findnextchar(',',line,ic,len)
            if (ic .gt. ic1+1 .and. ic .lt. len) then
              ncol=ncol+1
              call blankout(title(ncol),1,30)
              ltitle(ncol)=ic-ic1
              title(ncol)(1:ltitle(ncol))=line(ic1:ic-1)
            end if
            ic=ic+1
            ic1=ic
            ic=ic+1
          end do
          read (inpt,*)
          ierr_mean=2
          call askyn('Do you want to tabulate the errors too',38,1,-1,
         -  ierr,0,0)
          if (ierr .gt. 0) call quiz(ans,ierr_mean,'m',' ',0,
         -  'error estimate type',19,0,5,6,000)
          write (iout,1023) err_typ(ierr_mean)(1:lerr_typ(ierr_mean))
          call askyn('Do you want to mark with m and M the extreme values',
         -  51,1,1,mark,117,4)
          if (mark .gt. 0) write (iout,2004)
          if (ipairs .eq. 0) print *,'Residue-molecule data found'
          if (ipairs .eq. 1) print *,'Residue-residue data found'
          call read_amb_data_csv(data,err,ncol,ixr1,ixr2,resnames,nresdat,
         -  ipairs,ierr_mean,inpt,MAXCOL,mxrsd,MAXREC)
          print *,'Number of properties in the input data:',ncol
          if (ipairs .eq. 0) then
            print *,'Number of residues read=',nresdat
            nres=nresdat
          else
            print *,'Number of residue pairs read=',nresdat
            nrespair=nresdat
            do ir=1,nresdat
              ixfres(ir)=0
              ixlres(ir)=0
            end do
            iresprev=0
            nres=0
            do ir=1,nresdat
              ires=ixr1(ir)
              if (ires .ne. iresprev) then
                nres=nres+1
                ixfres(nres)=ir
                if (nres .gt. 1) ixlres(nres-1)=ir-1
                iresprev=ires
              end if
            end do
            ixlres(nres)=nrespair
          end if
          if (ipairs .eq. 1) write (6,1022)
          iok=0
          do while (iok .eq. 0)
            ncolp=0
            nd=1
            do while (nd .gt. 0)
              call pickname('Index of choice (0 to finish the list)',38,
         -      title,ltitle,ncol,nd)
              if (nd .eq. 0) then
                if (ncolp .eq. 0) then
                  print *,'WARNING: Nothing selected'
                  call askyn('OK',2,1,-1,iok,0,0)
                  if (iok .eq. 1) return
                else
                  write (6,2001)
         -          (title(ixprint(ip))(1:ltitle(ixprint(ip))),ip=1,ncolp)
                  call askyn('OK',2,1,+1,iok,0,0)
                end if
              else
                ncolp=ncolp+1
                ixprint(ncolp)=nd
              end if
            end do
          end do
          maxresno=ixr1(nresdat)
          call zeroiti(iresix,0,maxresno)
          do ir=1,nres
            if (ipairs .eq. 0) iresix(ixr1(ir))=ir
            if (ipairs .eq. 1) iresix(ixr2(ir))=ir
          end do
          call zeroit(colsumm,ncolp)
          do ir=1,maxresno
            minmaxlab1(ir)=' '
          end do
          if (ipairs .eq. 0) then
            if (mark .eq. 1) then
              do ip=1,ncolp
                rmin(ip)=data(ixprint(ip),1)
                rmax(ip)=data(ixprint(ip),1)
                ixcolmin(ip)=1
                ixcolmax(ip)=1
              end do
              do ir=2,nres
                do ip=1,ncolp
                  r=data(ixprint(ip),ir)
                  if (r .gt. rmax(ip)) then
                    rmax(ip)=r
                    ixcolmax(ip)=ir
                  else if (r .lt. rmin(ip)) then
                    rmin(ip)=r
                    ixcolmin(ip)=ir
                  end if
                end do
              end do
            end if
            if (ierr .eq. 0 .or. ncolp .gt. 4)
         -    write (iout,1001)
         -     (title(ixprint(ip))(1:ltitle(ixprint(ip))),ip=1,ncolp)
            if (ierr .eq. 0) then
              do ir=1,nres
                if (mark .eq. 1) call labminmax(ir,ncolp,ixcolmin,
         -        ixcolmax,minmaxlab1,mxrsd)
                write (iout,1002) ixr1(ir),resnames(ixr1(ir))(1:3),
         -        (data(ixprint(ip),ir),minmaxlab1(ip),ip=1,ncolp)
                end do
            else
              if (ncolp .gt. 4) then
                do ir=1,nres
                  if (mark .eq. 1) call labminmax(ir,ncolp,ixcolmin,
         -          ixcolmax,minmaxlab1,mxrsd)
                  write (iout,1002) ixr1(ir),resnames(ixr1(ir))(1:3),
         -          (data(ixprint(ip),ir),minmaxlab1(ip),ip=1,ncolp)
                  write (iout,1007)ixr1(ir),(err(ixprint(ip),ir),ip=1,ncolp)
                end do
              else
                write (iout,1004)
         -        (title(ixprint(ip))(1:ltitle(ixprint(ip))),ip=1,ncolp)
                do ir=1,nres
                  if (mark .eq. 1) call labminmax(ir,ncolp,ixcolmin,
         -          ixcolmax,minmaxlab1,mxrsd)
                  write (iout,1003) ixr1(ir),resnames(ixr1(ir))(1:3),
         -          (data(ixprint(ip),ir),minmaxlab1(ip),
         -           err(ixprint(ip),ir),ip=1,ncolp)
                end do
              end if
            end if
            do ir=1,nres
              do ip=1,ncolp
                colsumm(ip)=colsumm(ip)+data(ixprint(ip),ir)
              end do
            end do
            if (ierr .eq. 0) then
              write (iout,1112) (colsumm(ip),ip=1,ncolp)
            else
              write (iout,1113) (colsumm(ip),ip=1,ncolp)
            end if
          else
            if (ncolp .gt. 1) then
              call getrange(ires1,ixr1(1),ires2,maxresno,incr,0,
         -      'reference residue number',24,maxresno,144)
              write (iout,1114) ires1,ires2
              call zeroit(colsum,ncolp)
              do ir=1,nres
                irp=ixfres(ir)
                if (ixr1(irp) .ge. ires1 .and.  ixr1(irp) .le. ires2) then
                  if (mark .eq. 1) then
                    do ip=1,ncolp
                      rmin(ip)=data(ixprint(ip),ir)
                      rmax(ip)=data(ixprint(ip),ir)
                      ixcolmin(ip)=1
                      ixcolmax(ip)=1
                    end do
                    if (mark .eq. 1) then
                      do irr=irp,ixlres(ir)
                        do ip=1,ncolp
                          r=data(ixprint(ip),irr)
                          if (r .gt. rmax(ip)) then
                            rmax(ip)=r
                            ixcolmax(ip)=irr-irp+1
                          else if (r .lt. rmin(ip)) then
                            rmin(ip)=r
                            ixcolmin(ip)=irr-irp+1
                          end if
                        end do
                      end do
                    end if
                  end if
                  ir0=irp-1
                  call zeroit(colsum,ncolp)
                  if (ierr .eq. 1) then
                    write (iout,1104)
         -            title(ixprint(1))(1:ltitle(ixprint(1))),
         -            (title(ixprint(ip))(1:ltitle(ixprint(ip))),ip=2,ncolp)
                    do irr=ixfres(ir),ixlres(ir)
                      if (mark .eq. 1) call labminmax(irr-irp+1,ncolp,
         -              ixcolmin,ixcolmax,minmaxlab1,mxrsd)
                      write (iout,1107)
         -              ixr1(irr),resnames(ixr1(irr))(1:3),
         -              ixr2(irr),resnames(ixr2(irr))(1:3),
         -              (data(ixprint(ip),irr),minmaxlab1(ip),
         -              err(ixprint(ip),irr),ip=1,ncolp)
                      do ip=1,ncolp
                        colsum(ip)=colsum(ip)+data(ixprint(ip),irr)
                      end do
                    end do
                    write (iout,1111) ' ---- SUM',(colsum(ip),ip=1,ncolp)
                    do ip=1,ncolp
                      colsumm(ip)=colsumm(ip)+colsum(ip)
                    end do
                  else
                    write (iout,1101)
         -            (title(ixprint(ip))(1:ltitle(ixprint(ip))),ip=1,ncolp)
                    do irr=ixfres(ir),ixlres(ir)
                      if (mark .eq. 1) call labminmax(irr-irp+1,ncolp,
         -              ixcolmin,ixcolmax,minmaxlab1,mxrsd)
                      write (iout,1102)
         -              ixr1(irr),resnames(ixr1(irr))(1:3),
         -              ixr2(irr),resnames(ixr2(irr))(1:3),
         -              (data(ixprint(ip),irr),minmaxlab1(ip),
         -              ip=1,ncolp)
                      do ip=1,ncolp
                        colsum(ip)=colsum(ip)+data(ixprint(ip),irr)
                      end do
                    end do
                    write (iout,1110) ' ---- SUM',(colsum(ip),ip=1,ncolp)
                    do ip=1,ncolp
                      colsumm(ip)=colsumm(ip)+colsum(ip)
                    end do
                  end if
                end if
              end do
              if (ierr .eq. 0) then
                write (iout,1110) ' SUMofSUM',(colsumm(i),i=1,ncolp)
              else
                write (iout,1111) ' SUMofSUM',(colsumm(i),i=1,ncolp)
              end if
            else
              write (iout,1009) title(ixprint(1))(1:ltitle(ixprint(1)))
    300       ifail12=1
              do while (ifail12 .eq. 1)
                write (6,1011) 'rows'
                call getrange(iresrow1,ixr1(1),iresrow2,maxresno,incr,0,
         -        'residue number',14,maxresno,0)
                call restoix(iresix,iresrow1,iresrow2,ix1,ix2,ifail12,
         -        maxresno)
                write (6,1011) 'columns'
                call getrange(irescol1,ixr1(1),irescol2,maxresno,incr,0,
         -        'residue number',14,maxresno,0)
                call restoix(iresix,iresrow1,iresrow2,ix1,ix2,ifail,
         -        maxresno)
                ifail12=ifail12+ifail
              end do
              if ((irescol1 .ge. iresrow1 .and. irescol1 .le. iresrow2) .or.
         -       (irescol2 .ge. iresrow1 .and. irescol2 .le. iresrow2)) then
                print *,'Residue ranges overlap'
                call askyn('Do you want to change the ranges',32,1,-1,ichng,
         -        0,0)
                if (ichng .eq. 1) go to 300
              end if
              do ir=1,nres
                if (ixr2(ir) .eq. iresrow1) iresrow1p=ir
                if (ixr2(ir) .eq. iresrow2) iresrow2p=ir
                if (ixr2(ir) .eq. irescol1) irescol1p=ir
                if (ixr2(ir) .eq. irescol2) irescol2p=ir
              end do
              if (irescol1p*irescol2p*iresrow1p*iresrow2 .eq. 0) then
                if (irescol1p .eq. 0) write (6,1015) irescol1
                if (irescol2p .eq. 0) write (6,1015) irescol2
                if (iresrow1p .eq. 0) write (6,1015) iresrow1
                if (iresrow2p .eq. 0) write (6,1015) iresrow2
                go to 300
              end if
              ntabcol=irescol2p-irescol1p+1
              ntabrow=iresrow2p-iresrow1p+1
              if (ntabcol .gt. ntabrow) then
               print *,'Number of columns is larger than the number of rows'
                call askyn('Do you want to change the ranges',32,1,1,ichng,
         -        0,0)
                if (ichng .eq. 1) go to 300
              end if
              do ir=1,ntabcol
                ixcol(ir)=irescol1p-1+ir
              end do
              do ir=1,ntabrow
                ixrow(ir)=iresrow1p-1+ir
              end do
    302       call zeroit(colsum,ntabcol)
              call zeroit(colsumm,ntabcol)
              call zeroiti(ixcolmin,0,ntabcol)
              call zeroiti(ixcolmax,0,ntabcol)
              call zeroit(tabrowsum,ntabrow)
              do irc=1,ntabcol
                colmin(irc)=999999.0
                colmax(irc)=-colmin(irc)
              end do
              do irr=1,ntabrow
                if0=ixfres(ixrow(irr))-1
                do irc=1,ntabcol
                  r=data(ixprint(1),if0+ixcol(irc))
                  colsum(irc)=colsum(irc)+r
                  tabrowsum(irr)=tabrowsum(irr)+r
                  if (r .lt. colmin(irc)) then
                    colmin(irc)=r
                    ixcolmin(irc)=irr
                  end if
                  if (r .gt. colmax(irc)) then
                    colmax(irc)=r
                    ixcolmax(irc)=irr
                  end if
                end do
              end do
              write (iout,1012) (ixr2(irc),resnames(ixr2(irc))(1:3),
         -      irc=irescol1p,irescol2p),0,'SUM'
              write (iout,1013) ('-----------',irc=1,ntabcol+1)
              do irr=1,ntabrow
                if (mark .eq. 1) call labminmax(irr,ntabcol,ixcolmin,
         -        ixcolmax,minmaxlab1,mxrsd)
                if0=ixfres(ixrow(irr))-1
                write (iout,1014)
         -        ixr2(ixrow(irr)),resnames(ixr2(ixrow(irr)))(1:3),
         -        '|',(data(ixprint(1),if0+ixcol(irc)),minmaxlab1(irc),
         -        irc=1,ntabcol),tabrowsum(irr)
                if (ierr .gt. 0) write (iout,1016)
         -        '|',(err(ixprint(1),if0+ixcol(irc)),irc=1,ntabcol)
              end do
              write (iout,1013) ('-----------',irc=1,ntabcol+1)
              write (iout,1014) 0,'SUM',':',(colsum(i),' ',i=1,ntabcol)
              call askyn('Do you want to tabulate an other energy term',44,
         -      1,-1,more,0,0)
              if (more .eq. 1) then
    303         call pickname('Index of choice (0 to finish the list)',38,
         -        title,ltitle,ncol,nd)
                if (nd .eq. 0) go to 303
                ixprint(1)=nd
                write (iout,*)
                write (iout,1009) title(ixprint(1))(1:ltitle(ixprint(1)))
                go to 302
              end if
            end if
          end if
          icorr=0
          call askyn(
         -  'Do you want the correlations between the properties read',56,
         -  1,-1,icorr,0,0)
          ncorrcalc=0
          if (icorr .gt. 0) then
            write (6,1020) outtabfile(1:linpstatfile),
         -    (title(i)(1:ltitle(i)),colsumm(i),i=1,ncolp)
            print *,'NOTE: correlation calculation is NOT limited to the ',
         -    'properties tabulated'
            itypedone=0
            ntypepairs=0
            do while (itypedone .eq. 0)
              ntypepairs=ntypepairs+1
              call pickname('First property to correlate (zero to exit)',42,
         -      title,ltitle,ncol,ic1)
              if (ic1 .eq. 0) then
                itypedone=1
              else
                call pickname('Second property to correlate',28,title,
         -        ltitle,ncol,ic2)
                s1=0.0
                s2=0.0
                s12=0.0
                ss1=0.0
                ss2=0.0
                if (ipairs .eq. 0) then
                  do i=1,nres
                    s12=s12+data(ic1,i)*data(ic2,i)
                    s1=s1+data(ic1,i)
                    s2=s2+data(ic2,i)
                    ss1=ss1+data(ic1,i)**2
                    ss2=ss2+data(ic2,i)**2
                  end do
                  corr=(s12-s1*s2/nres)/
         -          sqrt((ss1-s1**2/nres)*(ss2-s2**2/nres))
                  write (6,1005)
         -          title(ic1)(1:ltitle(ic1)),label(nc)(1:llabel(nc)),
         -          title(ic2)(1:ltitle(ic2)),label(nc)(1:llabel(nc)),
         -          corr
                  write (iout,1005)
         -          title(ic1)(1:ltitle(ic1)),label(nc)(1:llabel(nc)),
         -          title(ic2)(1:ltitle(ic2)),label(nc)(1:llabel(nc)),
         -          corr
                else
                  write (6,1021)
                  ir1=0
                  do while (ir1 .eq. 0)
                    call getint('Residue number of the selected residue',38,
         -            ixr1(1),1,maxresno,irr1,00)
                    ir1=iresix(irr1)
                    if (ir1 .eq. 0) print *,'Non-interacting residue'
                  end do
                  do i=ixfres(ir1),ixlres(ir1)
                    col1(i-ixfres(ir1)+1)=data(ic1,i)
                    col2(i-ixfres(ir1)+1)=data(ic2,i)
                  end do
                  nrows=ixlres(ir1)-ixfres(ir1)+1
                  do i=1,nrows
                    s12=s12+col1(i)*col2(i)
                    s1=s1+col1(i)
                    s2=s2+col2(i)
                    ss1=ss1+col1(i)**2
                    ss2=ss2+col2(i)**2
                  end do
                  if (s12 .ne. 0.0) then
                    corr=(s12-s1*s2/nrows)/
         -            sqrt((ss1-s1**2/nrows)*(ss2-s2**2/nrows))
                    write (6,1010)
         -            title(ic1)(1:ltitle(ic1)),label(nc)(1:llabel(nc)),
         -            title(ic2)(1:ltitle(ic2)),label(nc)(1:llabel(nc)),
         -            irr1,resnames(irr1)(1:3),corr
                    write (iout,1010)
         -            title(ic1)(1:ltitle(ic1)),label(nc)(1:llabel(nc)),
         -            title(ic2)(1:ltitle(ic2)),label(nc)(1:llabel(nc)),
         -            irr1,resnames(irr1)(1:3),corr
                  else
                    if (s1 .eq. 0.0) write(6,1018) title(ic1)(1:ltitle(ic1))
                    if (s2 .eq. 0.0) write(6,1018) title(ic2)(1:ltitle(ic2))
                  end if
                end if
              end if
            end do
          end if
          if (irepeat .eq. 0) then
            call askyn(
         -    'Do you want to tabulate a different data type or source',55,
         -    1,-1,more,0,0)
            if (more .gt. 0) then
              rewind inpt
              go to 100
            end if
          end if
          line(1:1)='*'
          do while (line(1:7) .ne. 'idecomp')
            read (inpt,1000,end=999) line
          end do
          if (line(1:9) .eq. 'idecomp =') read (line(10:11),*) idecomp
          if (idecomp .eq. 4) ipairs=1
          call blankout(atitle,1,80)
          read (inpt,1000,end=999) atitle
          call lastchar(atitle,latitle,80)
          call getskipcomma(inpt,line,len,llab,ifail)
          lsyslabel=llab
          syslabel(1:lsyslabel)=line(1:llab)
          call findname(syslabel,label,1,4,nc,lsyslabel)
          write (iout,*)
          write (iout,*) atitle(1:latitle)
          print *
          write (6,*) atitle(1:latitle)
          irepeat=1
          go to 100
    999   stop
    1000  format(a)
    1001  format(/,'  Residue ',a10,20(1x,a9))
    1002  format(i5,1x,a3,2x,20(f9.2,a1))
    1003  format(i5,1x,a3,1x,4(f9.2,a1,f8.2))
    1004  format(/,'  Residue ',4(a10,'    +/- '))
    1005  format(' Correlation between ',a,' (',a,') and ',a,' (',a,')=',
         -  f6.4)
    1007  format(i5,' +/-:',f9.2,19f10.2)
    1009  format(' Residue-residue contribution table for property ',a,/)
    1010  format(/,' Correlation between ',a,' (',a,') and ',a,' (',a,
         -  ') for residue ',i4,' (',a,')=',f6.4)
    1011  format(' Specify residue range for the table ',a)
    1012  format(13x,1000(i6,1x,a3))
    1013  format(13x,1000(a))
    1014  format(1x,i6,1x,a3,1x,a1,f10.2,a1,1000(f9.2,a1))
    1015  format(' ERROR: residue ',i6,' is not tabulated')
    1016  format(7x,'+/-: ',a1,1000(f10.2),1x)
    1017  format(' Data ',a,' tabulated: ',a)
    1018  format(' Sorry, can not corrwlate correlation since all ',a,
         - ' values are zero')
    1019  format(1x,a,' is not found in file ',a)
    1020  format(/,' Column sums of all properties in the file ',a,':',/,
         -  (1x,a20,'SUM:',f12.5))
    1021  format(' Input table has residue-residue energies',/,
         -  ' Correlations will be calculated for a the different energy ',
         -  'terms',/,' of a selected residue')
    1022  format(' NOTE: if you select only one property to tabulate then ',
         -  /,' a residue-residue matrix will be printed',/,' otherwise ',
         -  'separate residue-property matrices will be printed ',/,
         -  ' for each selected residue')
    1023  format(' The symbols +/- stand for ',a)
    1101  format(/,'  Residue - Residue ',a10,19(1x,a10))
    1102  format(i5,1x,a3,i6,1x,a3,20(f10.2,a1))
    1104  format(/,'  Residue - Residue ',20(a10,'    +/- '))
    1107  format(i5,1x,a3,i6,1x,a3,20(f9.2,a1,f8.2))
    1110  format(6x,a9,':  ',20f11.2)
    1111  format(5x,a9,':  ',20(f11.2,7x))
    1112  format('      SUM:',20f10.2)
    1113  format('      SUM:',20(f11.2,7x))
    1114  format(' Interaction tables will be generated  for residue-',
         -  'residue energies for residues in the range [',i5,',',i5,'] ',/,
         -  ' (interacting with all the rest)')
    2000  format(/,' Customized tabulation of Amber residue analysis',/,
         -  ' File analyzed: ',a)
    2001  format(' Column(s) to tabulate:',50(1x,a))
    2004  format(' The minimum and maximum ',
         -  'values in each column are marked with m and M, resp.')
          end
          subroutine read_amb_data_csv(data,err,ncol,ix1,ix2,resnames,
         -  nres,ipairs,ierr_mean,inpt,mxcol,mxrsd,mxrec)
          dimension  data(mxcol,mxrec),err(mxcol,mxrec),ix1(mxrec),
         -  ix2(mxrec)
          character*8 resnames(mxrsd)
          character*3 rn1,rn2
          character*1000 line
          len=1000
          nres=0
          lc=len
          do while (lc .gt. 1)
            call blankout(line,1,len)
            read (inpt,1000,end=999) line
            call lastchar(line,lc,len)
            if (lc .gt. 1) then
              nres=nres+1
              if (nres .gt. mxrec) then
                write (6,1001) mxrec
                stop
              end if
              ic=1
              rn1=line(ic:ic+2)
              call findnextchar(',',line,ic,len)
              read (line(ic-4:ic-1),*) ix1(nres)
              ic=ic+1
              ic1=ic
              if (ipairs .eq. 0) then
                call findnextchar(',',line,ic,len)
                call blankout(resnames(ix1(nres)),1,8)
                resnames(ix1(nres))(1:3)=rn1
              else
                rn2=line(ic:ic+2)
                call findnextchar(',',line,ic,len)
                read (line(ic-4:ic-1),*) ix2(nres)
                call blankout(resnames(ix1(nres)),1,8)
                call blankout(resnames(ix2(nres)),1,8)
                resnames(ix1(nres))(1:3)=rn1
                resnames(ix2(nres))(1:3)=rn2
              end if
              ic=ic+1
              do nc=1,ncol
                call getnextcsv(line,i,data(nc,nres),2,ic,len)
                call getnextcsv(line,i,sd,2,ic,len)
                call getnextcsv(line,i,err_mean,2,ic,len)
                if (ierr_mean .eq. 1) err(nc,nres)=sd
                if (ierr_mean .eq. 2) err(nc,nres)=err_mean
              end do
            end if
          end do
    999   return
          stop
    1000  format(a)
    1001  format(' ERROR: Number of residue-residue records exceeds ',
         -  'the limit (',i9,')',/,8x,'Redimension with larger MAXREC (and',
         -  ' possibly, larger MAXPHI')
          end
          subroutine checklabel(line,label,llabel,inpt)
          character*1000 line
          character*10 label,labelread
          call blankout(line,1,80)
          read (inpt,1000) line
          call lastchar(line,ilc,80)
          llabelread=ilc-4
          labelread(1:llabelread)=line(5:ilc)
          if (labelread(1:llabelread) .ne. label(1:llabel)) then
            print *,'ERROR: incorrect data label:',labelread(1:llabelread),
         -    ' (instead of ',label(1:llabel),')'
            stop
          end if
          return
    1000  format(a)
          end
          subroutine restoix(iresix,ir1,ir2,ix1,ix2,ifail,maxres)
          dimension iresix(maxres)
          ifail=0
          ix1=iresix(ir1)
          if (ix1 .eq. 0) then
            ir=ir1
            do while (iresix(ir) .eq. 0 .and. ir .lt. ir2)
              ir=ir+1
            end do
            if (iresix(ir) .gt. 0) then
              ix1=iresix(ir)
            else
              print *,'Residue range [',ir1,',',ir2,'] has no data'
              ifail=1
            end if
          end if
          ix2=iresix(ir2)
          if (ix2 .eq. 0) then
            ir=ir2
            do while (iresix(ir) .eq. 0 .and. ir .gt. ir1)
              ir=ir-1
            end do
            ix2=iresix(ir)
            if (iresix(ir) .eq. 0)print *,'PROGRAM ERROR in restoix'
          end if
          return
          end
          subroutine getskipcomma(inpt,line,len,llab,ifail)
          character*1000 line
          ifail=0
          lc=1
          do while (lc .le. 1)
            call blankout(line,1,len)
            read (inpt,1000,end=999) line
            call lastchar(line,lc,len)
          end do
          ndel=0
          do ic=1,lc
            if (line(ic:ic) .eq. ',' .or. line(ic:ic) .eq. ':') then
              ndel=ndel+1
            else
              line(ic-ndel:ic-ndel)=line(ic:ic)
            end if
          end do
          llab=lc-ndel
          return
    1000  format(a)
    999   ifail=1
          end
          subroutine labminmax(ir,ncol,ixcolmin,ixcolmax,minmaxlab1,mxrsd)
          dimension ixcolmin(mxrsd),ixcolmax(mxrsd)
          character*1 minmaxlab1(mxrsd)
          do ic=1,ncol
            minmaxlab1(ic)=' '
            if (ixcolmax(ic) .eq. ir) then
              minmaxlab1(ic)='M'
            end if
            if (ixcolmin(ic) .eq. ir) then
              minmaxlab1(ic)='m'
            end if
            if (ixcolmin(ic) .eq. ixcolmax(ic) .and. ixcolmax(ic) .eq. ir)
         -    minmaxlab1(ic)='c'
          end do
          return
          end
          subroutine getnextint(line,int,ic,len)
          character*(*) line
          call nextchar(line,ic,len)
          ic1=ic
          call nextblank(line,ic,len)
          ic2=ic
          read (line(ic1:ic2-1),*,err=999) int
          return
    999   print *,'Invalid integer:',line(ic1:ic2-1)
          stop
          end
          subroutine getnextreal(line,r,ic,len)
          character*(*) line
          call nextchar(line,ic,len)
          ic1=ic
          call nextblank(line,ic,len)
          ic2=ic
          read (line(ic1:ic2-1),*,err=999) r
          return
    999   print *,'Invalid real:',line(ic1:ic2-1)
          stop
          end
          subroutine getnextcsv(line,int,real,iorr,ic,len)
          character*(*) line
          if (line(ic:ic) .eq. ',') ic=ic+1
          ic1=ic
          ic2=ic1
          real=0.0
          int=0
          call findnextchar(',',line,ic,len)
          if (line(ic:ic).eq. ',') then
            ic2=ic-1
            if (iorr .eq. 0) then
              read (line(ic1:ic2),*,end=999,err=999) int
            else
              read (line(ic1:ic2),*,end=999,err=999) real
            end if
          else
            ic=ic1
            call nextblank(line,ic,len)
            ic2=ic-1
            if (iorr .eq. 0) then
              read (line(ic1:ic2),*,end=999,err=999) int
            else
              read (line(ic1:ic2),*,end=999,err=999) real
            end if
          end if
          return
    999   print *,'Invalid number:',line(ic1:ic2),'| ic1,ic2=',ic1,ic2
          stop
          end
          subroutine findindex(lab,llab,q,lq,list,llist,nlist,ix,maxlablen,
         -  ihelp)
          character*(*) q,lab,list(nlist)
          dimension llist(nlist)
          ix=0
    110   call getname(lab,llab,q(1:lq),lq,maxlablen,'',0,0,ihelp,0)
          if (llab .le. 1) return
          do i=1,nlist
            if (lab(1:llab) .eq. list(i)(1:llist(i))) ix=i
          end do
          if (ix .eq. 0) then
            print *,'No match found for ',lab(1:llab)
            go to 110
          end if
          return
          end
          subroutine cellpart(c,ian,itemp1,na1,na,padding,spacing,corner,
         -  ecell,edge,xyzmin,xyzmax,vtot,nxyz,ixyz,icellno,itemp2,index,
         -  ifirst,ilast,ntotcell,levout,iout,maxrec)
          dimension c(3,na),ian(na),itemp1(maxrec),corner(3),cent(3),
         -  edge(3),ecell(3),xyzmin(3),xyzmax(3),nxyz(3),ixyz(3),
         -  icellno(maxrec),itemp2(maxrec),index(maxrec),ifirst(maxrec),
         -  ilast(maxrec)
          call extension(c,ian,0,na1,na,xyzmin,xyzmax,cent,0,0,v)
          do k=1,3
            edge(k)=xyzmax(k)-xyzmin(k)+2.0*padding
            corner(k)=xyzmin(k)-padding
            nxyz(k)=int(edge(k)/spacing)
            if (nxyz(k) .eq. 0 .or. edge(k)-nxyz(k)*ecell(k) .ge. 0.5)
         -    nxyz(k)=nxyz(k)+1
            ecell(k)=(edge(k)+0.0001)/nxyz(k)
          end do
          ntotcell=nxyz(1)*nxyz(2)*nxyz(3)
          if (ntotcell .gt. maxrec) then
            write (6,7000) ntotcell,maxrec,ntotcell
            stop
          end if
          vtot=edge(1)*edge(2)*edge(3)
          nha=0
          do ia=na1,na
            if (ian(ia) .gt. 1) then
              do k=1,3
                ixyz(k)=(c(k,ia)-corner(k))/ecell(k)
              end do
              nha=nha+1
              icellno(nha)=1+ixyz(1)+nxyz(1)*ixyz(2)+nxyz(1)*nxyz(2)*ixyz(3)
              index(nha)=ia
              if (levout .gt. 3) write (iout,7001) ia,nha,icellno(nha),ixyz
            end if
          end do
          if (levout .gt. 2) write (iout,*) 'na,nha=',na,nha
          call mrgsrti(6,index,icellno,nha,ifirst,ilast,itemp1,itemp2,
         -  maxrec)
          if (levout .gt. 3)
         -  write (iout,7002) (ia,icellno(ia),index(ia),ia=1,nha)
          call zeroiti(ifirst,0,ntotcell)
          ia=1
          icell=icellno(ia)
          ifirst(icell)=ia
          do while (ia .lt. nha)
            ia=ia+1
            if (icellno(ia) .gt. icell) then
              ilast(icell)=ia-1
              icell=icellno(ia)
              ifirst(icell)=ia
            end if
          end do
          ilast(icell)=nha
          return
    7000  format(' ERROR: the number of solute cells (',i8,') exceeds the',
         -  ' maximum number',/,' of records (',i8,')',/,' Recompile with ',
         -  'the parameter MAXREC > ',i8,' or increase the grid spacing')
    7001  format(i5,' nha=',i4, ' icellno=',f8.1,' ixyz=',3i6)
    7002  format(i5,' icellno=',f8.1,' index=',i6)
          end
          subroutine dialps(iout,labdial,llabdial,title,ltitle,remark,
         -  lremark,nrdiv,ndials,ndprow,nframesaved,pi,ipspage,npspageinc,
         -  nfravgd,idincr,noopen,noclose,iconndial,ioutpr,mappdf,ipdfgrd)
          character*(*) labdial(ndials)
          character*80 title
          character*(*) remark
          dimension llabdial(ndials)
          parameter (MAXFRAMES=50000,MAXCOPY=600)
          common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
         -  increment,increment2,res(2,MAXFRAMES,MAXCOPY),
         -  x0(MAXCOPY),y0(MAXCOPY),nxselres,ixselres(MAXCOPY)
          character*200 trajnam,trajnam2
          common /trajname/ trajnam,trajnam2,ltrajnam,ltrajnam2,ifirsttraj,
         -  ifirsttraj2,ilasttraj,ilasttraj2,incrementtraj,incrementtraj2
          if (ndials .eq. 0) then
            print *,'ERROR: no torsions were selected for dial plots'
            return
          end if
          print *,'Drawing ',ndials,' dials for ',nframesaved,' frames'
          nlt=min0(80,ltrajnam)
          xm=550.0
          ym=650.0
          nddone=0
          if (ndprow .eq. 0) ndprow=xm/sqrt(xm*ym/float(ndials))+1
          edge=0.95*xm/ndprow
          maxrows=(ym-50.0)/(edge*1.2)
          maxrows=max0(1,maxrows)
          npages=(ndials-1)/(ndprow*maxrows)+1+npspageinc
          if (nfravgd .eq. 0)
         -  call getint('Number of snapshots to average in the dials',43,
         -    1,1,nframe,nfravgd,28)
          if (noopen .eq. 0) then
            call openps(iout,xm,ym,title(1:ltitle),ltitle,remark,lremark,
         -    trajnam,nlt,trajnam,0,npages,ipspage)
          else
            call plothead(iout,xm,ym,title,ltitle,remark,lremark,trajnam,
         -    nlt,trajnam,0)
          end if
          ym=ym-100
          if (nfravgd .gt. 1) then
            write (iout,1000) xm*0.04,ym*0.95+100,nfravgd
            ymfac=0.85
          else
            ymfac=0.88
          end if
          npage=0
          do while (nddone .lt. ndials)
            nddo=min0(ndials-nddone,ndprow*maxrows)
            call partwindow(xm,ym,ymfac,nddo,edge,x0,y0,nddone,ndprow,nrows,
         -    MAXCOPY)
            ipspage=ipspage+1
            write (iout,1003) ipspage
            ifirst=1
            ilast=0
            do id=nddone+1,nddone+nddo
              if (id .eq. nddone+nddo .or. mod(id,ndprow) .eq. 0) ilast=1
              call drawdial(iout,edge,nframesaved,nfravgd,id,labdial(id),
         -      llabdial(id),nrdiv,ndprow,ifirst,ilast,idincr,
         -      iconndial,ioutpr,mappdf,ipdfgrd,pi)
              ifirst=0
            end do
            nddone=nddone+nddo
            write (iout,*) 'showpage'
            if (nddone .lt. ndials) write (iout,*) '25 25 translate'
          end do
          if (noclose .eq. 0) close (iout)
          return
    1000  format(2f6.1,' m',/,
         -  '(Plots were averaged over',i4,' frames) show')
    1003  format('%%Page: 1 ',i4)
          end
          subroutine partwindow(xm,ym,ymfac,nd,edge,x0,y0,ndincr,ndprow,
         -  nrows,maxdials)
          dimension x0(maxdials),y0(maxdials)
          y00=ym*ymfac
          nleft=nd
          ndone=0
          nrows=0
          do while (nleft .gt. 0)
            ndo=min0(nleft,ndprow)
            x00=(xm-ndo*edge)/2.0
            do ir=1,ndo
              ndone=ndone+1
              x0(ndincr+ndone)=x00+(ir-1)*edge
              y0(ndincr+ndone)=y00
            end do
            nrows=nrows+1
            nleft=nleft-ndo
            y00=y00-edge*1.2
          end do
          return
          end
          subroutine drawdial(iout,edge,n,incr,idial,lab,llab,nrdiv,ndprow,
         -  ifirst,ilast,incrid,iconndial,ioutpr,mappdf,ipdfgrd,pi)
          character*(*) lab
          parameter (MAXFRAMES=50000,MAXCOPY=600)
          common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
         -  increment,increment2,res(2,MAXFRAMES,MAXCOPY),
         -  x0(MAXCOPY),y0(MAXCOPY),nxselres,ixselres(MAXCOPY)
          real*8 ddd,cosav,sinav
          dimension npdf(360),pdf(360)
          data riprev /0.0/,angprev /0.0/
          pi2=2.0*pi
          rdtodg=180.0/pi
          lyshift= 95
          cx=x0(idial)+edge*0.50
          cy=y0(idial)-edge*0.50+lyshift
          if (mappdf .eq. 0) then
            r=0.45*edge
            r0=0.04*edge
            r1=0.41*edge
          else
            r=0.40*edge
            r0=0.03*edge
            r1=0.37*edge
          end if
          write (iout,*) 'np'
          if (ndprow .lt. 3) then
            lfont=14
            lfshift=5
          else if (ndprow .lt. 5) then
            lfont=10
            lfshift=0
          else
            lfont=8
            lfshift=0
          end if
          write (iout,1005) 'Symbol',lfont
          if (ndprow .lt. 4 .or. ilast .eq. 1) then
            write (iout,1000) cx+r+2.0,cy-2.0
            call psshow(iout,'0',1)
          end if
          write (iout,1000) cx-5.0,cy+r+3.0+lfshift
          call psshow(iout,'p/2',3)
          if (ndprow .lt. 4 .or. ifirst .eq. 1) then
            write (iout,1000) cx-r-7.0-lfshift,cy-2.0
            call psshow(iout,'p',1)
          end if
          write (iout,1000) cx-8.0,cy-r-10.0-lfshift
          call psshow(iout,'3p/2',4)
          lfont=12
          if (ndprow .gt. 4) lfont=8
          write (iout,1005) 'Helvetica',lfont
          write (iout,1000) x0(idial)+5.0,y0(idial)+lyshift
          call psshow(iout,lab,llab)
          write (iout,*) 'sk'
          write (iout,*) 'np'
          write (iout,1000) cx+r,cy
          write (iout,1003) cx,cy,r,0.0,360.0
          if (nrdiv .gt. 1) then
            write (iout,*) 'sk'
            write (iout,*) '[2] 0 setdash'
            do ir=1,nrdiv-1
              write (iout,1003) cx,cy,r0+r1*float(ir)/float(nrdiv),
         -      0.0,360.0
            end do
          end if
          write (iout,*) 'sk'
          write (iout,*) '[] 0 setdash'
          write (iout,*) 'np'
          do ia=1,36
            ang=float(ia*10)/rdtodg
            rx=sin(ang)*r
            ry=cos(ang)*r
            write (iout,1000) cx+rx,cy+ry
            if (mod(ia,3) .eq. 0) then
              write (iout,1001) cx+0.94*rx,cy+0.94*ry
            else
              write (iout,1001) cx+0.97*rx,cy+0.97*ry
            end if
          end do
          write (iout,1000) cx-r,cy
          write (iout,1001) cx+r,cy
          write (iout,*) 'sk'
          write (iout,*) 'np'
          write (iout,1000) cx,cy+r
          write (iout,1001) cx,cy-r
          write (iout,*) 'sk'
          write (iout,*) '0.6 0.6 0.6 setrgbcolor'
          write (iout,*) 'np'
          write (iout,1003) cx,cy,r0,0.0,360.0
          write (iout,*) 'fill'
          write (iout,*) 'sk'
          call rgbcolor(iout,-4)
          write (iout,1004) 2
          write (iout,*) 'np'
          write (iout,1000) cx,cy
          write (iout,1001) cx+r0*res(1,1,incrid+idial),
         -  cy+r0*res(2,1,incrid+idial)
          write (iout,*) 'sk'
          anggrid=5.0
          cosav=0.d0
          sinav=0.d0
          angmin=pi2
          angmax=0.0
          incrloop=max0(1,incr)
          rdot=0.5
          if (n .lt. 100) rdot=1.0
          if (n .lt. 10) rdot=1.5
          call rgbcolor(iout,-6)
          do i=1,n,incrloop
            if (incrloop .eq. 1) then
              ang=dacoscheck(ddd,res(1,i,incrid+idial),0,ioutpr,'DRAWDIAL')
              if (res(2,i,incrid+idial) .lt. 0.0) ang=pi2-ang
              if (ang. gt. angmax) angmax=ang
              if (ang. lt. angmin) angmin=ang
            else
              cosavinc=0.0
              sinavinc=0.0
              do j=i,i+min0(n,incrloop-1)
                cosavinc=cosavinc+res(1,j,incrid+idial)
                sinavinc=sinavinc+res(2,j,incrid+idial)
                ang=dacoscheck(ddd,res(1,i,incrid+idial),0,ioutpr,
         -        'DRAWDIAL')
                if (res(2,i,incrid+idial) .lt. 0.0) ang=pi2-ang
                if (ang. gt. angmax) angmax=ang
                if (ang. lt. angmin) angmin=ang
              end do
              cosavinc=cosavinc/incrloop
              sinavinc=sinavinc/incrloop
              sqsum=sqrt(cosavinc**2+sinavinc**2)
              cosavinc=cosavinc/sqsum
              sinavinc=sinavinc/sqsum
              ang=dacoscheck(ddd,cosavinc,0,iout,'DRAWDIAL')
              if (sinavinc .lt. 0.0) ang=-ang
            end if
            ri=r0+r1*float(i)/float(n)
            if (iconndial .eq. 1) then
              if (i .eq. 1) then
                write (iout,1004) 1
                write (iout,*) 'np'
                write (iout,1000) cx+cos(ang)*r0,cy+sin(ang)*r0
              else
                angdev=(ang-angprev)
                if (angdev .gt. 0.0) then
                  angdevrev=angdev-2.0*pi
                else
                  angdevrev=angdev+2.0*pi
                end if
                if (abs(angdevrev) .lt. abs(angdev)) angdev=angdevrev
                if (abs(angdev)*ri .gt. anggrid) then
                  nd=abs(angdev)*ri/anggrid
                  if (i .gt. n/2) nd=2*nd
                  do id=1,nd
                    angi=angprev+angdev*float(id)/float(nd)
                    rii=riprev+(ri-riprev)*float(id)/float(nd)
                    write (iout,1001) cx+cos(angi)*rii,cy+sin(angi)*rii
                  end do
                else
                  write (iout,1001) cx+cos(ang)*ri,cy+sin(ang)*ri
                end if
              end if
            else
              ri=r0+r1*float(i)/float(n)
              write (iout,1003) cx+cos(ang)*ri,cy+sin(ang)*ri,rdot,0,360.0
              write (iout,*) 'sk'
            end if
            riprev=ri
            angprev=ang
          end do
          write (iout,*) 'sk'
          do i=1,n
            cosav=cosav+res(1,i,incrid+idial)
            sinav=sinav+res(2,i,incrid+idial)
          end do
          cv=1.d0-dsqrt(cosav**2+sinav**2)/dfloat(n)
          lthick=2
          if (ndprow .gt. 6) lthick=1
          if (n .gt. 0) then
            call rgbcolor(iout,-1)
            write (iout,1004) lthick
            cosav=cosav/n
            sinav=sinav/n
            sqsum=sqrt(cosav**2+sinav**2)
            cosav=cosav/sqsum
            sinav=sinav/sqsum
            write (iout,*) 'np'
            write (iout,1000) cx+cosav*r0,cy+sinav*r0
            write (iout,1001) cx+cosav*(r0+r1),cy+sinav*(r0+r1)
            write (iout,*) 'sk'
            call rgbcolor(iout,-6)
            write (iout,1004) 2*lthick
            write (iout,*) 'np'
            rx=r*res(1,n,incrid+idial)
            ry=r*res(2,n,incrid+idial)
            write (iout,1000) cx+rx,cy+ry
            write (iout,1001) cx+1.1*rx,cy+1.1*ry
            write (iout,*) 'sk'
          end if
          call rgbcolor(iout,-9)
          write (iout,1004) 4
          write (iout,*) 'np'
          write (iout,1000) cx,cy+r0
          write (iout,1001) cx,cy+r0+r1*cv
          write (iout,*) 'sk'
          call rgbcolor(iout,9)
          write (iout,1004) 1
          if (ioutpr .gt. 0) then
            angmaxd=angmax*rdtodg
            angmind=angmin*rdtodg
            grd=ipdfgrd
            write (ioutpr,1006) lab(1:llab),angmind,angmaxd
            call zeroiti(npdf,0,360)
            call zeroit(pdf,360)
            do i=1,n
              ang=dacoscheck(ddd,res(1,i,incrid+idial),0,ioutpr,'DRAWDIAL')
              if (res(2,i,incrid+idial) .lt. 0.0) ang=pi2-ang
              ang=ang*rdtodg
              ix=ang/grd+1
              npdf(ix)=npdf(ix)+1
            end do
            ixmin=angmind/grd+1
            ixmax=angmaxd/grd+1
            ixmax=min0(ixmax,360/ipdfgrd)
            pdfmax=0.0
            do ix=ixmin,ixmax
              pdf(ix)=float(npdf(ix))/float(n)
              write (ioutpr,1007) ix,ix*grd-grd/2.0,pdf(ix)
              if (pdfmax .lt. pdf(ix)) pdfmax=pdf(ix)
            end do
            if (pdfmax .gt. 0.0 .and. mappdf .gt. 0) then
              do ix=ixmin,ixmax
                pdf(ix)=r0+r1+(pdf(ix)/pdfmax)*r1/2.75
              end do
              write (iout,1008) 'newpath'
              angmin2=angmin+(grd/2.0)/rdtodg
              write (iout,1000) cx+pdf(ixmin)*cos(angmin2),
         -      cy+pdf(ixmin)*sin(angmin2)
              do ix=ixmin+1,ixmax
                ang=(ix*grd-grd/2.0)/rdtodg
                write (iout,1001) cx+pdf(ix)*cos(ang),cy+pdf(ix)*sin(ang)
              end do
              if (ixmax .eq. 360/ipdfgrd .and. pdf(1) .gt. 0.0) then
                ang=(grd/2.0)/rdtodg
                write (iout,1001) cx+pdf(1)*cos(ang),cy+pdf(1)*sin(ang)
              end if
              write (iout,1008) 'stroke'
            end if
          end if
          return
    1000  format(2f12.5,' m')
    1001  format(2f12.5,' l')
    1003  format(5f12.4,' arc')
    1004  format(i5,' setlinewidth')
    1005  format('/',a,' findfont',/,i2,' scalefont',/,'setfont')
    1006  format(/,' Distribution of ',a,' in the range [',f7.2,',',f7.2,
         -  '] (deg)')
    1007  format(i4,' ang=',f7.2,' P=',f7.5)
    1008  format(a)
          end
          subroutine psshow(iout,string,len)
          character*(*) string
          character*200 clean
          inc=0
          do ic=1,len
            if (string(ic:ic) .eq. '(') then
              clean(ic+inc:ic+inc)='\\'
              clean(ic+inc+1:ic+inc+1)='('
              inc=inc+1
            else if (string(ic:ic) .eq. ')') then
              clean(ic+inc:ic+inc)='\\'
              clean(ic+inc+1:ic+inc+1)=')'
              inc=inc+1
            else
              clean(ic+inc:ic+inc)=string(ic:ic)
            end if
          end do
          write (iout,1000) clean(1:len+inc)
          return
    1000  format('(',a,' ) show')
          end
          subroutine openps(iout,xm,ym,title,ltitle,title1,ltitle1,
         -  filename,lfilename,filename2,lfilename2,npspages,ipspage)
          character*(*) title,title1,filename,filename2
          ixm=xm+25.0
          iym=ym+25.0
          call psheader(iout,title,ltitle,-10,-10,ixm,iym,npspages,ipspage)
          write (iout,2000)
          call plothead(iout,xm,ym,title,ltitle,title1,ltitle1,
         -  filename,lfilename,filename2,lfilename2)
          return
    2000  format('/m { moveto } def',/,'/l { lineto } def',/,
         -  '/np { newpath } def',/, '/sk { stroke } def',/,
         -  '/f { fill } def',/,'/lw { setlinewidth } def',/,
         -  '/Helvetica findfont',/,'12 scalefont',/,'setfont',/,
         -  '25 25 translate')
          end
          subroutine psheader(iout,title,ltitle,ix0,iy0,ixm,iym,npspages,
         -  ipspage)
          character*(*) title
          character*12 today
          common /today_date/ ltoday,today
          if (npspages .gt. 0) then
            write (iout,1000) title(1:ltitle)
            write (iout,1030) ix0,iy0,ixm,iym
            if (ltoday .gt. 0) write (iout,1001) today(1:ltoday)
            write (iout,1040)
            write (iout,2000)
            ipspage=0
          end if
          return
    1000  format('%!PS-Adobe-2.0 ',/,'%%Title: ',a,/,
         -  '%%Creator: SIMULAID')
    1001  format('%%CreationDate: ',a)
    1030  format('%%BoundingBox:',4i8)
    1040  format('%%EndComments')
    2000  format('/m { moveto } def',/,'/l { lineto } def',/,
         -  '/np { newpath } def',/, '/sk { stroke } def',/,
         -  '/f { fill } def',/,'/lw { setlinewidth } def',/,
         -  '/r { rlineto } def')
          end
          subroutine plothead(iout,xm,ym,title,ltitle,title1,ltitle1,
         -  filename,lfilename,filename2,lfilename2)
          character*(*) title,title1,filename,filename2
          yinc=0.0
          if (lfilename2 .gt. 0) then
            write (iout,1000) xm*0.04,ym*0.91+yinc
            write (iout,1003) 'Second file',filename2(1:lfilename2)
            yinc=yinc+ym*0.02
          end if
          if (lfilename .gt. 0) then
            write (iout,1000) xm*0.04,ym*0.91+yinc
            write (iout,1003) 'File',filename(1:lfilename)
            yinc=yinc+ym*0.02
          end if
          if (ltitle1 .gt. 0) then
            write (iout,1000) xm*0.04,ym*0.91+yinc
            call psshow(iout,title1,ltitle1)
            yinc=yinc+ym*0.02
          end if
          write (iout,1000) xm*0.04,ym*0.91+yinc
          itw=0
          if (ltitle .ge. 4) then
            if (title(1:4) .eq. '@#$%') then
              call psshow(iout,'Simulaid-generated plot',23)
              itw=1
            end if
          end if
          if (itw .eq. 0 .and. ltitle .ge. 76) then
            call lastchar(title,lct,ltitle)
            call psshow(iout,title,lct)
          end if
          return
    1000  format(2f12.5,' m')
    1003  format('(',a,' analyzed: ',a,' ) show')
          end
          subroutine hbbridge(nanchor,ianchor,indexa,ianchor2,iselfanc,
         -  lpath,nbridgetype,ibridgetype,maxbridgemem,n,nhbneig,ineig,list,
         -  nnblist,iparent,ixres,resnames,brslv,nabr,nrescol,nmc,ifail,
         -  listbridge,iout,maxng,maxbridgelen,maxbridgetype,
         -  minbridgelenprint,maxrsd,maxrec)
          character*8 resnames
          dimension ianchor(nanchor),indexa(n),nhbneig(n),ineig(maxng,n),
         -  lpath(maxbridgetype,maxbridgelen,nanchor),
         -  nbridgetype(maxbridgelen,nanchor),
         -  ibridgetype(maxbridgetype,maxbridgelen,nanchor),resnames(maxrsd)
          dimension list(maxrec),nnblist(maxrec),iparent(maxrec),
         -  ixres(maxrec),ip(10),iflist(10),illist(10)
          character*8 brslv
          character*80 line
          ifail=0
          do iia=1,nanchor
            do ia=1,ixres(n)
              iparent(ia)=-1
            end do
            iat=ianchor(iia)
            if (indexa(iat) .eq. 0) then
              print *,'PROGRAM ERROR: ',iia,'th anchorlist=',iat,
         -      ' is not marked as anchor'
              stop
            end if
            list(1)=iat
            ll=1
            ixp=ixres(iat)
            ll1=1
            iflist(1)=ll1
            illist(1)=ll
            do it=1,maxbridgemem+1
              nn=0
              do il=ll1,ll
                ia=list(il)
                if (ia .ne. iat) ixp=ixres(ia)
                if (ixp .le. 0) then
                  write (iout,1005) iat,ia,it,il,ixp
                  write (6,1005) iat,ia,it,il,ixp
                  stop
                end if
                do in=1,nhbneig(ia)
                  ian=ineig(maxng-in+1,ia)
                  do j=1,illist(min0(2,it))
                    if (list(j) .eq. ian) go to 100
                  end do
                  do itt=3,it
                    call findixsort(list,iflist(itt),illist(itt),ian,
         -            ixian,itryl)
                    if (ixian .gt. 0) go to 100
                  end do
                  call findixsort(nnblist,1,nn,ian,ixian,itrynnb)
                  if (ixian .gt. 0) go to 100
                  if (resnames(ixres(ian))(1:nrescol) .ne.
         -            brslv(1:nrescol)) then
                    idoit=1
                    if (ianchor2 .eq. 1) then
                      if (indexa(ian) .lt. 1) idoit=0
                    else
                      if (iselfanc .eq. 0 .and. indexa(ian) .eq. 1) idoit=0
                    end if
                    if (idoit .eq. 1 .and.
         -              (indexa(ian) .lt. 1 .or. ian .gt. iat)) then
                      if (nbridgetype(it,iia) .eq. 0) then
                        nbridgetype(it,iia)=1
                        ibridgetype(1,it,iia)=ian
                        iend=1
                        go to 300
                      end if
                      call findixsort(ibridgetype(1,it,iia),1,
         -               nbridgetype(it,iia),ian,ixian,itry)
                      if (ixian .gt. 0) then
                        iend=ixian
                        go to 300
                      end if
                      if (nbridgetype(it,iia) .lt. maxbridgetype) then
                        ixian=itry
                        do ib=nbridgetype(it,iia),ixian,-1
                          ibridgetype(ib+1,it,iia)=ibridgetype(ib,it,iia)
                          lpath(ib+1,it,iia)=lpath(ib,it,iia)
                        end do
                        nbridgetype(it,iia)=nbridgetype(it,iia)+1
                        ibridgetype(ixian,it,iia)=ian
                        iend=ixian
                      else
                        write (6,1006) maxbridgetype
                        write (iout,1006) maxbridgetype
                        if (nmc .gt. 0) then
                          write (6,1008) nmc
                          write (iout,1008) nmc
                          ifail=1
                          return
                        else
                          percdone=100.0*float(iia)/float(nanchor)
                          write (6,1009) percdone
                          write (iout,1009) percdone
                          stop
                        end if
                      end if
    300               lpath(iend,it,iia)=lpath(iend,it,iia)+1
                      if (listbridge .gt. 0) then
                        ixptb=ixp
                        ip(it)=ixptb
                        iit=it
                        do while (iit .gt. 2)
                          iit=iit-1
                          ixptb=iparent(ixptb)
                          ip(iit)=ixptb
                          if (ixp .eq. -1) then
                            write (6,1007) iat,it
                            write (iout,1007) iat,it
                            stop
                          end if
                        end do
                        if (nmc .eq. 0) then
                          ic0=0
                        else
                          ic0=10
                          write (line(1:10),1004) nmc
                        end if
                        write (line(ic0+1:ic0+18),1000) iat
                        ic=ic0+18
                        if (it .gt. minbridgelenprint) then
                          do iit=2,it
                            write (line(ic+1:ic+17),1001) ip(iit)
                            ic=ic+17
                            if (iit .eq. 2 .and. iit .lt. it) then
                              write (iout,1003) line(1:ic)
                              ic=ic0+18
                              call blankout(line,1,ic)
                            end if
                          end do
                        end if
                        write (line(ic+1:ic+15),1002)
         -                ibridgetype(iend,it,iia)
                        write (iout,1003) line(1:ic+15)
                      end if
                    end if
                  else
                    isolv=ixres(ian)
                    iparent(isolv)=ixp
                    iaa=ian
                    do while (iaa .gt. 1 .and. ixres(iaa) .eq. ixres(ian))
                      iaa=iaa-1
                    end do
                    if (iaa .eq. 1 .and. ixres(iaa) .eq. ixres(ian))
         -            iaa=iaa-1
                    ifr=iaa+1
                    iaa=ian
                    do while (iaa .lt. n .and. ixres(iaa) .eq. ixres(ian))
                      iaa=iaa+1
                    end do
                    if (iaa .eq. n .and. ixres(iaa) .eq. ixres(ian))
         -            iaa=iaa+1
                    ilr=iaa-1
                    if (ilr-ifr+1 .ne. nabr) then
                      write (6,1010) brslv,ixres(ian),ilr-ifr+1,nabr
                      write (iout,1010) brslv,ixres(ian),ilr-ifr+1,nabr
                      stop
                    end if
                    if (nn .gt. 0) then
                      do is=nn,itrynnb,-1
                        nnblist(is+nabr)=nnblist(is)
                      end do
                    end if
                    do isv=1,nabr
                      nnblist(itrynnb-1+isv)=ifr-1+isv
                    end do
                    nn=nn+nabr
                  end if
    100           continue
                end do
              end do
              call trnsfi(list(ll+1),nnblist,nn)
              ll1=ll+1
              ll=ll+nn
              iflist(it+1)=ll1
              illist(it+1)=ll
            end do
          end do
          return
    1000  format(' Anchor 1:',i5,' - ')
    1001  format(' solvent',i6,' - ')
    1002  format(' Anchor 2:',i5)
    1003  format(a)
    1004  format(i10)
    1005  format(' PROGRAM ERROR at iat,ia,it,il=',2i5,i3,i2,
         -  ': ixres(ia)=',i4)
    1006  format(' ERROR: maximum number of bridge end types (',i4,
         -  ') is exceeded',/,8x,'Reduce the number of bridge members or',/,
         -  8x,'increase MAXBRIDGETYPE')
    1007  format(' PROGRAM ERROR in traceback iat=',i4,' it=',i1)
    1008  format(8x,'Last frame processed=',i9)
    1009  format(8x,'Processed ',f5.1,' % of the anchors')
    1010  format(' ERROR: bridge residue ',a,' #',i5,' has',i4,' atoms ',
         -  'instead of',i3,/,' - check the input STRUCTURE file')
          end
          subroutine pairdistconf(c,n,rmsdmin,rmsdmax)
          dimension c(3,n)
          parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
          parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
         -  (6*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
          common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),ing(MAX2D,MAX2D),
         -  ihbtores(MAXBONDS),nusepair(MAXBONDS),nhb_atot(MAXBONDS),
         -  nhb_rtot(MAXBONDS),a1(MAXBONDS),a2(MAXBONDS),fill(IFILL2)
          rmsd2d(1,1)=0.0
          rmsdmax=0.0
          rmsdmin=99999.0
          do ia=2,n
            do ja=1,ia-1
              d2=sqrt(dist2(c(1,ia),c(1,ja)))
              rmsd2d(ia,ja)=d2
              rmsd2d(ja,ia)=d2
              if (d2 .lt. rmsdmin) rmsdmin=d2
              if (d2 .gt. rmsdmax) rmsdmax=d2
            end do
            rmsd2d(ia,ia)=0.0
          end do
          return
          end
          subroutine printclusterpdb(c,frocc,bfac,ncl,ifclst,ilclst,ixclst,
         -  title,na)
          dimension c(3,na),frocc(na),bfac(na),ifclst(ncl),ilclst(ncl),
         -  ixclst(na)
          character*80 title
          character*200 pdbout
          nl=0
          call openfile(50,0,'clustered PDB',13,'new',pdbout,nl,notfnd,
         -  0,1,1,0,0)
          write (50,1001) 'REMARK '//title(1:72)
          write (50,1001) 'REMARK Atoms clustered into different residues'
          na=1
          write (50,1000) na,' O  ','CNT','A',1,0.0,0.0,0.0,1.0,0.0
          do icl=1,ncl
            do ia=ifclst(icl),ilclst(icl)
              na=na+1
              iap=ixclst(ia)
              write (50,1000) na,' H  ','CLS','C',icl,
         -      (c(k,iap),k=1,3),frocc(iap),bfac(iap)
            end do
          end do
          write (50,1001) 'END'
          close (50)
          return
    1000  format('ATOM  ',i5,1x,a4,1x,a3,1x,a1,i4,1x,3x,3f8.3,2f6.2)
    1001  format(a)
          end
          subroutine printclusterext(c,cent,ncl,ifclst,ilclst,ixclst,
         -  na,iclstyp,outfile,namleno,iout)
          dimension c(3,na),cent(3,ncl),ifclst(ncl),ilclst(ncl),ixclst(na)
          character*(*) outfile
          dimension xyzmin(3),xyzmax(3),xyz(3)
          character*1 xyzl
          character*200 centfile
          common /axislab/ xyzl(3)
          real*8 dxyz(3),r,theta,phi
          do icl=1,ncl
            do k=1,3
              xyzmin(k)=99999.0
              xyzmax(k)=-99999.0
            end do
            rmin=99999.0
            rmax=0.0
            thetamin=10.0
            thetamax=-10.0
            phimin=10.0
            phimax=-10.0
            do ia=ifclst(icl),ilclst(icl)
              do k=1,3
                xyz(k)=c(k,ixclst(ia))
                dxyz(k)=xyz(k)
                if (xyzmin(k) .gt. xyz(k)) xyzmin(k)=xyz(k)
                if (xyzmax(k) .lt. xyz(k)) xyzmax(k)=xyz(k)
              end do
              call polar(dxyz(1),dxyz(2),dxyz(3),r,phi,theta)
              if (r .lt. rmin) rmin=r
              if (r .gt. rmax) rmax=r
              if (theta .lt. thetamin) thetamin=theta
              if (theta .gt. thetamax) thetamax=theta
              if (phi .lt. phimin) phimin=phi
              if (phi .gt. phimax) phimax=phi
            end do
            write (iout,1000) icl
            if (iclstyp .ne. 2 .and. iclstyp .ne. 4) then
              call zeroit(cent(1,icl),3)
              do ia=ifclst(icl),ilclst(icl)
                do k=1,3
                  cent(k,icl)=cent(k,icl)+c(k,ixclst(ia))
                end do
              end do
              do k=1,3
                cent(k,icl)=cent(k,icl)/float(ilclst(icl)-ifclst(icl)+1)
              end do
            end if
            write (iout,1002) (cent(k,icl),k=1,3)
            write (iout,1001) ('    '//xyzl(k),xyzmin(k),xyzmax(k),'A',
         -    k=1,3)
            write (iout,1001) '    R',rmin,rmax,'A'
            write (iout,1001) 'Theta',thetamin,thetamax,'rad'
            write (iout,1001) '  Phi',phimin,phimax,'rad'
          end do
          call askyn('Do you want a cluster-center file',33,
         -  1,-1,icentfile,000,0)
          if (icentfile .eq. 1) then
            centfile(1:namleno)=outfile(1:namleno)
            centfile(namleno+1:namleno+4)='.cnt'
            print *,'Center coordinates will be written to file ',
         -    centfile(1:namleno+4)
            call openfile(51,0,'cluster center',14,'new',centfile,namleno+4,
         -    notfound,0,1,1,0,0)
            write (51,1003) ncl,((cent(k,icl),k=1,3),icl=1,ncl)
          end if
          return
    1000  format(/,' Cluster ',i5,':')
    1001  format(1x,a,'-range: [',f6.1,' - ',f6.1,'] ',a)
    1002  format(' Cluster center coordinates: ',3f10.5)
    1003  format(i3,/,(3f12.5))
          end
          subroutine selectbond(ixres,nanchor,ianchor,indexa,ianchor2,
         -  iselfanc,iqfsel2,nhbneig,ineig,nbfound,nbresfound,nmc,nhbdist,
         -  rhbdist,bondname,lbondname,ianc_anc,nosameseg,isegno,c,itemp,
         -  itempres,nbonds,ifail,iout,maxng,maxrec,mxbonds)
          dimension ixres(maxrec),ianchor(nanchor),indexa(maxrec),
         -  nhbneig(maxrec),ineig(maxng,maxrec),ianc_anc(mxbonds),
         -  nhbdist(mxbonds),rhbdist(mxbonds),isegno(maxrec),c(3,maxrec),
         -  itemp(mxbonds),itempres(mxbonds)
          character*(*) bondname
          parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
          parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
         -  (6*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
          common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),ing(MAX2D,MAX2D),
         -  ihbtores(MAXBONDS),nusepair(MAXBONDS),nhb_atot(MAXBONDS),
         -  nhb_rtot(MAXBONDS),a1(MAXBONDS),a2(MAXBONDS),fill(IFILL2)
          common /bondpairs/ ihbpair(2,MAXBONDS),ihb_pair_res(3,MAXBONDS)
          parameter (MAXFRAMES=50000,MAXCOPY=600,MAXITEMS=2*MAXCOPY-2)
          common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
         -  increment,increment2,ires(MAXITEMS,MAXFRAMES),
         -  scres(2,MAXFRAMES),x0(MAXCOPY),y0(MAXCOPY),nxselres,
         -  ixselres(MAXCOPY)
          nbitmax=30*MAXITEMS
          call trajlimtest(nframe,MAXFRAMES)
          call zeroiti(itemp,0,mxbonds)
          call zeroiti(itempres,0,mxbonds)
          ndistsum=0
          do i=1,nbfound
            ndistsum=ndistsum+nhbdist(i)
          end do
          nbonds=0
          do iia=1,nanchor
            iat=ianchor(iia)
            if (indexa(iat) .eq. 0) print *,'PROGRAM ERROR: ',iia,
         -    'th anchorlist=',iat,' is not marked as anchor'
            do in=1,nhbneig(iat)
              ian=ineig(maxng-in+1,iat)
              idoit=1
              if (ianchor2 .eq. 1) then
                if (indexa(ian) .lt. 1) idoit=0
              else if (iselfanc .eq. 0) then
                if (indexa(ian) .gt. 0) idoit=0
              else
                if (iqfsel2 .eq. 1 .and. indexa(ian) .eq. 0) idoit=0
              end if
              if (nosameseg .eq. 1 .and. isegno(ian) .eq. isegno(iat))
         -      idoit=0
              if (idoit .eq. 1 .and.
         -        (indexa(ian) .lt. 1 .or. ian .gt. iat)) then
                if (ian .gt. iat) then
                  ib1=iat
                  ib2=ian
                else
                  ib2=iat
                  ib1=ian
                end if
                nbonds=nbonds+1
                ihb=1
                do while (ihb .le. nbfound .and.
         -        (ib1 .ne. ihbpair(1,ihb) .or. ib2 .ne. ihbpair(2,ihb)))
                  ihb=ihb+1
                end do
                if (ihb .gt. nbfound) then
                  nbfound=nbfound+1
                  if (ihb .lt. MAXBONDS) then
                    ihbpair(1,nbfound)=ib1
                    ihbpair(2,nbfound)=ib2
                    nhbdist(ihb)=1
                    if (indexa(ian) .gt. 0) ianc_anc(ihb)=1
                  else
                    write (6,1005) bondname(1:lbondname),mxbonds
                    write (iout,1005) bondname(1:lbondname),mxbonds
                    if (nmc .gt. 0) then
                      write (6,1008) nmc
                      write (iout,1008) nmc
                    else
                      percdone=100.0*float(iia)/float(nanchor)
                      write (6,1009) percdone
                      write (iout,1009) percdone
                    end if
                    call askyn('Do you want to continue without tracking',
         -            40,0,1,istopscan,112,0)
                    ifail=2*istopscan-1
                    return
                  end if
                else
                  nhbdist(ihb)=nhbdist(ihb)+1
                end if
                d12=sqrt(dist2(c(1,ib1),c(1,ib2)))
                rhbdist(ihb)=rhbdist(ihb)+d12
                itemp(ihb)=1
                ir1=ixres(ib1)
                ir2=ixres(ib2)
                ihb=1
                do while (ihb .le. nbresfound .and.
         -        (ir1 .ne. ihb_pair_res(1,ihb) .or.
         -         ir2 .ne. ihb_pair_res(2,ihb)))
                  ihb=ihb+1
                end do
                if (ihb .gt. nbresfound) then
                  nbresfound=nbresfound+1
                  ihb_pair_res(1,nbresfound)=ir1
                  ihb_pair_res(2,nbresfound)=ir2
                  ihb_pair_res(3,nbresfound)=1
                  ihb_pair_res(3,nbresfound+1)=0
                  itempres(nbresfound)=1
                else if (itempres(ihb) .eq. 0) then
                  ihb_pair_res(3,ihb)=ihb_pair_res(3,ihb)+1
                  itempres(ihb)=1
                end if
              end if
            end do
          end do
          ndistsum=0
          itsum=0
          do i=1,nbfound
            ndistsum=ndistsum+nhbdist(i)
            itsum=itsum+itemp(i)
          end do
          if (nbfound .le. nbitmax)
         -  call savebitc(ires(1,nframe),itemp,nbfound,30,MAXITEMS)
          if (nbfound .eq. nbitmax+1) then
            write (6,1005) bondname(1:lbondname),nbitmax
            write (iout,1005) bondname(1:lbondname),nbitmax
          end if
          return
    1005  format(' ERROR: maximum number of ',a,' bonds to store (',i5,
         -  ') is exceeded',/,8x,'Reduce the number of anchors or',/,
         -  8x,'increase the size of the array res in the common block ',
         -  '/analres/')
    1008  format(8x,'Last frame processed=',i9)
    1009  format(8x,'Processed ',f5.1,' % of the anchors')
          end
          subroutine trackstat(nbonds,nhbdist,nhbpers,maxlenon,
         -  maxlenoff,itf,itl,it,itprev)
          dimension nhbdist(nbonds),nhbpers(nbonds),maxlenon(nbonds),
         -  maxlenoff(nbonds),itf(nbonds),itl(nbonds),it(nbonds),
         -  itprev(nbonds)
          parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
          parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
         -  (6*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
          common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),ing(MAX2D,MAX2D),
         -  ihbtores(MAXBONDS),nusepair(MAXBONDS),nhb_atot(MAXBONDS),
         -  nhb_rtot(MAXBONDS),a1(MAXBONDS),a2(MAXBONDS),fill(IFILL2)
          parameter (MAXFRAMES=50000,MAXCOPY=600,MAXITEMS=2*MAXCOPY-2)
          common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
         -  increment,increment2,ires(MAXITEMS,MAXFRAMES),
         -  scres(2,MAXFRAMES),x0(MAXCOPY),y0(MAXCOPY),nxselres,
         -  ixselres(MAXCOPY)
          dimension isegstart(MAXBONDS)
          call zeroiti(nhbdist,0,nbonds)
          call zeroiti(nhbpers,0,nbonds)
          call zeroiti(maxlenon,0,nbonds)
          call zeroiti(maxlenoff,0,nbonds)
          call zeroiti(isegstart,0,nbonds)
          call zeroiti(itf,0,nbonds)
          call zeroiti(itl,0,nbonds)
          do ifr=1,nframe
            call readbitc(ires(1,ifr),it,nbonds,30,MAXITEMS)
            do i=1,nbonds
              if (itf(i) .gt. 0) then
                if (it(i) .ne. itprev(i)) then
                  len=ifr-isegstart(i)
                   if (itprev(i) .eq. 1) then
                     if (maxlenon(i) .lt. len) maxlenon(i)=len
                   else
                     if (maxlenoff(i) .lt. len) maxlenoff(i)=len
                   end if
                   isegstart(i)=ifr
                end if
              end if
              if (it(i) .eq. 1) then
                nhbdist(i)=nhbdist(i)+1
                if (itf(i) .eq. 0) then
                  itf(i)=ifr
                  isegstart(i)=ifr
                end if
                itl(i)=ifr
                if (ifr .gt. 1 .and. itprev(i) .eq. 0)
         -        nhbpers(i)=nhbpers(i)+1
              end if
            end do
            call trnsfi(itprev,it,nbonds)
          end do
          return
          end
          subroutine getbondtrack(itr,itrack,ifirstframe,lastframe,nbits,
         -  nfrm)
          dimension itrack(nfrm)
          parameter (MAXFRAMES=50000,MAXCOPY=600,MAXITEMS=2*MAXCOPY-2)
          common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
         -  increment,increment2,ires(MAXITEMS,MAXFRAMES),
         -  scres(2,MAXFRAMES),x0(MAXCOPY),y0(MAXCOPY),nxselres,
         -  ixselres(MAXCOPY)
          call zeroiti(itrack,0,nframe)
          ifirstframe=0
          lastframe=0
          ii=(itr-1)/nbits+1
          ib=mod(itr-1,nbits)
          do ifr=1,nframe
            if (btest(ires(ii,ifr),ib)) itrack(ifr)=1
            if (itrack(ifr) .eq. 1) then
              if (ifirstframe .eq. 0) ifirstframe=ifr
              lastframe=ifr
              if (ifirstframe .eq. 0) ifirstframe=ifr
            end if
          end do
          return
          end
          subroutine autocorr(itr_ix,itr,itrack,ifirstframe,lastframe,
         -  iframeunit,framefac,iauctypeinp,lastframeinp,nreusemax,percon,
         -  loffmin,nseg_scr,nauc_extra,nframe,iout,mxframes)
          dimension itrack(mxframes)
          parameter (MAXFRAMES=50000)
          parameter (MAXFRAMES2=MAXFRAMES/2)
          dimension auc(MAXFRAMES2),nauc(MAXFRAMES2),lfrunit(4)
          parameter (MAXFRAMES21=MAXFRAMES2+1,MAXCOPY=600)
          common /aucw/ auc_all(MAXFRAMES21,MAXCOPY)
          dimension ran(1),ixran(100)
          character*6 frunit(4)
          data frunit /'frames','ps    ','ns    ','ms    '/,lfrunit/6,2,2,2/
          iauctype=iauctypeinp
          nframe2=max0(nframe,lastframeinp)/2
          call zeroit(auc,nframe2)
          call zeroiti(nauc,0,nframe2)
          if (nframe-lastframe .gt. loffmin .and. iauctype .gt. 3) then
            iauctype=3
            write (iout,1005) nframe,lastframe,loffmin
          end if
          nframeuse=lastframe-ifirstframe+1
          lastframeuse=0
          if (iauctype .eq. 1) then
            lastframeuse=lastframe
          else if (iauctype .eq. 2) then
            lastframeuse=nframe
          else
            if (iauctype .eq. 3) then
              nframeuse=lastframeinp-ifirstframe+1
              call zeroiti(itrack,nframe,lastframeinp)
            else if (iauctype .eq. 4) then
              nframeuse=lastframeinp-ifirstframe+1
              nadd=lastframeinp-lastframe
              incr=lastframe
              lentrackuse=min0(lastframe-ifirstframe+1,nreusemax)
              do while (nadd .gt. 0)
                ncop=min0(nadd,lentrackuse)
                incr0=max(ifirstframe-1,lastframe-ncop)
                if (ncop .ge. nseg_scr .and. nseg_scr .gt. 0) then
                  lenseg_scr=ncop/nseg_scr
                  call scramble(ixran,nseg_scr)
                  do is=1,nseg_scr-1
                    ishift=(ixran(is)-is)*lenseg_scr
                    do i=lenseg_scr*(is-1)+1,lenseg_scr*is
                      itrack(incr+i)=itrack(incr0+i+ishift)
                    end do
                  end do
                  do i=lenseg_scr*(nseg_scr-1)+1,ncop
                    itrack(incr+i)=itrack(incr0+i)
                  end do
                else
                  do i=1,ncop
                    itrack(incr+i)=itrack(incr0+i)
                  end do
                end if
                nadd=nadd-ncop
                incr=incr+ncop
              end do
            else if (iauctype .eq. 5) then
              nframeuse=lastframeinp-ifirstframe+1
              do i=lastframe+1,lastframeinp
                call randpx(1,ran)
                irand=0
                if (ran(1) .lt. percon) irand=1
                itrack(i)=irand
              end do
            end if
            lastframeuse=lastframeinp
          end if
          do ifr=ifirstframe,max0(lastframe,lastframeinp)
            if (itrack(ifr) .eq. 1) then
              ntodo=min0(nframeuse/2,lastframeuse-ifr+1)-1
              do ifrr=1,ntodo
                auc(ifrr)=auc(ifrr)+itrack(ifr+ifrr)
                nauc(ifrr)=nauc(ifrr)+1
              end do
            end if
          end do
          iauchalf=0
          aucsum=0.0
          do ifr=1,nframe2
            if (nauc(ifr) .gt. 0) auc(ifr)=auc(ifr)/float(nauc(ifr))
            aucsum=aucsum+auc(ifr)
            if (iauchalf .eq. 0) then
              if (auc(ifr) .lt. 0.5) iauchalf=ifr
            end if
          end do
          rnfr2=framefac*(nframeuse/2)
          if (iframeunit .gt. 2) then
            if (iauchalf .eq. 0) write (iout,1002) itr,aucsum*framefac,'>',
         -    rnfr2,frunit(iframeunit)(1:lfrunit(iframeunit))
            if (iauchalf .gt. 0) write (iout,1002) itr,aucsum*framefac,'=',
         -    iauchalf*framefac,frunit(iframeunit)(1:lfrunit(iframeunit))
          else
            if (iauchalf .eq. 0) write (iout,1001) itr,aucsum*framefac,'>',
         -    rnfr2,frunit(iframeunit)(1:lfrunit(iframeunit))
            if (iauchalf .gt. 0) write (iout,1001) itr,aucsum*framefac,'=',
         -    iauchalf*framefac,frunit(iframeunit)(1:lfrunit(iframeunit))
          end if
          write (iout,1003) (auc(i),i=1,10)
          incr=max0(1,(nframe-1)/20+1)
          write (iout,1004) (auc(i*incr),i=1,nframeuse/(2*incr))
          if (itr_ix .le. MAXCOPY) then
            call trnsfr(auc_all(1,itr_ix),auc,nframe2)
            auc_all(nframe2+1,itr_ix)=aucsum
          else
            nauc_extra=nauc_extra+1
          end if
          return
    1001  format(' BA#',i4,' AUC sum=',f7.1,' Half time of the track auc ',
         -  a,f9.1,1x,a)
    1002  format(' BA#',i4,' AUC sum=',f11.4,' Half time of the track auc ',
         -  a,f9.4,1x,a)
    1003  format(' AUC (1-10):',10f6.3)
    1004  format(' AUC (incr):',10f6.3)
    1005  format(' Paddig switched to 0s (nframe=',i6,' laston=',i6,
         -  ' loffmin=',i6,')')
          end
          subroutine print_auc(lab,llab,ntracks,nframe,bondname,lbondname)
          character*(*) lab,bondname(ntracks)
          parameter (MAXFRAMES=50000,MAXCOPY=600)
          parameter (MAXFRAMES2=MAXFRAMES/2)
          parameter (MAXFRAMES21=MAXFRAMES2+1)
          common /aucw/ auc_all(MAXFRAMES21,MAXCOPY)
          call openfile(91,0,' ',1,'new',lab,llab,notfnd,0,1,1,0,0)
          ntrackw=min0(ntracks,MAXCOPY)
          write (91,1003) (it,it=1,ntrackw)
          write (91,1004) (it,bondname(it)(1:lbondname),it=1,ntrackw)
          write (91,1001) 0,(1.0,it=1,ntrackw)
          do if=1,nframe/2
            write (91,1001) if,(auc_all(if,it),it=1,ntrackw)
          end do
          write (91,1002) (auc_all(nframe/2+1,it),it=1,ntrackw)
          close (91)
          return
    1001  format(i7,400f7.3)
    1002  format('#AUCSUM',400f7.1)
    1003  format('#      ',400i7)
    1004  format('#      ',400(i4,':',a))
          end
          subroutine printrmsd2(iout,n1,n2,lab,llab)
          character*(*) lab
          parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
          parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-MAX2D*MAX2D)
          common /nnwork/ rmsd2d(MAX2D,MAX2D),fill(IFILL2)
          write (iout,*) lab(1:llab)
          do i=1,n1
            write (iout,1000) i,(rmsd2d(i,j),j=1,n2)
          end do
          return
    1000  format(i4,' rmsd2:',10f8.2)
          end
          subroutine hbbridgeprint(nanchor,ianchor,lpath,nbridgetype,
         -  ibridgetype,maxbridgemem,line,index,iresno,inamcol1,inamcol2,
         -  irescol1,irescol2,iout,maxbhcount,maxhbtype,
         -  minbridgelenprint,minbridgepercprint,nframe,maxbridgelen,
         -  maxbridgetype,maxrec)
          dimension ianchor(nanchor),nbridgetype(maxbridgelen,nanchor),
         -  lpath(maxbridgetype,maxbridgelen,nanchor),iresno(maxrec),
         -  ibridgetype(maxbridgetype,maxbridgelen,nanchor),index(maxrec)
          character* 132 line(maxrec)
          dimension lensum(10)
          call zeroiti(lensum,0,maxbridgelen)
          if (minbridgelenprint .gt. 1) write (iout,1006) minbridgelenprint
          if (minbridgepercprint .gt. 0)
         -   write (iout,1007) minbridgepercprint,nframe
          write (iout,*)
          maxbrtyp=0
          maxbhcount=0
          maxhbtype=0
          do ia=1,nanchor
            ifrom=ianchor(ia)
            do id=1,maxbridgemem+1
              if (nbridgetype(id,ia) .gt. maxbrtyp)
         -       maxbrtyp=nbridgetype(id,ia)
              do in=1,nbridgetype(id,ia)
                ito=ibridgetype(in,id,ia)
                nbr=lpath(in,id,ia)
                if (id .ge. minbridgelenprint) then
                  iperc=float(100*nbr)/float(nframe)
                  if (iperc .ge. minbridgepercprint) then
                    write (iout,1000) ifrom,iresno(ifrom),
         -            line(index(ifrom))(inamcol1:inamcol2),
         -            line(index(ifrom))(irescol1:irescol2),ito,iresno(ito),
         -            line(index(ito))(inamcol1:inamcol2),
         -            line(index(ito))(irescol1:irescol2),id,nbr
                    if (id .lt. 1 .or. id .gt. 10) print *,
         -            'ia,ifrom,ito,nbr,id=',ia,ifrom,ito,nbr,id
                    lensum(id)=lensum(id)+nbr
                    if (id .eq. 1) then
                      maxhbtype=maxhbtype+1
                      if (nbr .gt. maxbhcount) maxbhcount=nbr
                    end if
                  end if
                end if
              end do
            end do
          end do
          write (iout,*)
          do id=1,maxbridgelen
            if (lensum(id) .gt. 0) write (iout,1001) id,lensum(id)
          end do
          write (6,1005) maxbrtyp,maxbridgetype
          write (iout,1005) maxbrtyp,maxbridgetype
          return
    1000  format(' From (',i6,i6,')(',a,1x,a,') to (',i6,i6,
         -  ')(',a,1x,a,') of length ',i1,' #:',i5)
    1001  format(' Number of paths of length',i2,'=',i9)
    1005  format(/,' Maximum number of bridge types per anchor atom found=',
         -  i3,' limit=',i3)
    1006  format(' Bridges with length < ',i1,' will not be printed')
    1007  format(' Bridges that occur less than ',i3,'% of the',i6,
         -  ' frames will not be printed')
          end
          subroutine bondcorrsum(nbondcorr,nresbondcorr,scpmin,scpmax,
         -  ibframe,itempsum,ifirstframe,correxp,icorrtyp,
         -  icorrtrans,iaggregate,icorrbothstart,nframeav,imatprint,iout,
         -  mx2d)
          dimension ibframe(mx2d),itempsum(mx2d),ifirstframe(mx2d)
          parameter (MAXFRAMES=50000,MAXCOPY=600,MAXITEMS=2*MAXCOPY-2)
          common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
         -  increment,increment2,ires(MAXITEMS,MAXFRAMES),
         -  scres(2,MAXFRAMES),x0(MAXCOPY),y0(MAXCOPY),nxselres,
         -  ixselres(MAXCOPY)
          parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
          parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
         -  (6*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
          common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),ing(MAX2D,MAX2D),
         -  ihbtores(MAXBONDS),nusepair(MAXBONDS),nhb_atot(MAXBONDS),
         -  nhb_rtot(MAXBONDS),ibond(MAXBONDS),a1(MAXBONDS),fill(IFILL2)
          character*1 ans
          if (nbondcorr .le. 1) then
            write (6,1004) nbondcorr
            return
          end if
          ncorr=nbondcorr
          if (iaggregate .gt. 0) ncorr=nresbondcorr
          if (ncorr .gt. MAX2D) then
            write (6,1005) MAX2D,ncorr
            return
          end if
          call trajlimtest(nframe,MAXFRAMES)
          call quiz(ans,icorrtyp,'b',' ',0,'bond correlation type',21,
         -  0,5,6,85)
          if (icorrtyp .eq. 3) then
    8010    call getint('Number of frames to average over',32,5,1,nframe,
         -    nframeav,84)
            if (nframeav .ge. nframe) then
              write (6,1008) nframe
              go to 8010
            end if
          end if
          call quiz(ans,icorrtrans,'-',' ',0,
         -  'correlation - measure transformation',36,0,5,6,000)
          write (6,1002)
          call getint('Exponent of correlations',24,1,0,9,icorrexp,3)
          if (nframe .ge. 1000)
         -  print *,'Calculating correlation matrix - wait'
          correxp=icorrexp
          if (icorrexp .lt. 1) correxp=1.0/float(-icorrexp)
          write (iout,1001)
          call zeroiti(nng,0,MAX2D)
          call zeroiti(ifirstframe,0,MAX2D)
          if (icorrtyp .eq. 3) call zeroiti(itempsum,0,MAX2D)
          call zeroiti(ing,0,MAX2D*MAX2D)
          nframe10=nframe/10+1
          scpmax=0.0
          scpmin=1.0
          do ifr=1,nframe
            call readbitc(ires(1,ifr),ibframe,nbondcorr,30,MAXITEMS)
            if (icorrtyp .eq. 3) then
              do ib=1,ncorr
                itempsum(ib)=itempsum(ib)+ibframe(ib)
              end do
            end if
            do ib=1,ncorr
              if (ibframe(ib) .eq. 1 .and. ifirstframe(ib) .eq. 0)
         -      ifirstframe(ib)=ifr
              nng(ib)=nng(ib)+ibframe(ib)
            end do
            do ib1=2,ncorr
              do ib2=1,ib1-1
                if (icorrbothstart .eq. 0) then
                   iuseib12=ifirstframe(ib1)+ifirstframe(ib2)
                else
                   iuseib12=ifirstframe(ib1)*ifirstframe(ib2)
                end if
                if (iuseib12 .gt. 0) then
                  if (icorrtyp .lt. 3) then
                    icorr=ibframe(ib1)*ibframe(ib2)
                    if (icorrtyp .eq. 1) then
                      icorr=icorr+(1-ibframe(ib1))*(1-ibframe(ib2))
                    end if
                    ing(ib1,ib2)=ing(ib1,ib2)+icorr
                    ing(ib2,ib1)=ing(ib2,ib1)+1
                  else if (mod(ifr,nframeav) .eq. 0) then
                    icorr=itempsum(ib1)*itempsum(ib2)
                    ing(ib1,ib2)=ing(ib1,ib2)+icorr
                    ing(ib2,ib1)=ing(ib2,ib1)+1
                  end if
                end if
              end do
            end do
            if (icorrtyp .eq. 3) then
              if (mod(ifr,nframeav) .eq. 0) call zeroiti(itempsum,0,ncorr)
            end if
            if (nframe .ge. 1000 .and. mod(ifr,nframe10) .eq. 0)
         -    write (6,1000) ifr/nframe10
          end do
          scp=0.0
          do ib1=2,ncorr
            do ib2=1,ib1-1
              if (icorrtyp .eq. 1 .or. icorrtyp .eq. 2) then
                scp=float(ing(ib1,ib2))/float(ing(ib2,ib1))
              else if (icorrtyp .eq. 3) then
                scp=float(ing(ib1,ib2))/float(ing(ib2,ib1)*nframeav**2)
              end if
              if (scp .lt. 0.0 .or. scp .gt. 1.0)
         -      write (iout,1003) ib1,ib2,ing(ib1,ib2),ing(ib2,ib1),scp
              if (icorrtrans .eq. 1) then
                scp=(1.0-scp)**correxp
              else if (icorrtrans .eq. 2) then
                scp=(amin1(1.0/scp,99.0))**correxp
              else
                scp=scp**correxp
              end if
              rmsd2d(ib1,ib2)=scp
              rmsd2d(ib2,ib1)=scp
              if (scp .lt. scpmin) scpmin=scp
              if (scp .gt. scpmax) scpmax=scp
            end do
          end do
          if (imatprint .eq. 1) then
            if (iaggregate .eq. 0) write (iout,1007) ' '
            if (iaggregate .eq. 1) write (iout,1007) 'residue-aggregated'
            do ib1=1,ncorr
              write (iout,1006) ib1,(rmsd2d(ib1,ib2),ib2=1,ncorr)
            end do
          end if
          return
    1000  format(i2,'0 % done')
    1001  format(/,' === Calculating correlation between bond histories ',
         -  'for clustering the bonds')
    1002  format(' Negative number -n for exponent will be changed to ',
         -  '1/n')
    1003  format(' PROGRAM ERROR: ib1,2=',2i6,' ing(ib1,ib2)=',i6,
         -  ' ing(ib2,ib1)=',i6,' scp=',f10.5)
    1004  format(' Correlation calculations require at least 2 bonds',/,
         -  ' but there is only ',i2,' left')
    1005  format(' ERROR: Bond correlation calculation is limited to ',i5,
         -  ' bonds',/,8x,'- filter out more bonds or recompile Simulaid ',
         -  'with MAX2D > ',i5)
    1006    format(' IB1=',i4,' RMSD2D:',/,(15f5.2))
    1007  format(' The ',a,' bond correlation matrix')
    1008  format(' # of frames to average over should be < # of frames (',
         -  i6,')')
          end
          subroutine bondcorrprint(nhbcorr,iout,line,index,iresno,indexbond,
         -  correxp,icorrtyp,icorrtrans,nframeav,nhbdist,ifhbclust,
         -  ilhbclust,ixhbclst,rclust,nclust,iclust,inamcol1,inamcol2,
         -  irescol1,irescol2,nhneigmin,hblimfac,angmin,rhph_sltbmax,
         -  percmin,percmax,minresdist,maxresdist,numres,icorrp,nframe,
         -  bondname,lbondname,icontract,ixresno,resnames,maxrec,mxbonds)
          dimension iresno(maxrec),index(maxrec),indexbond(mxbonds),
         -  nhbdist(mxbonds),ifhbclust(mxbonds),ilhbclust(mxbonds),
         -  ixhbclst(mxbonds),ixresno(maxrec)
          character*(*) bondname
          character*132 line(maxrec)
          character*8 resnames(maxrec)
          parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
          parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
         -  (6*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
          common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),ing(MAX2D,MAX2D),
         -  ihbtores(MAXBONDS),nusepair(MAXBONDS),nhb_atot(MAXBONDS),
         -  nhb_rtot(MAXBONDS),ibond(MAXBONDS),a1(MAXBONDS),fill(IFILL2)
          common /bondpairs/ ihbpair(2,MAXBONDS),ihb_pair_res(3,MAXBONDS)
          dimension i12(2),ihistogram(10)
          character*1 corb
          character*8 aname(2),rname(2)
          if (nhbcorr .gt. MAX2D) then
            print *,'PROGRAM ERROR: nhbcorr=',nhbcorr,' MAX2D=',MAX2D
            return
          end if
          lan=inamcol2-inamcol1+1
          lrn=irescol2-irescol1+1
          if (iclust .eq. 0) write (iout,1026) bondname(1:lbondname)
          if (iclust .eq. 1) write (iout,1013) bondname(1:lbondname)
          if (icorrtyp .eq. 1) write (iout,1014)
          if (icorrtyp .eq. 2) write (iout,1015)
          if (icorrtyp .eq. 3) write (iout,1017) nframeav
          if (icorrtrans .eq. 1) write (iout,1018) correxp
          if (icorrtrans .eq. 2) write (iout,1019) correxp
          if (icorrtrans .eq. 3) write (iout,1020) correxp
          call write_traj_lim(iout,
         -  'Correlations calculated from trajectory',39,1,incr_tr,0)
          if (bondname(1:8) .eq. 'hydrogen') then
            write (iout,1010) hblimfac,angmin
          else if (bondname(1:11) .eq. 'hydrophobic') then
            write (iout,1011) bondname(1:11),rhph_sltbmax,' ',nhneigmin
          else if (bondname(1:11) .eq. 'salt-bridge') then
            write (iout,1011) bondname(1:11),rhph_sltbmax
          end if
          nprint=0
          if (percmin .gt. 0.0 .or. percmax .lt. 100.0) then
            write (iout,1006) bondname(1:lbondname),percmin,percmax
            nprint=1
          end if
          if (minresdist .gt. 1 .or. maxresdist .lt. numres-1) then
            write (iout,1007) bondname(1:lbondname),minresdist,maxresdist
            nprint=1
          end if
          if (nprint .eq. 0) write (iout,1005) bondname(1:lbondname)
          if (iclust .gt. 0) then
            if (rclust .gt. 0.0)  write (iout,1003) rclust
            nclp=nclust
          else
            nclp=1
            ifhbclust(1)=1
            ilhbclust(1)=nhbcorr
          end if
          maxhbtype=0
          minhbtype=nframe
          scpmax=0.0
          scpmin=1.0
          if (icorrtrans .ne. 2) then
            scpmaxp=1.0
          else
            scpmaxp=5.0
            if (correxp .gt. 1.0) scpmaxp=10.0
          end if
          call zeroiti(ihistogram,0,10)
          do ib=1,nhbcorr
            nhbd=nhbdist(indexbond(ib))
            if (nhbd .gt. maxhbtype) maxhbtype=nhbd
            if (nhbd .lt. minhbtype) minhbtype=nhbd
            do ibb=2,ib
              if (icontract .eq. 0) then
                scp=rmsd2d(indexbond(ib),indexbond(ibb))
              else
                scp=rmsd2d(ixhbclst(ib),ibb)
              end if
              if (scpmax .lt. scp) scpmax=scp
              if (scpmin .gt. scp) scpmin=scp
              ix=10*abs(scp-1.e-6)/scpmaxp+1
              if (ix .gt. 10) ix=1
              ihistogram(ix)=ihistogram(ix)+1
            end do
          end do
          write (6,1016) scpmin,scpmax
          write (iout,1016) scpmin,scpmax
          normfac=max0(1,(nhbcorr*(nhbcorr-1))/2)
          write (6,1008) scpmaxp,
         -   (float(ihistogram(i))/float(normfac),i=1,10)
          write (iout,1008) scpmaxp,
         -   (float(ihistogram(i))/float(normfac),i=1,10)
          ihb=0
          corb=':'
          if (icorrp .eq. 0) corb=' '
          do ic=1,nclp
            if (iclust .eq. 1) then
              write (iout,1012) ic,ilhbclust(ic)-ifhbclust(ic)+1
              call findbestcorrep(iout,ifhbclust(ic),ilhbclust(ic),
         -      indexbond,mxbonds)
            end if
            if (icontract .eq. 0) write (iout,1022) bondname(1:lbondname)
            if (icontract .eq. 1) write (iout,1023)
            if (icorrp .gt. 0) write (iout,1024)
            do ib=ifhbclust(ic),ilhbclust(ic)
              ihb=ihb+1
              if (icorrp .eq. 1) write (iout,*)
              ib1=indexbond(ib)
              if (icontract .eq. 0) then
                do i=1,2
                  i12(i)=ihbpair(i,ib1)
                  aname(i)(1:lan)=line(index(i12(i)))(inamcol1:inamcol2)
                  rname(i)(1:lrn)=line(index(i12(i)))(irescol1:irescol2)
                end do
                write (iout,1001) ib,ib1,(i12(i),
         -        aname(i)(1:lan),iresno(i12(i)),rname(i)(1:lrn),i=1,2),
         -        float(100*nhbdist(ib1))/float(nframe),corb
              else
                ixr1=ihb_pair_res(1,ib1)
                ixr2=ihb_pair_res(2,ib1)
                ir1=ixresno(ixr1)
                ir2=ixresno(ixr2)
                call lastchar(resnames(ixr1),lc1,8)
                call lastchar(resnames(ixr2),lc2,8)
                write (iout,1025) ixhbclst(ib),ib1,resnames(ixr1)(1:lc1),
         -        ir1,resnames(ixr2)(1:lc2),ir2
              end if
              if (icorrp .eq. 1) then
                if (icontract .eq. 0) then
                  if (icorrtrans .eq. 2) then
                    write (iout,1021)
         -            (rmsd2d(ib1,indexbond(ib2)),ib2=1,nhbcorr)
                  else
                    write (iout,1009)
         -            (rmsd2d(ib1,indexbond(ib2)),ib2=1,nhbcorr)
                  end if
                else
                  if (icorrtrans .eq. 2) then
                    write (iout,1021)
         -            (rmsd2d(ixhbclst(ib),ib2),ib2=1,nhbcorr)
                  else
                    write (iout,1009)
         -            (rmsd2d(ixhbclst(ib),ib2),ib2=1,nhbcorr)
                  end if
                  if (icorrtrans .eq. 1) then
                    do ib2=1,nhbcorr
                     if (rmsd2d(ixhbclst(ib),ib2) .lt. 0.0 .or.
         -               rmsd2d(ixhbclst(ib),ib2) .gt. 1.0) write (iout,*)
         -             'ib2=',ib2,' rmsd2d=',rmsd2d(ixhbclst(ib),ib2)
                    end do
                  end if
                end if
              end if
            end do
            if (nclp .gt. 1) write (iout,1002) ic
          end do
          return
    1001  format(' FB#',i5,' (',i4,'):',i6,1x,a,i6,1x,a,' -',
         -  i6,1x,a,i6,1x,a,' occ=',f6.2,'% ',a)
    1002  format(1x,23('-'),' End of cluster ',i4,1x,30('-'))
    1003  format(' Clustered with Rclust=',f5.3)
    
    1005  format(' All ',a,' bonds are included')
    1006  format(' Filtered list: ',a,' bonds are included only when ',/,
         -  5x,'their occurrence is in the range [',f5.1,' - ',f6.1,'] %')
    1007  format(' Filtered list: ',a,' bonds are included only when ',/,
         -  5x,'their interresidue number difference is in the range [',i5,
         -  ' - ',i5,'] residues')
    1008  format(' Histogram of distance measures (10% bins in the 0 - ',
         -  f4.1,' range):',/,10f6.3,/)
    1009  format(15f5.2)
    1010  format(' Hydrogen-bonds thresholds: hblimfac=',f5.2,
         -  ' and H-bond angle minimum=',f5.1)
    1011  format(' Distance threshold for ',a,'bond=',f5.2,a,/,' Minimum ',
         -  'number of bonded hydrogens for a hydrophobic carbon=',i1)
    1012  format(' Cluster ',i4,' number of members:',i5)
    1013  format(' Clustering results of ',a,' bonds based on correlation')
    1014  format(' Correlation measure: CORR=(HB1.HB2)+(1-HB1).(1-HB2) ',
         -  '(include the off states)')
    1015  format(' Correlation measure: CORR=(HB1.HB2) (correlate only the',
         -  '  off states')
    1016  format(' Range of the distance measure values:',
         -  ' [',f5.2,' - ',f8.2,']')
    1017  format(' Correlations are calculated using a running average ',
         -  'over',i4,' windows')
    1018  format(' Distance measure: the correlation complement power ',
         -  '(1-CORR)^(',f5.3,')')
    1019  format(' Distance measure: the correlation inverse power ',
         -  '(1/CORR)^(',f5.3,')')
    1020  format(' Distance measure: the correlation power CORR^(',f5.3,')')
    1021  format(15f5.1)
    1022  format(1x,a,' bond# (original #)')
    1023  format(' res-res# (original #)')
    1024  format(' Correlation measures in each row refer to the ',
         -  'unclustered order')
    1025  format(' RR#',i5,' (',i5,') ( ',a,i4,' - ',a,i4,')')
    1026  format(' Correlation based distance matrix of ',a,' bonds')
          end
          subroutine plotbondcorr(ips,nbonds,yclab,lyclab,icontract,
         -  indexbond,title,temp,itemp,lablim,ncolcode,maxcolcode,
         -  ipspage,ipsclose)
          parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
          parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
         -  (6*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
          dimension temp(MAX2D),itemp(MAX2D),indexbond(MAX2D)
          character*(*) yclab(nbonds)
          character*80 title
          common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),ing(MAX2D,MAX2D),
         -  ihbtores(MAXBONDS),nusepair(MAXBONDS),nhb_atot(MAXBONDS),
         -  nhb_rtot(MAXBONDS),ibond(MAXBONDS),a1(MAXBONDS),fill(IFILL2)
          dimension kc(1,1)
          real*8 dc(1,1)
          if (nbonds .lt. lablim) then
            nyclab=nbonds
          else
            nyclab=1
            lyclab=1
          end if
          inc=max0(1,500/nbonds)
          ixdel0=25
          iydel0=100
          ixdel=25
          iydel=200
          iytop=0
          do i=1,MAX2D
            temp(i)=i
            itemp(i)=i
          end do
          call plotmat(ips,kc,rmsd2d,dc,nbonds,nbonds,0,0,0,0,1,1,
         -  ixdel0,iydel0,0,iytop,0.0,1.0,ncolcode,maxcolcode,ixdel,iydel,
         -  inc,1.0,itemp,indexbond,indexbond,title,80,
         -  'Bond correlation distance measure matrix',40,1,' ',1,temp,
         -  yclab,nyclab,lyclab,1,MAX2D,1,MAX2D,MAX2D,ipspage,ipsclose)
          if (icontract .eq. 1) then
            iytop=iytop+15
            call pswrite(ips,ixdel0,iytop,'m',1)
            write (ips,*)
         -   '(Bond tracks contracted to residue-residue tracks) show'
          end if
          iydel=iydel-50
          ixcent=max0(0,(nbonds*inc-50*ncolcode)/2)
          call colcodeminmax(ips,25+ixcent,-iydel-5,0,ncolcode,
         -  maxcolcode,0.0,1.0)
          write (ips,1000) 'showpage'
          return
    1000  format(a)
          end
          subroutine printbonddist(nframe,nbfound,nhbdist,index2d,
         -  ianc_anc,naabond,iout,bondtype,lbondtype,iselfanc,maxbondcount,
         -  maxhb)
          dimension nhbdist(maxhb),index2d(maxhb),
         -  ianc_anc(maxhb)
          character*(*) bondtype
          dimension nhbhist(10)
          maxbondcount=0
          minbondcount=nframe
          nbondsum=0
          naabond=0
          do ib=1,nbfound
            nhbd=nhbdist(index2d(ib))
            if (nhbd .gt. maxbondcount) maxbondcount=nhbd
            if (nhbd .lt. minbondcount) minbondcount=nhbd
            nbondsum=nbondsum+nhbd
            naabond=naabond+ianc_anc(ib)
          end do
          call zeroiti(nhbhist,0,10)
          do ib=1,nbfound
            ix=(10*nhbdist(index2d(ib))-1)/maxbondcount+1
            nhbhist(ix)=nhbhist(ix)+1
          end do
          write (6,2000) bondtype(1:lbondtype),nbfound,maxbondcount
          write (6,2001) bondtype(1:lbondtype),naabond
          if (iselfanc .eq. 1)
         -  write (iout,2001) bondtype(1:lbondtype),naabond
          write (6,2003) bondtype(1:lbondtype),float(nbondsum)/float(nframe)
          write (iout,2003) bondtype(1:lbondtype),
         -  float(nbondsum)/float(nframe)
          write (6,2002) nframe,minbondcount,maxbondcount,
         -  (nhbhist(i),i=1,10)
          write (iout,2002) nframe,minbondcount,maxbondcount,
         -  (nhbhist(i),i=1,10)
          return
    2000  format(' Number of ',a,'-bond types found=',i5,/,
         -  ' Most persistent bond was present in ',i6,' configurations')
    2001  format(' Number of anchor-anchor ',a,' bonds found=',i6)
    2002  format(' Histogram of the number of frames a bond is present ',
         -  'over',i7,' configurations',/,
         -  ' (10% intervals of [',i5,' - ',i5,'] range:',/,10i7)
    2003  format(' Total number of ',a,' bonds / number of frames=',f7.1)
          end
          subroutine finalizebonds(n,nbfound,nbfoundorig,nbresfound,iw0,iw1,
         -  numres,nresslt,npspages,ipspage,nres2d,ibondcorr,iresbondcorr,
         -  nhneigmin,hblimfac,angmin,rhph_sltbmax,inamcol1,inamcol2,
         -  irescol1,irescol2,ifhb2d,ilhb2d,nhbdist,rhbdist,iframeunit,
         -  framefac,title,ltitle,xtrajlab,lxtrajlab,xtraj,value,ifa_s,
         -  ila_s,ih,cv,temp,index,iresno,ifres,isegno,atnames,resnames,
         -  ixres,ixresno,ixsegno, indexa,indexs,index2d,ianc_anc,isc,
         -  ixclst,irepav,irepmx,irepeng,irepkm,rmsdlim,engcl,it1,it2,it3,
         -  it4,it5,irrix,itemp1,itemp2,itemp3,nrrbond,line,bondtype,
         -  lbondtype,ibondtype,label2d,iselfanc,ianchor2,iresshift,
         -  ifailbond,nbondavg,inpfile,namleni,maxbondf,nmcmaxbond,ncolcode,
         -  maxcolcode,maxbondcount,mxbonds,maxrsd,maxfrm,maxrec,mx2d)
          dimension index(maxrec),iresno(maxrec),ifres(maxrec),
         -  isegno(maxrec),ixres(maxrec),ixresno(maxrsd),ixsegno(maxrsd),
         -  indexs(maxrec),index2d(mxbonds),ianc_anc(mxbonds),engcl(mx2d),
         -  it1(mxbonds),it2(mxbonds),it3(mxbonds),it4(mxbonds),
         -  it5(mxbonds),irrix(maxrec),itemp1(maxrec),itemp2(maxrec),
         -  itemp3(maxrec),nrrbond(mxbonds),ifhb2d(mxbonds),ilhb2d(mxbonds),
         -  irepav(mx2d),irepmx(mx2d),irepeng(mx2d),irepkm(mx2d),
         -  nhbdist(mxbonds),rhbdist(mxbonds),value(mxbonds),ifa_s(mxbonds),
         -  ila_s(mxbonds),ih(maxrec),cv(maxrec),temp(maxrec),isc(maxrec),
         -  ixclst(mxbonds),rmsdlim(mxbonds),indexa(maxrec),xtraj(maxfrm)
          character*8 atnames(maxrec),resnames(maxrsd)
          character*80 title,label2d(mx2d),label,remark
          character*(*) xtrajlab,inpfile
          character* 132 line(maxrec)
          character*(*) bondtype
          parameter (MAXFRAMES=50000,MAXCOPY=600)
          parameter (MAXCOPY1=MAXCOPY-1)
          common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
         -  increment,increment2,res(2,MAXFRAMES,MAXCOPY1),
         -  scres(2,MAXFRAMES),x0(MAXCOPY),y0(MAXCOPY),nxselres,
         -  ixselres(MAXCOPY)
          parameter (MAXBONDS=10000)
          dimension nhbpers(MAXBONDS),itrackf(MAXBONDS),itrackl(MAXBONDS),
         -  maxlenon(MAXBONDS),maxlenoff(MAXBONDS),itrack(MAXFRAMES),
         -  xtrajmod(MAXFRAMES),data(MAXFRAMES)
          dimension c(3,1),ct1(3,1),ct2(3,1)
          real*8 dsum,dsum2,dsumm,dsumm2,bsum,bsum2,aabsum,aabsum2
          character*37 yclab(MAXBONDS)
          character*80 plotlab
          character*200 aucfile
          if (ifailbond .ne. 0) return
          if (nbfound .eq. 0) then
            write (6,2001)
            write (iw0,2001)
            return
          end if
          nosortindex2d=0
          lablim=50
          icorrtyp=0
          icorrtrans=0
          call zeroiti(nhbpers,0,MAXBONDS)
          call zeroiti(itrackf,0,MAXBONDS)
          call zeroiti(itrackl,0,MAXBONDS)
          plotlab(1:lbondtype)=bondtype(1:lbondtype)
          plotlab(lbondtype+1:lbondtype+7)=' bond #'
          lplotlab=lbondtype+7
          if (nbfound .eq. 0) return
          icorrbothstart=0
          call askyn('Do you want to end the track statistics at '//
         -  'the last on frame',60,1,-1,iuselaston,135,0)
          if (ibondcorr+iresbondcorr .gt. 0)
         -  call askyn('Do you want to correlate only after both '//
         -    'tracks started',55,1,-1,icorrbothstart,136,0)
          call trackstat(nbfound,nhbdist,nhbpers,maxlenon,maxlenoff,
         -  itrackf,itrackl,it1,it2)
    8005  call indexit(index2d,1,nbfound,0)
          write (iw0,2007) bondtype(1:lbondtype),maxbondf,nmcmaxbond
          write (6,2007) bondtype(1:lbondtype),maxbondf,nmcmaxbond
          call printbonddist(nframe,nbfound,nhbdist,index2d,
         -  ianc_anc,naabond,iw0,bondtype,lbondtype,iselfanc,maxbondcount,
         -  mxbonds)
          nbfoundorig=nbf ound
          call filterbonds(n,nbfound,nhbdist,rhbdist,nhbpers,itrackf,
         -  itrackl,itrack,maxlenon,maxlenoff,iframeunit,framefac*increment,
         -  nframe,index2d,bondtype,lbondtype,line,index,inamcol1,inamcol2,
         -  irescol1,irescol2,iresno,isegno,ixres,ixresno,ixsegno,ifres,
         -  numres,nresslt,ianc_anc,isc,bondtype,lbondtype,percminb,
         -  percmaxb,minresdistb,maxresdistb,nochange,cv,iuselaston,iauc,
         -  iaucw,inpfile,namleni,temp,it1,it2,it3,it4,irrix,itemp2,iw0,
         -  maxrec,maxrsd,mxbonds,MAXFRAMES,MAXCOPY)
          call bondsum(nbfoundorig,nbfound,index2d,ixres,atnames,resnames,
         -  isegno,iresno,ifres,it1,iw0,MAXBONDS,maxrsd,maxrec)
          call makebondlab(1,nbfound,0,1,yclab,lyclab,irrix,ixresno,
         -  ixres,index2d,resnames,atnames,nbfound,mxbonds,maxrsd,maxrec)
          if (iaucw .gt. 0) then
            call getname(aucfile,laucfile,
         -    'Name of the file to write the bond autocorrelations',51,80,
         -    '',0,0,0,0)
            call print_auc(aucfile,laucfile,nbfound,nframe,yclab,lyclab)
            write (6,2002) aucfile(1:laucfile)
            write (iw0,2002) aucfile(1:laucfile)
          end if
          rhbcorrclust=0.0
          nhbcorrclust=1
          print *,'NFRAME,XTRAJ(1),XTRAJ(NFRAME)=',
         -  nframe,xtraj(1),xtraj(nframe)
          call plotbond(iw1,nbfoundorig,nbfound,nbresfound,nhbcorrclust,
         -  ianc_anc,ifhb2d,ilhb2d,index2d,indexs,it1,it2,rhbcorrclust,0,
         -  xtraj(nframe),10,title,ltitle,xtrajlab,lxtrajlab,plotlab,
         -  lplotlab,0,percminb,percmaxb,numres,minresdistb,maxresdistb,
         -  rhph_sltbmax,bondtype,lbondtype,0,nhneigmin,nbondmax,naabondmax,
         -  icorrtyp,icorrtrans,nframeav,correxp,hblimfac,angmin,lablim,
         -  ibondtype,1,it3,ixresno,itemp3,ixres,nrrbond,atnames,
         -  resnames,npspages,ipspage,mxbonds,maxrsd,maxrec)
          call roundlimint(naabondmax+1,iyd2,nyd2)
          call roundlimint(nbondmax+1,iyd,nyd)
          nplot=2
          iyinc=0
          if (iselfanc .eq. 0 .or. ianchor2 .eq. 1
         -   .or. naabond .eq. nbfoundorig) then
            nplot=1
            if (iselfanc .eq. 1) iyinc=1
          end if
          dsum=0.d0
          dsumm=0.d0
          dsum2=0.d0
          dsumm2=0.d0
          nbmin=10000
          nbmax=0
          naabmin=10000
          naabmax=0
          do i=1,nframe
            dsum=dsum+scres(1,i)
            dsumm=dsumm+scres(2,i)
            dsum2=dsum2+scres(1,i)**2
            dsumm2=dsumm2+scres(2,i)**2
            if (nbmin .gt. scres(1,i)) nbmin=scres(1,i)
            if (nbmax .lt. scres(1,i)) nbmax=scres(1,i)
            if (naabmin .gt. scres(2,i)) naabmin=scres(2,i)
            if (naabmax .lt. scres(2,i)) naabmax=scres(2,i)
          end do
          write (iw0,2003) ' ',bondtype(1:lbondtype),dsum/dfloat(nframe),
         -  dsqrt(dsum2/dfloat(nframe)-(dsum/dfloat(nframe))**2),nbmin,nbmax
          if (iselfanc .eq. 1) write (iw0,2003) ' anchor-anchor ',
         -  bondtype(1:lbondtype),dsumm/dfloat(nframe),
         -  dsqrt(dsumm2/dfloat(nframe)-(dsumm/dfloat(nframe))**2),
         -  naabmin,naabmax
          bsum=0.d0
          aabsum=0.d0
          bsum2=0.d0
          aabsum2=0.d0
          do ifr=1,nframe
            bsum=bsum+scres(1,ifr)
            bsum2=bsum2+scres(1,ifr)**2
            aabsum=aabsum+scres(2,ifr)
            aabsum2=aabsum2+scres(1,ifr)**2
            data(ifr)=scres(1,ifr)
          end do
          avgbond=bsum/dfloat(nframe)
          avgaabond=aabsum/dfloat(nframe)
          bsd=dsqrt(bsum2/dfloat(nframe)-(bsum/dfloat(nframe))**2)
          aabsd=dsqrt(aabsum2/dfloat(nframe)-(aabsum/dfloat(nframe))**2)
          call batchmean(nframe,0,data,'Average # of bonds',18,iw0,0,av,sd,
         -  ci)
          if (nbondavg .gt. 1) then
            nfr=nframe/nbondavg
            incr=0
            do iaa=1,nfr
              nbsum=0
              nbaasum=0
              do ia=incr+1,incr+nbondavg
                nbsum=nbsum+scres(1,ia)
                nbaasum=nbaasum+scres(2,ia)
              end do
              scres(1,iaa)=float(nbsum)/float(nbondavg)
              scres(2,iaa)=float(nbaasum)/float(nbondavg)
              xtrajmod(iaa)=xtraj(incr+nbondavg)
              incr=incr+nbondavg
            end do
            write (remark,2004) nbondavg,avgbond,bsd
            lremark=65
          else
            nfr=nframe
            call trnsfr(xtrajmod,xtraj,nframe)
            write (remark,2005) avgbond,bsd
            lremark=22
          end if
          if (ci .ne. 999.0) then
            write (remark(lremark+1:lremark+15),2008) ci
            lremark=lremark+15
          end if
          if (nplot .eq. 2) then
            write (remark(lremark+1:lremark+14),2006) avgaabond,aabsd
            lremark=lremark+25
          end if
          llabel=16+lbondtype
          label(1:llabel)='Number of '//bondtype(1:lbondtype)//' bonds'
          call plot2fun(iw1,nplot,xtrajmod,scres,scres,nfr,0.0,0.0,0,0.0,
         -  float(iyd),nyd,0.0,float(iyd2),nyd2,title,80,remark,lremark,
         -  xtrajlab,lxtrajlab,label,llabel,'Number of anchor-anchor bonds',
         -  29,1,0,6,2,1,0,0,iyinc,0,ipspage,1,1,0)
          if (ibondcorr .gt. 0 .and. nbfoundorig .gt. mx2d) then
            write (6,2000) nbfoundorig,mx2d
            ibondcorr=0
          end if
          if (ibondcorr .gt. 0) then
            ireadwrite=1
            ifhb2d(1)=1
            ilhb2d(1)=nbfound
            call bondcorrsum(nbfoundorig,0,scpmin,scpmax,it1,it2,it3,
         -    correxp,icorrtyp,icorrtrans,0,icorrbothstart,nframeav,0,
         -    iw0,mx2d)
            call bondcorrprint(nbfound,iw0,line,index,iresno,index2d,
         -    correxp,icorrtyp,icorrtrans,nframeav,nhbdist,ifhb2d,ilhb2d,
         -    ixclst,rhbcorrclust,nhbcorrclust,0,inamcol1,inamcol2,irescol1,
         -    irescol2,nhneigmin,hblimfac,angmin,rhph_sltbmax,percminb,
         -    percmaxb,minresdistb,maxresdistb,numres,1,nframe,bondtype,
         -    lbondtype,0,ixresno,resnames,maxrec,mxbonds)
            call plotbondcorr(iw1,nbfound,yclab,lyclab,0,index2d,
         -    title,temp,itemp2,lablim,ncolcode,maxcolcode,ipspage,0)
            rhbcorrclustdef=(scpmax-scpmin)/2.0
            call clusterdistr(nbfound,iw0,rmsdlim,scpmin,scpmax,nhbdist,it1,
         -    it2,it3,it4,ifhb2d,ilhb2d,nhbcorrclust,indexa,index2d,
         -    ixclst,it5,value,ifa_s,ila_s,ih,temp,rhbcorrclustdef,
         -    rhbcorrclust,res(1,1,11),0,'Correlation-based distance',26,0,
         -    0,irepav,irepmx,irepeng,irepkm,engcl,c,ct1,ct2,1,27,
         -    iclstyp,nrrbond,1,label2d,80,0,1,nosortindex2d,1,mxbonds,
         -    maxframe)
            call plotbond(iw1,nbfoundorig,nbfound,nbresfound,nhbcorrclust,
         -    ianc_anc,ifhb2d,ilhb2d,index2d,indexs,it1,it2,rhbcorrclust,
         -    iclstyp,xtraj(nframe),10,title,ltitle,xtrajlab,lxtrajlab,
         -    'Bond #',6,1,percminb,percmaxb,numres,minresdistb,maxresdistb,
         -    rhph_sltbmax,bondtype,lbondtype,1,nhneigmin,nbondmax,
         -    naabondmax,icorrtyp,icorrtrans,nframeav,correxp,hblimfac,
         -    angmin,lablim,ibondtype,1,it3,ixresno,itemp3,ixres,
         -    nrrbond,atnames,resnames,npspages,ipspage,mxbonds,maxrsd,
         -    maxrec)
            call bondcorrprint(nbfound,iw0,line,index,iresno,index2d,
         -    correxp,icorrtyp,icorrtrans,nframeav,nhbdist,ifhb2d,ilhb2d,
         -    ixclst,rhbcorrclust,nhbcorrclust,1,inamcol1,inamcol2,irescol1,
         -    irescol2,nhneigmin,hblimfac,angmin,rhph_sltbmax,percminb,
         -    percmaxb,minresdistb,maxresdistb,numres,0,nframe,bondtype,
         -    lbondtype,0,ixresno,resnames,maxrec,mxbonds)
            call askyn(
         -    'Do yo want to repeat clustering with different filters',
         -     54,1,-1,irepscan,0,0)
            if (irepscan .eq. 1) then
              nbfound=nbfoundorig
              go to 8005
            end if
          end if
          call mapbondstorespairs(nbfound,nbfoundorig,nbresfilt,nbresfound,
         -  nframe,ixres,it1,bondtype,lbondtype,line,index,irescol1,
         -  irescol2,nresslt,percminb,percmaxb,minresdistb,maxresdistb,
         -  percminr,percmaxr,minresdistr,maxresdistr,ifres,
         -  iresno,isegno,nochange,index2d,ifa_s,ila_s,itemp1,itemp2,itemp3,
         -  iw0,mxbonds,maxrsd,maxrec)
          call condensetracks(nbfoundorig,nbresfilt,it1,it2,iw0,mxbonds)
          call res_res_bond(nres2d,nbfound,index2d,nhbdist,iresno,ixres,
         -  ifres,isegno,irrix,itemp2,itemp3,title,ltitle,bondtype,
         -  lbondtype,line,index,irescol1,irescol2,iresshift,iw0,iw1,
         -  ipspage,ncolcode,maxcolcode,mxbonds,maxrsd,maxrec)
          call plotbond(iw1,nbfoundorig,nbfound,nbresfilt,nhbcorrclust,
         -  ianc_anc,ifhb2d,ilhb2d,index2d,indexs,it1,it2,rhbcorrclust,0,
         -  xtraj(nframe),10,title,ltitle,xtrajlab,lxtrajlab,
         -  'Residue pair #',14,1,percminr,percmaxr,numres,minresdistr,
         -  maxresdistr,rhph_sltbmax,bondtype,lbondtype,0,nhneigmin,
         -  nbondmax,naabondmax,icorrtyp,icorrtrans,nframeav,correxp,
         -  hblimfac,angmin,lablim,ibondtype,2,it3,ixresno,irrix,ixres,
         -  nrrbond,atnames,resnames,npspages,ipspage,mxbonds,maxrsd,maxrec)
          if (iresbondcorr .gt. 0) then
            call bondcorrsum(nbfoundorig,nbresfilt,scpmin,scpmax,it1,it2,
         -    it3,correxp,icorrtyp,icorrtrans,1,icorrbothstart,
         -    nframeav,1,iw0,mx2d)
            call indexit(itemp1,1,nbresfilt,0)
            call makebondlab(1,nbresfilt,0,2,yclab,lyclab,irrix,ixresno,
         -    ixres,itemp1,resnames,atnames,nbresfilt,mxbonds,maxrsd,maxrec)
            call plotbondcorr(iw1,nbresfilt,yclab,lyclab,1,itemp1,title,
         -    temp,itemp2,lablim,ncolcode,maxcolcode,ipspage,0)
            rhbcorrclustdef=(scpmax-scpmin)/2.0
            ifhb2d(1)=1
            ilhb2d(1)=nbresfound
            call clusterdistr(nbresfilt,iw0,rmsdlim,scpmin,scpmax,nhbdist,
         -    it1,it2,it3,it4,ifhb2d,ilhb2d,nhbcorrclust,indexa,irrix,
         -    ixclst,it5,value,ifa_s,ila_s,ih,temp,rhbcorrclustdef,
         -    rhbcorrclust,res(1,1,11),0,'Correlation-based distance',26,0,
         -    0,irepav,irepmx,irepeng,irepkm,engcl,c,ct1,ct2,1,27,
         -    iclstyp,nrrbond,1,label2d,80,0,1,nosortindex2d,0,mxbonds,
         -    maxframe)
            call bondcorrprint(nbresfilt,iw0,line,index,iresno,irrix,
         -    correxp,icorrtyp,icorrtrans,nframeav,nhbdist,ifhb2d,ilhb2d,
         -    ixclst,rhbcorrclust,nhbcorrclust,1,inamcol1,inamcol2,irescol1,
         -    irescol2,nhneigmin,hblimfac,angmin,rhph_sltbmax,percminr,
         -    percmaxr,minresdistr,maxresdistr,numres,1,nframe,bondtype,
         -    lbondtype,1,ixresno,resnames,maxrec,mxbonds)
            call plotbond(iw1,nbfoundorig,nbfound,nbresfilt,nhbcorrclust,
         -    ianc_anc,ifhb2d,ilhb2d,ixclst,indexs,it1,it2,rhbcorrclust,
         -    iclstyp,xtraj(nframe),10,title,ltitle,xtrajlab,lxtrajlab,
         -    'Residue pair #',14,1,percminr,percmaxr,numres,minresdistr,
         -    maxresdistr,rhph_sltbmax,bondtype,lbondtype,0,nhneigmin,
         -    nbondmax,naabondmax,icorrtyp,icorrtrans,nframeav,correxp,
         -    hblimfac,angmin,lablim,ibondtype,2,it3,ixresno,irrix,
         -    ixres,nrrbond,atnames,resnames,npspages,ipspage,mxbonds,
         -    maxrsd,maxrec)
          end if
          call askyn(
         -  'Do you want to calculate residue-residue autocorrelation',56,
         -   1,-1,iauc,0,0)
          if (iauc .eq. 1)
         -  call autocorr_res_res(nbresfilt,nframe,iframeunit,
         -    framefac*increment,itrack,nhbdist,nhbpers,maxlenon,
         -    maxlenoff,itrackf,itrackl,ifres,iresno,isegno,resnames,
         -    irescol2-irescol1+1,it2,it3,iuselaston,iw0,mxbonds,MAXFRAMES,
         -    maxrsd,maxrec)
          return
    2000  format(' ERROR: the number of bonds found (',i5,') exceeds the',
         -  ' limit (',i5,')',/,' either increase the parameter MAX2D and ',
         -  ' recompile Simulaid',/,' or select fewer atoms to analyze')
    2001  format(' NOTE: no bonds were found')
    2002  format(' Full autocorrelation functions were written to file',/,
         -  1x,a)
    2003  format(' Average number of',a,a,' bonds/frame=',f6.1,' S.D.=',
         -  f5.1,/,' Range: [',i4,',',i4,']')
    2004  format(' Number of bonds averaged over',i5,' frames; <NB>=',f5.1,
         -  ' S.D.=',f5.1)
    2005  format(' <NB>=',f5.1,' S.D.=',f5.1)
    2006  format('; <NBaa>=',f5.1,' S.D.=',f5.1)
    2007  format(' Maximum number of ',a,' bonds=',i5,' at frame# ',i8)
    2008  format(' CI(1sig)=',f5.1)
          end
          subroutine condensetracks(nbfoundorig,nbres,ibframe,ibframe_rr,
         -  iout,mxbonds)
          dimension ibframe(mxbonds),ibframe_rr(mxbonds)
          parameter (MAXFRAMES=50000,MAXCOPY=600,MAXITEMS=2*MAXCOPY-2)
          common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
         -  increment,increment2,ires(MAXITEMS,MAXFRAMES),
         -  scres(2,MAXFRAMES),x0(MAXCOPY),y0(MAXCOPY),nxselres,
         -  ixselres(MAXCOPY)
          parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
          parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
         -  (6*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
          common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),ing(MAX2D,MAX2D),
         -  ihbtores(MAXBONDS),nusepair(MAXBONDS),nhb_atot(MAXBONDS),
         -  nhb_rtot(MAXBONDS),ibond(MAXBONDS),a1(MAXBONDS),fill(IFILL2)
          write (iout,2000) nbfoundorig,nbres
          do ifr=1,nframe
            call zeroiti(ibframe_rr,0,nbres)
            call readbitc(ires(1,ifr),ibframe,nbfoundorig,30,MAXITEMS)
            do ib=1,nbfoundorig
              ibb=ihbtores(ib)
              if (ibframe(ib)*ibb .gt. 0) ibframe_rr(ibb)=1
            end do
            call savebitc(ires(1,ifr),ibframe_rr,nbres,30,MAXITEMS)
          end do
          return
    2000  format(' Bond tracks of ',i4,' bonds condensed to ',i3,
         - ' res-res tracks')
          end
          subroutine mapbondstorespairs(nbfound,nbfoundorig,nbresfound,
         -  nbresorig,nframe,ixres,indexres,bondname,lbondname,line,index,
         -  irescol1,irescol2,nresslt,percmind,percmaxd,minresdistd,
         -  maxresdistd,percmin,percmax,minresdist,maxresdist,ifres,iresno,
         -  isegno,nochange,indexbond,ifa,ila,itemp1,itemp2,itemp3,iout,
         -  mxbonds,maxrsd,maxrec)
          dimension index(maxrec),ixres(maxrec),indexbond(maxrsd),
         -  indexres(mxbonds),ifres(maxrec),iresno(maxrec),isegno(maxrec),
         -  ifa(mxbonds),ila(mxbonds),itemp1(maxrec),itemp2(maxrec),
         -  itemp3(maxrec)
          character* 132 line(maxrec)
          character*(*) bondname
          parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
          parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
         -  (6*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
          common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),ing(MAX2D,MAX2D),
         -  ihbtores(MAXBONDS),nusepair(MAXBONDS),nhb_atot(MAXBONDS),
         -  nhb_rtot(MAXBONDS),ibond(MAXBONDS),a1(MAXBONDS),fill(IFILL2)
          common /bondpairs/ ihbpair(2,MAXBONDS),ihb_pair_res(3,MAXBONDS)
          call indexit(indexbond,1,nbfoundorig,0)
          write (6,1005)
          write (iout,1007)
          write (iout,1022) nbresorig,bondname(1:lbondname)
          call askyn(
         -  'Do yo want to filter the residue-aggregated bonds',49,1,1,
         -  ifiltrr,83,0)
          if (ifiltrr .eq. 1) then
            call getfiltlims(percmind,percmaxd,minresdistd,maxresdistd,
         -    percmin,percmax,minresdist,maxresdist,nresslt,nochange,
         -    bondname,lbondname,' res-res ',9,iout)
            write (iout,1020) 'filtered out'
            ndel=0
            do irr=1,nbresorig
              ir1=ihb_pair_res(1,irr)
              ir2=ihb_pair_res(2,irr)
              perc=100.0*float(ihb_pair_res(3,irr))/float(nframe)
              irdiff=iabs(ir1-ir2)
              if (perc .lt. percmin .or. perc .gt. percmax .or.
         -      irdiff .lt. minresdist .or. irdiff .gt. maxresdist) then
                ndel=ndel+1
                ia1=ifres(ir1)
                ia2=ifres(ir2)
                write (iout,1002) irr,iresno(ia1),
         -        line(index(ia1))(irescol1:irescol2),isegno(ia1),
         -        iresno(ia2),line(index(ia2))(irescol1:irescol2),
         -        isegno(ia2),perc
              else
                ihb_pair_res(1,irr-ndel)=ihb_pair_res(1,irr)
                ihb_pair_res(2,irr-ndel)=ihb_pair_res(2,irr)
                ihb_pair_res(3,irr-ndel)=ihb_pair_res(3,irr)
              end if
            end do
            nbresfound=nbresorig-ndel
            write (6,1011) nbresfound,nbresorig
            write (iout,1011) nbresorig,nbresfound
            do irr=1,ndel
              ihb_pair_res(3,nbresfound+irr)=0
            end do
            ndel=0
            do ib=1,nbfoundorig
              ihb=indexbond(ib)
              ir1=ixres(ihbpair(1,ihb))
              ir2=ixres(ihbpair(2,ihb))
              ifound=0
              do irr=1,nbresfound
                if ((ir1 .eq. ihb_pair_res(1,irr) .and.
         -           ir2 .eq. ihb_pair_res(2,irr)) .or.
         -          (ir2 .eq. ihb_pair_res(1,irr) .and.
         -           ir1 .eq. ihb_pair_res(2,irr))) then
                  ifound=1
                  go to 100
                end if
              end do
    100       if (ifound .eq. 0) then
                ndel=ndel+1
              else
                indexbond(ib-ndel)=indexbond(ib)
              end if
            end do
            nbfound=nbfoundorig-ndel
            write (6,1023) bondname(1:lbondname),nbfoundorig,nbfound
            write (iout,1023) bondname(1:lbondname),nbfoundorig,nbfound
          else
            nbfound=nbfoundorig
          end if
          nbuse=nbfound
          call zeroiti(ihbtores,0,nbfoundorig)
          call zeroiti(nusepair,0,nbresorig)
          call indexit(itemp1,1,nbresorig,0)
          do ibb=1,nbuse
            ib=indexbond(ibb)
            ir1=ixres(ihbpair(1,ib))
            ir2=ixres(ihbpair(2,ib))
            do irr=1,nbresfound
              if (ihb_pair_res(1,irr) .eq. ir1) then
                if (ihb_pair_res(2,irr) .eq. ir2) then
                  ihbtores(ib)=irr
                  nusepair(irr)=nusepair(irr)+1
                  go to 200
                end if
              end if
            end do
            if (nochange .eq. 1) then
              write (6,1000) (ihbpair(k,ib),k=1,2),ir1,ir2
              write (iout,1000) (ihbpair(k,ib),k=1,2),ir1,ir2
            end if
    200     continue
          end do
          do irr=1,nbresfound
            itemp2(irr)=ihb_pair_res(1,irr)
          end do
          call indexit(indexres,1,nbresfound,0)
          call mrgsrti(6,indexres,itemp2,nbresfound,ifa,ila,itemp1,itemp3,
         -  mxbonds)
          write (iout,1020)
         -  'kept - sequence numbers also refer to the bond track #'
          do ipp=1,nbresfound
            ip=indexres(ipp)
            ir1=ihb_pair_res(1,ip)
            ir2=ihb_pair_res(2,ip)
            ia1=ifres(ir1)
            ia2=ifres(ir2)
            perc=100.0*float(ihb_pair_res(3,ip))/float(nframe)
            write (iout,1002) ipp,iresno(ia1),
         -    line(index(ia1))(irescol1:irescol2),isegno(ia1),iresno(ia2),
         -    line(index(ia2))(irescol1:irescol2),isegno(ia2),perc,' ',
         -    nusepair(ipp)
          end do
          write (iout,*)
          return
    1000  format(' PROGRAM ERROR: bond between atoms',i6,i7,' (residue ',
         -  'indices',i5,i6,')'/,' is not found in the residue pair list')
    1002  format(i6,' Bonded % of residues',i6,' (',a,') C/S',i2,' and',i6,
         -  ' (',a,') C/S',i2,'=',f5.1,a,' Nbonds=',i3)
    1005  format(/,' Generating residue-contracted bond information')
    1007  format(/,' === Residue-contracted bond information:')
    1011  format(' Number of residue-residue pairs filtered down from',i6,
         -  ' to',i5)
    1020  format(/,' List of residue-residue pairs ',a)
    1022  format(' There are ',i4,' residue-residue pairs with ',a,' bonds')
    1023  format(' After res-res filtering the number of ',a,' bonds',/,
         -  ' changed from',i6,' to',i5)
          end
          subroutine autocorr_res_res(nbres,nframe,iframeunit,
         -  framefac,itrack,nhbdist,nhbpers,maxlenon,maxlenoff,
         -  itrackf,itrackl,ifres,iresno,isegno,resnames,nrescol,
         -  it1,it2,iuselaston,iout,mxbonds,mxframes,mxrsd,mxrec)
          dimension itrack(mxframes),
         -  nhbdist(mxbonds),nhbpers(mxbonds),maxlenon(mxbonds),
         -  maxlenoff(mxbonds),itrackf(mxbonds),itrackl(mxbonds),
         -  ifres(mxrsd),iresno(mxrec),isegno(mxrec),it1(mxbonds),
         -  it2(mxbonds)
          character*8 resnames(mxrsd)
          parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
          parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
         -  (6*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
          common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),ing(MAX2D,MAX2D),
         -  ihbtores(MAXBONDS),iusepair(MAXBONDS),nhb_atot(MAXBONDS),
         -  nhb_rtot(MAXBONDS),a1(MAXBONDS),a2(MAXBONDS),fill(IFILL2)
          common /bondpairs/ ihbpair(2,MAXBONDS),ihb_pair_res(3,MAXBONDS)
          parameter (MAXFRAMES=50000,MAXCOPY=600,MAXITEMS=2*MAXCOPY-2)
          nreusemax=nframe
          call auc_params(iauctype,lastframeinp,loffmin,nreusemax,
         -  nseg_scr,iaucw,nframe,iframeunit,framefac,'Residue-residue',15,
         -  iuselaston,iout,mxframes)
          call trackstat(nbres,nhbdist,nhbpers,maxlenon,maxlenoff,itrackf,
         -  itrackl,it1,it2)
          nauc_extra=0
          do irr=1,nbres
            ir1=ihb_pair_res(1,irr)
            ir2=ihb_pair_res(2,irr)
            perc=100.0*float(ihb_pair_res(3,irr))/float(nframe)
            ia1=ifres(ir1)
            ia2=ifres(ir2)
            write (iout,2000) irr,
         -    resnames(ir1)(1:nrescol),iresno(ia1),isegno(ia1),
         -    resnames(ir2)(1:nrescol),iresno(ia2),isegno(ia2),perc
            call persistence(nhbdist(irr),nhbpers(irr),itrackf(irr),
         -    itrackl(irr),maxlenon(irr),maxlenoff(irr),iframeunit,
         -    framefac,nframe,iuselaston,iout)
            call getbondtrack(irr,itrack,ifirstframe,lastframe,30,nframe)
            call autocorr(irr,irr,itrack,ifirstframe,lastframe,iframeunit,
         -    framefac,iauctype,lastframeinp,nreusemax,percon,loffmin,
         -    nseg_scr,nauc_extra,nframe,iout,mxframes)
          end do
          return
    2000  format(' RR#',i4,1x,a,i5,' C/S',i2,' - ',a,i5,' C/S',i2,
         -  ' perc=',f5.1)
          end
          subroutine writetrack(iout_track,iout,nbits,ntracks,nres2d,
         -  trackfile,ltrackfile,ianc_anc)
          dimension ianc_anc(ntracks)
          character*(*) trackfile
          parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
          parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
         -  (6*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
          common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),ing(MAX2D,MAX2D),
         -  ihbtores(MAXBONDS),nusepair(MAXBONDS),nhb_atot(MAXBONDS),
         -  nhb_rtot(MAXBONDS),a1(MAXBONDS),a2(MAXBONDS),fill(IFILL2)
          common /bondpairs/ ihbpair(2,MAXBONDS),ihb_pair_res(3,MAXBONDS)
          parameter (MAXFRAMES=50000,MAXCOPY=600,MAXITEMS=2*MAXCOPY-2)
          common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
         -  increment,increment2,ires(MAXITEMS,MAXFRAMES),
         -  scres(2,MAXFRAMES),x0(MAXCOPY),y0(MAXCOPY),nxselres,
         -  ixselres(MAXCOPY)
          character*200 trajnam,trajnam2
          common /trajname/ trajnam,trajnam2,ltrajnam,ltrajnam2,ifirsttraj,
         -  ifirsttraj2,ilasttraj,ilasttraj2,incrementtraj,incrementtraj2
          dimension itrack(MAXFRAMES)
          write (iout_track,1000) trajnam(1:ltrajnam)
          write (iout_track,1001)nframe,ntracks,nres2d,firsttraj,ilasttraj,
         -  incrementtraj
          do itr=1,ntracks
            call zeroiti(itrack,0,nframe)
            ii=(itr-1)/nbits+1
            ib=mod(itr-1,nbits)
            do ifr=1,nframe
              if (btest(ires(ii,ifr),ib)) itrack(ifr)=1
            end do
            write (iout_track,1006) itr,(ihbpair(k,itr),k=1,2),
         -    ianc_anc(itr),(itrack(ifr),ifr=1,nframe)
          end do
          write (iout,1002) trackfile(1:ltrackfile),nframe,ntracks
          close (iout_track)
          return
    1000  format(a)
    1001  format(6i7)
    1002  format(' Bond tracks were written to file ',a,/,
         -  ' Number of frames=',i7,/,' Number of tracks=',i5)
    1006  format(' TRACK#',i5,' ia1=',i7,' ia2=',i7,' iAA=',i1,/,(100i1))
          end
          subroutine readtrack(iout_track,iout,nbits,nbfound,nbresfound,
         -  nres2d,ixres,trackfile,ltrackfile,ianc_anc,ifail,maxrec)
          dimension ixres(maxrec),ianc_anc(nbfound)
          character*(*) trackfile
          parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
          parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
         -  (6*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
          common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),ing(MAX2D,MAX2D),
         -  ihbtores(MAXBONDS),nusepair(MAXBONDS),nhb_atot(MAXBONDS),
         -  nhb_rtot(MAXBONDS),itempres(MAXBONDS),a2(MAXBONDS),fill(IFILL2)
          common /bondpairs/ ihbpair(2,MAXBONDS),ihb_pair_res(3,MAXBONDS)
          parameter (MAXFRAMES=50000,MAXCOPY=600,MAXITEMS=2*MAXCOPY-2)
          common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
         -  increment,increment2,ires(MAXITEMS,MAXFRAMES),
         -  scres(2,MAXFRAMES),x0(MAXCOPY),y0(MAXCOPY),nxselres,
         -  ixselres(MAXCOPY)
          character*200 trajnam,trajnam2
          common /trajname/ trajnam,trajnam2,ltrajnam,ltrajnam2,ifirsttraj,
         -  ifirsttraj2,ilasttraj,ilasttraj2,incrementtraj,incrementtraj2
          dimension itrack(MAXFRAMES)
          itr=0
          call blankout(trajnam,1,200)
          read (iout_track,1000,end=888,err=888) trajnam
          call lastchar(trajnam,ltrajnam,200)
          nres2d=0
          read (iout_track,1001,end=100,err=100) nframe,ntracks,nres2d,
         -  ifirsttraj,ilasttraj,incrementtraj
    100   if (nres2d .eq. 0) go to 888
          nframetot=nframe
          nbfound=ntracks
          do itr=1,ntracks
            call zeroiti(itrack,0,nframe)
            read (iout_track,1004,end=888,err=888) itrr,
         -    (ihbpair(k,itr),k=1,2),ianc_anc(itr),
         -    (itrack(ifr),ifr=1,nframe)
            ii=(itr-1)/nbits+1
            ib=mod(itr-1,nbits)
            do ifr=1,nframe
              if (itrack(ifr) .eq. 1)
         -      ires(ii,ifr)=ibset(ires(ii,ifr),ib)
            end do
            ir1=ixres(ihbpair(1,itr))
            ir2=ixres(ihbpair(2,itr))
            ihb=1
            do while (ihb .le. nbresfound .and.
         -    (ir1 .ne. ihb_pair_res(1,ihb) .or.
         -     ir2 .ne. ihb_pair_res(2,ihb)))
              ihb=ihb+1
            end do
            if (ihb .gt. nbresfound) then
              nbresfound=nbresfound+1
              ihb_pair_res(1,nbresfound)=ir1
              ihb_pair_res(2,nbresfound)=ir2
              ihb_pair_res(3,nbresfound)=1
              ihb_pair_res(3,nbresfound+1)=0
              itempres(nbresfound)=1
            else if (itempres(ihb) .eq. 0) then
              ihb_pair_res(3,ihb)=ihb_pair_res(3,ihb)+1
              itempres(ihb)=1
            end if
          end do
          write (iout,1002) trackfile(1:ltrackfile)
          write (iout,1003) nframe,ntracks,nbresfound
          write (6,1003) nframe,ntracks,nbresfound
          call write_traj_lim(iout,' ',0,1,incr_tr,0)
          close (iout_track)
          ifail=0
          return
    888   if (itr .eq. 0) write (6,1005)
          if (itr .gt. 0) write (6,1006) itr
          return
    1000  format(a)
    1001  format(6i7)
    1002  format(' Bond tracks were read from file ',a)
    1003  format(' Number of frames=',i7,/,' Number of tracks=',i5,/,
         -  ' Number of residue-residue pairs=',i4)
    1004  format(' TRACK#',i5,' ia1=',i7,' ia2=',i7,' iAA=',i1,/,(100i1))
    1005  format(' ERROR reading the track file header')
    1006  format(' ERROR reading track # ',i5)
          end
          subroutine writeconn(ioutpdb,ifres,ilres,line,index,inamcol1,
         -  inamcol2,c,n,iresbondcorr,nrrbond,nframe,iout,mxbonds,maxrsd,
         -  maxrec)
          dimension ifres(maxrsd),ilres(maxrsd),index(maxrec),c(3,maxrec),
         -  nrrbond(mxbonds)
          character* 132 line(maxrec)
          parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
          parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
         -  (6*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
          common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),ing(MAX2D,MAX2D),
         -  ihbtores(MAXBONDS),nusepair(MAXBONDS),nhb_atot(MAXBONDS),
         -  nhb_rtot(MAXBONDS),ibond(MAXBONDS),a1(MAXBONDS),fill(IFILL2)
          common /bondpairs/ ihbpair(2,MAXBONDS),ihb_pair_res(3,MAXBONDS)
          dimension cHe(3)
          lname=inamcol2-inamcol1+1
          if (lname .lt. 1) then
            print *,'PROGRAM ERROR inamcol1,2=',inamcol1,inamcol2
            stop
          end if
          nnoCA=0
          nrr=1
          nrw=0
          corrmax=0.0
          corrmin=1.0
          iconncorr=0
          iconnacorr=0
          if (iresbondcorr .eq. 1) then
            call askyn('Do you want to connect correlated bonds',39,1,-1,
         -    iconncorr,00,0)
            if (iconncorr .eq. 1) then
              call getreal(
         -      'Maximum (correlation) distance measure',38,1.0,corrmax,1,0)
              write (iout,2003) ' ','<',corrmax
              write (ioutpdb,2003) 'REMARK ','<',corrmax
            else
              call askyn('Do you want to connect anti-correlated bonds',44,
         -      1,-1,iconnacorr,00,0)
              if (iconnacorr .eq. 1) then
                call getreal(
         -        'Minimum (correlation) distance measure',38,1.0,corrmin,
         -        1,0)
                write (iout,2003) ' ','>',corrmin
                write (ioutpdb,2003) 'REMARK ','>',corrmin
              end if
            end if
          end if
          if (iconncorr+iconnacorr .gt. 0) then
            write (ioutpdb,1000) 'TER'
            do while (ihb_pair_res(3,nrr) .gt. 0 .and. nrr .le. MAXBONDS)
              irr1=ihb_pair_res(1,nrr)
              call findCA(line,index,ifres(irr1),ilres(irr1),inamcol1,
         -      inamcol2,iCA1,nnoCA,maxrec)
              irr2=ihb_pair_res(2,nrr)
              call findCA(line,index,ifres(irr2),ilres(irr2),inamcol1,
         -      inamcol2,iCA2,nnoCA,maxrec)
              do k=1,3
                cHe(k)=(c(k,iCA1)+c(k,iCA2))/2.0
              end do
              nrw=nrw+1
              write (ioutpdb,1001) n+nrw,nrw,cHe,
         -      float(nrrbond(nrw))/float(nframe)
              nrr=nrr+1
            end do
            write (ioutpdb,1000) 'TER'
            do ir1=1,nrw
              do ir2=ir1+1,nrw
                if (rmsd2d(ir1,ir2) .gt. corrmin .or.
         -        rmsd2d(ir1,ir2) .lt. corrmax)
         -          write (ioutpdb,2001) n+ir1,n+ir2
              end do
            end do
            if (nnoCA .gt. 0) write (6,2000) nnoCA
            if (nnoCA .gt. 0) write (iout,2000) nnoCA
          else
            do while (ihb_pair_res(3,nrr) .gt. 0 .and. nrr .le. MAXBONDS)
              nrr=nrr+1
            end do
          end if
          write (ioutpdb,1000) 'REMARK CA - CA bonds'
          do irr=1,nrr
            irr1=ihb_pair_res(1,irr)
            call findCA(line,index,ifres(irr1),ilres(irr1),inamcol1,
         -    inamcol2,iCA1,nnoCA,maxrec)
            irr2=ihb_pair_res(2,irr)
            call findCA(line,index,ifres(irr2),ilres(irr2),inamcol1,
         -    inamcol2,iCA2,nnoCA,maxrec)
            write (ioutpdb,2001) iCA1,iCA2
            write (iout,2004) irr1,irr2,iCA1,iCA2
          end do
          write (iout,2002) nrr
          return
    1000  format(a)
    1001  format('ATOM',i7,' He   HE  ','X',i4,4x,3f8.2,1x,f5.3,' 0.000',
         -  11x,'He')
    2000  format(' NOTE:',i4,' residues had no CA atom - first atom in ',
         -  'the residue is used')
    2001  format('CONECT',2i5)
    2002  format(' Number of CA-CA bonds created=',i4)
    2003  format(a,' Bonds created between CA-CA pairs with correlation ',
         -  'measure ',a,f6.2)
    2004  format(' CA - CA bonds between residues',i6,' and',i6,' (atom ',
         -  'numbers',2i7)
          end
          subroutine findCA(line,index,ifr,ilr,inamcol1,inamcol2,iCA,nnoCA,
         -  maxrec)
          dimension index(maxrec)
          character* 132 line(maxrec)
          character*8 aname
          iCA=0
          do ia=ifr,ilr
            aname(1:inamcol2-inamcol1+1)=line(index(ia))(inamcol1:inamcol2)
            if (aname(1:4) .eq. 'CA  ' .or. aname(1:4) .eq. ' CA ') iCA=ia
          end do
          if (iCA .eq. 0) then
            iCA=ifr
            nnoCA=nnoCA+1
          end if
          return
          end
          subroutine rmsdckp(iunit,ireadwrite)
          parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
          parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-MAX2D*MAX2D)
          common /nnwork/ rmsd2d(MAX2D,MAX2D),fill(IFILL2)
          if (ireadwrite .eq. 1) then
            write (iunit) rmsd2d
          else
            read (iunit,end=999) rmsd2d
          end if
          return
    999   print *,'ERROR: 2D-RMMSD checkpoint file was too short'
          stop
          end
          subroutine readint(line,icol1,icol2,intg,ihextyp,istop,ierr)
          character*(*) line
          common /askhex/ iaskhex(4),ishex(4)
          character*1 tab,ctrlM
          common /tab/ tab,ctrlM
          common /logging/ logfile,ipredict
          character*14 inplab(4)
          data inplab /'atom number   ','residue number','residue id    ',
         -  'data          '/
          ierr=0
          if (icol1 .gt. icol2) then
            write (6,2001) inplab(ihextyp),icol1,icol2,line(1:icol2)
            stop
          end if
          nchars=0
          do ic=icol1,icol2
            if (line(ic:ic) .ne. ' ' .and. line(ic:ic) .ne. tab)
         -    nchars=nchars+1
          end do
          if (nchars .eq. 0) then
            intg=0
          else if (ishex(ihextyp) .eq. 0) then
            read (line(icol1:icol2),*,ERR=100) intg
          else
            intg=iconvhex(line(icol1:icol2),icol2-icol1+1)
          end if
          return
    100   if (iaskhex(ihextyp) .eq. 1) then
            ishex(ihextyp)=ishexadecimal(line(icol1:icol2),icol2-icol1+1)
            if (ishex(ihextyp) .eq. 0) then
              write (6,2000) inplab(ihextyp),icol1,icol2,line
              ierr=1
              if (istop .eq. 1) stop
            else
              print *,'Input ',inplab(ihextyp),' appears to be hexadecimal'
              if (ipredict .eq. 0)
         -      call askyn('Is this correct',15,1,1,ishex(ihextyp),00,0)
              iaskhex(ihextyp)=0
              intg=iconvhex(line(icol1:icol2),icol2-icol1+1)
            end if
          else
            write (6,2000) inplab(ihextyp),icol1,icol2,line
            ierr=1
            if (istop .eq. 1) stop
          end if
          return
    2000  format(' ERROR: Invalid integer was read for ',a,/,
         -  8x,'Column range: [',i3,',',i3,':]; the line read:'/,a)
    2001  format(' PROGRAM ERROR in readint: icol1 > icol2 (',2i3,')',
         -  ' the line read was:'/,a)
          end
          subroutine delphigrid(iu,iu1,iu2,c,n,nslt,xstart,ystart,zstart,
         -  gx,gy,gz,ngx,ngy,ngz,igincr,rnear,igridfile,iexcl,iquery,
         -  interpol)
          dimension c(3,n)
          parameter (MAXPHI=400)
          common /nnwork/ phimap(MAXPHI,MAXPHI,MAXPHI)
          character*1 xyz
          common /axislab/ xyz(3)
          dimension xyzmin(3),xyzmax(3)
          if (iquery .eq. 1) then
            x=0.0
            do while (x .ne. 999.0)
              call getreal('X coordinate (999 to quit)',26,999999.0,x,0,0)
              if (x .ne. 999.0) then
                call getreal('Y coordinate',12,999999.0,y,0,0)
                call getreal('Z coordinate',12,999999.0,z,0,0)
                call interpolate(x,y,z,gx,gy,gz,xstart,ystart,zstart,phi)
              write (6,1000) x,y,z,phi
              end if
            end do
          end if
          if (igridfile .eq. 1) then
    101     call getreal('Grid X coordinate minimum',25,xstart,xgmin,0,0)
            call getreal('Grid X coordinate maximum',25,xstart+ngx*gx,xgmax,
         -    0,0)
            ixgmin=(xgmin-xstart)/gx-1
            if (ixgmin .lt. 1) ixgmin=1
            ixgmax=(xgmax-xstart)/gx+1
            if (ixgmax .gt. ngx) ixgmax=ngx
            if (ixgmin .gt. ixgmax) then
              print *,'Invalid X grid range:',ixgmin,ixgmax
              go to 101
            end if
    102     call getreal('Grid Y coordinate minimum',25,ystart,ygmin,0,0)
            call getreal('Grid Y coordinate maximum',25,ystart+ngy*gy,ygmax,
         -    0,0)
            iygmin=(ygmin-ystart)/gy-1
            if (iygmin .lt. 1) iygmin=1
            iygmax=(ygmax-ystart)/gx+1
            if (iygmax .gt. ngy) iygmax=ngy
            if (iygmin .gt. iygmax) then
              print *,'Invalid Y grid range:',iygmin,iygmax
              go to 102
            end if
    103     call getreal('Grid Z coordinate minimum',25,zstart,zgmin,0,0)
            call getreal('Grid Z coordinate maximum',25,zstart+ngz*gz,zgmax,
         -    0,0)
            izgmin=(zgmin-zstart)/gz-1
            if (izgmin .lt. 1) izgmin=1
            izgmax=(zgmax-zstart)/gx+1
            if (izgmax .gt. ngz) izgmax=ngz
            if (izgmin .gt. izgmax) then
              print *,'Invalid Z grid range:',izgmin,izgmax
              go to 103
            end if
            rnear2=0.0
            if (iexcl .eq. 1) then
              rnear2=rnear**2
              ncheck=0
              ndrop=0
              do k=1,3
                xyzmin(k)=10000.0
                xyzmax(k)=-xyzmin(k)
              end do
              ii=0
              do ia=1,nslt
                do k=1,3
                  if (c(k,ia) .lt. xyzmin(k)) xyzmin(k)=c(k,ia)
                  if (c(k,ia) .gt. xyzmax(k)) xyzmax(k)=c(k,ia)
                end do
                if (c(1,ia)+rnear .gt. xgmin .and.
         -          c(1,ia)-rnear .lt. xgmax .and.
         -          c(2,ia)+rnear .gt. ygmin .and.
         -          c(2,ia)-rnear .lt. ygmax .and.
         -          c(3,ia)+rnear .gt. zgmin .and.
         -          c(3,ia)-rnear .lt. zgmax) then
                  ncheck=ncheck+1
                  ixmin=(c(1,ia)-rnear-xstart)/gx-1
                  if (ixmin .lt. 1) ixmin=1
                  ixmax=(c(1,ia)+rnear-xstart)/gx+2
                  if (ixmax .gt. ngx) ixmax=ngx
                  iymin=(c(2,ia)-rnear-ystart)/gy-1
                  if (iymin .lt. 1) iymin=1
                  iymax=(c(2,ia)+rnear-ystart)/gy+2
                  if (iymax .gt. ngy) iymax=ngy
                  izmin=(c(3,ia)-rnear-zstart)/gz-1
                  if (izmin .lt. 1) izmin=1
                  izmax=(c(3,ia)+rnear-zstart)/gz+2
                  if (izmax .gt. ngz) izmax=ngz
                  do iz=izmin,izmax
                    do iy=iymin,iymax
                      do ix=ixmin,ixmax
                        ii=ii+1
                        x=xstart+(ix-1)*gx
                        y=ystart+(iy-1)*gy
                        z=zstart+(iz-1)*gz
                        dd=(x-c(1,ia))**2+(y-c(2,ia))**2+(z-c(3,ia))**2
                        if (dd. lt. rnear2 .and.
         -                  phimap(ix,iy,iz) .ne. 999999.9) then
                          phimap(ix,iy,iz)=999999.9
                          ndrop=ndrop+1
                        end if
                      end do
                    end do
                  end do
                end if
              end do
              write (6,2008) (xyz(k),xyzmin(k),xyzmax(k),k=1,3)
            end if
            ngw=0
            ngd=0
            write (6,1002) ncheck,nslt,ii,ndrop
            do iz=izgmin,izgmax,igincr
              do iy=iygmin,iygmax,igincr
                do ix=ixgmin,ixgmax,igincr
                  ngw=ngw+1
                  x=xstart+(ix-1)*gx
                  y=ystart+(iy-1)*gy
                  z=zstart+(iz-1)*gz
                  pm=phimap(ix,iy,iz)
                  if (pm .eq. 999999.9) then
                    pm=0.0
                    ngd=ngd+1
                  end if
                  if (abs(pm) .lt. 99.0) then
                    write (iu,1004) iz,x,y,z,pm
                  else
                    if (pm .lt. -999.0) pm=-999.0
                    if (pm .gt. 999.0) pm=999.0
                    write (iu,1010) iz,x,y,z,pm
                  end if
                  if (pm .ne. 0.0 .and. iu1 .gt. 0) then
                    if (abs(pm) .lt. 99.0) then
                      write (iu1,1004) iz,x,y,z,pm
                    else
                      if (pm .lt. -999.0) pm=-999.0
                      if (pm .gt. 999.0) pm=999.0
                      write (iu1,1010) iz,x,y,z,pm
                    end if
                  end if
                end do
              end do
            end do
            if (interpol .eq. 1) then
              call fillinterpolate(phimap,ixgmin,ixgmax,iygmin,iygmax,
         -     izgmin,izgmax,igincr,MAXPHI,MAXPHI,MAXPHI,999999.9,ninterpol)
              do iz=izgmin,izgmax,igincr
                do iy=iygmin,iygmax,igincr
                  do ix=ixgmin,ixgmax,igincr
                    x=xstart+(ix-1)*gx
                    y=ystart+(iy-1)*gy
                    z=zstart+(iz-1)*gz
                    pm=phimap(ix,iy,iz)
                    if (abs(pm) .lt. 99.0) then
                      write (iu2,1004) iz,x,y,z,pm
                    else
                      if (pm .lt. -999.0) pm=-999.0
                      if (pm .gt. 999.0) pm=999.0
                      write (iu2,1010) iz,x,y,z,pm
                    end if
                  end do
                end do
              end do
              write (6,1005) 'interpolated',ninterpol
              if (ninterpol .ne. ngd)
         -      print *,'ERROR in number of dropped/interpolated grids'
            end if
          end if
          write (6,1003) ngw
          if (iexcl .gt. 0)
         -   write (6,1005) 'dropped (or written with zero potentials)',ngd
          return
    1000  format(' phi(',f10.5,',',f10.5,',',f10.5,')=',f12.5)
    1002  format(' Checked ',i5,' atoms out of ',i6,'; Checked',i9,
         -  ' grids',/,' Number of grids found too close to atoms=',i8)
    1003  format(' Number of grid points written=',i7)
    1004  format('ATOM        He   GRD A ',i3,4x,3f8.3,'  1.00',f6.2)
    1005  format(' Number of ',a,' grid points=',i6)
    1010  format('ATOM        He   GRD A ',i3,4x,3f8.3,'  1.00',f6.1)
    2008  format(' Solute extensions: ',/,3(1x,a,': [',f7.1,' - ',f7.1,']'))
          return
          end
          subroutine fillinterpolate(pmap,nx1,nx,ny1,ny,nz1,nz,igincr,
         -  nxmax,nymax,nzmax,pinf,ninterpol)
          dimension pmap(nxmax,nymax,nzmax)
          ninterpol=0
          ngr=0
          do iz=nz1,nz,igincr
            do iy=ny1,ny,igincr
              do ix=nx1,nx,igincr
                ngr=ngr+1
                if (pmap(ix,iy,iz) .eq. pinf) then
                  ninterpol=ninterpol+1
                  pint=0.0
                  ixlim=ix
                  do while (ixlim .le. nx .and. pmap(ixlim,iy,iz) .eq. pinf)
                    ixlim=ixlim+1
                  end do
                  if (ix .eq. nx1) then
                    if (ixlim .gt. nx) then
                      print *,'Empty line iy=',iy,' iz=',iz
                      stop
                    end if
                    pint=pint+pmap(ixlim,iy,iz)
                  else if (ixlim .gt. nx) then
                    pint=pint+pmap(ix-igincr,iy,iz)
                  else
                    pint=pint+(igincr*pmap(ixlim,iy,iz)+
         -            (ixlim-ix)*pmap(ix-igincr,iy,iz))/(ixlim-ix+igincr)
                  end if
                  iylim=iy
                  do while (iylim .le. ny .and. pmap(ix,iylim,iz) .eq. pinf)
                    iylim=iylim+1
                  end do
                  if (iy .eq. ny1) then
                    if (iylim .gt. ny) then
                      print *,'Empty line ix=',ix,' iz=',iz
                      stop
                    end if
                    pint=pint+pmap(ix,iylim,iz)
                  else if (iylim .gt. ny) then
                    pint=pint+pmap(ix,iy-igincr,iz)
                  else
                    pint=pint+(igincr*pmap(ix,iylim,iz)+
         -            (iylim-iy)*pmap(ix,iy-igincr,iz))/(iylim-iy+igincr)
                  end if
                  izlim=iz
                  do while (izlim .le. nz .and. pmap(ix,iy,izlim) .eq. pinf)
                    izlim=izlim+1
                  end do
                  if (iz .eq. nz1) then
                    if (izlim .gt. nz) then
                      print *,'Empty line ix=',ix,' iy=',iy
                      stop
                    end if
                    pint=pint+pmap(ix,iy,izlim)
                  else if (izlim .gt. nz) then
                    pint=pint+pmap(ix,iy,iz-igincr)
                  else
                    pint=pint+(igincr*pmap(ix,iy,izlim)+
         -            (izlim-iz)*pmap(ix,iy,iz-igincr))/(izlim-iz+igincr)
                  end if
                  pmap(ix,iy,iz)=pint/3.0
                end if
              end do
            end do
          end do
          return
          end
          subroutine delphilabel(c,n,nslt,xstart,ystart,zstart,gx,gy,gz,cv)
          dimension c(3,n),cv(n)
          parameter (MAXPHI=400)
          common /nnwork/ phimap(MAXPHI,MAXPHI,MAXPHI)
          nl=0
          do ia=1,nslt
            call interpolate(c(1,ia),c(2,ia),c(3,ia),gx,gy,gz,
         -    xstart,ystart,zstart,phi)
            cv(ia)=phi
          end do
          return
          end
          subroutine readmap(iu,xstart,ystart,zstart,gx,gy,gz,ngx,ngy,ngz,
         -  nconf,work,lwork)
          dimension work(lwork)
          parameter (MAXPHI=400)
          common /nnwork/ phimap(MAXPHI,MAXPHI,MAXPHI)
          character*60 toplbl !ascii header
          integer*4 ivary ! 0 => x index varys most rapidly
          integer*4 nbyte ! =4, # of bytes in data
          integer*4 inddat ! =0, floating point data
          real*4 xang,yang,zang ! =90,90,90 unit cell angles
          integer*4 intx,inty,intz ! =igrid-1, # of intervals/grid side
          real*4 extentx, extenty, extentz ! maximum extent of grid in x,y,z
          real*4 xstart,xend ! beginning, end of grid sides
          real*4 ystart,yend ! in fractional
          real*4 zstart,zend ! units of extent*
          data imin /0/,jmin /0/,kmin /0/
          rewind iu
          read (iu) toplbl
          read (iu) ivary, nbyte, inddat, extentx, extenty, extentz,
         -  xang, yang, zang, xstart, xend, ystart, yend,
         -  zstart, zend, intx, inty, intz
          if (ivary .eq. 0) write (6,*) 'X index varies faster (Fortran)'
          if (ivary .gt. 0) write (6,*) 'Z index varies faster (C)'
          gx=extentx*(xend-xstart)/(intx)
          gy=extenty*(yend-ystart)/(inty)
          gz=extentz*(zend-zstart)/(intz)
          phimin=1000000.0
          ngx=intx+1
          ngy=inty+1
          ngz=intz+1
          write (6,1002) 'X',extentx*xstart,extentx*xend,gx,ngx
          write (6,1002) 'Y',extenty*ystart,extenty*yend,gy,ngy
          write (6,1002) 'Z',extentz*zstart,extentz*zend,gz,ngz
          write (6,1003) extentx*(xstart+xend)/2.0,
         -  extenty*(ystart+yend)/2.0,extentz*(zstart+zend)/2.0
          nskip=0
          if (ngx .gt. MAXPHI) then
            ngxx=ngx
            do while (ngxx .gt. MAXPHI)
              ngxx=ngxx/2
              nskip=nskip+1
            end do
            if (nconf .le. 1) write (6,1000) ngx,MAXPHI,2**nskip
            gx=gx*2**nskip
            gy=gy*2**nskip
            gz=gz*2**nskip
          end if
          nuse=2**nskip
          if (ivary .eq. 0) then
            do k=1,ngz
              do j=1,ngy
                read (iu) (work(i),i=1,ngx)
                do i=1,ngx
                  if (work(i) .lt. phimin) then
                    phimin=work(i)
                    imin=i
                    jmin=j
                    kmin=k
                  end if
                end do
                if (mod(k,nuse) .eq. 0 .and. mod(j,nuse) .eq. 0) then
                  do i=1,ngx
                    if (mod(i,nuse) .eq. 0)
         -            phimap((i-1)/nuse+1,(j-1)/nuse+1,(k-1)/nuse+1)=work(i)
                  end do
                end if
              end do
            end do
          else
            do k=1,ngx
              do j=1,ngy
                read (iu) (work(i),i=1,ngz)
                do i=1,ngz
                  if (work(i) .lt. phimin) then
                    phimin=work(i)
                    imin=i
                    jmin=j
                    kmin=k
                  end if
                end do
                if (mod(k,nuse) .eq. 0 .and. mod(j,nuse) .eq. 0) then
                  do i=1,ngz
                    if (mod(i,nuse) .eq. 0)
         -            phimap((i-1)/nuse+1,(j-1)/nuse+1,(k-1)/nuse+1)=work(i)
                  end do
                end if
              end do
            end do
          end if
          xstart=xstart*extentx
          ystart=ystart*extenty
          zstart=zstart*extentz
          write (6,1001) phimin,xstart+(imin-1)*gx/2**nskip,
         -  ystart+(jmin-1)*gy/2**nskip,zstart+(kmin-1)*gz/2**nskip
          return
    1000  format(' The number of gridpoints (',i4,') exceeds ',i4,
         -  ' - only every',i3,'-th will be used',/,
         -  ' (update/replace the nnwork common block to avoid this)')
    1001  format(' The lowest potential=',f10.4,' at (',f8.2,',',f8.2,',',
         -  f8.2,')')
    1002  format(1x,a,'-direction start=',f10.5,' end=',f10.5,
         -  ' gridsize=',f6.3,' (',i3,' grids)')
    1003  format(' The grid is centered at (',f10.5,',',f10.5,',',f10.5,')')
          end
          subroutine interpolate(x,y,z,gx,gy,gz,xstart,ystart,zstart,phi)
          parameter (MAXPHI=400)
          common /nnwork/ phimap(MAXPHI,MAXPHI,MAXPHI)
          ix=(x-xstart)/gx+1
          iy=(y-ystart)/gy+1
          iz=(z-zstart)/gz+1
          xm=xstart+(ix-1)*gx
          ym=ystart+(iy-1)*gy
          zm=zstart+(iz-1)*gz
          wxp=(x-xm)/gx
          wyp=(y-ym)/gy
          wzp=(z-zm)/gz
          wxm=1.0-wxp
          wym=1.0-wyp
          wzm=1.0-wzp
          p0y0=wym*phimap(ix+0,iy+0,iz+0)+wyp*phimap(ix+0,iy+1,iz+0)
          p0y1=wym*phimap(ix+0,iy+0,iz+1)+wyp*phimap(ix+0,iy+1,iz+1)
          p1y0=wym*phimap(ix+1,iy+0,iz+0)+wyp*phimap(ix+1,iy+1,iz+0)
          p1y1=wym*phimap(ix+1,iy+0,iz+1)+wyp*phimap(ix+1,iy+1,iz+1)
          p0yz=wzm*p0y0+wzp*p0y1
          p1yz=wzm*p1y0+wzp*p1y1
          phi=wxm*p0yz+wxp*p1yz
          return
          end
          subroutine readreal(line,icol1,icol2,r)
          character*(*) line
          if (icol2-icol1 .eq. 2) then
            read (line(icol1:icol2),1003,ERR=100) r
          else if (icol2-icol1 .eq. 3) then
            read (line(icol1:icol2),1004,ERR=100) r
          else if (icol2-icol1 .eq. 4) then
            read (line(icol1:icol2),1005,ERR=100) r
          else if (icol2-icol1 .eq. 5) then
            read (line(icol1:icol2),1006,ERR=100) r
          else if (icol2-icol1 .eq. 6) then
            read (line(icol1:icol2),1007,ERR=100) r
          else if (icol2-icol1 .eq. 7) then
            read (line(icol1:icol2),1008,ERR=100) r
          else if (icol2-icol1 .eq. 8) then
            read (line(icol1:icol2),1009,ERR=100) r
          else if (icol2-icol1 .eq. 9) then
            read (line(icol1:icol2),1010,ERR=100) r
          else if (icol2-icol1 .eq. 10) then
            read (line(icol1:icol2),1011,ERR=100) r
          else if (icol2-icol1 .eq. 11) then
            read (line(icol1:icol2),1012,ERR=100) r
          else if (icol2-icol1 .eq. 12) then
            read (line(icol1:icol2),1013,ERR=100) r
          else if (icol2-icol1 .eq. 13) then
            read (line(icol1:icol2),1014,ERR=100) r
          else if (icol2-icol1 .eq. 14) then
            read (line(icol1:icol2),1015,ERR=100) r
          else if (icol2-icol1 .eq. 15) then
            read (line(icol1:icol2),1016,ERR=100) r
          else if (icol2-icol1 .eq. 16) then
            read (line(icol1:icol2),1017,ERR=100) r
          else if (icol2-icol1 .eq. 17) then
            read (line(icol1:icol2),1018,ERR=100) r
          else if (icol2-icol1 .eq. 18) then
            read (line(icol1:icol2),1019,ERR=100) r
          else if (icol2-icol1 .eq. 19) then
            read (line(icol1:icol2),1020,ERR=100) r
          else if (icol2-icol1 .gt. 20) then
            print *,'EXTEND subroutine readreal to larger reals'
            print *,'r=',r,' icol1,2=',icol1,icol2
            stop
          else
            print *,'PROGRAM ERROR: invalid column range in readreal:',
         -  icol1,' - ',icol2
          end if
          return
    100   write (6,200) icol1,icol2,line
    200   format(' ERROR: Invalid real was read between columns ',
         -  i3,' and ',i3,':',/,a132)
          return
    1003  format(f3.0)
    1004  format(f4.0)
    1005  format(f5.0)
    1006  format(f6.0)
    1007  format(f7.0)
    1008  format(f8.0)
    1009  format(f9.0)
    1010  format(f10.0)
    1011  format(f11.0)
    1012  format(f12.0)
    1013  format(f13.0)
    1014  format(f14.0)
    1015  format(f15.0)
    1016  format(f16.0)
    1017  format(f17.0)
    1018  format(f18.0)
    1019  format(f19.0)
    1020  format(f20.0)
          end
          subroutine getname(name,len,q,lqin,maxlen,defname,ld,nonameok,
         -  ihelp,itip)
          character*(*) q,defname,name
          common /logging/ logfile,ipredict
          character*80 qline,ansline,defn
    100   lq=lqin
          defn(1:ld)=defname(1:ld)
          call blankout(name,1,maxlen)
          qline(1:lq)=q(1:lq)
          call blankout(ansline,1,80)
          nitems=0
          if (ld+ihelp+itip .gt. 0) then
            qline(lq+1:lq+2)=' ['
            lq=lq+2
            if (ld .gt. 0) then
              qline(lq+1:lq+ld)=defn(1:ld)
              lq=lq+ld
              nitems=nitems+1
            end if
            if (ihelp .gt. 0) then
              if (nitems .gt. 0) then
                qline(lq+1:lq+1)=','
                lq=lq+1
              end if
              qline(lq+1:lq+1)='?'
              lq=lq+1
              nitems=nitems+1
            end if
            if (itip .gt. 0) then
              if (nitems .gt. 0) then
                qline(lq+1:lq+1)=','
                lq=lq+1
              end if
              qline(lq+1:lq+1)='+'
              lq=lq+1
            end if
            qline(lq+1:lq+1)=']'
            lq=lq+1
          end if
          write (6,1000) qline(1:lq)
          read (5,1001) ansline
          call lastchar(ansline,lc,80)
          if (ansline(1:1) .eq. '?' .and. lc .eq. 1) then
            call explanation(ihelp,0)
            go to 100
          end if
          if (ansline(1:1) .eq. '+' .and. lc .eq. 1) then
            call explanation(0,itip)
            go to 100
          end if
          ifail=0
          if (ansline(1:1) .eq. '"') then
            call readquotestring(ansline,'"',i1,i2,ifail,80)
            if (ifail .gt. 0) go to 100
          else if (ansline(1:1) .eq. "'") then
            call readquotestring(ansline,"'",i1,i2,ifail,80)
            if (ifail .gt. 0) go to 100
          else
            ii=1
            call nextchar(ansline,ii,80)
            i1=ii
            call nextblank(ansline,ii,80)
            i2=ii-1
          end if
          if (i2-i1+1 .gt. maxlen) then
            write (6,1002) ansline(i1:i2),maxlen
            go to 100
          else if (i1 .gt. i2) then
            if (ld .gt. 0) then
              name(1:ld)=defn(1:ld)
              len=ld
            else if (nonameok .eq. 0) then
              print *,'Please, type in a name'
              go to 100
            else
              len=0
            end if
          else
            len=i2-i1+1
            name(1:len)=ansline(i1:i2)
          end if
          if (logfile .gt. 0) then
            nbl=0
            do ic=i1,i2
              if (ansline(ic:ic) .eq. ' ') nbl=nbl+1
            end do
            if (nbl .eq. 0) write (logfile,1001) ansline(i1:i2)
            if (nbl .gt. 0) write (logfile,1003) ansline(i1:i2)
          end if
          return
    1000  format(1x,a,'=',$)
    1001  format(a)
    1002  format(' Name read (',a,') is longer than allowed (',i3,')')
    1003  format('"',a,'"')
          end
          subroutine readquotestring(line,delim,i1,i2,ifail,len)
          character*(*) line
          character*1 delim
          i1=2
          ii=2
          ifail=0
          do while (line(ii:ii) .ne. delim .and. ii .lt. len)
              ii=ii+1
          end do
          if (line(ii:ii) .ne. delim) then
            ifail=1
            print *,'Missing closing quote'
          else
            i2=ii-1
          end if
          return
          end
          subroutine blankout(line,n1,n2)
          character*(*) line
          do i=n1,n2
            line(i:i)=' '
          end do
          return
          end
          subroutine writeline(iout,line,icol1,icol2,nocr)
          character* 132 line
          lc=icol2
          if (icol2 .eq. 0) call lastchar(line,lc,132)
          if (nocr .eq. 0) then
            write (iout,2000) line(icol1:lc)
          else
            write (iout,1000) line(icol1:lc)
          end if
          return
    1000  format(a,$)
    2000  format(a)
          end
          subroutine getint(q,len,idef,noneg,maxval,in,ihelp)
          character*(*) q
          character*132 ansline,pline
          common /logging/ logfile,ipredict
          lenq=len
          pline(1:1)=' '
          pline(2:lenq+1)=q(1:lenq)
          idefault=idef
          if (idefault .ne. 999999) then
            if (maxval .gt. 0 .and. idefault .gt. maxval) then
              write (6,2002)  idefault,maxval
              lenq=lenq+1
              pline(lenq:lenq)='='
            else
    1003  format(i5)
    1004  format(i4)
    1005  format(i3)
    1006  format(i2)
              pline(lenq+2:lenq+3)=' ['
              if (iabs(idefault) .ge. 10000) then
                write (pline(lenq+4:lenq+11),1002) iabs(idefault)
                lenq=lenq+11
              else if (iabs(idefault) .ge. 1000) then
                write (pline(lenq+4:lenq+8),1003) iabs(idefault)
                lenq=lenq+8
              else if (iabs(idefault) .ge. 100) then
                write (pline(lenq+4:lenq+7),1004) iabs(idefault)
                lenq=lenq+7
              else if (iabs(idefault) .ge. 10) then
                write (pline(lenq+4:lenq+6),1005) iabs(idefault)
                lenq=lenq+6
              else
                write (pline(lenq+4:lenq+5),1006) iabs(idefault)
                lenq=lenq+5
              end if
              if (ihelp .eq. 0) then
                pline(lenq+1:lenq+2)=']='
                lenq=lenq+2
              else
                pline(lenq+1:lenq+4)=',?]='
                lenq=lenq+4
              end if
            end if
          else
            if (ihelp .eq. 0) then
              pline(lenq+2:lenq+2)='='
              lenq=lenq+2
            else
              pline(lenq+2:lenq+5)='[?]='
              lenq=lenq+5
            end if
          end if
    100   call writeline(6,pline,1,lenq,1)
          call blankout(ansline,1,132)
          read (5,1001,end=99) ansline
          ii=1
          call nextchar(ansline,ii,132)
          if (ansline(ii:ii) .eq. '?') then
            if (ihelp .eq. 0) then
              print *,'Sorry, no help for this'
            else
              call explanation(ihelp,0)
            end if
            go to 100
          end if
          i1=ii
          call nextblank(ansline,ii,132)
          i2=ii-1
          if (i1 .gt. i2) then
            if (idefault .eq. 999999) go to 100
            in=idefault
            if (logfile .gt. 0) write (logfile,3000)
          else
            ic1=i1
            if (ansline(i1:i1) .eq. '-' .or.  ansline(i1:i1) .eq. '+')
         -    ic1=i1+1
            do i=ic1,i2
              if (idigit(ansline(i:i),1) .ne. 1) go to 999
            end do
            read (ansline(i1:i2),*,err=998) in
            if (logfile .gt. 0) write (logfile,*) in
          end if
          if (noneg .eq. 1 .and. in .lt. 0) then
            write (6,2000) q(1:len)
            go to 100
          end if
          if (maxval .gt. 0 .and. in .gt. maxval) then
            write (6,2001) maxval
            go to 100
          end if
          return
    99    print *,'ERROR: run out of data'
          stop
    998   print *,'Invalid input for an integer:',ansline(i1:i2)
          print *,'I1,I2=',i1,i2
          go to 900
    999   print *,'Invalid character for an integer:',ansline(i:i)
    900   call lastchar(ansline,lc,132)
          if (ishexadecimal(ansline,lc) .eq. 1) then
            print *,'Looks like the input is hexadecimal'
            call askyn('Do you want to interpret it as hexadecimal',42,1,-1,
         -    ihx,0,0)
            if (ihx .eq. 1) then
              in=iconvhex(ansline,lc)
              print *,'Input string ',ansline(1:lc),' converted to ',in
              return
            end if
          end if
          go to 100
    
    1001  format(a132)
    1002  format(i8)
    2000  format(' ERROR: negative number is invalid for ',a)
    2001  format(' ERROR: number read exceeds limit (',i9,')')
    2002  format(' PROGRAM ERROR: default value (',i8,') exceeds maximum ',
         -  'value (',i8,')')
    3000  format(a)
          end
          subroutine getintline(q,len,noneg,maxval,inputs,n,ihelp)
          dimension inputs(n)
          character*(*) q
          character*132 ansline,pline
          common /logging/ logfile,ipredict
          lenq=len
          pline(1:1)=' '
          pline(2:lenq+1)=q(1:lenq)
          if (ihelp .eq. 0) then
            pline(lenq+2:lenq+2)='='
            lenq=lenq+2
          else
            pline(lenq+2:lenq+5)='[?]='
            lenq=lenq+5
          end if
    100   call writeline(6,pline,1,lenq,1)
          call blankout(ansline,1,132)
          read (5,1001) ansline
          ii=1
          call nextchar(ansline,ii,132)
          if (ansline(ii:ii) .eq. '?') then
            if (ihelp .eq. 0) then
              print *,'Sorry, no help for this'
            else
              call explanation(ihelp,0)
            end if
            go to 100
          end if
          i1=ii
          call lastchar(ansline,ilc,132)
          if (logfile .gt. 0) write (logfile,3000) ansline(1:ilc)
          read (ansline,*,end=888,err=999) (inputs(k),k=1,n)
          do k=1,n
            if (inputs(k) .gt. maxval) then
              write (6,2001) inputs(k),maxval
              go to 100
            else if (noneg .eq. 1 .and. inputs(k) .lt. 0) then
              write (6,2000) inputs(k),q(1:len)
              go to 100
            end if
          end do
          return
    888   print *,'Insufficient number of entries'
          go to 100
    999   print *,'Invalid input for an integer:',ansline(1:ilc)
          go to 100
    1001  format(a132)
    2000  format(' ERROR: negative number read (',i9,') is invalid for ',a)
    2001  format(' ERROR: number read (',i9,') exceeds limit (',i9,')')
    3000  format(a)
          end
          subroutine getreal(q,len,default,r,noneg,ihelp)
          character*(*) q
          character*132 ansline,pline
          common /logging/ logfile,ipredict
          lenq=len
          pline(1:1)=' '
          pline(2:lenq+1)=q(1:lenq)
          if (default .ne. 999999.0) then
            pline(lenq+2:lenq+3)=' ['
            if (default .eq. 0.0) then
              write (pline(lenq+4:lenq+6),1007) default
              lenq=lenq+6
            else if (abs(default) .ge. 1000.0) then
              write (pline(lenq+4:lenq+11),1002) default
              lenq=lenq+11
            else if (abs(default) .ge. 100.0) then
              write (pline(lenq+4:lenq+10),1003) default
              lenq=lenq+10
            else if (abs(default) .ge. 10.0) then
              write (pline(lenq+4:lenq+9),1004) default
              lenq=lenq+9
            else if (abs(default) .ge. 1.0) then
              write (pline(lenq+4:lenq+8),1005) default
              lenq=lenq+8
            else
              write (pline(lenq+4:lenq+11),1006) default
              lenq=lenq+11
            end if
            if (ihelp .eq. 0) then
              pline(lenq+1:lenq+2)=']='
              lenq=lenq+2
            else
              pline(lenq+1:lenq+4)=',?]='
              lenq=lenq+4
            end if
          else
            if (ihelp .eq. 0) then
              pline(lenq+2:lenq+2)='='
              lenq=lenq+2
            else
              pline(lenq+2:lenq+5)='[?]='
              lenq=lenq+5
            end if
          end if
    100   call writeline(6,pline,1,lenq,1)
          call blankout(ansline,1,132)
          read (5,1001,end=99) ansline
          ii=1
          call nextchar(ansline,ii,132)
          if (ansline(ii:ii) .eq. '?') then
            if (ihelp .eq. 0) then
              print *,'Sorry, no help for this'
            else
              call explanation(ihelp,0)
            end if
            go to 100
          end if
          i1=ii
          call nextblank(ansline,ii,132)
          i2=ii-1
          if (i1 .gt. i2) then
            if (default .eq. 999999.0) go to 100
            r=default
            if (logfile .gt. 0) write (logfile,3000)
          else
            read (ansline(i1:i2),*,err=999) r
            if (noneg .eq. 1 .and. r .lt. 0.0) then
              print *,'ERROR: negative number is invalid'
              go to 100
            end if
            if (logfile .gt. 0) write (logfile,*) r
          end if
          return
    99    print *,'ERROR: run out of data'
          stop
    999   print *,'Invalid input for a real'
          go to 100
    1001  format(a132)
    1002  format(f8.1)
    1003  format(f7.2)
    1004  format(f6.2)
    1005  format(f5.2)
    1006  format(f8.5)
    1007  format(f3.1)
    3000  format(a)
          end
          subroutine getname4(ic,line,name,len,lead_trail)
          character*(*) line
          character*4 name
          name='    '
          call nextchar(line,ic,len)
          icf=ic
          call nextblank(line,ic,len)
          if (ic-icf .le. 4 .or. lead_trail .eq. 1) then
            name(1:ic-icf)=line(icf:ic-1)
          else
            name=line(ic-4:ic-1)
          end if
          return
          end
          subroutine askyn(q,lenqin,iyn,idefans,ians,ihelp,itip)
          character*(*) q
          character*132 pline
          character*1 ans
          character*5 defans
          common /graphics/ npixx,npixy,maxpixx,maxpixy,idwmain,idwplot,
         -  wx,wy,wz,wxdr
          common /logging/ logfile,ipredict
          ians=0
          if (idefans .eq. -1) then
            defans=' [n] '
            lendef=5
          else if (idefans .eq. +1) then
            defans=' [y] '
            lendef=5
          else
            defans=' '
            lendef=1
          end if
          lenq=lenqin
          pline(1:1)=' '
          pline(2:lenq+1)=q(1:lenq)
          pline(lenq+2:lenq+6)=' (y/n'
          lenq=lenq+6
          if (ihelp .gt. 0) then
            pline(lenq+1:lenq+2)='/?'
            lenq=lenq+2
          end if
          if (itip .gt. 0) then
            pline(lenq+1:lenq+2)='/+'
            lenq=lenq+2
          end if
          lenq=lenq+1
          pline(lenq:lenq)=')'
          pline(lenq+1:lenq+lendef)=defans(1:lendef)
    100   call writeline(6,pline,1,lenq+lendef,1)
          ans= ' '
          read (5,1001,end=99,err=99) ans
          if (ans .eq. '?') then
            if (ihelp .eq. 0) then
              print *,'Sorry, no help on this'
              go to 100
            else
              call explanation(ihelp,0)
              go to 100
            end if
          end if
          if (ans .eq. '+') then
            if (itip .eq. 0) then
              print *,'Sorry, no tip on this'
              go to 100
            else
              call explanation(0,itip)
              go to 100
            end if
          end if
    99    if (ans .ne. 'n' .and. ans .ne. 'N' .and. ans .ne. 'y' .and.
         -  ans .ne. 'Y') then
            call lastchar(ans,ilc,1)
            if (ilc .eq. 1) then
              print *,'Invalid answer - please, answer y or n'
              go to 100
            else if (idefans .ne. 1 .and. idefans .ne. -1) then
              print *,'Pls answer y or n'
              go to 100
            else
              if (idefans .eq. -1) then
                ans='n'
              else if (idefans .eq. 1) then
                ans='y'
              end if
            end if
          end if
          if (logfile .gt. 0) write (logfile,1001) ans
          if (ans .eq. 'y' .or. ans .eq. 'Y') ians=1
          if (iyn .eq. 0) ians=1-ians
          return
    1001  format(a1)
          end
          subroutine quiz(char,ians,defchar,prefix,lprefix,question0,lqt0,
         -  nqincr,inpt,iout,ihelp)
          character*(*) prefix,question0
          character*60 ansline
          character*80 line,line1(100),question
          character*1 char,defchar,ans,ch(2,100)
          dimension len(100),lenans(100)
          character*60 q(100),promptlist,prompttype
          common /quizinfo/ nqst(600),lqst(600),iqfst(600),iqlst(600),
         -  maxq,init,nprompttype,promptlist(600),prompttype(600)
          common /logging/ logfile,ipredict
          idebug=0
          if (init .eq. 0) then
            init=1
            nprompttype=0
            lqq=0
            do il=1,maxq
              call lastchar(promptlist(il),ilc,60)
              if (promptlist(il)(1:4) .eq. '****') then
                if (nprompttype .gt. 0) then
                  iqlst(nprompttype)=il-1
                  lqst(nprompttype)=lqq
                end if
                if (ilc .eq. 4) go to 10
                nprompttype=nprompttype+1
                prompttype(nprompttype)(1:55)=promptlist(il)(6:60)
                if (nprompttype .gt. 1) iqlst(nprompttype-1)=il-1
                iqfst(nprompttype)=il+1
              else
                if (lqq .lt. ilc) lqq=ilc
              end if
            end do
    10      if (idebug .gt. 0) then
              do i=1,nprompttype
                print *,'i,ifl,ill=',i,iqfst(i),iqlst(i)
                do ip=iqfst(i),iqlst(i)
                  print *,'ip,len=',ip,lqst(i)
                  print *,promptlist(ip)(1:lqst(i))
                end do
              end do
            end if
          end if
          iquiz=1
          do while (question0(1:lqt0) .ne. prompttype(iquiz)(1:lqt0) .and.
         -   iquiz .le. nprompttype)
            iquiz=iquiz+1
          end do
          if (iquiz .gt. nprompttype) then
            print *,'PROGRAM ERROR: quiz type ',question0(1:lqt0),
         -    ' is unknown'
            stop
          end if
          if (lprefix .eq. 0) then
            question(1:lqt0)=question0(1:lqt0)
            lqt=lqt0
          else if (lprefix .gt. 0) then
            question(1:lprefix)=prefix(1:lprefix)
            lqt=lprefix+1
            question(lqt:lqt)=' '
            question(lqt+1:lqt+lqt0)=question0(1:lqt0)
            lqt=lqt+lqt0
          else
            question(1:lqt0)=question0(1:lqt0)
            lqt=lqt0+1
            question(lqt:lqt)=' '
            question(lqt+1:lqt-lprefix)=prefix(1:-lprefix)
            lqt=lqt-lprefix
          end if
          if (idebug .gt. 0) print *,'QUIZ nprompttype,iquiz=',
         -  nprompttype,iquiz,' nq,lq=',nq,lq
          do iq=iqfst(iquiz),iqlst(iquiz)
            q(iq-iqfst(iquiz)+1)=promptlist(iq)
          end do
          nq=iqlst(iquiz)-iqfst(iquiz)+1
          lq=lqst(iquiz)
          if (nq .gt. 40) then
            write (iout,*) '***** Redimension quiz to more than 40 items'
            stop
          end if
          nqq=nq-nqincr
          if (ihelp .gt. 0) nqq=nqq+1
          ans=' '
    100   if (lqt .gt. 0) write (iout,1002) question(1:lqt)
          idebug=idebug+1
          if (idebug .eq. 4) stop
          ideffound=0
          do iq=1,nq-nqincr
            ich=1
            do while (q(iq)(ich:ich) .ne. '<' .and. ich .lt. lq)
              ich=ich+1
            end do
            ich=ich+1
            ichgrt=ich+1
            il=lq
            do while (q(iq)(il:il) .eq. ' ' .and. il .gt. 1)
              il=il-1
            end do
            len(iq)=il
            lenans(iq)=il-2
            if (ichgrt .eq. il) lenans(iq)=lenans(iq)-1
            ch(1,iq)=q(iq)(ich:ich)
            iconvcase=1
            if (ich .lt. lq-1) then
              call findcase(q(iq)(ich+2:ich+2),icase)
              if (icase .eq. 1) iconvcase=0
            end if
            if (iconvcase .eq. 1 .and. ich .gt. 3) then
              call findcase(q(iq)(ich-2:ich-2),icase)
              if (icase .eq. 1) iconvcase=0
            end if
            call uplow(ch(1,iq),ch(2,iq),1,noabc)
            if (noabc .eq. 1) ch(2,iq)=ch(1,iq)
            if (ich .eq. 2) then
              line1(iq)(1:1)=ch(1,iq)
              line1(iq)(2:il-2)=q(iq)(4:il)
            else
              line1(iq)(1:ich-2)=q(iq)(1:ich-2)
              line1(iq)(ich-1:ich-1)=ch(iconvcase+1,iq)
              if (il-ich .gt. 1) line1(iq)(ich:il-2)=q(iq)(ich+2:il)
              call uplow(line1(iq)(1:1),line1(iq)(1:1),2,noabc)
            end if
            line(1:len(iq))=q(iq)(1:len(iq))
            do ic=len(iq)+1,lq
              line(ic:ic)=' '
            end do
            do ic=len(iq)+2+mod(len(iq),2),lq-1,2
              line(ic:ic)='-'
            end do
            line(lq+1:lq+2)=': '
            line(lq+3:lq+3)=ch(2,iq)
            line(lq+4:lq+4)=ch(1,iq)
            lqw=lq+3
            if (defchar .eq. ch(2,iq)) then
              ideffound=1
              line(lq+4:lq+14)=' (default)'
              lqw=lq+14
            end if
            if (iq .lt. nqq) write (iout,1001) line(1:lqw)
            if (iq .eq. nqq) write (iout,1006) line(1:lqw)
          end do
          if (ihelp .gt. 0) then
            ch(1,nqq)='?'
            ch(2,nqq)='?'
            call blankout(line,1,lq)
            line(1:4)='Help'
            do ic=6,lq-1,2
              line(ic:ic)='-'
            end do
            line(lq+1:lq+3)=': ?'
            write (iout,1006) line(1:lq+3)
          end if
          ans=' '
          read (inpt,1000) ans
          if (defchar .ne. ' ') then
            if (ideffound .eq. 0) then
              print *,'PROGRAM ERROR: invalid default character: ',defchar
            else if (ans .eq. ' ' .or. ans .eq. '') then
              ans=defchar
            end if
          end if
          do iq=1,nq
            ians=iq
            if (ans .eq. ch(1,iq)) then
              char=ch(2,iq)
              go to 200
            else if (ans .eq. ch(2,iq)) then
              char=ans
              go to 200
            end if
          end do
          if (ihelp .gt. 0 .and. ans .eq. '?') then
            call explanation(ihelp,0)
          else
            write (iout,*) ans,': Invalid answer, pls repeat'
          end if
          go to 100
    200   if (ians .ge. 1 .and. ians .le. nq) then
            lans=lenans(ians)
            write (iout,1003) line1(ians)(1:lans)
            ansline(1:lans)=line1(ians)(1:lans)
            if (logfile .gt. 0) write (logfile,1000) ans
          else if (ians .eq. nqq) then
            call explanation(ihelp,0)
            go to 100
          else
            lans=1
            ansline(1:lans)='?'
          end if
          return
    1000  format(a1)
    1001  format(1x,a,a)
    1002  format(/,' SELECT ',a,':')
    1003  format(' "',a,'" selected')
    1006  format(1x,a,'  ',$)
          end
          subroutine menulist
          character*60 promptlist,prompttype
          common /quizinfo/ nqst(600),lqst(600),iqfst(600),iqlst(600),
         -  maxq,init,nprompttype,promptlist(600),prompttype(600)
          character*55 submenu1(20)
          character*55 submenue(20)
          character*35 submenua(20)
          data submenu1 /
         -  '                                                       ',
         -  'optimization type                                      ',
         -  '                                                       ',
         -  'structure file format conversion type                  ',
         -  'trajectory file format conversion type                 ',
         -  'name conversion type                                   ',
         -  'trajectory/configuration stack packing/unpacking       ',
         -  'conformation manipulation                              ',
         -  'miscellaneous file creation                            ',
         -  'configuration analysis                                 ',
         -  'clustering source                                      ',
         -  9*'                                                       '/
          data submenua /
         -  'topology/geometry analysis         ',
         -  'bond tracking                      ',
         -  'atomic property calculation        ',
         -  'molecular property calculation     ',
         -  'RMSD calculation                   ',
         -  'distance analysis                  ',
         -  14*'                                   '/
          data submenue /
         -  'selecting option                                       ',
         -  '(additional) conformation transformation type          ',
         -  '                                                       ',
         -  'modification type                                      ',
         -  16*'                                                       '/
          call findmenu('run type',8,ix1)
          ix10=ix1
          ix1=ix1+1
          nn=0
          do while (promptlist(ix1)(1:3) .ne. '<Q>')
            write (6,1000) '   ',promptlist(ix1)
            call lastchar(submenu1(ix1-ix10),lc1,55)
            if (lc1 .gt. 1) then
              call findmenu(submenu1(ix1-ix10),lc1,ix2)
              ix20=ix2
              ix2=ix2+1
              do while (promptlist(ix2)(1:4) .ne. '****' .and.
         -              promptlist(ix2)(1:3) .ne. '<Q>')
                write (6,1000) '     ',promptlist(ix2)
                if (submenu1(ix1-ix10)(1:lc1) .eq.
         -          'configuration analysis') then
                  call lastchar(submenua(ix2-ix20),lc2,35)
                  if (lc2 .gt. 1) then
                    call findmenu(submenua(ix2-ix20),lc2,ix3)
                    ix3=ix3+1
                    do while (promptlist(ix3)(1:4) .ne. '****' .and.
         -                    promptlist(ix3)(1:3) .ne. '<Q>')
                      write (6,1000) '       ',promptlist(ix3)
                      ix3=ix3+1
                    end do
                  end if
                else if (submenu1(ix1-ix10)(1:lc1) .eq.
         -          'conformation manipulation') then
                  call lastchar(submenue(ix2-ix20),lc2,55)
                  if (lc2 .gt. 1) then
                    call findmenu(submenue(ix2-ix20),lc2,ix3)
                    ix3=ix3+1
                    do while (promptlist(ix3)(1:4) .ne. '****' .and.
         -                    promptlist(ix3)(1:3) .ne. '<Q>')
                      write (6,1000) '       ',promptlist(ix3)
                      ix3=ix3+1
                    end do
                  end if
                end if
                ix2=ix2+1
                if (ix2-ix20 .gt. 20) then
                  write (6,2000)
                  stop
                end if
              end do
            end if
            ix1=ix1+1
          end do
          return
    1000  format(a,a)
    2000  format(' PROGRAM ERROR: submenua or submenue array is too short',
         -  ' in subroutine menulist')
          end
          subroutine findmenu(label,llabel,ix)
          character*(*) label
          character*60 promptlist,prompttype
          common /quizinfo/ nqst(600),lqst(600),iqfst(600),iqlst(600),
         -  maxq,init,nprompttype,promptlist(600),prompttype(600)
          ix=1
          do while (promptlist(ix)(1:5) .ne. '**** ' .or.
         -          promptlist(ix)(6:5+llabel) .ne. label(1:llabel))
            ix=ix+1
            if (ix .eq. 500) then
              print *,'PROGRAM ERROR: menu ',label(1:llabel),' is not found'
              stop
            end if
          end do
          return
          end
          subroutine uplow(charin,charout,iuptolow,noabc)
          character*1 charin,charout
          character*1 abc,idig,digits,hexdigits
          common /charactersets/ ihex(25),abc(26,2),idig(10),digits(14),
         -  hexdigits(25)
          do ic=1,26
            if (charin .eq. abc(ic,iuptolow)) then
              charout=abc(ic,3-iuptolow)
              noabc=0
              return
            end if
          end do
          noabc=1
          return
          end
          subroutine findcase(charin,icase)
          character*1 charin
          character*1 abc,idig,digits,hexdigits
          common /charactersets/ ihex(25),abc(26,2),idig(10),digits(14),
         -  hexdigits(25)
          icase=0
          do ic=1,26
            if (charin .eq. abc(ic,1)) icase=1
            if (charin .eq. abc(ic,2)) icase=2
          end do
          return
          end
          subroutine drawpbc(edgexyz,edge_gen,ioppbc,ixyzhex,cent,i2nd,
         -  icrot,crot,sizefac,ioutpdb)
          dimension edgexyz(3),edge_gen(3,3),cent(3),ixyzhex(3),crot(3,3),
         -  e2(3),vp(3,48),ixdup(48),hxy(2,6),vphl(3,7),vphu(3,7)
          common /graphics/ npixx,npixy,maxpixx,maxpixy,idwmain,idwplot,
         -  wx,wy,wz,wxdr
          common /rotmat/ matrot0(4,4),matrot(4,4),nomat0
          common /pbcrotmat/ torot_ac(3,3),torot_ca(3,3),tofac_ac,tofac_ca
          common /depthcuedat/ near,ifar,ramp0,idepth,idepthon,idrawh,
         -  linew,isidec,nbackb,idrawslv
          if (ioppbc .gt. 9) return
          call indexit(ixdup,1,48,0)
          if (ioutpdb .gt. 0) iconntyp=2
          wxold=wx
          wx=0.0
          npixmin=min0(npixx,npixy)
          if (ioppbc .eq. 1) then
            edgemax=edgexyz(1)
            wx=(edgemax/2.0)*sizefac
            edgexyz(2)=edgexyz(1)
            edgexyz(3)=edgexyz(1)
          else if (ioppbc .eq. 2) then
            edgemax=amax1(edgexyz(1),edgexyz(2),edgexyz(3))
            wx=(edgemax/2.0)*sizefac
          else if (ioppbc .eq. 3) then
            wx=edgexyz(1)*sizefac
          else if (ioppbc .eq. 4) then
            wx=amax1(edgexyz(1)/2,edgexyz(2))*sizefac
          else if (ioppbc .eq. 5) then
            wx=amax1(edgexyz(1)/2,edgexyz(2)/2,edgexyz(3)/2)*sizefac
          else if (ioppbc .eq. 6 .or. ioppbc .eq. 7) then
            wx=edgexyz(1)*sizefac
          else if (ioppbc .eq. 8) then
            wx=(edgexyz(1)/sqrt(3.0))*sizefac
          else if (ioppbc .eq. 9) then
           wx=edge_gen(1,1)*1.3*sizefac
          else if (ioppbc .eq. 10) then
            print *,'Sorry, no cell is to be drawn for inputted images'
          else if (ioppbc .eq. 11) then
            print *,'Sorry, no cell is to be drawn for sphere PBC'
          else
            print *,'ERROR: invalid pbc code=',ioppbc
          end if
          wx=wx+amax1(abs(cent(1)),amax1(abs(cent(2)),abs(cent(3))))
          if (wx .lt. 5.0) wx=5.0
          wy=wx
          wz=wx
          if (wx .gt. wxold .and. i2nd .eq. 0) then
          end if
          if (i2nd .eq. 0) then
            wylab=0.9*wxdr
            wxlab=0.9*wxdr
          end if
          if (ioppbc .eq. 1 .or. ioppbc .eq. 2) then
            nv=8
            do k=1,3
              e2(k)=edgexyz(k)/2.0
            end do
            vp(2,1)=-e2(2)
            vp(3,1)=-e2(3)
            vp(2,2)=+e2(2)
            vp(3,2)=-e2(3)
            vp(2,3)=+e2(2)
            vp(3,3)=+e2(3)
            vp(2,4)=-e2(2)
            vp(3,4)=+e2(3)
            do m=1,4
              vp(1,m)=-e2(1)
              vp(1,m+4)=+e2(1)
              do k=2,3
                vp(k,m+4)=vp(k,m)
              end do
            end do
            call shiftmol(vp,8,cent,vp,1.0)
            call writevertices(vp,8,ioppbc,ioutpdb,iconntyp,icrot,crot)
            do m=1,4
              call connlinix(vp,m,mod(m,4)+1,ixdup,iconntyp,ioutpdb,48)
              call connlinix(vp,m+4,mod(m,4)+5,ixdup,iconntyp,ioutpdb,48)
              call connlinix(vp,m,m+4,ixdup,iconntyp,ioutpdb,48)
            end do
          else if (ioppbc .eq. 3) then
            nv=14
            edge=edgexyz(1)
            edge2=edgexyz(1)/2.0
            call zeroit(vp,3*6)
            do k=1,3
              vp(k,2*(k-1)+1)=-edge
              vp(k,2*k)=edge
            end do
            do i=1,4
              vp(1,2*(i-1)+7)=(-1)**i*edge2
              vp(1,2*(i-1)+8)=vp(1,2*(i-1)+7)
              vp(2,2*(i-1)+7)=(-1)**((i-1)/2)*edge2
              vp(2,2*(i-1)+8)=vp(2,2*(i-1)+7)
              vp(3,2*(i-1)+7)=-edge2
              vp(3,2*(i-1)+8)=+edge2
            end do
            call shiftmol(vp,14,cent,vp,1.0)
            call finddup(vp,ixdup,14,nunique)
            call writevertices(vp,nunique,ioppbc,ioutpdb,iconntyp,
         -    icrot,crot)
            call connlinix(vp,1,07,ixdup,iconntyp,ioutpdb,48)
            call connlinix(vp,1,08,ixdup,iconntyp,ioutpdb,48)
            call connlinix(vp,1,11,ixdup,iconntyp,ioutpdb,48)
            call connlinix(vp,1,12,ixdup,iconntyp,ioutpdb,48)
            call connlinix(vp,2,09,ixdup,iconntyp,ioutpdb,48)
            call connlinix(vp,2,10,ixdup,iconntyp,ioutpdb,48)
            call connlinix(vp,2,13,ixdup,iconntyp,ioutpdb,48)
            call connlinix(vp,2,14,ixdup,iconntyp,ioutpdb,48)
            call connlinix(vp,3,11,ixdup,iconntyp,ioutpdb,48)
            call connlinix(vp,3,12,ixdup,iconntyp,ioutpdb,48)
            call connlinix(vp,3,13,ixdup,iconntyp,ioutpdb,48)
            call connlinix(vp,3,14,ixdup,iconntyp,ioutpdb,48)
            call connlinix(vp,4,07,ixdup,iconntyp,ioutpdb,48)
            call connlinix(vp,4,08,ixdup,iconntyp,ioutpdb,48)
            call connlinix(vp,4,09,ixdup,iconntyp,ioutpdb,48)
            call connlinix(vp,4,10,ixdup,iconntyp,ioutpdb,48)
            call connlinix(vp,5,07,ixdup,iconntyp,ioutpdb,48)
            call connlinix(vp,5,09,ixdup,iconntyp,ioutpdb,48)
            call connlinix(vp,5,13,ixdup,iconntyp,ioutpdb,48)
            call connlinix(vp,5,11,ixdup,iconntyp,ioutpdb,48)
            call connlinix(vp,6,08,ixdup,iconntyp,ioutpdb,48)
            call connlinix(vp,6,10,ixdup,iconntyp,ioutpdb,48)
            call connlinix(vp,6,14,ixdup,iconntyp,ioutpdb,48)
            call connlinix(vp,6,12,ixdup,iconntyp,ioutpdb,48)
          else if (ioppbc .eq. 4 .or. ioppbc .eq. 5) then
            nv=12
            edgep2=edgexyz(1)/2.0
            if (ioppbc .eq. 4) then
              edgey=edgexyz(2)
              esq3p2=edgey*(sqrt(3.0)/2.0)
              vp(ixyzhex(2),1)=edgey
              vp(ixyzhex(2),2)=edgey/2.0
              vp(ixyzhex(3),2)=esq3p2
            else
              edgex=edgexyz(3)
              edgey=edgexyz(2)
              w=sqrt(edgey**2-edgex**2/4.0)
              h=(w-edgex/(2.0*sqrt(3.0)))/2.0
              vp(ixyzhex(2),1)=w-h
              vp(ixyzhex(3),2)=edgex/2.0
              vp(ixyzhex(2),2)=h
            end if
            vp(ixyzhex(3),1)=0.0
            vp(ixyzhex(3),3)=vp(ixyzhex(3),2)
            vp(ixyzhex(2),3)=-vp(ixyzhex(2),2)
            vp(ixyzhex(2),4)=-vp(ixyzhex(2),1)
            vp(ixyzhex(3),4)=0.0
            vp(ixyzhex(2),5)=-vp(ixyzhex(2),2)
            vp(ixyzhex(3),5)=-vp(ixyzhex(3),2)
            vp(ixyzhex(2),6)=-vp(ixyzhex(2),3)
            vp(ixyzhex(3),6)=-vp(ixyzhex(3),3)
            do m=1,6
              vp(ixyzhex(1),m)=-edgep2
              vp(ixyzhex(1),m+6)=+edgep2
              do k=2,3
                vp(ixyzhex(k),m+6)=vp(ixyzhex(k),m)
              end do
            end do
            call shiftmol(vp,12,cent,vp,1.0)
            call writevertices(vp,12,ioppbc,ioutpdb,iconntyp,icrot,crot)
            do m=1,6
              call connlinix(vp,m,mod(m,6)+1,ixdup,iconntyp,ioutpdb,48)
              call connlinix(vp,m+6,mod(m,6)+7,ixdup,iconntyp,ioutpdb,48)
              call connlinix(vp,m,m+6,ixdup,iconntyp,ioutpdb,48)
            end do
          else if (ioppbc .eq. 6 .or. ioppbc .eq. 7) then
            eto2=edgexyz(1)
            eto=edgexyz(1)/2.0
            print *,'eto,sto2=',eto,eto2
            call zeroit(vp,(3*6*8))
            vp(1,1)=eto
            vp(3,1)=eto2
            vp(2,2)=eto
            vp(3,2)=eto2
            vp(2,3)=eto2
            vp(3,3)=eto
            vp(1,4)=eto
            vp(2,4)=eto2
            vp(1,5)=eto2
            vp(2,5)=eto
            vp(1,6)=eto2
            vp(3,6)=eto
            vp(1,1+6)=eto
            vp(3,1+6)=-eto2
            vp(2,2+6)=eto
            vp(3,2+6)=-eto2
            vp(2,3+6)=eto2
            vp(3,3+6)=-eto
            vp(1,4+6)=eto
            vp(2,4+6)=eto2
            vp(1,5+6)=eto2
            vp(2,5+6)=eto
            vp(1,6+6)=eto2
            vp(3,6+6)=-eto
            vp(1,1+12)=-eto
            vp(3,1+12)=-eto2
            vp(2,2+12)=eto
            vp(3,2+12)=-eto2
            vp(2,3+12)=eto2
            vp(3,3+12)=-eto
            vp(1,4+12)=-eto
            vp(2,4+12)=eto2
            vp(1,5+12)=-eto2
            vp(2,5+12)=eto
            vp(1,6+12)=-eto2
            vp(3,6+12)=-eto
            vp(1,1+18)=-eto
            vp(3,1+18)=eto2
            vp(2,2+18)=eto
            vp(3,2+18)=eto2
            vp(2,3+18)=eto2
            vp(3,3+18)=eto
            vp(1,4+18)=-eto
            vp(2,4+18)=eto2
            vp(1,5+18)=-eto2
            vp(2,5+18)=eto
            vp(1,6+18)=-eto2
            vp(3,6+18)=eto
            vp(1,1+24)=eto
            vp(3,1+24)=eto2
            vp(2,2+24)=-eto
            vp(3,2+24)=eto2
            vp(2,3+24)=-eto2
            vp(3,3+24)=eto
            vp(1,4+24)=eto
            vp(2,4+24)=-eto2
            vp(1,5+24)=eto2
            vp(2,5+24)=-eto
            vp(1,6+24)=eto2
            vp(3,6+24)=eto
            vp(1,1+30)=eto
            vp(3,1+30)=-eto2
            vp(2,2+30)=-eto
            vp(3,2+30)=-eto2
            vp(2,3+30)=-eto2
            vp(3,3+30)=-eto
            vp(1,4+30)=eto
            vp(2,4+30)=-eto2
            vp(1,5+30)=eto2
            vp(2,5+30)=-eto
            vp(1,6+30)=eto2
            vp(3,6+30)=-eto
            vp(1,1+36)=-eto
            vp(3,1+36)=-eto2
            vp(2,2+36)=-eto
            vp(3,2+36)=-eto2
            vp(2,3+36)=-eto2
            vp(3,3+36)=-eto
            vp(1,4+36)=-eto
            vp(2,4+36)=-eto2
            vp(1,5+36)=-eto2
            vp(2,5+36)=-eto
            vp(1,6+36)=-eto2
            vp(3,6+36)=-eto
            vp(1,1+42)=-eto
            vp(3,1+42)=eto2
            vp(2,2+42)=-eto
            vp(3,2+42)=eto2
            vp(2,3+42)=-eto2
            vp(3,3+42)=eto
            vp(1,4+42)=-eto
            vp(2,4+42)=-eto2
            vp(1,5+42)=-eto2
            vp(2,5+42)=-eto
            vp(1,6+42)=-eto2
            vp(3,6+42)=eto
            if (ioppbc .eq. 7)
         -    call rotate_c(vp,48,torot_ca,vp,'VERTICES',8)
            call shiftmol(vp,48,cent,vp,1.0)
            call finddup(vp,ixdup,48,nunique)
            call writevertices(vp,nunique,ioppbc,ioutpdb,iconntyp,
         -    icrot,crot)
            do ifa=1,8
              do m=1,6
                call connlinix(vp,m+(ifa-1)*6,mod(m,6)+1+(ifa-1)*6,ixdup,
         -        iconntyp,ioutpdb,48)
              end do
            end do
          else if (ioppbc .eq. 8) then
    C       Hexagonal close-packed
            d=edgexyz(1)
            t=d*sqrt(3.0)/(2.0*sqrt(2.0))
            hl=d/(2.0*sqrt(6.0))
            hh=(t+hl)/2.0
            hxy(1,1)=d/2.0
            hxy(2,1)=-d/(2.0*sqrt(3.0))
            hxy(1,2)=0.0
            hxy(2,2)=-d/sqrt(3.0)
            hxy(1,3)=-d/2.0
            hxy(2,3)=-d/(2.0*sqrt(3.0))
            hxy(1,4)=-d/2.0
            hxy(2,4)=+d/(2.0*sqrt(3.0))
            hxy(1,5)=0.0
            hxy(2,5)=d/sqrt(3.0)
            hxy(1,6)=d/2.0
            hxy(2,6)=+d/(2.0*sqrt(3.0))
            call zeroit(vp,6)
            vp(3,1)=t
            vp(3,2)=-t
            do i=1,6
              call trnsfr(vphu(1,i),hxy(1,i),2)
              if (mod(i,2) .eq. 1) then
                vphu(3,i)=hl
              else
                vphu(3,i)=hh
              end if
            end do
            call trnsfr(vp(1,3),vphu,18)
            call trnsfr(vphl(1,1),vphu(1,1),21)
            do k=1,7
              vphl(3,k)=-vphl(3,k)
            end do
            call trnsfr(vp(1,9),vphl,18)
            call finddup(vp,ixdup,14,nunique)
            call writevertices(vp,nunique,ioppbc,ioutpdb,iconntyp,
         -    icrot,crot)
            do m=1,6
              call connlinix(vp,m+2,mod(m,6)+3,ixdup,iconntyp,ioutpdb,48)
            end do
            do k=2,6,2
              call connlinix(vp,1,k+2,ixdup,iconntyp,ioutpdb,48)
            end do
            do m=1,6
              call connlinix(vp,8+m,mod(m,6)+9,ixdup,iconntyp,ioutpdb,48)
            end do
            do k=2,6,2
              call connlinix(vp,2,k+8,ixdup,iconntyp,ioutpdb,48)
            end do
            do i=1,6
              call connlinix(vp,i+2,i+8,ixdup,iconntyp,ioutpdb,48)
            end do
          else if (ioppbc .eq. 9) then
            do k=1,3
              vp(k,1)=(-edge_gen(k,1)-edge_gen(k,2)-edge_gen(k,3))/2.0
            end do
            call arrsum(vp(1,1),edge_gen(1,1),vp(1,2),3)
            call arrsum(vp(1,2),edge_gen(1,2),vp(1,3),3)
            call arrsum(vp(1,1),edge_gen(1,2),vp(1,4),3)
            call arrsum(vp(1,1),edge_gen(1,3),vp(1,5),3)
            call arrsum(vp(1,5),edge_gen(1,1),vp(1,6),3)
            call arrsum(vp(1,6),edge_gen(1,2),vp(1,7),3)
            call arrsum(vp(1,5),edge_gen(1,2),vp(1,8),3)
            call writevertices(vp,8,ioppbc,ioutpdb,iconntyp,
         -    icrot,crot)
            do m=1,4
              call connlinix(vp,m,mod(m,4)+1,ixdup,iconntyp,ioutpdb,48)
              call connlinix(vp,m+4,mod(m,4)+5,ixdup,iconntyp,ioutpdb,48)
              call connlinix(vp,m,m+4,ixdup,iconntyp,ioutpdb,48)
            end do
          end if
          return
          end
          subroutine writevertices(vp,n,ioppbc,ioutpdb,iconntyp,icrot,crot)
          character*3 pbcres
          dimension vp(3,n),crot(3,3)
          common /pbcresname/ pbcres(10)
          real*8 c8(3)
          if (iconntyp .eq. 1) return
          if (icrot .eq. 1) call rotate_c(vp,n,crot,vp,'WVERTICES',9)
          do ia=1,n
            do k=1,3
              c8(k)=vp(k,ia)
            end do
            call writepdbd(ioutpdb,c8,ia,1,'VERT',pbcres(ioppbc),'V',1.0,0.)
          end do
          return
          end
          subroutine connlinix(p,i1,i2,ixdup,iconntyp,ioutpdb,max)
          dimension p(3,max)
          dimension ixdup(max)
          if (iconntyp .ne. 2) then
          end if
          if (iconntyp .ne. 1) then
            if (ixdup(i1) .lt. ixdup(i2)) then
              write (ioutpdb,1000) ixdup(i1),ixdup(i2)
            else
              write (ioutpdb,1000) ixdup(i2),ixdup(i1)
            end if
          end if
          return
    1000  format('CONECT',2i5)
          end
          subroutine finddup(p,ixdup,n,nunique)
          dimension p(3,n),ixdup(n),ixshift(48)
          do i=2,n
            do j=1,i-1
              if (ixdup(j) .eq. j) then
                if (dist2(p(1,i),p(1,j)) .le. 0.001) then
                  ixdup(i)=j
                  go to 100
                end if
              end if
            end do
    100     continue
          end do
          ndel=0
          do i=1,n
            if (ixdup(i) .ne. i) then
              ndel=ndel+1
            else
              call trnsfr(p(1,i-ndel),p(1,i),3)
              ixshift(i)=i-ndel
            end if
          end do
          do i=1,n
            ixdup(i)=ixshift(ixdup(i))
          end do
          nunique=n-ndel
          return
          end
          subroutine setcolor(ic)
          common /depthcuedat/ near,ifar,ramp0,idepth,idepthon,idrawh,
         -  linew,isidec,nbackb,idrawslv
          if (idepthon*idepth .eq. 1) then
            if (ic .eq. 0) then
            else
              i1=100*ic+1
              i2=100*(ic+1)
            end if
          else
          end if
          return
          end
          subroutine depthcueonoff(ion)
          common /depthcuedat/ near,ifar,ramp0,idepth,idepthon,idrawh,
         -  linew,isidec,nbackb,idrawslv
          if (ion .eq. 1) then
            idepthon=1
          else
            idepthon=0
          end if
          return
          end
          subroutine kahn(co,nats,docircfit,dir,ip,fp,rms,
         -  iprint,message,MAXHX)
          implicit real*8(a-h,o-z)
    
          real*8 co(3,MAXHX)
          integer nats,iprint
          real*8 ip(3)              !the coordinates of the initial point
          real*8 fp(3)              !the coordinates of the final point
          real*8 dir(3)             !the axis vector
    
          logical docircfit
    
          character*60 Message
          real*8 hsum(3)
    
          real*8 p1(3),p2(3),h(3),v1(3),v2(3),a(3),b(3),r,d
          real*8 tmp(3),p1mp2(3),p2mp1(3),dmag,ddot
          real*8 h1(3,100)
          integer hcount
    
          if (iprint .gt. 3) write (6,7777) ((co(k,i),k=1,3),i=1,nats)
    7777  format(' Axis routine input:',/,(3f10.4))
    
          do i=1,3
             hsum(i)=0.0
          end do
          hcount=1
          do i=2,nats-2
             call dvset(p1,co(1,i))
             call dvset(p2,co(1,i+1))
             call dvdif (p1,co(1,i-1),a)
             call dvdif (p1,co(1,i+1),b)
             call dvnorm(a)
             call dvnorm(b)
             call dvsum(a,b,v1)
             call dvnorm(v1)
             call dvdif (p2,co(1,i),a)
             call dvdif (p2,co(1,i+2),b)
             call dvnorm(a)
             call dvnorm(b)
             call dvsum(a,b,v2)
             call dvnorm(v2)
    
             call dcross(v1,v2,h)
             call dvnorm(h)
             call dvsum(h,hsum,hsum)
    
             call dvdif (p1,p2,p1mp2)
             call dvdif (p2,p1,p2mp1)
             d=ddot(p2mp1,h)        !rise/residue
             call dvmul(h,d,tmp)
    
             r=(dmag(tmp)**2 - dmag(p2mp1)**2)
         -        /(2.0*abs(ddot(p2mp1,v2)))
    
             call dvmul(V1,r,tmp)
             call dvsum(P1,tmp,H1(1,hcount))
             call dvmul(V2,r,tmp)
             call dvsum(P2,tmp,H1(1,hcount+1))
             hcount=hcount+2
          end do
    
          call dvset(dir,hsum)
          call dvnorm(dir)
    
          call parlsq(h1,hcount-1,docircfit,dir,ip,fp,rms,0)
    
          if (docircfit) then
             call circfit(co,nats,dir,ip)
          else
             call dvdif (co(1,1),ip,tmp)
             call dvproj(dir,tmp,tmp)
             call dvsum(ip,tmp,ip)
          end if
    
          call RMScalc(co,nats,dir,ip,fp,RMS)
          call writeout_h(dir,ip,fp,rms,message,iprint)
          return
          end
          subroutine vaset(v,x,y,z)
          real*4 v(3),x,y,z
          V(1) = X
          V(2) = Y
          V(3) = Z
          RETURN
          end
          subroutine VNRM(B,A)
          real*4 b(3),a(3)
    C
          SUM2 = A(1)*A(1) + A(2)*B(2) + A(3)*A(3)
          IF (SUM2 .LT. 1.0E-8) GO TO 50
          SUM = SQRT(SUM2)
          B(1) = A(1) / SUM
          B(2) = A(2) / SUM
          B(3) = A(3) / SUM
          RETURN
    C
     50   B(1) = 0.0
          B(2) = 0.0
          B(3) = 0.0
          RETURN
          end
          subroutine parlsq(co,n,docircfit,dir,ip,fp,rms,iprint)
    
          implicit real*8(a-h,o-z)
          real*8 co(3,n)
          integer n,iprint          !n=number of atoms
          real*8 ip(3)              !the coordinates of the initial point
          real*8 fp(3)              !the coordinates of the final point
          real*8 dir(3)             !the axis vector
          logical docircfit
    
          character*60 message
    
          St=0.
          Srx=0.
          Sry=0.
          Srz=0.
          St_rx=0.
          St_ry=0.
          St_rz=0.
          St2=0.
          do i=1,n
             t= i-1
             St=St + t
             Srx=Srx + co(1,i)
             Sry=Sry + co(2,i)
             Srz=Srz + co(3,i)
             St_rx=St_rx + t * co(1,i)
             St_ry=St_ry + t * co(2,i)
             St_rz=St_rz + t * co(3,i)
             St2=St2 + t**2
          end do
    
          D=St2*n - St*St
          dir(1)=(n*St_rx - St*Srx)/D
          dir(2)=(n*St_ry - St*Sry)/D
          dir(3)=(n*St_rz - St*Srz)/D
    
          if (docircfit) then
             call circfit(co,n,dir,ip)
          else
             ip(1) =(St2*Srx - St*St_rx)/D
             ip(2) =(St2*Sry - St*St_ry)/D
             ip(3) =(St2*Srz - St*St_rz)/D
          end if
    
          call dvnorm(dir)
          call RMScalc(co,n,dir,ip,fp,RMS)
          message='parlsq'
          call writeout_h(dir,ip,fp,rms,message,iprint)
          end
          subroutine RMScalc(co,nats,dir,ip,fp,rms)
          implicit real*8(a-h,o-z)
          real*8 co(3,nats) !the input coordinates
          integer nats              !number of atoms
          real*8 ip(3)              !the coordinates of the initial point
          real*8 fp(3)              !the coordinates of the final point
          real*8 dir(3)             !the axis vector
    
          real*8 tmp(3)
    
          rms=0.0
          sum=0.0
          sum2=0.0
          do i=1,nats
             call dvdif (co(1,i),ip,tmp)
             call dvproj(dir,tmp,tmp)
             call dvsum(ip,tmp,fp)
             dd=ddistsq(co(1,i),fp)
             sum=sum+sqrt(dd)
             sum2=sum2+dd
          end do
          rms=sqrt(sum2/float(nats)-(sum/float(nats))**2)
          end
          subroutine writeout_h(dir,ip,fp,rms,message,iprint)
          real*8 dir(3),ip(3),fp(3),rms
          integer iprint,kprint
          character*60 message
    
          kprint=mod(iprint,10)
          if (kprint .eq. 0) return
    
     10   format(a6,1x,3(f12.6,1x))
     20   format('     RMS deviation: ',f11.6)
          if (message(1:5) .ne. '     ') write(*,*) '  '//message
          write(*,10) '     D',dir
          write(*,10) '     I',ip
          write(*,10) '     F',fp
          write(*,20) rms
          end
          subroutine circfit(x,nats,dir,ip)
          implicit real*8 (a-h,o-z)
          real*8 x(3,nats)
          real*8 xp(3,100)
          real*8 ax(6),sum(5),xp0(3)
          real*8 dir(3),ip(3),tmp(3)
          real*8 zero(3)
          integer nats
    
          data zero/0.,0.,0./
          call dvset(ax(1),ip)
          call dvset(ax(4),dir)
    
    
          call polar(dir(1),dir(2),dir(3),r,thet,fi)
          do iat=1,nats
             call dvset(xp(1,iat),x(1,iat))
             call rotabout(xp(1,iat),zero,-thet,'z')
             call rotabout(xp(1,iat),zero,-fi,'y')
          end do
          call dvset(tmp,dir)
          do i=1,5
             sum(i)=0.
          end do
    
          do i=1,nats
             do j=i+1,nats
                sum(1)=sum(1)+(xp(1,i)-xp(1,j))**2
                sum(2)=sum(2)+(xp(2,i)-xp(2,j))**2
                sum(3)=sum(3)+(xp(1,i)-xp(1,j))*(xp(2,i)-xp(2,j))
                scrat=xp(1,i)**2+xp(2,i)**2-xp(1,j)**2-xp(2,j)**2
                sum(4)=sum(4)+scrat*(xp(1,i)-xp(1,j))
                sum(5)=sum(5)+scrat*(xp(2,i)-xp(2,j))
             end do
          end do
    
          xp0(1)=(sum(4)*sum(2)-sum(5)*sum(3))/
         -     (2.0*(sum(1)*sum(2)-sum(3)**2))
          xp0(2)=(sum(4)-2.0*xp0(1)*sum(1))/(2.0*sum(3))
          xp0(3)=xp(3,1)            !z coordinate of first atom
          call rotabout(xp0,zero,fi,'y')
          call rotabout(xp0,zero,thet,'z')
          call dvset(ax,xp0)
    
          call dvset(ip,ax)
          end
          subroutine polar(x,y,z,r,theta,phi)
          real*8 x,y,z,r,theta,phi
          data PI /3.1415926/
          real*8 cosa
    
          r=(x**2 + y**2 + z**2)**0.5
          if ((x .ne. 0.0) .and. (y .ne. 0.0)) then
             theta=atan(abs(y/x))
             if (y .gt. 0.0) then
                if (x .lt. 0.0) theta=PI-theta ! quadrant 2
             else
                if (x .lt. 0.0) theta=PI+theta ! quadrant 3
                if (x .gt. 0.0) theta=2.0*PI-theta ! quadrant 4
             end if
          else
             if (x .eq. 0.0) then
                if (y .ge. 0.0) then
                   theta=PI/2.0
                else
                   theta=3*PI/2.0
                end if
             end if
             if (y .eq. 0.0) then
                if (x .ge. 0) then
                   theta=0.0
                else
                   theta=PI
                end if
             end if
          end if
          if (r .eq. 0.0) then
             phi = 0.0
          else
             cosa=dble(z)/dble(r)
             phi=dacoscheck(cosa,ccc,1,6,'POLAR')
          end if
          end
          subroutine rotabout(v,v0,t,axis)
          real*8 v(3),v0(3),t,temp(3)
          character*1 axis
    
          st=sin(t)
          ct=cos(t)
          if ((axis .eq. 'x') .or. (axis .eq. 'X')) then
             temp(1)=v(1)
             temp(2)=v0(2) + v(2)*ct - v0(2)*ct - v(3)*st + v0(3)*st
             temp(3)=v0(3) + v(3)*ct - v0(3)*ct + v(2)*st - v0(2)*st
          else
             if ((axis .eq. 'y') .or. (axis .eq. 'Y')) then
                temp(1)=v0(1) + v(1)*ct - v0(1)*ct + v(3)*st - v0(3)*st
                temp(2)=v(2)
                temp(3)=v0(3) + v(3)*ct - v0(3)*ct - v(1)*st + v0(1)*st
             else
                if ((axis .eq. 'z') .or. (axis .eq. 'Z')) then
                   temp(1)=v0(1) + v(1)*ct - v0(1)*ct - v(2)*st + v0(2)*st
                   temp(2)=v0(2) + v(2)*ct - v0(2)*ct + v(1)*st - v0(1)*st
                   temp(3)=v(3)
                else
                   return           !no rotation if wrong axis specified
                end if
             end if
          end if
          do i=1,3
             v(i)=temp(i)
          end do
          end
          subroutine transp(rot,N)
          real rot(N,N),tmp
          do i=1,N
             do j=i+1,N
                tmp=rot(j,i)
                rot(j,i)=rot(i,j)
                rot(i,j)=tmp
             end do
          end do
          return
          end
          subroutine vdiv(z,x,y)
          real*8 x(3), y, z(3)
          integer i
          if (y .lt. 1e-12) then
             write(*,*) 'vdiv: can''t divide vector by zero!'
          else
             do i=1,3
                z(i)=x(i)/y
             end do
          end if
          end
          subroutine dvset(a,b)
          real*8 a(3),b(3)
          a(1)=b(1)
          a(2)=b(2)
          a(3)=b(3)
          return
          end
          subroutine vnorm(x)
          real x(3)
          real rmag,amag
          rmag=amag(x)
          if (rmag .lt. 1e-12) then
             continue
          else
             x(1)=x(1)/rmag
             x(2)=x(2)/rmag
             x(3)=x(3)/rmag
          end if
          end
          subroutine dvnorm(x)
          real*8 x(3)
          real*8 rmag,dmag
          rmag=dmag(x)
          if (rmag .lt. 1e-12) then
             write(*,*) 'dvnorm: can''t normalize zero vector'
          else
             x(1)=x(1)/rmag
             x(2)=x(2)/rmag
             x(3)=x(3)/rmag
          end if
          end
          subroutine dcross(x,y,z)
          real*8 x(3), y(3), z(3)
          z(1)= x(2)*y(3)-y(2)*x(3)
          z(2)=-x(1)*y(3)+y(1)*x(3)
          z(3)= x(1)*y(2)-y(1)*x(2)
          end
          subroutine dvdif(x,y,z)
          real*8 x(3), y(3), z(3)
          z(1)=x(1)-y(1)
          z(2)=x(2)-y(2)
          z(3)=x(3)-y(3)
          end
          subroutine dvmul(x,y,z)
          real*8 x(3), y, z(3)
          z(1)=x(1)*y
          z(2)=x(2)*y
          z(3)=x(3)*y
          end
          subroutine dvdiv(x,y,z)
          real*8 x(3), y, z(3)
          integer i
          if (y .lt. 1e-12) then
             write(*,*) 'dvdiv: can''t divide vector by zero!'
          else
             do i=1,3
                z(i)=x(i)/y
             end do
          end if
          end
          subroutine vsum(x,y,z)
          real*4 x(3), y(3), z(3)
          z(1)=x(1)+y(1)
          z(2)=x(2)+y(2)
          z(3)=x(3)+y(3)
          end
          subroutine dvsum(x,y,z)
          real*8 x(3), y(3), z(3)
          z(1)=x(1)+y(1)
          z(2)=x(2)+y(2)
          z(3)=x(3)+y(3)
          end
          subroutine dvproj(x,y,z)
          real*8 x(3),y(3),z(3)
          real*8 tmp(3),ddot
          call dvset(tmp,x)
          call dvnorm(tmp)
          call dvmul(tmp,ddot(tmp,y),z)
          return
          end
          subroutine resautocorr(ires,incrementac,ncf,xyplot,mxframes)
          dimension xyplot(2,mxframes)
          parameter (MAXFRAMES=50000,MAXCOPY=600)
          common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
         -  increment,increment2,res(2,MAXFRAMES,MAXCOPY),
         -  x0(MAXCOPY),y0(MAXCOPY),nxselres,ixselres(MAXCOPY)
          ncf=nframe/(2*incrementac)
          if (ncf .eq. 0) then
            write (6,1000) nframe,incrementac
            return
          end if
          call zeroit(xyplot,2*ncf)
          do i=1,ncf
            i0=i*incrementac
            do inc=1,ncf-i
              i1=(i+inc)*incrementac
              xyplot(1,inc+1)=xyplot(1,inc+1)+
         -      (res(1,i0,2*ires-1)*res(1,i1,2*ires-1)+
         -      res(2,i0,2*ires-1)*res(2,i1,2*ires-1)+
         -      res(1,i0,2*ires)*res(1,i1,2*ires)+
         -      res(2,i0,2*ires)*res(2,i1,2*ires))/2.0
            end do
          end do
          xyplot(1,1)=1.0
          do i=2,ncf-1
            xyplot(1,i)=xyplot(1,i)/float(ncf-i)
          end do
          xyplot(1,ncf)=xyplot(1,ncf-1)
          return
    1000  format(' PROGRAM ERROR in resautocorr: nframe (',i8,
         -  ') < 2* increment (',i8,')')
          end
          subroutine hydropathylist(n,nslt,ixres,resnames,cv,ihydtyp,
         -  maxrsd,maxrec)
          character*8 resnames
          dimension ixres(maxrec),resnames(maxrsd),cv(n)
          character*3 hphres
          character*1 ans
          dimension hph3(4,23),hphres(23)
          data hphres /
         -  'ALA','ARG','ASN','ASP','CYS','GLN','GLU','GLY','HIS',
         -  'ILE','LEU','LYS','MET','PHE','PRO','SER','THR','TRP','TYR',
         -  'VAL','ASX','GLX','UNK'/
          data hph3 /
         -  0.62,1.80,-0.50,0.0, -2.53,-4.50,-1.81,0.0,
         -  -0.78,-3.50,-0.85,0.0, -0.90,-3.50,-3.64,0.0,
         -  0.29,2.50,0.02,0.0, -0.85,-3.50,-0.77,0.0,
         -  -0.74,-3.50,-3.63,0.0, 0.48,-0.40,-1.15,0.0,
         -  -0.40,-3.20,-2.33,0.0, 1.38,4.50,1.12,0.0,
         -  1.06,3.80,1.25,0.0, -1.50,-3.90,-2.80,0.0,
         -  0.64,1.90,0.67,0.0, 1.19,2.80,1.71,0.0,
         -  0.12,-1.60,-0.14,0.0, -0.18,-0.80,-0.46,0.0,
         -  -0.05,-0.70,-0.25,0.0, 0.81,-0.90,2.09,0.0,
         -  0.26,-1.30,0.71,0.0, 1.08,4.20,0.46,0.0,
         -  -0.84,-3.50,-2.25,0.0, -0.80,-3.50,-2.20,0.0,
         -  0.00,-0.49,-0.52,0.0/
          if (ihydtyp .eq. 0) then
            call quiz(ans,ihydtyp,' ',' ',0,
         -  'hydropathy/hydrophobicity scale source',38,0,5,6,0)
            if (ihydtyp .eq. 4) then
              do i=1,23
                call getreal('Residue '//hphres(i)//' hydrophobicity',26,
         -        999999.0,hph3(4,i),0,0)
              end do
            end if
            write (6,1002) (hphres(i),(hph3(j,i),j=1,4),i=1,23)
          end if
          do ia=1,nslt
            ir=1
            do while (ir .lt. 23 .and.
         -     resnames(ixres(ia))(1:3) .ne. hphres(ir))
              ir=ir+1
            end do
            cv(ia)=hph3(ihydtyp,ir)
          end do
          do ia=nslt+1,n
            cv(ia)=hph3(ihydtyp,23)
          end do
          return
    1002  format(' The residue values stored:',/,
         -   '    Kyte-Dooli Eisenberg     White    Input',/,
         -  (1x,a3,4f10.2))
          end
          subroutine cvlist(c,n,nslt,nsltref_f,nsltref_l,naslv,islvrep,
         -  icvtyp,rcut,rprox,cv,ixtemp,rtemp,dtemp,ifa,ila,it1,ctemp,
         -  isortslv,cvlim)
          dimension c(3,n),cv(n),ixtemp(n),rtemp(n),ifa(n),ila(n),it1(n),
         -  ctemp(3,n),dtemp(n),rprox(n)
          real*8 xnum,ynum,znum,den
          rcut2=rcut*rcut
          call zeroit(rprox,nslt)
          do ia=1,nslt
            xnum=0.d0
            ynum=0.d0
            znum=0.d0
            den=0.d0
            do ja=nsltref_f,nsltref_l
              if (ia .ne. ja) then
                dx=c(1,ia)-c(1,ja)
                dy=c(2,ia)-c(2,ja)
                dz=c(3,ia)-c(3,ja)
                d2=dx*dx+dy*dy+dz*dz
                if (d2 .le. rcut2) then
                  d=sqrt(d2)
                  if (icvtyp .eq. 1) then
                    xnum=xnum+dx/d
                    ynum=ynum+dy/d
                    znum=znum+dz/d
                    den=den+1.d0
                  else
                    xnum=xnum+dx
                    ynum=ynum+dy
                    znum=znum+dz
                    den=den+d
                  end if
                end if
              end if
            end do
            if (den .gt. 0.d0) then
              cv(ia)=1.d0-dsqrt(xnum*xnum+ynum*ynum+znum*znum)/den
            else
              cv(ia)=0.0
            end if
          end do
          if (n .gt. nslt) then
            numslv=(n-nslt)/naslv
            iaa=nslt+islvrep
            do ia=1,numslv
              xnum=0.d0
              ynum=0.d0
              znum=0.d0
              den=0.d0
              d2min=1000000.0
              do ja=nsltref_f,nsltref_l
                dx=c(1,iaa)-c(1,ja)
                dy=c(2,iaa)-c(2,ja)
                dz=c(3,iaa)-c(3,ja)
                d2=dx*dx+dy*dy+dz*dz
                if (d2 .le. rcut2) then
                  d=sqrt(d2)
                  if (icvtyp .eq. 1) then
                    xnum=xnum+dx/d
                    ynum=ynum+dy/d
                    znum=znum+dz/d
                    den=den+1.d0
                  else
                    xnum=xnum+dx
                    ynum=ynum+dy
                    znum=znum+dz
                    den=den+d
                  end if
                end if
                if (d2min .gt. d2) d2min=d2
              end do
              cvi=0.0
              if (den .gt. 0.d0)
         -      cvi=1.d0-dsqrt(xnum*xnum+ynum*ynum+znum*znum)/den
              d2min=sqrt(d2min)
              do i=nslt+(ia-1)*naslv+1,nslt+ia*naslv
                cv(i)=cvi
                rprox(i)=d2min
              end do
              iaa=iaa+naslv
              rtemp(ia)=cvi
              dtemp(ia)=sqrt(d2min)
              ixtemp(ia)=ia
            end do
            if (isortslv .eq. 1) then
              call trnsfr(ctemp(1,nslt+1),c(1,nslt+1),3*(n-nslt))
              call mrgsrt(6,ixtemp,rtemp,numslv,ifa,ila,it1,ctemp,n)
              limfound=0
              if (cvlim .ge. 1.0) limfound=1
              do ia=1,numslv
                ia0=nslt+(ia-1)*naslv
                ix0=nslt+(ixtemp(ia)-1)*naslv
                do i=ia0+1,ia0+naslv
                  cv(i)=rtemp(ia)
                  rprox(i)=dtemp(ia)
                  ix=ix0+(i-ia0)
                  call trnsfr(c(1,i),ctemp(1,ix),3)
                end do
                if (limfound .eq. 0) then
                  if (rtemp(ia) .gt. cvlim) then
                    limfound=1
                    write (6,1000) cvlim,ia-1,cvlim,numslv-ia+1,numslv
                  end if
                end if
              end do
            end if
          end if
          return
    1000  format(' Number of solvents with CV < ',f6.3,'=',i4,/,
         -  ' Number of solvents with CV > ',f6.3,'=',i4,
         -  ' (total: ',i6,')')
          end
          subroutine cvplot(c,n,nslt,imaptyp,line,index,indexr,inamcol1,
         -  inamcol2,iresncol1,iresncol2,repnam,title,ltitle,ncolcode,
         -  maxcolcode,iwr,ips,iclose,maxrec,ipspage)
          dimension c(3,n),index(n),indexr(n)
          character*8 repnam
          character*(*) title
          parameter (MAXPHI=400,MAXCV=2000)
          parameter (IFILL3=MAXPHI*MAXPHI*MAXPHI-(8*MAXCV+5*MAXCV*MAXCV))
          common /nnwork/ mx(MAXCV,MAXCV),rij(3,MAXCV,MAXCV),
         -  dij(MAXCV,MAXCV),cvavfor(MAXCV),cvavback(MAXCV),cvav(MAXCV),
         -  cvrow(MAXCV),cvcol(MAXCV),ca(3,MAXCV),fill(IFILL3)
          dimension rmx(1,1),ixshuffle(MAXCV)
          real*8 rijsum(3),dijsum,forsum(MAXCV),backsum(MAXCV),dmx(1,1)
          character*4 yclab(1)
          character*47 maptyp(2)
          character*8 atnam
          character* 132 line(maxrec)
          common /graphics/ npixx,npixy,maxpixx,maxpixy,idwmain,idwplot,
         -  wx,wy,wz,wxdr
          data mxr /MAXCV/,iok /0/
          data maptyp /
         -  'Domain map based on standard circular variances',
         -  'Domain map based on weighted circular variances'/
          data nyclab /1/,lyclab /1/
          call indexit(ixshuffle,1,MAXCV,0)
          lnam=inamcol2-inamcol1+1
          nres=0
          ireso=0
          icafound=0
          do ia=1,nslt
            atnam(1:lnam)=line(index(ia))(inamcol1:inamcol2)
            call leftadjustn(atnam,atnam,8)
            read (line(index(ia))(iresncol1:iresncol2),*,ERR=999) iresn
            if (iresn .ne. ireso) then
              if (ireso .ne. 0) then
                iok=1
                if (icafound .lt. 1) then
                  print *,'Residue ',ireso,' had no ',repnam(1:lnam)
                  iok=0
                end if
                if (iok .eq. 1) then
                  nres=nres+1
                end if
              end if
              ireso=iresn
              icafound=0
            end if
            if (atnam(1:lnam) .eq. repnam(1:lnam)) then
              if (nres .ge. mxr) then
                print *,'ERROR: program is prepared only for ',mxr,
         -        ' residues'
                stop
              end if
              icafound=1
              call trnsfr(ca(1,nres+1),c(1,ia),3)
            end if
          end do
          if (iok .eq. 1) nres=nres+1
          if (nres .eq. 0) then
            print *,'No residues containing ',repnam(1:lnam),' were found'
            stop
          end if
          print *,'Number of ',repnam(1:lnam),'-containig residues=',nres
          do ix=1,nres
            do iy=ix,nres
              d=0.0
              do k=1,3
                rij(k,iy,ix)=ca(k,iy)-ca(k,ix)
                rij(k,ix,iy)=-rij(k,iy,ix)
                d=d+rij(k,iy,ix)**2
              end do
              d=sqrt(d)
              if (imaptyp .eq. 1 .and. iy .ne. ix) then
                do k=1,3
                  rij(k,iy,ix)=rij(k,iy,ix)/d
                  rij(k,ix,iy)=-rij(k,iy,ix)
                end do
                d=1.0
              end if
              dij(iy,ix)=d
              dij(ix,iy)=d
            end do
          end do
          cvavfor(1)=0.0
          cvavfor(nres)=0.0
          cvavback(1)=0.0
          cvavback(nres)=0.0
          do ix=1,nres
            mx(ix,ix)=9
            call zeroitd(rijsum,3)
            dijsum=0.d0
            forsum(ix)=0.d0
            do iy=ix+1,nres
              do k=1,3
                rijsum(k)=rijsum(k)+rij(k,ix,iy)
              end do
              dijsum=dijsum+dij(ix,iy)
              cv=dsqrt(rijsum(1)**2+rijsum(2)**2+rijsum(3)**2)/dijsum
              cvrow(iy)=cv
              forsum(ix)=forsum(ix)+cv
              mx(ix,iy)=float(ncolcode)*cv+1
              if (mx(ix,iy) .lt. 1) mx(ix,iy)=1
            end do
            if (nrep .le. 1 .and. iwr .gt. 0) write (iwr,2000)
         -     'For',ix,forsum(ix),(cvrow(iy),iy=ix+1,nres)
          end do
          do ix=nres,1,-1
            call zeroitd(rijsum,3)
            dijsum=0.d0
            backsum(ix)=0.d0
            do iy=ix-1,1,-1
              do k=1,3
                rijsum(k)=rijsum(k)+rij(k,ix,iy)
              end do
              dijsum=dijsum+dij(ix,iy)
              cv=dsqrt(rijsum(1)**2+rijsum(2)**2+rijsum(3)**2)/dijsum
              cvcol(iy)=cv
              backsum(ix)=backsum(ix)+cv
              mx(ix,iy)=float(ncolcode)*cv+1
              if (mx(ix,iy) .lt. 1) mx(ix,iy)=1
            end do
            if (nrep .le. 1 .and. iwr .gt. 0)
         -    write (iwr,2000) 'Bac',ix,backsum(ix),(cvcol(iy),iy=1,ix-1)
          end do
          do ix=2,nres-1
            cvavfor(ix)=forsum(ix)/(nres-ix)
            cvavback(ix)=backsum(ix)/(ix-1)
            cvav(ix)=(forsum(ix)+backsum(ix))/nres
          end do
          if (nrep .le. 1 .and. iwr .gt. 0)
         -  write (iwr,2001) (cvav(ix),ix=1,nres)
          nrep=0
          nrep=nrep+1
          inc=max0(1,500/nres)
          ixdel=25
          iydel=115
          iytop=0
          call plotmat(ips,mx,rmx,dmx,nres,nres,0,0,0,0,1,nrep,ixdel,iydel,
         -  0,iytop,0.0,1.0,ncolcode,maxcolcode,ixdelsh,iydelsh,inc,1.0,
         -  indexr,ixshuffle,ixshuffle,title,ltitle,' ',0,0,' ',1,ca,yclab,
         -  nyclab,lyclab,mxr,1,1,MAXCV,mxr,ipspage,0)
          iydown=-80
          if (nres .lt. 750) ixdel=ixdel+45
          scalefac=inc
          call colstrip(cvavfor,nres,ixdel,scalefac,iydown,nrep,' F',
         -  ncolcode,ips)
          call colstrip(cvavback,nres,ixdel,scalefac,iydown+18,nrep,' B',
         -  ncolcode,ips)
          call colstrip(cvav,nres,ixdel,scalefac,iydown+36,nrep,' T',
         -  ncolcode,ips)
          iydown=iydown+54
          call colcode01(ips,ixdel,iydown+5,ncolcode,nrep)
          iydown=iydown+18
          if (nrep .le. 1) then
            call rgbcolor(ips,9)
            write (ips,3001) ixdel,iydown
            call psshow(ips,maptyp(imaptyp),47)
          end if
          write (ips,*) 'showpage'
          if (iclose .eq. 1) then
            close (iwr)
            close (ips)
          end if
          return
    999   print *,'ERROR: illegal residue number in line',index(ia),':'
          print *,line(index(ia))(1:80)
          stop
    2000  format(1x,a,i4,f10.4,(20f5.2))
    2001  format(' CV column averages:',/,(8x,20f5.2))
    3001  format(i4,i5,' m')
          end
          subroutine plotmat(ips,kc,rc,dc,nresx,nresy,ixinc,iyinc,
         -  ixincshift,iyincshift,navg,nrep,ixdel0,iydel0,idown,iytop,rcmin,
         -  rcmax,ncol,maxcol,ixdel,iydel,incinp,scalefacinp,index,
         -  ixshufflex,ixshuffley,title,ltitle,title2,ltitle2,itrajname,
         -  xylab,lxylab,xyval,yclab,nyclab,lyclab,mxr,mxrr,mxrd,mx,mxix,
         -  ipspage,ipsclose)
          character*(*) title,title2,xylab,yclab(nyclab)
          real*8 dc
          dimension kc(mxr,mxr),rc(mxrr,mxrr),dc(mxrd,mxrd),index(mxix),
         -  ixshufflex(mx),ixshuffley(mx),xyval(mx)
          data ix0 /0/,iy0 /0/,rcxy /0.0/
          incr_tr=1
          incr_tr2=1
          scalefac=scalefacinp
          lycinc=lyclab/10
          scalefac=scalefac*(1.0-lycinc*0.04)
          icharsize=12
          ipsdraw=ips
          ipsdraw=-ipsdraw
          maxrrgb=maxcol
          maxcol1=maxcol+1
          ipspage=ipspage+1
          write (ips,1020) ipspage
          inc=incinp*navg
          write (ips,3011) icharsize
          if (rcmax .eq. rcmin) rcmax=rcmax+0.1
          ixdel=ixdel0
          ixdelmat=ixdel0
          iydel=iydel0
          if (scalefac .ne. 1.0) then
            write (ips,3003) scalefac,scalefac
            icharscale=float(icharsize)/scalefac
            write (ips,3011) icharscale
            iydel=iydel/scalefac
            iytop=iytop/scalefac
            ixdel=ixdel/scalefac
          end if
          if (nresx*scalefac .lt. 550) ixdelmat=ixdel0+40/scalefac
          if (iytop .eq. 0) iytop=iydel+nresy*inc
          if (ltitle .gt. 0) then
            iytop=iytop+15
            call pswrite(ips,ixdel,iytop,'m',1)
            write (ips,*) '(System: ) show'
            call psshow(ips,title,ltitle)
          end if
          if (itrajname .eq. 3) then
            iytop=iytop+15
            call pswrite(ips,ixdel,iytop,'m',1)
            call write_traj_lim(ips,' ',1,2,incr_tr2,1)
            iytop=iytop+15
            call pswrite(ips,ixdel,iytop,'m',1)
            call write_traj_lim(ips,' ',1,1,incr_tr,1)
          else if (itrajname .gt. 0) then
            iytop=iytop+15
            call pswrite(ips,ixdel,iytop,'m',1)
            call write_traj_lim(ips,' ',1,itrajname,incr_tr,1)
          end if
          if (ltitle2 .gt. 0) then
            iytop=iytop+15
            call pswrite(ips,ixdel,iytop,'m',1)
            call psshow(ips,title2,ltitle2)
          end if
          write (ips,3005) 'Plot matrix elements'
          do iyy=1,nresy
            iy=ixshuffley(iyy+iyinc)-iyincshift
            kcprev=-1
            do ixx=1,nresx
              ix=ixshufflex(ixx+ixinc)-ixincshift
              if (mxr .gt. 1) then
                kccurr=kc(ix,iy)
              else
                if (mxrr .gt. 1) rcxy=rc(ix,iy)
                if (mxrd .gt. 1) rcxy=dc(ix,iy)
                if (ncol .eq. 0) then
                  kccurr=100.0*(rcxy-rcmin)/(rcmax-rcmin)+1.0
                else
                  if (rcxy .le. rcmin) then
                    kccurr=0
                  else if (rcxy .gt. rcmax) then
                    kccurr=ncol+1
                  else
                    rr=amax1(-0.00001,rcxy-rcmin-0.00001)
                    kccurr=(rr/(rcmax-rcmin))*ncol+1
                  end if
                end if
              end if
              if (nrep .le. 1) then
                if (kccurr .ne. kcprev) then
                  if (kcprev .ne. -1 .and. (kcprev .ne. maxcol1 .or.
         -            ncol .eq. 0)) then
                    call pswrite(ips,ixdelmat+(ixx-1)*inc,iydel+(iyy)*inc,
         -            'l',1)
                    call pswrite(ips,ixdelmat+(ixx-1)*inc,iydel+(iyy-1)*inc,
         -            'l',1)
                    call pswrite(ips,ix0-inc,iy0-inc,'l',1)
                    write (ips,3006)
                    ix0=-1
                  end if
                  if (kccurr .ne. maxcol1 .or. ncol .eq. 0) then
                    if (ncol .eq. 0) then
                      call rrgbcolor(ips,kccurr,100,0)
                    else
                      call rgbcolor(ips,kccurr)
                    end if
                    ix0=ixdelmat+(ixx)*inc
                    iy0=iydel+(iyy)*inc
                    call pswrite(ips,ix0-inc,iy0-inc,'m',1)
                    call pswrite(ips,ix0-inc,iy0,'l',1)
                  end if
                  kcprev=kccurr
                end if
              end if
            end do
            if (ix0 .ne. -1 .and. nrep .le. 1) then
              call pswrite(ips,ixdelmat+(nresx)*inc,iydel+(iyy)*inc,'l',1)
              call pswrite(ips,ixdelmat+(nresx)*inc,iydel+(iyy-1)*inc,'l',1)
              call pswrite(ips,ix0-inc,iy0-inc,'l',1)
              write (ips,3006)
            end if
          end do
          ridown=idown
          idown1=idown+06
          idown2=idown1+9
          rydel=iydel-idown
          rydel1=iydel-idown1
          rydel2=iydel-idown2
          write (ips,3004) 2
          call rgbcolor(ips,9)
          irxmax=nresx
          irymax=nresy
          if (lxylab .gt. 1) then
            write (ips,3000)
            ix=ixdelmat+(nresx*inc)*0.45
            iydown=30/scalefac
            call pswrite(ips,ix,iydel-idown-iydown,'m',1)
            write (ips,3009) xylab(1:lxylab)
            write (ips,3001)
            xmax=xyval(nresx)
            call roundlim(xmax,xdiv,nxdiv)
            ymax=xyval(nresy)
            if (iyinc .gt. 0) ymax=xyval(nresy+iyinc)-xyval(iyinc)
            call roundlim(ymax,ydiv,nydiv)
            xdiv_i=xdiv*float(nresx)/xmax
            ydiv_i=ydiv*float(nresy)/ymax
            iydiv=ydiv
          else
            call roundlimint(nresx,ixdiv,nxdiv)
            call roundlimint(nresy,iydiv,nydiv)
            xdiv=ixdiv
            ydiv=iydiv
            xdiv_i=ixdiv
            ydiv_i=iydiv
            xmax=xdiv*nresx
            ymax=ydiv*nresy
          end if
          write (ips,3005) 'Plot bounding rectangle'
          call drawrect(ipsdraw,9,1,ixdelmat,ixdelmat+nresx*inc,iydel,
         -  iydel+max0(nresy,iydiv/incr_tr)*inc,nrep)
          write (ips,3005) 'Plot ticks, axis values'
          ixadd=0
          iyadd=0
          if (abs(xmax-nxdiv*xdiv) .lt. xmax*0.01) ixadd=1
          if (abs(ymax-nydiv*ydiv) .lt. ymax*0.01) iyadd=1
          idown1=idown1/scalefac
          idown2=idown2/scalefac
          ixsshift=14/scalefac
          itickstep=10/(xdiv_i*inc)+1
          do itic=1,nxdiv+ixadd,itickstep
            if (lxylab .le. 1) then
              ir=itic*xdiv_i*inc
            else
              ir=(itic-1)*xdiv_i*inc
            end if
            irinc=max0(1,ir/inc)
            if (index(irinc) .le. irxmax) then
              if (nrep .le. 1) then
                write (ips,3000)
                call pswrite(ips,ixdelmat+ir,iydel+nresy*inc+idown,'m',1)
                call pswrite(ips,ixdelmat+ir,iydel+nresy*inc+idown1,'l',1)
                write (ips,3001)
                write (ips,3000)
                call pswrite(ips,ixdelmat+ir,iydel-idown,'m',1)
                call pswrite(ips,ixdelmat+ir,iydel-idown1,'l',1)
                write (ips,3001)
                call pswrite(ips,ixdelmat+ir-ixsshift,iydel-idown2,'m',1)
                if (lxylab .le. 1) then
                  write (ips,3008) index(irinc)
                else if (xylab(1:1) .eq. ' ' .or.
         -               xdiv .ge. 1.0) then
                  ix=navg*(itic-1)*xdiv
                  write (ips,3008) ix
                else
                  write (ips,3010) navg*(itic-1)*xdiv
                end if
              end if
            end if
          end do
          itickstep=10/(ydiv_i*inc)+1
          do itic=1,nydiv+iyadd,itickstep
            if (lxylab .le. 1) then
              ir=itic*ydiv_i*inc
            else
              ir=(itic-1)*ydiv_i*inc
            end if
            irinc=max0(1,ir/inc)+iyinc
            if (index(irinc) .le. iyinc+irymax .or. itic .eq. 1) then
              write (ips,3000)
              call pswrite(ips,ixdelmat,iydel+ir,'m',1)
              call pswrite(ips,ixdelmat-(idown1-idown),iydel+ir,'l',1)
              write (ips,3001)
              write (ips,3000)
              call pswrite(ips,ixdelmat+nresx*inc,iydel+ir,'m',1)
              if (nyclab .le. 1) then
                call pswrite(ips,ixdelmat+nresx*inc+(idown1-idown),iydel+ir,
         -        'l',1)
              else
                call pswrite(ips,ixdelmat+nresx*inc-(idown1-idown),iydel+ir,
         -        'l',1)
              end if
              write (ips,3001)
              if (ixdelmat .gt. ixdel0) then
                call pswrite(ips,ixdel0,iydel+ir-4,'m',1)
                if (lxylab .le. 1) then
                  write (ips,3008) index(irinc)
                else if (xylab(1:1) .eq. ' ' .or.
         -               ydiv .ge. 1.0) then
                  iy=navg*(itic-1)*ydiv+iyinc
                  write (ips,3008) iy
                else
                  write (ips,3010) navg*(itic-1)*ydiv
                end if
              end if
            end if
          end do
          if (nyclab .gt. 1) then
            write (ips,3011) icharsize/2+1
            do iy=1,nyclab
              call pswrite(ips,ixdelmat+nresx*inc,iydel+(iy-1)*inc+inc/3,
         -      'm',1)
              write (ips,3009) yclab(iy)(1:lyclab)
            end do
            write (ips,3011) icharsize
          end if
          if (scalefac .ne. 1.0) then
            write (ips,3003) 1.0/scalefac,1.0/scalefac
            write (ips,3011) icharsize
          end if
          if (ipsclose .eq. 1) close (ips)
          return
    1020  format('%%Page: 1 ',i4)
    3000  format('np')
    3001  format('sk')
    3003  format(f10.6,f10.6,' scale')
    3004  format(i5,' lw')
    3005  format('% ',a)
    3006  format('f')
    3008  format('(',i6,') show')
    3009  format('(',a,') show')
    3010  format('(',f6.2,') show')
    3011  format('/Helvetica findfont',/,i4,' scalefont',/,'setfont')
          end
          subroutine contractmat(rij,nxo,nyo,nxn,nyn,navg,ixx,ixy,
         -  itemp1,itemp2,temp,isort,iouttemp,ndim)
          dimension rij(ndim,ndim),ixx(ndim),ixy(ndim),
         -  itemp1(ndim),itemp2(ndim),temp(ndim)
          character*9 filename
          navgdef=max0(1,max0(nxo,nyo)/1000)
          call getint(
         -  'Number of x and y entries to average in the 2D-RMSD plot',56,
         -  navgdef,1,min0(nxo,nyo),navg,122)
          if (navg .eq. 1) then
            write (6,*) 'All matrix elements will be plotted'
            nxn=nxo
            nyn=nyo
            return
          else
            ntry=0
            iopen=1
            filename='rij__.tmp'
            do while (ntry .lt. 10 .and. iopen .gt. 0)
              write (filename(5:5),1000) ntry
              open(unit=iouttemp,status='new',file=filename,iostat=iopen,
         -      form='unformatted')
              ntry=ntry+1
            end do
            if (iopen .gt. 0) then
              print *,'PROGRAM ERROR: could not open rij.tmp'
              stop
            end if
            write (iouttemp) ((rij(i,j),i=1,nxo),j=1,nyo)
            if (isort .gt. 0) then
              do iy=1,nyo
                do i=1,nxo
                  temp(i)=rij(ixx(i),iy)
                end do
                call trnsfr(rij(1,iy),temp,nxo)
              end do
              call trnsfi(itemp1,ixy,nyo)
              do i=1,nyo
                itemp2(itemp1(i))=i
              end do
              do iy=1,nyo
                call trnsfr(temp,rij(1,itemp1(iy)),nxo)
                call trnsfr(rij(1,itemp1(iy)),rij(1,iy),nxo)
                call trnsfr(rij(1,iy),temp,nxo)
                itemp1(itemp2(iy))=itemp1(iy)
                itemp2(itemp1(itemp1(iy)))=itemp1(iy)
              end do
            end if
            nxn=(nxo-1)/navg+1
            nyn=(nyo-1)/navg+1
            do ix=1,nxn
              do iy=1,nyn
                sum=0.0
                ixf0=(ix-1)*navg
                iyf0=(iy-1)*navg
                ixl=min0(nxo,ixf0+navg)
                iyl=min0(nyo,iyf0+navg)
                do jx=ixf0+1,ixl
                  do jy=iyf0+1,iyl
                    sum=sum+rij(jx,jy)
                  end do
                end do
                if (ixl .eq. ixf0 .or. iyl .eq. iyf0) then
                  write (6,9781) ixl,ixf0,iyl,iyf0
    9781          format(' ixl,ixf0=',2i6,' iyl,iyf0=',2i6)
                end if
                rij(ix,iy)=sum/((ixl-ixf0)*(iyl-iyf0))
              end do
            end do
          end if
          return
    1000  format(i1)
          end
          subroutine pswrite(iout,i1,i2,lab,llab)
          character*(*) lab
          character*80 line
          icol=1
          call writeint(line,icol,i1,lenw)
          line(icol:icol)=' '
          icol=icol+1
          call writeint(line,icol,i2,lenw)
          line(icol:icol)=' '
          line(icol+1:icol+llab)=lab(1:llab)
          write (iout,1000) line(1:icol+llab)
          return
    1000  format(a)
          end
          subroutine writeint(line,icol,int,len)
          character*(*) line
          ii=int
          if (ii .lt. 0) ii=-ii
          if (ii .eq. 0) then
            len=1
          else
            rii=ii+0.00001
            len=alog10(rii)+1
          end if
          if (int .lt. 0) len=len+1
          if (len .eq. 1) then
            write (line(icol:icol),101) int
          else if (len .eq. 2) then
            write (line(icol:icol+1),102) int
          else if (len .eq. 3) then
            write (line(icol:icol+2),103) int
          else if (len .eq. 4) then
            write (line(icol:icol+3),104) int
          else if (len .eq. 5) then
            write (line(icol:icol+4),105) int
          else if (len .eq. 6) then
            write (line(icol:icol+5),106) int
          else if (len .eq. 7) then
            write (line(icol:icol+6),107) int
          else if (len .eq. 8) then
            write (line(icol:icol+7),108) int
          else if (len .eq. 9) then
            write (line(icol:icol+8),109) int
          end if
          icol=icol+len
          return
    101   format(i1)
    102   format(i2)
    103   format(i3)
    104   format(i4)
    105   format(i5)
    106   format(i6)
    107   format(i7)
    108   format(i8)
    109   format(i9)
          end
          subroutine drawrect(ips0,kc,lw,ix0,ix1,iy0,iy1,nrep)
          ips=iabs(ips0)
          if (nrep .le. 1) then
            write (ips,3004) lw
            write (ips,3000)
            call rgbcolor(ips,kc)
            call pswrite(ips,ix0,iy0,'m',1)
            call pswrite(ips,ix0,iy1,'l',1)
            call pswrite(ips,ix1,iy1,'l',1)
            call pswrite(ips,ix1,iy0,'l',1)
            call pswrite(ips,ix0,iy0,'l',1)
            write(ips,3001)
          end if
          return
    3000  format('np')
    3001  format('sk')
    3004  format(i5,' lw')
          end
          subroutine rainbowscale(iplot,ix0,ixwid,iy0,n,rn,rmin,rmax,
         -  label,llabel)
          character*(*) label
          write (iplot,1019) 15
          ixprev=ix0
          do i=1,100
            call rrgbcolor(iplot,i,100,1)
            ix=ix0+ixwid*float(i)/float(100)
            write (iplot,1002) ixprev,iy0
            write (iplot,1009) ix,iy0
            ixprev=ix
          end do
          write (iplot,1011)
          call rrgbcolor(iplot,i,1,0)
          write (iplot,1002) ix0-30,iy0-25
          if (n .eq. 0 .and. rn .eq. 0.0) then
            write (iplot,1014) rmin
            ixlabwid=8.0*alog10(amax1(10.1,rmax))
            write (iplot,1002) ix0+ixwid-30-ixlabwid,iy0-25
            write (iplot,1014) rmax
          else
            write (iplot,1013) 0
            if (rn .gt. float(n)) then
              ixlabwid=8.0*alog10(amax1(10.1,rn))
              write (iplot,1002) ix0+ixwid-30-ixlabwid,iy0-25
              write (iplot,1014) rn
            else
              ixlabwid=8.0*(alog10(float(n))+2.0)
              write (iplot,1002) ix0+ixwid-ixlabwid,iy0-25
              write (iplot,1013) n
            end if
          end if
          write (iplot,1002) ix0+ixwid/2-50,iy0-25
          call psshow(iplot,label,llabel)
          return
    1002  format(i4,i5,' moveto')
    1009  format(i4,i5,' lineto')
    1011  format('stroke')
    1013  format('(',i10,') show')
    1014  format('(',f10.4,') show')
    1019  format(i5,' setlinewidth')
          end
          subroutine colstrip(cvav,nres,ixdel,scalefac,iydown,nrep,lab,ncol,
         -  ips)
          dimension cvav(nres)
          character*2 lab
          riy=iydown
          if (nrep .le. 1) then
            write (ips,3004) 12
            write (ips,*) 'np'
            write (ips,3001) ixdel,-iydown
          end if
          kcprev=0
          ixcurr=kcprev
          ix=1
          rrprev=0.0
          ixxprev=ixdel
          do while (ix .lt. nres)
            do while (ixcurr .eq. kcprev .and. ix .lt. nres)
              ix=ix+1
              ixcurr=ncol*cvav(ix)+1
              if (ix .eq. nres) ixcurr=0
            end do
            if (kcprev .gt. ncol) kcprevncol=ncol
            rr=ix-1
            if (nrep .le. 1) then
              call rgbcolor(ips,kcprev)
              write (ips,*) 'np'
              ixx=ixdel+scalefac*(ix-1)
              write (ips,3001) ixxprev,-iydown
              write (ips,3002) ixx,-iydown
              write (ips,*) 'sk'
              ixxprev=ixx
            end if
            kcprev=ixcurr
          end do
          rr=nres
              rx=nres+5
          if (nrep .le. 1) then
            call rgbcolor(ips,kcprev)
            write (ips,*) 'np'
            ixnres=ixdel+scalefac*nres
            write (ips,3001) ixnres,-iydown
            call rgbcolor(ips,9)
            write (ips,3001) ixnres+5,-iydown-5
            call psshow(ips,lab,2)
            write (ips,*) 'sk'
          end if
          return
    3001  format(i4,i5,' m')
    3002  format(i4,i5,' l')
    3004  format(i5,' setlinewidth')
          end
          subroutine colcode01(ips,ixright,iydown,ncode,nrep)
          iyd0=iydown-2
          iyd1=iydown+3
          iyd2=iydown+8
          if (nrep .le. 1) then
            write (ips,3004) 12
            do icol=1,ncode
              call rgbcolor(ips,9)
              ix0=ixright+(icol-1)*50
              write (ips,3001) ix0,-iyd2
              write (ips,3012) ncode-icol,ncode
              write (ips,*) 'np'
              call rgbcolor(ips,icol)
              write (ips,3001) ix0+35,-iyd1
              write (ips,3002) ix0+45,-iyd1
              write (ips,*) 'sk'
            end do
          end if
          do icol=1,ncode
            call drawrect(-ips,9,1,ix0+35,ix0+45,-iyd2,-iyd0,nrep)
          end do
          return
    3001  format(i4,i5,' m')
    3002  format(i4,i5,' l')
    3004  format(i5,' setlinewidth')
    3012  format('(>',i1,'/',i1,':) show')
          end
          subroutine colcodeminmax(ips,ixright,iydown,nrep,ncode,maxcode,
         -  rmin,rmax)
          character*6 limline
          iyd0=iydown-2
          iyd1=iydown+3
          iyd2=iydown+8
          absmax=amax1(abs(rmin),abs(rmax))
          if (nrep .le. 1) then
            write (ips,3004) 12
            do icol=0,ncode+1
              call rgbcolor(ips,9)
              ix0=ixright+(icol)*50
              write (ips,3001) ix0,-iyd2
              if (icol .le. ncode) then
                write (ips,3012) '<=',icol,ncode
                icoldrw=icol
              else
                write (ips,3012) '>',ncode,ncode
                icoldrw=maxcode+1
              end if
              write (ips,*) 'np'
              call rgbcolor(ips,icoldrw)
              write (ips,3001) ix0+35,-iyd1
              write (ips,3002) ix0+45,-iyd1
              write (ips,*) 'sk'
            end do
            iyd3=iyd2+15
            call rgbcolor(ips,9)
            do icol=0,ncode+1
              ix0=ixright+(icol)*50
              write (ips,3001) ix0,-iyd3
              rlim=rmin+float(icol)*(rmax-rmin)/float(ncode)
              if (icol .gt. ncode) rlim=rmax
              if (absmax .lt. 1.0) then
                write (limline,3013) rlim
              else if (absmax .lt. 10.0) then
                write (limline,3014) rlim
              else
                write (limline,3015) rlim
              end if
              if (icol .le. ncode) then
                write (ips,3016) '<=',limline
                icoldrw=icol
              else
                write (ips,3016) '>',limline
                icoldrw=maxcode+1
              end if
            end do
          end if
          call rgbcolor(ips,9)
          do icol=0,ncode+1
            ix0=ixright+(icol)*50
            call drawrect(-ips,9,1,ix0+35,ix0+45,-iyd2,-iyd0,nrep)
          end do
          return
    3001  format(i4,1x,i5,' m')
    3002  format(i4,1x,i5,' l')
    3004  format(i5,' setlinewidth')
    3012  format('(',a,i1,'/',i1,':) show')
    3013  format(f6.3)
    3014  format(f6.2)
    3015  format(f6.1)
    3016  format('(',a,a,') show')
          end
          subroutine rgbcolor_sgi(iout,icol)
          if (icol .eq. 0) then
            write (iout,1000) 1.0,1.0,1.0
          else if (icol .eq. 1) then
            write (iout,1000) 1.0,0.0,0.0
          else if (icol .eq. 2) then
            write (iout,1000) 0.0,1.0,0.0
          else if (icol .eq. 3) then
            write (iout,1000) 1.0,1.0,0.0
          else if (icol .eq. 4) then
            write (iout,1000) 0.0,0.0,1.0
          else if (icol .eq. 5) then
            write (iout,1000) 1.0,0.0,1.0
          else if (icol .eq. 6) then
            write (iout,1000) 0.0,1.0,1.0
          else if (icol .eq. 7) then
            write (iout,1000) 1.0,0.5,0.0
          else if (icol .eq. 8) then
            write (iout,1000) 0.5,1.0,0.0
          else if (icol .eq. 9) then
            write (iout,1000) 0.0,0.0,0.0
          end if
          return
    1000  format(3f5.1,' setrgbcolor')
          end
          subroutine rgbcolor(iout,icolinp)
          common /colorinfo/ ncolcode,maxcolcode
          dimension icolconv(9,8)
          data icolconv /
         -  1,9,0,0,0,0,0,0,9,
         -  1,6,9,0,0,0,0,0,9,
         -  1,4,6,9,0,0,0,0,9,
         -  1,3,4,6,9,0,0,0,9,
         -  1,3,4,6,10,9,0,0,9,
         -  1,3,4,5,6,10,9,0,9,
         -  1,2,3,4,5,6,10,9,9,
         -  1,2,3,4,5,6,7,8,9/
          if (icolinp .eq. maxcolcode+1 .or. icolinp .eq. 0) then
            icol=icolinp
          else if (icolinp .lt. 0) then
            icol=-icolinp
          else
            icol=icolconv(icolinp,ncolcode)
          end if
          if (icol .eq. 0) then
            write (iout,1000) 1.0,1.0,1.0
          else if (icol .eq. 1) then
            write (iout,1000) 1.0,0.0,0.0
          else if (icol .eq. 2) then
            write (iout,1000) 1.0,0.5,0.0
          else if (icol .eq. 3) then
            write (iout,1000) 1.0,1.0,0.0
          else if (icol .eq. 4) then
            write (iout,1000) 0.0,1.0,0.0
          else if (icol .eq. 5) then
            write (iout,1000) 0.0,1.0,1.0
          else if (icol .eq. 6) then
            write (iout,1000) 0.0,0.0,1.0
          else if (icol .eq. 7) then
            write (iout,1000) 0.5,0.0,1.0
          else if (icol .eq. 8) then
            write (iout,1000) 1.0,0.0,0.5
          else if (icol .eq. 9) then
            write (iout,1000) 0.0,0.0,0.0
          else if (icol .eq. 10) then
            write (iout,1000) 1.0,0.0,1.0
          end if
          return
    1000  format(3f5.1,' setrgbcolor')
          end
          subroutine rrgbcolor(iout,icol,imax,iprt)
          if (iprt .eq. 1) write (iout,*) 'stroke'
          if (imax .eq. 1) then
            write (iout,1000) 0.0,0.0,0.0
          else
            rcol=float(icol-1)/float(imax-1)
            if (rcol .le. 0.25) then
              write (iout,1000) 1.0,4.0*rcol,0.0
            else if (rcol .le. 0.5) then
              write (iout,1000) (2.0-4.0*rcol),1.0,0.0
            else if (rcol .le. 0.75) then
              write (iout,1000) 0.0,1.0,4.0*(rcol-0.5)
            else
              write (iout,1000) 0.0,4.0-4.0*rcol,1.0
            end if
          end if
          if (iprt .eq. 1) write (iout,*) 'newpath'
          return
    1000  format(3f6.2,' setrgbcolor')
          end
          subroutine plotdssp(ips,ifss,ilss,itypss,nss,icx,maxconf,framefac,
         -  nxd,nyd,itit,ntit,xlab,nxlab,ylab,nylab,nframe,ifrdssp,ilrdssp,
         -  ixresno)
          dimension ifss(nss),ilss(nss),itypss(nss),ixresno(ilrdssp)
          character*(*) itit,xlab,ylab
          dimension shiftl(9)
          character*1 typc
          character*21 ssname
          common /dsspnames/ lssname(9),ssname(9),typc(9)
          data shiftl /0.0,0.19,0.41,0.64,0.0,0.3,0.45,0.6,0.75/
          xm=675
          ym=495
          xmm=0.9*xm
          ymm=0.9*ym
          xm0=0.076*xm
          ym0=0.085*ym
          ixd=maxconf/nxd
          if (mod(maxconf,nxd) .ne. 0) ixd=ixd+1
          maxrsd=ilrdssp-ifrdssp+1
          iyd=maxrsd/nyd
          if (mod(maxrsd,nyd) .ne. 0) iyd=iyd+1
          xmax=nxd*ixd
          ymax=nyd*iyd
          if (nframe .eq. 1) then
            call psheader(ips,itit,ntit,-30,-130,830,830,1,ipspage)
            write (ips,1006)
            write (ips,3000)
            write (ips,*) '-90 rotate'
            write (ips,1001) -xm*1.1,0.1*ym,' translate'
            write (ips,*) 'np'
            write (ips,1001) xm0,ym0,' m'
            write (ips,1001) xm0,ym0+ymm,' l'
            write (ips,1001) xm0+xmm,ym0+ymm,' l'
            write (ips,1001) xm0+xmm,ym0,'   l'
            write (ips,1001) xm0,ym0,' l'
            write (ips,*) 'sk'
            write (ips,*) 'np'
            write (ips,1001) xm0,ym0+1.03*ymm,' m'
            call psshow(ips,itit,ntit)
            write (ips,1001) xm0+0.50*xmm,ym0+1.02*ymm,' m'
            write (ips,*) 'sk'
            write (ips,*) 'np'
            write (ips,1001) xm0+0.45*xmm,ym0-0.07*ymm,' m'
            call psshow(ips,xlab,nxlab)
            write (ips,*) 'sk'
            write (ips,1001) xm0-0.06*xmm,ym0+0.4*ymm,' translate'
            write (ips,*) '90 rotate'
            write (ips,*) 'np'
            write (ips,1001) 0.0,0.0,' m'
            call psshow(ips,ylab,nylab)
            write (ips,*) 'sk'
            write (ips,*) '-90 rotate'
            write (ips,1001) -(xm0-0.06*xmm),-(ym0+0.4*ymm),' translate'
            write (ips,*) 3,' setlinewidth'
            yinc=0.10*ymm
            do is=1,9
              if (is .eq. 5) yinc=yinc+0.05*ymm
              call rgbcolor(ips,is)
              write (ips,*) 'np'
              write (ips,1001) xm0+shiftl(is)*xmm,ym0-yinc,' m'
              call psshow(ips,ssname(is),lssname(is))
              call psshow(ips,':',1)
              write (ips,1005) 0.01*xmm,0.006*ymm,' rmoveto'
              write (ips,1005) 0.040*xmm,0.0,' rlineto'
              write (ips,1005) 0.01*xmm,-0.006*ymm,' rmoveto'
              write (ips,*) 'sk'
            end do
            write (ips,*) 'np'
            write (ips,*) 1,' setlinewidth'
            call rgbcolor(ips,9)
            ifloatx=0
            if (xlab(1:1) .ne. ' ' .and. framefac*float(ixd) .lt. 100.0)
         -    ifloatx=1
            do ix=1,nxd
              write (ips,*) 'np'
              write (ips,1001) xm0+xmm*float(ix)/float(nxd),ym0,' m'
              write (ips,1001) 0.0,+0.01*ymm,' rlineto'
              write (ips,*) 'sk'
              write (ips,*) 'np'
              write (ips,1001) xm0+0.02*xmm+xmm*float(2*ix-1)/float(2*nxd),
         -      ym0-0.04*ymm,' m'
              if (ifloatx .eq. 0) then
                ixl=framefac*float(ix*ixd)
                write (ips,1002) ixl
              else
                write (ips,1007) framefac*float(ix*ixd)
              end if
            end do
            do iy=1,nyd
              write (ips,*) 'np'
              write (ips,1001) xm0,ym0+float(iy)/float(nyd)*ymm,' m'
              write (ips,1001) +0.01*xmm,0.0,' rlineto'
              write (ips,*) 'sk'
              write (ips,*) 'np'
              write (ips,1001) xm0-0.07*xmm,ym0-0.01*ymm+
         -      float(iy)/float(nyd)*ymm,' m'
              write (ips,1002) ixresno(ifrdssp-1+iy*iyd)
            end do
          end if
          rx=xm0+icx*xmm/xmax
          write (ips,*) 1,' setlinewidth'
          write (ips,*) 'np'
          itprev=0
          ym0=ym0-(ifrdssp-1)*ymm/ymax
          do iss=1,nss
            if (ilss(iss) .gt. ifrdssp .and. ifss(iss) .lt. ilrdssp) then
              if (itypss(iss) .ne. itprev) then
                if (itprev .ne. 0) write (ips,1003)
                call rgbcolor(ips,itypss(iss))
                itprev=itypss(iss)
              end if
              write (ips,1001) rx,ym0+max0(ifrdssp,ifss(iss))*ymm/ymax,'m'
              write (ips,1001) rx,ym0+min0(ilrdssp,ilss(iss))*ymm/ymax,'l'
            end if
          end do
          write (ips,*) 'sk'
          return
    1001  format(2f8.1,1x,a)
    1002  format('(',i8,') show',/,'sk')
    1003  format('sk',/,'np')
    1005  format(2f8.1,1x,a)
    1006  format('%%Page: 1 1')
    1007  format('(',f8.2,') show',/,'sk')
    3000  format('/m { moveto } def',/,'/l { lineto } def',/,
         -  '/np { newpath } def',/, '/sk { stroke } def',/,
         -  '/f { fill } def',/,'/lw { setlinewidth } def',/,
         -  '/Helvetica findfont',/,'12 scalefont',/,'setfont')
          end
          subroutine res_res_bond(nres,nbfound,indexbond,nhbdist,iresno,
         -  ixres,ifres,isegno,irrix,it2,it3,title,ltitle,bondname,
         -  lbondname,line,index,irescol1,irescol2,iresshift,iout,iplot,
         -  ipspage,ncolcode,maxcolcode,mxbonds,maxrsd,maxat)
          dimension nhbdist(mxbonds),iresno(maxat),ixres(maxat),
         -  indexbond(mxbonds),ifres(maxat),isegno(maxat),index(maxat),
         -  irrix(maxat),it2(maxat),it3(maxat)
          character*(*) title,bondname
          character* 132 line(maxat)
          character*200 trajnam,trajnam2
          common /trajname/ trajnam,trajnam2,ltrajnam,ltrajnam2,ifirsttraj,
         -  ifirsttraj2,ilasttraj,ilasttraj2,incrementtraj,incrementtraj2
          parameter (MAXFRAMES=50000,MAXCOPY=600,MAXITEMS=2*MAXCOPY-2)
          common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
         -  increment,increment2,ires(MAXITEMS,MAXFRAMES),
         -  scres(2,MAXFRAMES),x0(MAXCOPY),y0(MAXCOPY),nxselres,
         -  ixselres(MAXCOPY)
          parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
          parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
         -  (6*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
          common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),ing(MAX2D,MAX2D),
         -  ihbtores(MAXBONDS),nusepair(MAXBONDS),nhb_atot(MAXBONDS),
         -  nhb_rtot(MAXBONDS),ibond(MAXBONDS),a1(MAXBONDS),fill(IFILL2)
          common /bondpairs/ ihbpair(2,MAXBONDS),ihb_pair_res(3,MAXBONDS)
          dimension ixshuffle(MAX2D)
          real*8 dc(1,1)
          character*1 ans
          character*13 yclab(40)
          character*80 question
          call indexit(ixshuffle,1,MAX2D,0)
          call zeroiti(irrix,0,nres)
          call zeroiti(it2,0,nres)
          call zeroiti(it3,0,nres)
          do i=1,nbfound
            ihb=indexbond(i)
            irrix(ixres(ihbpair(1,ihb)))=1
            irrix(ixres(ihbpair(2,ihb)))=1
          end do
          nreshb=0
          do ir=1,nres
            if (irrix(ir) .gt. 0) then
              nreshb=nreshb+1
              it2(ir)=nreshb
              it3(nreshb)=ir
            end if
          end do
          write (iout,1021)
          write (6,1018) bondname(1:lbondname),nreshb
          write (question,2000) bondname(1:lbondname)
          lq=45+lbondname
          call askyn(question,lq,1,+1,ireduceplot,73,0)
          call quiz(ans,iresres,'c',' ',0,'treatment of contacts',21,
         -  0,5,6,70)
          write (iout,1018) bondname(1:lbondname),nreshb
          write (iout,1000) bondname(1:lbondname),nbfound,nframe
          if (ireduceplot .eq. 0) then
            call indexit(it2,1,nres,0)
            call indexit(it3,1,nres,0)
            nreshb=nres
          end if
          if (ireduceplot .gt. 0 .or. iresshift .gt. 0) then
            write (iout,1001) bondname(1:lbondname),(ir,
         -    iresno(ifres(it3(ir))),isegno(ifres(it3(ir))),
         -    ixres(ifres(it3(ir))),ir=1,nreshb)
            if (iresshift .gt. 0) write (iout,1019)
            write (iout,1014)(it3(ir),ir=1,nreshb)
          end if
          nhbresmax=0
          do ir=1,nreshb
            do jr=1,nreshb
              ing(ir,jr)=0
              rmsd2d(ir,jr)=0.0
            end do
          end do
          do i=1,nbfound
            ihb=indexbond(i)
            ir1=it2(ixres(ihbpair(1,ihb)))
            ir2=it2(ixres(ihbpair(2,ihb)))
            ing(ir1,ir2)=ing(ir1,ir2)+1
            if (nhbresmax .lt. ing(ir1,ir2)) nhbresmax=ing(ir1,ir2)
            rmsd2d(ir1,ir2)=rmsd2d(ir1,ir2)+nhbdist(ihb)
            if (ir1 .ne. ir2) then
              ing(ir2,ir1)=ing(ir1,ir2)
              rmsd2d(ir2,ir1)=rmsd2d(ir1,ir2)
            end if
          end do
          write (6,1017) bondname(1:lbondname),nhbresmax
          write (iout,1017) bondname(1:lbondname),nhbresmax
          write (iout,1010) bondname(1:lbondname)
          do jr=nreshb,1,-1
            write (iout,1003) jr,it3(jr),(ing(ir,jr),ir=1,nreshb)
          end do
          write (iout,1013) bondname(1:lbondname)
          do jr=nreshb,1,-1
            do ir=1,nreshb
              rmsd2d(ir,jr)=rmsd2d(ir,jr)/float(nframe)
              a1(ir)=rmsd2d(ir,jr)
            end do
            call writesmall(iout,a1,nreshb,jr,it3(jr))
          end do
          write (iout,1012) bondname(1:lbondname)
          write (iout,1014)(it3(ir),ir=1,nreshb)
          do jr=nreshb,1,-1
            call zeroit(a1,nreshb)
            do ir=1,nreshb
              if (ing(ir,jr) .gt. 0) a1(ir)=rmsd2d(ir,jr)/float(ing(ir,jr))
            end do
            call writesmall(iout,a1,nreshb,jr,it3(jr))
            if (ans .eq. 'a') call trnsfr(rmsd2d(1,jr),a1,nreshb)
          end do
          call sortbondlist(ixres,nbfound,indexbond,maxrsd,mxbonds)
          irescodeprev=0
          do ifr=1,nframe
            call readbitc(ires(1,ifr),ibond,nbfound,30,MAXITEMS)
            do ib=1,nbfound
              ihb=indexbond(ib)
              if (ibond(ihb) .gt. 0) then
                ir1=it2(ixres(ihbpair(1,ihb)))
                ir2=it2(ixres(ihbpair(2,ihb)))
                irescode=ir1*MAXRSD+ir2
                if (irescode .ne. irescodeprev) then
                  irescodeprev=irescode
                  ing(ir1,ir2)=ing(ir1,ir2)+1
                  ing(ir2,ir1)=ing(ir1,ir2)
                end if
              end if
            end do
          end do
          write (iout,1016) bondname(1:lbondname)
          write (iout,1014)(it3(ir),ir=1,nreshb)
          do ir=1,nreshb
            do jr=1,nreshb
              ing(ir,jr)=0
            end do
          end do
          ip=1
          do while (ihb_pair_res(3,ip) .gt. 0)
            ir1=it2(ihb_pair_res(1,ip))
            ir2=it2(ihb_pair_res(2,ip))
            if (ir1*ir2 .gt. 0) ing(ir1,ir2)=ihb_pair_res(3,ip)
            ip=ip+1
          end do
          n_res_res=ip-1
          do jr=nreshb,1,-1
            call zeroit (a1,nreshb)
            do ir=1,nreshb
              a1(ir)=float(ing(ir,jr))/float(nframe)
            end do
            call writesmall(iout,a1,nreshb,jr,it3(jr))
            if (ans .eq. 'i') call trnsfr(rmsd2d(1,jr),a1,nreshb)
          end do
          rhbmax=0.0
          do ir=1,nreshb
            do jr=1,nreshb
              if (rhbmax .lt. rmsd2d(ir,jr)) rhbmax=rmsd2d(ir,jr)
            end do
          end do
          if (nreshb .gt. 0) then
            inc=max0(1,500/nreshb)
            iydel=150
            call indexit(irrix,1,n_res_res,0)
            write (question,2002) bondname(1:lbondname)
            lq=38+lbondname
            call getreal(question,lq,rhbmax,rhbscalemax,0,74)
            call getint('Last residue to plot on the Y axis',34,
         -    nreshb,1,nreshb,iylst,94)
            call getint('First residue to plot on the Y axis',35,
         -    1,1,nreshb,iyfst,94)
            iyinc=iyfst-1
            nreshby=iylst-iyinc
            if (nreshby .le. 40) then
              nyclab=nreshby
              lyclab=1
              do iy=iyfst,iylst
                ia=ifres(it3(iy))
                write (yclab(iy-iyinc),1008)
         -        line(index(ia))(irescol1:irescol2),iresno(ia)
                if (irescol2-irescol1+7 .gt. lyclab)
         -        lyclab=irescol2-irescol1+7
              end do
            else
              nyclab=1
              lyclab=0
            end if
            scalefac=1.0
            iytop=0
            call plotmat(iplot,ing,rmsd2d,dc,nreshb,nreshby,0,0,0,iyinc,
         -    1,0,40,iydel,00,iytop,0.0,rhbscalemax,ncolcode,maxcolcode,
         -    ixdelsh,iydelsh,inc,scalefac,ixshuffle,ixshuffle,irrix,
         -    title,ltitle,'Residue-residue bond strength',29,1,' ',1,a1,
         -    yclab,nyclab,lyclab,1,MAX2D,1,MAX2D,MAX2D,ipspage,0)
            write (iplot,*) '% Drawing separator lines'
            call rgbcolor(iplot,9)
            write (iplot,*) '2 lw'
            if (nreshby .gt. 1) scalefac=scalefac*0.95
            do i=1,nreshb-1
              if (isegno(ifres(it3(i+1))) .ne. isegno(ifres(it3(i)))) then
                write (iplot,*) 'np'
                ixdell=ixdelsh
                if (nreshb .lt. 550) ixdell=ixdelsh+40
                write (iplot,1005) ixdell+i*inc,iydelsh
                write (iplot,1006) ixdell+i*inc,iydelsh+nreshb*inc
                write (iplot,1005) ixdell,iydelsh+(i-iyfst+1)*inc
                write (iplot,1006) ixdell+nreshb*inc,iydelsh+(i-iyfst+1)*inc
                write (iplot,*) 'sk'
              end if
            end do
            if (nreshb .ge. 5) iydel=iydel-50
            if (nreshb .lt. 5) iydel=iydel-20
            ixcent=max0(0,(nreshb*inc-50*ncolcode)/2)
            call colcodeminmax(iplot,25+ixcent,-iydel-5,0,ncolcode,
         -    maxcolcode,0.0,rhbscalemax)
            iydel=iydel-35
            write (iplot,1005) 75,iydel
            write (iplot,1004) bondname(1:lbondname),0.0,rhbscalemax
            iydel=iydel-15
            write (iplot,1005) 75,iydel
            write (iplot,1007) bondname(1:lbondname)
            iydel=iydel-15
            write (iplot,1005) 75,iydel
            if (ans .eq. 'i') then
              write (iplot,1009) 'Multiple contacts are ignored'
            else if (ans .eq. 'a') then
              write (iplot,1009) 'Multiple contacts are averaged'
            else
              write (iplot,1009) 'Multiple contacts are accumulated'
            end if
          else
            Print *,'No ',bondname(1:lbondname),'-bonding residue was found'
          end if
          write (iplot,*) 'showpage'
          print *,'END RES_RES_BOND'
          return
    1000  format(' Number of different ',a,' bonds used=',i6,/,
         -  ' Number of frames analyzed=',i6,/)
    1001  format(' List of the original indices of the ',a,
         -  '-bonding residues',/,(' Residue index(on plot)=',i4,
         -  ' residue #=',i5,' segment #=',i4,' residue index=',i5))
    1003  format(' iy=',i4,' iy(orig)=',i5,10i5,/(23x,10i5))
    1004  format('( Range of the ',a,'-bond fraction scale:',f8.3,'  -',
         -  f8.3,') show')
    1005  format(2i5,' m')
    1006  format(2i5,' l')
    1007  format('( Residue-Residue ',a,' bond fractions ) show')
    1008  format(1x,a,i5)
    1009  format('( ',a,' ) show')
    1010  format(/,' Number of different ',a,' bonds between residue pairs')
    1012  format(/,' Fraction of time the ',a,' bonds are formed between ',
         -  'residue pairs',/,
         -  ' averaged over all bonds between these residues')
    1013  format(/,' Average number of ',a,' bonds between residue pairs')
    1014  format(' iy(orig):',13x,10i5,/,(23x,10i5))
    1016  format(/,' Fraction of time any ',a,' bond was formed between ',
         -  'residue pairs')
    1017  format(/,' Maximum number of ',a,' bonds between two residues=',
         -  i4)
    1018  format(' Number of residues involved in ',a,' bonding=',i5)
    1019  format(' NOTE: residue numbers below refer to the residue ',
         -  'INDICES printed above')
    1021  format(/,' === Residue-residue bond matrix data:')
    2000  format('Do you want only ',a,'-bonded residues in the plot')
    2002  format('Limit of the residue-residue ',a,' bond map scale')
          end
          subroutine writesmall(iout,a,n,iy,iyorig)
          dimension a(n)
          character*80 line
          nw=0
          do while (nw .lt. n)
            call blankout(line,1,80)
            if (nw .eq. 0) write (line(1:24),1001) iy,iyorig
            write (line(25:74),1002) (a(i),i=nw+1,min0(n,nw+10))
            do i=1,min0(10,n-nw)
              if (a(nw+i) .lt. 0.00001) line(24+(i-1)*5+1:24+i*5)=' 0.0 '
            end do
            write (iout,1000) line(1:74)
            nw=nw+10
          end do
          return
    1000  format(a)
    1001  format(' iy=',i4,' iy(orig)=',i5,':')
    1002  format(10f5.2)
          end
          subroutine mrgsortlist(list,it1,it2,it3,it4,it5,n)
          dimension list(n),it1(n),it2(n),it3(n),it4(n),it5(n)
          call indexit(it1,1,n,0)
          call mrgsrti(6,it1,list,n,it2,it3,it4,it5,n)
          return
          end
          subroutine sortlist(iout,list,listlen,itemp,iorig,lab,itestonly,
         -  maxval)
          dimension list(listlen),itemp(maxval),iorig(listlen)
          character*3 lab
          call zeroiti(itemp,0,maxval)
          nerr=0
          do i=1,listlen
            if (itemp(list(i)) .gt. 0) then
              write (6,1000) lab,list(i),listlen,maxval
              if (iout .gt. 0) write (iout,1000) lab,list(i),listlen,maxval
              nerr=nerr+1
            end if
            itemp(list(i))=i
          end do
          if (nerr .gt. 0) then
            write (6,1001) (list(i),i=1,listlen)
            if (iout .gt. 0) write (iout,1001) (list(i),i=1,listlen)
          end if
          if (itestonly .eq. 0) then
            ll=0
            do i=1,maxval
              if (itemp(i) .gt. 0) then
                ll=ll+1
                list(ll)=i
                iorig(ll)=itemp(i)
              end if
            end do
          end if
          return
    1000  format(' PROGRAM ERROR in ',a,' sortlist: duplicate entry ',i6,
         -  /,' List length=',i6,' Maximum value=',i6)
    1001  format(' List entries:',/,(10i6))
          end
          subroutine sortbondlist(ixres,listlen,indexbond,maxrsd,mxbonds)
          dimension ixres(maxrsd),indexbond(mxbonds)
          parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
          parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
         -  (6*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
          parameter (IFILL6=MAX2D*MAX2D-6*MAXBONDS)
          common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),fill(IFILL6),
         -  i1(MAXBONDS),i2(MAXBONDS),i3(MAXBONDS),i4(MAXBONDS),
         -  newpair(2,MAXBONDS),ihbtores(MAXBONDS),nusepair(MAXBONDS),
         -  nhb_atot(MAXBONDS),nhb_rtot(MAXBONDS),a1(MAXBONDS),
         -  a2(MAXBONDS),fill_2(IFILL2)
          common /bondpairs/ ihbpair(2,MAXBONDS),ihb_pair_res(3,MAXBONDS)
          do i=1,listlen
            ii=indexbond(i)
            a1(i)=ixres(ihbpair(1,ii))*MAXBONDS+ixres(ihbpair(2,ii))
          end do
          call mrgsrt(6,indexbond,a1,listlen,i2,i3,i4,a2,listlen)
          return
          end
          subroutine bondsum(nhbtot,nhbfilt,indexbond,ixres,atnames,
         -  resnames,isegno,iresno,ifres,ihb,iout,mxbonds,maxrsd,
         -  maxrec)
          dimension indexbond(mxbonds),ixres(maxrec),ihb(mxbonds),
         -  isegno(maxrec),iresno(maxrec),ifres(maxrec)
          character*8 atnames(maxrec),resnames(maxrsd)
          parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
          parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
         -  (7*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
          parameter (MAXFRAMES=50000,MAXCOPY=600,MAXITEMS=2*MAXCOPY-2)
          common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
         -  increment,increment2,ires(MAXITEMS,MAXFRAMES),
         -  scres(2,MAXFRAMES),x0(MAXCOPY),y0(MAXCOPY),nxselres,
         -  ixselres(MAXCOPY)
          common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),ing(MAX2D,MAX2D),
         -  ihbtores(MAXBONDS),nusepair(MAXBONDS),nhb_atot(MAXBONDS),
         -  nhb_rtot(MAXBONDS),ibond(MAXBONDS),ihb_a(MAXBONDS),
         -  ihb_r(MAXBONDS),fill(IFILL2)
          common /bondpairs/ ihbpair(2,MAXBONDS),ihb_pair_res(3,MAXBONDS)
          call askyn(
         -  'Do you want to limit the bond sums to the filtered bonds',56,
         -  1,-1,iusefilt,0,0)
          nhbuse=nhbtot
          if (iusefilt .eq. 1) nhbuse=nhbfilt
          maxat=0
          maxres=0
          do ibb=1,nhbuse
            ib=ibb
            if (iusefilt .eq. 1) ib=indexbond(ibb)
            ib1=ihbpair(1,ib)
            ib2=ihbpair(2,ib)
            if (maxat .lt. ib1) maxat=ib1
            if (maxat .lt. ib2) maxat=ib2
            ir1=ixres(ib1)
            ir2=ixres(ib2)
            if (maxres .lt. ir1) maxres=ir1
            if (maxres .lt. ir2) maxres=ir2
          end do
          if (maxat .gt. MAXBONDS) then
            write (6,2000) maxat,MAXBONDS
            return
          end if
          call zeroiti(nhb_atot,0,maxat)
          call zeroiti(nhb_rtot,0,maxres)
          lnam=0
          lres=0
          do ifr=1,nframetot
            call readbitc(ires(1,ifr),ihb,nhbtot,30,MAXITEMS)
            call zeroiti(ihb_a,0,maxat)
            call zeroiti(ihb_r,0,maxres)
            do ibb=1,nhbuse
              ib=ibb
              if (iusefilt .eq. 1) ib=indexbond(ibb)
              if (ihb(ib) .eq. 1) then
                ib1=ihbpair(1,ib)
                ib2=ihbpair(2,ib)
                ihb_a(ib1)=1
                ihb_a(ib2)=1
                call lastchar(atnames(ib1),lc,8)
                if (lnam .lt. lc) lnam=lc
                call lastchar(atnames(ib2),lc,8)
                if (lnam .lt. lc) lnam=lc
                ir1=ixres(ib1)
                ir2=ixres(ib2)
                ihb_r(ir1)=1
                ihb_r(ir2)=1
                call lastchar(resnames(ir1),lc,8)
                if (lres .lt. lc) lres=lc
                call lastchar(resnames(ir2),lc,8)
                if (lres .lt. lc) lres=lc
              end if
            end do
            do ia=1,maxat
              nhb_atot(ia)=nhb_atot(ia)+ihb_a(ia)
            end do
            do ir=1,maxres
              nhb_rtot(ir)=nhb_rtot(ir)+ihb_r(ir)
            end do
          end do
          write (iout,2003) 'atom'
          do ia=1,maxat
            if (nhb_atot(ia) .gt. 0) write (iout,2001) ia,
         -    atnames(ia)(1:lnam),resnames(ixres(ia))(1:lres),
         -    iresno(ia),isegno(ia),nhb_atot(ia),
         -    100.0*float(nhb_atot(ia))/float(nframetot)
          end do
          write (iout,2003) 'residue'
          do ir=1,maxres
            if (nhb_rtot(ir) .gt. 0) write (iout,2002) ir,
         -    resnames(ir)(1:lres),isegno(ifres(ir)),iresno(ifres(ir)),
         -    nhb_rtot(ir),100.0*float(nhb_rtot(ir))/float(nframetot)
          end do
          return
    2000  format(' ERROR: Number of atoms (',i7,') exceeds the value of ',
         -  'the parameter MAXBONDS ',/,8x,'(',i7,') - atom and residue ',
         -  'bond sum calculation will be skipped')
    2001  format(' Atom',i6,1x,a,1x,a,' resno=',i5,' C/S:',i2,
         -  ' # of frames bonded=',i5,' % bonded=',f6.2)
    2002  format(' Residue',i6,1x,a,' S/C:',i2,' resno=',i5,
         -  ' # of frames bonded=',i5,' % bonded=',
         -  f6.2)
    2003  format(/,' === List of the number and percent of frames where ',
         -  'each ',a,' formed a bond')
          end
          subroutine plotbond(ips,nhbtot,nhbplot,nbresplot,nclust,ianc_anc,
         -  ifhbclust,ilhbclust,index,ihb,ihbon,ihbstart,rdclust,iclust,
         -  xtrajmax,nydd,itit,ntit,xlab,nxlab,ylab,nylab,nohead,percmin,
         -  percmax,numres,minresdist,maxresdist,distmax,bondname,lbondname,
         -  nobullet,nhneigmin,nbondmax,naabondmax,icorrtyp,icorrtrans,
         -  nframeav,correxp,hblimfac,angmin,lablim,ibondtype,ibondlab,
         -  itemp1,ixresno,irrix,ixres,nrrbond,atnames,
         -  resnames,npspages,ipspage,mxbonds,maxrsd,maxrec)
          dimension ianc_anc(mxbonds),ifhbclust(mxbonds),ilhbclust(mxbonds),
         -  index(mxbonds),ihb(mxbonds),ihbon(mxbonds),ihbstart(mxbonds),
         -  itemp1(mxbonds),ixresno(maxrsd),irrix(maxrsd),
         -  ixres(maxrec),nrrbond(mxbonds)
          character*(*) itit,xlab,ylab,bondname
          character*8 atnames(maxrec),resnames(maxrsd)
          parameter (MAXFRAMES=50000,MAXCOPY=600,MAXITEMS=2*MAXCOPY-2)
          common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
         -  increment,increment2,ires(MAXITEMS,MAXFRAMES),
         -  scres(2,MAXFRAMES),x0(MAXCOPY),y0(MAXCOPY),nxselres,
         -  ixselres(MAXCOPY)
          character*41 clstyp
          common /cluster_typ/ nclstyp,inumclst(9),ireadcutoff(9),
         -  lclstyp(9),clstyp(9)
          parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
          parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
         -  (6*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
          common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),ing(MAX2D,MAX2D),
         -  ihbtores(MAXBONDS),nusepair(MAXBONDS),nhb_atot(MAXBONDS),
         -  nhb_rtot(MAXBONDS),ibond(MAXBONDS),a1(MAXBONDS),fill(IFILL2)
          dimension icolrb(2),lcorrtyp(3)
          character*1 corrtrans(3)
          character*36 corrtyp(3)
          character*37 bondlab(1)
          data icolrb /1,6/,lcorrtyp /36,28,28/
          data corrtrans /'-','/',' '/,corrtyp /
         -  'Correlate both the on and off states',
         -  'Correlate only the on states        ',
         -  'Correlate averaged on states        '/
          nhbtot=min0(nhbtot,30*MAXITEMS)
          if (iclust .gt. 0 .and. nclust .eq. 0) return
          ntotplot=nhbplot
          if (ibondlab .eq. 2) ntotplot=nbresplot
          if (ntotplot .le. 20) then
            xm=650
            ym=amax1(200.0,350.0*float(ntotplot)/20.0)
            xm0=75
            xm00=-40
            xmm=0.9*xm
          else
            xm=675
            ym=495
            xmm=0.9*xm
            xm0=0.075*xm
            xm00=xm0-0.15*xmm
          end if
          ymm09=0.9*ym
          ymm=amin1(ymm09,float(nhbplot*10))
          if (ibondlab .eq. 1) then
            xm0=xm0+0.05*xmm
            xm00=xm0-0.20*xmm
          end if
          yshiftinc=12
          ym0=2.0*yshiftinc+5.0
          if (xlab(1:1) .eq. ' ') then
            nfrtot=nframetot
            call roundlimint(nfrtot,ixd,nxd)
          else
            frtot=xtrajmax
            call roundlim(frtot,xdiv,nxd)
            nfrtot=float(nframetot)*frtot/xtrajmax+1
            ixd=nfrtot/nxd+1
          end if
          xfac=xmm/(float(nxd)*xdiv*float(nframetot)/xtrajmax)
          nyd=nydd
          if (ibondlab .eq. 2) then
            if (iclust .eq. 0) then
              call trnsfi(itemp1,index,nhbtot)
              call indexit(index,1,nhbtot,0)
            end if
          end if
          call roundlimint(ntotplot,iyd,nyd)
          ymax=nyd*iyd
          yfac=ymm/float(iyd*nyd)
          lw=1
          if (ntotplot .le. 100) lw=2
          if (ntotplot .le. 50) lw=3
          call zeroiti(ihbon,0,nhbtot)
          call zeroiti(ihbstart,0,nhbtot)
          if (iclust .eq. 0) call zeroiti(nrrbond,0,ntotplot)
          nbondmax=0
          naabondmax=0
          nhbsumsum=0
          do ifr=1,nframetot
            call readbitc(ires(1,ifr),ihb,nhbtot,30,MAXITEMS)
            if (ibondlab .lt. 2) then
              nhbsum=0
              nhbaasum=0
              do ibx=1,nhbtot
                if (ihb(ibx) .eq. 1) then
                  nhbsum=nhbsum+1
                  if (ianc_anc(ibx) .eq. 1) nhbaasum=nhbaasum+1
                end if
              end do
              scres(1,ifr)=nhbsum
              scres(2,ifr)=nhbaasum
              if (nbondmax .lt. nhbsum) nbondmax=nhbsum
              if (naabondmax .lt. nhbaasum) naabondmax=nhbaasum
              nhbsumsum=nhbsumsum+nhbsum
            else
              if (iclust .eq. 0) then
                do ib=1,ntotplot
                  nrrbond(ib)=nrrbond(ib)+ihb(ib)
                end do
              end if
            end if
            if (ifr .eq. 1) then
              call trnsfi(ihbon,ihb,ntotplot)
              if (nohead .eq. 0) call psheader(ips,itit,ntit,
         -      -30,-130,830,830,npspages,ipspage)
              write (ips,3000) 10
              ipspage=ipspage+1
              write (ips,1019) ipspage
              write (ips,*) '-90 rotate'
              write (ips,1001) -xm*1.1,0.03*ym,' translate'
              write (ips,*) 'np'
              write (ips,1001) xm0,ym0,' m'
              write (ips,1001) xm0,ym0+ymm+4,' l'
              write (ips,1001) xm0+xmm,ym0+ymm+4,' l'
              write (ips,1001) xm0+xmm,ym0,'   l'
              write (ips,1001) xm0,ym0,' l'
              write (ips,*) 'sk'
              write (ips,*) 'np'
              yshift=yshiftinc
              if (distmax .gt. 0.0 .or. nhneigmin .gt. 0) then
                write (ips,1001) xm0,ym0+ymm+yshift,' m'
                write (ips,1005) bondname(1:lbondname),distmax
                yshift=yshift+yshiftinc
              end if
              if (ibondtype .eq. 1 .or. ibondtype .eq. 2) then
                write (ips,1001) xm0,ym0+ymm+yshift,' m'
                if (ibondtype .eq. 2) write (ips,1004) nhneigmin
                if (ibondtype .eq. 1) write (ips,1015) hblimfac,angmin
                yshift=yshift+yshiftinc
              end if
              if (percmin .gt. 0.0 .or. percmax .lt. 100.0) then
                write (ips,1001) xm0,ym0+ymm+yshift,' m'
                write (ips,1007) percmin,percmax
                yshift=yshift+yshiftinc
              end if
              if (minresdist .gt. 0 .or. maxresdist .lt. numres-1) then
                write (ips,1001) xm0,ym0+ymm+yshift,' m'
                write (ips,1008) minresdist,maxresdist
                yshift=yshift+yshiftinc
              end if
              if (ibondlab .eq. 2) then
                write (ips,1001) xm0,ym0+ymm+yshift,' m'
                write (ips,1018) bondname(1:lbondname)
                yshift=yshift+yshiftinc
              end if
              write (ips,1001) xm0,ym0+ymm+yshift,' m'
              if (iclust .eq. 0) then
                write (ips,1009) bondname(1:lbondname)
              else
                if (rdclust .gt. 0.0) then
                  write (ips,1010) clstyp(iclust)(1:lclstyp(iclust)),rdclust
                else
                  write (ips,1012) clstyp(iclust)(1:lclstyp(iclust)),nclust
                end if
                yshift=yshift+yshiftinc
                write (ips,1001) xm0,ym0+ymm+yshift,' m'
                write (ips,1013) corrtyp(icorrtyp)(1:lcorrtyp(icorrtyp))
                if (icorrtyp .eq. 3) write (ips,1014) nframeav
                write (ips,1023) corrtrans(icorrtrans),correxp
              end if
              yshift=yshift+yshiftinc
              write (ips,1001) xm0,ym0+ymm+yshift,' m'
              call write_traj_lim(ips,' ',1,1,incr_tr,1)
              yshift=yshift+yshiftinc
              write (ips,1001) xm0,ym0+ymm+yshift,' m'
              call psshow(ips,'Title: ',7)
              call psshow(ips,itit,ntit)
              write (ips,*) 'sk'
              write (ips,3000) 12
              call rgbcolor(ips,9)
              write (ips,*) 'np'
              write (ips,1001) xm0+0.45*xmm,ym0-2.0*yshiftinc,' m'
              call psshow(ips,xlab,nxlab)
              write (ips,*) 'sk'
              if (ibondlab .eq. 0 .or. ntotplot .gt. lablim) then
                write (ips,1001) xm0-0.06*xmm,ym0+0.4*ymm,' translate'
                write (ips,*) '90 rotate'
                write (ips,*) 'np'
                write (ips,1001) 0.0,0.0,' m'
                call psshow(ips,ylab,nylab)
                write (ips,*) 'sk'
                write (ips,*) '-90 rotate'
                write (ips,1001) -(xm0-0.06*xmm),-(ym0+0.4*ymm),' translate'
              else if (ntotplot .gt. lablim) then
               if (ibondlab .eq. 2) write (6,1022) lablim,'residue pairs'
               if (ibondlab .eq. 1) write (6,1022) lablim,
         -       bondname(1:lbondname)
              end if
              write (ips,*) 3,' setlinewidth'
              write (ips,*) 'np'
              write (ips,*) 1,' setlinewidth'
              call rgbcolor(ips,9)
              ifloatx=0
              do ix=1,nxd
                write (ips,*) 'np'
                write (ips,1001) xm0+xmm*float(ix)/float(nxd),ym0,' m'
                write (ips,1001) 0.0,+0.01*ymm,' rlineto'
                write (ips,*) 'sk'
                write (ips,*) 'np'
                write (ips,1001) xm0-0.02*xmm+
         -        xmm*float(4*ix-1)/float(4*nxd),ym0-yshiftinc,' m'
                if (xlab(1:1) .eq. ' ') then
                  write (ips,1002) (ix*ixd)
                else
                  if (xdiv .ge. 1.0) then
                    ixxdiv=ix*xdiv+0.01
                    write (ips,1002) ixxdiv
                  else
                    write (ips,1003) (ix*xdiv)
                  end if
                end if
              end do
              if (ibondlab .eq. 0 .or. ntotplot .gt. lablim) then
                do iy=1,nyd
                  write (ips,*) 'np'
                  write (ips,1001) xm0,ym0+float(iy)/float(nyd)*ymm,' m'
                  write (ips,1001) +0.01*xmm,0.0,' rlineto'
                  write (ips,*) 'sk'
                  write (ips,*) 'np'
                  write (ips,1001) xm0-0.07*xmm,ym0-0.01*ymm+
         -          float(iy)/float(nyd)*ymm,' m'
                  write (ips,1002) iy*iyd
                end do
              else
                write (ips,1021) 8
                do iy=1,ntotplot
                  if (mod(iy,iyd) .eq. 0) then
                    write (ips,*) 'np'
                    write (ips,1001) xm0,ym0+float(iy)/float(nyd*iyd)*ymm,
         -            ' m'
                    write (ips,1001) +0.01*xmm,0.0,' rlineto'
                    write (ips,*) 'sk'
                  end if
                  write (ips,*) 'np'
                  write (ips,1001) xm00,
         -          ym0+float(iy)/float(nyd*iyd)*ymm,' m'
                  call makebondlab(iy,iy,iy-1,ibondlab,bondlab,lbondlab,
         -          irrix,ixresno,ixres,index,resnames,atnames,1,mxbonds,
         -          maxrsd,maxrec)
                  write (ips,1013) bondlab(1)(1:lbondlab)
                end do
                write (ips,1021) 12
              end if
              if (iclust .gt. 0) then
                write (ips,*) 12,' setlinewidth'
                xclust0=xm0+1.02*xmm
                ncp=0
                do ic=1,nclust
                  if (ilhbclust(ic)-ifhbclust(ic) .gt. 0) then
                    ncp=ncp+1
                    xinc=1.00
                    write (ips,*) 'np'
                    write (ips,1001) xinc*xclust0,ym0+yfac*ifhbclust(ic),'m'
                    write (ips,1001) xinc*xclust0,ym0+yfac*ilhbclust(ic),'l'
                    write (ips,*) 'sk'
                  end if
                end do
              end if
              write (ips,*) lw,' setlinewidth'
            end if
            nlwp=0
            do ib=1,ntotplot
              ibx=index(ib)
              if (nobullet .eq. 0) then
                if (ihbstart(ibx) .eq. 0 .and. ihb(ibx) .eq. 1) then
                  ihbstart(ibx)=1
                  write (ips,*) 'np'
                  call rgbcolor(ips,9)
                  write (ips,1016) xm0+xfac*float(ifr),ym0+yfac*float(ib),
         -          float(lw),0.0,360.0
                  write (ips,*) 'fill'
                  write (ips,*) 'sk'
                end if
              end if
              if (ihb(ibx) .eq. 1 .and. ihbon(ibx) .eq. 0) then
                ihbon(ibx)=ifr
              else if ((ihb(ibx) .eq. 0  .or. ifr .eq. nframetot) .and.
         -              ihbon(ibx) .gt. 0) then
                ym=ym0+yfac*float(ib)
                write (ips,*) 'np'
                call rgbcolor(ips,-icolrb(ianc_anc(ibx)+1))
                write (ips,1001) xm0+xfac*float(ihbon(ibx)),ym,' m'
                write (ips,1001) xm0+xfac*float(ifr),ym,' l'
                write (ips,*) 'sk'
                ihbon(ibx)=0
              end if
            end do
          end do
          call rgbcolor(ips,9)
          write (ips,*) 1,' setlinewidth'
          do iy=1,nyd
            write (ips,*) 'np'
            write (ips,1001) xm0+xmm,ym0+float(iy)/float(nyd)*ymm,' m'
            write (ips,1001) -0.01*xmm,0.0,' rlineto'
            write (ips,*) 'sk'
          end do
          write (ips,*) lw,' setlinewidth'
          axshift=0.0
          if (nbondmax .gt. naabondmax) then
            write (ips,*) 'np'
            call rgbcolor(ips,-icolrb(1))
            write (ips,1001) xm0+10.0,ym0-0.08*ymm09,' m'
            write (ips,1001) 20.0,0.0,' rlineto'
            write (ips,1001) xm0+30.0,ym0-0.08*ymm09,' m'
            write (ips,1011) ' : anchor -- non-anchor'
            write (ips,*) 'sk'
            axshift=1.0
          end if
          if (naabondmax .gt. 0) then
            write (ips,*) lw,' setlinewidth'
            write (ips,*) 'np'
            call rgbcolor(ips,-icolrb(2))
            write (ips,1001) xm0+10.0+axshift*0.6*xmm,ym0-0.08*ymm09,' m'
            write (ips,1001) 20.0,0.0,' rlineto'
            write (ips,1001) xm0+30.0+axshift*0.6*xmm,ym0-0.08*ymm09,' m'
            write (ips,1011) ' : anchor -- anchor'
            write (ips,*) 'sk'
          end if
          call rgbcolor(ips,9)
          write (ips,*) 1,' setlinewidth'
          write (ips,*) 'showpage'
          if (ibondlab .eq. 2) call trnsfi(index,itemp1,nhbtot)
          return
    1001  format(2f8.1,1x,a)
    1002  format('(',i8,') show',/,'sk')
    1003  format('(',f8.2,') show',/,'sk')
    1004  format('( Minimum number of hydrogens on hydrophobic carbons=',
         -  i1,') show')
    1005  format('( Length limit of a ',a,' bond=',f5.2,' A) show')
    1007  format('(Minimum and maximum % occurrences to show=',
         -  f4.1,f6.1,') show')
    1008  format('(Minimum and maximum interresidue distances to show=',
         -  i4,' and ',i5,' residues ) show')
    1009  format('(Unclustered plot, original ',a,'-bond order ) show')
    1010  format('(Clustering method: ',a,'; distance measure cutoff=',f5.2,
         -  ' ) show')
    1011  format('(',a,') show')
    1012  format('(Clustering method: ',a,' Number of clusters=',i2,')show')
    1013  format('(',a,' ) show')
    1014  format('(# of frames averaged=',i4,' ) show')
    1015  format('(Hydrogen-bond parameters: hblimfac=',f6.3,
         -  ' angmin=',f8.2,' deg ) show')
    1016  format(5f12.4,' arc')
    1018  format('(Residue aggregated time course of ',a,' bonds) show')
    1019  format('%%Page: 1 ',i4)
    
    1021  format('/Helvetica findfont',/,i2,' scalefont',/,'setfont')
    1022  format(' NOTE: more than',i3,1x,a,' - no room for the names')
    1023  format('(; distance measure=(1',a,'corr)^',f4.2,' ) show')
    3000  format('/m { moveto } def',/,'/l { lineto } def',/,
         -  '/np { newpath } def',/, '/sk { stroke } def',/,
         -  '/f { fill } def',/,'/lw { setlinewidth } def',/,
         -  '/Helvetica findfont',/,i2,' scalefont',/,'setfont')
          end
          subroutine makebondlab(ilab1,ilab2,inc,ibondlab,bondlab,lbondlab,
         -  irrix,ixresno,ixres,index,resnames,atnames,maxbondlab,mxbonds,
         -  maxrsd,maxrec)
          dimension ixresno(maxrsd),irrix(maxrsd),ixres(maxrec),
         -  index(mxbonds)
          character*8 atnames(maxrec),resnames(maxrsd)
          character*37 bondlab(maxbondlab)
          parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
          parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
         -  (6*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
          common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),ing(MAX2D,MAX2D),
         -  ihbtores(MAXBONDS),nusepair(MAXBONDS),nhb_atot(MAXBONDS),
         -  nhb_rtot(MAXBONDS),ibond(MAXBONDS),a1(MAXBONDS),fill(IFILL2)
          common /bondpairs/ ihbpair(2,MAXBONDS),ihb_pair_res(3,MAXBONDS)
          lbondlab=0
          do ilab=ilab1,ilab2
            call blankout(bondlab(ilab-inc),1,37)
            if (ibondlab .eq. 2) then
              irr=irrix(ilab)
              ixr1=ihb_pair_res(1,irr)
              ixr2=ihb_pair_res(2,irr)
              ir1=ixresno(ixr1)
              ir2=ixresno(ixr2)
              call lastchar(resnames(ixr1),lc1,8)
              call lastchar(resnames(ixr2),lc2,8)
              lbondlabi=11+lc1+lc2
              write (bondlab(ilab-inc)(1:lbondlabi),1002)
         -      resnames(ixr1)(1:lc1),ir1,resnames(ixr2)(1:lc2),ir2
            else
              ia1=ihbpair(1,index(ilab))
              ia2=ihbpair(2,index(ilab))
              ixr1=ixres(ia1)
              ixr2=ixres(ia2)
              ir1=ixresno(ixr1)
              ir2=ixresno(ixr2)
              call lastchar(resnames(ixr1),lc1,8)
              call lastchar(resnames(ixr2),lc2,8)
              lbondlabi=21+lc1+lc2
              write (bondlab(ilab-inc)(1:lbondlabi),1001) atnames(ia1)(1:4),
         -      resnames(ixr1)(1:lc1),ir1,atnames(ia2)(1:4),
         -      resnames(ixr2)(1:lc2),ir2
            end if
            if (lbondlab .lt. lbondlabi) lbondlab=lbondlabi
          end do
          return
    1001  format(a,1x,a,i4,' - ',a,1x,a,i4)
    1002  format(a,i4,' - ',a,i4)
          end
          subroutine plot2fun(iplot,nplot,x,y12,sd12,n,xmn,xdv,nxdv,y1mn,
         -  y1dv,ny1dv,y2mn,y2dv,ny2dv,title,ntit,remark,lremark,xlab,lxlab,
         -  y1lab,ly1lab,y2lab,ly2lab,itrajfile,iprt,iout,nplotdim,
         -  nosd,nsdfreq_in,iconn,iyinc,npspages,ipspage,noclose,landscape,
         -  modhgt)
          dimension x(n),y12(nplotdim,n),sd12(nplotdim,n)
          character*(*) title,remark,xlab,y1lab,y2lab
          data ny2 /0/,ly2 /0/,iy2min /0/,y2div /0.0/,
         -  y1fac /0.0/,y2fac /0.0/,icol1 /7/,icol2 /7/
          if (n .lt. 1) return
          write (iplot,8791) '% START plot2fun: ',y1lab(1:ly1lab)
    8791  format(a,a)
          if (iyinc .gt. 0 .and. nplot .gt. 1) then
            print *,'PROGRAM ERROR: iyinc > 0 and nplot > 1 in plot2fun'
            print *,'Called for ',title(1:ntit)
            return
          end if
          nsdfreq=nsdfreq_in
          ix0=150
          iy0=100
          ixwid=450
          if (modhgt .eq. 1 .and. ny1dv .gt. 0) then
            iyhgt=min0(420,20*ny1dv)
          else
            iyhgt=420
          end if
          if (nplot .eq. 2) then
            icol1=6
            icol2=1
          else
            icol1=9
          endif
          call psheader(iplot,title,ntit,0,0,612,792,npspages,ipspage)
          ipspage=ipspage+1
          write (iplot,1019) ipspage
          if (landscape .eq. 1) write (iplot,1001)
          write (iplot,1002) ix0+ixwid/2-50,iy0-40
          call psshow(iplot,xlab,lxlab)
          ixcent=80
          if (ntit .gt. 50) ixcent=0
          write (iplot,1002) ix0+ixcent,iy0+iyhgt+10
          call psshow(iplot,title,ntit)
          if (itrajfile .gt. 0) then
            write (iplot,1002) ix0+ixcent,iy0+iyhgt+25
            call write_traj_lim(iplot,' ',1,itrajfile,incr_tr,1)
          end if
          write (iplot,1011)
          write (iplot,1010) ix0,iy0,ixwid,iyhgt,-ixwid
          if (nxdv .gt. 0) then
            xmin=xmn
            nx=nxdv
            if (xdv .eq. 0.0) then
              xmax=x(n)
              xdiv=(xmax-xmin)/float(nx)
            else
              xdiv=xdv
              xmax=xmin+nx*xdiv
            end if
          else
            xmin=0.0
            xmax=x(n)
            call roundlim(xmax,xdiv,nx)
          end if
          call arminmax2(y12,1,n,nplot,y1min,y1max,y2min,y2max,iyinc,
         -  nplotdim)
          if (iyinc .eq. 1) then
            if (ny2dv .gt. 0) then
              y1min=y2mn
              y1div=y2dv
              ny1=ny2dv
              y1max=y1min+y1div*ny1
            else
              ny1=10
              y1div=(y1max-y1min)/ny1
            end if
          else
            if (ny1dv .gt. 0) then
              y1min=y1mn
              y1div=y1dv
              ny1=ny1dv
              y1max=y1min+y1div*ny1
            else
              ny1=10
              y1div=(y1max-y1min)/ny1
            end if
          end if
          ly1=alog10(amax1(abs(y1min),abs(y1max)))
          iy1min=0
          if (nplot .eq. 2) then
            if (ny2dv .gt. 0) then
              y2min=y2mn
              y2div=y2dv
              ny2=ny2dv
              y2max=y2min+y2div*ny2
            else
              ny2=10
              y2div=(y2max-y2min)/ny2
            end if
            ly2=alog10(amax1(abs(y2min),abs(y2max)))
            iy1min=0
          end if
          do i=iy1min,ny1
            write (iplot,1012)
            write (iplot,1002) ix0,iy0+i*iyhgt/ny1
            write (iplot,1003) 5,0
            write (iplot,1011)
          end do
          call rgbcolor(iplot,-icol1)
          write (iplot,1012)
          do i=iy1min,ny1
            write (iplot,1002) ix0-50,iy0-5+i*iyhgt/ny1
            if (ly1 .lt. 0) then
              write (iplot,1023) y1min+i*y1div
            else if (ly1 .lt. 2) then
              write (iplot,1022) y1min+i*y1div
            else if (ly1 .lt. 4) then
              write (iplot,1007) y1min+i*y1div
            else if (ly1 .lt. 7) then
              iy1=y1min+i*y1div
              write (iplot,1005) iy1
            else
              write (iplot,1006) y1min+i*y1div
            end if
          end do
          write (iplot,1011)
          call rgbcolor(iplot,9)
          if (nplot .eq. 1) then
            iy2min=iy1min
            ny2=ny1
          end if
          write (iplot,8922) iy2min,ny2,ix0,iy0,iyhgt
    8922  format('% iy2min,ny2,ix0,iy0,iyhgt=',5i6)
          do i=iy2min,ny2
            write (iplot,1012)
            write (iplot,1002) ix0+ixwid,iy0+i*iyhgt/ny2
            write (iplot,1003) -5,0
            write (iplot,1011)
          end do
          if (nplot .eq. 2) then
            call rgbcolor(iplot,-icol2)
            write (iplot,1012)
            do i=iy2min,ny2
              write (iplot,1002) ix0+ixwid+3,iy0-5+i*iyhgt/ny2
              if (ly2 .lt. 0) then
                write (iplot,1023) y2min+i*y2div
              else if (ly2 .lt. 2) then
                write (iplot,1022) y2min+i*y2div
              else if (ly2 .lt. 4) then
                write (iplot,1007) y2min+i*y2div
              else if (ly2 .lt. 7) then
                iy2=y2min+i*y2div
                write (iplot,1005) iy2
              else
                write (iplot,1006) y2min+i*y2div
              end if
            end do
            write (iplot,1011)
            call rgbcolor(iplot,9)
          end if
          xrange=nx*xdiv
          do i=0,nx
            write (iplot,1012)
            write (iplot,1002) ix0+i*ixwid/nx,iy0
            write (iplot,1003) 0,5
            write (iplot,1002) ix0+i*ixwid/nx,iy0+iyhgt
            write (iplot,1003) 0,-5
            write (iplot,1011)
            write (iplot,1002) ix0-30+i*ixwid/nx,iy0-15
            if (xrange .gt. 10.01) then
              ix=xmin+i*xdiv+0.01
              write (iplot,1013) ix
            else
              xi=xmin+i*xdiv
              write (iplot,1008) xi
            end if
          end do
          write (iplot,1011)
          call rgbcolor(iplot,-icol1)
          write (iplot,1012)
          if (iconn .eq. 1) then
            write (iplot,1002) ix0+10,iy0+iyhgt-15
            write (iplot,1003) 40,0
            write (iplot,1016) 0,-3
          else
            write (iplot,1020) ix0+10,iy0+iyhgt-12,' 2 0 360 arc'
            write (iplot,1016) 0,-3
          end if
          call psshow(iplot,':',1)
          if (iyinc .eq. 0) call psshow(iplot,y1lab,ly1lab)
          if (iyinc .eq. 1) call psshow(iplot,y2lab,ly2lab)
          write (iplot,1011)
          if (lremark .gt. 0) then
            write (iplot,1012)
            call rgbcolor(iplot,9)
            write (iplot,1002) ix0+10,iy0+iyhgt-30
            call psshow(iplot,remark,lremark)
            write (iplot,1011)
            call rgbcolor(iplot,-icol1)
          end if
          write (iplot,1012)
          if (y1max .gt. y1min) y1fac=iyhgt/(y1max-y1min)
          if (y1max .eq. y1min) y1fac=0.0
          iprev=0
          if (nsdfreq .eq. 0) nsdfreq=max0(1,n/30)
          mody2=1
          if (nsdfreq .eq. 1) mody2=0
          xmaxgraph=amax1(xmax,nx*xdiv)
          write (iplot,1004) 'first function'
          do i=1,n
            if (x(i) .ge. xmin .and. x(i) .le. xmax .and.
         -      y12(iyinc+1,i) .ge. y1min .and.
         -      y12(iyinc+1,i) .le. y1max) then
              ix=ix0+ixwid*(x(i)-xmin)/(xmaxgraph-xmin)
              iy=iy0+y1fac*(y12(iyinc+1,i)-y1min)
              if (iconn .eq. 1) then
                if (iprev .eq. 0) then
                  write (iplot,1002) ix,iy
                  iprev=1
                else
                  write (iplot,1009) ix,iy
                end if
              else
                write (iplot,1012)
                write (iplot,1020) ix,iy,' 2 0 360 arc'
                write (iplot,1011)
              end if
              if (nosd .eq. 0) then
                if (mod(i,nsdfreq) .eq. 0) then
                  iysd=y1fac*sd12(iyinc+1,i)
                  if (iysd .gt. 0) then
                    write (iplot,1003) 0,iysd
                    write (iplot,1003) 3,0
                    write (iplot,1003) -6,0
                    write (iplot,1003) 3,0
                    write (iplot,1003) 0,-2*iysd
                    write (iplot,1003) 3,0
                    write (iplot,1003) -6,0
                    write (iplot,1003) 3,0
                    write (iplot,1003) 0,iysd
                  end if
                end if
              end if
            else
              iprev=0
            end if
          end do
          write (iplot,1004) 'second function'
          write (iplot,1011)
          if (nplot .eq. 2) then
            call rgbcolor(iplot,-icol2)
            if (iconn .eq. 1) write (iplot,1015)
            write (iplot,1012)
            if (iconn .eq. 1) then
              write (iplot,1002) ix0+ixwid/2,iy0+iyhgt-15
              write (iplot,1003) 40,0
              write (iplot,1016) 0,-3
            else
              write (iplot,1020) ix0+ixwid/2,iy0+iyhgt-12,' 2 0 360 arc'
              write (iplot,1021)
              write (iplot,1011)
              write (iplot,1012)
              write (iplot,1002) ix0+ixwid/2,iy0+iyhgt-13
            end if
            call psshow(iplot,':',1)
            call psshow(iplot,y2lab,ly2lab)
            write (iplot,1011)
            write (iplot,1012)
            if (y2max .gt. y2min) y2fac=iyhgt/(y2max-y2min)
            if (y2max .eq. y2min) y2fac=0.0
            iprev=0
            do i=1,n
              if (x(i) .ge. xmin .and. x(i) .le. xmax .and.
         -        y12(2,i) .ge. y2min .and. y12(2,i) .le. y2max) then
                ix=ix0+ixwid*(x(i)-xmin)/(xmaxgraph-xmin)
                iy=iy0+y2fac*(y12(2,i)-y2min)
                if (iconn .eq. 1) then
                  if (iprev .eq. 0) then
                    write (iplot,1002) ix,iy
                    iprev=1
                  else
                    write (iplot,1009) ix,iy
                  end if
                else
                  write (iplot,1012)
                  write (iplot,1020) ix,iy,' 2 0 360 arc'
                  write (iplot,1021)
                  write (iplot,1011)
                end if
                if (nosd .eq. 0) then
                  if (mod(i,nsdfreq) .eq. mody2) then
                    iysd=y2fac*sd12(2,i)
                    if (iysd .gt. 0) then
                      write (iplot,1003) 0,iysd
                      write (iplot,1003) 3,0
                      write (iplot,1003) -6,0
                      write (iplot,1003) 3,0
                      write (iplot,1003) 0,-2*iysd
                      write (iplot,1003) 3,0
                      write (iplot,1003) -6,0
                      write (iplot,1003) 3,0
                      write (iplot,1003) 0,iysd
                    end if
                  end if
                end if
              else
                iprev=0
              end if
            end do
            write (iplot,1011)
            call rgbcolor(iplot,9)
          end if
          if (landscape .eq. 1) write (iplot,1097)
          write (iplot,1098)
          if (noclose .eq. 0) close (iplot)
          if (iprt .gt. 0) then
            do i=1,n
              write (iout,2001) i,x(i),(y12(iyinc+k,i),k=1,nplot)
            end do
          end if
          return
    1001  format('/Helvetica findfont',/,'11 scalefont',/,'setfont',/,
         -  '612 0 translate',/,'90 rotate')
    1002  format(i5,i6,' m')
    1003  format(i5,i6,' r')
    1004  format('% Plot ',a)
    1005  format('(',i8,') show')
    1006  format('(',e10.4,') show')
    1007  format('(',f8.2,') show')
    1008  format('(',f10.2,') show')
    1009  format(i5,i6,' l')
    1010  format('% Drawing of graph boundaries',/,'newpath',/,
         -  i3,1x,i3,' moveto',/,i4,' 000 rlineto',/,'000 ',i4,' rlineto',/,
         -  i5,' 000 rlineto',/,'closepath',/,'stroke')
    1011  format('sk')
    1012  format('np')
    1013  format('(',i10,') show')
    1015  format('[2] 0 setdash')
    1016  format(i5,i6,' rmoveto')
    
    1019  format('%%Page: 1 ',i4)
    1020  format(2i5,1x,a)
    1021  format('f')
    1022  format('(',f8.4,') show')
    1023  format('(',f8.6,') show')
    1097  format('-90 rotate',/,'-612 0 translate')
    1098  format('showpage')
    2001  format(i11,3e14.6)
          end
          subroutine scatterps(ips,xmin,xmax,xm,ymin,ymax,ym,x,y,ix1,iy1,n,
         -  title,lentit,noclose)
          dimension x(2,n),y(2,n)
          character*(*) title
          write (ips,1005)
          x0=0.1*xm
          y0=0.1*ym
          write (ips,1001) x0,y0
          write (ips,1002) x0,ym
          write (ips,1002) xm,ym
          write (ips,1002) xm,y0
          write (ips,1002) x0,y0
          write (ips,1000)
          write (ips,1005)
          write (ips,1001) x0,0.01*ym
          write (ips,1004) xmin
          write (ips,1001) 0.9*xm,0.01*ym
          write (ips,1004) xmax
          write (ips,1001) 0.0,0.0
          write (ips,1004) ymin
          write (ips,1001) 0.0,ym
          write (ips,1004) ymax
          write (ips,1001) x0,1.01*ym
          call psshow(ips,title,lentit)
          write (ips,1000)
          do i=1,n
            xx=x0+(xm-x0)*(x(ix1,i)-xmin)/(xmax-xmin)
            yy=y0+(ym-y0)*(y(iy1,i)-ymin)/(ymax-ymin)
            write (ips,1005)
            write (ips,1003) xx,yy,3,0,360
            write (ips,1000)
          end do
          write (ips,*) 'showpage'
          if (noclose .eq. 0) close (ips)
          return
    1000  format('stroke')
    1001  format(2f10.1,' moveto')
    1002  format(2f10.1,' lineto')
    1003  format(2f10.1,3i5,' arc')
    1004  format('(',f10.2,') show')
    1005  format('newpath')
          end
          subroutine plotnps(x,y,nxmax,nymax,nf,imf,iml,ifg,r0,cx,
         -  x00,xd,nx,y00,yd,ny,iprt,ntit,tit,ntit2,tit2,xlab,lenx,
         -  fclab,lfclab,imarkx,imarks,marks,iplot,ipspage,npspages,
         -  inperr,iout)
          dimension x(nxmax),y(nymax),imf(nf),iml(nf),ifg(nf),lfclab(nf),
         -  imarks(nxmax)
          character*(*) xlab,fclab(nf),tit,tit2
          character*1 marks(9)
          if (iplot .eq. 0) return
          if (iprt .gt. 0) then
            write (iout,5002)
            do if=1,nf
              write (iout,5005) if,x(ifg(if)),x(ifg(if)+iml(if)-imf(if)),
         -      (y(ig),ig=imf(if),iml(if))
              if (iprt .gt. 1) write (iout,5006) (x(ig),ig=imf(if),iml(if))
            end do
          end if
          ix0=100
          iy0=90
          ixwid=600
          iyhgt=480
          call psheader(iplot,tit,ntit,0,0,612,792,npspages,ipspage)
          write (iplot,1001)
          if (nf .gt. 1) call rgbrainbowcolor(iplot,-1.0)
          write (iplot,1002) ix0+300-ntit*3,iy0+iyhgt+10
          write (iplot,1004) tit(1:ntit)
          write (iplot,1002) ix0+300,iy0-40
          iytit=iy0+iyhgt-15
          if (ntit2 .gt. 0) then
            write (iplot,1002) ix0+10,iytit
            write (iplot,1004) tit2(1:ntit2)
            iytit=iytit-15
          end if
          if (lenx .gt. 0) then
            write (iplot,1002) ix0+300,iy0-30-lenx/5
            write (iplot,1004) xlab(1:lenx)
          end if
          iyhgt=iyhgt-40
          if (xd .eq. 0.0) then
            write (iout,5001)
            inperr=inperr+1
            return
          else
            xmin=x00
            xdiv=xd
            xmax=xmin+nx*xdiv
          end if
          if (yd .eq. 0.0) then
            ymin=y(1)
            ymax=ymin
            do i=1,iml(nf)
              if (y(i) .lt. ymin) ymin=y(i)
              if (y(i) .gt. ymax) ymax=y(i)
            end do
            ny=10
            ydiv=(ymax-y00)/10.0
          else
            ymin=y00
            ydiv=yd
            ymax=ymin+ny*ydiv
          end if
          write (iplot,*) 'np'
          write (iplot,1002) ix0,iy0
          write (iplot,1007) ix0,iy0+iyhgt
          write (iplot,1007) ix0+ixwid,iy0+iyhgt
          write (iplot,1007) ix0+ixwid,iy0
          write (iplot,1007) ix0,iy0
          write (iplot,*) 'sk'
          ly=alog10(abs(ydiv))
          do i=1,ny
            write (iplot,1008)
            write (iplot,1002) ix0,iy0+i*iyhgt/ny
            write (iplot,1003) 5,0
            if (ly .lt. 7) then
              write (iplot,1002) ix0-50,iy0-5+i*iyhgt/ny
              write (iplot,1005) ymin+i*ydiv
            else
              write (iplot,1002) ix0-60,iy0-5+i*iyhgt/ny
              write (iplot,1006) ymin+i*ydiv
            end if
            write (iplot,1002) ix0+ixwid,iy0+i*iyhgt/ny
            write (iplot,1003) -5,0
            write (iplot,1011)
            write (iplot,1002) ix0+ixwid+10,iy0-5+i*iyhgt/ny
            if (ly .lt. 7) write (iplot,1005) ymin+i*ydiv
            if (ly .ge. 7) write (iplot,1006) ymin+i*ydiv
          end do
          if (imarkx .gt. 0) then
            maxx=0
            do if=1,nf
              nxif=ifg(if)+iml(if)-imf(if)
              if (nxif .gt. maxx) maxx=nxif
            end do
            do i=1,maxx
              if (imarks(i) .gt. 0) then
                ix=(x(i)-xmin)*ixwid/(xmax-xmin)
                write (iplot,1002) ix0+ix,iy0+iyhgt
                write (iplot,1004) marks(imarks(i))
              end if
            end do
          end if
          write (iplot,1011)
          do i=1,nx
            write (iplot,1008)
            write (iplot,1002) ix0+i*ixwid/nx,iy0
            write (iplot,1003) 0,5
            write (iplot,1011)
            write (iplot,1008)
            write (iplot,1002) ix0+i*ixwid/nx,iy0+iyhgt
            write (iplot,1003) 0,-5
            write (iplot,1011)
            write (iplot,1002) ix0-30+i*ixwid/nx,iy0-15
            write (iplot,1013) r0+i*cx*xdiv
          end do
          write (iplot,1011)
          if (ymax .gt. ymin) then
            yfac=iyhgt/(ymax-ymin)
          else
            yfac=0.0
          end if
          iylab=iy0+iyhgt-15
          ixinc=max0(1,nx/15)
          maxfclab=0
          do if=1,nf
            if (maxfclab .lt. lfclab(if)) maxfclab=lfclab(if)
          end do
          do if=1,nf
            istarted=0
            if (nf .gt. 1)
         -    call rgbrainbowcolor(iplot,float(if-1)/float(nf-1))
            write (iplot,1016) 1+2*if
            write (iplot,1008)
            write (iplot,1002) ix0+3*ixwid/4,iylab
            write (iplot,1012) if
            write (iplot,1002) ix0+3*ixwid/4+15,iylab+4
            write (iplot,1003) max0(ixwid/12,ixwid/4-6*maxfclab-30),0
            write (iplot,1002) ix0+3*ixwid/4+15+max0(ixwid/12,
         -    ixwid/4-6*maxfclab-30),iylab
            write (iplot,1015) fclab(if)(1:lfclab(if))
            write (iplot,1011)
            iylab=iylab-15
            write (iplot,1008)
            do ig=imf(if),iml(if)
              if (y(ig) .ne. 0.0) then
                ix=ix0+(x(ifg(if)+ig-imf(if))-xmin)*ixwid/(xmax-xmin)
                iy=iy0+yfac*(y(ig)-ymin)
                if (istarted .eq. 0) then
                  write (iplot,1002) ix,iy
                  istarted=1
                else
                  write (iplot,1007) ix,iy
                end if
              end if
            end do
            write (iplot,1011)
          end do
          if (nf .gt. 1) call rgbrainbowcolor(iplot,-1.0)
          write (iplot,1014)
          write (iplot,1099)
          return
    1001  format('/Helvetica findfont',/,'11 scalefont',/,'setfont',/,
         -  '612 0 translate',/,'90 rotate')
    1002  format(i4,i4,' moveto')
    1003  format(i5,i5,' rlineto')
    1004  format('(',a,') show')
    1005  format('(',f10.3,') show')
    1006  format('(',e10.4,') show')
    1007  format(i5,i5,' lineto')
    1008  format('newpath')
    1011  format('stroke')
    1012  format('(',i2,') show')
    1013  format('(',f10.2,') show')
    1014  format('-90 rotate',/,'-612 0 translate')
    1015  format('( : ',a,') show')
    1016  format('[',i3,' 3] 0 setdash')
    1099  format('showpage')
    5001  format(' ***** PROGRAM ERROR: plotnps needs nonzero xdiv')
    5002  format(1x,//,(1x,a))
    5005  format(' Plot ',i5,' xfirst=',e12.5,' xlast=',e12.5,' y=',/,
         -  (10e13.6))
    5006  format(//)
          end
          subroutine rgbrainbowcolor(iout,frac)
          if (frac .lt. 0.0) then
            red=0.0
            green=0.0
            blue=0.0
          else if (frac .le. 0.5) then
            red=2.0*(0.5-frac)
            green=2.0*frac
            blue=0.0
          else
            red=0.0
            green=2.0*(0.5-(frac-0.5))
            blue=2.0*(frac-0.5)
          end if
          write (iout,1000) red,green,blue
          return
    1000  format(3f5.1,' setrgbcolor')
          end
          subroutine plot2d(iplot,xy,n,nfravgt,xmn,xdv,nxdv,ymn,ydv,nydv,
         -  title,ntit,plotdesc,lplotdesc,remark,lremark,xlab,lxlab,
         -  ylab,lylab,timelab,ltimelab,iperiod,iprt,iout,npspages,ipspage,
         -  noclose,maxplot)
          dimension xy(2,maxplot)
          character*(*) title,plotdesc,remark,xlab,ylab,timelab
          write (iplot,*) '% START plot2d: ',ylab(1:lylab)
          if (nfravgt .eq. 0)
         -  call getint(
         -    'Number of snapshots to average in the 2D trace plots',43,
         -    1,1,nframe,nfravgt,142)
          incr=max0(1,nfravgt)
          ix0=110
          iy0=150
          ixwid=400
          iyhgt=400
          call psheader(iplot,title,ntit,0,0,612,792,npspages,ipspage)
          ipspage=ipspage+1
          write (iplot,1020) ipspage
          write (iplot,1001) ix0+ixwid/2-50,iy0-40
          call psshow(iplot,xlab,lxlab)
          write (iplot,1001) 45,iy0+iyhgt/2-50
          write (iplot,1018) 90
          call psshow(iplot,ylab,lylab)
          write (iplot,1018) -90
          ixcent=80
          if (ntit .gt. 50) ixcent=0
          write (iplot,1002) ix0+ixcent,iy0+iyhgt+10
          write (iplot,1017)
          call psshow(iplot,title,ntit)
          write (iplot,1010) ix0,iy0,ixwid,iyhgt,-ixwid
          if (lplotdesc .gt. 0) then
            write (iplot,1002) ix0,iy0+iyhgt+25
            call psshow(iplot,plotdesc,lplotdesc)
          end if
          if (lremark .gt. 0) then
            write (iplot,1002) ix0,iy0+iyhgt-20
            call psshow(iplot,remark,lremark)
          end if
          write (iplot,1011)
          call arminmax2(xy,1,n,2,xmin,xmax,ymin,ymax,0,2)
          if (nxdv .gt. 0) then
            xmin=xmn
            xdiv=xdv
            nx=nxdv
            xmax=xmin+nx*xdiv
          else
            nx=10
            xdiv=(xmax-xmin)/10.0
          end if
          if (nydv .gt. 0) then
            ymin=ymn
            ydiv=ydv
            ny=nydv
            ymax=ymin+ydiv*ny
          else
            ny=10
            ydiv=(ymax-ymin)/ny
          end if
          lx=alog10(amax1(abs(xmin),abs(xmax)))
          if (xmin .ne. 0.0) then
            ixmin=0
          else
            ixmin=1
          end if
          write (iplot,1007) 'Draw ticks, axis values'
          if (ymin .ne. 0.0) then
            iymin=0
          else
            iymin=1
          end if
          ly=alog10(amax1(abs(ymin),abs(ymax)))
          do i=iymin,ny
            write (iplot,1012)
            write (iplot,1002) ix0,iy0+i*iyhgt/ny
            write (iplot,1003) 5,0
            write (iplot,1002) ix0+ixwid,iy0+i*iyhgt/ny
            write (iplot,1003) -5,0
            write (iplot,1011)
            write (iplot,1002) ix0-60,iy0-5+i*iyhgt/ny
            if (ny .lt. 8 .or. mod(i,2) .eq. 0) then
              if (ly .lt. 7) write (iplot,1005) ymin+i*ydiv
              if (ly .ge. 7) write (iplot,1006) ymin+i*ydiv
            end if
          end do
          write (iplot,1011)
          if (xmin .ne. 0.0) then
            ixmin=0
          else
            ixmin=1
          end if
          do i=ixmin,nx
            write (iplot,1012)
            write (iplot,1002) ix0+i*ixwid/nx,iy0
            write (iplot,1003) 0,5
            write (iplot,1002) ix0+i*ixwid/nx,iyhgt+iy0
            write (iplot,1003) 0,-5
            write (iplot,1011)
            write (iplot,1002) ix0-30+i*ixwid/nx,iy0-15
            if (nx .lt. 8 .or. mod(i,2) .eq. 0) then
              if (lx .lt. 7) write (iplot,1005) xmin+i*xdiv
              if (lx .ge. 7) write (iplot,1006) xmin+i*xdiv
            end if
          end do
          write (iplot,1007) 'Plot traces'
          if (xmax .gt. xmin) then
            xfac=ixwid/(xmax-xmin)
          else
            xfac=0.0
          end if
          if (ymax .gt. ymin) then
            yfac=iyhgt/(ymax-ymin)
          else
            yfac=0.0
          end if
          ixrange=xdiv*nx*xfac*0.8
          iyrange=ydiv*ny*yfac*0.8
          call rrgbcolor(iplot,1,n,1)
          newpath=1
          iprev=0
          intcol=n/100+1
          nn=max0(1,n/incr)
          xav=0.0
          yav=0.0
          iprev=0
          ixprev=ix0+xfac*(xy(1,1)-xmin)
          iyprev=iy0+yfac*(xy(2,1)-ymin)
          do i=1,n
            xav=xav+xy(1,i)
            yav=yav+xy(2,i)
            if (mod(i,incr) .eq. 0) then
              xav=xav/float(incr)
              yav=yav/float(incr)
              ix=ix0+xfac*(xav-xmin)
              iy=iy0+yfac*(yav-ymin)
              xav=0.0
              yav=0.0
              if (i .gt. 1) then
                idraw=1
                if (iperiod .eq. 1) then
                  if (iabs(ix-ixprev) .gt. ixrange .or.
         -            iabs(iy-iyprev) .gt. iyrange ) idraw=0
                end if
                if (idraw .eq. 1) then
                  if (newpath .eq. 1) write (iplot,1002) ixprev,iyprev
                  if (float(i-iprev)/float(n) .ge. 0.1) then
                    ixx=(ix+ixprev)/2
                    iyy=(iy+iyprev)/2
                    write (iplot,1009) ixx,iyy
                    call rrgbcolor(iplot,i,n,1)
                    write (iplot,1002) ixx,iyy
                    write (iplot,1009) ix,iy
                  else
                    write (iplot,1009) ix,iy
                  end if
                end if
                if (nn .lt. 200 .or. mod(i,intcol) .eq. 0 .or.
         -          idraw .eq. 0) then
                  call rrgbcolor(iplot,i,n,1)
                  newpath=1
                else
                  newpath=0
                end if
              end if
              iprev=i
              ixprev=ix
              iyprev=iy
            end if
          end do
          write (iplot,1011)
          call rainbowscale(iplot,ix0,ixwid,iy0-100,n,0.0,0.0,0.0,
         -  timelab,ltimelab)
          write (iplot,1098)
          if (noclose .eq. 0) close (iplot)
          if (iprt .gt. 0) write (iout,2001) (i,(xy(k,i),k=1,2),i=1,n)
          return
    1001  format('/Helvetica findfont',/,'11 scalefont',/,'setfont',/,
         -  i4,i5,' moveto')
    1002  format(i5,i6,' moveto')
    1003  format(i5,i6,' rlineto')
    1005  format('(',f10.2,') show')
    1006  format('(',e10.4,') show')
    1007  format('% ',a)
    1009  format(i5,i6,' lineto')
    1010  format('% Drawing of graph boundaries',/,'newpath',/,
         -  i3,1x,i3,' moveto',/,i4,' 000 rlineto',/,'000 ',i4,' rlineto',/,
         -  i5,' 000 rlineto',/,'closepath',/,'stroke')
    1011  format('stroke')
    1012  format('newpath')
    1017  format('(System: ) show')
    1018  format(i5,' rotate')
    1020  format('%%Page: 1 ',i4)
    1098  format('-90 rotate',/,'-612 0 translate',/,'showpage')
    2001  format(i11,2e14.6)
          end
          subroutine arminmax2(ar,nfst,nlst,nplot,armin1,armax1,armin2,
         -  armax2,iyinc,ndim)
          dimension ar(ndim,nlst)
          if (nplot .eq. 2 .and. iyinc .gt. 0) then
            write (6,2000) nplot,iyinc
            iyinc=0
          end if
          armin1=1.e+30
          armax1=-armin1
          do i=nfst,nlst
            if (ar(iyinc+1,i) .lt. armin1) armin1=ar(iyinc+1,i)
            if (ar(iyinc+1,i) .gt. armax1) armax1=ar(iyinc+1,i)
          end do
          if (nplot .eq. 2) then
            armin2=1.e+30
            armax2=-armin2
            do i=nfst,nlst
              if (ar(2,i) .lt. armin2) armin2=ar(2,i)
              if (ar(2,i) .gt. armax2) armax2=ar(2,i)
            end do
          end if
          return
    2000  format(' PROGRAM ERROR: illegal nplot,iyinc (',i2,',',i2,')')
          end
          subroutine averageres(nframe,res,ix,ires,maxframe,maxres,av,sd)
          dimension res(2,maxframe,maxres)
          real*8 sum,sum2
          sum=0.d0
          sum2=0.d0
          do iframe=1,nframe
            sum=sum+res(ix,iframe,ires)
            sum2=sum2+res(ix,iframe,ires)**2
          end do
          av=sum/nframe
          sd=dsqrt(dabs(sum2/nframe-(sum/nframe)**2))
          return
          end
          subroutine roundlim(dmaxinp,div,ndiv)
          if (dmaxinp .gt. 1000000.0) then
            fac=10000.0
          else if (dmaxinp .gt. 100000.0) then
            fac=1000.0
          else if (dmaxinp .gt. 10000.0) then
            fac=100.0
          else if (dmaxinp .gt. 1000.0) then
            fac=10.0
          else
            fac=1.0
          end if
          dmax=dmaxinp/fac
          if (dmax .le. 0.05) then
            div=0.005
          else if (dmax .le. 0.1) then
            div=0.01
          else if (dmax .le. 0.2) then
            div=0.02
          else if (dmax .le. 0.5) then
            div=0.05
          else if (dmax .le. 1.0) then
            div=0.1
          else if (dmax .le. 2.0) then
            div=0.2
          else if (dmax .le. 5.0) then
            div=0.5
          else if (dmax .le. 8.0) then
            div=1.0
          else if (dmax .le. 10.0) then
            div=1.0
          else if (dmax .le. 12.0) then
            div=1.0
          else if (dmax .le. 15.0) then
            div=1.5
          else if (dmax .le. 20.0) then
            div=2.0
          else if (dmax .le. 25.0) then
            div=2.5
          else if (dmax .le. 50.0) then
            div=5.0
          else if (dmax .le. 100.0) then
            div=10.0
          else if (dmax .le. 200.0) then
            div=20.0
          else if (dmax .le. 250.0) then
            div=25.0
          else if (dmax .le. 400.0) then
            div=40.0
          else if (dmax .le. 500.0) then
            div=50.0
          else if (dmax .le. 600.0) then
            div=60.0
          else if (dmax .le. 750.0) then
            div=75.0
          else if (dmax .le. 800.0) then
            div=80.0
          else if (dmax .le. 1000.0) then
            div=100.0
          else
            div=200.0
          end if
          ndiv=(dmax+0.0001)/div
          if (dmax-ndiv*div .gt. dmax*0.01) ndiv=ndiv+1
          div=div*fac
          return
          end
          subroutine roundlimint(nmaxinp,idiv,ndiv)
          if (nmaxinp .gt. 1000000) then
            ifac=10000
          else if (nmaxinp .gt. 100000) then
            ifac=1000
          else if (nmaxinp .gt. 10000) then
            ifac=100
          else if (nmaxinp .gt. 1000) then
            ifac=10
          else
            ifac=1
          end if
          nmax=nmaxinp/ifac
          if (nmax .le. 10) then
            idiv=1
          else if (nmax .le. 50) then
            idiv=5
          else if (nmax .le. 100) then
            idiv=10
          else if (nmax .le. 200) then
            idiv=20
          else if (nmax .le. 250) then
            idiv=25
          else if (nmax .le. 300) then
            idiv=30
          else if (nmax .le. 400) then
            idiv=40
          else if (nmax .le. 500) then
            idiv=50
          else if (nmax .le. 600) then
            idiv=60
          else if (nmax .le. 750) then
            idiv=75
          else if (nmax .le. 800) then
            idiv=80
          else if (nmax .le. 1000) then
            idiv=100
          else
            idiv=200
          end if
          idiv=idiv*ifac
          ndiv=(nmaxinp-1)/idiv+1
          return
          end
          subroutine setdivxy(armin,armax,nxydiv,xydiv,xymin)
          if (armin .ne. 0.0) then
           arminimp=armin
            call roundlim(armin,xymindiv,nxymindiv)
            armin=xymindiv*(nxymindiv-1)
            do while (armin .gt. arminimp)
              armin=armin-xymindiv
            end do
          end if
          range=armax-armin
          call roundlim(range,xydiv,nxydiv)
          nmin=armin/xydiv
          xymin=nmin*xydiv
          return
          end
          subroutine checkbend(c,axisdir,camod,axfact,perpvec,x0,
         -  n,nup,ndown,nrun,nnear,axtol,rcirc,circ,rn,idecide,idebughx)
          real*8 c(3,n),axisdir(3),camod(3,n),perpvec(3,n),axfact(n),x0(3),
         -  circ(3),rn(3)
          real*8 rm(3),x(3),x1(3),x2(3),rr,rmin,ddistsq,ddot
          real*8 cx(3,50)
          dimension nupdown(2)
          call fitpoints(c,n,3,x0,rn,axfact,idebughx)
          if (idebughx .gt. 0) then
            do i=1,n
              call writepdbd(77,c(1,i),i,i,'C   ','CA ','A',1.0,0.0)
            end do
            call writepdbd(77,x0,n+1,n+1,'S   ','X0 ','B',1.0,0.0)
            if (idebughx .gt. 1) then
              idecide=6
              nup=0
              ndown=0
              nrun=0
            else
              call dvsum(x0,rn,x1)
              call writepdbd(77,x1,n+2,n+2,'S   ','RN ','B',1.0,0.0)
            end if
          end if
          if (idebughx .gt. 0)
         -  write (78,1000) (i,(c(k,i),k=1,3),(camod(k,i),k=1,3),axfact(i),
         -    (perpvec(k,i),k=1,3),i=1,n)
          rmin=1000.d0
          do i=1,n
            rr=ddistsq(c(1,i),camod(1,i))
            if (rr .lt. rmin) then
              rmin=rr
              imin=i
            end if
          end do
          rr=dsqrt(rmin)
          do i=1,n
            do k=1,3
              camod(k,i)=c(k,i)+rr*perpvec(k,i)
            end do
          end do
          if (idebughx .gt. 0) then
            do i=1,n
              call writepdbd(77,camod(1,i),i,i,'C   ','CA ','B',1.0,0.0)
            end do
          end if
          call circfit(c,n,axisdir,circ)
          rcirc=dsqrt(ddistsq(circ,x0))
          rr=0
          do i=1,n
            rr=rr+ddistsq(circ,c(1,i))
          end do
          rcirc=dsqrt(rr/dfloat(n))
          if (idebughx .gt. 0) write (77,1002) circ,x0,rcirc
          do i=1,n
            call dvdif(camod(1,i),x0,x1)
            rr=ddot(x1,rn)
            do k=1,3
              camod(k,i)=camod(k,i)-rr*rn(k)
            end do
          end do
          call fitpoints(camod,n,2,x0,rm,axfact,0)
          if (idebughx .gt. 0) then
            do i=1,n
              call writepdbd(77,camod(1,i),i,i,'N   ','CAP','C',1.0,0.0)
            end do
            call writepdbd(77,x0,n+1,n+1,'P   ','X0 ','B',1.0,0.0)
            call dvsum(x0,rm,x1)
            call writepdbd(77,x1,n+2,n+2,'P   ','RM ','B',1.0,0.0)
          end if
          if (idebughx .gt. 0) then
            call dvdif(camod(1,1),x0,x1)
            call dvdif(camod(1,2),x0,x2)
            call dvprd(x1,x2,x)
            do i=3,n
              call dvdif(camod(1,i),x0,x1)
              rr=ddot(x,x1)
              write (78,1001) i,(camod(k,i),k=1,3),rr
            end do
            call trnsfrd(cx,camod,3*n)
          end if
          do i=1,n
            do k=1,3
              camod(k,i)=(camod(k,i)-x0(k))-axfact(i)*rm(k)
            end do
          end do
          if (idebughx .gt. 0) then
            do i=1,n
              call dvdif(cx(1,i),camod(1,i),x)
              call writepdbd(77,x,i,i,'O   ','CA0','D',1.0,0.0)
            end do
          end if
          nnear=0
          if (axtol .gt. 0.0) then
            do i=1,n
              if (sngl(ddot(camod(1,i),camod(1,i))) .le. axtol**2) then
                nnear=nnear+1
              else if (nnear .gt. 0) then
                call trnsfrd(camod(1,i-nnear),camod(1,i),3)
              end if
            end do
          end if
          call zeroiti(nupdown,0,2)
          iupdown=0
          nswitch=0
          do i=2,n-nnear
            if (ddot(camod(1,i-1),camod(1,i)) .lt. 0.d0) then
              nswitch=nswitch+1
              iupdown=1-iupdown
            end if
            nupdown(iupdown+1)=nupdown(iupdown+1)+1
          end do
          nrun=nswitch+1
          nup=nupdown(1)
          ndown=nupdown(2)
          call runtest(nup,ndown,nrun,idecide)
          return
    1000  format(i3,' c=',3f8.3,' camod=',3f8.3,' axfac=',f8.3,/,
         -  ' perp=',3f8.4)
    1001  format(i3,' camod=',3f8.3,' plane check (->0)=',f10.6)
    1002  format(' CHECKBEND circ=',3f10.5,' x0=',3f10.5,' rcirc=',f10.5)
          end
          subroutine runtest(nup,ndown,nrun,idecide)
          dimension nmncrt(20,20),nmxcrt(20,20)
          data nmncrt/20*0,
         -  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2,
         -  0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3,
         -  0, 0, 0, 0, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4,
         -  0, 0, 0, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5,
         -  0, 0, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 6, 6,
         -  0, 0, 2, 2, 3, 3, 3, 4, 4, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6,
         -  0, 0, 2, 3, 3, 3, 4, 4, 5, 5, 5, 6, 6, 6, 6, 6, 7, 7, 7, 7,
         -  0, 0, 2, 3, 3, 4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8,
         -  0, 0, 2, 3, 3, 4, 5, 5, 5, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 9,
         -  0, 0, 2, 3, 4, 4, 5, 5, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 9,
         -  0, 2, 2, 3, 4, 4, 5, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9,10,10,
         -  0, 2, 2, 3, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 9,10,10,10,10,
         -  0, 2, 2, 3, 4, 5, 5, 6, 7, 7, 8, 8, 9, 9, 9,10,10,10,11,11,
         -  0, 2, 3, 3, 4, 5, 6, 6, 7, 7, 8, 8, 9, 9,10,10,11,11,11,12,
         -  0, 2, 3, 4, 4, 5, 6, 6, 7, 8, 8, 9, 9,10,10,11,11,11,12,12,
         -  0, 2, 3, 4, 4, 5, 6, 7, 7, 8, 9, 9,10,10,11,11,11,12,12,13,
         -  0, 2, 3, 4, 5, 5, 6, 7, 8, 8, 9, 9,10,10,11,11,12,12,13,13,
         -  0, 2, 3, 4, 5, 6, 6, 7, 8, 8, 9,10,10,11,11,12,12,13,13,13,
         -  0, 2, 3, 4, 5, 6, 6, 7, 8, 9, 9,10,10,11,12,12,13,13,13,14/
          data nmxcrt/60*0,
         -  0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         -  0, 0, 0, 9,10,10,11,11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         -  0, 0, 0, 9,10,11,12,12,13,13,13,13, 0, 0, 0, 0, 0, 0, 0, 0,
         -  0, 0, 0, 0,11,12,12,12,14,14,14,14,15,15,15, 0, 0, 0, 0, 0,
         -  0, 0, 0, 0,11,12,13,13,14,15,15,16,16,16,16,17,17,17,17,17,
         -  0, 0, 0, 0, 0,13,14,14,15,16,16,16,17,17,18,18,18,18,18,18,
         -  0, 0, 0, 0, 0,13,14,15,16,16,17,17,18,18,18,19,19,19,20,20,
         -  0, 0, 0, 0, 0,13,14,15,16,17,17,18,19,19,19,20,20,20,21,21,
         -  0, 0, 0, 0, 0,13,14,16,16,17,18,19,19,20,20,21,21,21,22,22,
         -  0, 0, 0, 0, 0, 0,15,16,17,18,19,19,20,20,21,21,22,22,23,23,
         -  0, 0, 0, 0, 0, 0,15,16,17,18,19,20,20,21,22,23,23,23,23,24,
         -  0, 0, 0, 0, 0, 0,15,16,18,18,19,20,21,22,22,23,23,24,24,25,
         -  0, 0, 0, 0, 0, 0, 0,17,18,19,29,21,21,22,23,23,24,25,25,25,
         -  0, 0, 0, 0, 0, 0, 0,17,18,19,20,21,22,23,23,24,25,25,26,26,
         -  0, 0, 0, 0, 0, 0, 0,17,18,19,20,21,22,23,24,25,25,26,26,27,
         -  0, 0, 0, 0, 0, 0, 0,17,18,29,21,22,23,23,24,25,26,26,27,27,
         -  0, 0, 0, 0, 0, 0, 0,17,18,20,21,22,23,25,25,26,26,27,27,28/
          if (ndown .gt. 20 .or. nup .gt. 20) then
            idecide=5
          else if (ndown .eq. 0 .or. nup .eq. 0) then
            idecide=1
          else if (nmxcrt(ndown,nup) .eq. 0 .or.
         -           nmncrt(ndown,nup) .eq. 0) then
            idecide=1
          else if (nrun .lt. nmncrt(ndown,nup)) then
            idecide=2
          else if (nrun .gt. nmxcrt(ndown,nup)) then
            idecide=4
          else
            idecide=3
          end if
          return
          end
          subroutine fitpoints(c,n,ndim,c0,dir,axfact,idebughx)
          real*8 c(3,n),c0(3),dir(3),axfact(n)
          real*8 dd(3),sum,ddot
          real*8 rr(3,3),diag(3),offdiag(3)
          data kcol /0/,kmin /0/,kmax /0/
          if (ndim .ne. 2 .and. ndim .ne. 3) then
            print *,'PROGRAM ERROR: invalid ndim in fitpoints=',ndim
            stop
          end if
          call zeroitd(c0,3)
          do i=1,n
            do k=1,3
              c0(k)=c0(k)+c(k,i)
            end do
          end do
          do k=1,3
            c0(k)=c0(k)/dfloat(n)
          end do
          if (idebughx .eq. 2) return
          do k=1,3
            do l=k,3
              sum=0.d0
              do i=1,n
                sum=sum+(c(k,i)-c0(k))*(c(l,i)-c0(l))
              end do
              rr(k,l)=sum
              rr(l,k)=sum
            end do
          end do
          if (idebughx .gt. 0) write (77,1000) 'Matrix',rr
          call dtred2(rr,3,3,diag,offdiag)
          call dtqli(diag,offdiag,3,3,rr,ierr)
          if (ierr .gt. 0) then
            write (6,1004)
            stop
          end if
          if (idebughx .gt. 0) write (77,1000) 'Eigenvectors',rr
          if (idebughx .gt. 0) then
            write (77,1000) 'diag',diag
            write (77,1000) 'offdiag',offdiag
          end if
          emax=0.0
          emin=1000.0
          nz=0
          do k=1,3
            if (dabs(diag(k)) .lt. 0.005d0) then
              nz=nz+1
            else
              if (diag(k) .gt. emax) then
                emax=diag(k)
                kmax=k
              end if
              if (diag(k) .lt. emin) then
                emin=diag(k)
                kmin=k
              end if
            end if
          end do
          if (ndim .eq. 2 .and. nz .eq. 0) write (6,1001) diag
          if (ndim .eq. 3 .and. nz .gt. 0) print *,'WARNING: 3D dataset ',
         -  'appears to be in a plane'
          if (ndim .eq. 2) kcol=kmax
          if (ndim .eq. 3) kcol=kmin
          do k=1,3
            dir(k)=rr(k,kcol)
          end do
          do i=1,n
            call dvdif(c(1,i),c0,dd)
            axfact(i)=ddot(dir,dd)
          end do
          return
    1000  format(1x,a,'=',/,(3f15.5))
    1001  format(' ERROR: no zero eigenvalue found when fitting points ',
         -  'in a plane',/,8x,'diag=',3f10.5)
    1004  format(' Calculation aborted due to diagonalization failure')
          end
          subroutine findbestrep(iw0,icl,iclsub,nframe,mask,irdavmn,irdmxmn,
         -  ieng,emin,emax,eav,diam,diammin,diammax,irepeng,label,llabel,
         -  iout_term,mx2d)
          dimension mask(mx2d)
          character*(*) label
          parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
          parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
         -  (4*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
          common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),ing(MAX2D,MAX2D),
         -  ihbpair(2,MAXBONDS),a1(MAXBONDS),a2(MAXBONDS),fill(IFILL2)
          rdsmn=1.0e+20
          rdmn=1.0e+20
          nmem=0
          rmsdmax=0.0
          nframeused=0
          irdmxmn=0
          iravxmn=0
          do ix=1,nframe
            if (mask(ix) .gt. 0) nframeused=nframeused+1
          end do
          nsing=0
          if (icl .gt. 0) then
            if (iclsub .eq. 0) then
              if (iout_term .gt. 0)
         -      write (iout_term,1005) icl,nframeused
              if (iw0 .gt. 0) write (iw0,1005) icl,nframeused
            else
              if (iout_term .gt. 0) write (iout_term,1002)
         -      icl,iclsub,nframeused
              if (iw0 .gt. 0) write (iw0,1002) icl,iclsub,nframeused
            end if
          else
            write (6,*)
          end if
          if (ieng .gt. 0) then
            write (6,1006) icl,eav,emin,emax
            write (iw0,1006) icl,eav,emin,emax
          end if
          do ix=1,nframe
            nmem0=nmem
            if (mask(ix) .gt. 0) then
              nmem=nmem+1
              a1(ix)=0.0
              a2(ix)=0.0
              do iy=1,ix-1
                if (mask(iy) .gt. 0) then
                  a1(ix)=a1(ix)+rmsd2d(iy,ix)**2
                  if (rmsd2d(iy,ix) .gt. a2(ix)) a2(ix)=rmsd2d(iy,ix)
                  if (rmsd2d(iy,ix) .ge. rmsdmax) then
                    rmsdmax=rmsd2d(iy,ix)
                    ix1=ix
                    ix2=iy
                  end if
                end if
              end do
              do iy=ix+1,nframe
                if (mask(iy) .gt. 0) then
                  a1(ix)=a1(ix)+rmsd2d(ix,iy)**2
                  if (rmsd2d(ix,iy) .gt. a2(ix)) a2(ix)=rmsd2d(ix,iy)
                end if
              end do
              if (a1(ix) .lt. rdsmn) then
                rdsmn=a1(ix)
                irdavmn=ix
              end if
              if (a2(ix) .lt. rdmn) then
                rdmn=a2(ix)
                irdmxmn=ix
              end if
            end  if
            if (nmem .gt. nmem0) a1(ix)=a1(ix)/float(nmem-nmem0)
          end do
          if (nmem .gt. 1) then
            if (iout_term .gt. 0)
         -    write (iout_term,1010) irdmxmn,label(1:llabel),rdmn,
         -      label(1:llabel),rmsdmax,ix1,ix2,label(1:llabel),
         -      label(1:llabel),ix1,irdmxmn,rmsd2d(ix1,irdmxmn),
         -      label(1:llabel),ix2,irdmxmn,rmsd2d(ix2,irdmxmn)
            if (iw0 .gt. 0)
         -    write (iw0,1010) irdmxmn,label(1:llabel),rdmn,
         -    label(1:llabel),rmsdmax,ix1,ix2,label(1:llabel),
         -    label(1:llabel),ix1,irdmxmn,rmsd2d(ix1,irdmxmn),
         -    label(1:llabel),ix2,irdmxmn,rmsd2d(ix2,irdmxmn)
            if (label(1:4) .eq. 'RMSD') then
              if (iout_term .gt. 0)
         -      write (iout_term,1011) irdavmn,rdsmn/nframeused,ix1,irdavmn,
         -      rmsd2d(ix1,irdavmn),ix2,irdavmn,rmsd2d(ix2,irdavmn)
              if (iw0 .gt. 0)
         -      write (iw0,1011) irdavmn,rdsmn/nframeused,ix1,irdavmn,
         -      rmsd2d(ix1,irdavmn),ix2,irdavmn,rmsd2d(ix2,irdavmn)
              if (diammin .gt. rmsdmax) diammin=rmsdmax
              if (diammax .lt. rmsdmax) diammax=rmsdmax
              diam=rmsdmax
            end if
            if (irdavmn .ne. irdmxmn) then
              if (iout_term .gt. 0)
         -      write (iout_term,1001) label(1:llabel),irdavmn,irdmxmn,
         -        rmsd2d(irdavmn,irdmxmn)
              write (iw0,1001) label(1:llabel),irdavmn,irdmxmn,
         -      rmsd2d(irdavmn,irdmxmn)
            end if
          end if
          if (label(1:4) .eq. 'RMSD' .and. iw0 .gt. 0) then
            write (iw0,1003)
            do ix=1,nframe
              if (mask(ix) .gt. 0) then
                write (iw0,1004) ix,sqrt(a1(ix)),a2(ix)
              end if
            end do
          end if
          return
    1001  format(1x,a,' between the two center estimates',
         -  ' (',i5,',',i5,')=',f8.2)
    1002  format(/,' Cluster #',i4,' Subcluster #',i3,
         -  ' Number of members=',i5)
    1003  format(/,' RMSD average and maximum (over other cluster members)',
         -  ' for each frame analyzed')
    1004  format(' Frame #',i4,' sqrt(<MSD>)=',f12.3,' Maximum RMSD=',f8.2)
    1005  format(/,' Cluster #',i4,' Number of members=',i5)
    1006  format(' Cluster #',i4,' Average energy: ',e12.5,
         -  ' Range: [',e12.5,',',e12.5,']')
    1011  format(' Cluster center based on the lowest mean MSD:    #',i5,
         -  ' (<MSD>=',f8.2,')',/
         -  ' Cluster radius based on the lowest mean MSD:   ',/,
         -  16x,'RMSD(',i5,',',i5,')=',f8.2,'  RMSD(',i5,',',i5,')=',f8.2)
    1010  format(' Cluster center: #',i5,' - based on the lowest maximum ',
         -  a,' (',f8.2,')',/
         -  ' Largest ',a,' (cluster diameter) is ',f8.2,
         -  ' between #',i5,' & #',i5,/,
         -  ' Cluster radius based on the lowest maximum ',a,':',/,
         -  1x,a,'(',i5,',',i5,')=',f8.2,2x,a,'(',i5,',',i5,')=',f8.2)
          end
          subroutine findbestcorrep(iout,ifcl,ilcl,index,mx2d)
          dimension index(mx2d)
          parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
          parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
         -  (4*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
          common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),ing(MAX2D,MAX2D),
         -  ihbpair(2,MAXBONDS),a1(MAXBONDS),a2(MAXBONDS),fill(IFILL2)
          ravmax=100000.0
          ixavmax=0
          rminmax=100000.0
          ixminmax=0
          nmem=ilcl-ifcl+1
          rxymax=0.0
          ixmax=0.
          iymax=0.
          do ixx=ifcl,ilcl
            ix=index(ixx)
            r2av=0.0
            r2max=0.0
            do iyy=ifcl,ilcl
              if (iyy .ne. ixx) then
                iy=index(iyy)
                r2=rmsd2d(ix,iy)
                r2av=r2av+r2
                if (r2 .gt. r2max) r2max=r2
                if (r2 .gt. rxymax) then
                  rxymax=r2
                  ixmax=ix
                  iymax=iy
                end if
              end if
            end do
            if (r2max .lt. rminmax) then
              rminmax=r2max
              ixminmax=ix
            end if
            r2av=r2av/nmem
            if (r2av .lt. ravmax) then
              ravmax=r2av
              ixavmax=ix
            end if
          end do
          write (iout,1001) 'max',ixminmax,'max',rminmax
          write (iout,1001) 'avg',ixavmax,'avg',ravmax
          write (iout,1002) rxymax,ixmax,iymax
          write (iout,1003) ixminmax,ixavmax,rmsd2d(ixavmax,ixminmax)
          write (iout,1004)
          return
    1001  format(' Cluster center based on the lowest ',a,' distance: ',i5,
         -  1x,a,' distance=',f8.3)
    1002  format(' Cluster diameter=',f8.2,' (distance between ',i6,
         -  ' and ',i6,')')
    1003  format(' Distance between the two center estimates',
         -  ' (',i5,',',i5,') =',f8.2)
    1004  format(' NOTE: numbers above refer to the unfiltered bond number')
          end
          subroutine plot2drmsd(nrep,iw0,iw1,xtraj,maxn,title,title2,
         -  ltitle2,ltrajfile2,xlab,lxlab,ncolcode,maxcolcode,iedit,noopt2d,
         -  limresrange,normsavg,rmsdmin,rmsdmax,absdevmin,absdevmax,
         -  rmsdmn,rmsdmx,indexa,indexr,ixshuffle,ixshuffleref,ilastclx,
         -  nclx,ilastcly,ncly,ym_2d,itemp1,itemp2,temp,matplotonly,isymm,
         -  noplotdist,iskip2dplot,isortmat,noclose,ipspage,ifindbest)
          character*80 title
          character*(*) title2
          character*(*) xlab
          dimension xtraj(maxn),indexa(maxn),indexr(maxn),ixshuffle(maxn),
         -  ixshuffleref(maxn),ilastcly(maxn),ilastclx(maxn),
         -  itemp1(maxn),itemp2(maxn),temp(maxn)
          parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
          parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
         -  (4*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
          common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),ing(MAX2D,MAX2D),
         -  ihbpair(2,MAXBONDS),a1(MAXBONDS),a2(MAXBONDS),fill(IFILL2)
          parameter (MAXFRAMES=50000,MAXCOPY=600)
          common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
         -  increment,increment2,res(2,MAXFRAMES,MAXCOPY),
         -  x0(MAXCOPY),y0(MAXCOPY),nxselres,ixselres(MAXCOPY)
          dimension kc(1,1)
          real*8 dc(1,1)
          dimension nrmsd(100),xrmsd(100),refrmsd(100)
          character*4 yclab(1)
          character*80 title2add
          data nyclab /1/,lyclab /1/
          cdiammin=100000.0
          cdiammax=0.0
          if (ifindbest .gt. 0) then
            call indexit(indexa,1,nframe,0)
            write (6,1015)
            call findbestrep(iw0,0,0,nframe,indexa,irdavmn,irdmxmn,
         -    0,0.0,0.0,0.0,cdiam,cdiammin,cdiammax,0,'RMSD',4,6,MAX2D)
          end if
          rcmax=0.0
          rcmin=100000.0
          nz_rmsd=0
          do ix=1,nframe
            if (isymm .eq. 1) then
              do iy=ix+1,nframe
                if (rmsd2d(ix,iy) .gt. rcmax) rcmax=rmsd2d(ix,iy)
                if (rmsd2d(ix,iy) .lt. rcmin) rcmin=rmsd2d(ix,iy)
                if (rmsd2d(ix,iy) .eq. 0.0) nz_rmsd=nz_rmsd+1
              end do
              rmsd2d(ix,ix)=0.0
            else
              do iy=1,nframeref
                if (rmsd2d(ix,iy) .gt. rcmax) rcmax=rmsd2d(ix,iy)
                if (rmsd2d(ix,iy) .lt. rcmin) rcmin=rmsd2d(ix,iy)
                if (rmsd2d(ix,iy) .eq. 0.0) nz_rmsd=nz_rmsd+1
              end do
            end if
          end do
          write (6,1011) 'RMSD',rcmin,rcmax
          write (iw0,1011) 'RMSD',rcmin,rcmax
          if (rcmin .eq. 0.0) then
            write (6,1017) 'WARNING','minimum','some',' ',nz_rmsd
            write (iw0,1017) 'WARNING','minimum','some',' ',nz_rmsd
          end if
          if (rcmax .eq. 0.0) then
            write (6,1017) 'ERROR','maximum','all'
            write (iw0,1017) 'ERROR','maximum','all'
            print *,'Exiting plotting'
            return
          end if
          if (absdevmin .lt. 100000.0) then
            write (6,1011) 'absolute deviation',absdevmin,absdevmax
            write (iw0,1011) 'absolute deviation',absdevmin,absdevmax
          end if
          if (isymm .eq. 1) then
            rmsdmn=0.0
          else if (rmsdmin .gt. 0.0) then
            write (6,1010) 'minimum',rmsdmin
            write (iw0,1010) 'minimum',rmsdmin
            rmsdmn=rmsdmin
          else
            rmsdmn=rcmin
          end if
          if (rmsdmax .ne. 0.0) then
            write (6,1010) 'maximum',rmsdmax
            write (iw0,1010) 'maximum',rmsdmax
            rmsdmx=rmsdmax
          else
            rmsdmx=rcmax
          end if
          nframetop=max0(nframe,nframeref)
          if (iskip2dplot .eq. 0) then
            inc=max0(1,500/nframetop)
            scalefac=amin1(1.0,500.0/float(nframetop))
            iyrange=scalefac*(nframeref*inc)+15
            iytop=ym_2d*0.87
            iydel=max0(150,iytop-iyrange)
            iouttemp=91
            call contractmat(rmsd2d,nframe,nframeref,nframeplot,
         -    nframerefplot,navg,ixshuffle,ixshuffleref,itemp1,itemp2,
         -    temp,isortmat,iouttemp,MAX2D)
            iydel=iydel-15
            if (limresrange .gt. 0) then
              write (iw1,1005) 25,iytop
              call psshow(iw1,
         -      'RMSD was calculated on a limited residue set',44)
              iydel=iydel-15
              iytop=iytop-15
            end if
            write (iw1,1005) 25,iytop
            write (title2add,1019) navg
            iydel=iydel-15
            iytop=iytop-15
            ladd=30
            if (ltitle2 .gt. 0) then
              title2add(1:ladd+ltitle2)=title2(1:ltitle2)//' '//
         -      title2add(1:ladd)
              ladd=ladd+ltitle2
            end if
            call psshow(iw1,title2add(1:ladd),ladd)
            iydel=iydel-15
            iytop=iytop-15
            itrajname=1
            if (ltrajfile2 .gt. 0) then
              nframe2=nframe
              iydel=iydel-15
              iytop=iytop-15
              itrajname=3
            end if
            if (isortmat .eq. 1 .and. navg .gt. 1) then
              call indexit(ixshuffle,1,nframe,0)
              call indexit(ixshuffleref,1,nframeref,0)
            end if
            call plotmat(iw1,kc,rmsd2d,dc,nframeplot,nframerefplot,0,0,0,0,
         -    navg,nrep,25,iydel,00,iytop,rmsdmn,rmsdmx,ncolcode,maxcolcode,
         -    ixdelsh,iydelsh,inc,scalefac,indexr,ixshuffle,ixshuffleref,
         -    title,0,' ',0,itrajname,xlab,lxlab,xtraj,yclab,nyclab,lyclab,
         -    1,MAX2D,1,MAX2D,MAX2D,ipspage,0)
            if (navg .gt. 1) then
              rewind iouttemp
              read (iouttemp,end=999)
         -      ((rmsd2d(i,j),i=1,nframe),j=1,nframeref)
              close (iouttemp,status='delete')
            end if
            if (nframe .ge. 50) iydel=iydel-50
            if (nframe .lt. 50) iydel=iydel-40
            ixcent=amax1(0.0,(scalefac*(nframe*inc)-80*ncolcode)/2)
            call colcodeminmax(iw1,20+ixcent,-iydel,nrep,ncolcode,
         -    maxcolcode,rmsdmn,rmsdmx)
            iydel=iydel-40
            write (iw1,1005) 50,iydel
            write (iw1,1002) rmsdmn,rmsdmx
            write (iw1,1005) 50+250,iydel
            if (noopt2d .eq. 0) then
              if (iedit .eq. 0) write (iw1,1009) 'all atoms'
              if (iedit .eq. 1) write (iw1,1009) 'a limited set of atoms'
            else
              write (iw1,1016)
            end if
            print *
            if (max0(nclx,ncly) .le. 10 .and. min0(nclx,ncly) .gt. 0) then
              write (iw1,1018)
              call rgbcolor(iw1,9)
              lw=2
              if (max0(nclx,ncly) .gt. 10) lw=1
              lw=lw/scalefac
              write (iw1,1012) lw
              if (max0(nclx,ncly) .gt. 1 .and. scalefac .ne. 1.0)
         -      write (iw1,1013) scalefac,scalefac
              write (iw1,*) 'np'
              ixdell=25
              if (nframeplot*scalefac .lt. 550) ixdell=ixdell+40/scalefac
              do ic=1,nclx
                if (ilastclx(ic) .ne. nframe) then
                  write (iw1,1005) ixdell+ilastclx(ic)*inc,iydelsh
                  write (iw1,1006) ixdell+ilastclx(ic)*inc,
         -          iydelsh+nframeref*inc
                end if
              end do
              do ic=1,ncly
                if (ilastcly(ic) .ne. nframe) then
                  write (iw1,1005) ixdell,iydelsh+ilastcly(ic)*inc
                  write (iw1,1006) ixdell+nframe*inc,
         -          iydelsh+ilastcly(ic)*inc
                end if
              end do
              write (iw1,*) 'sk'
              if (max0(nclx,ncly) .gt. 1 .and. scalefac .ne. 1.0)
         -        write (iw1,1013) 1.0/scalefac,1.0/scalefac
            else
              if (max0(nclx,ncly) .gt. 0) write (6,1004)
            end if
            write (iw1,*) 'showpage'
            if (matplotonly .eq. 1) then
              if (noclose .eq. 0) close (iw1)
              return
            end if
          end if
          if (normsavg .eq. 0 .or. nframe .lt. 25) then
            write (iw0,1000)
            do il=1,nframe-1
              rmssum=0.0
              rmssum2=0.0
              rmssum4=0.0
              do i=1,nframe-il
                rmssum=rmssum+rmsd2d(i,i+il)
                rmssum2=rmssum2+rmsd2d(i,i+il)**2
                rmssum4=rmssum4+rmsd2d(i,i+il)**4
              end do
              res(1,il,8)=rmssum/(nframe-il)
              res(2,il,8)=rmssum2/(nframe-il)
              res(1,il,9)=sqrt(abs(rmssum2/(nframe-il)-res(1,il,8)**2))
              res(2,il,9)=sqrt(abs(rmssum4/(nframe-il)-res(2,il,8)**2))
              write (iw0,1001) il,((res(k,il,ii),ii=8,9),k=1,2)
            end do
            if (noplotdist .eq. 0) then
              call arminmax2(res(1,1,8),1,nframe-1,2,armin1,armax1,armin2,
         -      armax2,0,2)
              call roundlim(armax1,y1div,ny1div)
              call roundlim(armax2,y2div,ny2div)
              call plot2fun(iw1,2,xtraj,res(1,1,8),res(1,1,9),nframe-1,
         -      0.0,0.0,0,0.0,y1div,ny1div,0.0,y2div,ny2div,title,80,' ',1,
         -      xlab,lxlab,'2D-map averaged RMSD',20,
         -      '2D-map averaged MSD',19,1,0,6,2,0,0,1,0,0,
         -      ipspage,1,1,0)
            end if
          end if
          call zeroiti(nrmsd,0,100)
          if (normsavg .eq. 0 .and. nframe .ge. 25) then
            rcmaxx=rcmax**2
            ircmax=rcmax**2
            rcmax=ircmax+1
            if (nframe .ge. 100) then
              rcdiv=rcmaxx/99.9999
            else if (nframe .ge. 50) then
              rcdiv=rcmaxx/49.9999
            else
              rcdiv=rcmaxx/24.9999
            end if
            do il=1,nframe-1
              do i=1,nframe-il
                ix=rmsd2d(i,i+il)**2/rcdiv+1
                if (ix .gt.100) ix=100
                nrmsd(ix)=nrmsd(ix)+1
              end do
            end do
            pmax1=0.0
            pmax2=0.0
            dcoef=rcmaxx/float(nframe)
            do ix=1,100
              refrmsd(ix)=(nframe-(ix*rcdiv)/dcoef)/
         -      float((nframe*(nframe-1))/2)
            end do
            write (iw0,1007) ' '
            do ix=1,100
              res(1,ix,9)=float(nrmsd(ix))/float((nframe*(nframe-1))/2)
              if (pmax1 .lt. res(1,ix,9)) pmax1=res(1,ix,9)
              xrmsd(ix)=ix*rcdiv
              if (ix .gt. 98) then
                res(2,ix,9)=res(2,98,9)
              else
                res(2,ix,9)=res(1,ix,9)/refrmsd(ix)
              end if
              if (pmax2 .lt. res(2,ix,9)) pmax2=res(2,ix,9)
              write (iw0,1008) ix,xrmsd(ix),res(1,ix,9),' ',res(2,ix,9)
            end do
            if (noplotdist .eq. 0) then
              call roundlim(pmax1,y1div,ny1div)
              call roundlim(pmax2,y2div,ny2div)
              call plot2fun(iw1,2,xrmsd,res(1,1,9),res(1,1,9),100,0.0,
         -      rcmax/10.,10,0.0,y1div,ny1div,0.0,y2div,ny2div,title,80,
         -      ' ',1,'MSD',3,' MSD distribution',17,
         -      ' MSD/Reference ideal distribution',33,1,
         -      0,6,2,1,0,1,0,0,ipspage,1,1,0)
            end if
          else if (normsavg .eq. 1) then
            ircmax=rcmax+1.0
            rcmax=ircmax
            rcdiv=rcmax/99.9999
            do i1=1,nframe
              do i2=1,nframeref
                ix=rmsd2d(i2,i1)/rcdiv+1
                if (ix .gt.100) ix=100
                nrmsd(ix)=nrmsd(ix)+1
              end do
            end do
            pmax1=0.0
            write (iw0,1007) ' R'
            do ix=1,100
              res(1,ix,9)=float(nrmsd(ix))/float(nframe*nframeref)
              if (pmax1 .lt. res(1,ix,9)) pmax1=res(1,ix,9)
              xrmsd(ix)=ix*rcdiv
              write (iw0,1008) ix,xrmsd(ix),res(1,ix,9)
            end do
            call roundlim(pmax1,y1div,ny1div)
            call plot2fun(iw1,1,xrmsd,res(1,1,9),res(1,1,9),100,0.0,
         -    rcmax/10.,10,0.0,y1div,ny1div,0.0,y2div,ny2div,title,80,' ',1,
         -    'RMSD',4,'RMSD distribution',17,' ',1,1,
         -    0,6,2,1,0,1,0,0,ipspage,1,1,0)
          end if
          if (noclose .eq. 0) close (iw1)
          return
    999   write (6,1014)
          stop
          return
    1000  format(/,' Average RMSD & MSD as a function of time (frame ',
         -  '# difference) over the 2D map:',/)
    1001  format(' RMSD(',i5,')=',f10.5,' SD=',f10.5,
         -  ' MSD=',f10.5,' SD=',f10.5)
    1002  format('( Range of the RMSD scale:',f8.3,'  -',f8.3,') show')
    
    1004  format(' NOTE: There are too many clusters for drawing ',
         -  'cluster-delineating lines')
    1005  format(2i5,' m')
    1006  format(2i5,' l')
    1007  format(/,'Distribution of the',a,'MSD values:',/)
    1008  format(i4,' p(RMSD=',f9.2,')=',f8.6,a,'p(refRMSD)=',f10.5)
    1009  format('( Overlay is based on ',a,') show')
    1010  format(' RMSD ',a,' used for plotting=',f10.2,' A')
    1011  format(' Range of ',a,' values: [',f12.5,',',f12.5,'] A')
    1012  format(i2,' lw')
    1013  format(f10.6,f10.6,' scale')
    1014  format(' PROGRAM ERROR: could not restore original matrix from ',
         -  'the temporary file rij.tmp')
    1015  format(' Details of the structure ensemble as a single cluster:')
    1016  format('( RMSD was calculated without overlay) show')
    1017  format(1x,a,' RMSD ',a,' is zero - ',a,' items are identical',a,/,
         -  ' Number of zero RMSDs=',i10)
    1018  format('% Draw cluster separator lines')
    1019  format('Number of frames averaged=',i2)
          end
          subroutine plot_atomdist_sd(n,line,index,inamcol1,inamcol2,
         -  irescol1,irescol2,iresncol1,iresncol2,ldist,ndist,nframe,indexa,
         -  ixshuffle,xtraj,title,trajfile,ltrajfile,isdtyp,iw0,iw1,
         -  ipspage,maxrec)
          dimension ldist(ndist),index(n),indexa(ndist),
         -  ixshuffle(ndist),xtraj(ndist)
          character*132 line(maxrec)
          character*80 title
          character*(*) trajfile
          parameter (MAXPHI=400,MAX2D=5000)
          parameter (IFILL9=MAXPHI*MAXPHI*MAXPHI-
         -  (2*MAX2D*MAX2D+11*MAX2D))
          real*8 trajdist,cav,cavs,rr,dscprod
          common /nnwork/ trajdist(MAX2D,MAX2D),cav(3,MAX2D),
         -  cavsng(3,MAX2D),cavs(MAX2D),fill(IFILL9)
          common /colorinfo/ ncolcode,maxcolcode
          dimension kc(1,1),rc(1,1),lnormtyp(4)
          character*4 yclab(1)
          character*17 normtyp(4)
          data normtyp /' ','/RMSD(i)*RMSD(j) ','/r(i,j) ','*r(i,j) '/,
         -  lnormtyp /1,17,8,8/
          data nyclab /1/,lyclab /1/
          rcmax=0.0
          rcmin=100000.0
          rmsdmax=0.0
          rmsdmin=100000.0
          do ia=1,ndist
            xtraj(ia)=ia
            do k=1,3
              cav(k,ia)=cav(k,ia)/dfloat(nframe)
              cavsng(k,ia)=cav(k,ia)
            end do
            rr=dscprod(cav(1,ia),cav(1,ia))
            cavs(ia)=dsqrt(cavs(ia)/dfloat(nframe)-rr)
            if (rmsdmax .lt. cavs(ia)) rmsdmax=cavs(ia)
            if (rmsdmin .gt. cavs(ia)) rmsdmin=cavs(ia)
            do ja=1,ia-1
              sd=dsqrt(trajdist(ia,ja)/dfloat(nframe)-
         -      (trajdist(ja,ia)/dfloat(nframe))**2)
              if (isdtyp .eq. 2) then
                sd=sd/(cavs(ia)*cavs(ja))
              else if (isdtyp .eq. 3) then
                sd=sd/sqrt(dist2(cavsng(1,ia),cavsng(1,ja)))
              else if (isdtyp .eq. 3) then
                sd=sd*sqrt(dist2(cavsng(1,ia),cavsng(1,ja)))
              end if
              trajdist(ia,ja)=sd
              trajdist(ja,ia)=sd
              if (rcmin .gt. sd) rcmin=sd
              if (rcmax .lt. sd) rcmax=sd
            end do
            trajdist(ia,ia)=0.d0
          end do
          do ia=1,ndist
            write (iw0,1000) ia,ldist(ia),
         -    line(index(ldist(ia)))(inamcol1:inamcol2),
         -    line(index(ldist(ia)))(irescol1:irescol2),
         -    line(index(ldist(ia)))(iresncol1:iresncol2),
         -    (cav(k,ia),k=1,3),cavs(ia),
         -    normtyp(isdtyp)(1:lnormtyp(isdtyp)),
         -    (trajdist(ia,ja),ja=1,ndist)
          end do
          write (6,1011) 'SD(rij)',normtyp(isdtyp)(1:lnormtyp(isdtyp)),
         -  rcmin,rcmax
          write (iw0,1011) 'SD(rij)',normtyp(isdtyp)(1:lnormtyp(isdtyp)),
         -  rcmin,rcmax
          write (6,1011) 'site RMSD',' ',rmsdmin,rmsdmax
          write (iw0,1011) 'site RMSD',' ',rmsdmin,rmsdmax
          if (rmsdmax .gt. 10.0) then
            write (6,1006)
            write (iw0,1006)
          end if
          if (rcmin .eq. 0.0) then
            write (6,1017) 'minimum','some'
            write (iw0,1017) 'minimum','some'
          end if
          if (rcmax .eq. 0.0) then
            write (6,1017) 'maximum','all'
            write (iw0,1017) 'maximum','all'
            print *,'Exiting plotting'
            return
          end if
          navg=1
          nrep=0
          ixdelsh=0
          inc=max0(1,500/ndist)
          scalefac=amin1(1.0,500.0/float(ndist))
          iyrange=scalefac*(ndist*inc)+20
          ym_2d=800.0
          iytop=ym_2d*0.83
          iydel=max0(150,iytop-iyrange)
          iymax=iydel+iyrange
          write (iw1,1005) 25,iymax
          write (iw1,1003) normtyp(isdtyp)(1:lnormtyp(isdtyp)),
         -  trajfile(1:ltrajfile)
          iymax=iymax+15
          write (iw1,1005) 25,iymax
          call plotmat(iw1,kc,rc,trajdist,ndist,ndist,0,0,0,0,navg,
         -  nrep,25,iydel,00,iytop,rcmin,rcmax,ncolcode,maxcolcode,ixdelsh,
         -  iydelsh,inc,scalefac,indexa,ixshuffle,ixshuffle,title,0,
         -  ' ',0,0,'Atom #',6,xtraj,yclab,nyclab,lyclab,MAX2D,
         -    MAX2D,MAX2D,1,1,ipspage,0)
          if (ndist .ge. 50) iydel=iydel-50
          if (ndist .lt. 50) iydel=iydel-40
          ixcent=amax1(0.0,(scalefac*(ndist*inc)-80*ncolcode)/2)
          call colcodeminmax(iw1,20+ixcent,-iydel,nrep,ncolcode,
         -  maxcolcode,rcmin,rcmax)
          iydel=iydel-40
          write (iw1,1005) 50,iydel
          write (iw1,1002) rcmin,rcmax
          write (iw1,1005) 50+250,iydel
          return
    1000  format(i5,' Atom',i7,' (',a,',',a,a,') <c>=',3f8.3,
         -  ' RMSD(c)=',f6.2,/,' SD(Rij)',a,':',/,(10f8.4))
    1002  format('( Range of the SD scale:',f8.5,'  -',f8.5,') show')
    1003  format('( Atom-atom distance SD',a,'of trajectory file ',a,
         -  ') show')
    1005  format(2i5,' m')
    1006  format(' NOTE: trajectory scan did not use PBC - trajectory ',
         -  'has to be centered first')
    1011  format(' Range of ',a,a,' values: [',f12.5,',',f12.5,'] A')
    1017  format(' SD(rij) ',a,' is zero - ',a,' items are identical')
          end
          subroutine read_distmat(iw0,n,rijrmin,rijrmax,ix,label,inpfile,
         -  iuout,mx2d)
          dimension ix(mx2d)
          character*500 label(mx2d)
          character*500 line
          character*(*) inpfile
          parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
          parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
         -  (4*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
          common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),ing(MAX2D,MAX2D),
         -  ihbpair(2,MAXBONDS),a1(MAXBONDS),a2(MAXBONDS),fill(IFILL2)
          dimension n10(10)
          llen=500
          namleni=0
          call openfile(iw0,0,'distance matrix file',20,'old',inpfile,
         -  namleni,notfnd,0,1,1,0,0)
          call askyn('Do you want to limit the label to its last word',47,
         -  1,-1,lastword,0,0)
          read (iw0,*,err=666) n
          call checkdim(n,MAX2D,'MAX2D',5,'matrix dimension',16,0)
          if (n .lt. 1) then
            write (6,1005) n
            stop
          else
            write (6,1003) n
            write (iuout,1003) n,' ',inpfile(1:namleni)
          end if
          do i=1,n
            call blankout(line,1,llen)
            read (iw0,2000,end=999) line
            call lastchar(line,lline,llen)
            if (lline .eq. llen) write (6,1004) llen,i,line
            ic=1
            if (line(1:1) .eq. ' ') call nextchar(line,ic,llen)
            ic1=ic
            call nextblank(line,ic,llen)
            read (line(ic1:ic-1),*,err=777) ix(i)
            call blankout(label(i),1,llen)
            if (lastword .eq. 0) then
              call nextchar(line,ic,llen)
              label(i)(1:lline-ic+1)=line(ic:lline)
            else
              call laststring(line,icf,icl,lline,llen)
              label(i)(1:icl-icf+1)=line(icf:icl)
            end if
            read (iw0,*,end=999,err=888) (rmsd2d(i,j),j=1,n)
          end do
          close (iw0)
          rijrmin=1000000.0
          rijrmax=-rijrmin
          nerr=0
          do i=1,n
            do j=1,i-1
              if (rmsd2d(i,j) .lt. rijrmin) rijrmin=rmsd2d(i,j)
              if (rmsd2d(i,j) .gt. rijrmax) rijrmax=rmsd2d(i,j)
              if (rmsd2d(i,j) .ne. rmsd2d(j,i)) then
                nerr=nerr+1
                if (nerr .le. 10)
         -         write (6,1001) i,j,rmsd2d(i,j),j,i,rmsd2d(j,i)
              end if
            end do
          end do
          write (6,1002) rijrmin,rijrmax
          call transform_mat(rmsd2d,n,mx2d,rijrmin,iuout)
          call transform_dist(rijrmin,rijmin)
          call transform_dist(rijrmax,rijmax)
          if (rijmin .gt. rijmax) then
            x=rijmax
            rijmax=rijmin
            rijmin=x
          end if
          write (6,1006) rijmin,rijmax
          call zeroiti(n10,0,10)
          rijrange=rijmax-rijmin
          nz=0
          do i=1,n
            do j=1,i-1
              ixd=10.0*(rmsd2d(i,j)-rijmin)/rijrange
              if (ixd .lt. 10) ixd=ixd+1
              n10(ixd)=n10(ixd)+1
              if (rmsd2d(i,j) .eq. 0.0) nz=nz+1
            end do
          end do
          write (6,1007) n10
          if (nz .gt. 0) then
            write (6,1008) nz
            call askyn('Do you want a list of identical pairs',37,
         -    1,-1,ilistdup,0,0)
            if (ilistdup .gt. 0) then
              do i=1,n
                do j=1,i-1
                  if (rmsd2d(i,j) .eq. 0.0) then
                    call lastchar(label(i),lci,500)
                    call lastchar(label(j),lcj,500)
                    if (lci .eq. lcj) then
                      if (label(i)(1:lci) .eq. label(j)(1:lcj)) then
                        write (6,1009) i,label(i)(1:lci),j,label(j)(1:lcj)
                      end if
                    end if
                  end if
                end do
              end do
            end if
          end if
          return
    666   print *,' ERROR: invalid matrix dimension:'
          rewind iw0
          read (iw0,2000,end=999) line
          print *,line(1:20)
          stop
    777   print *,' ERROR: invalid sequence number for item ',i,':',
         -  line(ic1:ic-1)
          stop
    888   print *,' ERROR: invalid number read for item ',i
          stop
    999   print *,' ERROR: matrix input ended unexpectedly'
          stop
    1001  format(' Symmetry ERROR: R[',i5,',',i5,']=',f10.5,' and ',
         -  'R[',i5,',',i5,']=',f10.5)
    1002  format(' Range of matrix values: [',f10.5,',',f10.5,']',/,
         -  ' NOTE: if the input matrix entries represent similarities',/,
         -  '       then you have to use one of the (1-r(i,j)) transform',
         -  ' options')
    1003  format(' Distance matrix dimension=',i5,a,/,' Read from file ',a)
    1004  format(' WARNING: label is longer than ',i4,' characters in row',
         -  i6,':',/,1x,a)
    1005  format(' ERROR: Input matrix dimension is non=positive:',i9)
    1006  format(' Transformed distance range: [',f10.5,',',f10.5,']')
    1007  format(' Distribution of the distances:',/,10i7)
    1008  format(' NOTE: there are ',i6,' identical item pairs')
    1009  format(' #',i5,' (',a,') is identical with #',i5,' (',a,')')
    2000  format(a)
          end
          subroutine transform_mat(r,n,nmax,rijrmin,iuout)
          dimension r(nmax,nmax)
          character*1 ans
          common /transform_dist_dat/ itranstyp,nexp,rijmin,fracexp
          fracexp=1.0
          rijmin=rijrmin
          call quiz(ans,itranstyp,'u',' ',0,'transformation type',19,
         -   0,5,6,00)
          if (itranstyp .gt. 1) then
            if (itranstyp .ne. 4) then
              call getint('Exponent',8,1,1,6,nexp,0)
              fracexp=1.0/float(nexp)
            end if
            do i=1,n
              do j=1,i-1
                call transform_dist(r(i,j),r(i,j))
                r(j,i)=r(i,j)
              end do
            end do
            write (iuout,1001)
            if (itranstyp .eq. 2) write (iuout,1002) nexp
            if (itranstyp .eq. 3) write (iuout,1003) nexp
            if (itranstyp .eq. 4) write (iuout,1004)
            if (itranstyp .eq. 5) write (iuout,1005) nexp
            if (itranstyp .eq. 6) write (iuout,1006) nexp
            if (itranstyp .eq. 7) write (iuout,1007) nexp
            if (itranstyp .eq. 8) write (iuout,1008) nexp
            if (itranstyp .eq. 9) write (iuout,1009) nexp
          else
            write (iuout,*) 'Input matrix used as is'
          end if
          return
    1001  format(' Input data trasnformed as')
    1002  format(' r(i,j)=r(i,j)**',i1)
    1003  format(' r(i,j)=r(i,j)**(1/',i1,')')
    1004  format(' r(i,j)=1.0-r(i,j)')
    1005  format(' r(i,j)=(1.0-r(i,j))**',i1)
    1006  format(' r(i,j)=(1.0-r(i,j))**(1/',i1,')')
    1007  format(' r(i,j)=abs(r(i,j)**',i1)
    1008  format(' r(i,j)=(1.0-abs(r(i,j))**',i1)
    1009  format(' r(i,j)=(r(i,j)-min(r(i,j))**',i1)
          end
          subroutine transform_dist(r_read,r_trans)
          common /transform_dist_dat/ itranstyp,nexp,rijmin,fracexp
          if (itranstyp .eq. 1) then
            r_trans=r_read
          else if (itranstyp .eq. 2) then
            r_trans=r_read**nexp
          else if (itranstyp .eq. 3) then
            r_trans=r_read**fracexp
          else if (itranstyp .eq. 4) then
            r_trans=1.0-r_read
          else if (itranstyp .eq. 5) then
            r_trans=(1.0-r_read)**nexp
          else if (itranstyp .eq. 6) then
            r_trans=(1.0-r_read)**fracexp
          else if (itranstyp .eq. 7) then
            r_trans=abs(r_read)**nexp
          else if (itranstyp .eq. 8) then
            r_trans=(1.0-abs(r_read))**nexp
          else if (itranstyp .eq. 9) then
            r_trans=(r_read-rijmin)**nexp
          end if
          return
          end
          subroutine read_2drmsd(iw0,system,lsystem,trajname,ltrajname,
         -  trajname2,ltrajname2,ifirst,ilast,incr,ifirst2,ilast2,
         -  incr2,isym,rmsdmn,rmsdmx,nframeread,nframex,nframey,
         -  ietotsaved,maxecho,limresrange,ierr)
          character*(*) trajname,trajname2,system
          parameter (MAXFRAMES=50000,MAXCOPY=600)
          parameter (MAXCOPY1=MAXCOPY-1)
          common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
         -  increment,increment2,res(2,MAXFRAMES,MAXCOPY1),
         -  xyplot(2,MAXFRAMES),x0(MAXCOPY),y0(MAXCOPY),nxselres,
         -  ixselres(MAXCOPY)
          parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
          parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
         -  (4*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
          common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),ing(MAX2D,MAX2D),
         -  ihbpair(2,MAXBONDS),a1(MAXBONDS),a2(MAXBONDS),fill(IFILL2)
          character*16 errlab
          character*80 line
          ierr=1
          limresrange=1
          nline=0
          rmsdmn=1000000.0
          ltrajname2=0
          if (isym .eq. 1) rmsdmn=0.0
          rmsdmx=0.0
          nframex=0
          nframey=0
          call blankout(errlab,1,16)
          do while (.true.)
            call blankout(line,1,80)
            read (iw0,1000,end=999) line
            nline=nline+1
            if (line(1:9) .eq. ' Config #') then
              errlab='structure number'
              read (line(11:15),*,err=888) ix
              read (line(43:47),*,err=888) jx
              if (ix .gt. nframex) nframex=ix
              if (jx .gt. nframey) nframey=jx
              read (iw0,1000,end=999) line
              errlab='RMSD'
              read (line(21:28),*,err=888) rmsd2d(ix,jx)
              if (rmsd2d(ix,jx) .gt. rmsdmx) rmsdmx=rmsd2d(ix,jx)
              if (rmsd2d(ix,jx) .lt. rmsdmn) rmsdmn=rmsd2d(ix,jx)
              if (isym .eq. 1) rmsd2d(jx,ix)=rmsd2d(ix,jx)
              if (line(51:53) .eq. 'Ec=') then
                errlab='energy'
                read (line(64:77),*,err=888) res(1,ix,11)
                ietotsaved=1
              end if
              nline=nline+1
              lc=2
              do while (lc .gt. 1)
                call blankout(line,1,80)
                read (iw0,1000,end=999) line
                call lastchar(line,lc,80)
                nline=nline+1
              end do
            else if (line(1:33) .eq. ' Second trajectory file analyzed:')
         -           then
              call lastchar(line,icl,80)
              ltrajname2=icl-33
              trajname2(1:ltrajname2)=line(34:33+ltrajname2)
              nline=nline+1
              print *,'Second trajectory: ',trajname2(1:ltrajname2)
            else if (line(1:26) .eq. ' Trajectory file analyzed:') then
              call lastchar(line,icl,80)
              ltrajname=icl-26
              trajname(1:ltrajname)=line(27:26+ltrajname)
              nline=nline+1
              print *,'Trajectory: ',trajname(1:ltrajname)
            else if (line(1:47) .eq.
         -    ' Trajectory first and last frame and increment:') then
              read (line(48:68),1001,end=777,err=777) ifirst,ilast,incr
              call save_traj_lim(ifirst,ilast,incr,1)
             else if (line(1:54) .eq.
         -    ' Second trajectory first and last frame and increment:') then
              read (line(55:75),1001,end=777,err=777) ifirst2,ilast2,incr2
              call save_traj_lim(ifirst2,ilast2,incr2,2)
            else if (line(1:27) .eq. ' Number of frames analyzed=') then
              call lastchar(line,icl,80)
              errlab='number of frames'
              read (line(28:icl),*,err=888) nframeread
              nline=nline+1
              print *,'Number of structures analyzed=',nframeread
              go to 100
            else if (line(1:8) .eq. ' System:') then
              call blankout(line,1,80)
              read (iw0,1000,end=999) line
              call lastchar(line,lsystem,80)
              system(1:lsystem)=line(1:lsystem)
              nline=nline+2
              print *,'System:',system(1:lsystem)
            else if (line(1:28) .eq. ' All atoms are used for RMSD') then
              limresrange=0
            end if
          end do
    100   if (ltrajname2 .gt. 0) then
            do i=1,min0(maxecho,nframex)
              write (iw0,2000) i,(rmsd2d(i,j),j=1,nframey)
            end do
          else
            do i=2,min0(maxecho,nframeread)
              write (iw0,2000) i,(rmsd2d(j,i),j=1,i-1)
            end do
            nframex=max0(nframex,nframey)
            nframey=max0(nframex,nframey)
          end if
          write (6,2001) nframex,nframey
          ierr=0
          return
    777   print *,'ERROR: invalid frame limits:'
          print *,line
          return
    888   print *,'ERROR: invalid input for ',errlab,':'
          print *,line
          return
    999   print *,'ERROR: 2D RMSD file ended prematurely at line #',nline
          return
    1000  format(a)
    1001  format(3i7)
    2000  format(' RMSD(',i4,'):',10f6.1,/,(12x,10f6.1))
    2001  format(' Matrix of ',i6,' rows and ',i6,' columns read')
          end
          subroutine matchtraj(rmsdsim,iw0)
          parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
          parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
         -  (4*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
          common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),ing(MAX2D,MAX2D),
         -  ihbpair(2,MAXBONDS),a1(MAXBONDS),a2(MAXBONDS),fill(IFILL2)
          parameter (MAXFRAMES=50000,MAXCOPY=600)
          common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
         -  increment,increment2,res(2,MAXFRAMES,MAXCOPY),
         -  x0(MAXCOPY),y0(MAXCOPY),nxselres,ixselres(MAXCOPY)
          dimension nsame1(MAX2D),nsame2(MAX2D)
          character*6 lab
          nframe1=nframeref
          nframe2=nframe
          call zeroiti(nsame1,0,nframe1)
          call zeroiti(nsame2,0,nframe2)
          rmsdmin=100000.0
          do if=1,nframe1
            rmsdmini=100000.0
            do jf=1,nframe2
              if (rmsdmini .gt. rmsd2d(if,jf)) then
                rmsdmini=rmsd2d(if,jf)
                jmin=jf
              end if
              if (rmsdsim .gt. rmsd2d(if,jf)) then
                nsame1(if)=nsame1(if)+1
              end if
            end do
            a1(if)=jmin
            if (rmsdmin .gt. rmsdmini) then
              rmsdmin=rmsdmini
              igmin=if
              jgmin=jmin
            end if
          end do
          do jf=1,nframe2
            rmsdminj=100000.0
            do if=1,nframe1
              if (rmsdminj .gt. rmsd2d(if,jf)) then
                rmsdminj=rmsd2d(if,jf)
                imin=if
              end if
              if (rmsdsim .gt. rmsd2d(if,jf)) then
                nsame2(jf)=nsame2(jf)+1
              end if
            end do
            a2(jf)=imin
          end do
          write (iw0,1004) 2,1
          do if=1,nframe1
            jmin=a1(if)
            minrev1=a2(jmin)
            lab='      '
            if (minrev1 .eq. if) lab='mutual'
            if (rmsdsim .eq. 0) then
              write (iw0,1000) 1,if,2,jmin,rmsd2d(if,jmin),lab
            else
              write (iw0,1003) 1,if,rmsdsim,nsame1(if),jmin,
         -      rmsd2d(if,jmin),lab
            end if
          end do
          write (iw0,1004) 1,2
          do jf=1,nframe2
            imin=a2(jf)
            minrev2=a1(imin)
            lab='      '
            if (minrev2 .eq. jf) lab='mutual'
            if (rmsdsim .eq. 0) then
              write (iw0,1000) 2,jf,1,imin,rmsd2d(imin,jf),lab
            else
              write (iw0,1003) 2,jf,rmsdsim,nsame2(jf),imin,
         -      rmsd2d(imin,jf),lab
            end if
          end do
          write (iw0,1001) igmin,jgmin,rmsdmin
          return
    1000  format(' Traj',i2,' frame',i5,' closest from traj',i2,' is frame',
         -  i5,' RMSD=',f10.1,1x,a)
    1001  format(' Best match is between traj 1, frame',i5,' traj 2, frame',
         -  i5,' RMSD=',f10.1)
    1003  format(' Tr',i2,' Fr',i5,' N(<',f4.1,')=',i2,' closest:',i5,
         -  ' RMSD=',f5.1,1x,a)
    1004  format(' Matching Trajectory',i2,' frames to Trajectory',i2,
         -  ' frames')
          end
          subroutine rmsd(co,c,n,nfinalov,nfinalrmsd,atw,atwsum,atw1,c1,
         -  c2,indxov1,indxov2,noopt2d,isymm,indxrmsd1,indxrmsd2,rot,com1,
         -  com2,etot,etot2,iout,devmax,devmaxnoopt,maxat)
          dimension co(3,n),c(3,n),atw(n),atw1(n),c1(3,n),c2(3,n),
         -  indxov1(n),indxov2(n),indxrmsd1(n),indxrmsd2(n),rot(3,3),
         -  com1(3),com2(3)
          real*8 atwsum
          character*2 iatnm2
          common /atnam/ aw(99),nval(99),nvalmax(99),mmofan(99),
         -  mmatno(64),iatnm2(99)
          parameter (MAXFRAMES=50000,MAXCOPY=600)
          common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
         -  increment,increment2,res(2,MAXFRAMES,MAXCOPY),
         -  x0(MAXCOPY),y0(MAXCOPY),nxselres,ixselres(MAXCOPY)
          parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
          parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
         -  (4*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
          common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),ing(MAX2D,MAX2D),
         -  ihbpair(2,MAXBONDS),a1(MAXBONDS),a2(MAXBONDS),fill(IFILL2)
          sdnoopt=sqrt(sdsum(nfinalrmsd,co,c,atw,indxrmsd1,indxrmsd2,
         -  devmaxnoopt,maxat))
          if (noopt2d .eq. 0) then
            call bestoverlay(nfinalov,indxov1,indxov2,co,c,atw,atwsum,c1,c2,
         -    atw1,rot,com1,com2,00,0.001,iout,maxat)
            call shiftmol(co,n,com1,c1,-1.0)
            call shiftmol(c,n,com2,c2,-1.0)
            call rotate_c(c2,n,rot,c2,'RMSD',4)
            sd=sqrt(sdsum(nfinalrmsd,c1,c2,atw,indxrmsd1,indxrmsd2,devmax,
         -    maxat))
          else
            devmax=devmaxnoopt
          end if
          call trajlimtest(nframe,MAXFRAMES)
          if (etot .eq. 0.0) then
            if (noopt2d .eq. 0)
         -    write (iout,1001) 'Best overlap:',sd,devmax
            write (iout,1001) 'No   overlap:',sdnoopt,devmaxnoopt
          else
            if (noopt2d .eq. 0) then
              write (iout,1001) 'Best overlap:',sd,devmax,' ','c',etot
              write (iout,1001) 'No   overlap:',sdnoopt,devmaxnoopt,' ',
         -      'r',etot2
            else
              write (iout,1001) 'No   overlap:',sdnoopt,devmaxnoopt,' ',
         -      'c',etot
            end if
            res(1,nframe,9)=etot
          end if
          if (nframeref .le. 1) then
            res(1,nframe,7)=sd
            res(2,nframe,7)=devmax
            res(1,nframe,8)=sdnoopt
            res(2,nframe,8)=devmaxnoopt
          end if
          if (nframeref .gt. 0) then
            if (noopt2d .eq. 0) then
              rmsd2d(nframe,nframeref)=sd
              if (isymm .eq. 1) rmsd2d(nframeref,nframe)=sd
            else
              rmsd2d(nframe,nframeref)=sdnoopt
              if (isymm .eq. 1) rmsd2d(nframeref,nframe)=sdnoopt
            end if
          end if
          return
    1001  format(1x,a,' RMSD=',f8.3,' Max dev=',f10.3,' A',
         -  a,'E',a1,'=',e14.7)
          end
          subroutine rmsf(cref,c,atw,nslt,ixres,index,bfacavg,nresslt,
         -  maxat)
          dimension cref(3,maxat),c(3,maxat),atw(maxat),ixres(maxat),
         -  index(maxat)
          real*8 bfacavg(nresslt)
          ia=1
          ir=ixres(index(ia))
          do while (ia .le. nslt)
            rmsfs=0.0
            atwrsum=0.0
            do while (ir .eq. ixres(index(ia)))
              iaa=index(ia)
              dev2=0
              do k=1,3
                dev2=dev2+(c(k,iaa)-cref(k,iaa))**2
              end do
              rmsfs=rmsfs+atw(iaa)*dev2
              atwrsum=atwrsum+atw(iaa)
              ia=ia+1
              if (ia .gt. nslt) go to 100
              if (index(ia) .eq. 0) print *,'INDEX(',ia,')=0 !!'
            end do
    100     continue
            bfacavg(ir)=bfacavg(ir)+rmsfs/atwrsum
            if (ia .le. nslt) ir=ixres(index(ia))
          end do
          return
          end
          subroutine rmsf_av(cdp,cdp2,atw,n,index,ixres,rmsfsum,rmsfav,
         -  nframe,nslt,nresslt)
          real*8 cdp(3,n),cdp2(3,n),rmsfsum(nresslt)
          dimension atw(nslt),index(n),ixres(nslt),rmsfav(nresslt)
          real*8 atwrsum
          call zeroitd(rmsfsum,nresslt)
          ia=1
          ir=ixres(index(ia))
          do while (ia .le. n)
            rmsfs=0.0
            atwrsum=0.d0
            do while (ir .eq. ixres(index(ia)))
              atwrsum=atwrsum+atw(index(ia))
              do k=1,3
                rmsfsum(ir)=rmsfsum(ir)+
         -        atw(index(ia))*(cdp2(k,ia)/nframe-(cdp(k,ia)/nframe)**2)
              end do
              ia=ia+1
              if (ia .gt. n) go to 100
            end do
    100     continue
            rmsfav(ir)=dsqrt(rmsfsum(ir)/atwrsum)
            if (ia .le. n) ir=ixres(index(ia))
          end do
          return
          end
          subroutine celldipole(c,n,nslt,index,nats,q,icharges,aw,iout,
         -  itraj)
          dimension c(3,n),index(n),q(n),aw(n)
          parameter (MAXFRAMES=50000,MAXCOPY=600)
          common /analres/ nframe,nframeref,nframetot,maxframe,maxpres,
         -  increment,increment2,res(2,MAXFRAMES,MAXCOPY),
         -  x0(MAXCOPY),y0(MAXCOPY),nxselres,ixselres(MAXCOPY)
          real*8 dipole(3),com(3),awsum
          dimension dipslt(3),dipslv(3),diptot(3)
          call trajlimtest(nframe,MAXFRAMES)
          call zeroitd(dipole,3)
          call zeroitd(com,3)
          awsum=0.d0
          do ia=1,nats
            do k=1,3
              if (icharges .gt. 0)
         -      dipole(k)=dipole(k)+c(k,index(ia))*q(index(ia))
                com(k)=com(k)+c(k,index(ia))*aw(index(ia))
            end do
            awsum=awsum+aw(index(ia))
          end do
          do k=1,3
            if (icharges .gt. 0) dipslt(k)=dipole(k)
            com(k)=com(k)/awsum
          end do
          if (iout .gt. 0) write (iout,1003) com
          if (itraj .gt. 0) then
            res(2,nframe,14)=com(1)
            res(1,nframe,15)=com(2)
            res(2,nframe,15)=com(3)
          end if
          if (icharges .eq. 0) return
          dipsltabs=sqrt(dipslt(1)**2+dipslt(2)**2+dipslt(3)**2)
          call zeroitd(dipole,3)
          do ia=nslt+1,n
            do k=1,3
              dipole(k)=dipole(k)+c(k,ia)*q(ia)
            end do
          end do
          do k=1,3
            dipslv(k)=dipole(k)
          end do
          dipslvabs=sqrt(dipslv(1)**2+dipslv(2)**2+dipslv(3)**2)
          do ia=1,nslt
            do k=1,3
              dipole(k)=dipole(k)+c(k,index(ia))*q(index(ia))
            end do
          end do
          diptotabs=sqrt(diptot(1)**2+diptot(2)**2+diptot(3)**2)
          if (iout .ne. 0) then
            write (iout,1000) dipsltabs
            if (n .gt. nslt) write (iout,1001) dipslvabs,diptotabs
            write (iout,1002) 'solute ',dipslt
            if (n .gt. nslt) then
              write (iout,1002) 'solvent',dipslv
              write (iout,1002) 'cell   ',diptot
            end if
          end if
          if (itraj .gt. 0) then
            res(1,nframe,10)=diptotabs
            res(2,nframe,10)=dipsltabs
            res(1,nframe,11)=diptot(1)
            res(2,nframe,11)=diptot(2)
            res(1,nframe,12)=diptot(3)
            res(1,nframe,13)=dipslt(1)
            res(2,nframe,13)=dipslt(2)
            res(1,nframe,14)=dipslt(3)
          end if
          return
    1000  format(' Dipole moment of the solute=',f10.3)
    1001  format(' Dipole moment of the solvents=',f10.3,
         -  ' total=',f10.3,' au*A')
    1002  format(' Dipole moment vector of ',a,'=',3f10.3,' au*A')
    1003  format(' Center-of-mass=',3f10.4,' A')
          end
          subroutine clusterdistr(ndim,iout,rdlim,rdmin,rdmax,nhbdist,
         -  it1,it2,it3,it4,ifclst,ilclst,nrdclust,indexa,index2d,ixclst,
         -  it2d,value,ifa_s,ila_s,ih,cv,rdclustdef,rdclust,etotsaved,
         -  ietotsaved,label,llabel,isorttype,ifindbestrep,irepav,irepmx,
         -  irepeng,irepkm,engcl,c,cent,cent_prev,maxct,ihelp,iclstyp,
         -  iwt,nomemprint,label2d,llabel2d,ilabel2d,idistp,nosortindex2d,
         -  iuseindex2d,mx2d,maxframe)
          dimension rdlim(mx2d),nhbdist(mx2d),it1(mx2d),it2(mx2d),
         -  it3(mx2d),it4(mx2d),ifclst(mx2d),ilclst(mx2d),ixclst(mx2d),
         -  it2d(mx2d),index2d(mx2d),indexa(mx2d),value(mx2d),ifa_s(mx2d),
         -  ila_s(mx2d),ih(mx2d),irepav(mx2d),irepmx(mx2d),iwt(mx2d),
         -  cv(mx2d),etotsaved(2,maxframe),irepeng(mx2d),irepkm(mx2d),
         -  engcl(mx2d),c(3,ndim),cent(3,maxct),cent_prev(3,maxct)
          character*(*) label
          character*(*) label2d(mx2d)
          parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
          dimension cutofflist(5),imemcut(MAX2D,5),ifcl_prev(MAX2D),
         -  ilcl_prev(MAX2D),icent_fin(MAX2D)
          character*18 memlab
          character*200 memdir,memfilename
          character*500 line
          character*1 ans
          character*41 clstyp
          common /cluster_typ/ nclstyp,inumclst(9),ireadcutoff(9),
         -  lclstyp(9),clstyp(9)
          data iu_clst /60/
          idistprint=idistp
          nrdclust=0
          irepeng(1)=0
          nnmin=0
          idenclstyp=0
          if (rdmax .le. 0.0) then
            print *,'ERROR: largest distance is nonpositive:',rdmax
            return
          end if
          iclstyp=1
    8910  call quiz(ans,iclstyp,' ',' ',0,'clustering algorithm',20,
         -  0,5,6,40)
          if (ans .eq. 'q') then
            if (nrdclust .eq. 0) then
              print *,'NOTE: no clustering was done'
              call askyn('No clustering was done - still want to quit',43,
         -      1,1,iquit,130,0)
              if (iquit .eq. 0) go to 8910
            end if
            return
          end if
          if (maxct .le. 1 .and. iclstyp .eq. 5) then
            write (6,*)
         -   'COM as cluster center only applies to clustering atoms'
            go to 8910
          end if
          write (iout,2060) clstyp(iclstyp),ndim
          write (6,2060) clstyp(iclstyp),ndim
          if (iclstyp .ne. 4) call zeroiti(irepkm,0,ndim)
          if (inumclst(iclstyp) .eq. 1) then
            call getint('Number of clusters requested',28,999999,1,ndim,
         -    nrdclust,ihelp)
            rdclust=0.0
            write (iout,2061) nrdclust
          else if (ireadcutoff(iclstyp) .eq. 1) then
            write (line,1014) label(1:llabel)
            call getreal(line,22+llabel,rdclustdef,rdclust,1,ihelp)
            nhbcorrclust=1
          end if
          if (iclstyp .eq. 9) then
            call quiz(ans,idenclstyp,' ',' ',0,'density clustering variant',
         -    26,0,5,6,141)
            if (idenclstyp .lt. 2) call getint(
         -    'Minimum number of common neighbors',34,999999,1,ndim,nnmin,
         -    000)
            if (idenclstyp .eq. 3) call getint(
         -    'Minimum number of individual neighbors',38,999999,1,ndim,
         -    nnmin,000)
          end if
          write (iout,2062)
          if (iclstyp .ne. 3 .and. idistprint .ge. 0)
         -  call askyn('Do you want to print all cluster-cluster distances',
         -    50,1, -1,idistprint,130,0)
          call zeroit(rdlim,ndim)
          rdlim(1)=rdmax
          rdlim(ndim)=rdmin
          if (rdlim(ndim) .eq. 0.0) rdlim(ndim)=0.000001
          call trnsfi(it2d,index2d,ndim)
          if (iclstyp .eq. 1 .or. iclstyp .eq. 4 .or. iclstyp .eq. 5 .or.
         -    iclstyp .eq. 6 .or. iclstyp .eq. 8 .or. iclstyp .eq. 9) then
            if (ans .ne. 'k')
         -    write (iout,2092) label(1:llabel),rdclust
            call rmsdcluster(rdclust,1,ndim,index2d,iwt,ixclst,ifclst,
         -    ilclst,it1,it2,it3,irepav,irepmx,it4,c,cent,cent_prev,irepkm,
         -    maxct,iclstyp,idenclstyp,nnmin,nrdclust,nosortindex2d,
         -    iuseindex2d,ifail,1,label,llabel,iout)
            if (ifail .gt. 0) go to 8910
            nclust=nrdclust
            if (ans .ne. 'k') write (6,2090) label(1:llabel),rdclust,nclust
            call reportclust(ndim,0,1,nclust,ifclst,ilclst,index2d,value,
         -    it1,ifa_s,ila_s,ih,cv,indexa,irepav,irepmx,irepeng,irepkm,
         -    engcl,nhbdist,etotsaved,ietotsaved,ifindbestrep,label,llabel,
         -    isorttype,idistprint,nomemprint,iout,maxframe,mx2d)
          else if (iclstyp .eq. 2 .or. iclstyp .eq. 7) then
            write (6,2093) nrdclust,rdmin,rdmax
            write (iout,2093) nrdclust,rdmin,rdmax
            call zeroiti(indexa,0,ndim)
            nclust=1
            rdmn=rdmin
            rdmx=rdmax
            nclmx=nrdclust
            do while (rdlim(nclmx) .eq. 0.0)
              nclmx=nclmx-1
            end do
            rdmx=rdlim(nclmx)
            nclmn=nrdclust
            do while (rdlim(nclmn) .eq. 0.0)
              nclmn=nclmn+1
            end do
            rdmn=rdlim(nclmn)
            ntry=0
            call trnsfi(it4,index2d,ndim)
            do while (nclust .ne. nrdclust .and. ntry .le. ndim)
              call trnsfi(index2d,it4,ndim)
              rdclust=(rdmn+rdmx)/2.0
              call rmsdcluster(rdclust,1,ndim,index2d,iwt,ixclst,ifclst,
         -      ilclst,it1,it2,it3,irepav,irepmx,it4,c,cent,cent_prev,
         -      icent_fin,maxct,iclstyp,idenclstyp,nnmin,nclust,
         -      nosortindex2d,iuseindex2d,ifail,ntry,label,llabel,iout)
              if (ifail .gt. 0) go to 8910
              if (nclust .lt. nrdclust) rdmx=rdclust
              if (nclust .gt. nrdclust) rdmn=rdclust
              write (6,2090) label(1:llabel),rdclust,nclust
              write (iout,2090) label(1:llabel),rdclust,nclust
              if (indexa(nclust) .gt. 25) then
                write (iout,2094) nrdclust,nclust
                write (6,2094) nrdclust,nclust
                nrdclust=nclust
                ntry=ndim
              end if
              indexa(nclust)=indexa(nclust)+1
              rdlim(nclust)=rdclust
              ntry=ntry+1
            end do
            write (iout,2066) label(1:llabel),nclust,rdclust
            write (6,2066) label(1:llabel),nclust,rdclust
            if (nclust .ne. nrdclust) then
              write (iout,2094) nrdclust,nclust
              write (6,2094) nrdclust,nclust
              nrdclust=nclust
            end if
            call reportclust(ndim,0,1,nclust,ifclst,ilclst,index2d,value,
         -    it1,ifa_s,ila_s,ih,cv,indexa,irepav,irepmx,irepeng,irepkm,
         -    engcl,nhbdist,etotsaved,ietotsaved,ifindbestrep,label,llabel,
         -    isorttype,idistprint,nomemprint,iout,maxframe,mx2d)
          else if (iclstyp .eq. 3) then
    100     call getint('Number of cutoffs',17,5,1,5,ncutoff,00)
            if (ncutoff .le. 1) go to 100
            call askyn('Do you want uniformly spaced cutoffs',36,1,1,
         -    iunif,0,0)
            if (iunif .eq. 1) then
              call transform_dist(rdmin,rdtmin)
              call transform_dist(rdmax,rdtmax)
              if (rdtmin .lt. rdtmax) then
                call getreal('Largest cutoff',14,rdtmax,rcutulim,1,00)
                call getreal('Smallest cutoff',15,rdtmin,rcutllim,1,00)
              else
                call getreal('Largest cutoff',14,rdtmin,rcutulim,1,00)
                call getreal('Smallest cutoff',15,rdtmax,rcutllim,1,00)
              end if
              do icut=1,ncutoff
                cutofflist(icut)=
         -        rcutulim-(icut-1)*(rcutulim-rcutllim)/(ncutoff-1)
              end do
            else
              print *,'Specify the cutoffs (in decreasing order)'
              rcutprev=rdmax+1.0
              do icut=1,ncutoff
    110         write (line(1:11),1015) icut
                call getreal(line,11,999999.0,cutofflist(icut),1,00)
                if (cutofflist(icut) .ge. rdmax) then
                  print *,'Cutoff read exceeds the largest distance'
                  go to 110
                else if (cutofflist(icut) .ge. rcutprev) then
                  print *,'Cutoffs need to be in decreasing order'
                  go to 110
                end if
                rcutprev=cutofflist(icut)
              end do
            end if
            write (6,1016) (cutofflist(icut),icut=1,ncutoff)
            write (iout,*) 'Hierarchical clustering with multiple cutoffs'
            write (iout,1016) (cutofflist(icut),icut=1,ncutoff)
            call getint('Cluster level to calculate average',34,ncutoff,1,
         -    ncutoff,lev_avg,00)
            call askyn('Do you want to write cluster member files',41,1,-1,
         -    memfiles,129,0)
            if (memfiles .eq. 1) then
    111       call getname(memdir,lmemdir,'Name of the directory to write',
         -      30,60,'',0,0,0,0)
              call checkdir(memdir,lmemdir,iu_clst,iopen)
              if (iopen .gt. 0) then
                write (6,1024) memdir(1:lmemdir)
                go to 111
              end if
              memdir(lmemdir+1:lmemdir+2)='/C'
              lmemdir=lmemdir+2
              memfilename=memdir
            end if
            write (iout,1023) lev_avg
            ifcl_prev(1)=1
            ilcl_prev(1)=ndim
            ncl_prev=1
            call indexit(index2d,1,ndim,0)
            write (iout,1019)
            do icut=1,ncutoff
              ncltot=0
              do icl=1,ncl_prev
                call rmsdcluster(cutofflist(icut),ifcl_prev(icl),
         -        ilcl_prev(icl),index2d,iwt,ixclst,ifclst(ncltot+1),
         -        ilclst(ncltot+1),it1,it2,it3,irepav,irepmx,it4,c,cent,
         -        cent_prev,icent_fin,maxct,iclstyp,idenclstyp,nnmin,nclust,
         -        nosortindex2d,iuseindex2d,ifail,1,label,llabel,iout)
                if (ifail .gt. 0) go to 8910
                do ic=ncltot+1,ncltot+nclust
                  do ia=ifclst(ic),ilclst(ic)
                    imemcut(index2d(ia),icut)=ic-ncltot
                  end do
                end do
                ncltot=ncltot+nclust
              end do
              call trnsfi(ifcl_prev,ifclst,ncltot)
              call trnsfi(ilcl_prev,ilclst,ncltot)
              ncl_prev=ncltot
            end do
            iranksum=0
            nsum=0
            irank_rep=ndim+1
            ia_rep=0
            ia_start=1
            do ia=1,ndim
              write (line,1017) ia,index2d(ia),
         -      (imemcut(index2d(ia),lev),lev=1,ncutoff)
              len=18+5*ncutoff
              line(len+1:len+1)=' '
              len=len+1
              rankav=0.0
              if (ia .eq. ndim) then
                if (nsum .gt. 0) rankav=float(iranksum)/float(nsum)
                iend=1
              else
                iend=0
                do lev=1,lev_avg
                  if (imemcut(index2d(ia+1),lev) .ne.
         -            imemcut(index2d(ia),lev)) iend=1
                end do
                if (index2d(ia) .lt. irank_rep) then
                  irank_rep=index2d(ia)
                  ia_rep=ia
                end if
                if (iend .eq. 1) then
                  if (nsum .gt. 0)
         -          rankav=float(iranksum+index2d(ia))/float(nsum+1)
                  iranksum=0
                  nsum=0
                  irank_rep=ndim+1
                else
                  iranksum=iranksum+index2d(ia)
                  nsum=nsum+1
                end if
              end if
              if (ilabel2d .gt. 0) then
                call lastchar(label2d(index2d(ia)),lc,llabel2d)
                line(len+1:len+lc)=label2d(index2d(ia))(1:lc)
                len=len+lc
              end if
              if (memfiles .eq. 1 .and. iend .eq. 1) then
                lmemfilename=lmemdir
                do lev=1,lev_avg
                  call writeint(memfilename,lmemfilename+1,
         -          imemcut(index2d(ia),lev),ndig)
                  lmemfilename=lmemfilename+ndig+1
                  memfilename(lmemfilename:lmemfilename)='.'
                end do
                memfilename(lmemfilename+1:lmemfilename+4)='clst'
                lmemfilename=lmemfilename+4
                open(unit=iu_clst,form='formatted',status='new',
         -        file=memfilename(1:lmemfilename),iostat=iopen)
                if (iopen .eq. 0) then
                  do imem=ia_start,ia
                    call lastchar(label2d(index2d(imem)),lc,llabel2d)
                    write (iu_clst,1000) label2d(index2d(imem))(1:lc),
         -            index2d(imem)
                  end do
                  close (iu_clst)
                else
                  write (6,*) 'ERROR: could not open ',
         -          memfilename(1:lmemfilename)
                   write (6,*) 'lmemfilename=',lmemfilename
                end if
                if (iend .eq. 1) ia_start=ia+1
              end if
              if (rankav .gt. 0.0) then
                write (line(len+1:len+18),1010) rankav
                len=len+13
                call laststring(label2d(index2d(ia_rep)),ifc,ilc,lc,500)
                write (line(len+1:len+ilc-ifc+7),1022)
         -        label2d(index2d(ia_rep))(ifc:ilc)
                len=len+ilc-ifc+7
              else if (iend .eq. 1) then
                write (line(len+1:len+10),1025) index2d(ia_rep)
                len=len+10
              end if
              write (iout,1018) line(1:len)
            end do
            return
          end if
          isubcl=0
          if (nclust .lt. ndim .and. iclstyp .eq. 1) then
            call askyn('Do you want to try sub clustering',33,1,-1,isubcl,
         -    29,0)
            if (isubcl .gt. 0) then
              call quiz(ans,isubclustertyp,' ',' ',0,
         -      'subclustering algorithm',23,0,5,6,78)
              call getint('Minimum number of members for subclustering',43,
         -      999999,1,ndim,minsubclust,30)
              write (iout,1011) minsubclust
              if (isubclustertyp .eq. 1) then
                write (iout,1012)
              else if (isubclustertyp .eq. 2) then
                call getreal(
         -        'Maximum percent of density for being on the surface',51,
         -        20.0,surfacepercent,1,79)
                surfacefract=surfacepercent/100.0
                call getreal(
         -        'Distance exponent for local density descriptor',46,
         -        2.0,denexp,0,81)
                denexphalf=denexp/2.0
                write (iout,1013) surfacepercent,denexp
              end if
              do ic=nclust,1,-1
                if (ilclst(ic)-ifclst(ic) .gt. minsubclust) then
                  call rmsdsubcluster(ic,ifclst(ic),ilclst(ic),index2d,
         -          ixclst,ifa_s,ila_s,rdclust,isubclustertyp,
         -          surfacefract,denexphalf,it1,it2,indexa,ih,it4,value,
         -          cv,iout,nclustic,label,llabel)
                  if (nclustic .gt. 1) then
                    write (iout,2065) ic,nclustic
                    write (6,2065) ic,nclustic
                    do icc=nclust,ic+1,-1
                      ifclst(icc)=ifclst(icc-(nclustic-1))
                      ilclst(icc)=ilclst(icc-(nclustic-1))
                    end do
                    do icc=1,nclustic
                      ifclst(ic+icc-1)=ifa_s(icc)
                      ilclst(ic+icc-1)=ila_s(icc)
                    end do
                    call sortlist(iout,index2d,ilclst(nclust),it1,it2,'IX2',
         -            1,mx2d)
                    call reportclust(ndim,ic,ic,ic+nclustic-1,ifclst,ilclst,
         -            index2d,value,it1,ifa_s,ila_s,ih,cv,indexa,irepav,
         -            irepmx,irepeng,irepkm,engcl,nhbdist,etotsaved,
         -            ietotsaved,ifindbestrep,label,llabel,isorttype,
         -            idistprint,nomemprint,iout,maxframe,mx2d)
                    print *,'ic=',ic,' IREPMX=',irepmx(ic)
                  else
                    write  (iout,*) 'None of the clusters split up'
                    write  (6,*) 'None of the clusters split up'
                  end if
                end if
              end do
            end if
          end if
          if (ilabel2d .eq. 1 .and. iclstyp .ne. 3) then
            write (iout,1021)
            do ic=1,nrdclust
              do i=ifclst(ic),ilclst(ic)
                lmemlab=0
                if (i .eq. ifclst(ic)) then
                  memlab(1:6)=' FIRST'
                  lmemlab=6
                end if
                if (ixclst(i) .eq. irepav(ic)) then
                  memlab(lmemlab+1:lmemlab+6)=' AVMIN'
                  lmemlab=lmemlab+6
                end if
                if (ixclst(i) .eq. irepmx(ic)) then
                  memlab(lmemlab+1:lmemlab+6)=' MXMIN'
                  lmemlab=lmemlab+6
                end if
                call lastchar(label2d(ixclst(i)),llab,llabel2d)
                write (iout,1020) ic,ixclst(i),label2d(ixclst(i))(1:llab),
         -        memlab(1:lmemlab)
              end do
            end do
          end if
          if (ietotsaved .gt. 0) then
            call askyn(
         -    'Do you want a histogram of cluster member energies',50,1,-1,
         -    ihiste,0,0)
            if (ihiste .gt. 0)
         -    call getreal('Histogram bin size',18,1.0,rbin,1,000)
            call askyn(
         -    'Do you want to list the energies of the cluster members',55,
         -    1,-1,iliste,0,0)
            if (ihiste+iliste .gt. 0) then
              do ic=1,nclust
                do i=ifclst(ic),ilclst(ic)
                  cv(i-ifclst(ic)+1)=etotsaved(1,index2d(i))
                end do
                nmem=ilclst(ic)-ifclst(ic)+1
                if (iliste .gt. 0) write (iout,1026) ic,(cv(i),i=1,nmem)
                if (ihiste .gt. 0) call histogram(cv,nmem,0.0,rbin,
         -        'cluster energies',16,it1,iout,mx2d)
              end do
            end if
          end if
          call askyn('Do you want to run more clustering',34,1,-1,
         -  ians,0,0)
          if (ians .eq. 1) then
            call trnsfi(index2d,it2d,ndim)
            go to 8910
          end if
          return
    1000  format(a,i8)
    1010  format(' <R>=',f8.1)
    1011  format(' Subclustering clusters containing at least',i4,
         -  ' members')
    1012  format(' Subclustering ignores members with the ',
         -  'smallest number of neighbors')
    1013  format(' Subclustering ignores members whose local density is ',
         -  'less than ',f5.1,' %',/,' of the maximum local density',/,
         -  ' Local density is the sum of 1/rij^',f3.1)
    1014  format(a,' cutoff for clustering')
    1015  format('Cutoff # ',i2)
    1016  format(' Cutoff list: ',5f10.5)
    1017  format(i6,' (',i6,') : ',5(i4,'.'))
    1018  format(1x,a,1x,a)
    1019  format(/,' In the list below, each line corresponds to one ',
         -  'clustered item',/,' For  ( N ) i1. i2. i3. i4. i5., N is the ',
         -  ' original index of this item,'/,' i1 is the cluster number N ',
         -  ' belongs to, obtained with cutoff #1; ',/,' i2 is the ',
         -  'cluster number of N within cluster i1, obtained with cutoff ',
         -  '#2;',/,' i3 is the cluster number of N within cluster i2, ',
         -  'obtained with cutoff #3; etc.',/
         -  ' <R> is the average rank of the cluster members',/)
    1020  format(' Cluster #',i5,' member #',i5,1x,a,a)
    1021  format(/,' List of cluster member labels read from the distance ',
         -  'matrix file')
    1022  format(' REP: ',a)
    1023  format(' Cluster rank averages and representatives are obtained ',
         -  'at cutoff level',i2)
    1024  format(' Directory ',a,' is not found',/,
         -  ' Create the directory and try again')
    1025  format(' S R=',i5)
    1026  format(' Cluster #',i6,' Energies:',/,(5e12.5))
    2060  format(/,' === Clustering method: ',a,/,
         -  ' Number of items to cluster=',i6)
    2061  format(' Number of clusters requested=',i5)
    2062  format(' Clusters are reported in the order of increasing ',
         -  'average indices (<rank>)')
    2065  format(' Cluster ',i4,' partitioned into',i3,' subclusters')
    2066  format(1x,a,' threshold resulting in ',i3,' clusters=',f6.2)
    2090  format(1x,a,' threshold=',f9.2,' number of clusters=',i4)
    2092  format(' Clustering with ',a,' threshold=',f8.3,' A',/)
    2093  format(' Clustering into ',i4,' sets. Range of RMSDs: [',
         -  f8.2,',',f8.2,']'/)
    2094  format(' Clustering failure: instead of',i4,' clusters',i4,
         -  ' was generated')
          end
          subroutine clusterplot(ips,xtraj,value,ifirst,ilast,ncl,ixclst,
         -  nframe,xtrajlab,lxtrajlab,ipspage,noclose,mx2d)
          dimension xtraj(mx2d),value(mx2d),ifirst(mx2d),ilast(mx2d),
         -  ixclst(mx2d)
          character*(*) xtrajlab
          if (nframe .gt. mx2d) then
            write (6,1000) nframe,mx2d
            return
          end if
          do ic=1,ncl
            do ia=ifirst(ic),ilast(ic)
              if (ixclst(ia) .lt. 1 .or. ixclst(ia) .gt. nframe) then
                print *,'CLUSTER ERROR ic,ia,ixclst(ia)=',ic,ia,ixclst(ia)
              else
                value(ixclst(ia))=ic
              end if
            end do
          end do
          iprt=0
          call plot2fun(ips,1,xtraj,value,value,nframe,0.0,0.0,0,0.0,
         -  1.0,ncl+1,0.0,0.0,0,'Cluster membership',18,' ',0,
         -  xtrajlab,lxtrajlab,'Cluster #',9,' ',0,1,iprt,
         -  6,1,1,0,0,0,0,ipspage,noclose,1,1)
          return
    1000  format(' PROGRAM ERROR in CLUSTERPLOT: nframe (',i8,') > ',
         -  'max2d (',i5,')')
          end
          subroutine rmsdcluster(rmsdclust,nfrst,n,index2d,iwt,iclst,ifirst,
         -  ilast,it1,it2,it3,it4,it5,it6,c,cent,cent_prev,icent_fin,
         -  maxct,iclstyp,idenclstyp,nnmin,nofcls,nosortindex2d,iuseindex2d,
         -  ifail,ntry,label,llabel,iout)
          dimension index2d(n),iwt(n),iclst(n),ifirst(n),ilast(n),it1(n),
         -  it2(n),it3(n),it4(n),it5(n),it6(n),c(3,n),cent(3,maxct),
         -  cent_prev(3,maxct),icent_fin(maxct)
          character*(*) label
          parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
          parameter (IFILL21=MAXPHI*MAXPHI*MAXPHI-
         -  (6*MAXBONDS+2*MAX2D+2*MAX2D*MAX2D))
          common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),ing(MAX2D,MAX2D),
         -  ihbtores(MAXBONDS),nusepair(MAXBONDS),nhb_atot(MAXBONDS),
         -  nhb_rtot(MAXBONDS),t1(MAXBONDS),w(MAXBONDS),nng2r(MAX2D),
         -  fill(IFILL21)
          dimension icent(MAX2D),icent0(MAX2D),index2dd(MAX2D),
         -  iorder(MAXBONDS),t2(MAXBONDS)
          ifail=0
          sdmin=100000.0
          sdmax=0.0
          nz_sd=0
          nofcls_t=0
          if (nfrst .gt. n) then
            print *,'PROGRAM ERROR: nfrst > n - nfrst=',nfrst,' n=',n
            stop
          end if
          if (n .gt. MAXBONDS) then
            write (6,1001)
            stop
          end if
          if (nfrst .eq. n) then
             nofcls=1
             iclst(n)=n
             ifirst(1)=n
             ilast(1)=n
             return
          end if
          call zeroiti(nng,0,n)
          if (iclstyp .eq. 9) call zeroiti(nng2r,0,n)
          if (iuseindex2d .eq. 1) then
            call trnsfi(index2dd,index2d,n)
          else
            call indexit(index2dd,1,n,0)
          end if
          rmsdclust4=rmsdclust*4.0
          do ii=nfrst,n
            i=index2dd(ii)
            do jj=ii+1,n
              j=index2dd(jj)
              if (rmsd2d(i,j) .lt. sdmin) sdmin=rmsd2d(i,j)
              if (rmsd2d(i,j) .gt. sdmax) sdmax=rmsd2d(i,j)
              if (rmsd2d(i,j) .eq. 0.0) nz_sd=nz_sd+1
              if (iclstyp .ne. 4 .and. iclstyp .ne. 5) then
                if (rmsd2d(i,j) .lt. rmsdclust) then
                  nng(ii)=nng(ii)+1
                  nng(jj)=nng(jj)+1
                  ing(nng(ii),ii)=jj
                  ing(nng(jj),jj)=ii
                end if
              end if
              if (iclstyp .eq. 9) then
                if (rmsd2d(i,j) .lt. rmsdclust4) then
                  ing(MAX2D-nng2r(ii),ii)=jj
                  ing(MAX2D-nng2r(jj),jj)=ii
                  nng2r(ii)=nng2r(ii)+1
                  nng2r(jj)=nng2r(jj)+1
                end if
              end if
            end do
          end do
          write (6,1002) sdmin,sdmax
          write (iout,1002) sdmin,sdmax
          if (iclstyp .eq. 8 .and. nosortindex2d .eq. 0) then
            nmem=n-nfrst+1
            call indexit(iorder,1,n,0)
            do ii=nfrst,n
              t2(ii-nfrst+1)=-float(iwt(ii))
            end do
            call mrgsrt(6,iorder(nfrst),t2,nmem,it2,it3,it4,t1,nmem)
            do i=nfrst,n
              if (nng(i) .gt. 1) then
                do ii=1,nng(i)
                  t2(ii)=-float(iwt(ing(ii,i)))
                end do
                call mrgsrt(6,ing(1,i),t2,nng(i),it2,it3,it4,t1,nng(i))
              end if
            end do
          end if
          if (sdmin .eq. 0.0) then
            if (ntry .lt. 2)
         -    write (6,1000) label(1:llabel),'minimum','some',' ',nz_sd
          else if (sdmax .eq. 0.0) then
            write (6,1000) label(1:llabel),'maximum','all'
            print *,'Exiting clustering'
            ifail=1
            return
          end if
          if (iclstyp .le. 3) then
            call clstrs(ing,nng,it1,nfrst,n,iclst,ifirst,ilast,0,nofcls,
         -    it2,0,it2,0,iout,inperr,0,n,n,MAX2D)
          else if (iclstyp .eq. 4) then
            call clstrs_kmedoids(nfrst,n,index2dd,iclst,ifirst,ilast,nofcls,
         -    rmsd2d,icenttyp,icent,icent0,it1,it2,it3,it4,it5,it6,t1,
         -    icent_fin,n,n,MAX2D,iout)
            if (maxct .gt. 1) then
              do ic=1,nofcls
                call trnsfr(cent(1,ic),c(1,icent_fin(ic)),3)
              end do
            end if
          else if (iclstyp .eq. 5) then
            call clstrs_kmeans(nfrst,n,index2dd,iclst,ifirst,ilast,nofcls,
         -    rmsd2d,icent,it1,it2,it3,it4,it5,it6,c,cent,cent_prev,ifail,
         -    n,n,MAX2D)
            if (ifail .gt. 0) return
          else if (iclstyp .eq. 6 .or. iclstyp .eq. 7) then
            call clstrs_maxnn(ing,nng,nfrst,n,iclst,ifirst,ilast,0,
         -    nofcls,it2,n,n,MAX2D)
          else if (iclstyp .eq. 8) then
            iverb=1
            iout_c=iout
            call clstrs(ing,nng,it1,nfrst,n,iclst,ifirst,ilast,0,nofcls,
         -    iorder,1,it2,1,iout_c,inperr,iverb,n,n,MAX2D)
          else if (iclstyp .eq. 9) then
            call clstrs_density(nfrst,n,iclst,ifirst,ilast,nofcls,nofcls_t,
         -    nng,ing,nng2r,idenclstyp,nnmin,it1,it2,it3,it4,it5,it6,MAX2D,
         -    iout)
          end if
          do ic=1,nofcls
            nmem=ilast(ic)-ifirst(ic)
            if (nmem .ge. 1) then
              do ia=1,nmem
                t2(ia)=iclst(ia+ifirst(ic)-1)
              end do
              call indexit(it1,1,nmem,0)
              call mrgsrt(6,it1,t2,nmem,it2,it3,it4,t1,nmem)
              do ia=1,nmem
                iclst(ia+ifirst(ic)-1)=t2(ia)
              end do
            end if
          end do
          do ii=nfrst,n
            if (iclst(ii) .lt. 1 .or. iclst(ii) .gt. n)
         -    print *,'ii=',ii,' iclst=',iclst(ii)
            it1(ii)=index2d(iclst(ii))
          end do
          call trnsfi(index2d(nfrst),it1(nfrst),n-nfrst+1)
          if (iclstyp .eq. 9) nofcls=nofcls_t
          return
    1000  format(1x,a,1x,a,' is zero - ',a,' items are identical',a,/,
         -  ' # of zero RMSDs=',i6)
    1001  format(' ERROR: number of items exceeds limit',/,
         -  ' Redimension the arrays index2dd and iorder to M A X R E C')
    1002  format(' Range of the distance measures: [',f10.5,',',f10.5,']')
          end
          subroutine rmsdsubcluster(numclst,nfrst,n,index2d,iclst,ifirst,
         -  ilast,rmsdclust,isubclustertyp,surfacefract,denexphalf,
         -  i1,i2,i3,i4,i5,value,t1,iout,nofcls,label,llabel)
          dimension index2d(n),iclst(n),ifirst(n),ilast(n),value(n),t1(n),
         -  i1(n),i2(n),i3(n),i4(n),i5(n)
          character*(*) label
          parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
          parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
         -  (4*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
          common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),ing(MAX2D,MAX2D),
         -  ihbpair(2,MAXBONDS),a1(MAXBONDS),a2(MAXBONDS),fill(IFILL2)
          dimension ix1(MAX2D)
          data indxidel /0/
          write (6,1002) nfrst,n,rmsdclust
          write (iout,1002) nfrst,n,label(1:llabel),rmsdclust
          nofcls=0
          call zeroiti(nng,0,n)
          do ii=nfrst,n
            i=index2d(ii)
            do jj=ii+1,n
              j=index2d(jj)
              if (rmsd2d(i,j) .lt. rmsdclust) then
                nng(ii)=nng(ii)+1
                nng(jj)=nng(jj)+1
                ing(nng(ii),ii)=jj
                ing(nng(jj),jj)=ii
              end if
            end do
          end do
          call clstrs(ing,nng,ix1,nfrst,n,iclst,ifirst,ilast,0,nofcls,i2,0,
         -  i2,0,6,inperr,0,n,n,MAX2D)
          if (nofcls .gt. 1) then
            write (6,1004) nofcls
            return
          end if
          call trnsfi(i3,nng,n)
          do while (.true.)
            istart=0
            if (isubclustertyp .eq. 1) then
              call trnsfi(i4,nng,n)
              nnmax=-1
              nnmin=n+1
              do i=nfrst,n
                if (nng(i) .gt. 0) then
                  if (nng(i) .gt. nnmax) nnmax=nng(i)
                  if (nng(i) .lt. nnmin) nnmin=nng(i)
                end if
              end do
              if (nnmin .eq. nnmax) then
                write (6,1001) nnmin
                go to 200
              end if
              write (6,1007) nnmin
              write (iout,1007) nnmin
              ndel=0
              do i=nfrst,n
                if (nng(i) .eq. nnmin) then
                  ndel=ndel+1
                  i5(ndel)=i
                end if
              end do
              write (6,1003) numclst,n-nfrst+1,nnmin,nnmax
              write (iout,1003) numclst,n-nfrst+1,nnmin,nnmax
            else
              tmin=100000.0
              tmax=0.0
              do ii=nfrst,n
                i=index2d(ii)
                t1(ii)=0.0
                do jj=nfrst,n
                  j=index2d(jj)
                  if (i .ne. j) t1(ii)=t1(ii)+1.0/rmsd2d(i,j)**denexphalf
                end do
                if (tmin .gt. t1(ii)) tmin=t1(ii)
                if (tmax .lt. t1(ii)) tmax=t1(ii)
              end do
              ndel=0
              do i=nfrst,n
                if (t1(i) .lt. surfacefract*tmax) then
                  ndel=ndel+1
                  i5(ndel)=i
                end if
              end do
              write (6,1009) numclst,n-nfrst+1,tmin,tmax
              write (iout,1009) numclst,n-nfrst+1,tmin,tmax
            end if
            write (6,1010) (index2d(i5(i)),i=1,ndel)
            write (iout,1010) (index2d(i5(i)),i=1,ndel)
            do i=1,ndel
              id=i5(i)
              do in=1,nng(id)
                idel=ing(in,id)
                do jn=1,nng(idel)
                  if (ing(jn,idel) .eq. id) then
                    indxidel=jn
                    go to 100
                  end if
                end do
    100         ing(indxidel,idel)=ing(nng(idel),idel)
                nng(idel)=nng(idel)-1
              end do
              nng(id)=0
            end do
            call clstrs(ing,nng,i1,nfrst,n,iclst,ifirst,ilast,0,nofcls,
         -    i2,0,i2,0,6,inperr,0,n,n,MAX2D)
            nsingl=0
            do ic=1,nofcls
              if (ifirst(ic) .eq. ilast(ic)) then
                nsingl=nsingl+1
              end if
            end do
            nofcls=nofcls-nsingl
            write (6,1005) nofcls
            nc=0
            if (nofcls .gt. 1) then
              do ic=1,nofcls+nsingl
                if (ifirst(ic) .lt. ilast(ic)) then
                  nc=nc+1
                  i5(nc)=ilast(ic)-ifirst(ic)+1
                end if
              end do
            end if
            if (nc .gt. 0) write (6,1006) (i5(i),i=1,nc)
            call askyn('Do you want to shave more nodes',31,
         -    1,-1,moreshave,0,0)
            if (moreshave .eq. 0) go to 200
          end do
    200   if (nofcls .gt. 1) then
            call zeroiti(i5,0,n)
            do ic=1,nofcls
              if (ifirst(ic) .lt. ilast(ic)) then
                do ia=ifirst(ic),ilast(ic)
                 i5(ia)=ic
                end do
              end if
            end do
            do ia=nfrst,n
              if (i5(ia) .eq. 0) then
                do ja=1,i3(ia)
                  if (i5(ing(ja,i3(ia))) .ne. 0) then
                    i5(ia)=i5(ing(ja,i3(ia)))
                    go to 300
                  end if
                end do
    300         continue
              end if
            end do
            call indexit(i1,1,n,0)
            nmem=n-nfrst+1
            do ia=1,nmem
              value(ia)=i5(ia+nfrst-1)
            end do
            call mrgsrt(6,i1,value,nmem,i2,i3,i5,t1,nmem)
            ic=1
            ifirst(ic)=nfrst
            icprev=value(1)
            do ia=nfrst,n
              ia0=ia-nfrst+1
              iclst(ia)=i1(ia0)
              if (value(ia0) .ne. icprev) then
                ilast(ic)=ia-1
                ic=ic+1
                ifirst(ic)=ia
              end if
            end do
            ilast(ic)=n
            if (ic .ne. nofcls) write (6,1000) nofcls,ic
            do ia=nfrst,n
              i1(ia)=index2d(iclst(ia))
            end do
            call trnsfi(index2d(nfrst),i1(nfrst),n-nfrst+1)
          end if
          return
    1000  format(' PROGRAM ERROR in rmsdsubcluster nofcls=',i5,' ic=',i5)
    1001   format(' All nodes have the same number of neighbors (',i5,
         -  ') - can not subcluster')
    1002  format(' Subclustering structures [',i6,' - ',i6,
         -  '] with ',a,' threshold=',f5.2)
    1003  format(' Cluster #',i4,' (',i4,' members): minimum and maximum ',
         -  '# of neighbors=',2i5)
    1004  format(' PROGRAM ERROR: invalid subclustering - nofcls=',i4)
    1005  format(' Number of subclusters found=',i4)
    1006  format(' Number of members in the subclusters found=',5i5,/(10i5))
    1007  format(' Temporarily deleting members with only',i3,' neighbours')
    1009  format(' Cluster #',i4,' (',i4,' members): local density ',
         -  'min/max=',2f10.5)
    1010  format(' Temporarily deleting:',10i5)
          end
          subroutine reportclust(ndim,icl0,nfclst,nlclst,ifclst,ilclst,
         -  index2d,value,it1,ifa_s,ila_s,ih,cv,indexa,irepav,irepmx,
         -  irepeng,irepkm,engcl,nhbdist,etotsaved,ietotsaved,ifindbestrep,
         -  label,llabel,isorttype,idistprint,nomemprint,iout,maxframe,mx2d)
          dimension it1(mx2d),ifclst(mx2d),ilclst(mx2d),index2d(mx2d),
         -  indexa(mx2d),value(mx2d),ifa_s(mx2d),ila_s(mx2d),ih(mx2d),
         -  irepav(mx2d),irepmx(mx2d),irepeng(mx2d),irepkm(mx2d),
         -  nhbdist(mx2d),cv(mx2d),engcl(mx2d),etotsaved(2,maxframe)
          character*(*) label
          parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
          parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
         -  (6*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
          common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),ing(MAX2D,MAX2D),
         -  ihbtores(MAXBONDS),nusepair(MAXBONDS),nhb_atot(MAXBONDS),
         -  nhb_rtot(MAXBONDS),ixrank(MAXBONDS),rankav(MAXBONDS),
         -  fill(IFILL2)
          dimension diamcl(MAX2D)
          data emax /0.0/
          nclust=nlclst-nfclst+1
          do ic=nfclst,nlclst
            ixsum=0
            do i=ifclst(ic),ilclst(ic)
              ixsum=ixsum+index2d(i)
            end do
            nmem=ilclst(ic)-ifclst(ic)+1
            rankav(ic)=float(ixsum)/float(nmem)
          end do
          call indexit(ixrank,1,nclust,0)
          call mrgsrt(6,ixrank,rankav(nfclst),nclust,ifa_s,ila_s,ih,cv,
         -  max2d)
          do icc=1,nclust
            ifa_s(icc)=ifclst(ixrank(icc)+nfclst-1)
            ila_s(icc)=ilclst(ixrank(icc)+nfclst-1)
          end do
          do ic=nfclst,nlclst
            ifclst(ic)=ifa_s(ic-nfclst+1)
            ilclst(ic)=ila_s(ic-nfclst+1)
          end do
          iout_term=6
          if (nlclst-nfclst .gt. 9) then
            iout_term=0
            print *,'Cluster characteristics are printed on the .rd2 file ',
         -    'only'
          end if
          cdiammin=100000.0
          cdiammax=0.0
          if (ifindbestrep .gt. 0) then
            call indexit(indexa,1,ndim,0)
            write (6,1015)
            call findbestrep(0,0,0,ndim,indexa,irdavmn,irdmxmn,
         -    0,0.0,0.0,0.0,cdiam,cdiammin,cdiammax,0,'RMSD',4,0,MAX2D)
          end if
          maxmem=0
          diammin=100000.0
          diammax=0.0
          do ic=nfclst,nlclst
            nmem=ilclst(ic)-ifclst(ic)+1
            if (nmem .gt. maxmem) maxmem=nmem
            if (nomemprint .eq. 0)
         -    write (iout,2090) ic,nmem,rankav(ic)
            if (isorttype .eq. 1) then
              do i=ifclst(ic),ilclst(ic)
                value(i-ifclst(ic)+1)=index2d(i)
              end do
              call indexit(it1,1,nmem,0)
              call mrgsrt(6,it1,value,nmem,ifa_s,ila_s,ih,cv,max2d)
              do i=ifclst(ic),ilclst(ic)
                index2d(i)=value(i-ifclst(ic)+1)
              end do
              i00=ifclst(ic)-1
              i0=0
              do while (i0 .lt. nmem)
                if (nomemprint .eq. 0) write (iout,2091)ic,(index2d(i00+i),
         -        i=i0+1,min0(i0+10,nmem))
                i0=i0+10
              end do
            else if (isorttype .gt. 1) then
              do i=ifclst(ic),ilclst(ic)
                it1(i-ifclst(ic)+1)=index2d(i)
                value(i-ifclst(ic)+1)=-nhbdist(index2d(i))
              end do
              call mrgsrt(6,it1,value,nmem,ifa_s,ila_s,ih,cv,max2d)
              call trnsfi(index2d(ifclst(ic)),it1,nmem)
              i0=0
              do while (i0 .lt. nmem)
                if (nomemprint .eq. 0) write (iout,2091) ic,(it1(i),
         -        i=i0+1,min0(i0+10,nmem))
                i0=i0+10
              end do
            end if
            emax=-1.e+32
            if (ietotsaved .gt. 0) then
              emin=1.e+32
              esum=0.0
              do i=ifclst(ic),ilclst(ic)
                etot=etotsaved(1,index2d(i))
                esum=esum+etot
                if (emin .gt. etot) then
                  emin=etot
                  irepeng(ic)=index2d(i)
                end if
                if (emax .lt. etot) emax=etot
              end do
              engcl(ic)=esum/(ilclst(ic)-ifclst(ic)+1)
            end if
            if (ifindbestrep .eq. 1) then
              call zeroiti(indexa,0,ndim)
              do i=ifclst(ic),ilclst(ic)
                indexa(index2d(i))=1
              end do
              if (icl0 .eq. 0) then
                call findbestrep(iout,ic,0,ndim,indexa,irepav(ic),
         -        irepmx(ic),ietotsaved,emin,emax,engcl(ic),diamcl(ic),
         -        diammin,diammax,irepeng(ic),label,llabel,iout_term,max2d)
              else
                call findbestrep(iout,icl0,ic,ndim,indexa,irepav(ic),
         -        irepmx(ic),ietotsaved,emin,emax,engcl(ic),diamcl(ic),
         -        diammin,diammax,irepeng(ic),label,llabel,iout_term,max2d)
              endif
            end if
          end do
          write (6,2095) (ilclst(ic)-ifclst(ic)+1,ic=1,nclust)
          write (iout,2095) (ilclst(ic)-ifclst(ic)+1,ic=1,nclust)
          if (ifindbestrep .eq. 1) then
            write (6,2101) (diamcl(ic),ic=1,nclust)
            write (iout,2101) (diamcl(ic),ic=1,nclust)
          end if
          if (maxmem .gt. 1 .and. ifindbestrep .gt. 0) then
            write (6,2099)  cdiammin,diammin,diammax
            write (iout,2099)  cdiammin,diammin,diammax
          end if
          if (ifindbestrep .eq. 1) then
            if (label(1:4) .eq. 'RMSD') then
              write (iout,2096) 'average RMSD'
              i0=0
              do while (i0 .lt. nclust)
                write (iout,2098) ' clrepa ',
         -        (irepav(i),i=i0+1,min0(i0+10,nclust))
                i0=i0+10
              end do
            end if
            write (iout,2097) 'maximum ',label(1:llabel)
            i0=0
            do while (i0 .lt. nclust)
              write (iout,2098) ' clrepm ',
         -      (irepmx(i),i=i0+1,min0(i0+10,nclust))
              i0=i0+10
            end do
            write (iout,2089)
            i0=0
            do while (i0 .lt. nclust)
              write (iout,2098) ' clfrst ',
         -      (index2d(ifclst(i)),i=i0+1,min0(i0+10,nclust))
              i0=i0+10
            end do
            if (ietotsaved .gt. 0 .and. ifindbestrep .eq. 1) then
              write (iout,2096) 'lowest energy'
              i0=0
              do while (i0 .lt. nclust)
                write (iout,2094) ' clrepe ',
         -        (irepeng(ic),etotsaved(1,irepeng(ic)),
         -        ic=i0+1,min0(i0+3,nclust))
                i0=i0+3
              end do
              write (iout,2100) (engcl(ic),ic=1,nclust)
            end if
            nz=0
            do i=1,nclust
              if (irepkm(i) .eq. 0) nz=nz+1
            end do
            if (nz .eq. 0) then
              write (iout,2096) 'k-medoids clustering centers'
              i0=0
              do while (i0 .lt. nclust)
                write (iout,2098) ' clrepkm',
         -        (index2d(irepkm(i)),i=i0+1,min0(i0+10,nclust))
                i0=i0+10
              end do
            end if
            if (idistprint .eq. 1 .and. nlclst-nfclst .gt. 0) then
              do ic=nfclst,nlclst
                if (label(1:4) .eq. 'RMSD') then
                  write (iout,2080) ic,
         -          (rmsd2d(irepav(ic),irepav(jc)),jc=nfclst,nlclst)
                else
                  write (iout,2092) ic,label(1:llabel),
         -          (rmsd2d(irepmx(ic),irepmx(jc)),jc=nfclst,nlclst)
                end if
              end do
            end if
          end if
          return
    1015  format(1x,a)
    2080  format(' RMSDs between <MSD>-based center of cluster',i4,' and ',
         -  /,' the other cluster centers:',/,(10f8.2))
    2089  format(/,' First member of each cluster:')
    2090  format(/,' Cluster #',i4,' contains ',i4,' members (<rank>=',
         -  f8.1,'):')
    2091  format(' clmem ',i4,':',10i6)
    2092  format(' Cluster',i4,1x,a,'-based center-center distances:',/,
         -  (10f8.2))
    2094  format(a,3(i8,' (',e12.5,')'))
    2095  format(/,' Number of members in each cluster:',/,(10i5))
    2096  format(/,' Cluster representatives (centers) based on ',a,':')
    2097  format(/,' Cluster representatives (centers) based on ',a,a,':')
    2098  format(1x,a,':',10i6)
    2099  format(' Diameter of the whole set:',f8.2,
         -  ' Cluster diameter range: [',f8.2,',',f8.2,']')
    2100  format(/,' Average energy of the cluster members:',/,(5e13.5))
    2101  format(' Cluster diameters:',/,(10f8.2))
          end
          subroutine countsim(ifclst,ilclst,index,nclust,rmsdsimdefr,
         -  rmsdsim,nsim,iout,mx2d)
          dimension ifclst(mx2d),ilclst(mx2d),index(mx2d),nsim(mx2d)
          parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
          parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
         -  (4*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
          common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),ing(MAX2D,MAX2D),
         -  ihbpair(2,MAXBONDS),a1(MAXBONDS),a2(MAXBONDS),fill(IFILL2)
          rmsdsimdef=rmsdsimdefr
          if (rmsdsimdefr .eq. 0.0) rmsdsimdef=1.0
          call getreal('MAXimum RMSD for intra-cluster similarity',41,
         -  rmsdsimdef,rmsdsim,1,86)
          write (iout,1000) nclust,rmsdsim
          do ic=1,nclust
            nsimic=0
            rmsdmin=99999.9
            rmsdmax=0.0
            do ia=ifclst(ic),ilclst(ic)
              do ja=ia+1,ilclst(ic)
                rmsd=rmsd2d(index(ia),index(ja))
                if (rmsd .le. rmsdsim) nsimic=nsimic+1
                if (rmsd .lt. rmsdmin) rmsdmin=rmsd
                if (rmsd .gt. rmsdmax) rmsdmax=rmsd
              end do
            end do
            nsim(ic)=nsimic
            nmem=ilclst(ic)-ifclst(ic)+1
            write (iout,1001) ic,nmem
            if (nmem .gt. 1)
         -    write (iout,1002) rmsdsim,nsimic,
         -      100.0*float(nsimic)/float((nmem*(nmem-1))/2),rmsdmin,rmsdmax
          end do
          return
    1000  format(/,' Counting similar members of',i4,' clusters with ',
         -  'similarity RMSD cutoff=',f5.1,' A')
    1001  format(' Cluster',i5,' nmem=',i4)
    1002  format(8x,'# of member pairs within',f6.1,' A RMSD=',i8,
         -  ' (',f6.2,' % of all pairs)',/,
         -  8x,'RMSD range of all pairs: [',f7.1,',',f7.1,']')
          end
          subroutine countsimx(ifclst1,ilclst1,index1,nclust1,
         -  ifclst2,ilclst2,index2,nclust2,rmsdsim,iout,mx2d)
          dimension ifclst1(mx2d),ilclst1(mx2d),index1(mx2d),
         -  ifclst2(mx2d),ilclst2(mx2d),index2(mx2d)
          parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
          parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
         -  (4*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
          common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),ing(MAX2D,MAX2D),
         -  ihbpair(2,MAXBONDS),a1(MAXBONDS),a2(MAXBONDS),fill(IFILL2)
          write (iout,1000) nclust1,nclust2,rmsdsim
          do ic1=1,nclust1
            do ic2=1,nclust2
              nsimic=0
              rmsddmin=1000000.0
              rmsddmax=0.0
              do i1=ifclst1(ic1),ilclst1(ic1)
                do i2=ifclst2(ic2),ilclst2(ic2)
                  rmsd=rmsd2d(index1(i1),index2(i2))
                  if (rmsd .le. rmsdsim) nsimic=nsimic+1
                  if (rmsd .lt. rmsddmin)rmsddmin=rmsd
                  if (rmsd .gt. rmsddmax)rmsddmax=rmsd
                end do
              end do
              nmem1=ilclst1(ic1)-ifclst1(ic1)+1
              nmem2=ilclst2(ic2)-ifclst2(ic2)+1
              write (iout,1001) ic1,nmem1,ic2,nmem2
              if (nmem1*nmem2 .gt. 0 .and. min0(nmem1,nmem2) .gt. 1)
         -      write (iout,1002) rmsdsim,nsimic,
         -        100.0*float(nsimic)/float(nmem1*nmem2),rmsddmin,rmsddmax
            end do
            write (iout,*)
          end do
          return
    1000  format(' Counting similar members between',i4,' and ',i4,
         -  ' clusters',/,' Similarity RMSD cutoff=',f5.1,' A')
    1001  format(' Traj1, cluster',i4,' (nmem=',i4,') and ',
         -  ' Traj2, cluster',i4,' (nmem=',i4,')')
    1002  format(3x,'# of Traj1-Traj2 pairs within',f6.1,' A RMSD=',i8,
         -  ' (',f6.2,' % of all pairs)',/,
         -  3x,'RMSD range of all Traj1-Traj2 pairs: [',f7.1,',',f7.1,']')
          end
          subroutine mapclustx(ixtr2,ifclst1,ilclst1,irepmx1,nclust1,
         -  ifclst2,ilclst2,index2,nclust2,nndist,nndistsum,
         -  rmsdmapmax,nframe2,trajnam1,ltrajnam1,trajnam2,
         -  ltrajnam2,iout,mx2d)
          dimension ifclst1(mx2d),ilclst1(mx2d),irepmx1(mx2d),ifclst2(mx2d),
         -  ilclst2(mx2d),index2(mx2d),nndist(mx2d),nndistsum(mx2d)
          character*(*) trajnam1,trajnam2
          parameter (MAXPHI=400,MAX2D=5000,MAXBONDS=10000)
          parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-
         -  (4*MAXBONDS+MAX2D+2*MAX2D*MAX2D))
          common /nnwork/ rmsd2d(MAX2D,MAX2D),nng(MAX2D),ing(MAX2D,MAX2D),
         -  ihbpair(2,MAXBONDS),a1(MAXBONDS),a2(MAXBONDS),fill(IFILL2)
          dimension rmsddmin(MAX2D),rmsddmax(MAX2D)
          data iclmin /0/
          write (iout,1004) rmsdmapmax,trajnam1(1:ltrajnam1),
         -  trajnam2(1:ltrajnam2)
          call zeroiti(nndistsum,0,nclust1)
          do ic2=1,nclust2
            do ic1=1,nclust1
              nndist(ic1)=0
              rmsddmax(ic1)=0.0
              rmsddmin(ic1)=1000000.0
            end do
            do ia=ifclst2(ic2),ilclst2(ic2)
              rmsddmn=100000.0
              if (ixtr2 .eq. 2) then
                do ic1=1,nclust1
                  if (rmsd2d(irepmx1(ic1),index2(ia)) .lt. rmsddmn) then
                    rmsddmn=rmsd2d(irepmx1(ic1),index2(ia))
                    iclmin=ic1
                  end if
                end do
              else
                do ic1=1,nclust1
                  if (rmsd2d(index2(ia),irepmx1(ic1)) .lt. rmsddmn) then
                    rmsddmn=rmsd2d(index2(ia),irepmx1(ic1))
                    iclmin=ic1
                  end if
                end do
              end if
              if (rmsddmn .le. rmsdmapmax)then
                nndist(iclmin)=nndist(iclmin)+1
                if (rmsddmn .lt. rmsddmin(iclmin)) rmsddmin(iclmin)=rmsddmn
                if (rmsddmn .gt. rmsddmax(iclmin)) rmsddmax(iclmin)=rmsddmn
              end if
            end do
            write (iout,1000) ic2,ilclst2(ic2)-ifclst2(ic2)+1,ixtr2,3-ixtr2
            do ic1=1,nclust1
              if (nndist(ic1) .gt. 0) then
                write (iout,1001) nndist(ic1),
         -        float(100*nndist(ic1))/float(ilclst2(ic2)-ifclst2(ic2)+1),
         -        ic1,ilclst1(ic1)-ifclst1(ic1)+1,
         -        ' ',rmsddmin(ic1),rmsddmax(ic1)
                nndistsum(ic1)=nndistsum(ic1)+nndist(ic1)
              else
                write (iout,1001) nndist(ic1),0.0,ic1,
         -        ilclst1(ic1)-ifclst1(ic1)+1
              end if
              write (iout,1005) ic2,irepmx1(ic2),ic1,irepmx1(ic1),
         -      rmsd2d(irepmx1(ic1),irepmx1(ic2))
            end do
          end do
          write (iout,*)
          nmapped=0
          do ic1=1,nclust1
            write (iout,1002) 3-ixtr2,ic1,ixtr2,nndistsum(ic1),
         -    100.0*float(nndistsum(ic1))/float(nframe2)
            nmapped=nmapped+nndistsum(ic1)
          end do
          write (iout,1003) ixtr2,3-ixtr2,nmapped,
         -  100.0*float(nmapped)/float(nframe2)
          return
    1000  format(' Mapping cluster',i3,' (# of members=',i4,') of Traj',i2,
         -  ' to clusters of Traj',i2)
    1001  format(i6,' members (',f5.1,'%) mapped on Clst',i4,
         -  ' (',i5,' members)',a,'RMSDs: [',f5.1,',',f5.1,']')
    1002  format(' Traj',i2,' Clst',i4,': total # of ',
         -  'structures in Traj',i2,' mapped on it:',i5,' (',f5.1,' %)')
    1003  format(' Total number of structures in Traj',i2,' mapped on Traj',
         -  i2,':',i4,' (',f5.1,' %)')
    1004  format(' Mapping clusters of two trajectories:',/,
         -  ' counting the number of members of cluster A that are within',
         -  f6.2,' A RMSD',/,' of the representative element of cluster B',
         -  /,' Trajectory 1:',a,/,' Trajectory 2:',a)
    1005  format(' RMSD between representative element of cluster',i3,' (',
         -  i6,') and',/,' representative element of cluster',i3,' (',i6,
         -  '):',f5.1,' A')
          end
          subroutine residcorr(c1,c2,n,index,ncorr,nframe)
          dimension c1(3,n),c2(3,n),index(ncorr)
          parameter (MAXPHI=400,MAX2D=5000)
          parameter (IFILL4=MAXPHI*MAXPHI*MAXPHI-
         -  (2*MAX2D*MAX2D+17*MAX2D))
          real*8 trajcorr,cav1,cav2,cavs1,cavs2
          common /nnwork/ trajcorr(MAX2D,MAX2D),cav1(3,MAX2D),
         -  cav2(3,MAX2D),cavs1(MAX2D),cavs2(MAX2D),
         -  row(MAX2D),fill(IFILL4)
          if (nframe .eq. 1) then
            call zeroitd(cav1,3*ncorr)
            call zeroitd(cav2,3*ncorr)
            call zeroitd(cavs1,ncorr)
            call zeroitd(cavs2,ncorr)
            do ir=1,ncorr
              call zeroitd(trajcorr(1,ir),ncorr)
            end do
          end if
          do ir=1,ncorr
            do k=1,3
              cav1(k,ir)=cav1(k,ir)+c1(k,index(ir))
              cav2(k,ir)=cav2(k,ir)+c2(k,index(ir))
              cavs1(ir)=cavs1(ir)+scprod(c1(k,index(ir)),c1(k,index(ir)))
              cavs2(ir)=cavs2(ir)+scprod(c2(k,index(ir)),c2(k,index(ir)))
            end do
            do jr=1,ir
              trajcorr(ir,jr)=trajcorr(ir,jr)+
         -      scprod(c1(1,index(ir)),c2(1,index(jr)))
              trajcorr(jr,ir)=trajcorr(ir,jr)
            end do
          end do
          return
          end
          subroutine atomdist_sd(c,n,ldist,ndist,nframe)
          dimension c(3,n),ldist(ndist)
          parameter (MAXPHI=400,MAX2D=5000)
          parameter (IFILL9=MAXPHI*MAXPHI*MAXPHI-
         -  (2*MAX2D*MAX2D+11*MAX2D))
          real*8 trajdist,cav,cavs
          common /nnwork/ trajdist(MAX2D,MAX2D),cav(3,MAX2D),
         -  cavsng(3,MAX2D),cavs(MAX2D),fill(IFILL9)
          real*8 d2
          if (nframe .eq. 1) then
            call zeroitd(cav,3*ndist)
            call zeroitd(cavs,ndist)
            do ir=1,ndist
              call zeroitd(trajdist(1,ir),ndist)
            end do
          end if
          do ir=1,ndist
            do k=1,3
              cav(k,ir)=cav(k,ir)+c(k,ldist(ir))
              cavs(ir)=cavs(ir)+scprod(c(1,ldist(ir)),c(1,ldist(ir)))
            end do
            do jr=1,ir
              d2=dist2(c(1,ldist(ir)),c(1,ldist(jr)))
              trajdist(ir,jr)=trajdist(ir,jr)+d2
              trajdist(jr,ir)=trajdist(jr,ir)+dsqrt(d2)
            end do
          end do
          return
          end
          subroutine read_write_ccc(ndials,iout,irw)
          parameter (MAXPHI=400,MAX2D=5000)
          parameter (IFILL2=MAXPHI*MAXPHI*MAXPHI-(MAX2D*MAX2D+MAX2D))
          common /nnwork/ ccc(MAX2D,MAX2D),itemp(MAX2D),fill(IFILL2)
          if (irw .eq. 1) then
            write (iout) ndials
            do i=1,ndials
              write (iout) (ccc(i,j),j=1,ndials)
            end do
          else
            rewind iout
            read (iout) ndials
            do i=1,ndials
              read (iout) (ccc(i,j),j=1,ndials)
            end do
          end if
          return
          end
          subroutine normalmodes(ncorr,inpt,nframe,inptyp,iout,iannout,
         -  ierr,index,value,ifa,ila,itemp,temp,maxt)
          dimension index(maxt),value(maxt),ifa(maxt),
         -  ila(maxt),itemp(maxt),temp(maxt)
          parameter (MAXPHI=400,MAX2D=5000)
          parameter (IFILL4=MAXPHI*MAXPHI*MAXPHI-
         -  (2*MAX2D*MAX2D+17*MAX2D))
          real*8 trajcorr,diag,offdiag,diagfill,drow,drowfill,cavs1,cavs2
          common /nnwork/ trajcorr(MAX2D,MAX2D),drow(MAX2D),
         -  drowfill(2,MAX2D),diag(MAX2D),offdiag(MAX2D),
         -  diagfill(MAX2D),cavs1(MAX2D),cavs2(MAX2D),
         -  row(MAX2D),fill(IFILL4)
          character*80 lineinp
          ierr=1
          rewind inpt
          if (inptyp .eq. 0) then
            do jr=1,ncorr
              read (inpt,end=999) (drow(ir),ir=1,ncorr)
              do ir=1,ncorr
                trajcorr(ir,jr)=drow(ir)
              end do
            end do
          else if (inptyp .eq. 1) then
            read (inpt,end=100,err=100) ncorr
            do i=1,ncorr
              read (inpt,end=101,err=101) (row(j),j=1,ncorr)
              do j=1,ncorr
                trajcorr(i,j)=row(j)
              end do
            end do
          else
            read (inpt,1005,end=100,err=100) lineinp
            call lastchar(lineinp,lc,80)
            ic=1
            if (lineinp(ic:ic) .eq. '#') ic=2
            read (lineinp(ic:lc),*,end=100,err=100) ncorr
            if (inptyp .eq. 2 .and. ncorr .gt. 3000) then
              print *,'Change format 2006 in subroutine normalmodes'
              stop
            end if
            do i=1,ncorr
              if (inptyp .eq. 3) then
                read (inpt,1004,end=101,err=101) (trajcorr(i,j),j=1,ncorr)
              else
                read (inpt,1006,end=101,err=101) (trajcorr(i,j),j=1,ncorr)
              end if
            end do
          end if
          ierr=0
          call dtred2(trajcorr,ncorr,MAX2D,diag,offdiag)
          call dtqli(diag,offdiag,ncorr,MAX2D,trajcorr,ierr)
          if (ierr .gt. 0) then
            write (6,1007)
            write (iout,1004)
            return
          end if
          call askyn('Do you want to sort by eigenvalues',34,1,-1,isortev,0,
         -  0)
          call indexit(index,1,ncorr,0)
          if (isortev .eq. 1) then
            do i=1,ncorr
              value(i)=-diag(i)
            end do
            call mrgsrt(6,index,value,ncorr,ifa,ila,itemp,temp,maxt)
          end if
          if (iannout .eq. 1) then
            if (inptyp .eq. 0) then
              call write_traj_lim(iout,
         -      'Eigenvalues and eigenvectors of the covariance matrix',53,
         -      1,incr_tr,0)
              write (iout,1001) nframe
            end if
            do jjr=1,ncorr
              jr=index(jjr)
              write (iout,1002) jjr,diag(jr),(trajcorr(ir,jr),ir=1,ncorr)
            end do
          else
            do jjr=1,ncorr
              jr=index(jjr)
              write (iout,1003) diag(jr),(trajcorr(ir,jr),ir=1,ncorr)
            end do
          end if
          return
    999   write (6,1000) jr
          return
    100   print *,'Input covariance matrix is empty'
          return
    101   print *,'Input covariance matrix read aborted at row ',i
          return
    1000  format(' ERROR: residue correlation matrix of file trajcorr.mat',
         -  ' is incomplete',/,' Reading column ',i5,/,
         -  ' Normal mode calculation is skipped')
    1001  format(' Number of frames used=',i8)
    1002  format(i6,' Eigenvalue=',e12.5,' eigenvector:',/,(5e13.5))
    1003  format(3000e13.6)
    1004  format(5e13.6)
    1005  format(a)
    1006  format(3000e13.6)
    1007  format(' Calculation aborted due to diagonalization failure')
          end
          subroutine plotresidcorr(ncorr,nframe,index,indexr,
         -  ncol,maxcol,nrep,iout,iplt,xm,ym,title,ltitle,
         -  ipspage,iucorrmat,icovmatplot,temp,maxtemp)
          dimension index(ncorr),indexr(ncorr)
          character*(*) title
          dimension temp(maxtemp)
          parameter (MAXPHI=400,MAX2D=5000)
          parameter (IFILL4=MAXPHI*MAXPHI*MAXPHI-
         -  (2*MAX2D*MAX2D+17*MAX2D))
          real*8 trajcorr,cav1,cav2,cavs1,cavs2
          common /nnwork/ trajcorr(MAX2D,MAX2D),cav1(3,MAX2D),
         -  cav2(3,MAX2D),cavs1(MAX2D),cavs2(MAX2D),
         -  row(MAX2D),fill(IFILL4)
          real*8 ddot
          dimension mx(1,1),rx(1,1),ixshuffle(MAX2D)
          character*4 yclab(1)
          data nyclab /1/,lyclab /1/
          call indexit(ixshuffle,1,MAX2D,0)
          call write_traj_lim(iout,'Residue covariances and correlations',
         -  36,1,incr_tr,0)
          write (iout,1000) ncorr,nframe,(index(ir),ir=1,ncorr)
          do ir=1,ncorr
            do k=1,3
              cav1(k,ir)=cav1(k,ir)/nframe
              cav2(k,ir)=cav2(k,ir)/nframe
            end do
            cavs1(ir)=cavs1(ir)/nframe
            cavs2(ir)=cavs2(ir)/nframe
          end do
          rcmax=-100000.0
          rcmin=-rcmax
          do ir=1,ncorr
            do jr=1,ncorr
              trajcorr(ir,jr)=(trajcorr(ir,jr)/nframe-
         -      ddot(cav1(1,ir),cav2(1,jr)))
              if (trajcorr(ir,jr) .lt. rcmin) rcmin=trajcorr(ir,jr)
              if (trajcorr(ir,jr) .gt. rcmax) rcmax=trajcorr(ir,jr)
            end do
          end do
          write (iout,1004) rcmin,rcmax
          do ir=1,ncorr
            if (rcmin .lt. 10000.0 .or. rcmax .gt. 10000.0) then
              write (iout,1003) (trajcorr(ir,jr),jr=1,ncorr)
            else
              write (iout,1002) (trajcorr(ir,jr),jr=1,ncorr)
            end if
          end do
          if (iucorrmat .gt. 0) then
            call openfile(iucorrmat,0,'log',3,'new','trajcorr.mat',12,
         -      notfnd,0,2,1,0,0)
            do jr=1,ncorr
              write (iucorrmat) (trajcorr(ir,jr),ir=1,ncorr)
            end do
          end if
          inc=max0(1,500/ncorr)
          scalefac=amin1(1.0,500.0/float(ncorr))
          iydel=150
          iytop=0
          if (icovmatplot .eq. 1) then
            call plotmat(iplt,mx,rx,trajcorr,ncorr,ncorr,0,0,0,0,1,nrep,30,
         -    iydel,0,iytop,rcmin,rcmax,ncol,maxcol,ixdelsh,iydelsh,inc,
         -    scalefac,indexr,ixshuffle,ixshuffle,title,ltitle,' ',0,1,' ',
         -    0,temp,yclab,nyclab,lyclab,1,1,MAX2D,MAX2D,MAX2D,
         -    ipspage,0)
            iydel=iydel-50
            call rainbowscale(iplt,ixdelsh+50,450,iydel,0,0.0,rcmin,rcmax,
         -    'Covariance',10)
            call plothead(iplt,xm,ym-15,title,0,
         -    'Residue covariance matrix',25,' ',0,' ',0)
            write (iplt,*) 'showpage'
          end if
          do ir=1,ncorr
            cavs1(ir)=dsqrt(dabs(trajcorr(ir,ir)))
          end do
          do ir=1,ncorr
            do jr=1,ir-1
              trajcorr(ir,jr)=trajcorr(ir,jr)/(cavs1(ir)*cavs1(jr))
              trajcorr(jr,ir)=trajcorr(jr,ir)/(cavs1(ir)*cavs1(jr))
            end do
          end do
          do ir=1,ncorr
            trajcorr(ir,ir)=1.d0
          end do
          write (iout,*) 'The correlation matrix:'
          do ir=1,ncorr
            write (iout,1001) (trajcorr(ir,jr),jr=1,ncorr)
          end do
          iydel=150
          iytop=0
          call plotmat(iplt,mx,rx,trajcorr,ncorr,ncorr,0,0,0,0,1,nrep,30,
         -  iydel,0,iytop,-1.0,1.0,ncol,maxcol,ixdelsh,iydelsh,inc,scalefac,
         -  indexr,ixshuffle,ixshuffle,title,ltitle,' ',0,1,' ',0,temp,
         -  yclab,nyclab,lyclab,1,1,MAX2D,MAX2D,MAX2D,ipspage,0)
          iydel=iydel-50
          call rainbowscale(iplt,ixdelsh+50,450,iydel,0,0.0,-1.0,1.0,
         -  'Correlation',11)
          call plothead(iplt,xm,ym-15,title,0,
         -  'Residue correlation matrix',26,' ',0,' ',0)
          write (iplt,*) 'showpage'
          return
    1000  format(' Number of residues used=',i5,/,
         -  ' Number of structures used=',i6,/,
         -  ' Atomindices used for the calculation:',/,(10i6))
    1001  format(10f8.4)
    1002  format(10f8.2)
    1003  format(5e12.5)
    1004  format(' The covariance matrix (min=',e12.5,' max=',e12.5,'):')
          end
          subroutine clstrs(ineig,nneig,nnloop,n0,n,iclst,ifirst,ilast,
         -  nofcls0,nofcls,iorder,iuseorder,iused,iclique,iout,inperr,iverb,
         -  maxat,maxgr,maxneig)
          dimension ineig(maxneig,maxat),nneig(maxat),iclst(maxat),
         -  ifirst(maxgr),ilast(maxgr),nnloop(maxat),iorder(maxat),
         -  iused(maxat)
          jc=0
          do ii=n0,n
            if (iuseorder .eq. 1) then
              i=iorder(ii)
            else
              i=ii
            end if
            nnloop(i)=nneig(i)
            iused(i)=1
            if (iverb .gt. 0)
         -    write (iout,1010) i,nneig(i),(ineig(j,i),j=1,nneig(i))
            do in=1,nneig(i)
              j=ineig(in,i)
              if (j .lt. n0 .or. j .gt. n) then
                write (iout,1013) i,j,n0,n
                return
              end if
              nfound=0
              do jn=1,nneig(j)
                if (ineig(jn,j) .eq. i) nfound=nfound+1
              end do
              if (nfound .ne. 1) then
                write (iout,1011) j,i,i
                write (iout,1010) j,nneig(j),(ineig(k,j),k=1,nneig(j))
                inperr=inperr+1
              end if
            end do
          end do
          nofcls=nofcls0
          if (n .lt. n0) return
          nfound=n0-1
          ifirst(nofcls0+1)=n0
          do i=n0,n
            if (iused(i) .gt. 0) then
              ic=i
              ncl=0
              kroot=1
              do while (kroot .lt. ncl .or. ncl .eq. 0)
                if (iverb .gt. 1) write (iout,1009)
         -        i,kroot,ncl,ic,nnloop(ic),iused(ic)
                do while (ncl .eq. 0 .or. nnloop(ic) .gt. 0)
                  if (iused(ic) .gt. 0) then
                    if (iclique .eq. 0 .or. ncl .eq. nfound) then
                      ncl=ncl+1
                      iused(ic)=0
                      iclst(nfound+ncl)=ic
                      if (iverb .gt. 1)
         -              write (iout,1008) 'Added1',ic,nnloop(ic),ncl,kroot
                    else
                      nmatch=0
                      do icc=nfound+1,nfound+ncl
                        do iin=1,nneig(ic)
                          if (iclst(icc) .eq. ineig(iin,ic)) then
                            nmatch=nmatch+1
                            go to 101
                          end if
                        end do
                        go to 102
    101                 continue
                      end do
    102               if (nmatch .eq. ncl) then
                        ncl=ncl+1
                        iused(ic)=0
                        iclst(nfound+ncl)=ic
                        if (iverb .gt. 1)
         -                write (iout,1008) 'Added',ic,nnloop(ic),ncl,kroot
                      else
                        if (iverb .gt. 1) write (iout,1008)
         -                'Skipped',ic,nnloop(ic),ncl,kroot
                        iused(ic)=-1
                      end if
                    end if
                  end if
                  if (nnloop(ic) .gt. 0) then
                    jc=ineig(nnloop(ic),ic)
                    do while (iused(jc) .le. 0 .and. nnloop(ic) .gt. 0)
                      jc=ineig(nnloop(ic),ic)
                      nnloop(ic)=nnloop(ic)-1
                      if (iverb .gt. 1) write (iout,1006)
         -              ic,jc,nnloop(ic),iused(jc),ncl
                    end do
                    if (iused(jc) .gt. 0) ic=jc
                  end if
                end do
                ic=iclst(nfound+kroot)
                if (nnloop(ic) .eq. 0) kroot=kroot+1
                if (iverb .gt. 1) write (iout,1007)
         -          nfound,kroot,ic,jc,nnloop(ic),ncl
              end do
              nofcls=nofcls+1
              if (iclique .eq. 1) then
                do ii=n0,n
                  nnloop(ii)=nneig(ii)
                  if (iused(ii) .eq. -1) iused(ii)=1
                end do
              end if
              nfound=nfound+ncl
              ilast(nofcls)=ifirst(nofcls)+ncl-1
              if (nofcls .lt. maxgr) ifirst(nofcls+1)=ilast(nofcls)+1
              if (iverb .gt. 0) write (iout,1005) nofcls,
         -      ifirst(nofcls),ilast(nofcls),ncl
            end if
          end do
          if (iverb .gt. 0) write (iout,*) 'Number of clusters=',nofcls
          if (n .ne. ilast(nofcls)) then
            write (iout,1001) ilast(nofcls),n0,n
            inperr=inperr+1
          end if
          return
    1001  format(' ***** PROGRAM ERROR in cluster search:',
         -  ' il=',i6,' n0,n=',2i6)
    1005  format(' CLSTRS nofcls=',i8,' if,il=',2i6,' ncl=',i5)
    1006  format(' CLSTRS ic,jc=',2i5,' nnloop(ic),iused(jc)=',2i3,
         -  ' ncl=',i5)
    1007  format(' CLSTRS nfound,kroot=',2i6,' ic,jc,nnloop(ic)=',2i6,i3,
         -  ' ncl=',i5)
    1008  format(' CLSTRS ',a,' ic=',i8,' nnloop(ic)=',i2,' ncl,kroot=',2i5)
    1009  format(' CLSTRS i,kroot,ncl,ic,nnloop(ic),iused(ic)=',6i8)
    1010  format(' CLSTRS ',i5,' nn=',i4,(' in=',15i6))
    1011  format(' ***** PROGRAM ERROR: neighbour',i8,' of',i8,' does not ',
         -  'have',i8,' as neighbor exactly once:')
    1013  format(' ERROR: index=',i5,' neighbor=',i5,' is outside the ',
         -  '[',i5,',',i5,'] interval')
          end
          subroutine clstrs_kmedoids(n0,n,index2d,iclst,ifirst,ilast,nofcls,
         -  rmsd2d,icenttyp,icent,icent0,it1,it2,it3,it4,it5,indxclst,t1,
         -  icent_fin,maxnode,maxgr,mx2d,iout)
          dimension index2d(maxnode),iclst(maxnode),ifirst(maxgr),
         -  ilast(maxgr),it1(maxnode),it2(maxnode),it3(maxnode),
         -  it4(maxnode),it5(maxnode),indxclst(maxnode),icent_fin(maxgr),
         -  icent(mx2d),icent0(mx2d),t1(maxnode),rmsd2d(mx2d,mx2d)
          parameter (MAX2D=5000)
          dimension indxmax(MAX2D),indxav(MAX2D),distmax(MAX2D),
         -  distav(MAX2D)
          character*1 ans
          data icminmax /0/,icminav /0/,jmin /0/
          iverb=1
          nitersave=min0(20,mx2d/nofcls)
          call zeroiti(icent,0,nitersave*nofcls)
          call init_kmedoids(nofcls,index2d,ifirst,ilast,icent,rmsd2d,n0,n,
         -  nnode,ierr,iverb,mx2d)
          call quiz(ans,icenttyp,'r',' ',0,'k-medoids center choice',23,0,
         -  5,6,139)
          if (icenttyp .eq. 1) write (iout,1004) 'smallest maximum distance'
          if (icenttyp .eq. 2) write (iout,1004) 'smallest average distance'
          call sortlist(0,icent,nofcls,it1,it2,'IK0',0,mx2d)
          call zeroiti(indxclst,n0-1,n)
          do ic=1,nitersave
            icent0(ic)=(ic-1)*nofcls
          end do
          nchange=1
          iter=0
          maxiter=max0(5*nofcls,2*(n-n0))
          looping=0
          do while (nchange .gt. 0 .and.
         -          iter .lt. maxiter .and. looping .eq. 0)
            nchange=0
            ic0prev=icent0(mod(iter,nitersave)+1)
            iter=iter+1
            ic0=icent0(mod(iter,nitersave)+1)
            do i=n0,n
               ii=index2d(i)
              jmin=0
              do j=1,nofcls
                if (i .eq. icent(ic0prev+j)) then
                  jmin=j
                end if
              end do
              if (jmin .eq. 0) then
                rmin=10000.0
                do j=1,nofcls
                  if (rmin .gt. rmsd2d(ii,index2d(icent(ic0prev+j)))) then
                    rmin=rmsd2d(ii,index2d(icent(ic0prev+j)))
                    jmin=j
                  end if
                end do
              end if
              if (jmin .ne. indxclst(i)) then
                nchange=nchange+1
                indxclst(i)=jmin
              end if
            end do
            if (nchange .gt. 0) then
              call indexit(it1,1,nnode,0)
              call mrgsrti(6,it1,indxclst(n0),nnode,it2,it3,it4,it5,n)
              ifirst(1)=n0
              ixprev=indxclst(n0)
              nc=1
              do i=n0,n
                iclst(i)=it1(i-n0+1)
                if (indxclst(i) .gt. ixprev) then
                  ixprev=indxclst(i)
                  ilast(nc)=i-1
                  nc=nc+1
                  ifirst(nc)=i
                end if
              end do
              ilast(nc)=n
              nchange=0
              if (nc .ne. nofcls) then
                write (6,1001) nc,nofcls
              else
                do ic=1,nofcls
                  rminmax=100000.0
                  ravmax=100000.0
                  ixa=0
                  do ia=ifirst(ic),ilast(ic)
                    iaa=index2d(iclst(ia))
                    rmax=0.0
                    rav=0.0
                    do ja=ifirst(ic),ilast(ic)
                      if (rmsd2d(iaa,index2d(iclst(ja))) .gt. rmax)
         -              rmax=rmsd2d(iaa,index2d(iclst(ja)))
                        rav=rav+rmsd2d(iaa,index2d(iclst(ja)))
                    end do
                    if (rminmax .gt. rmax) then
                      rminmax=rmax
                      icminmax=ia
                    end if
                    rav=rav/float(ilast(ic)-ifirst(ic)+1)
                    if (ravmax .gt. rav) then
                      ravmax=rav
                      icminav=ia
                    end if
                    ixa=ixa+1
                    distmax(ixa)=rmax
                    distav(ixa)=rav
                    indxav(ixa)=ixa
                    indxmax(ixa)=ixa
                  end do
                  nmem=ixa
                  if (icenttyp .eq. 1) then
                    icent(ic0+ic)=iclst(icminmax)
                  else if (icenttyp .eq. 2) then
                    icent(ic0+ic)=iclst(icminav)
                  else if (icenttyp .eq. 3) then
                    call mrgsrt(6,indxmax,distmax,nmem,it2,it3,it4,t1,nmem)
                    call mrgsrt(6,indxav,distav,nmem,it2,it3,it4,t1,nmem)
                    do ia=1,nmem
                      it2(indxmax(ia))=ia
                      it3(indxav(ia))=ia
                    end do
                    icnext=0
                    avminindx=2*MAX2D
                    do ia=1,nmem
                      av=float(it2(ia)+it3(ia))/2.0
                      t1(ia)=av
                      if (av .lt. avminindx) then
                        avminindx=av
                        icnext=ia
                      end if
                    end do
                    icent(ic0+ic)=iclst(ifirst(ic)-1+icnext)
                  end if
                end do
                call mrgsortlist(icent(ic0+1),it1,it2,it3,it4,it5,nofcls)
                do ic=1,nnode
                  if (icent(ic0prev+ic) .ne. icent(ic0+ic))nchange=nchange+1
                end do
                if (nchange .gt. 0 .and. iter .gt. nitersave) then
                  ip=2
                  do while (looping .eq. 0 .and. ip .lt. nitersave)
                    idiff=0
                    ic0prev=icent0(mod(iter-ip,nitersave)+1)
                    ip=ip+1
                    do ic=1,nofcls
                      if (icent(ic0prev+ic) .ne. icent(ic0+ic)) idiff=1
                    end do
                    looping=1-idiff
                  end do
                end if
              end if
            else
              ic0=icent0(mod(iter-1,nitersave)+1)
            end if
            if (iverb .gt. 0) write (6,1000) iter,(icent(ic0+k),k=1,nofcls)
            do ic=1,nofcls
              icent_fin(ic)=icent(ic0+ic)
            end do
            write (iout,1005) (icent_fin(ic),ic=1,nofcls)
          end do
          if (nchange .gt. 0 .and. looping .eq. 0) write (6,1002) iter
          if (nchange .gt. 0 .and. looping .eq. 1) write (6,1003) iter
          return
    1000  format(' Iteration ',i4,' Centers chosen=',(10i5))
    1001  format(' PROGRAM ERROR: nc=',i5,' Number of clusters requested=',
         -  i5)
    1002  format(' NOTE: clustering did not converge in',i6,' iterations ',
         -  '- it may be looping')
    1003  format(' NOTE: clustering detected looping on the centers found ',
         -  'after',i6,' iterations')
    1004  format(' Criterion for cluster center choice: ',a)
    1005  format(' Cluster centers:',(10i5))
          return
          end
          subroutine clstrs_kmeans(n0,n,index2d,iclst,ifirst,ilast,nofcls,
         -  rmsd2d,icent,it1,it2,it3,it4,it5,indxclst,c,cent,cent_prev,
         -  ifail,maxnode,maxgr,mx2d)
          dimension index2d(maxnode),iclst(maxnode),ifirst(maxgr),
         -  ilast(maxgr),it1(maxnode),it2(maxnode),it3(maxnode),
         -  it4(maxnode),it5(maxnode),indxclst(maxnode),c(3,n),
         -  cent(3,maxnode),cent_prev(3,maxnode)
          dimension icent(mx2d),rmsd2d(mx2d,mx2d)
          iverb=0
          call indexit(index2d,1,MAX2D,0)
          do i=1,n
            do j=i+1,n
              rmsd2d(i,j)=dist2(c(1,j),c(1,i))
              rmsd2d(j,i)=rmsd2d(i,j)
            end do
          end do
          call init_kmedoids(nofcls,index2d,ifirst,ilast,icent,rmsd2d,n0,n,
         -  nnode,ierr,iverb,mx2d)
          ifail=0
          do i=1,nofcls
            call trnsfr(cent(1,i),c(1,icent(i)),3)
          end do
          call zeroiti(indxclst,n0-1,n)
          nchange=1
          iter=0
          maxiter=max0(5*nofcls,2*(n-n0))
          do while (nchange .gt. 0 .and. iter .lt. maxiter)
            nchange=0
            iter=iter+1
            do i=n0,n
              rmin=10000.0
              jmin=0
              do j=1,nofcls
                d2=dist2(cent(1,j),c(1,i))
                if (d2 .lt. rmin) then
                  rmin=d2
                  jmin=j
                end if
              end do
              if (jmin .ne. indxclst(i)) then
                nchange=nchange+1
                indxclst(i)=jmin
              end if
            end do
            if (nchange .gt. 0) then
              call trnsfr(cent_prev,cent,3*nofcls)
              call zeroit(cent,3*nofcls)
              call zeroiti(icent,0,nofcls)
              do i=n0,n
                ic=indxclst(i)
                icent(ic)=icent(ic)+1
                do k=1,3
                  cent(k,ic)=cent(k,ic)+c(k,i)
                end do
              end do
              do ic=1,nofcls
                if (icent(ic) .gt. 0) then
                  do k=1,3
                    cent(k,ic)=cent(k,ic)/float(icent(ic))
                  end do
                else
                  call trnsfr(cent,cent_prev,3*nofcls)
                end if
              end do
            end if
          end do
          call indexit(it1,1,nnode,0)
          call mrgsrti(6,it1,indxclst(n0),nnode,it2,it3,it4,it5,n)
          ifirst(1)=n0
          indxprev=indxclst(n0)
          nc=1
          do i=n0,n
            iclst(i)=it1(i-n0+1)
            if (indxclst(i) .gt. indxprev) then
              indxprev=indxclst(i)
              ilast(nc)=i-1
              nc=nc+1
              ifirst(nc)=i
            end if
          end do
          ilast(nc)=n
          if (nc .ne. nofcls) then
            write (6,1001) nc,nofcls
            ifail=1
          end if
          if (nchange .gt. 0) write (6,1002) iter
          return
    1001  format(' Clustering failure: nc=',i5,
         -  ' Number of clusters requested=',i5,/,' Clustering algorithm ',
         -  'needs extension',/' Try with different starting structure or ',
         -  'use the option where cluster centers are nodes')
    1002  format(' NOTE: clustering did not converge in',i6,' iterations ')
          return
          end
          subroutine init_kmedoids(nofcls,index2d,ifirst,ilast,icent,rmsd2d,
         -  n0,n,nnode,ierr,iverb,mx2d)
          dimension index2d(mx2d),icent(mx2d),ifirst(mx2d),ilast(mx2d),
         -  rmsd2d(mx2d,mx2d)
          integer*4 ixo
          common /rangen/ ixo
          dimension ran(1)
          character*31 qcent
          if (nofcls .le. 0 .or. nofcls .gt. n-n0+1) then
            print *,'PROGRAM ERROR: invalid number of clusters requested:',
         -    nofcls
            nofcls=1
            ifirst(1)=n0
            ilast(1)=n
            ierr=1
            return
          end if
          nnode=n-n0+1
          if (nnode .lt. nofcls) then
            print *,'ERROR: can not generate ',nofcls,' clusters from',nnode
            ierr=1
            return
          end if
          ierr=0
          call askyn('Do you want to specify initial cluster centers',46,
         -  1,-1,ireadct,92,0)
          if (ireadct .eq. 1) then
            do k=1,nofcls
              write (qcent,1001) k
              call getint(qcent,31,999999,1,n,icent(k),00)
            end do
          else
            if (ixo .ne. 1237) then
              call askyn(
         -      'Do you want to reinitialize the random-number seed',
         -      50,1,1,ireinit,92,0)
              if (ireinit .eq. 1) call randpx_init(1357)
            end if
            call randpx(1,ran)
            icent(1)=n0+ran(1)*nnode
            ix=0
            do k=2,nofcls
              rminmax=0.0
              do i=n0,n
                ii=index2d(i)
                rmin=10000.0
                do j=1,k-1
                  if (i .eq. icent(j)) then
                    rmin=0.0
                  else
                    if (rmin .gt. rmsd2d(ii,index2d(icent(j))))
         -            rmin=rmsd2d(ii,index2d(icent(j)))
                  end if
                end do
                if (rmin .gt. rminmax) then
                  icent(k)=i
                  rminmax=rmin
                end if
              end do
            end do
          end if
          if (iverb .gt. 0) write (6,1000) (icent(k),k=1,nofcls)
          return
    1000  format(' Initial centers chosen=',(10i5))
    1001  format(' Initial center for cluster #',i3)
          end
          subroutine clstrs_maxnn(ineig,nneig,n0,n,iclst,ifirst,
         -  ilast,nofcls0,nofcls,idrop,maxnode,maxgr,maxneig)
          dimension ineig(maxneig,maxnode),nneig(maxnode),iclst(maxnode),
         -  ifirst(maxgr),ilast(maxgr),idrop(maxnode)
          data indxidel /0/
          nleft=n-n0+1
          nofcls=nofcls0
          lastnode=n0-1
          do while (nleft .gt. 0)
            nnmax=0
            do i=n0,n
              if (nneig(i) .ge. nnmax) then
                nnmax=nneig(i)
                imin=i
              end if
            end do
            if (nnmax .lt. 0) write (6,1002) imin,nnmax
            nofcls=nofcls+1
            lastnode=lastnode+1
            ifirst(nofcls)=lastnode
            iclst(lastnode)=imin
            do in=1,nneig(imin)
             iclst(lastnode+in)=ineig(in,imin)
            end do
            lastnode=lastnode+nneig(imin)
            ilast(nofcls)=lastnode
            nleft=nleft-nneig(imin)-1
            if (ilast(nofcls)+nleft .ne. n)
         -    write (6,1001) nofcls,ilast(nofcls),nleft,n
            if (nleft .lt. 0) write (6,1000) nofcls0,nofcls,imin,nleft
            call trnsfi(idrop,ineig(1,imin),nneig(imin))
            ndrop=nneig(imin)+1
            idrop(ndrop)=imin
            do i=1,ndrop
              id=idrop(i)
              if (nneig(id) .lt. 0) write (6,1003) nofcls,id,nneig(id)
              do in=1,nneig(id)
                idel=ineig(in,id)
                do jn=1,nneig(idel)
                  if (ineig(jn,idel) .eq. id) then
                    indxidel=jn
                    go to 100
                  end if
                end do
    100         ineig(indxidel,idel)=ineig(nneig(idel),idel)
                nneig(idel)=nneig(idel)-1
              end do
              nneig(id)=-1
            end do
          end do
    1000  format(' PROGRAM ERROR: nofcls0,nofcls,imin,nleft=',4i8,' < 0 !')
    1001  format(' PROGRAM ERROR: nofcls,ilast(nofcls),nleft,n=',4i6,
         -  ' (il+nl ne n)')
    1002  format(' PROGRAM ERROR: imin,nnmax=',2i5,' ( <0 !)')
    1003  format(' PROGRAM ERROR: nofcls,id=',2i5,' nneig(id)=',i4,' (<0!)')
          return
          end
          subroutine clstrs_density(nfrst,n,iclst,ifirst,ilast,nofcls,
         -  nofcls_t,nng,ing,nng2r,idenclstyp,nnmin,it1,it2,it3,it4,it5,
         -  it6,mx2d,iout)
          dimension iclst(mx2d),ifirst(mx2d),ilast(mx2d),nng(mx2d),
         -  ing(mx2d,mx2d),nng2r(mx2d),it1(mx2d),it2(mx2d),it3(mx2d),
         -  it4(mx2d),it5(mx2d),it6(mx2d)
          print *
          iverb=1
          nngmin=mx2d
          nngmax=0
          nz=0
          do i=nfrst,n
            if (nng(i) .lt. nngmin) nngmin=nng(i)
            if (nng(i) .gt. nngmax) nngmax=nng(i)
            if (nng(i) .lt. nnmin) nz=nz+1
          end do
          write (iout,2001) nngmin,nngmax
          write (   6,2001) nngmin,nngmax
          if (nz .gt. 0) write (iout,2000) nnmin,nz
          if (idenclstyp .eq. 3) then
            do i=nfrst,n
              do jj=1,nng(i)
                j=iabs(ing(jj,i))
                if (i .lt. j) then
                  if (nng(i) .lt. nnmin .or. nng(j) .lt. nnmin) then
                    do ii=1,nng(j)
                      if (ing(ii,j) .eq. i) ing(ii,j)=-ing(ii,j)
                    end do
                    ing(jj,i)=-ing(jj,i)
                  end if
                end if
              end do
            end do
            call clean_ng(nfrst,n,nng,ing,mx2d)
            call checknnlist(nfrst,n,ing,nng,nerr,mx2d)
            if (nerr .gt. 0) stop
            iverb=0
            call clstrs(ing,nng,it1,nfrst,n,iclst,ifirst,ilast,0,nofcls,
         -    it2,0,it2,0,0006,inperr,iverb,n,n,mx2d)
          else if (idenclstyp .eq. 2) then
            do i=nfrst,n
              do j=1,nng(i)
                nmatch=0
                do ii=1,nng(i)
                  do jj=1,nng(j)
                    iii=iabs(ing(jj,j))
                    if (iii .gt. i) then
                      if (iabs(ing(ii,i)) .eq. iii) nmatch=nmatch+1
                    end if
                  end do
                end do
                if (nmatch .lt. nnmin) then
                  do ii=1,nng(i)
                    if (ing(ii,i) .eq. j) ing(ii,i)=-ing(ii,i)
                  end do
                  do jj=1,nng(j)
                    if (ing(jj,j) .eq. i) ing(jj,j)=-ing(jj,j)
                  end do
                end if
              end do
            end do
            call clean_ng(nfrst,n,nng,ing,mx2d)
            call clstrs(ing,nng,it1,nfrst,n,iclst,ifirst,ilast,0,nofcls,
         -    it2,0,it2,0,iout,inperr,0,n,n,mx2d)
          else if (idenclstyp .eq. 1) then
            call zeroiti(it3,nfrst-1,n)
            do i=nfrst,n
              do j=1,nng2r(i)
                ing(nng(i)+j,i)=ing(mx2d-j+1,i)
              end do
            end do
            do i=nfrst,n
              do j=1,nng(i)+nng2r(i)
                jn=ing(j,i)
                nmatch=0
                do ii=1,nng(i)
                  do jj=1,nng(jn)
                    if (ing(ii,i) .eq. ing(jj,jn)) nmatch=nmatch+1
                  end do
                end do
                if (nmatch .ge. nnmin) then
                  ing(mx2d-it3(i),i)=jn
                  ing(mx2d-it3(jn),jn)=i
                  it3(i)=it3(i)+1
                  it3(jn)=it3(jn)+1
                end if
              end do
            end do
            do i=nfrst,n
              do j=1,it3(i)
                ing(j,i)=ing(mx2d-j+1,i)
              end do
            end do
            call trnsfi(nng(nfrst),it3(nfrst),n-nfrst+1)
            call clstrs(ing,nng,it1,nfrst,n,iclst,ifirst,ilast,0,nofcls,
         -    it2,0,it2,0,iout,inperr,0,n,n,mx2d)
          end if
          do i=1,nofcls
            it6(i)=float(ifirst(i)-ilast(i))
          end do
          call indexit(it1,1,nofcls,0)
          call mrgsrti(iout,it1,it6,nofcls,it2,it3,it4,it5,nofcls)
          inc=0
          do i=1,nofcls
            nmem=ilast(it1(i))-ifirst(it1(i))+1
            do j=1,nmem
              it4(inc+j)=iclst(ifirst(it1(i))-1+j)
            end do
            it2(i)=inc+1
            it3(i)=inc+nmem
            inc=inc+nmem
          end do
          call trnsfi(ifirst,it2,nofcls)
          call trnsfi(ilast,it3,nofcls)
          call trnsfi(iclst,it4,n-nfrst+1)
          i=1
          do while (ilast(i) .gt. ifirst(i) .and. i .lt. nofcls)
            i=i+1
          end do
          nsing=0
          if (ilast(i) .eq. ifirst(i)) nsing=nofcls-i+1
          write (iout,*) 'Number of single nodes=',nsing
          nofcls_t=nofcls-nsing
          return
    2000  format(' Number of nodes with fewer than',i4,' neighbors=',i5)
    2001  format(' Range of the number of neighbors: [',i4,',',i4,']')
          end
          subroutine clean_ng(nfrst,n,nng,ing,maxn)
          dimension nng(maxn),ing(maxn,maxn)
          do i=nfrst,n
            ndel=0
            do j=1,nng(i)
              if (ing(j,i) .le. 0) then
                ndel=ndel+1
              else
                ing(j-ndel,i)=ing(j,i)
              end if
            end do
            nng(i)=nng(i)-ndel
          end do
          return
          end
          subroutine masktolist(index,mask,n,nfinal,isave)
          dimension index(n),mask(n)
          nfinal=0
          do i=1,n
            if (mask(i) .eq. isave) then
              nfinal=nfinal+1
              index(nfinal)=i
            end if
          end do
          return
          end
          subroutine extract(c,index,ndim,n,nfinal)
          dimension c(ndim,n),index(n)
          nfinal=0
          do ia=1,n
            if (index(ia) .eq. 0) then
              nfinal=nfinal+1
              if (nfinal .lt. ia) call trnsfr(c(1,nfinal),c(1,ia),ndim)
            end if
          end do
          return
          end
          subroutine bestoverlay(nat,index1,index2,c1,c2,atw,atwsuminp,
         -  cc1,cc2,atw1,rot,com1,com2,LEVTEST,TOLERANCE,iout,maxat)
          dimension index1(maxat),index2(maxat),c1(3,maxat),c2(3,maxat),
         -  atw(maxat),cc2(3,maxat),cc1(3,maxat),atw1(maxat),
         -  rot(3,3),com1(3),com2(3)
          dimension ijk(3,2)
          real*8 atwsuminp,atwsum,sm,r(3,3),dcom1(3),dcom2(3),
         -  rr(3,3),diag(3),offdiag(3),a(3,3),b(3,3),rmu(3)
          data iz /0/,inz /0/,atwsum /0.d0/
          ijk(1,1)=2
          ijk(1,2)=3
          ijk(2,1)=1
          ijk(2,2)=3
          ijk(3,1)=1
          ijk(3,2)=2
          devmax=0.0
          if (nat .eq. 1) return
          do k=1,3
            dcom1(k)=0.d0
            dcom2(k)=0.d0
          end do
          do i=1,nat
            atw1(i)=atw(index1(i))
            do k=1,3
              cc1(k,i)=c1(k,index1(i))
              cc2(k,i)=c2(k,index2(i))
              dcom1(k)=dcom1(k)+atw1(i)*cc1(k,i)
              dcom2(k)=dcom2(k)+atw(index2(i))*cc2(k,i)
            end do
          end do
          if (atwsuminp .eq. 0.d0) then
            atwsum=0.d0
            do i=1,nat
              atwsum=atwsum+atw1(i)
            end do
          else
            atwsum=atwsuminp
          end if
          do k=1,3
            com1(k)=dcom1(k)/atwsum
            com2(k)=dcom2(k)/atwsum
          end do
          if (LEVTEST .gt. 0) write (LEVTEST,1001) atwsum,com1,com2
          do i=1,nat
            do k=1,3
              cc1(k,i)=cc1(k,i)-com1(k)
              cc2(k,i)=cc2(k,i)-com2(k)
            end do
          end do
          do k=1,3
            do l=1,3
              r(k,l)=0.d0
              do i=1,nat
                r(k,l)=r(k,l)+atw1(i)*cc1(k,i)*cc2(l,i)
              end do
              r(k,l)=r(k,l)/atwsum
            end do
          end do
          do k=1,3
            do l=1,3
              sm=0.d0
              do m=1,3
                sm=sm+r(m,k)*r(m,l)
              end do
              rr(k,l)=sm
            end do
          end do
          if (LEVTEST .gt. 0) then
            write (LEVTEST,1000) "r",r
            write (LEVTEST,1000) "rr",rr
          end if
          call dtred2(rr,3,3,diag,offdiag)
          call dtqli(diag,offdiag,3,3,rr,ierr)
          if (ierr .gt. 0) then
            write (6,1004)
            if (iout .gt. 0) write (iout,1004)
            return
          end if
    1004  format(' Calculation aborted due to diagonalization failure')
          do k=1,3
            do l=1,3
              a(k,l)=rr(l,k)
            end do
          end do
          nz=0
          do k=1,3
            if (dabs(diag(k)) .gt. TOLERANCE) then
              rmu(k)=dsqrt(dabs(diag(k)))
            else
              rmu(k)=0.d0
              nz=nz+1
            end if
          end do
          if (LEVTEST .gt. 0) write (LEVTEST,*) "mu=",rmu
          do k=1,3
            if (rmu(k) .lt. TOLERANCE) then
              iz=k
            else
              do l=1,3
                sm=0.d0
                do m=1,3
                  sm=sm+r(l,m)*a(k,m)
                end do
                b(k,l)=sm/rmu(k)
              end do
              inz=k
            end if
          end do
          if (LEVTEST .gt. 0) write (LEVTEST,*) "nz=",nz
          if (nz .eq. 1) then
             a(iz,1)=a(ijk(iz,1),2)*a(ijk(iz,2),3)-
         -     a(ijk(iz,1),3)*a(ijk(iz,2),2)
             a(iz,2)=a(ijk(iz,1),3)*a(ijk(iz,2),1)-
         -     a(ijk(iz,1),1)*a(ijk(iz,2),3)
             a(iz,3)=a(ijk(iz,1),1)*a(ijk(iz,2),2)-
         -     a(ijk(iz,1),2)*a(ijk(iz,2),1)
             b(iz,1)=b(ijk(iz,1),2)*b(ijk(iz,2),3)-
         -     b(ijk(iz,1),3)*b(ijk(iz,2),2)
             b(iz,2)=b(ijk(iz,1),3)*b(ijk(iz,2),1)-
         -     b(ijk(iz,1),1)*b(ijk(iz,2),3)
             b(iz,3)=b(ijk(iz,1),1)*b(ijk(iz,2),2)-
         -     b(ijk(iz,1),2)*b(ijk(iz,2),1)
          else if (nz .eq. 2) then
            do k=1,3
              a(iz,k)=0.d0
              b(iz,k)=0.d0
            end do
            if (dabs(a(inz,1)) .lt. TOLERANCE) then
              a(iz,1)=rmu(inz)
            else if (dabs(a(inz,2)) .ge. TOLERANCE) then
              a(iz,1)= -a(inz,1)
            else
              a(iz,2)=rmu(inz)
            end if
            if (dabs(b(inz,1)) .lt. TOLERANCE) then
              b(iz,1)=rmu(inz)
            else if (dabs(b(inz,2)) .ge. TOLERANCE) then
              b(iz,1)= -b(inz,1)
            else
              b(iz,2)=rmu(inz)
            end if
            if (iz .eq. ijk(inz,1)) then
              jz=ijk(inz,2)
            else
              jz=ijk(inz,1)
            end if
            a(jz,1)=a(ijk(jz,1),2)*a(ijk(jz,2),3)-
         -    a(ijk(jz,1),3)*a(ijk(jz,2),2)
            a(jz,2)=a(ijk(jz,1),3)*a(ijk(jz,2),1)-
         -    a(ijk(jz,1),1)*a(ijk(jz,2),3)
            a(jz,3)=a(ijk(jz,1),1)*a(ijk(jz,2),2)-
         -    a(ijk(jz,1),2)*a(ijk(jz,2),1)
            b(jz,1)=b(ijk(jz,1),2)*b(ijk(jz,2),3)-
         -    b(ijk(jz,1),3)*b(ijk(jz,2),2)
            b(jz,2)=b(ijk(jz,1),3)*b(ijk(jz,2),1)-
         -    b(ijk(jz,1),1)*b(ijk(jz,2),3)
            b(jz,3)=b(ijk(jz,1),1)*b(ijk(jz,2),2)-
         -    b(ijk(jz,1),2)*b(ijk(jz,2),1)
            a(iz,1)=a(ijk(iz,1),2)*a(ijk(iz,2),3)-
         -    a(ijk(iz,1),3)*a(ijk(iz,2),2)
            a(iz,2)=a(ijk(iz,1),3)*a(ijk(iz,2),1)-
         -    a(ijk(iz,1),1)*a(ijk(iz,2),3)
            a(iz,3)=a(ijk(iz,1),1)*a(ijk(iz,2),2)-
         -    a(ijk(iz,1),2)*a(ijk(iz,2),1)
            b(iz,1)=b(ijk(iz,1),2)*b(ijk(iz,2),3)-
         -    b(ijk(iz,1),3)*b(ijk(iz,2),2)
            b(iz,2)=b(ijk(iz,1),3)*b(ijk(iz,2),1)-
         -    b(ijk(iz,1),1)*b(ijk(iz,2),3)
            b(iz,3)=b(ijk(iz,1),1)*b(ijk(iz,2),2)-
         -    b(ijk(iz,1),2)*b(ijk(iz,2),1)
          end if
          if (LEVTEST .gt. 0) then
            write (LEVTEST,*) "diag: ",diag
            write (LEVTEST,*) "mu: ",rmu
          end if
          if (LEVTEST .gt. 0) then
            write (LEVTEST,1000) "a",a
            write (LEVTEST,1000) "b",b
          end if
          do k=1,3
            do l=1,3
              sm=0.0
              do m=1,3
                sm=sm+b(m,k)*a(m,l)
              end do
              rot(k,l)=sm
            end do
          end do
          if (LEVTEST .gt. 0) write (LEVTEST,1000) "rot",rot
          call check_rotmat(rot,'KABSCH',6,ifail,LEVTEST)
          if (ifail .gt. 0) write (6,1002) diag,rmu
          return
    1000  format(' BESTOV ',a,/,(3f16.7))
    1001  format(' BESTOV atwsum=',e15.7,' com1=',3f12.7,' com2=',3f12.7)
    1002  format(' BESTOV diag=',3e15.7,' mu=',3e15.7)
          end
          subroutine blockfromcum(bl,cum,xcum,n)
          real*8 cum,xcum,denom
          dimension bl(n),cum(n),xcum(n)
          if (n .lt. 1) return
          if (xcum(1) .eq. 0.d0) bl(1)=0.d0
          if (xcum(1) .ne. 0.d0) bl(1)=cum(1)/xcum(1)
          do i=2,n
            denom=xcum(i)-xcum(i-1)
            if (denom .eq. 0.d0) bl(i)=bl(i-1)
            if (denom .ne. 0.d0) bl(i)=(cum(i)-cum(i-1))/denom
          end do
          return
          end
          subroutine batchmean(npts,nskip,u,label,llabel,iout,nopr,avg,sd,
         -  ci)
          character*(*) label
          dimension u(npts)
          parameter (MAXSORT=128)
          common /sortsat/ ixdat(MAXSORT),dat(MAXSORT),datsort(MAXSORT),
         -  ifst(MAXSORT),ilst(MAXSORT),itemp(MAXSORT),temp(MAXSORT)
          real*8 datsum,datsum2
          dimension nmncrt(20,20),nmxcrt(20,20)
          character*12 uncorr,corr,low,decide
          data uncorr/'Uncorrelated'/,corr/'Correlated  '/,
         -  low/' ???        '/
          data nmncrt/20*0,
         -  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2,
         -  0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3,
         -  0, 0, 0, 0, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4,
         -  0, 0, 0, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5,
         -  0, 0, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 6, 6,
         -  0, 0, 2, 2, 3, 3, 3, 4, 4, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6,
         -  0, 0, 2, 3, 3, 3, 4, 4, 5, 5, 5, 6, 6, 6, 6, 6, 7, 7, 7, 7,
         -  0, 0, 2, 3, 3, 4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8,
         -  0, 0, 2, 3, 3, 4, 5, 5, 5, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 9,
         -  0, 0, 2, 3, 4, 4, 5, 5, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 9,
         -  0, 2, 2, 3, 4, 4, 5, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9,10,10,
         -  0, 2, 2, 3, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 9,10,10,10,10,
         -  0, 2, 2, 3, 4, 5, 5, 6, 7, 7, 8, 8, 9, 9, 9,10,10,10,11,11,
         -  0, 2, 3, 3, 4, 5, 6, 6, 7, 7, 8, 8, 9, 9,10,10,11,11,11,12,
         -  0, 2, 3, 4, 4, 5, 6, 6, 7, 8, 8, 9, 9,10,10,11,11,11,12,12,
         -  0, 2, 3, 4, 4, 5, 6, 7, 7, 8, 9, 9,10,10,11,11,11,12,12,13,
         -  0, 2, 3, 4, 5, 5, 6, 7, 8, 8, 9, 9,10,10,11,11,12,12,13,13,
         -  0, 2, 3, 4, 5, 6, 6, 7, 8, 8, 9,10,10,11,11,12,12,13,13,13,
         -  0, 2, 3, 4, 5, 6, 6, 7, 8, 9, 9,10,10,11,12,12,13,13,13,14/
          data nmxcrt/60*0,
         -  0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         -  0, 0, 0, 9,10,10,11,11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         -  0, 0, 0, 9,10,11,12,12,13,13,13,13, 0, 0, 0, 0, 0, 0, 0, 0,
         -  0, 0, 0, 0,11,12,12,12,14,14,14,14,15,15,15, 0, 0, 0, 0, 0,
         -  0, 0, 0, 0,11,12,13,13,14,15,15,16,16,16,16,17,17,17,17,17,
         -  0, 0, 0, 0, 0,13,14,14,15,16,16,16,17,17,18,18,18,18,18,18,
         -  0, 0, 0, 0, 0,13,14,15,16,16,17,17,18,18,18,19,19,19,20,20,
         -  0, 0, 0, 0, 0,13,14,15,16,17,17,18,19,19,19,20,20,20,21,21,
         -  0, 0, 0, 0, 0,13,14,16,16,17,18,19,19,20,20,21,21,21,22,22,
         -  0, 0, 0, 0, 0, 0,15,16,17,18,19,19,20,20,21,21,22,22,23,23,
         -  0, 0, 0, 0, 0, 0,15,16,17,18,19,20,20,21,22,23,23,23,23,24,
         -  0, 0, 0, 0, 0, 0,15,16,18,18,19,20,21,22,22,23,23,24,24,25,
         -  0, 0, 0, 0, 0, 0, 0,17,18,19,29,21,21,22,23,23,24,25,25,25,
         -  0, 0, 0, 0, 0, 0, 0,17,18,19,20,21,22,23,23,24,25,25,26,26,
         -  0, 0, 0, 0, 0, 0, 0,17,18,19,20,21,22,23,24,25,25,26,26,27,
         -  0, 0, 0, 0, 0, 0, 0,17,18,29,21,22,23,23,24,25,26,26,27,27,
         -  0, 0, 0, 0, 0, 0, 0,17,18,20,21,22,23,25,25,26,26,27,27,28/
          if (nopr .eq. 0) write (iout,1001) label(1:llabel),npts,nskip
          sd2i=0.0
          ci=999.0
          n=npts-nskip
          if (n .lt. 2) return
          datsum=0.d0
          datsum2=0.d0
          do i=1,n
            datsum=datsum+u(i-nskip)
            datsum2=datsum2+u(i-nskip)**2
          end do
          avg=datsum/dfloat(n)
          sd=dsqrt(datsum2/dfloat(n)-(datsum/dfloat(n))**2)
          if (n .gt. MAXSORT) then
            lb=n/MAXSORT
            nb=MAXSORT
            do ib=1,nb
              datsum=0.d0
              do i=(ib-1)*lb+1,ib*lb
                datsum=datsum+u(i-nskip)
              end do
              dat(ib)=datsum/dfloat(lb)
            end do
            n=nb
          else
            do i=nskip+1,npts
              dat(i-nskip)=u(i)
            end do
          end if
          lenblk=1
          call blankout(decide,1,12)
          do while (n .ge. 4 .and. decide .ne. low)
            call indexit(ixdat,1,n,0)
            call trnsfr(datsort,dat,n)
            call mrgsrt(iout,ixdat,datsort,n,ifst,ilst,itemp,temp,n)
            if (mod(n,2) .eq. 1) then
              datmed=datsort(n/2+1)
            else
              datmed=(datsort(n/2)+datsort(n/2+1))/2.0
            end if
            Z=0.0
            nup=0
            ndown=0
            nrun=1
            rp=dat(1)-datmed
            do i=2,n
              if (rp*(dat(i)-datmed) .le. 0.0) nrun=nrun+1
              if (rp .gt. 0.0) nup=nup+1
              if (rp .le. 0.0) ndown=ndown+1
              rp=dat(i)-datmed
            end do
            if (mod(n,2) .eq. 1) nrun=nrun-1
            if (rp .gt. 0.0) nup=nup+1
            if (rp .le. 0.0) ndown=ndown+1
            if (ndown .eq. 0 .or. nup .eq. 0) then
              decide=low
            else if (max0(nup,ndown) .le. 20) then
              if (nmxcrt(ndown,nup) .eq. 0 .or.
         -        nmncrt(ndown,nup) .eq. 0) then
                decide=low
              else
                if (nrun .lt. nmncrt(ndown,nup) .or.
         -           nrun .gt. nmxcrt(ndown,nup)) then
                  decide=corr
                else
                  decide=uncorr
                end if
              end if
            else
              r=float(2*nup*ndown)/float(nup+ndown)+1
              s2=float(2*nup*ndown*(2*nup*ndown-nup-ndown))/
         -      float((nup+ndown)**2*(nup+ndown))
              z=(float(nrun)-r)/sqrt(s2)
              if (z .gt. 1.96) then
                decide=corr
              else
                decide=uncorr
              end if
            end if
            if (decide .eq. uncorr) then
              datsum=0.d0
              datsum2=0.d0
              do i=1,n
                datsum=datsum+dat(i)
                datsum2=datsum2+dat(i)**2
              end do
              avg=datsum/dfloat(n)
              sd=dsqrt(datsum2/dfloat(n)-(datsum/dfloat(n))**2)
              ci=sd/sqrt(float(n-1))    
            end if
            if (nopr .eq. 0) write (iout,1002)
         -    label(1:llabel),lenblk,nup,ndown,nrun,decide,ci,z
            if (ci .ne. 999.0) return
            do i=1,n/2
              dat(i)=(dat(2*i)+dat(2*i-1))/2.0
            end do
            n=n/2
            lenblk=2*lenblk
          end do
          return
    1001  format(/,1x,a8,' Number of data points=',i6,
         -  ' Number of data points skipped=',i4)
    1002    format(1x,a,' block size=',i9,' nup=',i3,' ndown=',i3,
         -    ' nrun=',i3,2x,a12,' CI(1s)=',f10.4,' Z=',f10.4)
          end
          subroutine savebitc(mapbit,ibitx,n,nbits,maxbit)
          dimension mapbit(maxbit),ibitx(n)
          iw=1
          ib=0
          ibb=0
          mapbi=0
          do i=1,n
            ib=ib+1
            ibb=ibb+1
            if (ibitx(ibb) .eq. 1) mapbi=ibset(mapbi,ib-1)
            if (ib .eq. nbits) then
              mapbit(iw)=mapbi
              iw=iw+1
              mapbi=0
              ib=0
            end if
          end do
          if (ib .gt. 0) mapbit(iw)=mapbi
          return
          end
          subroutine readbitc(mapbit,ibitx,n,nbits,maxbit)
          dimension mapbit(maxbit),ibitx(n)
          nloops=(n-1)/nbits+1
          do il=1,nloops
            ibdone=(il-1)*nbits
            itodo=ibdone+min0(nbits,n-ibdone)
            mapbi=mapbit(il)
            do ib=ibdone+1,itodo
              ix=mapbi/2
              ibitx(ib)=mapbi-2*ix
              mapbi=ix
            end do
          end do
          return
          end
          subroutine dtqli(d,e,n,np,z,ierr)
          real*8 d(np),e(np),z(np,np)
          real*8 dd,r,g,s,c,p,f,b
          ierr=0
          if (n.gt.1) then
            do i=2,n
              e(i-1)=e(i)
            end do
            e(n)=0.d0
            do l=1,n
              iter=0
    1         do m=l,n-1
                dd=abs(d(m))+abs(d(m+1))
                if (e(m) .eq. 0.0) go to 2
                if (dd .ne. 0.0) then
                  if (abs(e(m))/dd .lt. 1.d-15) go to 2
                end if
              end do
              m=n
    2         if (m. ne. l) then
                if (iter .eq. 300) then
                  print *,'error: too many iterations in tqli'
                  ierr=1
                  return
                end if
                iter=iter+1
                g=(d(l+1)-d(l))/(2.d0*e(l))
                r=sqrt(g**2+1.d0)
                g=d(m)-d(l)+e(l)/(g+sign(r,g))
                s=1.d0
                c=1.d0
                p=0.d0
                do i=m-1,l,-1
                  f=s*e(i)
                  b=c*e(i)
                  if(abs(f).ge.abs(g))then
                    c=g/f
                    r=dsqrt(c**2+1.d0)
                    e(i+1)=f*r
                    s=1.d0/r
                    c=c*s
                  else
                    s=f/g
                    r=dsqrt(s**2+1.d0)
                    e(i+1)=g*r
                    c=1.d0/r
                    s=s*c
                  endif
                  g=d(i+1)-p
                  r=(d(i)-g)*s+2.d0*c*b
                  p=s*r
                  d(i+1)=g+p
                  g=c*r-b
                  do k=1,n
                    f=z(k,i+1)
                    z(k,i+1)=s*z(k,i)+c*f
                    z(k,i)=c*z(k,i)-s*f
                  end do
                end do
                d(l)=d(l)-p
                e(l)=g
                e(m)=0.d0
                go to 1
              endif
            end do
          endif
          return
          end
          subroutine dtred2(a,n,np,d,e)
          real*8 a(np,np),d(np),e(np)
          real*8 scale,h,f,g
          if (n .gt. 1) then
            do i=n,2,-1
              l=i-1
              h=0.d0
              scale=0.d0
              if (l. gt. 1) then
                do k=1,l
                  scale=scale+abs(a(i,k))
                end do
                if(scale.eq.0.)then
                  e(i)=a(i,l)
                else
                  do k=1,l
                    a(i,k)=a(i,k)/scale
                    h=h+a(i,k)**2
                  end do
                  f=a(i,l)
                  g=-sign(sqrt(h),f)
                  e(i)=scale*g
                  h=h-f*g
                  a(i,l)=f-g
                  f=0.
                  do j=1,l
                    a(j,i)=a(i,j)/h
                    g=0.
                    do k=1,j
                      g=g+a(j,k)*a(i,k)
                    end do
                    if (l .gt. j) then
                      do k=j+1,l
                        g=g+a(k,j)*a(i,k)
                      end do
                    end if
                    e(j)=g/h
                    f=f+e(j)*a(i,j)
                  end do
                  hh=f/(h+h)
                  do j=1,l
                    f=a(i,j)
                    g=e(j)-hh*f
                    e(j)=g
                    do k=1,j
                      a(j,k)=a(j,k)-f*e(k)-g*a(i,k)
                    end do
                  end do
                endif
              else
                e(i)=a(i,l)
              end if
              d(i)=h
            end do
          endif
          d(1)=0.d0
          e(1)=0.d0
          do i=1,n
            l=i-1
            if (d(i) .ne. 0.d0) then
              do j=1,l
                g=0.
                do k=1,l
                  g=g+a(i,k)*a(k,j)
                end do
                do k=1,l
                  a(k,j)=a(k,j)-g*a(k,i)
                end do
              end do
            endif
            d(i)=a(i,i)
            a(i,i)=1.d0
            if (l .ge. 1) then
              do j=1,l
                a(i,j)=0.d0
                a(j,i)=0.d0
              end do
            endif
          end do
          return
          end
          subroutine amoeba(p,y,mp,np,ndim,ftol,iter,c,cnew,ih,n,nnh,edge,
         -  ioppbc,cell,ncell,ixyzhex,rot,mintyp)
    C*****Numerical Recipes
          parameter (NMAX=20,ALPHA=1.0,BETA=0.5,GAMMA=2.0,ITMAX=200)
          dimension p(MP,NP),y(MP),pr(NMAX),prr(NMAX),pbar(NMAX)
          dimension c(3,n),cnew(3,n),ih(n),edge(3),cell(3,27),
         -  rot(3,3),ixyzhex(3)
          mpts=ndim+1
          iiter=0
    110   iter=0
    1     ilo=1
          if (y(1) .gt. y(2)) then
            ihi=1
            inhi=2
          else
            ihi=2
            inhi=1
          end if
          do i=1,mpts
            if (y(i) .lt. y(ilo)) ilo=i
            if (y(i) .gt. y(ihi)) then
              inhi=ihi
              ihi=i
            else if (y(i) .gt. y(inhi)) then
              if (i .ne. ihi) inhi=i
            end if
          end do
          rtol=2.0*abs(y(ihi)-y(ilo))/(abs(y(ihi))+abs(y(ilo)))
          if (rtol .lt. ftol) then
            call euler(rot,p(ilo,1),p(ilo,2),p(ilo,3))
            return
          end if
          if (iter .eq. itmax) then
            iiter=iiter+1
            if (iiter .gt. 2) then
              print *,'Too many resets'
              call euler(rot,p(ilo,1),p(ilo,2),p(ilo,3))
              return
            end if
            print *,'Reset ',iiter
            ybest=y(ilo)
            do i=1,3
              pr(i)=p(ilo,i)+i*0.05
              p(ihi,i)=pr(i)
            end do
            y(ihi)=touch(c,ih,n,nnh,edge,ioppbc,cell,ncell,ixyzhex,PR,
         -    rot,mintyp,0,cnew)
            go to 110
          end if
          iter=iter+1
          ylo=-y(ilo)
          if (mod(iter,10) .eq. 0) write (6,1010) iter,ylo,ftol
    1010  format(' --- Iteration',i4,' Objective function=',e15.8,' A',
         -  ' (tolerance=',f9.7,')')
          do j=1,ndim
            pbar(j)=0.0
          end do
          do i=1,mpts
            if (i .ne. ihi) then
              do j=1,ndim
                pbar(j)=pbar(j)+p(i,j)
              end do
            end if
          end do
          do j=1,ndim
            pbar(j)=pbar(j)/ndim
            pr(j)=(1.0+alpha)*pbar(j)-alpha*p(ihi,j)
          end do
          YPR=touch(c,ih,n,nnh,edge,ioppbc,cell,ncell,ixyzhex,PR,rot,
         -  mintyp,0,cnew)
          if (ypr .le. y(ilo)) then
            do j=1,ndim
              prr(j)=gamma*pr(j)+(1.0-gamma)*pbar(j)
            end do
            yprr=touch(c,ih,n,nnh,edge,ioppbc,cell,ncell,ixyzhex,PRR,rot,
         -  mintyp,0,cnew)
            if (yprr .lt. y(ilo)) then
              do j=1,ndim
                p(ihi,j)=prr(j)
              end do
              y(ihi)=yprr
            else
              do j=1,ndim
                p(ihi,j)=pr(j)
              end do
              y(ihi)=ypr
            end if
          else if (ypr .ge. y(inhi)) then
            if (ypr .lt. y(ihi)) then
              do j=1,ndim
                p(ihi,j)=pr(j)
              end do
              y(ihi)=ypr
            end if
            do j=1,ndim
              prr(j)=beta*p(ihi,j)+(1.-beta)*pbar(j)
            end do
            yprr=touch(c,ih,n,nnh,edge,ioppbc,cell,ncell,ixyzhex,PRR,
         -    rot,mintyp,0,cnew)
            if (yprr .lt. y(ihi)) then
              do j=1,ndim
                p(ihi,j)=prr(j)
              end do
              y(ihi)=yprr
            else
              ywrst=y(ihi)
              ncont=0
    240       continue
              ncont=ncont+1
              yw=-10000.0
              do i=1,mpts
                if (i .ne. ilo) then
                  do j=1,ndim
                    pr(j)=0.5*(p(i,j)+p(ilo,j))
                    p(i,j)=pr(j)
                  end do
                  y(i)=touch(c,ih,n,nnh,edge,ioppbc,cell,ncell,ixyzhex,PR,
         -          rot,mintyp,0,cnew)
                  if (y(i) .gt. yw) yw=y(i)
                endiF
              end do
              if (yw-ywrst .gt. ftol .and. ncont .lt. 5) go to 240
            end if
          else
            do j=1,ndim
              p(ihi,j)=pr(j)
            end do
            y(ihi)=ypr
          end if
          go to 1
          end
          subroutine lubksb(a,n,np,indx,b)
          real a(np,np),b(n)
          integer indx(n)
          ii=0
          do 12 i=1,n
            ll=indx(i)
            sum=b(ll)
            b(ll)=b(i)
            if (ii.ne.0) then
              do 11 j=ii,i-1
                sum=sum-a(i,j)*b(j)
    11        continue
            else if (sum.ne.0.) then
              ii=i
            end if
            b(i)=sum
    12    continue
          do 14 i=n,1,-1
            sum=b(i)
            if (i.lt.n) then
              do 13 j=i+1,n
                sum=sum-a(i,j)*b(j)
    13        continue
            end if
            b(i)=sum/a(i,i)
    14    continue
          return
          end
          subroutine ludcmp(a,n,np,indx,d)
          parameter (NMAX=100,TINY=1.0e-20)
          real a(np,np),vv(nmax)
          integer indx(n)
          data imax /0/
          d=1.
          do 12 i=1,n
            aamax=0.
            do 11 j=1,n
              if (abs(a(i,j)).gt.aamax) aamax=abs(a(i,j))
    11      continue
            if (aamax.eq.0.) write(*,*) 'Oops, singular matrix!'
            vv(i)=1./aamax
    12    continue
          do 19 j=1,n
            if (j.gt.1) then
              do 14 i=1,j-1
                sum=a(i,j)
                if (i.gt.1) then
                  do 13 k=1,i-1
                    sum=sum-a(i,k)*a(k,j)
    13            continue
                  a(i,j)=sum
                end if
    14        continue
            end if
            aamax=0.
            do 16 i=j,n
              sum=a(i,j)
              if (j.gt.1) then
                do 15 k=1,j-1
                  sum=sum-a(i,k)*a(k,j)
    15          continue
                a(i,j)=sum
              end if
              dum=vv(i)*abs(sum)
              if (dum.ge.aamax) then
                imax=i
                aamax=dum
              end if
    16      continue
            if (j.ne.imax) then
              do 17 k=1,n
                dum=a(imax,k)
                a(imax,k)=a(j,k)
                a(j,k)=dum
    17        continue
              d=-d
              vv(imax)=vv(j)
            end if
            indx(j)=imax
            if (j.ne.n) then
              if (a(j,j).eq.0.)a(j,j)=tiny
              dum=1./a(j,j)
              do 18 i=j+1,n
                a(i,j)=a(i,j)*dum
    18        continue
            end if
    19    continue
          if (a(n,n).eq.0.) a(n,n)=tiny
          return
          end
          subroutine datprt(iout,version,iprtver,mark,lmark,
         -  hostname,lhostname,iheadnode,ihostonly)
          use iflport
          character*8 version
          character*(*) mark
          character*100 hostname
          character*12 today
          common /today_date/ ltoday,today
    C@AB      dimension idayspm(12)
          integer idtvalue(8),lmonths(12)
    C@AB      character*8 date_dat
    C@AB      character*10 time_dat
    C@AB      character*5 zone_dat
          character*8 date_dat
          character*10 time_dat
          character*5 zone_dat
    C@G7      character*3 mon
    C@G7      character*24 adate
    C@G7      external fdate
    C@G7      external etime
    C@UG      character*24 fdate
    C@UG      external fdate
    C@AX      character*24 fdate_
    C@AX      external fdate_
    C@HP      character*24 fdate
    C@HP      external fdate
          character*5 months(12)
          data months/'Jan.','Feb.','March','April','May','June',
         -   'July','Aug.','Sep.','Oct.','Nov.','Dec.'/
          data lmonths /4,4,5,5,3,7*4/
    C@AB      data idayspm /31,28,31,30,31,30,31,31,30,31,30,31/
          lhostname=0
          iheadnode=0
          call blankout(hostname,1,100)
    C@AB      call getenv('HOST',VALUE=hostname)
    C@UG      call getenv('HOST',hostname)
    C@G7      call getenv('HOST',hostname)
          istat=hostnam(hostname)
          call lastchar(hostname,lhostname,100)
          if (lhostname .gt. 0) then
            if (hostname(1:lhostname) .eq. 'minerva2' .or.
         -      hostname(1:lhostname) .eq. 'login1') iheadnode=1
          else
            iheadnode=-1
          end if
          if (ihostonly .eq. 1) return
          if (iprtver .eq. 1) write (iout,1000) mark(1:lmark),version
          call zeroiti(idtvalue,0,8)
          ltoday=0
          ief=0
          ief=1
          iab=0
    C@AB      iab=1
    C@UX      call system('date')
    C@UG      write (iout,1008) mark(1:lmark),fdate()
    C@AX      write (iout,1008) mark(1:lmark),fdate_()
    C@G7      call fdate(adate)
    C@G7      read (adate,1012) mon,iday,ihour,imin,isec,iyear
    C@G7      write (iout,1018) mark(1:lmark),mon,iday,iyear
    C@G7      write (today,1002) mon,iday,iyear
    C@G7      ltoday=12
    C@G7      write (iout,1011) mark(1:lmark),ihour,imin,isec
          if (ief+iab .gt. 0) then
            call date_and_time(date_dat,time_dat,zone_dat,idtvalue)
    C@AB        call date_and_time(date_dat,time_dat,zone_dat,idtvalue)
            write (iout,1009) mark(1:lmark),
         -    months(idtvalue(2))(1:lmonths(idtvalue(2))),idtvalue(3),
         -    idtvalue(1)
            write (iout,1011) mark(1:lmark),idtvalue(5),idtvalue(6),
         -    idtvalue(7)
            write (today,1001) idtvalue(2),idtvalue(3),idtvalue(1)
            ltoday=10
            do ic=1,ltoday
              if (today(ic:ic).eq. ' ') today(ic:ic)='0'
            end do
          end if
          return
    1000  format(a,'SIMULAID Version: ',a)
    1001  format(i2,'/',i2,'/',i4)
    C@G71002  format(a3,' ',i2,', ',i4)
    C@UG1008  format(a,'Date: ',a)
    C@AX1008  format(a,'Date: ',a)
    1009  format(a,'Date: ',a,i3,', ',i4)
    1011  format(a,'Time:',i5,' hours,',i3,' minutes,',i3,' seconds')
    C@G71012  format(4x,a3,4(1x,i2),1x,i4)
    C@G71018  format(a,'Date: ',a3,1x,i2,', ',i4)
          end
          subroutine testconst(izero,ione,itwo,fzero,fone,ftwo,iout,nfail,
         -  initfail,lab)
          character*4 lab
          if (initfail .gt. 0) nfail=0
          if (itwo+itwo .ne. itwo*itwo .or. itwo+itwo .eq. itwo) then
            nfail=nfail+1
            write (iout,1000) lab,'integer two'
          end if
          if (ftwo+ftwo .ne. ftwo*ftwo .or. ftwo+ftwo .eq. ftwo) then
            nfail=nfail+1
            write (iout,1000)lab, 'float two'
          end if
          if (ione+ione .eq. ione .or. ione*ione .ne. ione) then
            nfail=nfail+1
            write (iout,1000) lab,'integer one'
          end if
          if (fone+fone .eq. ione .or. fone*fone .ne. fone) then
            nfail=nfail+1
            write (iout,1000) lab,'float one'
          end if
          if (izero+izero .ne. izero .or. izero*izero .ne. izero) then
            nfail=nfail+1
            write (iout,1000) lab,'integer zero'
          end if
          if (fzero+fzero .ne. fzero .or. fzero*fzero .ne. fzero) then
            nfail=nfail+1
            write (iout,1000) lab,'float zero'
          end if
          return
    1000  format(' ***** PROGRAM ERROR at ',a,': Internal constant ',a,
         -  ' is corrupted')
          end
          subroutine length_test_check(lentest_ok,iout)
          dimension icntrl(21)
          lentest_ok=1
          call indexit(icntrl,1,20,0)
          open(unit=10,status="new",file='intel_test',form="unformatted",
         -  iostat=iopenok)
          if (iopenok .gt. 0) open(unit=10,status="old",file='intel_test',
         -   form="unformatted",err=100)
          write (10) (icntrl(i),i=1,20)
          write (10) 100
          close (10)
          open(unit = 10 , status = "OLD" , file = 'intel_test',
         -   form="UNFORMATTED" , ERR = 100)
          icntrl(21)=-999
          read(10,end=200,err=200) icntrl
    200   if (icntrl(21) .ne. -999) then
            write (iout,*) 'NOTE: record length checks will be skipped'
            lentest_ok=0
          end if
          close (10,status='delete')
          return
    100   print *,'PROGRAM ERROR: could not open file intel_test'
          return
          end
          subroutine explanation(ihelp,itip)
          character*60 answers,tips
          common /helplist/ init,maxans,answers(1000),
         -  linelen(1000),ifl(1000),ill(1000)
          common /tiplist/ initt,maxtips,tips(100),
         -  linelent(100),iflt(100),illt(100)
          idebug=0
          if (init .eq. 0) then
            nhelp=0
            init=1
            do il=1,maxans
              call lastchar(answers(il),ilc,60)
              linelen(il)=ilc
              if (answers(il)(1:4) .eq. '****') then
                if (nhelp .gt. 0) ill(nhelp)=il-1
                if (ilc .eq. 4) go to 100
                nhelp=nhelp+1
                read (answers(il)(5:ilc),*,err=300) ih
                if (ih .ne. nhelp) go to 300
                ifl(nhelp)=il+1
              end if
            end do
    100     if (idebug .gt. 0) then
              do i=1,nhelp
                print *,'i,ifl,ill=',i,ifl(i),ill(i)
                do ip=ifl(i),ill(i)
                  print *,'ip,len=',ip,linelen(ip)
                  print *,answers(ip)(1:linelen(ip))
                end do
              end do
            end if
            maxans=nhelp
          end if
          if (initt .eq. 0) then
            ntips=0
            initt=1
            do il=1,maxtips
              call lastchar(tips(il),ilc,60)
              linelent(il)=ilc
              if (tips(il)(1:4) .eq. '****') then
                if (ntips .gt. 0) illt(ntips)=il-1
                if (ilc .eq. 4) go to 200
                ntips=ntips+1
                read (tips(il)(5:ilc),*,err=300) it
                if (it .ne. ntips) go to 300
                iflt(ntips)=il+1
              end if
            end do
    200     continue
            maxtips=ntips
          end if
          if (ihelp .gt. maxans) then
            print *,'PROGRAM ERROR: invalid help number=',ihelp
            ihelp=0
          end if
          if (itip .gt. maxtips) then
            print *,'PROGRAM ERROR: invalid tip number=',itip
            itip=0
          end if
          if (ihelp .gt. 0) write (6,1000)
         -   (answers(i)(1:linelen(i)),i=ifl(ihelp),ill(ihelp))
          if (itip .gt. 0) write (6,1000)
         -   (tips(i)(1:linelent(i)),i=iflt(itip),illt(itip))
          return
    300   print *,'Help data error: ',nhelp,'-th item is labeled ',ihelp
          return
    1000  format(5x,a)
          end
end module simulaid